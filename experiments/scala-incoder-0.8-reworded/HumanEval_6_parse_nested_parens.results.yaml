language: scala
name: HumanEval_6_parse_nested_parens
results:
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        // Keep track of deepest nesting level encountered so far\n     \
    \   var max_level = 0\n        var max_level_so_far = 0\n\n        // Track the\
    \ groups which belong to the current level of nesting\n        var group_stack\
    \ : List[List[String]] = Nil\n\n        // Iterate over each of the parenthesis\
    \ groups and push them to the stack\n        for (char_index <- paren_string.indices)\
    \ {\n            if (paren_string(char_index) == '(') {\n                // Push\
    \ the current group to the stack\n                group_stack ::= Nil\n      \
    \          group_stack ::= paren_string.substring(char_index).split(\" \")\n \
    \           }\n            else if (paren_string(char_index) == ')') {\n     \
    \           // Increment the number of levels encountered\n                max_level\
    \ += 1\n                // If this is the deepest level, then pop off the stack\n\
    \                if (max_level > max_level_so_far) {\n                    max_level_so_far\
    \ = max_level\n                    max_level = group_stack.length\n          \
    \          // If there are no more levels of nesting, then break out of the for\
    \ loop\n                    if (max_level == 0) break\n                }\n\n \
    \               // Pop the current group\n                group_stack = group_stack.reverse\n\
    \            }\n        }\n\n        // Return the group list with the deepest\
    \ level added to the top\n        return max_level_so_far :: group_stack.reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpy3v1dja8.scala:22:28 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m                group_stack ::= paren_string.substring(char_index).split(\e\
    [31m\" \"\e[0m)\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mvalue ::= is not a member of List[List[String]] - did you mean List[List[String]].::?\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpy3v1dja8.scala:32:40 ------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m                    \e[33mif\e[0m (max_level == \e[31m0\e\
    [0m) break\n\e[31m\e[31m   |\e[0m                                        ^^^^^\e\
    [0m\n\e[31m   |\e[0m                                        Not found: break\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpy3v1dja8.scala:41:15\
    \ --------------------\e[0m\e[0m\n\e[31m41 |\e[0m        \e[33mreturn\e[0m max_level_so_far\
    \ :: group_stack.reverse\n\e[31m\e[31m   |\e[0m               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m               Found:    List[Matchable]\n\e[31m   |\e[0m\
    \               Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660029146
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_levels = paren_string.splitAsStream(\")\").toList.toMap\n\
    \        val paren_levels_count = paren_levels.toList.map(_.size).max\n      \
    \  val paren_level_map = (0 until paren_levels_count) map { i => paren_levels(i)\
    \ }.toMap\n        paren_level_map.toList.flatMap { case (parent, children) =>\
    \ children.map(paren_level_map(parent)).max }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpqhf_pur8.scala:10:40 ------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e[36mparen_levels\e[0m = paren_string.splitAsStream(\e\
    [31m\")\"\e[0m).toList.toMap\n\e[31m\e[31m   |\e[0m                          \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                           value\
    \ splitAsStream is not a member of String\n\e[31m\e[31m-- [E081] Type Error: /tmp/tmpqhf_pur8.scala:12:65\
    \ -----------------------------\e[0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e\
    [0m \e[36mparen_level_map\e[0m = (\e[31m0\e[0m until paren_levels_count) map {\
    \ \e[36mi\e[0m => paren_levels(i) }.toMap\n\e[31m\e[31m   |\e[0m             \
    \                                                    ^\e[0m\n\e[31m   |\e[0m \
    \                         Missing parameter type\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m                          I could not infer the type of the parameter i.\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpqhf_pur8.scala:13:77 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        paren_level_map.toList.flatMap { \e[33mcase\e\
    [0m (parent, children) => children.map(paren_level_map(parent)).max }\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \    ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue map is not a member of Nothing, but\
    \ could be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mOne of the following imports might fix the problem:\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m  import Option.option2Iterable\n\e[31m   |\e[0m  import collection.LazyZip2.lazyZip2ToIterable\n\
    \e[31m   |\e[0m  import collection.LazyZip3.lazyZip3ToIterable\n\e[31m   |\e[0m\
    \  import collection.LazyZip4.lazyZip4ToIterable\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.list\
    \ asScalaBuffer\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.properties\
    \ AsScalaMap\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.enumeration\
    \ AsScalaIterator\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.iterator\
    \ asScala\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.map\
    \ AsScalaConcurrentMap\n\e[31m "
  stdout: ''
  timestamp: 1660029149
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        var paren_count = 0\n        var deepest_level = 0\n        var deepest_level_stack\
    \ = List[Long](1l.toLong)\n        paren_string.split(\" \").foreach{ string =>\
    \ {\n            if(string.equals(\"(\")) {\n                paren_count += 1\n\
    \            }\n            if(string.equals(\")\")) {\n                paren_count\
    \ -= 1\n            }\n            if(string.equals(\"(\") && paren_count > 0)\
    \ {\n                deepest_level_stack = deepest_level_stack + (deepest_level_stack.length\
    \ - 1)\n            }\n            if(string.equals(\")\") && paren_count < 0)\
    \ {\n                deepest_level_stack = deepest_level_stack.dropRight(1)\n\
    \            }\n            if(string.equals(\")\")) {\n                if(deepest_level_stack.length\
    \ > 0) {\n                    deepest_level = deepest_level_stack\n          \
    \          deepest_level_stack = List[Long]()\n                }\n           \
    \ }\n        }}\n        if(deepest_level.length > 0) {\n            deepest_level\
    \ = deepest_level.dropRight(1)\n        }\n        val deepest_level_long_array:\
    \ Array[Long] = deepest_level.map { el => el.toLong }\n        return deepest_level_long_array\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmposg35nca.scala:21:58 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m                deepest_level_stack = deepest_level_stack\
    \ + (deepest_level_stack.length - \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m       \
    \                               ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ + is not a member of List[Long], but could be made available as an extension\
    \ method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might\
    \ make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e[0m  import\
    \ math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import math.Numeric.Implicits.infixNumericOps\n\
    \e[31m   |\e[0m\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmposg35nca.scala:28:36\
    \ --------------------\e[0m\e[0m\n\e[31m28 |\e[0m                    deepest_level\
    \ = deepest_level_stack\n\e[31m\e[31m   |\e[0m                               \
    \     ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                            Found:\
    \    (deepest_level_stack : List[Long])\n\e[31m   |\e[0m                     \
    \       Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmposg35nca.scala:33:25\
    \ ------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mif\e[0m(deepest_level.length\
    \ > \e[31m0\e[0m) {\n\e[31m\e[31m   |\e[0m           ^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m           value length is not a member of Int\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmposg35nca.scala:34:42 ------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m            deepest_level = deepest_level.dropRight(\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m                            ^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                            value dropRight is not a member\
    \ of Int\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmposg35nca.scala:36:66\
    \ ------------------------\e[0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e\
    [36mdeepest_level_long_array\e[0m: \e[35mArray\e[0m[\e[35mLong\e[0m] = deepest_level.map\
    \ { \e[36mel\e[0m => el"
  stdout: ''
  timestamp: 1660029149
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_stack_map : mutable.Map[String,mutable.Set[String]] = mutable.Map.empty\n\
    \        paren_string.split(\"\\\\s+\").map(x => {\n            val xs = x.split(\"\
    \\\\(\").map(y => y.trim()).drop(1)\n            val ys = x.split(\"\\\\)\").map(y\
    \ => y.trim()).drop(1)\n            paren_stack_map += x -> (paren_stack_map.getOrElse(x,\
    \ mutable.Set.empty).union(ys))\n        }).reduce(_ ++ _).map(x => (paren_stack_map(x)).max)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp6rj8v7se.scala:10:30 ------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e[36mparen_stack_map\e[0m : mutable.Map[\e\
    [35mString\e[0m,mutable.Set[\e[35mString\e[0m]] = mutable.Map.empty\n\e[31m\e\
    [31m   |\e[0m                              ^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                         Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp6rj8v7se.scala:10:72 ------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e[36mparen_stack_map\e[0m : mutable.Map[\e\
    [35mString\e[0m,mutable.Set[\e[35mString\e[0m]] = mutable.Map.empty\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \        ^^^^^^^\e[0m\n\e[31m   |\e[0m                                       \
    \               Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- Error: /tmp/tmp6rj8v7se.scala:15:10\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m15 |\e[0m       \
    \ }).reduce(_ ++ _).map(x => (paren_stack_map(x)).max)\n\e[31m\e[31m   |\e[0m\
    \          ^\e[0m\n\e[31m   |\e[0m          No ClassTag available for B\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m          where:    B is a type variable\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660029145
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        var max_nesting_level = 0\n        var max_nesting_level_group =\
    \ 0\n        paren_string.split(\"( +)\").foreach(f => {\n            val groups\
    \ = f.replaceAll(\"( +)\", \"$1 \").replaceAll(\"^ $\", \"\")\n            val\
    \ group_list = groups.split(\" +\").map(f => {\n                val chars = f.toCharArray\n\
    \                val count = chars.length\n                val count = chars.map(f\
    \ => f.toInt).sum\n                val count_l = new mutable.LongAccumulator[Int](0)\n\
    \                chars.foreach(f => {\n                    count_l.add(f.toInt)\n\
    \                })\n                count_l.value\n            })\n         \
    \   val level = group_list.max\n            if (level > max_nesting_level) {\n\
    \                max_nesting_level = level\n                max_nesting_level_group\
    \ = groups\n            }\n        })\n        (max_nesting_level_group).map(f\
    \ => f.toLong)\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpdihseqa4.scala:17:20 ---------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m                \e[33mval\e[0m \e[36mcount\e[0m = chars.map(\e\
    [36mf\e[0m => f.toInt).sum\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mcount is already defined as \e[33mvalue\e[0m \e[35mcount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E006] Not\
    \ Found Error: /tmp/tmpdihseqa4.scala:18:34 ------------------------\e[0m\e[0m\n\
    \e[31m18 |\e[0m                \e[33mval\e[0m \e[36mcount_l\e[0m = \e[33mnew\e\
    [0m mutable.LongAccumulator[\e[35mInt\e[0m](\e[31m0\e[0m)\n\e[31m\e[31m   |\e\
    [0m                                  ^^^^^^^\e[0m\n\e[31m   |\e[0m           \
    \                       Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- Error:\
    \ /tmp/tmpdihseqa4.scala:23:14 -----------------------------------------\e[0m\e\
    [0m\n\e[31m23 |\e[0m            })\n\e[31m\e[31m   |\e[0m              ^\e[0m\n\
    \e[31m   |\e[0m              No ClassTag available for B\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m              where:    B is a type variable\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpdihseqa4.scala:27:42 --------------------\e[0m\e\
    [0m\n\e[31m27 |\e[0m                max_nesting_level_group = groups\n\e[31m\e\
    [31m   |\e[0m                                          ^^^^^^\e[0m\n\e[31m   |\e\
    [0m                                          Found:    (groups : String)\n\e[31m\
    \   |\e[0m                                          Required: Int\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpdihseqa4.scala:30:34 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        (max_nesting_level_group).map(\e[36mf\e[0m =>\
    \ f.toLong)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m        value map is not a member of Int\n5 errors found\n"
  stdout: ''
  timestamp: 1660029148
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        var parentheses_depth = 0\n        var parentheses_levels : List[Long]\
    \ = List.empty\n        var parenthese_groups = List.empty\n        var parentheses_groups\
    \ : List[List[String]] = List.empty\n        paren_string.split(\"\\\\s+\").foreach\
    \ {\n            element => {\n                parentheses_groups = if (element\
    \ == \"(\") parenthese_groups else parenthese_groups \n                parentheses_groups\
    \ += List (element)\n            }\n        }\n\n        for (parentheses_group\
    \ <- parentheses_groups) {\n            if (parentheses_group.length == 1) {\n\
    \                parentheses_groups += List(parentheses_group)\n            }\n\
    \        }\n\n        for ((parentheses_group <- parentheses_groups) {\n     \
    \       parentheses_group.reduce { case (acc, element) => (parentheses_depth *\
    \ parentheses_levels , acc.length + element.length) }\n        }\n\n        parentheses_groups\
    \ = parentheses_groups.reverse\n        parentheses_groups.map { l => l.reduce\
    \ { case (acc, element) => acc.max } }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpew356by1.scala:27:32 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mfor\e[0m ((parentheses_group <- parentheses_groups)\
    \ {\n\e[31m\e[31m   |\e[0m                                ^^\e[0m\n\e[31m   |\e\
    [0m                                ')' expected, but '<-' found\n\e[31m\e[31m--\
    \ [E040] Syntax Error: /tmp/tmpew356by1.scala:27:55 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mfor\e[0m ((parentheses_group <- parentheses_groups)\
    \ {\n\e[31m\e[31m   |\e[0m                                                   \
    \    ^\e[0m\n\e[31m   |\e[0m                                            '<-' expected,\
    \ but '{' found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpew356by1.scala:17:35\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m                parentheses_groups\
    \ += List (element)\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue += is not a member of List[List[String]] - did you mean\
    \ List[List[String]].!=?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpew356by1.scala:23:35\
    \ ------------------------\e[0m\e[0m\n\e[31m23 |\e[0m                parentheses_groups\
    \ += List(parentheses_group)\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue += is not a member of List[List[String]] - did you mean\
    \ List[List[String]].!=?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpew356by1.scala:32:83\
    \ ------------------------\e[0m\e[0m\n\e[31m32 |\e[0m        parentheses_groups.map\
    \ { \e[36ml\e[0m => l.reduce { \e[33mcase\e[0m (acc, element) => acc.max } }\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                           ^\e[0m\n\e[31m   |\e[0mvalue foreach is not a member\
    \ of Null, but could be made available as an extension method.\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mOne of the following imports might fix the problem:\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m  import Option.option2Iterable\n\e[31m   |\e[0m  import collection.LazyZip2.lazyZip2ToIterable\n\
    \e[31m   |\e[0m  import collection.LazyZip3.lazyZip3ToIterable\n\e[31m   |\e[0m\
    \  import collection.LazyZip4.lazyZip4ToIter"
  stdout: ''
  timestamp: 1660029149
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n      paren_string.grouped(2)\n      .flatMap( _ => paren_string.grouped(2)\
    \ )\n      .flatMap( _ => paren_string.grouped(3) )\n      .map(_.toList.size)\n\
    \  }\n}\n\nval paren_string =\n\"\"\"\n  ((((()))))\n\"\"\"\nval list: List[Long]\
    \ = Problem.parseNestedParens(paren_string)\n\nval max_list = list.max\n\nval\
    \ max_str_1 = paren_string.split(\"( )\").max\n\nval max_str_2 = paren_string.grouped(2).flatMap(_.grouped(2)).flatMap(_.grouped(3)).map(_.toList.size).max\n\
    \nval max_str_3 = paren_string.grouped(3).flatMap(_.grouped(3)).flatMap(_.grouped(3)).map(_.toList.size).max\n\
    \nval max_str_4 = paren_string.grouped(2).flatMap(_.grouped(2)).flatMap(_.grouped(2)).flatMap(_.grouped(2)).flatMap(_.grouped(2)).flatMap(_.grouped(2)).flatMap(_.grouped(2)).flatMap(_.grouped(2)).flatMap(_.grouped(2)).flatMap(_.grouped(2)).flatMap(_.grouped(2)).flatMap(_.grouped(2)).flatMap(_.grouped(2)).flatMap(_.grouped(2)).flatMap(_.grouped(2)).flatMap(_.grouped(2)).flatMap(_.grouped(2)).flatMap(_.grouped(2)).flatMap(_.grouped(2)).flatMap(_.grouped(2)).flatMap(_.grouped(2)).flatMap(_.grouped(2)).flatMap(_.grouped(2)).flatMap(_.grouped(2)).flatMap(_.grouped(2)).flatMap(_.grouped(2)).flatMap(_.grouped(2)).flatMap(_.grouped(2)).flatMap(_.grouped(2)).flatMap(_.grouped(2)).flatMap(_.grouped(2)).flatMap(_.grouped(2)).flatMap(_.grouped(2)).flatMap(_.grouped(2)).flatMap(_.grouped(2)).flatMap(_.grouped(2)).flatMap(_.grouped(2)).flatMap(_.grouped(2)).flatMap(_.grouped(2)).flatMap(_.grouped(2)).flatMap(_.grouped(2)).flatMap(_.grouped(2)).flatMap(_.grou\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpanys5uc4.scala:32:4 ----------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpanys5uc4.scala:13:10 --------------------\e[0m\e[0m\n\e[31m10 |\e[0m\
    \      paren_string.grouped(\e[31m2\e[0m)\n\e[31m11 |\e[0m      .flatMap( _ =>\
    \ paren_string.grouped(\e[31m2\e[0m) )\n\e[31m12 |\e[0m      .flatMap( _ => paren_string.grouped(\e\
    [31m3\e[0m) )\n\e[31m13 |\e[0m      .map(_.toList.size)\n\e[31m\e[31m   |\e[0m\
    \      ^\e[0m\n\e[31m   |\e[0m      Found:    Iterator[Int]\n\e[31m   |\e[0m \
    \     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpanys5uc4.scala:31:952 -----------------------\e[0m\e[0m\n\e[31m31 |\e\
    [0m\e[33mval\e[0m \e[36mmax_str_4\e[0m = paren_string.grouped(\e[31m2\e[0m).flatMap(_.grouped(\e\
    [31m2\e[0m)).flatMap(_.grouped(\e[31m2\e[0m)).flatMap(_.grouped(\e[31m2\e[0m)).flatMap(_.grouped(\e\
    [31m2\e[0m)).flatMap(_.grouped(\e[31m2\e[0m)).flatMap(_.grouped(\e[31m2\e[0m)).flatMap(_.grouped(\e\
    [31m2\e[0m)).flatMap(_.grouped(\e[31m2\e[0m)).flatMap(_.grouped(\e[31m2\e[0m)).flatMap(_.grouped(\e\
    [31m2\e[0m)).flatMap(_.grouped(\e[31m2\e[0m)).flatMap(_.grouped(\e[31m2\e[0m)).flatMap(_.grouped(\e\
    [31m2\e[0m)).flatMap(_.grouped(\e[31m2\e[0m)).flatMap(_.grouped(\e[31m2\e[0m)).flatMap(_.grouped(\e\
    [31m2\e[0m)).flatMap(_.grouped(\e[31m2\e[0m)).flatMap(_.grouped(\e[31m2\e[0m)).flatMap(_.grouped(\e\
    [31m2\e[0m)).flatMap(_.grouped(\e[31m2\e[0m)).flatMap(_.grouped(\e[31m2\e[0m)).flatMap(_.grouped(\e\
    [31m2\e[0m)).flatMap(_.grouped(\e[31m2\e[0m)).flatMap(_.grouped(\e[31m2\e[0m)).flatMap(_.grouped(\e\
    [31m2\e[0m)).flatMap(_.grouped(\e[31m2\e[0m)).flatMap(_.grouped(\e[31m2\e[0m)).flatMap(_.grouped(\e\
    [31m2\e[0m)).flatMap(_.grouped(\e[31m2\e[0m)).flatMap(_.grouped(\e[31m2\e[0m)).flatMap(_.grouped(\e\
    [31m2\e[0m)).flatMap(_.grouped(\e[31m2\e[0m)).flatMap(_.grouped(\e[31m2\e[0m)).flatMap(_.grouped(\e\
    [31m2\e[0m)).flatMap(_.grouped(\e[31m2\e[0m)).flatMap(_.grouped(\e[31m2\e[0m)).flatMap(_.grouped(\e\
    [31m2\e[0m)).fl"
  stdout: ''
  timestamp: 1660029147
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val ls = paren_string.split(\" \")\n        val parens = mutable.ListBuffer[Long]()\n\
    \        val levels = mutable.ListBuffer[Long]()\n        ls.foreach{ s =>\n \
    \           val opening_parens = s.headOption match {\n                case None\
    \ => 0\n                case Some('(') => 1\n                case Some(')')  =>\
    \ -1\n            }\n            val current_level = s.lastOption.getOrElse(0)\n\
    \            if (opening_parens > 0) {\n                parens += current_level\n\
    \                levels += current_level\n            } else {\n             \
    \   levels += current_level\n            }\n        }\n        levels.toList.max\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp0u6esao6.scala:11:21 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mparens\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp0u6esao6.scala:12:21 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mlevels\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660029138
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        var paren_count : Long = 0\n        var nested_list: List[Long] =\
    \ Nil\n        for(i <- 0 until paren_string.length){\n            val curr_p\
    \ = paren_string(i).asInstanceOf[String]\n            paren_count += 1\n     \
    \       nested_list += List(paren_count)\n            if(!paren_p.equals(\" \"\
    ) && paren_p.equals(\"(\")) {\n                val paren_count_left = nested_list(0)\n\
    \                val left_paren_len = if (paren_count_left < paren_count) paren_count_left\
    \ else paren_count\n                nested_list += left_paren_len + 1\n      \
    \      } else if(!paren_p.equals(\" \") && paren_p.equals(\")\")) {\n        \
    \        val paren_count_right = nested_list(nested_list.length - 1)\n       \
    \         val right_paren_len = if (paren_count_right < paren_count) paren_count_right\
    \ else paren_count\n                nested_list += right_paren_len + 1\n     \
    \       }\n        }\n        nested_list\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpj6fmaxoe.scala:15:24 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m            nested_list += List(paren_count)\n\e[31m\e\
    [31m   |\e[0m            ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    value += is not\
    \ a member of List[Long] - did you mean List[Long].!=?\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpj6fmaxoe.scala:16:16 ------------------------\e[0m\e\
    [0m\n\e[31m16 |\e[0m            \e[33mif\e[0m(!paren_p.equals(\e[31m\" \"\e[0m)\
    \ && paren_p.equals(\e[31m\"(\"\e[0m)) {\n\e[31m\e[31m   |\e[0m              \
    \  ^^^^^^^\e[0m\n\e[31m   |\e[0m                Not found: paren_p\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpj6fmaxoe.scala:19:28 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m                nested_list += left_paren_len + \e[31m1\e\
    [0m\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \    value += is not a member of List[Long] - did you mean List[Long].!=?\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpj6fmaxoe.scala:20:23 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m            } \e[33melse\e[0m \e[33mif\e[0m(!paren_p.equals(\e\
    [31m\" \"\e[0m) && paren_p.equals(\e[31m\")\"\e[0m)) {\n\e[31m\e[31m   |\e[0m\
    \                       ^^^^^^^\e[0m\n\e[31m   |\e[0m                       Not\
    \ found: paren_p\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpj6fmaxoe.scala:23:28\
    \ ------------------------\e[0m\e[0m\n\e[31m23 |\e[0m                nested_list\
    \ += right_paren_len + \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m    value += is not a member of List[Long] - did you mean\
    \ List[Long].!=?\n5 errors found\n"
  stdout: ''
  timestamp: 1660029148
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        paren_string.split(\" \").toList.groupBy(_.charAt(0)).toList.flatMap(_._2.toLong)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpl062y5n2.scala:10:80 ------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m        paren_string.split(\e[31m\" \"\e[0m).toList.groupBy(_.charAt(\e\
    [31m0\e[0m)).toList.flatMap(_._2.toLong)\n\e[31m\e[31m   |\e[0m              \
    \                                                             ^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mvalue toLong is not a member of List[String], but could be made\
    \ available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the\
    \ following imports might make progress towards fixing the problem:\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n1 error found\n"
  stdout: ''
  timestamp: 1660029148
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val strList = paren_string.split(\"\\\\s+\")\n        val lengthList\
    \ = strList.map(_.length).sorted\n        val parenList = strList.zip(lengthList).map({\
    \ case (s, l) => (s, l) })\n        val maxNestingLevel = parenList.length\n \
    \       val nestedParenthesisList = new scala.collection.mutable.ListBuffer[Long]()\n\
    \        val level = 0\n        var parenStack = new scala.collection.mutable.Stack[String]()\n\
    \        val openParen = parenStack.pop()\n        while(parenStack.nonEmpty)\
    \ {\n            val currentParen = parenStack.pop()\n            if(currentParen\
    \ == openParen) {\n                val parenStr = currentParen + \" \"\n     \
    \           val currentLevel = level\n                val newLevel = level + 1\n\
    \                while(newLevel < maxNestingLevel) {\n                    val\
    \ newLevelStr = s\"($currentLevel${openParen}${parenStr}) \"\n               \
    \     val nextParenStr = s\"${openParen}${parenStr} ($currentLevel${openParen}${parenStr})\"\
    \n                    val newParenStr = (currentLevel + openParen + parenStr)\n\
    \                    val newParenLength =\n                        parenList.map(p\
    \ => (p._2.toLong)).max(_.length).length\n                    nestedParenthesisList.add(newParenLength.toLong)\n\
    \                }\n                level += 1\n            }\n        }\n   \
    \     nestedParenthesisList.sortWith(_.length < _.length)\n        nestedParenthesisList.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E086] Syntax Error: /tmp/tmp7vf_lpek.scala:29:62 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m                        parenList.map(\e[36mp\e[0m =>\
    \ (p._2.toLong)).max(_.length).length\n\e[31m\e[31m   |\e[0m                 \
    \                                             ^^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \                                Wrong number of parameters, expected: 2\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp7vf_lpek.scala:30:42 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m                    nestedParenthesisList.add(newParenLength.toLong)\n\
    \e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m  value add is not a member of scala.collection.mutable.ListBuffer[Long]\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp7vf_lpek.scala:32:22 ------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m                level += \e[31m1\e[0m\n\e[31m\e[31m \
    \  |\e[0m                ^^^^^^^^\e[0m\n\e[31m   |\e[0m                value +=\
    \ is not a member of Int - did you mean level.!=?\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmp7vf_lpek.scala:35:41 ------------------------\e[0m\e[0m\n\e[31m35\
    \ |\e[0m        nestedParenthesisList.sortWith(_.length < _.length)\n\e[31m\e\
    [31m   |\e[0m                                       ^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                                    value length is not a member of Long\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1660029148
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val parens = paren_string.split(\"\\\\s*\\\\(\")\n        val parentheses_size\
    \ = parens.size\n        val maxLevel = parentheses_size.toInt\n        var level\
    \ = 1 // Starting level always one (root level).\n        var current = List(1l.toLong)\
    \ //The current level is 1.\n\n        for (paren <- parens) {\n            val\
    \ curLevel = paren.split(\"\\\\s*\\\\)\").length\n            if (curLevel < maxLevel)\
    \ {\n                current.add(level.toLong)\n                level = curLevel\
    \ + 1\n            } else if (curLevel == maxLevel) {\n                current\
    \ = current.reverse\n            }\n        }\n\n        return current.reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpppbdwtbv.scala:19:24 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m                current.add(level.toLong)\n\e[31m\e[31m\
    \   |\e[0m                ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                value\
    \ add is not a member of List[Long]\n1 error found\n"
  stdout: ''
  timestamp: 1660029145
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        var max_level = 0\n        var result = ListBuffer.empty[Long]\n\
    \        for (group <- paren_string.split(\" \").toList) {\n            if(paren_string.length()\
    \ < group.length) result.append(group.length)\n            else {\n          \
    \      if (group.substring(0, group.length) == paren_string) {\n             \
    \       if (group.substring(group.length) == paren_string) result.append(group.length)\n\
    \                    else result.append(1)\n                }\n              \
    \  else {\n                    if (group.substring(0, group.length) == paren_string)\
    \ result.append(group.length)\n                    else result.append((max_level\
    \ + 1))\n                    max_level = (max_level + 1)\n                }\n\
    \            }\n        }\n        val max_list_size = result.toList.sortBy(x\
    \ => x)\n        if (max_list_size.size > max_level) max_list_size.drop(max_level)\
    \ else max_list_size\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp0xgtd9a4.scala:30)\n\tat Problem.main(tmp0xgtd9a4.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660029149
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val parentheses = paren_string.split(\" \").toList\n        var paren_level\
    \ = 0\n        var highest_level = 0\n        var levels_of_nesting = 0\n\n  \
    \      for( parentheses <- parentheses ) {\n            if(parentheses.startsWith(\"\
    (\")) {\n                paren_level += 1\n            }\n            if(parentheses.endsWith(\"\
    )\")) {\n                paren_level -= 1\n            }\n            if(parentheses.startsWith(\"\
    (\") && paren_level == 0) {\n                levels_of_nesting += 1\n        \
    \    }\n            if(parentheses.endsWith(\")\") && paren_level == 1) {\n  \
    \              levels_of_nesting -= 1\n            }\n            if((parentheses.startsWith(\"\
    (\") && paren_level == 1) ||\n                (parentheses.endsWith(\")\") &&\
    \ paren_level == 0) ) {\n                highest_level = max(highest_level, levels_of_nesting)\n\
    \            }\n        }\n        parentheses.toList.flatMap(n => n.toLong).distinct\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpdcg6gdsd.scala:33:42\
    \ --------------------\e[0m\e[0m\n\e[31m33 |\e[0m        parentheses.toList.flatMap(\e\
    [36mn\e[0m => n.toLong).distinct\n\e[31m\e[31m   |\e[0m                      \
    \                  ^^^^^^^^\e[0m\n\e[31m   |\e[0m                            \
    \            Found:    Long\n\e[31m   |\e[0m                                 \
    \       Required: IterableOnce[Any]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660029146
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        // Convert the input string to list of characters and find the index\
    \ of matching parenthesis\n        val paren_chars = paren_string.toList\n   \
    \     val paren_char_index = paren_chars.indexWhere(_ == '(')\n        if (paren_char_index\
    \ == -1) return List[Long]()\n        val bracket_chars = paren_chars.take(paren_char_index\
    \ + 1)\n        val opening_paren_nesting_count = bracket_chars.count(_ == '(')\n\
    \        val closing_paren_nesting_count = bracket_chars.count(_ == ')')\n   \
    \     var deepest_nesting_count = 0\n        var deepest_level = 0\n        //\
    \ Loop through the parenthesis string and count the opening/closing bracket nesting\
    \ levels\n        paren_chars.reverseIterator.foreach { c =>\n            if (c\
    \ == '(') deepest_nesting_count += 1\n            if (c == ')') deepest_nesting_count\
    \ -= 1\n            if (deepest_nesting_count < deepest_level) deepest_level =\
    \ deepest_nesting_count\n        }\n        // Now we have the deepest level of\
    \ nesting for each parenthesis. If the deepest level matches the deepest level\n\
    \        // of the deepest parenthesis in the input string, that parenthesis is\
    \ the final parenthesis of the input\n        // string. So we return the count\
    \ of the levels that we found.\n        if (deepest_level == deepest_nesting_count)\
    \ List(deepest_level.toLong)\n        else List[Long]()\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"\
    () (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpu3nnlj58.scala:32)\n\tat Problem.main(tmpu3nnlj58.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660029149
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        // Your code goes here\n        val list = paren_string.split(\"\
    \ \")\n        var max_count = 0\n        var max_level = 0\n        var count_list\
    \ = new collection.mutable.ArrayList[Long]()\n        var current_level = List.empty[Long]\n\
    \        var count = 0\n        for( i <- 0 until list.size ) {\n            val\
    \ s = list(i)\n            if( s == \"(\" ) {\n                if( count > max_count\
    \ ) {\n                    max_count = count\n                    max_level =\
    \ current_level\n                }\n                count += 1\n             \
    \   current_level :+= 1\n                count_list :+= current_level.last\n \
    \           }\n            if( s == \")\" ) {\n                count -= 1\n  \
    \              if( count > max_count ) {\n                    max_count = count\n\
    \                    max_level = current_level\n                }\n          \
    \      current_level -= 1\n            }\n        }\n        return max_level.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmph_b8z75z.scala:14:48 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mvar\e[0m \e[36mcount_list\e[0m = \e[33mnew\e\
    [0m collection.mutable.ArrayList[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \              type ArrayList is not a member of scala.collection.mutable\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmph_b8z75z.scala:22:32 --------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m                    max_level = current_level\n\e[31m\e\
    [31m   |\e[0m                                ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                                Found:    (current_level : List[Long])\n\e\
    [31m   |\e[0m                                Required: Int\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmph_b8z75z.scala:32:32 --------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m                    max_level = current_level\n\e[31m\e\
    [31m   |\e[0m                                ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                                Found:    (current_level : List[Long])\n\e\
    [31m   |\e[0m                                Required: Int\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmph_b8z75z.scala:34:30 ------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m                current_level -= \e[31m1\e[0m\n\e[31m\e\
    [31m   |\e[0m                ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    value -=\
    \ is not a member of List[Long] - did you mean List[Long].!=?\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmph_b8z75z.scala:37:25 ------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33mreturn\e[0m max_level.toList\n\e[31m\e\
    [31m   |\e[0m               ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m           value\
    \ toList is not a member of Int - did you mean Int.toInt?\n5 errors found\n"
  stdout: ''
  timestamp: 1660029149
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        var max_level_of_nesting = 0\n        var levels = scala.collection.mutable.List.empty[Long]\n\
    \        var parentheses_encountered = scala.collection.mutable.Set.empty[String]\n\
    \        for (paren \u2190 paren_string) {\n            parentheses_encountered.add(paren)\n\
    \            if (paren == '(') {\n                levels += 1\n            } else\
    \ if (paren == ')') {\n                levels -= 1\n                if (levels\
    \ == 0) {\n                    max_level_of_nesting = Math.max(max_level_of_nesting,\
    \ levels)\n                }\n            }\n        }\n        if (levels ==\
    \ 0) {\n            max_level_of_nesting = 0\n        }\n        return max_level_of_nesting\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp7pl8j2sx.scala:11:46 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mvar\e[0m \e[36mlevels\e[0m = scala.collection.mutable.List.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue List is not a member of scala.collection.mutable - did\
    \ you mean mutable.ListMap?\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp7pl8j2sx.scala:14:40\
    \ --------------------\e[0m\e[0m\n\e[31m14 |\e[0m            parentheses_encountered.add(paren)\n\
    \e[31m\e[31m   |\e[0m                                        ^^^^^\e[0m\n\e[31m\
    \   |\e[0m                                        Found:    (paren : Char)\n\e\
    [31m   |\e[0m                                        Required: String\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp7pl8j2sx.scala:27:15 --------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mreturn\e[0m max_level_of_nesting\n\e[31m\e\
    [31m   |\e[0m               ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m       \
    \        Found:    (max_level_of_nesting : Int)\n\e[31m   |\e[0m             \
    \  Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\nthere were 3 deprecation warnings; re-run with\
    \ -deprecation for details\n1 warning found\n3 errors found\n"
  stdout: ''
  timestamp: 1660029147
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_stack = new mutable.ListBuffer[Long]()\n        for (i\
    \ <- 0 until paren_string.length) {\n            paren_stack ::= paren_string(i)\n\
    \            if (paren_stack.size == 0)\n                paren_stack += 0\n  \
    \          if (paren_stack.size == 1)\n                paren_stack += 0\n    \
    \    }\n        paren_stack.toList\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpnzf9jug_.scala:10:30 ------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e[36mparen_stack\e[0m = \e[33mnew\e\
    [0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m             \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                              Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660029136
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        // (1) Split string by spaces.\n        // [(\"()\", \"()\"), (\"\
    ()()\", \"()\"), (\"()()()\", \"()\"), (\"(())\", \"()\"), (\"(())()\", \"()\"\
    ), (\"(())()()\", \"()\"), (\"(()())\", \"()\"), (\"(()())()\", \"()\"), (\"(())()()()\"\
    , \"()\")]\n        val paren_groups = paren_string.split(\" \").map(s => s.trim).toList\n\
    \        // [List(\"()\", \"()\"), List(\"()()\", \"()\"), List(\"()()()\", \"\
    ()\"), List(\"(())\", \"()\"), List(\"(())()\", \"()\"), List(\"(())()()\", \"\
    ()\"), List(\"(()())\", \"()\"), List(\"(()())()\", \"()\"), List(\"(())()()()\"\
    , \"()\")]\n\n        // 2) Use recursion to solve the problem\n        // [((())),\
    \ (()())), (()()()), (()(())), (()(()())), ((())()), ((())()), (())(()), (())()(),\
    \ (()()()()), (()(()()()()))]\n        paren_groups.flatMap{\n            case\
    \ List(x) => parseNestedParens(x)\n            case x => parseNestedParens(x)\
    \ ++ parseNestedParens(x)\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpwev165mh.scala:18:46\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m            \e[33mcase\e[0m List(x)\
    \ => parseNestedParens(x)\n\e[31m\e[31m   |\e[0m                             \
    \                 ^\e[0m\n\e[31m   |\e[0m                                    \
    \          Found:    (x : Any)\n\e[31m   |\e[0m                              \
    \                Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660029144
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_arrays = paren_string.split(\"( |, )\")\n        var deepest_level\
    \ = paren_arrays.length\n        val max_level_arrays = paren_arrays.map(parens\
    \ => parens.split(\" \")).flatten.maxBy(x => x.length)\n        for(max_level_string\
    \ <- max_level_arrays.toList){\n            if(max_level_string.length>deepest_level){\n\
    \                deepest_level = max_level_string.length\n            }\n    \
    \    }\n        paren_arrays.map(parens => parens.split(\" \")).flatten.maxBy(x\
    \ => x.length).toList.sortBy(x => x.length).reverse.take(deepest_level).reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp0jqaxfea.scala:14:32 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m            \e[33mif\e[0m(max_level_string.length>deepest_level){\n\
    \e[31m\e[31m   |\e[0m               ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m               value length is not a member of Char\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp0jqaxfea.scala:15:49 ------------------------\e[0m\e\
    [0m\n\e[31m15 |\e[0m                deepest_level = max_level_string.length\n\e\
    [31m\e[31m   |\e[0m                                ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                value length is not a member of\
    \ Char\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp0jqaxfea.scala:18:104 -----------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        paren_arrays.map(\e[36mparens\e[0m => parens.split(\e\
    [31m\" \"\e[0m)).flatten.maxBy(\e[36mx\e[0m => x.length).toList.sortBy(\e[36mx\e\
    [0m => x.length).reverse.take(deepest_level).reverse\n\e[31m\e[31m   |\e[0m  \
    \                                                                            \
    \                        ^^^^^^^^\e[0m\n\e[31m   |\e[0m                      \
    \              value length is not a member of Char\n\e[31m\e[31m-- Error: /tmp/tmp0jqaxfea.scala:18:111\
    \ ----------------------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        paren_arrays.map(\e\
    [36mparens\e[0m => parens.split(\e[31m\" \"\e[0m)).flatten.maxBy(\e[36mx\e[0m\
    \ => x.length).toList.sortBy(\e[36mx\e[0m => x.length).reverse.take(deepest_level).reverse\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                                       ^\e[0m\n\e[31m   |\e[0mambiguous\
    \ given instances: both \e[33mobject\e[0m \e[35mByte\e[0m in \e[33mobject\e[0m\
    \ \e[35mOrdering\e[0m and \e[33mobject\e[0m \e[35mChar\e[0m in \e[33mobject\e\
    [0m \e[35mOrdering\e[0m match type Ordering[B] of parameter ord of \e[33mmethod\e\
    [0m \e[35msortBy\e[0m in \e[33mtrait\e[0m \e[35mSeqOps\e[0m\n4 errors found\n"
  stdout: ''
  timestamp: 1660029149
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        paren_string.trim.split(\"\\\\s+\".r).map(n => n.trim.split(\"\\\\\
    (\").map(i => i(0)).size)\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpx8rxv2v8.scala:10:39\
    \ --------------------\e[0m\e[0m\n\e[31m10 |\e[0m        paren_string.trim.split(\e\
    [31m\"\\\\s+\"\e[0m.r).map(\e[36mn\e[0m => n.trim.split(\e[31m\"\\\\(\"\e[0m).map(\e\
    [36mi\e[0m => i(\e[31m0\e[0m)).size)\n\e[31m\e[31m   |\e[0m                  \
    \              ^^^^^^^^\e[0m\n\e[31m   |\e[0m                                Found:\
    \    scala.util.matching.Regex\n\e[31m   |\e[0m                              \
    \  Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660029144
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_array : List[String] = paren_string.split(\" +\")\n   \
    \     val max_level = 0\n        val result_level: List[Long] = Nil\n        paren_array.foreach{\
    \ group =>\n            var group_level = 0\n            val paren_group_array\
    \ : List[String] = group.split(\"\")\n            while (paren_group_array.length\
    \ > 1) {\n                paren_group_array.sliding(2).foreach(x => group_level\
    \ += x.length)\n            }\n            group_level = math.max(group_level,\
    \ max_level)\n            max_level = math.max(group_level, max_level)\n     \
    \       if (group_level == max_level) {\n                result_level :+ group_level\n\
    \            } else {\n                result_level :+ group_level\n         \
    \       result_level = Nil\n            }\n        }\n        result_level.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmps8erzhok.scala:10:59\
    \ --------------------\e[0m\e[0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e[36mparen_array\e\
    [0m : \e[35mList\e[0m[\e[35mString\e[0m] = paren_string.split(\e[31m\" +\"\e[0m)\n\
    \e[31m\e[31m   |\e[0m                                         ^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                         Found:    \e[1m\e\
    [31mArray\e[0m[String]\n\e[31m   |\e[0m                                      \
    \   Required: \e[1m\e[32mList\e[0m[String]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmps8erzhok.scala:15:62 --------------------\e[0m\e\
    [0m\n\e[31m15 |\e[0m            \e[33mval\e[0m \e[36mparen_group_array\e[0m :\
    \ \e[35mList\e[0m[\e[35mString\e[0m] = group.split(\e[31m\"\"\e[0m)\n\e[31m\e\
    [31m   |\e[0m                                                   ^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                                 Found:  \
    \  \e[1m\e[31mArray\e[0m[String]\n\e[31m   |\e[0m                            \
    \                     Required: \e[1m\e[32mList\e[0m[String]\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E052] Type Error: /tmp/tmps8erzhok.scala:20:22 -----------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m            max_level = math.max(group_level, max_level)\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m            Reassignment to val max_level\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E052] Type Error: /tmp/tmps8erzhok.scala:25:29 -----------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m                result_level = Nil\n\e[31m\e[31m   |\e\
    [0m                ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                Reassignment\
    \ to val result_level\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660029147
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        var parens_encountered = new scala.collection.mutable.HashSet[Long]()\n\
    \        var paren_depth = 0\n        var group_list = new scala.collection.mutable.ListBuffer[Long]()\n\
    \        for (i <- 0 until paren_string.length()) {\n            if (paren_encountered(paren_depth))\
    \ {\n                group_list.+=((paren_encountered(paren_depth)))\n       \
    \         paren_depth+=1\n            }\n            else {\n                if\
    \ (paren_string(i) == '(') {\n                    parens_encountered += paren_depth\n\
    \                    paren_depth += 1\n                }\n                if (paren_string(i)\
    \ == ')') {\n                    paren_depth -= 1\n                }\n       \
    \     }\n        }\n        return group_list.toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"\
    () (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp8z_6f8dw.scala:14:16 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m            \e[33mif\e[0m (paren_encountered(paren_depth))\
    \ {\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                Not found: paren_encountered\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp8z_6f8dw.scala:15:31 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m                group_list.+=((paren_encountered(paren_depth)))\n\
    \e[31m\e[31m   |\e[0m                               ^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                               Not found: paren_encountered\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660029137
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_char = \"()\"\n        val paren_str = paren_string.toList\n\
    \        val paren_char = paren_char.toChar\n\n        def parseParens(paren_str:\
    \ List[Char], current_level : Int) : List[Long] = {\n            val new_level\
    \ = current_level + 1\n            val new_parens = ListBuffer.empty[Long]\n \
    \           val paren_count = paren_str.count(_ == paren_char)\n\n           \
    \ val parens = paren_str.map(paren_char).distinct\n            val paren_level\
    \ = parens.count(paren_char).toLong\n\n            for ((i, paren) <- parens.view.zipWithIndex\
    \ if paren_level > current_level) {\n                val paren_str = paren_str.drop(i).toList\n\
    \                val paren_level = parens.count(paren_char).toLong\n         \
    \       val paren_char = parens.head\n\n                val parens_count = paren_str.count(_\
    \ == paren_char)\n                val parens_level = parens_count.toLong\n\n \
    \               parens_count match {\n                    case 0 => new_parens\
    \ ++= parseParens(paren_str, new_level)\n                    case _ => new_parens\
    \ ++= parseParens(paren_str, new_level) match {\n                        case\
    \ List(count) if count > 0 => parseParens(paren_str, new_level + 1)\n        \
    \                case _ => parseParens(paren_str, new_level)\n               \
    \     }\n                }\n            }\n            paren_level match {\n \
    \               case 0 => List(1l.toLong)\n                case _ => paren_str\
    \ match {\n                    case parens.head :: tail => paren_char :: parseParens(tail,\
    \ new_level)\n                    case _ => parseParens(paren_str, new_level)\n\
    \                }\n            }\n        }\n\n        parseParens(paren_str,\
    \ 0)\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp3h80wjkq.scala:12:12 ---------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mparen_char\e[0m = paren_char.toChar\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0mparen_char is already defined as \e[33mvalue\e[0m \e[35mparen_char\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- Error: /tmp/tmp3h80wjkq.scala:17:46\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m17 |\e[0m       \
    \     \e[33mval\e[0m \e[36mparen_count\e[0m = paren_str.count(_ == paren_char)\n\
    \e[31m\e[31m   |\e[0m                                              ^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Values of types Char and String cannot be compared\
    \ with == or !=\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp3h80wjkq.scala:19:39\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            \e[33mval\e[0m \e\
    [36mparens\e[0m = paren_str.map(paren_char).distinct\n\e[31m\e[31m   |\e[0m  \
    \                                     ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m       \
    \                                Found:    (paren_char : String)\n\e[31m   |\e\
    [0m                                       Required: Char => Any\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp3h80wjkq.scala:20:43 --------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m            \e[33mval\e[0m \e[36mparen_level\e[0m = parens.count(paren_char).toLong\n\
    \e[31m\e[31m   |\e[0m                                           ^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                         Found:    (paren_char\
    \ : String)\n\e[31m   |\e[0m                                         Required:\
    \ Nothing => Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp3h80wjkq.scala:33:50\
    \ ------------------------\e[0m\e[0m\n\e[31m33 |\e[0m                        \e\
    [33mcase\e[0m List(count) \e[33mif\e[0m count > \e[31m0\e[0m => parseParens(paren_s"
  stdout: ''
  timestamp: 1660029165
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        var count : Long = 0\n        var stack : List[Long] = List()\n \
    \       var stack_string = \"\"\n        for {\n            char <- paren_string.charAt(count)\n\
    \            if char == '('\n            if stack.length == 0\n            count\
    \ += 1\n            else {\n                stack ::= count\n                stack_string\
    \ += char\n                count += 1\n            }\n            else if char\
    \ == ')'\n            if stack.length > 0\n            count += 1\n          \
    \  else {\n                val stack_size = stack.length\n                stack_string\
    \ = stack_string.substring(0, stack_string.length - 1).toString.padRight(stack_size,\
    \ '0')\n                stack = stack.tail\n                stack_string += char\n\
    \                count += 1\n            }\n            else if char == ' '\n\
    \            if count + 1 == paren_string.length\n            count += 1\n   \
    \         else {\n                stack_string += char\n                count\
    \ += 1\n            }\n        } yield stack_string.toLong\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"\
    () (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpsj76dd1g.scala:18:12 ---------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m            \e[33melse\e[0m {\n\e[31m\e[31m   |\e[0m\
    \            ^^^^\e[0m\n\e[31m   |\e[0m            '<-' expected, but 'else' found\n\
    \e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpsj76dd1g.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m            \e[33melse\e[0m {\n\e[31m\e[31m   |\e[0m\
    \            ^^^^\e[0m\n\e[31m   |\e[0m            '<-' expected, but 'else' found\n\
    \e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpsj76dd1g.scala:36:12 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m            \e[33melse\e[0m {\n\e[31m\e[31m   |\e[0m\
    \            ^^^^\e[0m\n\e[31m   |\e[0m            '<-' expected, but 'else' found\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpsj76dd1g.scala:14:40 --------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m            char <- paren_string.charAt(count)\n\e[31m\e\
    [31m   |\e[0m                                        ^^^^^\e[0m\n\e[31m   |\e\
    [0m                                        Found:    (count : Long)\n\e[31m  \
    \ |\e[0m                                        Required: Int\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1660029160
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        // Initialization\n        var paren_levels : List[Long] = Nil\n\
    \        var paren_count : Long = 0\n        var paren_level = 0\n\n        //\
    \ Loop through the input string.\n        for (i <- paren_string.indices){\n \
    \           // If this character is opening, increase the level\n            if\
    \ (paren_string(i) == \"(\"){\n                paren_level += 1\n            }\n\
    \            // If this character is closing, decrease the level\n           \
    \ else if (paren_string(i) == \")\"){\n                paren_level -= 1\n    \
    \        }\n            // If the level is getting too high, ignore this character\
    \ and move on to the next one.\n            if (paren_level > paren_count){\n\
    \                paren_count += 1\n                paren_level = 0\n         \
    \   }\n            // If the level is getting too low, ignore this character and\
    \ move on to the next one.\n            if (paren_level < paren_count){\n    \
    \            paren_count -= 1\n                paren_level = 0\n            }\n\
    \        }\n        // Return the deepest level of nesting.\n        return paren_levels\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpno08h2ks.scala:18:16 -----------------------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m            \e[33mif\e[0m (paren_string(i) == \e[31m\"\
    (\"\e[0m){\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m        Values of types Char and String cannot be compared with\
    \ == or !=\n\e[31m\e[31m-- Error: /tmp/tmpno08h2ks.scala:22:21 -----------------------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m            \e[33melse\e[0m \e[33mif\e[0m (paren_string(i)\
    \ == \e[31m\")\"\e[0m){\n\e[31m\e[31m   |\e[0m                     ^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Values of types Char and String cannot be compared\
    \ with == or !=\n2 errors found\n"
  stdout: ''
  timestamp: 1660029162
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_levels = paren_string.split(\"\\\\s+\")\n        val max_depth\
    \ = paren_levels.length\n        val max_depth_tuple = (max_depth, List(1l.toLong))\n\
    \        paren_levels.foldLeft(max_depth_tuple){ \n            case(max_depth_tuple,\
    \ (cur_max_depth, paren_strings)) =>\n                val nested_levels = paren_strings.split(\"\
    \\\\)\")\n                (cur_max_depth + 1, nested_levels.map(_.toLong))\n \
    \       }._2\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp7m6g09ah.scala:15:50 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m                \e[33mval\e[0m \e[36mnested_levels\e\
    [0m = paren_strings.split(\e[31m\"\\\\)\"\e[0m)\n\e[31m\e[31m   |\e[0m       \
    \                             ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \                              value split is not a member of Any\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmp7m6g09ah.scala:16:31 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m                (cur_max_depth + \e[31m1\e[0m, nested_levels.map(_.toLong))\n\
    \e[31m\e[31m   |\e[0m                 ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ + is not a member of Any, but could be made available as an extension method.\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might make progress\
    \ towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660029168
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        //Get all groups in parentheses\n        val groups = paren_string.split(\"\
    \\\\(|\\\\)\")\n        //For each group in parentheses, parse the nested groups\
    \ into array\n        val arraygroups = groups.map(group => {\n           //Each\
    \ group has nested groups separated by spaces. Get the inner groups in an array.\n\
    \           val inner_groups = group.split(\"\\\\ |\\\\(\").map(inner_group =>\
    \ inner_group.split(\"\\\\)\").map(inner_inner_group => inner_inner_group.toLong).toList\n\
    \           inner_groups.getOrElse(Nil)\n        })\n        //Find the deepest\
    \ level of nesting in all arrays\n        val deepest_level = arraygroups.map(arraygroup\
    \ => {\n             //Calculate the sum of the lengths of inner groups\n    \
    \         arraygroup.map(inner_group => inner_group.length).sum\n        }).max\n\
    \        //Return result\n        deepest_level\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp81__67_c.scala:16:23 ---------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m           inner_groups.getOrElse(Nil)\n\e[31m\e[31m\
    \   |\e[0m                       ^\e[0m\n\e[31m   |\e[0m                     \
    \  expression expected but \e[31m'.'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ Error: /tmp/tmp81__67_c.scala:17:8 ------------------------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        })\n\e[31m\e[31m   |\e[0m        ^\e[0m\n\e[31m\
    \   |\e[0m        No ClassTag available for B\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \        where:    B is a type variable\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmp81__67_c.scala:21:24 ------------------------\e[0m\e[0m\n\e[31m21 |\e\
    [0m             arraygroup.map(\e[36minner_group\e[0m => inner_group.length).sum\n\
    \e[31m\e[31m   |\e[0m             ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m       \
    \      value map is not a member of Unit\n\e[31m\e[31m-- Error: /tmp/tmp81__67_c.scala:22:10\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m22 |\e[0m       \
    \ }).max\n\e[31m\e[31m   |\e[0m          ^\e[0m\n\e[31m   |\e[0m          No ClassTag\
    \ available for B\n\e[31m   |\e[0m\n\e[31m   |\e[0m          where:    B is a\
    \ type variable\n4 errors found\n"
  stdout: ''
  timestamp: 1660029169
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val parens = paren_string.split(\" \")\n        val max_level = 0\n\
    \        val max_level_list: List[Long] = Nil\n        for(paren <- parens) {\n\
    \            val level_count = paren.split(\"(\").length - 1\n            if(level_count\
    \ > max_level) {\n                max_level = level_count\n                max_level_list\
    \ = List(max_level.toLong)\n            }\n            else if(level_count ==\
    \ max_level) {\n                max_level_list = (max_level_list :+ max_level)\n\
    \            }\n        }\n        max_level_list\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmpzymgsy36.scala:16:26 -----------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m                max_level = level_count\n\e[31m\e[31m\
    \   |\e[0m                ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \          Reassignment to val max_level\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E052]\
    \ Type Error: /tmp/tmpzymgsy36.scala:17:31 -----------------------------\e[0m\e\
    [0m\n\e[31m17 |\e[0m                max_level_list = List(max_level.toLong)\n\e\
    [31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                Reassignment to val max_level_list\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E052] Type Error: /tmp/tmpzymgsy36.scala:20:31 -----------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m                max_level_list = (max_level_list :+ max_level)\n\
    \e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                Reassignment to val max_level_list\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1660029160
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        // Initialize output list\n        val output = ListBuffer[Long]()\n\
    \        // Initialize a stack to keep track of nested parens\n        var stack:\
    \ Stack[String] = Stack()\n        // Iterate through paren_string\n        for\
    \ (c <- paren_string)\n            if (c == '(')\n                stack.append(c)\n\
    \            else if (c == ')')\n                while (stack.size > 0 && (stack.pop()\
    \ == '('))\n                    output += stack.pop\n        else\n          \
    \  while (stack.size > 0 && (stack.pop() == '('))\n                output += stack.pop()\n\
    \        // Return output\n        output.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpwk9078ni.scala:21:8 ------------------------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33melse\e[0m\n\e[31m\e[31m   |\e[0m      \
    \  ^^^^\e[0m\n\e[31m   |\e[0m        end of statement expected but 'else' found\n\
    \e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpwk9078ni.scala:25:8 ----------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        output.toList\n\e[31m\e[31m   |\e[0m        ^^^^^^\e\
    [0m\n\e[31m   |\e[0m        '}' expected, but unindent found\n\e[31m\e[31m-- [E134]\
    \ Type Error: /tmp/tmpwk9078ni.scala:17:22 -----------------------------\e[0m\e\
    [0m\n\e[31m17 |\e[0m                stack.append(c)\n\e[31m\e[31m   |\e[0m   \
    \             ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives\
    \ of \e[33mmethod\e[0m \e[35mappend\e[0m in \e[33mtrait\e[0m \e[35mBuffer\e[0m\
    \ with types\n\e[31m   |\e[0m (elems: String*): collection.mutable.Stack[String]\n\
    \e[31m   |\e[0m (elem: String): collection.mutable.Stack[String]\n\e[31m   |\e\
    [0mmatch arguments ((c : Char))\n\e[31m\e[31m-- Error: /tmp/tmpwk9078ni.scala:19:42\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m19 |\e[0m       \
    \         \e[33mwhile\e[0m (stack.size > \e[31m0\e[0m && (stack.pop() == \e[31m'('\e\
    [0m))\n\e[31m\e[31m   |\e[0m                                          ^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Values of types String and Char cannot be compared\
    \ with == or !=\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpwk9078ni.scala:20:30\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m                    output +=\
    \ stack.pop\n\e[31m\e[31m   |\e[0m                              ^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                              Found:    String\n\e[31m   |\e[0m\
    \                              Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpwk9078ni.scala:23:35 --------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m                output += stack.pop()\n\e[31m\e[31m \
    \  |\e[0m                          ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m         \
    \                 Found:    String\n\e[31m   |\e[0m                          "
  stdout: ''
  timestamp: 1660029169
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        def findNestingLevel(paren_string : String) : Int = {\n         \
    \   val paren_level = paren_string.lastIndexOf(')') +1\n            paren_level\n\
    \        }\n        val parens_arr = paren_string.split(')')\n        val nesting_levels\
    \ = parens_arr.map(findNestingLevel)\n        val max_nesting = nesting_levels.max()\n\
    \        nesting_levels.map(x => x.toLong).toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpvgy_dlb8.scala:16:44 -----------------------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mmax_nesting\e[0m = nesting_levels.max()\n\
    \e[31m\e[31m   |\e[0m                          ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mmissing argument for parameter ord of \e[33mmethod\e[0m \e[35mmax\e\
    [0m in \e[33mtrait\e[0m \e[35mIterableOnceOps\e[0m: (\e[33mimplicit \e[0mord:\
    \ Ordering[B]): Int\n1 error found\n"
  stdout: ''
  timestamp: 1660029162
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        // Initialize an Array to store the groups of the string.\n     \
    \   var nested_paren_groups = ListBuffer[String]()\n\n        // Iterate through\
    \ each character of the string.\n        for(c <- paren_string) {\n          \
    \  if(c == '(') {\n                // If the character is '(', increment the length\
    \ of the list by 1.\n                nested_paren_groups.append(c.toString)\n\
    \            }\n            else if(c == ')') {\n                // If the character\
    \ is ')', decrement the length of the list and append the element at the end.\n\
    \                nested_paren_groups.pop()\n                nested_paren_groups.append(c.toString)\n\
    \            }\n        }\n        // Finally convert the list to Long.\n    \
    \    val nested_paren_groups_list = nested_paren_groups.toList\n        val nested_paren_groups_listLength\
    \ = nested_paren_groups_list.length\n        val nested_paren_groups_as_longs\
    \ = nested_paren_groups_list.map(_.toLong)\n        val nested_paren_groups_as_longs_sorted\
    \ = nested_paren_groups_as_longs.sort\n        val max_nested_paren_groups = nested_paren_groups_as_longs_sorted.take(nested_paren_groups_listLength)\n\
    \        return max_nested_paren_groups\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpa_puqxnv.scala:21:36 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m                nested_paren_groups.pop()\n\e[31m\e[31m\
    \   |\e[0m                ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue pop\
    \ is not a member of scala.collection.mutable.ListBuffer[String] - did you mean\
    \ scala.collection.mutable.ListBuffer[String].drop?\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmpa_puqxnv.scala:29:79 ------------------------\e[0m\e[0m\n\
    \e[31m29 |\e[0m        \e[33mval\e[0m \e[36mnested_paren_groups_as_longs_sorted\e\
    [0m = nested_paren_groups_as_longs.sort\n\e[31m\e[31m   |\e[0m               \
    \                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mvalue sort is not a member of List[Long], but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.seq\
    \ AsJavaList\n\e[31m   |\e[0m  import collection.convert.ImplicitConversionsToJava.seq\
    \ AsJavaList\n\e[31m   |\e[0m\n2 errors found\n"
  stdout: ''
  timestamp: 1660029169
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val max_level: Int = 0\n        var level : Int = 0\n        val\
    \ paren_list = mutable.ListBuffer[Long]()\n        for (x <- paren_string.split(\"\
    \ \").toList) {\n            if (x == \"(\" || x == \"[\" || x == \"{\") {\n \
    \               level += 1\n            } else if (x == \")\" || x == \"]\" ||\
    \ x == \"}\") {\n                level -= 1\n                if (level > max_level)\
    \ {\n                    max_level = level\n                    paren_list +=\
    \ x.toLong\n                }\n            }\n        }\n        paren_list.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmphc1ce3a1.scala:12:25 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mparen_list\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                         ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                         Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E052] Type Error: /tmp/tmphc1ce3a1.scala:19:30 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m                    max_level = level\n\e[31m\e[31m \
    \  |\e[0m                    ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m         \
    \           Reassignment to val max_level\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660029162
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_list_strings = paren_string.trim.split(' ').toList\n  \
    \      val paren_list_string_lengths = paren_list_strings.map(paren_list => paren_list_string.count(paren_list\
    \ => paren_list == '(') + paren_list_string.count(paren_list => paren_list ==\
    \ ')')).toList\n        val paren_list_strings_with_lengths = paren_list_strings.zipWithIndex.map\
    \ { case (paren_string, index) => (paren_string, paren_list_string_lengths(index))\
    \ }\n        val paren_list_strings_sorted = paren_list_strings_with_lengths.sortBy(_._2).reverse\n\
    \        val max_levels_of_nesting = paren_list_strings_sorted.find(_._2 > 0).get._1\n\
    \        val levels_of_nesting_list = paren_list_strings_sorted.map(x => max_levels_of_nesting\
    \ - x._2)\n        val number_of_max_level_of_nesting_list = levels_of_nesting_list.filter(_\
    \ > 1).size\n        val final_level_of_nesting_list = levels_of_nesting_list.sortWith(_\
    \ < _)\n        val final_level_of_nesting_list_with_number_of_levels_of_nesting_list\
    \ = final_level_of_nesting_list.zip(number_of_max_level_of_nesting_list).map(x\
    \ => x(0) + x(1)).toList\n        return final_level_of_nesting_list_with_number_of_levels_of_nesting_list\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpio33lorc.scala:11:77 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mparen_list_string_lengths\e\
    [0m = paren_list_strings.map(\e[36mparen_list\e[0m => paren_list_string.count(\e\
    [36mparen_list\e[0m => paren_list == \e[31m'('\e[0m) + paren_list_string.count(\e\
    [36mparen_list\e[0m => paren_list == \e[31m')'\e[0m)).toList\n\e[31m\e[31m   |\e\
    [0m                                                                          \
    \   ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                                  \
    \          Not found: paren_list_string\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- Error:\
    \ /tmp/tmpio33lorc.scala:13:84 -----------------------------------------\e[0m\e\
    [0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mparen_list_strings_sorted\e[0m\
    \ = paren_list_strings_with_lengths.sortBy(_._2).reverse\n\e[31m\e[31m   |\e[0m\
    \                                                                            \
    \        ^\e[0m\n\e[31m   |\e[0mambiguous given instances: both \e[33mobject\e\
    [0m \e[35mByte\e[0m in \e[33mobject\e[0m \e[35mOrdering\e[0m and \e[33mobject\e\
    [0m \e[35mShort\e[0m in \e[33mobject\e[0m \e[35mOrdering\e[0m match type Ordering[B]\
    \ of parameter ord of \e[33mmethod\e[0m \e[35msortBy\e[0m in \e[33mtrait\e[0m\
    \ \e[35mSeqOps\e[0m\n2 errors found\n"
  stdout: ''
  timestamp: 1660029163
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_chars = paren_string.toCharArray\n        var paren_count\
    \ : Int = 0\n        var paren_depth : Int = 0\n        var paren_list : List[Long]\
    \ = Nil\n        var max_depth : Int = 0\n\n        // Search for nested parens\n\
    \        for (paren_char <- paren_chars) {\n            if (paren_char == '(')\
    \ {\n                paren_count += 1\n                paren_depth += 1\n    \
    \        } else if (paren_char == ')') {\n                paren_depth -= 1\n \
    \               if (paren_depth == 0) {\n                    paren_count -= 1\n\
    \                    paren_list = paren_list :+ (paren_count)\n              \
    \      if (max_depth < paren_list.length)\n                        max_depth =\
    \ paren_list.length\n                }\n            }\n        }\n        return\
    \ paren_list\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp7socsqkp.scala:34)\n\tat Problem.main(tmp7socsqkp.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660029172
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        paren_string.trim\n            .split(\" \")\n            .map(string\
    \ => {\n                val parens = Parens(string)\n                parens.parens\n\
    \            }).flatMap {\n                case Parens(string) => parseNestedParens(string)\n\
    \                case parens => List(parens.count)\n            }.takeWhile(_.isDefined)\n\
    \            .map(_.get).toList\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpwcui5k2y.scala:13:29 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m                \e[33mval\e[0m \e[36mparens\e[0m = Parens(string)\n\
    \e[31m\e[31m   |\e[0m                             ^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                             Not found: Parens\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ Error: /tmp/tmpwcui5k2y.scala:15:14 -----------------------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m            }).flatMap {\n\e[31m\e[31m   |\e[0m     \
    \         ^\e[0m\n\e[31m   |\e[0m              No ClassTag available for B\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m              where:    B is a type variable\n2\
    \ errors found\n"
  stdout: ''
  timestamp: 1660029169
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        // For each parenthesis, append each of its nesting level to the\
    \ list.\n        // Also add its opening parenthesis to the list.\n        //\
    \ Start with zero nesting level and increment it for each opening parenthesis.\n\
    \        // Also, don't count empty parenthesis as nesting level.\n        val\
    \ paren_levels = new scala.collection.mutable.ListBuffer[Long]\n        paren_string.split(\"\
    \\\\(\\\\)\").map(x => paren_levels += paren_levels.size + 1).distinct\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()())\
    \ ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpsgn_tv6c.scala:15:85\
    \ --------------------\e[0m\e[0m\n\e[31m15 |\e[0m        paren_string.split(\e\
    [31m\"\\\\(\\\\)\"\e[0m).map(\e[36mx\e[0m => paren_levels += paren_levels.size\
    \ + \e[31m1\e[0m).distinct\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Array[scala.collection.mutable.ListBuffer[Long]]\n\
    \e[31m   |\e[0m        Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660029168
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        paren_string.split(\" \").groupBy(_.length)\n              .map(x\
    \ => (x._1, x._2.toList.length))\n              .maxBy(_._1)\n              ._2\n\
    \              .toList\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpz_agxj5r.scala:14:15 ------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m        paren_string.split(\e[31m\" \"\e[0m).groupBy(_.length)\n\
    \e[31m11 |\e[0m              .map(\e[36mx\e[0m => (x._1, x._2.toList.length))\n\
    \e[31m12 |\e[0m              .maxBy(_._1)\n\e[31m13 |\e[0m              ._2\n\e\
    [31m14 |\e[0m              .toList\n\e[31m\e[31m   |\e[0m        ^\e[0m\n\e[31m\
    \   |\e[0m        value toList is not a member of Int - did you mean _2.toInt?\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660029169
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        def paren(x : String): List[Long] = {\n            x match {\n  \
    \              case \"(\" => List(1L)\n                case \")\" => List(1L)\n\
    \                case _ => x\n            }\n        }\n        def deep(x : List[Long]):\
    \ List[Long] = {\n            x match {\n                case Nil => 1L\n    \
    \            case List(1L) => 1L\n                case List(t) => deep(paren(x)\
    \ - t)\n                case _ => deep(paren(x) - paren(x-1))\n            }\n\
    \        }\n        var max_level = 0\n        var groups = paren_string.split(\"\
    \ \").toList\n        groups.tail.foldLeft((groups, max_level)) { (cur_list, cur_value)\
    \ =>\n            val groups = cur_list._1\n            val cur_value = cur_list._2\n\
    \            val max_level = math.max(max_level, deep(groups))\n            (groups\
    \ ::: List(cur_value), max_level)\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp98v43g6u.scala:14:26\
    \ --------------------\e[0m\e[0m\n\e[31m14 |\e[0m                \e[33mcase\e\
    [0m _ => x\n\e[31m\e[31m   |\e[0m                          ^\e[0m\n\e[31m   |\e\
    [0m                          Found:    (x : String)\n\e[31m   |\e[0m         \
    \                 Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmp98v43g6u.scala:19:28 --------------------\e[0m\e\
    [0m\n\e[31m19 |\e[0m                \e[33mcase\e[0m Nil => \e[31m1L\e[0m\n\e[31m\e\
    [31m   |\e[0m                            ^^\e[0m\n\e[31m   |\e[0m            \
    \                Found:    (\e[31m1L\e[0m : Long)\n\e[31m   |\e[0m           \
    \                 Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmp98v43g6u.scala:20:33 --------------------\e[0m\e\
    [0m\n\e[31m20 |\e[0m                \e[33mcase\e[0m List(\e[31m1L\e[0m) => \e\
    [31m1L\e[0m\n\e[31m\e[31m   |\e[0m                                 ^^\e[0m\n\e\
    [31m   |\e[0m                                 Found:    (\e[31m1L\e[0m : Long)\n\
    \e[31m   |\e[0m                                 Required: List[Long]\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp98v43g6u.scala:21:43 --------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m                \e[33mcase\e[0m List(t) => deep(paren(x)\
    \ - t)\n\e[31m\e[31m   |\e[0m                                           ^\e[0m\n\
    \e[31m   |\e[0m                                           Found:    (x : List[Long])\n\
    \e[31m   |\e[0m                                           Required: String\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp98v43g6u.scala:22:37\
    \ --------------------\e[0m\e[0m\n\e[31m22 |\e[0m                \e[33mcase\e\
    [0m _ => deep(paren(x) - paren(x-\e[31m1\e[0m))\n\e[31m\e[31m   |\e[0m       \
    \                              ^\e[0m\n\e[31m   |\e"
  stdout: ''
  timestamp: 1660029173
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        // We use mutable list to keep track of how many parentheses are\
    \ already opened and closed\n        var open_count : Int = 0\n        var max_count\
    \ : Long = 0\n        var result : List[Long] = Nil\n        // Iterate through\
    \ string and keep track of number of open and closed paren\n        for (i <-\
    \ 0 until paren_string.length)\n        {\n            if (paren_string(i) ==\
    \ \"(\")\n            {\n                open_count++\n            } else if (paren_string(i)\
    \ == \")\")\n            {\n                open_count--\n            }\n\n  \
    \          if (open_count > max_count)\n            {\n                max_count\
    \ = open_count\n                result = result ::: (0 until open_count)\n   \
    \         }\n\n        }\n\n        // If there are any open paren without close,\
    \ increment max_count\n        if (open_count != 0)\n        {\n            max_count\
    \ = open_count\n            result = result ::: (0 until open_count)\n       \
    \ }\n\n        return result\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp5cn_ke3n.scala:19:28 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m                open_count++\n\e[31m\e[31m   |\e[0m \
    \                           ^\e[0m\n\e[31m   |\e[0m                          \
    \  expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E018] Syntax Error: /tmp/tmp5cn_ke3n.scala:22:28 ---------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m                open_count--\n\e[31m\e[31m   |\e[0m \
    \                           ^\e[0m\n\e[31m   |\e[0m                          \
    \  expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ Error: /tmp/tmp5cn_ke3n.scala:17:16 -----------------------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m            \e[33mif\e[0m (paren_string(i) == \e[31m\"\
    (\"\e[0m)\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m        Values of types Char and String cannot be compared with ==\
    \ or !=\n\e[31m\e[31m-- Error: /tmp/tmp5cn_ke3n.scala:20:23 -----------------------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m            } \e[33melse\e[0m \e[33mif\e[0m (paren_string(i)\
    \ == \e[31m\")\"\e[0m)\n\e[31m\e[31m   |\e[0m                       ^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Values of types Char and String cannot be compared\
    \ with == or !=\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp5cn_ke3n.scala:28:32\
    \ ------------------------\e[0m\e[0m\n\e[31m28 |\e[0m                result =\
    \ result ::: (\e[31m0\e[0m until open_count)\n\e[31m\e[31m   |\e[0m          \
    \                      ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        \
    \    value ::: is not a member of Range - did you mean Range.++:?\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmp5cn_ke3n.scala:37:28 ------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m            result = result ::: (\e[31m0\e[0m until open_count)\n\
    \e[31m\e[31m   |\e[0m                            ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m            value ::: is not a member of Range - did you"
  stdout: ''
  timestamp: 1660029172
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren = paren_string.flatMap{_.toChar}.toList\n        val stack\
    \ = ListBuffer[String]()\n        for (c <- paren) {\n            if (c != '('\
    \ && c != ')')\n                stack += c\n            else if (c == ')' && stack.length\
    \ != 0) {\n                val max_level = stack.foldLeft(0l)((a, b) => math.max(a,\
    \ b.toLong))\n                stack += c\n                stack.toList\n     \
    \       } else stack += c\n        }\n        stack.toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"\
    () (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpqoh3mfr_.scala:10:33 -----------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e[36mparen\e[0m = paren_string.flatMap{_.toChar}.toList\n\
    \e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e[35mflatMap\e[0m\
    \ in \e[33mclass\e[0m \e[35mStringOps\e[0m with types\n\e[31m   |\e[0m (f: Char\
    \ => String): String\n\e[31m   |\e[0m [B](f: Char => IterableOnce[B]): IndexedSeq[B]\n\
    \e[31m   |\e[0mmatch arguments (Char => Char)\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpqoh3mfr_.scala:21:14 --------------------\e[0m\e[0m\n\e[31m21\
    \ |\e[0m        stack.toList\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m        Found:    List[\e[1m\e[31mString\e[0m]\n\e[31m   |\e[0m\
    \        Required: List[\e[1m\e[32mLong\e[0m]\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660029170
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        // Your code here\n        // You can return an Array[Long] type\
    \ here\n        val res = paren_string.grouped(2).map(_.countRight(_)).filter(x\
    \ => x > 0).map(x => x.toLong).toList\n        if (res.size > 0) {\n         \
    \   res\n        } else {\n            res\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"\
    () (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E086] Syntax Error: /tmp/tmp1e_3yc74.scala:12:46 ---------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mres\e[0m = paren_string.grouped(\e\
    [31m2\e[0m).map(_.countRight(_)).filter(\e[36mx\e[0m => x > \e[31m0\e[0m).map(\e\
    [36mx\e[0m => x.toLong).toList\n\e[31m\e[31m   |\e[0m                        \
    \                      ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                 \
    \                Wrong number of parameters, expected: 1\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp1e_3yc74.scala:12:77 ------------------------\e[0m\e\
    [0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mres\e[0m = paren_string.grouped(\e\
    [31m2\e[0m).map(_.countRight(_)).filter(\e[36mx\e[0m => x > \e[31m0\e[0m).map(\e\
    [36mx\e[0m => x.toLong).toList\n\e[31m\e[31m   |\e[0m                        \
    \                                                   ^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ > is not a member of Nothing, but could be made available as an extension method.\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might fix the problem:\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m  import Byte.byte2double\n\e[31m   |\e[0m  import\
    \ Byte.byte2float\n\e[31m   |\e[0m  import Byte.byte2int\n\e[31m   |\e[0m  import\
    \ Byte.byte2long\n\e[31m   |\e[0m  import Byte.byte2short\n\e[31m   |\e[0m  import\
    \ Char.char2double\n\e[31m   |\e[0m  import Char.char2float\n\e[31m   |\e[0m \
    \ import Char.char2int\n\e[31m   |\e[0m  import Char.char2long\n\e[31m   |\e[0m\
    \  import math.BigDecimal.RoundingMode.ValueOrdering.mkOrderingOps\n\e[31m   |\e\
    [0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp1e_3yc74.scala:12:93 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mres\e[0m = paren_string.grouped(\e\
    [31m2\e[0m).map(_.countRight(_)).filter(\e[36mx\e[0m => x > \e[31m0\e[0m).map(\e\
    [36mx\e[0m => x.toLong).toList\n\e[31m\e[31m   |\e[0m                        \
    \                                                                   ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue toLong is not a member of Nothing, but could be made\
    \ available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the\
    \ following imports might fix the problem:\n\e[31m   |\e[0m\n\e[31m   |"
  stdout: ''
  timestamp: 1660029172
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_array = (paren_string.split(\" \")).map(x => x.toLong).toList\n\
    \        val max_level = paren_array.foldLeft(0l) { (max_level, a) => if (a >\
    \ max_level) max_level else a }\n        paren_array.slice(0, max_level).reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp7kderuw7.scala:12:29\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m        paren_array.slice(\e\
    [31m0\e[0m, max_level).reverse\n\e[31m\e[31m   |\e[0m                        \
    \     ^^^^^^^^^\e[0m\n\e[31m   |\e[0m                             Found:    (max_level\
    \ : Long)\n\e[31m   |\e[0m                             Required: Int\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660029170
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        // This string representation is given by problem. \n        // The\
    \ string representation should be validated and checked before calling.\n    \
    \    // This function will throw exception if the string is not valid.\n     \
    \   val paren_array      = paren_string.split(\" \")\n        var highest_level\
    \    = 1\n        var highest_level_num = 1\n        var temp_array        = new\
    \ Array[String](0)\n        var temp              = new Array[String](0)\n   \
    \     var temp_depth         = 1\n        // Add 1 to highest level to avoid printing\
    \ extra brackets around empty string and ()\n        var paren_count       = 0\n\
    \        for (i <- 0 to paren_array.length-1) {\n            if(paren_array(i).equals(\"\
    (\")){\n                paren_count += 1\n            }\n            else if(paren_array(i).equals(\"\
    )\")){\n                paren_count -= 1\n            }\n            // This checks\
    \ if there is any closing bracket to match the opening bracket\n            if(paren_count\
    \ != 0){\n                temp_array = paren_array.slice(i+1,paren_array.length-1)\n\
    \                temp     = temp_array.toArray\n                temp_depth = temp.length\n\
    \                // If temp array is empty means all parentheses are closed \n\
    \                if(temp_depth == 0){\n                    temp_array = paren_array.slice(i+1,paren_array.length-1)\n\
    \                    temp     = temp_array.toArray\n                    temp_depth\
    \ = temp.length\n                }\n                // If current level has more\
    \ levels than previous level means it is the new highest level\n             \
    \   else if(temp_depth > highest_level){\n                    highest_level =\
    \ temp_depth\n                    highest_level_num = i\n                }\n \
    \           }\n        }\n        // For example (\"(()()) ((())) () ((())()())\"\
    ) output is List(2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong).\n        return\
    \ highest_level_num.toLong :: highest_level.toLong :: temp_array.toList\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()())\
    \ ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp1_2v06j5.scala:47:15\
    \ --------------------\e[0m\e[0m\n\e[31m47 |\e[0m        \e[33mreturn\e[0m highest_level_num.toLong\
    \ :: highest_level.toLong :: temp_array.toList\n\e[31m\e[31m   |\e[0m        \
    \       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m               Found:    List[Matchable]\n\e[31m   |\e[0m\
    \               Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660029170
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_list_string = paren_string.split(\" \").map(x => x.toLong).toList.sorted\n\
    \        var deepest_level : List[Long] = List(0l)\n        var paren_level :\
    \ List[Long] = List(0l)\n        val paren_list = paren_list_string.map(x => x.toLong)\n\
    \        for ( i <- 1 to paren_list.size - 1 ){\n            val max_level = paren_list_string.take(i).foldLeft(0l){\n\
    \                case (a,b) => (if (b > a) b else a)\n            }\n        \
    \    deepest_level = deepest_level.zip(List(max_level)).map(x => x._1 + x._2)\n\
    \            paren_level = paren_level.zip(List(max_level)).map(x => x._1 + x._2)\n\
    \            if (deepest_level.last.equals(paren_level.last)) {\n            \
    \    deepest_level = deepest_level.dropRight(1)\n                paren_level =\
    \ paren_level.dropRight(1)\n            }\n        }\n        deepest_level\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.NumberFormatException: For input string: \"(()())\"\n\tat java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:67)\n\
    \tat java.base/java.lang.Long.parseLong(Long.java:697)\n\tat java.base/java.lang.Long.parseLong(Long.java:836)\n\
    \tat scala.collection.StringOps$.toLong$extension(StringOps.scala:928)\n\tat Problem$.$anonfun$1(tmp0ic0jj4d.scala:10)\n\
    \tat scala.collection.ArrayOps$.map$extension(ArrayOps.scala:929)\n\tat Problem$.parseNestedParens(tmp0ic0jj4d.scala:10)\n\
    \tat Problem$.main(tmp0ic0jj4d.scala:28)\n\tat Problem.main(tmp0ic0jj4d.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660029176
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val result: List[Long] = Nil\n        var paren_stack: List[Long]\
    \ = Nil\n        var open_paren = 0\n        var close_paren = 0\n        var\
    \ opening_paren = 0\n        var closing_paren = 0\n        var opening_string\
    \ = \"\"\n        var closing_string = \"\"\n        var opening_count = 0\n \
    \       var closing_count = 0\n        var paren_count = 0\n        for(i <- 0\
    \ until paren_string.length) {\n            if(paren_string.charAt(i) == '(')\
    \ {\n                if(open_paren != 0) {\n                    paren_stack.push(open_paren)\n\
    \                    paren_count += 1\n                }\n                open_paren\
    \ += 1\n                opening_string += paren_string.charAt(i)\n           \
    \ }\n            if(paren_string.charAt(i) == ')') {\n                if(open_paren\
    \ == open_paren - 1) {\n                    if(opening_paren != 0) {\n       \
    \                 paren_stack.push(open_paren)\n                        paren_count\
    \ += 1\n                    }\n                    open_paren -= 1\n         \
    \           closing_string += paren_string.charAt(i)\n                }\n    \
    \            if(open_paren == 0) {\n                    if(opening_paren == 0)\
    \ {\n                        result += paren_stack.foldRight((1l.toLong,open_paren.toLong)){\
    \ case ((a,b),c) => (b,a+1) }\n                    } else {\n                \
    \        result += paren_stack.foldRight((0l.toLong,open_paren.toLong)){ case\
    \ ((a,b),c) => (a,b+1) }\n                    }\n                    result +=\
    \ paren_stack.reverse.foldRight((0l.toLong,open_paren.toLong)){ case ((a,b),c)\
    \ => (a,b+1) }\n                    result += paren_stack.foldRight((0l.toLong,open_paren.toLong)){\
    \ case ((a,b),c) => (a,b+1) }\n                }\n                open_paren -=\
    \ 1\n                closing_string += paren_string.charAt(i)\n            }\n\
    \            if(paren_string.charAt(i) == '(') {\n                opening_paren\
    \ += 1\n                opening_string += paren_string.charAt(i)\n           \
    \ }\n            if(paren_string.charAt(i) == ')') {\n                opening_paren\
    \ -= 1\n                closing_string += paren_string.charAt(i)\n           \
    \ }\n            if(paren_string.charAt(i) == '\"') {\n                opening_count\
    \ += 1\n                opening_string += paren_string.charAt(i)\n           \
    \ }\n            if(paren_string.charAt(i) == ')') {\n                closing_count\
    \ += 1\n                closing_string += paren_string.charAt(i)\n           \
    \ }\n            if(open_paren == 0) {\n                result += paren_stack.foldRight((1l.toLong,open_paren.toLong)){\
    \ case ((a,b),c) => (b,a+1) }\n                result += paren_stack.\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()())\
    \ ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp4ne5yz_3.scala:70:4 ----------------------------\e\
    [0m\e[0m\n\e[31m70 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tmp4ne5yz_3.scala:78:0 ----------------------------\e[0m\e[0m\n\e[31m78\
    \ |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp4ne5yz_3.scala:24:32 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m                    paren_stack.push(open_paren)\n\e\
    [31m\e[31m   |\e[0m                    ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ push is not a member of List[Long] - did you mean List[Long].last?\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp4ne5yz_3.scala:33:36 ------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m                        paren_stack.push(open_paren)\n\
    \e[31m\e[31m   |\e[0m                        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mvalue push is not a member of List[Long] - did you mean List[Long].last?\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmp4ne5yz_3.scala:41:31 ------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m                        result += paren_stack.foldRight((\e\
    [31m1l\e[0m.toLong,open_paren.toLong)){ \e[33mcase\e[0m ((a,b),c) => (b,a+\e[31m1\e\
    [0m) }\n\e[31m\e[31m   |\e[0m                        ^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m        value += is not a member of List[Long] - did you mean result.!=?\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4ne5yz_3.scala:41:107 -------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m                        result += paren_stack.foldRight((\e\
    [31m1l\e[0m.toLong,open_paren.toLong)){ \e[33mcase\e[0m ((a,b),c) => (b,a+\e[31m1\e\
    [0m) }\n\e[31m\e[31m   |\e[0m                                                \
    \                                                           ^\e[0m\n\e[31m   |\e\
    [0m                                                     Found:    (b : Any)\n\e\
    [31m   |\e[0m                                                     Required: Long\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-"
  stdout: ''
  timestamp: 1660029180
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val parens = paren_string.split('(')\n        if (parens.isEmpty)\
    \ {\n            return List(0l)\n        }\n        val result = mutable.ListBuffer.empty[Long]\n\
    \        var depth = 0\n        var parensLevel = 0\n        var parentheses =\
    \ 0\n        for (paren <- parens) {\n            val parensString = paren.substring(1,\
    \ paren.length-1)\n            if (parensString.contains(')')) {\n           \
    \     parentheses = parensString.length\n                parensLevel = parensString.length\n\
    \            }\n            if (parensString.contains('(')) {\n              \
    \  parentheses = parensString.length\n                parensLevel = parensString.length\n\
    \            }\n            parentheses = Math.max(parentheses, parensLevel)\n\
    \        }\n        if (parentheses > 0) {\n            depth += 1\n         \
    \   if (parentheses > 1) {\n                depth += 1\n            }\n      \
    \  }\n        result.push(depth.toLong)\n        val leftParens = paren_string.length\
    \ - (paren_string.substring(0,paren_string.length-1).length) - parens\n      \
    \  if (leftParens > 0) {\n            val rightParens = paren_string.length -\
    \ (paren_string.substring(0,paren_string.length-1).length)\n            result.push(depth.toLong)\n\
    \            result.push(leftParens.toLong)\n            result.push(rightParens.toLong)\n\
    \        }\n        result.toList\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpv9rkmrp3.scala:14:21 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E134] Type Error: /tmp/tmpv9rkmrp3.scala:37:104 ----------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e[36mleftParens\e[0m = paren_string.length\
    \ - (paren_string.substring(\e[31m0\e[0m,paren_string.length-\e[31m1\e[0m).length)\
    \ - parens\n\e[31m\e[31m   |\e[0m                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m None of the overloaded alternatives of \e[33mmethod\e[0m\
    \ \e[35m-\e[0m in \e[33mclass\e[0m \e[35mInt\e[0m with types\n\e[31m   |\e[0m\
    \  (x: Double): Double\n\e[31m   |\e[0m  (x: Float): Float\n\e[31m   |\e[0m  (x:\
    \ Long): Long\n\e[31m   |\e[0m  (x: Int): Int\n\e[31m   |\e[0m  (x: Char): Int\n\
    \e[31m   |\e[0m  (x: Short): Int\n\e[31m   |\e[0m  (x: Byte): Int\n\e[31m   |\e\
    [0m match arguments ((parens : Array[String]))\n2 errors found\n"
  stdout: ''
  timestamp: 1660029179
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        var max_level = Long.MinValue\n        var level_num = 0\n      \
    \  var paren_count = 0\n        var paren_stack = List[Long]()\n        for {\n\
    \            c <- paren_string\n        } yield {\n            val level_num =\
    \ c.toLong\n            if (level_num > max_level) {\n                max_level\
    \ = level_num\n            }\n            if (level_num == 0 && paren_stack.isEmpty)\
    \ {\n                paren_stack = paren_stack + level_num\n            } else\
    \ {\n                val paren_level = paren_stack.length - 1\n              \
    \  val level_to_remove = paren_stack.take(paren_level).toList\n              \
    \  val paren_end_level = level_num - paren_level\n                val new_paren_level\
    \ = paren_stack.take(paren_end_level).toList\n                paren_stack = paren_stack\
    \ - level_to_remove + new_paren_level\n            }\n            paren_count\
    \ += 1\n        }\n        paren_stack.drop(max_level).reverse\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((()))\
    \ () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmppfu7elgk.scala:22:42 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m                paren_stack = paren_stack + level_num\n\
    \e[31m\e[31m   |\e[0m                              ^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mvalue + is not a member of List[Long], but could be made available as\
    \ an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports\
    \ might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e[0m  import\
    \ math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import math.Numeric.Implicits.infixNumericOps\n\
    \e[31m   |\e[0m\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmppfu7elgk.scala:27:55\
    \ --------------------\e[0m\e[0m\n\e[31m27 |\e[0m                \e[33mval\e[0m\
    \ \e[36mnew_paren_level\e[0m = paren_stack.take(paren_end_level).toList\n\e[31m\e\
    [31m   |\e[0m                                                       ^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                      Found:    (paren_end_level\
    \ : Long)\n\e[31m   |\e[0m                                      Required: Int\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmppfu7elgk.scala:28:42\
    \ ------------------------\e[0m\e[0m\n\e[31m28 |\e[0m                paren_stack\
    \ = paren_stack - level_to_remove + new_paren_level\n\e[31m\e[31m   |\e[0m   \
    \                           ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue - is not\
    \ a member of List[Long], but could be made available as an extension method.\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might make progress\
    \ towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmppfu7elgk.scala:32:25 --------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        paren_stack.drop(max_level).reverse\n\e[31m\e\
    [31"
  stdout: ''
  timestamp: 1660029187
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        def getMaxNesting(paren_string : String, group: List[Char], nesting\
    \ : Int) : List[Long] = {\n            if(paren_string.isEmpty) return List(nesting)\n\
    \            if(paren_string.charAt(0) == '(') {\n                val new_group:\
    \ List[Char] = paren_string.drop(1)\n                val nesting_level : Int =\
    \ group.size + 1\n                val max_nesting = getMaxNesting(new_group, group,\
    \ nesting_level)\n                val new_nesting = if (nesting_level > nesting)\
    \ nesting_level else nesting\n                val new_group: List[Char] = new_group\
    \ ++ max_nesting.map(x => group(x)).tail\n                getMaxNesting(new_group,\
    \ new_nesting, nesting + 1)\n            }\n            else List()\n        }\n\
    \n        // First split the input string into the group of parentheses.\n   \
    \     val groups: List[Char] = paren_string.chars().filter(!(_ == '(')).map(_.asInstanceOf[Char]).toList\n\
    \n        // Recursively call this function to get the max nesting of each group.\n\
    \        val result = getMaxNesting(paren_string, groups, 0)\n\n        // Convert\
    \ each long value to String and then to a list.\n        val groups_list: List[String]\
    \ = result.map(_.toString).toList\n\n        // Convert each String back to a\
    \ Long.\n        val groups_list_long: immutable.List[Long] = groups_list.map(_.toLong).toList\n\
    \n        // Return the list\n        groups_list_long\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"\
    () (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp1wn5xas3.scala:17:20 ---------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m                \e[33mval\e[0m \e[36mnew_group\e[0m:\
    \ \e[35mList\e[0m[\e[35mChar\e[0m] = new_group ++ max_nesting.map(\e[36mx\e[0m\
    \ => group(x)).tail\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mnew_group is already defined as \e[33mvalue\e[0m \e[35mnew_group\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmp1wn5xas3.scala:13:61 --------------------\e[0m\e[0m\n\
    \e[31m13 |\e[0m                \e[33mval\e[0m \e[36mnew_group\e[0m: \e[35mList\e\
    [0m[\e[35mChar\e[0m] = paren_string.drop(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m\
    \                                            ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                                            Found:    String\n\e[31m\
    \   |\e[0m                                            Required: List[Char]\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp1wn5xas3.scala:15:48\
    \ --------------------\e[0m\e[0m\n\e[31m15 |\e[0m                \e[33mval\e[0m\
    \ \e[36mmax_nesting\e[0m = getMaxNesting(new_group, group, nesting_level)\n\e\
    [31m\e[31m   |\e[0m                                                ^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                      Found:    (new_group\
    \ : List[Char])\n\e[31m   |\e[0m                                      Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp1wn5xas3.scala:18:30\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m                getMaxNesting(new_group,\
    \ new_nesting, nesting + \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m                \
    \              ^^^^^^^^^\e[0m\n\e[31m   |\e[0m                              Found:\
    \    (new_group : List[Char])\n\e[31m   |\e[0m                              Required:\
    \ String\n\e[31m   |\e[0m\n\e["
  stdout: ''
  timestamp: 1660029187
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        // This variable represents the current level.\n        var current_level\
    \ = 0\n        // This variable will hold the maximum nesting level of parentheses\
    \ encountered.\n        var max_nesting_level = 0\n\n        // For each character\
    \ in the string\n        for (c <- paren_string.toCharArray) {\n            //\
    \ Increment the nesting level for character\n            if (c == '(') {\n   \
    \             current_level += 1\n            } else if (c == ')') {\n       \
    \         current_level -= 1\n            }\n\n            // Update the maximum\
    \ nesting level when current level is updated.\n            if (current_level\
    \ > max_nesting_level) {\n                max_nesting_level = current_level\n\
    \            }\n        }\n\n        // This list will be returned in the end.\n\
    \        var returned_list : List[Long] = Nil\n\n        // For each character\
    \ in the string\n        for (c <- paren_string.toCharArray) {\n            //\
    \ Update the list with current level if it is greater than the maximum nesting\
    \ level so far.\n            if (current_level > max_nesting_level) {\n      \
    \          returned_list = returned_list :+ current_level\n            }\n   \
    \     }\n\n        // Return list\n        return returned_list\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((()))\
    \ () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmprvc9uelq.scala:45)\n\tat Problem.main(tmprvc9uelq.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660029188
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        var level = 0\n        val max_levels = new mutable.HashMap[String,\
    \ Int]()\n        paren_string.split(\" \").toList.foreach { x =>\n          \
    \  if(max_levels.containsKey(x)) {\n                max_levels.update(x, max_levels(x)\
    \ + 1)\n            } else {\n                max_levels.update(x, 1)\n      \
    \      }\n        }\n        max_levels.foreach { case (k, v) =>\n           \
    \ if(level < v) {\n                level = v\n            }\n        }\n     \
    \   level.toList.sortWith(_ < _).reverse.flatten.toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"\
    () (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpat5ajz7r.scala:11:29 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mmax_levels\e[0m = \e[33mnew\e\
    [0m mutable.HashMap[\e[35mString\e[0m, \e[35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m\
    \                             ^^^^^^^\e[0m\n\e[31m   |\e[0m                  \
    \           Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpat5ajz7r.scala:24:14 ------------------------\e[0m\e[0m\n\e[31m24 |\e\
    [0m        level.toList.sortWith(_ < _).reverse.flatten.toList\n\e[31m\e[31m \
    \  |\e[0m        ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        value toList is not\
    \ a member of Int - did you mean Int.toInt?\n2 errors found\n"
  stdout: ''
  timestamp: 1660029184
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        // Convert string to list of strings with each string representing\
    \ a group inside parentheses.\n        // E.g. \"(()())\" -> List(\"\", \"\",\
    \ \"\", \"(()())\", \"(())\", \"\", \"\", \"(())()\")\n        val group_list\
    \ = paren_string.split(\"\\\\s+\").map(s => if (s.matches(\"\\\\(\")) \"(\" +\
    \ s + \")\" else s)\n        val group_map: Map[String, List[Long]] = group_list.foldLeft(Map[String,\
    \ List[Long]]()) {\n            case(map, elem) => map + (elem -> List(map.getOrElse(elem,\
    \ 0l).getOrElse(0l) + 1))\n        }\n        val max_level = group_map.values.toList.max\n\
    \        // Convert map to list of tuples with each tuple representing a level\
    \ of nesting\n        val level_of_interest = group_map.values.map {\n       \
    \     case List(level) => (level.toLong, level.toLong)\n        }\n        //\
    \ Get all possible combinations of the levels corresponding to the maximum number\
    \ of levels of nesting.\n        // E.g. max_level = 3 so there are only 4 unique\
    \ combinations of levels of nesting:\n        // [(1, 2), (2, 3), (3, 1), (3,\
    \ 2)]\n        val all_levels = level_of_interest.permutations\n        // Filter\
    \ out all combinations which have more than one level of nesting.\n        val\
    \ levels_of_interest = all_levels.filter { x => x.size > 1 }\n        // Get the\
    \ max level of nesting among all levels of nesting\n        val max_level = levels_of_interest.toList.max\n\
    \        // Combine all levels of nesting into tuples for given maximum level\
    \ of nesting.\n        val level_of_interest_tuple = levels_of_interest.map {\n\
    \            case (level, others) => ((max_level - level).toLong, others)\n  \
    \      }\n        // Find all possible combinations of these tuples corresponding\
    \ to the maximum level of nesting\n        val level_of_interest_tuple_combinations\
    \ = level_of_interest_tuple.combinations(max_level)\n        // Filter to combinations\
    \ with same level of nesting.\n        val level_of_interest_tuple_combinations_filtered\
    \ = level_of_interest_tuple_combinations.filter { x => x.size == 1 }\n       \
    \ // Get the maximum level of nesting among these combinations of levels of nesting\n\
    \        val max_level_of_nesting = level_of_interest_tuple_combinations_filtered.toList.max\n\
    \        // Convert combinations of levels of nesting into lists of tuples of\
    \ levels of nesting\n        val level_of_interest_tuple_combinations_filtered_tuple\
    \ = level_of_interest_tuple_combinations_\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpmcmruxg3.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mmax_level\e[0m = levels_of_interest.toList.max\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mmax_level is already defined as \e[33mvalue\e[0m \e[35mmax_level\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmpmcmruxg3.scala:14:75 ------------------------\e[0m\e[0m\n\
    \e[31m14 |\e[0m            \e[33mcase\e[0m(map, elem) => map + (elem -> List(map.getOrElse(elem,\
    \ \e[31m0l\e[0m).getOrElse(\e[31m0l\e[0m) + \e[31m1\e[0m))\n\e[31m\e[31m   |\e\
    [0m                                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                            value getOrElse is not a member\
    \ of Matchable\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpmcmruxg3.scala:24:43\
    \ ------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e\
    [36mall_levels\e[0m = level_of_interest.permutations\n\e[31m\e[31m   |\e[0m  \
    \                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \           value permutations is not a member of Iterable[(Long, Long)]\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpmcmruxg3.scala:40:66 ------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m        \e[33mval\e[0m \e[36mlevel_of_interest_tuple_combinations_filtered_tuple\e\
    [0m = level_of_interest_tuple_combinations_\n\e[31m\e[31m   |\e[0m           \
    \                                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                        Not found: level_of_interest_tuple_combinations_\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpmcmruxg3.scala:41:5\
    \ ---------------------\e[0m\e[0m\n\e[31m41 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation avail"
  stdout: ''
  timestamp: 1660029187
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        var depth = 0\n        var paren_count : List[Long] = Nil\n     \
    \   val paren_counts = mutable.HashMap[String, Long]()\n        paren_string.split(\"\
    \\\\s+\").foreach(_.toUpperCase).foreach(p => {\n            val key = p.toString\n\
    \            val count = paren_counts.getOrElse(key, 0) + 1\n            paren_counts\
    \ += (key -> count)\n        })\n        paren_count.foreach(p => depth += p._1)\n\
    \        paren_count.reverse.foreach(p => depth += p._2)\n        val result:\
    \ List[Long] = paren_count.foldLeft(0)((a, b) => b + a).toList.reverse\n     \
    \   result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmps93fqn7q.scala:12:27 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mparen_counts\e[0m = mutable.HashMap[\e\
    [35mString\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                   \
    \        ^^^^^^^\e[0m\n\e[31m   |\e[0m                           Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmps93fqn7q.scala:13:58\
    \ ------------------------\e[0m\e[0m\n\e[31m13 |\e[0m        paren_string.split(\e\
    [31m\"\\\\s+\"\e[0m).foreach(_.toUpperCase).foreach(\e[36mp\e[0m => {\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        value foreach is not a member of Unit\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmps93fqn7q.scala:18:39 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        paren_count.foreach(\e[36mp\e[0m => depth +=\
    \ p._1)\n\e[31m\e[31m   |\e[0m                                 ^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                  value += is not a member of Int - did you mean\
    \ Int.!=?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmps93fqn7q.scala:18:44\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        paren_count.foreach(\e\
    [36mp\e[0m => depth += p._1)\n\e[31m\e[31m   |\e[0m                          \
    \                ^^^^\e[0m\n\e[31m   |\e[0m                                  \
    \      value _1 is not a member of Long\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmps93fqn7q.scala:19:47 ------------------------\e[0m\e[0m\n\e[31m19 |\e\
    [0m        paren_count.reverse.foreach(\e[36mp\e[0m => depth += p._2)\n\e[31m\e\
    [31m   |\e[0m                                         ^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                  value += is not a member of Int - did you mean Int.!=?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmps93fqn7q.scala:19:52 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        paren_count.reverse.foreach(\e[36mp\e[0m => depth\
    \ += p._2)\n\e[31m\e[31m   |\e[0m                                            \
    \      ^^^^\e[0m\n\e[31m   |\e[0m                                        va"
  stdout: ''
  timestamp: 1660029191
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        // Split the string into group of strings with parens and get the\
    \ deepest level of nesting of parens.\n        val groups = paren_string.split(\"\
    \ \").filter( _ != \"()\" )\n        val deepestLevel = groups.map(_.length).max\n\
    \        val depthToParenMap = groups.length zip (0 until deepestLevel)\n    \
    \    val maxLevels = groups.map( _.length).max\n        val depthToMaxLevelMap\
    \ = groups.length zip 0 toList\n        val maxLevelsNestingMap = depthToMaxLevelMap\
    \ map {\n            case (length, level) =>\n                val maxLevel = length\
    \ match {\n                    case n if n > 0 => n\n                    case\
    \ _ => -1\n                }\n                maxLevel\n        }\n        //\
    \ Build max levels mapping from parens to max level of nesting in the group.\n\
    \        val maxLevels = groups.map(_.length).max\n        val maxLevelsNestingMap\
    \ = depthToMaxLevelMap map {\n            case (length, level) =>\n          \
    \      val maxLevel = length match {\n                    case n if n > 0 => n\n\
    \                    case _ => -1\n                }\n                maxLevel\n\
    \        }\n        // Build the mappings needed to compute maxLevelsNesting.\n\
    \        val maxLevelsNestingMap = depthToMaxLevelMap map {\n            case\
    \ (length, level) =>\n                val maxLevel = length match {\n        \
    \            case n if n > 0 => n\n                    case _ => -1\n        \
    \        }\n                maxLevel\n        }\n        // Build the mappings\
    \ needed to compute maxLevelsNesting.\n        val maxLevelsNestingMap = depthToMaxLevelMap\
    \ map {\n            case (length, level) =>\n                val maxLevel = length\
    \ match {\n                    case n if n > 0 => n\n                    case\
    \ _ => -1\n                }\n                maxLevel\n        }\n        val\
    \ maxLevelsNesting = maxLevelsNestingMap map {\n            case (maxLevel, maxLevelNesting)\
    \ =>\n                if (maxLevelNesting == -1) {\n                    maxLevel\n\
    \                } else {\n                    maxLevel + maxLevelNesting\n  \
    \              }\n        }\n        // Build the mappings needed to compute maxLevelsNesting.\n\
    \        val maxLevelsNestingMap = depthToMaxLevelMap map {\n            case\
    \ (length, level) =>\n                val maxLevel = length match {\n        \
    \            case n if n > 0 => n\n                    case _ => -1\n        \
    \        }\n                maxLevel\n        }\n        // Build the mappings\
    \ needed to compute maxLevelsNe\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpnf7fqka3.scala:15:59 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mdepthToMaxLevelMap\e[0m\
    \ = groups.length zip \e[31m0\e[0m toList\n\e[31m\e[31m   |\e[0m             \
    \                                              ^\e[0m\n\e[31m   |\e[0m       \
    \                   expression expected but \e[31mend of statement\e[0m found\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpnf7fqka3.scala:25:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmaxLevels\e[0m = groups.map(_.length).max\n\e[31m\e[31m   |\e[0m     \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmaxLevels is\
    \ already defined as \e[33mvalue\e[0m \e[35mmaxLevels\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpnf7fqka3.scala:26:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmaxLevelsNestingMap\e[0m = depthToMaxLevelMap map {\n\e[31m\e[31m   |\e\
    [0m        ^\e[0m\n\e[31m   |\e[0mmaxLevelsNestingMap is already defined as \e\
    [33mvalue\e[0m \e[35mmaxLevelsNestingMap\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m27 |\e[0m            \e[33mcase\e[0m (length, level) =>\n\e[31m28 |\e[0m\
    \                \e[33mval\e[0m \e[36mmaxLevel\e[0m = length \e[33mmatch\e[0m\
    \ {\n\e[31m29 |\e[0m                    \e[33mcase\e[0m n \e[33mif\e[0m n > \e\
    [31m0\e[0m => n\n\e[31m30 |\e[0m                    \e[33mcase\e[0m _ => -\e[31m1\e\
    [0m\n\e[31m31 |\e[0m                }\n\e[31m32 |\e[0m                maxLevel\n\
    \e[31m33 |\e[0m        }\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpnf7fqka3.scala:35:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmaxLevelsNestingMap\e[0m = depthToMaxLevelMap map {\n\e[31m\e[31m   |\e\
    [0m        ^\e[0m\n\e[31m   |\e[0mmaxLevelsNestingMap is already defined as \e\
    [33mvalue\e[0m \e[35mmaxLevelsNestingMap\e["
  stdout: ''
  timestamp: 1660029191
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        paren_string.split(\"\\\\s+\")\n            .foldLeft(List[Long]())((nested,\
    \ x) => {\n                if (nested.isEmpty) {\n                    nested :+\
    \ x.toLong\n                } else {\n                    var last_level = nested.last\n\
    \                    var current_level = x.toLong\n                    while (current_level\
    \ > last_level) {\n                        nested :+ current_level\n         \
    \               current_level -= 1\n                    }\n                  \
    \  while (current_level < last_level) {\n                        nested :+ current_level\n\
    \                        current_level += 1\n                    }\n         \
    \       }\n            })\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpeltloust.scala:21:20\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m                    \e[33mwhile\e\
    [0m (current_level < last_level) {\n\e[31m\e[31m   |\e[0m                    ^\e\
    [0m\n\e[31m   |\e[0m                    Found:    Unit\n\e[31m   |\e[0m      \
    \              Required: List[Long]\n\e[31m22 |\e[0m                        nested\
    \ :+ current_level\n\e[31m23 |\e[0m                        current_level += \e\
    [31m1\e[0m\n\e[31m24 |\e[0m                    }\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660029188
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        // Use a hashmap to store the count of left parenthesis \n      \
    \  val parenMap = mutable.HashMap.empty[Char, Int]\n        for (i <- 0 to paren_string.length\
    \ - 1) {\n            if (paren_string(i) == '(') parenMap('(') += 1\n       \
    \     else if (paren_string(i) == ')') parenMap(')') += 1\n            else parenMap(paren_string(i))\n\
    \        }\n        // Find deepest level of parenthesis\n        var maxLevel\
    \ = 0\n        val levels = parenMap.keys\n        levels.foreach { level =>\n\
    \            if (level > maxLevel) maxLevel = level\n        }\n        val maxCount\
    \ = maxLevel * parenMap(')')\n        // Find the max depth\n        var maxCount\
    \ = maxLevel * parenMap(')')\n        var count = 0\n        val levels = parenMap.keys\n\
    \        levels.foreach { level =>\n            if (level == maxLevel) count +=\
    \ parenMap(')')\n            else if (level == maxLevel - 1) {\n             \
    \   count += maxCount\n            }\n        }\n        val maxDepth = count\
    \ * maxCount\n        val list = List[Long](maxDepth.toLong).toList\n        return\
    \ list\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp1vjq_tav.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mvar\e[0m \e[36mmaxCount\e[0m = maxLevel\
    \ * parenMap(\e[31m')'\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxCount is already defined as \e[33mvalue\e[0m \e[35mmaxCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp1vjq_tav.scala:27:12 ---------------------------\e[0m\e[0m\n\e\
    [31m27 |\e[0m        \e[33mval\e[0m \e[36mlevels\e[0m = parenMap.keys\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mlevels is\
    \ already defined as \e[33mvalue\e[0m \e[35mlevels\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp1vjq_tav.scala:11:23\
    \ ------------------------\e[0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e\
    [36mparenMap\e[0m = mutable.HashMap.empty[\e[35mChar\e[0m, \e[35mInt\e[0m]\n\e\
    [31m\e[31m   |\e[0m                       ^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \                 Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660029184
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        if (paren_string.isEmpty) List(1L)\n        else paren_string.foldLeft[List[Long]](List[Long](1L))\
    \ { case(acc, p) =>\n            val paren_count = p.count { x => x == '(' }\n\
    \            val deepest_level = paren_count match {\n                case 0 =>\
    \ 1\n                case x => paren_count - 1\n            }\n            acc\
    \ :+ deepest_level\n        }\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp47zx6_qt.scala:12:32 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m            \e[33mval\e[0m \e[36mparen_count\e[0m = p.count\
    \ { \e[36mx\e[0m => x == \e[31m'('\e[0m }\n\e[31m\e[31m   |\e[0m             \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m             value count is not\
    \ a member of Char - did you mean p.toInt?\n1 error found\n"
  stdout: ''
  timestamp: 1660029189
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val parens = paren_string.split(\" \")\n        val parens_size =\
    \ parens.size\n        val parens_list_with_paren = mutable.ListBuffer(parens_size)\n\
    \        var count = 0\n        var parens_index = -1\n        for(i <- 0 until\
    \ parens_size) {\n            if(parens(i) == \"(\") {\n                parens_list_with_paren\
    \ += parens_index\n                count += 1\n            }\n            else\
    \ if(parens(i) == \")\") {\n                parens_index -= count\n          \
    \      count -= 1\n            }\n        }\n        val parens_list_with_paren_2\
    \ = parens_list_with_paren.toList\n        var result: List[Long] = Nil\n    \
    \    if(parens_list_with_paren_2.nonEmpty) {\n            val max_count = Math.max(parens_list_with_paren_2.last,\
    \ parens_list_with_paren_2.last)\n            for((parens_index, count) <- 0 until\
    \ parens_list_with_paren_2.reverse.zip(parens_list_with_paren_2.tail.toList))\
    \ {\n                val max_count_index = max_count - count\n               \
    \ val max_count_index = max_count_index.toLong\n                if(max_count_index\
    \ != 0) {\n                    result = parens_list_with_paren.take(max_count_index)\n\
    \                }\n            }\n        }\n        return result.reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpeaekclll.scala:12:37 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mparens_list_with_paren\e\
    [0m = mutable.ListBuffer(parens_size)\n\e[31m\e[31m   |\e[0m                 \
    \                    ^^^^^^^\e[0m\n\e[31m   |\e[0m                           \
    \          Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660029185
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        if (paren_string.isEmpty) Nil\n        else paren_string.split(\"\
    \ \").map(x => parseNestedParens(x)).foldLeft(Nil: List[Long])(_ ++ _)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()())\
    \ ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.StackOverflowError\n\tat java.base/java.lang.reflect.Array.newInstance(Array.java:78)\n\
    \tat scala.reflect.ClassTag$GenericClassTag.newArray(ClassTag.scala:149)\n\tat\
    \ scala.collection.ArrayOps$.map$extension(ArrayOps.scala:925)\n\tat Problem$.parseNestedParens(tmpiaig484i.scala:11)\n\
    \tat Problem$.parseNestedParens$$anonfun$1(tmpiaig484i.scala:11)\n\tat scala.collection.ArrayOps$.map$extension(ArrayOps.scala:929)\n\
    \tat Problem$.parseNestedParens(tmpiaig484i.scala:11)\n\tat Problem$.parseNestedParens$$anonfun$1(tmpiaig484i.scala:11)\n\
    \tat scala.collection.ArrayOps$.map$extension(ArrayOps.scala:929)\n\tat Problem$.parseNestedParens(tmpiaig484i.scala:11)\n\
    \tat Problem$.parseNestedParens$$anonfun$1(tmpiaig484i.scala:11)\n\tat scala.collection.ArrayOps$.map$extension(ArrayOps.scala:929)\n\
    \tat Problem$.parseNestedParens(tmpiaig484i.scala:11)\n\tat Problem$.parseNestedParens$$anonfun$1(tmpiaig484i.scala:11)\n\
    \tat scala.collection.ArrayOps$.map$extension(ArrayOps.scala:929)\n\tat Problem$.parseNestedParens(tmpiaig484i.scala:11)\n\
    \tat Problem$.parseNestedParens$$anonfun$1(tmpiaig484i.scala:11)\n\tat scala.collection.ArrayOps$.map$extension(ArrayOps.scala:929)\n\
    \tat Problem$.parseNestedParens(tmpiaig484i.scala:11)\n\tat Problem$.parseNestedParens$$anonfun$1(tmpiaig484i.scala:11)\n\
    \tat scala.collection.ArrayOps$.map$extension(ArrayOps.scala:929)\n\tat Problem$.parseNestedParens(tmpiaig484i.scala:11)\n\
    \tat Problem$.parseNestedParens$$anonfun$1(tmpiaig484i.scala:11)\n\tat scala.collection.ArrayOps$.map$extension(ArrayOps.scala:929)\n\
    \tat Problem$.parseNestedParens(tmpiaig484i.scala:11)\n\tat Problem$.parseNestedParens$$anonfun$1(tmpiaig484i.scala:11)\n\
    \tat scala.collection.ArrayOps$.map$extension(ArrayOps.scala:929)\n\tat Problem$.parseNestedParens(tmpiaig484i.scala:11)\n\
    \tat Problem$.parseNestedParens$$anonfun$1(tmpiaig484i.scala:11)\n\tat scala.collection.ArrayOps$.map$extension(ArrayOps.scala:929)\n\
    \tat Problem$.parseNestedParens(tmpiaig484i.scala:11)\n\tat Problem$.parseNestedParens$$anonfun$1(tmpiaig484i.scala:11)\n\
    \tat scala.collection.ArrayOps$.map$"
  stdout: ''
  timestamp: 1660029194
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        // Add extra space to fix issues with matching with regex patterns\n\
    \        paren_string = paren_string.replaceAll(\"(.*) \", \"($1) \")\n      \
    \  // Extract the numbers of nested parens\n        var nested_parens = 0\n  \
    \      var nested_parentheses_set: mutable.Set[String] = mutable.Set()\n     \
    \   for (n <- 1 to paren_string.length()) {\n            // Use regex pattern\
    \ to match parens with proper number of nesting\n            if (paren_string.substring(n\
    \ - 1, n).matches(\"(\\\\()*(\\\\()+(\\\\())+(\\\\()*(\\\\))+\")){\n         \
    \       // If this group has proper number of nested parentheses, add it to the\
    \ set\n                if (paren_string.substring(n - 1, n).length() != nested_parens)\
    \ {\n                    nested_parentheses_set.clear()\n                    nested_parentheses_set\
    \ += paren_string.substring(n - 1, n).replaceAll(\"(.*) \", \"($1) \")\n     \
    \           }\n                // If this group has less parentheses, increment\
    \ the number of nested parens\n                else {\n                    nested_parens++\n\
    \                }\n            }\n        }\n        // Convert set into List\
    \ in descending order\n        val nested_parentheses = nested_parentheses_set.map(_.length)\n\
    \        nested_parentheses.sortBy(-_).reverse.headOption.toList\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((()))\
    \ () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpv6wc7_bq.scala:25:35 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m                    nested_parens++\n\e[31m\e[31m   |\e\
    [0m                                   ^\e[0m\n\e[31m   |\e[0m                \
    \                   expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E052] Type Error: /tmp/tmpv6wc7_bq.scala:11:21 -----------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        paren_string = paren_string.replaceAll(\e[31m\"\
    (.*) \"\e[0m, \e[31m\"($1) \"\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Reassignment to val paren_string\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpv6wc7_bq.scala:14:36 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mvar\e[0m \e[36mnested_parentheses_set\e\
    [0m: mutable.Set[\e[35mString\e[0m] = mutable.Set()\n\e[31m\e[31m   |\e[0m   \
    \                                 ^^^^^^^\e[0m\n\e[31m   |\e[0m              \
    \                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpv6wc7_bq.scala:14:58 ------------------------\e[0m\e\
    [0m\n\e[31m14 |\e[0m        \e[33mvar\e[0m \e[36mnested_parentheses_set\e[0m:\
    \ mutable.Set[\e[35mString\e[0m] = mutable.Set()\n\e[31m\e[31m   |\e[0m      \
    \                                                    ^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                                                      Not found: mutable\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660029186
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        // Initialize our stack\n        val stack : Stack[(Int, (Int, (Int,\
    \ (Int, Int))))] = Stack[(Int, (Int, (Int, (Int, Int))))]()\n        // Initialize\
    \ our result\n        val result : MutableList[Long] = MutableList()\n       \
    \ // Parse the input string\n        val string_array : Array[String] = paren_string.split(\"\
    \ \").toArray\n        // For each group of parentheses\n        for (string_group\
    \ <- string_array) {\n            val group_length : Int = string_group.length\n\
    \            // If this group is empty, just skip it\n            if (group_length\
    \ == 0) continue\n            // Else, push it to our stack\n            val par_count\
    \ = (string_group.charAt(0) == '(' ? 0 : 1)\n            val par_level = par_count\n\
    \            var par_level_in_depth = 0\n            var par_level_in_group =\
    \ 0\n            var par_depth = 0\n            // For each character in the group\n\
    \            for (char_val <- string_group) {\n                // If this is the\
    \ open parenthesis, push it to our stack\n                if (char_val == '(')\
    \ stack.push((par_count, par_level))\n                // If this is the close\
    \ parenthesis, pop out the stack\n                else if (char_val == ')') {\n\
    \                    // If this is the deepest level of nesting of parenthesis\n\
    \                    if (par_level == par_depth) {\n                        //\
    \ Keep track of the level of nesting of the group\n                        par_level_in_group\
    \ = par_level_in_depth\n                        // If this group is at the maximum\
    \ level of nesting, add the depth of this group to the result\n              \
    \          if (par_level_in_depth == par_level) result += (par_depth)\n      \
    \              }\n                    // Else, pop out the stack\n           \
    \         else {\n                        stack.pop()\n                      \
    \  par_level = stack.last._2\n                        par_depth = stack.last._1\n\
    \                        par_level_in_depth = par_level\n                    }\n\
    \                }\n                // If this character is equal to the current\
    \ level of nesting, increase the level of nesting of this group\n            \
    \    else if (par_level == par_depth + 1) {\n                    par_depth +=\
    \ 1\n                }\n                // Else, ignore this character as it's\
    \ not a closing parenthesis\n            }\n        }\n        // Return the result\n\
    \        return result.toList\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp6ahi0bba.scala:13:21 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m : \e[35mMutableList\e\
    [0m[\e[35mLong\e[0m] = MutableList()\n\e[31m\e[31m   |\e[0m                  \
    \   ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found: type MutableList\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp6ahi0bba.scala:13:41\
    \ ------------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m : \e[35mMutableList\e[0m[\e[35mLong\e[0m] = MutableList()\n\e\
    [31m\e[31m   |\e[0m                                         ^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                         Not found: MutableList\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp6ahi0bba.scala:20:35\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m            \e[33mif\e[0m\
    \ (group_length == \e[31m0\e[0m) continue\n\e[31m\e[31m   |\e[0m             \
    \                      ^^^^^^^^\e[0m\n\e[31m   |\e[0m                        \
    \           Not found: continue\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmp6ahi0bba.scala:22:59 ------------------------\e[0m\e[0m\n\e[31m22 |\e\
    [0m            \e[33mval\e[0m \e[36mpar_count\e[0m = (string_group.charAt(\e[31m0\e\
    [0m) == \e[31m'('\e[0m ? \e[31m0\e[0m : \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m \
    \                                                      ^^^^^\e[0m\n\e[31m   |\e\
    [0m                                         value ? is not a member of Char\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp6ahi0bba.scala:30:60 --------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m                \e[33mif\e[0m (char_val == \e[31m'('\e\
    [0m) stack.push((par_count, par_level))\n\e[31m\e[31m   |\e[0m               \
    \                                             ^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                                      Found:    (par_level : Int)\n\e[31m   |\e\
    [0m            "
  stdout: ''
  timestamp: 1660029192
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        // Initialize result with maximum level of nesting.\n        var\
    \ result : List[Long] = Nil\n        // Iterate over the string character by character.\
    \ Each time we meet a closing parentheses, we update result list.\n        var\
    \ opening_paren_count : Long = 1\n        for (cntr : Int <- 0 until paren_string.length)\
    \ {\n            // Check if character is closing parenthesis.\n            if\
    \ (paren_string(cntr) == '(') {\n                // Update nesting level.\n  \
    \              opening_paren_count += 1\n            }\n            // If character\
    \ is closing parentheses, check if nesting level is greater than the result.\n\
    \            if (paren_string(cntr) == ')') {\n                // If nesting level\
    \ is greater than the result and current character is opening parentheses, update\
    \ result.\n                if (opening_paren_count > result.length && paren_string(cntr)\
    \ == '(') {\n                    result = result :+ opening_paren_count\n    \
    \            }\n                // Reset nesting level.\n                opening_paren_count\
    \ = 1\n            }\n        }\n        // Return a list of longs.\n        result\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpilhxvkmf.scala:34)\n\tat Problem.main(tmpilhxvkmf.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660029193
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        // Create a string tree data structure to store the group strings\
    \ and corresponding level of nesting.\n        val paren_str_tree = new mutable.TreeMap[String,\
    \ List[Long]]()\n        // Iterate over the string and add elements to the tree\
    \ map. Each element is a list containing the group string\n        // and a level\
    \ of nesting.\n        paren_string.foreach {\n            element => {\n    \
    \            if(element.nonEmpty) {\n                    val group_string = element\n\
    \                    val group_list_list = paren_str_tree.getOrElseUpdate(group_string,\
    \ List[Long]())\n                    group_list_list ::= 0l.toLong\n         \
    \       }\n            }\n        }\n        // Get the deepest level of nesting.\n\
    \        val deepest_level_list = paren_str_tree.values.max\n        // Convert\
    \ the level of nesting lists to Long.\n        val deepest_level_list = deepest_level_list.map(_.toLong)\n\
    \        // Return the list of levels.\n        return deepest_level_list\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp5cbrhf_y.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mdeepest_level_list\e[0m\
    \ = deepest_level_list.map(_.toLong)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mdeepest_level_list is already defined as \e[33mvalue\e[0m\
    \ \e[35mdeepest_level_list\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp5cbrhf_y.scala:11:33 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mparen_str_tree\e[0m = \e\
    [33mnew\e[0m mutable.TreeMap[\e[35mString\e[0m, \e[35mList\e[0m[\e[35mLong\e[0m]]()\n\
    \e[31m\e[31m   |\e[0m                                 ^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                                 Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp5cbrhf_y.scala:16:27 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m                \e[33mif\e[0m(element.nonEmpty) {\n\e\
    [31m\e[31m   |\e[0m                   ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \                  value nonEmpty is not a member of Char\n3 errors found\n"
  stdout: ''
  timestamp: 1660029191
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        paren_string.split(\"\\\\s+\").map(x => if (x == \"(\" || x == \"\
    [\"){0l.toLong}\n                                        else if (x == \")\" ||\
    \ x == \"]\"){-1l.toLong}\n                                        else {1l.toLong}).max\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpl_g8wbs9.scala:10:8\
    \ ---------------------\e[0m\e[0m\n\e[31m10 |\e[0m        paren_string.split(\e\
    [31m\"\\\\s+\"\e[0m).map(\e[36mx\e[0m => \e[33mif\e[0m (x == \e[31m\"(\"\e[0m\
    \ || x == \e[31m\"[\"\e[0m){\e[31m0l\e[0m.toLong}\n\e[31m\e[31m   |\e[0m     \
    \   ^\e[0m\n\e[31m   |\e[0m        Found:    Long\n\e[31m   |\e[0m        Required:\
    \ \e[1m\e[32mList\e[0m\e[1m\e[32m[\e[0mLong\e[1m\e[32m]\e[0m\n\e[31m11 |\e[0m\
    \                                        \e[33melse\e[0m \e[33mif\e[0m (x == \e\
    [31m\")\"\e[0m || x == \e[31m\"]\"\e[0m){-\e[31m1l\e[0m.toLong}\n\e[31m12 |\e\
    [0m                                        \e[33melse\e[0m {\e[31m1l\e[0m.toLong}).max\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660029193
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_stack : List[List[Long]] = List(Nil).init\n        val\
    \ group_count : scala.collection.mutable.Map[String, Int] = scala.collection.mutable.Map.empty[String,\
    \ Int]\n        var level : Int = 0\n        var group : List[Long] = Nil\n  \
    \      var parens : List[Long] = Nil\n        var open_count : Int = 0\n     \
    \   var count : Int = paren_string.length\n\n        while ( count > 0 ) {\n \
    \           parens = paren_string.substring(0, count).replaceAll(\"[^()]\", \"\
    \")\n            if (paren_stack.last.size == count) {\n                paren_stack.last\
    \ :+ count\n            }\n            else {\n                level += (paren_stack.last\
    \ - paren_stack.last.drop(1)).max + 1\n                paren_stack.last :+ count\n\
    \            }\n            open_count = (paren_stack.last :+ count).length\n\
    \            count -= open_count\n            group = (paren_string.substring(0,\
    \ count).replaceAll(\"[^()]\", \"\") :: group).flatten\n            group_count\
    \ += (\"(\" + paren_stack.map(p => parens(p-1) + open_count).toList + \") :: \"\
    \ + group).zip(paren_stack.last).map(t => t._1 -> t._2)\n            group = []\n\
    \        }\n\n        group.toList.map(x => group_count(x)).toList.sortBy(_._1).reverse.drop(1).reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmphqchf0nj.scala:31:21 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m            group = []\n\e[31m\e[31m   |\e[0m       \
    \              ^\e[0m\n\e[31m   |\e[0m                     an identifier expected,\
    \ but ']' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmphqchf0nj.scala:32:8\
    \ ----------------------------\e[0m\e[0m\n\e[31m32 |\e[0m        }\n\e[31m\e[31m\
    \   |\e[0m        ^\e[0m\n\e[31m   |\e[0m        '=>' expected, but '}' found\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphqchf0nj.scala:19:64 --------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m            parens = paren_string.substring(\e[31m0\e\
    [0m, count).replaceAll(\e[31m\"[^()]\"\e[0m, \e[31m\"\"\e[0m)\n\e[31m\e[31m  \
    \ |\e[0m                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                     Found:    String\n\e[31m   |\e[0m   \
    \                  Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmphqchf0nj.scala:24:22 ------------------------\e[0m\e\
    [0m\n\e[31m24 |\e[0m                level += (paren_stack.last - paren_stack.last.drop(\e\
    [31m1\e[0m)).max + \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m                ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                value += is not a member of Int - did you\
    \ mean Int.!=?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmphqchf0nj.scala:24:43\
    \ ------------------------\e[0m\e[0m\n\e[31m24 |\e[0m                level +=\
    \ (paren_stack.last - paren_stack.last.drop(\e[31m1\e[0m)).max + \e[31m1\e[0m\n\
    \e[31m\e[31m   |\e[0m                          ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mvalue - is not a member of List[Long], but could be made available as\
    \ an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports\
    \ might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e[0m  import\
    \ math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import math.Numeric.Implicits.infixNumericOps\n\
    \e[31m   |\e[0m\n\e[31m\e[31m-- Error: /tmp/tmphqchf0nj.s"
  stdout: ''
  timestamp: 1660029199
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        var depth = 0\n        var max_depth = 0\n        // Initialize a\
    \ list to store the deepest level of nesting for each of the group\n        var\
    \ max_depth_list = List[Long]()\n        // Initialize a list to store all groups\
    \ and a counter to iterate through all groups\n        var group_and_group_list\
    \ = ListBuffer[List[Long]]()\n        var group_counter = 0\n        // For each\
    \ of the groups in the string separated by spaces \n        for(i <- 0 to paren_string.length\
    \ - 1) {\n            \n            // If the current group is empty add it to\
    \ the group and group_list\n            if(paren_string(i) == \" \") {\n     \
    \           group_and_group_list = group_and_group_list :+ i\n               \
    \ group_counter += 1\n            }\n            // If the current group is not\
    \ empty\n            else {\n                // Initialize a list to store all\
    \ groups and a counter to iterate through all groups\n                var group_and_group_list\
    \ = ListBuffer[List[Long]]()\n                var group_counter = 0\n        \
    \        // Split the string into groups separated by a space and add them to\
    \ the group list\n                for(j <- 0 to paren_string.length - 1 - i) {\n\
    \                    if(paren_string(i + j) == \" \") {\n                    \
    \    group_and_group_list = group_and_group_list :+ j\n                      \
    \  group_counter += 1\n                    }\n                }\n            \
    \    // Add the number of groups to the current depth and update the list with\
    \ the current depth\n                depth += group_counter\n                max_depth_list\
    \ = max_depth_list :+ depth\n                // If the maximum depth is larger\
    \ than the current depth and update it\n                if(max_depth_list.max\
    \ > depth) {\n                    max_depth = max_depth_list.max\n           \
    \     }\n                // If the current depth is equal to the maximum depth\
    \ update it\n                if(depth == max_depth) {\n                    max_depth_list\
    \ = max_depth_list :+ max_depth_list.max\n                }\n            }\n \
    \       }\n        // Return the max_depth_list\n        return max_depth_list\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp56_ae3gd.scala:21:15 -----------------------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m            \e[33mif\e[0m(paren_string(i) == \e[31m\"\
    \ \"\e[0m) {\n\e[31m\e[31m   |\e[0m               ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m        Values of types Char and String cannot be compared with\
    \ == or !=\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp56_ae3gd.scala:22:63\
    \ --------------------\e[0m\e[0m\n\e[31m22 |\e[0m                group_and_group_list\
    \ = group_and_group_list :+ i\n\e[31m\e[31m   |\e[0m                         \
    \                                      ^\e[0m\n\e[31m   |\e[0m               \
    \                                     Found:    (i : Int)\n\e[31m   |\e[0m   \
    \                                                 Required: List[Long]\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- Error: /tmp/tmp56_ae3gd.scala:32:23 -----------------------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m                    \e[33mif\e[0m(paren_string(i + j)\
    \ == \e[31m\" \"\e[0m) {\n\e[31m\e[31m   |\e[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Values of types Char and String cannot be compared\
    \ with == or !=\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp56_ae3gd.scala:33:71\
    \ --------------------\e[0m\e[0m\n\e[31m33 |\e[0m                        group_and_group_list\
    \ = group_and_group_list :+ j\n\e[31m\e[31m   |\e[0m                         \
    \                                              ^\e[0m\n\e[31m   |\e[0m       \
    \                                             Found:    (j : Int)\n\e[31m   |\e\
    [0m                                                    Required: List[Long]\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp56_ae3gd.scala:42:32\
    \ --------------------\e[0m\e[0m\n\e[31m42 |\e[0m                    max_depth\
    \ = max_depth_list.max\n\e[31m\e[31m   |\e[0m                                ^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                Found:    Long\n\e[31m   |\e\
    [0m                   "
  stdout: ''
  timestamp: 1660029197
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val nestedParen_str = paren_string.split(\" \")\n        val paren_stack\
    \ = mutable.Stack[String]()\n        for (nestedParen <- nestedParen_str) {\n\
    \            // Push this nestedPan onto the stack\n            if (nestedParen.charAt(0)\
    \ == '(') {\n                paren_stack.push(nestedParen)\n            } else\
    \ if (nestedParen.charAt(0) == ')') {\n                // If it currently in the\
    \ stack\n                if (paren_stack.nonEmpty && paren_stack.peek().charAt(0)\
    \ == '(') {\n                    // Pop the top stack item and append it to the\
    \ result list\n                    val paren = paren_stack.pop()\n           \
    \         val depth = nestedParen.split(\" \").length - 1\n                  \
    \  val result_list = List(depth.toLong)\n                    val result_list =\
    \ result_list :+ paren\n                    paren_stack.push(result_list)\n  \
    \              } else {\n                    // If not in the stack, just append\
    \ the character to the result list\n                    val result_list = List(nestedParen.charAt(0).toLong)\n\
    \                    paren_stack.push(result_list)\n                }\n      \
    \      }\n        }\n        // Return all the values from stack\n        return\
    \ paren_stack.map(_.toLong).toList\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpe6ex1ze5.scala:11:26 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mparen_stack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                          ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                          Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E161] Naming Error: /tmp/tmpe6ex1ze5.scala:23:24 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m                    \e[33mval\e[0m \e[36mresult_list\e\
    [0m = result_list :+ paren\n\e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mresult_list is already defined as \e[33mvalue\e[0m \e[35mresult_list\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n2 errors found\n"
  stdout: ''
  timestamp: 1660029191
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_stack = mutable.Stack[String]()\n        var levels = 0\n\
    \        for ( i <- paren_string.toCharArray) {\n            if (i == ')') paren_stack.pop()\n\
    \            else if (i == '(') {\n                paren_stack.push(i)\n     \
    \           levels += 1\n            }\n            else {\n                val\
    \ paren_level = levels\n                val paren_string = paren_stack\n     \
    \           paren_stack = mutable.Stack[String]()\n                if (paren_level\
    \ > levels) levels = paren_level\n                else if (paren_level < levels)\
    \ levels = paren_level\n            }\n        }\n        val max_level = levels.toLong\n\
    \        if (paren_string.length == max_level + 1) List(1l.toLong)\n        else\
    \ {\n            val paren_string = paren_string.toList\n            val max_level_str\
    \ = paren_string(max_level - 1).toString\n            val min_level_str = paren_string(max_level).toString.reverse\n\
    \            val max_level_parens = max_level_str.toInt\n            val min_level_parens\
    \ = min_level_str.toInt\n            val max_level_str = max_level_str.reverse\n\
    \            val min_level_str = min_level_str.reverse\n            val max_level_parens\
    \ = max_level_parens + 1\n            val min_level_parens = min_level_parens\
    \ + 1\n            val max_level_str = max_level_str + min_level_str\n       \
    \     val min_level_str = min_level_str + max_level_str\n            val max_level_str\
    \ = max_level_str + min_level_str\n            val max_level_parens = max_level_parens\
    \ + min_level_parens\n            val min_level_parens = min_level_parens + max_level_parens\n\
    \            val paren_stack_str = paren_stack.mkString(\"\").replace(\"[\", \"\
    \").replace(\"]\", \"\")\n            val paren_stack_str = paren_stack_str.replace(\"\
    [\", \"\")\n            val paren_stack_str = paren_stack_str.replace(\"]\", \"\
    \")\n            val paren_stack_str = paren_stack_str.replace(\"(\", \"\")\n\
    \            val paren_stack_str = paren_stack_str.replace(\")\", \"\")\n    \
    \        val paren_stack_str = paren_stack_str.substring(0, paren_stack_str.length)\n\
    \            val paren_stack_str = paren_stack_str.substring(min_level_parens)\n\
    \            val paren_stack_str = paren_stack_str + max_level_str\n         \
    \   val paren_stack_str = paren_stack_str.replace(\"(\", \"\")\n            val\
    \ paren_stack_str = paren_stack_str.replace(\")\", \"\")\n            val paren_stack_str\
    \ = paren_stack_str.substring(0, paren_stack_str.length)\n            val paren_stack_str\
    \ = paren_stack_str.substring(max_level_parens)\n            val \n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((()))\
    \ () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmp9l84mu_5.scala:55:15 ---------------------------\e\
    [0m\e[0m\n\e[31m55 |\e[0m            \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m  \
    \             ^\e[0m\n\e[31m   |\e[0m               pattern expected\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp9l84mu_5.scala:64:0 ----------------------------\e\
    [0m\e[0m\n\e[31m64 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp9l84mu_5.scala:10:26\
    \ ------------------------\e[0m\e[0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e\
    [36mparen_stack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e\
    [0m                          ^^^^^^^\e[0m\n\e[31m   |\e[0m                   \
    \       Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp9l84mu_5.scala:21:30 ------------------------\e[0m\e[0m\n\e[31m21 |\e\
    [0m                paren_stack = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e\
    [31m   |\e[0m                              ^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                         Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E161] Naming Error: /tmp/tmp9l84mu_5.scala:34:16 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m            \e[33mval\e[0m \e[36mmax_level_str\e[0m =\
    \ max_level_str.reverse\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmax_level_str is already defined as \e[33mvalue\e[0m \e[35mmax_level_str\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp9l84mu_5.scala:35:16 ---------------------------\e[0m\e[0m\n\e\
    [31m35 |\e[0m            \e[33mval\e[0m \e[36mmin_level_str\e[0m = min_level_str.reverse\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mmin_level_str is already defined as \e[33mvalue"
  stdout: ''
  timestamp: 1660029198
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_array = paren_string.split(\" \").toList\n        val levels_of_nesting\
    \ = new mutable.ArrayBuffer[Long]\n        var current_level = 0\n        for\
    \ (i <- 0 until paren_array.size) {\n            if (paren_array(i).equals(\"\
    (\")) {\n                current_level += 1\n            } else if (paren_array(i).equals(\"\
    )\")) {\n                current_level -= 1\n            }\n            if (current_level\
    \ == 0){\n                levels_of_nesting += current_level.toLong\n        \
    \    }\n        }\n        levels_of_nesting.toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"\
    () (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp8_2mul0c.scala:11:36 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mlevels_of_nesting\e[0m =\
    \ \e[33mnew\e[0m mutable.ArrayBuffer[\e[35mLong\e[0m]\n\e[31m\e[31m   |\e[0m \
    \                                   ^^^^^^^\e[0m\n\e[31m   |\e[0m            \
    \                        Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660029195
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_arr = paren_string.split(\"\\\\)\").toList\n        //\
    \ To track how many opening parenthesis we have, we will use a simple counter\n\
    \        // Since a list comprehension takes O(n), we use a mutable map\n    \
    \    val paren_count_map = mutable.Map[Int, Long]()\n        for (paren in paren_arr)\
    \ {\n            if (paren == \"(\") {\n                paren_count_map += 1\n\
    \            }\n            else if (paren == \")\") {\n                val count\
    \ = paren_count_map(paren)\n                if (count > 0) {\n               \
    \     paren_count_map -= 1\n                }\n            }\n            else\
    \ {\n                paren_count_map -= 1\n            }\n        }\n\n      \
    \  // Now we will need to convert this map to a list \n        val paren_list_array\
    \ = paren_count_map.toList.sorted\n        val max_count = paren_list_array.last\n\
    \        val max_index = paren_list_array.lastIndex\n        val paren_list_list\
    \ = paren_list_array.take(max_index)\n        val paren_list_long = paren_list_array.map(_.toLong)\n\
    \n        paren_list_long\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpdktst21q.scala:14:33 ---------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mfor\e[0m (paren in paren_arr) {\n\e[31m\e\
    [31m   |\e[0m                                 ^\e[0m\n\e[31m   |\e[0m        \
    \                         '<-' expected, but '{' found\n\e[31m\e[31m-- [E040]\
    \ Syntax Error: /tmp/tmpdktst21q.scala:37:4 ----------------------------\e[0m\e\
    [0m\n\e[31m37 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e[0m  \
    \  '<-' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpdktst21q.scala:13:30\
    \ ------------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e\
    [36mparen_count_map\e[0m = mutable.Map[\e[35mInt\e[0m, \e[35mLong\e[0m]()\n\e\
    [31m\e[31m   |\e[0m                              ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                              Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpdktst21q.scala:27:9 -------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        }\n\e[31m\e[31m   |\e[0m         ^\e[0m\n\e[31m\
    \   |\e[0mvalue withFilter is not a member of Null, but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import Option.option2Iterable\n\
    \e[31m   |\e[0m  import collection.LazyZip2.lazyZip2ToIterable\n\e[31m   |\e[0m\
    \  import collection.LazyZip3.lazyZip3ToIterable\n\e[31m   |\e[0m  import collection.LazyZip4.lazyZip4ToIterable\n\
    \e[31m   |\e[0m  import collection.convert.ImplicitConversions.list asScalaBuffer\n\
    \e[31m   |\e[0m  import collection.convert.ImplicitConversions.properties AsScalaMap\n\
    \e[31m   |\e[0m  import collection.convert.ImplicitConversions.enumeration AsScalaIterator\n\
    \e[31m   |\e[0m  import collection.convert.ImplicitConversions.iterator asScala\n\
    \e[31m   |\e[0m  import collection.convert.ImplicitConversions.map AsScalaConcurrentMap\n\
    \e[31m   |\e[0m  import collection.convert.ImplicitConversions.set asScala\n\e\
    [31m   |\e[0m\n\e[31m28 |\e[0m        \e[34m// Now we will need to convert this\
    \ map to "
  stdout: ''
  timestamp: 1660029204
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        def parseParens(paren_string : String) : List[Long] = {\n       \
    \     paren_string.asInstanceOf[List[String]].foldLeft(0l.toLong)( (acc, cur)\
    \ => {\n                val level = acc.toLong\n                val curVal = cur.asInstanceOf[String]\n\
    \                val parenCount = (curVal.indexOf('(') + curVal.indexOf(')')).toInt\n\
    \                if (parenCount > level) {\n                    val newLevel =\
    \ parenCount.toLong\n                    newLevel\n                } else if (parenCount\
    \ == level) {\n                    cur.toLong\n                } else {\n    \
    \                acc\n                }\n            })\n        }\n        val\
    \ parens = paren_string.trim.asInstanceOf[String]\n        val paren_groups =\
    \ parens.split(\" \")\n        paren_groups.length match {\n            case 0\
    \ => List()\n            case 1 => parseParens(paren_groups.head).toList\n   \
    \         case _ => {\n                var maxLevel = parseParens(paren_groups.head).toList.foldLeft(0l.toLong)(\
    \ (acc, curVal) => {\n                    var curLevel = acc\n               \
    \     if (curVal == '(') {\n                        curLevel = curLevel + 1\n\
    \                    }\n                    if (curVal == ')') {\n           \
    \             curLevel = curLevel - 1\n                    }\n               \
    \     if (curLevel > maxLevel) {\n                        maxLevel = curLevel\n\
    \                    }\n                    curLevel\n                })\n   \
    \             for (i <- 0 until paren_groups.length-1) {\n                   \
    \ val paren_group = paren_groups(i)\n                    val paren_group_level\
    \ = parseParens(paren_group).toList\n                    if (paren_group_level.size\
    \ < maxLevel) {\n                        maxLevel = paren_group_level.size\n \
    \                   }\n                }\n                maxLevel\n         \
    \   }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp0cslo7e_.scala:11:71\
    \ --------------------\e[0m\e[0m\n\e[31m11 |\e[0m            paren_string.asInstanceOf[\e\
    [35mList\e[0m[\e[35mString\e[0m]].foldLeft(\e[31m0l\e[0m.toLong)( (\e[36macc\e\
    [0m, \e[36mcur\e[0m) => {\n\e[31m\e[31m   |\e[0m            ^\e[0m\n\e[31m   |\e\
    [0m            Found:    Long\n\e[31m   |\e[0m            Required: \e[1m\e[32mList\e\
    [0m\e[1m\e[32m[\e[0mLong\e[1m\e[32m]\e[0m\n\e[31m12 |\e[0m                \e[33mval\e\
    [0m \e[36mlevel\e[0m = acc.toLong\n\e[31m13 |\e[0m                \e[33mval\e\
    [0m \e[36mcurVal\e[0m = cur.asInstanceOf[\e[35mString\e[0m]\n\e[31m14 |\e[0m \
    \               \e[33mval\e[0m \e[36mparenCount\e[0m = (curVal.indexOf(\e[31m'('\e\
    [0m) + curVal.indexOf(\e[31m')'\e[0m)).toInt\n\e[31m15 |\e[0m                \e\
    [33mif\e[0m (parenCount > level) {\n\e[31m16 |\e[0m                    \e[33mval\e\
    [0m \e[36mnewLevel\e[0m = parenCount.toLong\n\e[31m17 |\e[0m                 \
    \   newLevel\n\e[31m18 |\e[0m                } \e[33melse\e[0m \e[33mif\e[0m (parenCount\
    \ == level) {\n\e[31m19 |\e[0m                    cur.toLong\n\e[31m20 |\e[0m\
    \                } \e[33melse\e[0m {\n\e[31m21 |\e[0m                    acc\n\
    \e[31m22 |\e[0m                }\n\e[31m23 |\e[0m            })\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp0cslo7e_.scala:39:35 ---------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m                    \e[33mif\e[0m (curLevel > maxLevel)\
    \ {\n\e[31m\e[31m   |\e[0m                                   ^\e[0m\n\e[31m  \
    \ |\e[0m                                  Recursive \e[33mvariable\e[0m \e[35mmaxLevel\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp0cslo7e_.scala:40:24\
    \ ---------------------------\e[0m\e[0m\n\e[31m40 |\e[0m                     \
    \   maxLevel = curLevel\n\e[31m\e[31m   |\e[0m                        ^\e[0m\n\
    \e[31m   |\e[0m                        Recursive \e[33mvariable\e[0m \e[35mmaxLevel\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-exp"
  stdout: ''
  timestamp: 1660029209
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_string =  paren_string.replace(\"()\", \"\").replace(\"\
    ()\", \"\").replace(\"()\", \"\").replace(\"()\", \"\").replace(\"()\", \"\").replace(\"\
    ()\", \"\").replace(\"()\", \"\")\n        val paren_levels = paren_string.split(\"\
    \\\\(\")\n        val paren_levels_count = paren_levels.size\n        var level_counter\
    \ = 0\n        var current_level_paren_counter = 0\n        var deepest_level_of_paren\
    \ = 0\n        val highest_level_of_parens = mutable.HashMap.empty[Long, Long]\n\
    \        val highest_level_of_parens_count = mutable.HashMap.empty[Long, Int]\n\
    \        for (paren_level in paren_levels) {\n            current_level_paren_counter\
    \ = paren_levels_count - level_counter\n            level_counter += 1\n     \
    \       if (current_level_paren_counter == 0)\n                deepest_level_of_paren\
    \ = 0\n            else if (current_level_paren_counter > deepest_level_of_paren)\
    \ {\n                deepest_level_of_paren = current_level_paren_counter\n  \
    \              highest_level_of_parens.put(deepest_level_of_paren, current_level_paren_counter)\n\
    \                highest_level_of_parens_count.put(deepest_level_of_paren, current_level_paren_counter)\n\
    \            }\n        }\n        return highest_level_of_parens.toList.sortWith(_._1\
    \ > _._1)\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpup_47c32.scala:18:42 ---------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mfor\e[0m (paren_level in paren_levels)\
    \ {\n\e[31m\e[31m   |\e[0m                                          ^\e[0m\n\e\
    [31m   |\e[0m                                          '<-' expected, but '{'\
    \ found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpup_47c32.scala:10:28 ---------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e[36mparen_string\e[0m =  paren_string.replace(\e\
    [31m\"()\"\e[0m, \e[31m\"\"\e[0m).replace(\e[31m\"()\"\e[0m, \e[31m\"\"\e[0m).replace(\e\
    [31m\"()\"\e[0m, \e[31m\"\"\e[0m).replace(\e[31m\"()\"\e[0m, \e[31m\"\"\e[0m).replace(\e\
    [31m\"()\"\e[0m, \e[31m\"\"\e[0m).replace(\e[31m\"()\"\e[0m, \e[31m\"\"\e[0m).replace(\e\
    [31m\"()\"\e[0m, \e[31m\"\"\e[0m)\n\e[31m\e[31m   |\e[0m                     \
    \       ^\e[0m\n\e[31m   |\e[0m                            Recursive \e[33mvalue\e\
    [0m \e[35mparen_string\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpup_47c32.scala:16:38 ------------------------\e[0m\e\
    [0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mhighest_level_of_parens\e[0m\
    \ = mutable.HashMap.empty[\e[35mLong\e[0m, \e[35mLong\e[0m]\n\e[31m\e[31m   |\e\
    [0m                                      ^^^^^^^\e[0m\n\e[31m   |\e[0m       \
    \                               Not found: mutable\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpup_47c32.scala:17:44 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mhighest_level_of_parens_count\e\
    [0m = mutable.HashMap.empty[\e[35mLong\e[0m, \e[35mInt\e[0m]\n\e[31m\e[31m   |\e\
    [0m                                            ^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \                                           Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpup_47c32.scala:28:9 -------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        }\n\e[31m\e[31m   |\e[0m         ^\e[0m\n\e[31m\
    \  "
  stdout: ''
  timestamp: 1660029208
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        paren_string.split(\"\\\\s+\").map(v => v.count(_ == '(') - v.count(_\
    \ == '[') - v.count(_ == '{')).maxBy(_).map(_.toLong).toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"\
    () (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E081] Type Error: /tmp/tmp8igiox8p.scala:10:109 ----------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m        paren_string.split(\e[31m\"\\\\s+\"\e[0m).map(\e\
    [36mv\e[0m => v.count(_ == \e[31m'('\e[0m) - v.count(_ == \e[31m'['\e[0m) - v.count(_\
    \ == \e[31m'{'\e[0m)).maxBy(_).map(_.toLong).toList\n\e[31m\e[31m   |\e[0m   \
    \                                                                            \
    \                              ^\e[0m\n\e[31m   |\e[0m   Missing parameter type\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m   I could not infer the type of the parameter\
    \ _$4 of expanded function:\n\e[31m   |\e[0m   _$4 => \n\e[31m   |\e[0m     paren_string.split(\e\
    [32m\"\\\\s+\"\e[0m).map(\n\e[31m   |\e[0m       v => \n\e[31m   |\e[0m      \
    \   v.count(_$1 => _$1 == \e[31m'('\e[0m) - v.count(_$2 => _$2 == \e[31m'['\e\
    [0m) - \n\e[31m   |\e[0m           v.count(_$3 => _$3 == \e[31m'{'\e[0m)\n\e[31m\
    \   |\e[0m     ).maxBy(_$4).map(_$5 => _$5.toLong).toList.\n\e[31m\e[31m-- Error:\
    \ /tmp/tmp8igiox8p.scala:10:111 ----------------------------------------\e[0m\e\
    [0m\n\e[31m10 |\e[0m        paren_string.split(\e[31m\"\\\\s+\"\e[0m).map(\e[36mv\e\
    [0m => v.count(_ == \e[31m'('\e[0m) - v.count(_ == \e[31m'['\e[0m) - v.count(_\
    \ == \e[31m'{'\e[0m)).maxBy(_).map(_.toLong).toList\n\e[31m\e[31m   |\e[0m   \
    \                                                                            \
    \                                ^\e[0m\n\e[31m   |\e[0mambiguous given instances:\
    \ both \e[33mobject\e[0m \e[35mByte\e[0m in \e[33mobject\e[0m \e[35mOrdering\e\
    [0m and \e[33mobject\e[0m \e[35mString\e[0m in \e[33mobject\e[0m \e[35mOrdering\e\
    [0m match type Ordering[B] of parameter cmp of \e[33mmethod\e[0m \e[35mmaxBy\e\
    [0m in \e[33mtrait\e[0m \e[35mIterableOnceOps\e[0m\n2 errors found\n"
  stdout: ''
  timestamp: 1660029201
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_level = mutable.ListBuffer[Long]()\n        val paren_array\
    \ = paren_string.split(\" \")\n        paren_array.foreach(ele => {\n        \
    \    val opening_paren = ele.indexOf('(')\n            val closing_paren = ele.indexOf(')')\n\
    \            if(opening_paren < 0 || closing_paren < 0) {\n                return\n\
    \            }\n            if(opening_paren + 1 == closing_paren) {\n       \
    \         val new_level = paren_level.length\n                paren_level ++=\
    \ List(new_level)\n                return\n            }\n            val next_level_opening\
    \ = paren_array.getOrElse(opening_paren+1, 0).toLong\n            val next_level_closing\
    \ = paren_array.getOrElse(closing_paren+1, 0).toLong\n            val new_level\
    \ = paren_level.get(opening_paren).toLong + next_level_opening - next_level_closing\n\
    \            paren_level ++= List(new_level)\n        })\n        paren_level.toList.sortBy(_._)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp6dw4pnyg.scala:28:36 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        paren_level.toList.sortBy(_._)\n\e[31m\e[31m\
    \   |\e[0m                                    ^\e[0m\n\e[31m   |\e[0m        \
    \                           an identifier expected, but '_' found\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp6dw4pnyg.scala:10:26 ------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e[36mparen_level\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                          ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                          Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp6dw4pnyg.scala:16:16 --------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m                \e[33mreturn\e[0m\n\e[31m\e[31m   |\e\
    [0m                ^^^^^^\e[0m\n\e[31m   |\e[0m                Found:    Unit\n\
    \e[31m   |\e[0m                Required: List[Long]\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmp6dw4pnyg.scala:21:16 --------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m                \e[33mreturn\e[0m\n\e[31m\e[31m   |\e\
    [0m                ^^^^^^\e[0m\n\e[31m   |\e[0m                Found:    Unit\n\
    \e[31m   |\e[0m                Required: List[Long]\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp6dw4pnyg.scala:23:49 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            \e[33mval\e[0m \e[36mnext_level_opening\e\
    [0m = paren_array.getOrElse(opening_paren+\e[31m1\e[0m, \e[31m0\e[0m).toLong\n\
    \e[31m\e[31m   |\e[0m                                     ^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                        value getOrElse is not a member of\
    \ Array[String]\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp6dw4pnyg.scala:24:49\
    \ ------------------------\e[0m\e[0m\n\e[31m24 |\e[0m            \e["
  stdout: ''
  timestamp: 1660029210
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        var max_level = 0\n        var max_level_index = 0\n        var level\
    \ = 0\n        var stack = new mutable.Stack[List[Long]]\n        var result:\
    \ List[Long] = Nil\n        paren_string.split(\"\\\\s+\").foreach { elem =>\n\
    \            if(!elem.equals(\"(\") && elem.equals(\")\")) {\n               \
    \ stack.push(List(0, 0))\n            }\n            else if(elem.equals(\"(\"\
    )) {\n                stack.push(List(0, 0))\n            }\n            else\
    \ if(elem.equals(\")\")) {\n                var level_start = stack.get.apply(0).getOrElse(0)\n\
    \                var level_end = stack.get.apply(1).getOrElse(0)\n           \
    \     val max_level_size = level_end - level_start + 1\n                if(max_level_size\
    \ >= max_level) {\n                    max_level = max_level_size\n          \
    \          max_level_index = stack.size - 1\n                }\n             \
    \   stack.last.last.last.last.last.last.set(max_level_size + 1, level_end)\n \
    \               stack.pop()\n                level -= 1\n            }\n     \
    \       else {\n                val level_start = stack.get.apply(0).getOrElse(0)\n\
    \                val level_end = stack.get.apply(1).getOrElse(0)\n           \
    \     stack.last.last.last.last.last.set(level + 1, level_end)\n             \
    \   stack.get.apply(level + 1).foreach(x => stack.push(x))\n                level\
    \ += 1\n            }\n        }\n        stack.get.apply(max_level_index).foreach(x\
    \ => result.add(x))\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpxfc6ppcl.scala:13:24 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        \e[33mvar\e[0m \e[36mstack\e[0m = \e[33mnew\e\
    [0m mutable.Stack[\e[35mList\e[0m[\e[35mLong\e[0m]]\n\e[31m\e[31m   |\e[0m   \
    \                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                        Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660029202
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        if (paren_string.length <= 1) List(1l.toLong)\n        val resultList\
    \ = ListBuffer[Long]()\n        val currNesting = -1\n        def isNesting(index\
    \ : Long) : Boolean = {\n            if (paren_string(index) == \"(\") return\
    \ true\n            else if (paren_string(index) == \")\") return false\n    \
    \        else if (paren_string(index) == \" \") return true\n            else\
    \ return isNesting(index + 1)\n        }\n        def findNestingLevel(index :\
    \ Long) : Long = {\n            if (isNesting(index)) {\n                currNesting\
    \ += 1\n                findNestingLevel(index + 1)\n            } else currNesting\
    \ -= 1\n            currNesting\n        }\n        val openingBracketIndex =\
    \ 0\n        val closingBracketIndex = 0\n        while (openingBracketIndex <\
    \ paren_string.length) {\n            val closingBracketIndex = paren_string.indexOf(\"\
    )\", openingBracketIndex + 1)\n            if (closingBracketIndex >= 0) {\n \
    \               val closingBracketEndIndex = paren_string.indexOf(\")\", closingBracketIndex\
    \ + 1)\n                if (closingBracketEndIndex >= 0) {\n                 \
    \   val closingBracketString = paren_string.substring(closingBracketIndex, closingBracketEndIndex\
    \ + 1)\n                    val closingBracketNesting = findNestingLevel(closingBracketIndex\
    \ + 1)\n                    val currNestingLevel = findNestingLevel(openingBracketIndex\
    \ + 1)\n                    if (closingBracketNesting > currNestingLevel) resultList\
    \ += closingBracketNesting\n                    else if (closingBracketNesting\
    \ < currNestingLevel) resultList += currNestingLevel\n                }\n    \
    \        }\n            val openingBracketEndIndex = paren_string.indexOf(\"(\"\
    , openingBracketIndex + 1)\n            if (openingBracketEndIndex >= 0) {\n \
    \               val openingBracketString = paren_string.substring(openingBracketIndex,\
    \ openingBracketEndIndex + 1)\n                val openingBracketNesting = findNestingLevel(openingBracketIndex\
    \ + 1)\n                val currNestingLevel = findNestingLevel(closingBracketIndex\
    \ + 1)\n                if (openingBracketNesting > currNestingLevel) resultList\
    \ += openingBracketNesting\n                else if (openingBracketNesting < currNestingLevel)\
    \ resultList += currNestingLevel\n            }\n            openingBracketIndex\
    \ = paren_string.indexOf(\"(\", openingBracketIndex + 1)\n        }\n        resultList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphnhg2nbj.scala:14:29\
    \ --------------------\e[0m\e[0m\n\e[31m14 |\e[0m            \e[33mif\e[0m (paren_string(index)\
    \ == \e[31m\"(\"\e[0m) \e[33mreturn\e[0m \e[31mtrue\e[0m\n\e[31m\e[31m   |\e[0m\
    \                             ^^^^^\e[0m\n\e[31m   |\e[0m                    \
    \         Found:    (index : Long)\n\e[31m   |\e[0m                          \
    \   Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphnhg2nbj.scala:15:34\
    \ --------------------\e[0m\e[0m\n\e[31m15 |\e[0m            \e[33melse\e[0m \e\
    [33mif\e[0m (paren_string(index) == \e[31m\")\"\e[0m) \e[33mreturn\e[0m \e[31mfalse\e\
    [0m\n\e[31m\e[31m   |\e[0m                                  ^^^^^\e[0m\n\e[31m\
    \   |\e[0m                                  Found:    (index : Long)\n\e[31m \
    \  |\e[0m                                  Required: Int\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphnhg2nbj.scala:16:34 --------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m            \e[33melse\e[0m \e[33mif\e[0m (paren_string(index)\
    \ == \e[31m\" \"\e[0m) \e[33mreturn\e[0m \e[31mtrue\e[0m\n\e[31m\e[31m   |\e[0m\
    \                                  ^^^^^\e[0m\n\e[31m   |\e[0m               \
    \                   Found:    (index : Long)\n\e[31m   |\e[0m                \
    \                  Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmphnhg2nbj.scala:21:28 ------------------------\e[0m\e[0m\n\e[31m21 |\e\
    [0m                currNesting += \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        \
    \        ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m          value += is not a member\
    \ of Int - did you mean currNesting.!=?\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmphnhg2nbj.scala:23:31 ------------------------\e[0m\e[0m\n\e[31m23 |\e\
    [0m            } \e[33melse\e[0m currNesting -= \e[31m1\e[0m\n\e[31m\e[31m   |\e\
    [0m                   ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m          value -= is\
    \ not a member of Int - d"
  stdout: ''
  timestamp: 1660029212
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.trim.split(\"\\\\s+\")\n        val\
    \ paren_levels = mutable.ArrayBuffer.empty[Long]\n        for (paren_group <-\
    \ paren_groups) {\n            val paren_level = 0\n            val paren_count\
    \ = 0\n            val paren_stack = mutable.Stack.empty[String]\n           \
    \ val in_paren_group = 0\n            val paren_group_tokens = paren_group.split(\"\
    ()\")\n            for (paren_token <- paren_group_tokens) {\n               \
    \ if (paren_token.isEmpty) {\n                    paren_stack.push(\"\")\n   \
    \             } else {\n                    if (paren_token == \"(\") {\n    \
    \                    paren_stack.push(\"\")\n                        in_paren_group\
    \ += 1\n                    } else if (paren_token == \")\") {\n             \
    \           paren_count -= 1\n                        if (in_paren_group > 0)\
    \ {\n                            paren_stack.push(paren_token)\n             \
    \           } else {\n                            paren_level -= 1\n         \
    \                   paren_stack.pop\n                            if (paren_stack.nonEmpty\
    \ && paren_level == 0) {\n                                paren_levels += paren_stack.toList\n\
    \                                paren_levels += paren_stack.toList.reverse\n\
    \                            }\n                        }\n                  \
    \  }\n                }\n            }\n        }\n        paren_levels.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpxttuneai.scala:11:27 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mparen_levels\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                           ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                           Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpxttuneai.scala:15:30 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m            \e[33mval\e[0m \e[36mparen_stack\e[0m = mutable.Stack.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                              ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                              Not found: mutable\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpxttuneai.scala:24:39 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m                        in_paren_group += \e[31m1\e[0m\n\
    \e[31m\e[31m   |\e[0m                        ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m       value += is not a member of Int - did you mean in_paren_group.!=?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpxttuneai.scala:26:36 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m                        paren_count -= \e[31m1\e[0m\n\
    \e[31m\e[31m   |\e[0m                        ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m          value -= is not a member of Int - did you mean paren_count.!=?\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpxttuneai.scala:30:40 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m                            paren_level -= \e[31m1\e\
    [0m\n\e[31m\e[31m   |\e[0m                            ^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m          value -= is not a member of Int - did you mean paren_level.!=?\n\
    5 errors found\n"
  stdout: ''
  timestamp: 1660029210
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_str_list: List[String] = paren_string.split(\" \");\n \
    \       val max_level: Int = 0;\n        val paren_strs_group: List[String] =\
    \ paren_str_list.map(s => (s.toChar, s.toInt)).groupBy(_._1).mapValues(_.map(_._2).toList)\n\
    \        val parentheses_group: List[Map[Char,Int]] = paren_strs_group.mapValues(v\
    \ => List(v.last))\n        val max_level_of_group: List[Int] = parentheses_group.mapValues(_.length).toList.max\n\
    \n        max_level_of_group.foreach(s => max_level = s)\n        paren_strs_group.mapValues(v\
    \ => List(v.last))\n            .map(v => v.toString.count(_ == '(') - v.toString.count(_\
    \ == '(') - v.toString.count(_ == ')'))\n            .toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"\
    () (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp7vsufyl7.scala:10:61\
    \ --------------------\e[0m\e[0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e[36mparen_str_list\e\
    [0m: \e[35mList\e[0m[\e[35mString\e[0m] = paren_string.split(\e[31m\" \"\e[0m);\n\
    \e[31m\e[31m   |\e[0m                                           ^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                           Found:    \e[1m\e\
    [31mArray\e[0m[String]\n\e[31m   |\e[0m                                      \
    \     Required: \e[1m\e[32mList\e[0m[String]\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmp7vsufyl7.scala:12:72 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mparen_strs_group\e[0m: \e\
    [35mList\e[0m[\e[35mString\e[0m] = paren_str_list.map(\e[36ms\e[0m => (s.toChar,\
    \ s.toInt)).groupBy(_._1).mapValues(_.map(_._2).toList)\n\e[31m\e[31m   |\e[0m\
    \                                                                      ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                  value toChar is not a member\
    \ of String\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp7vsufyl7.scala:13:70\
    \ ------------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e\
    [36mparentheses_group\e[0m: \e[35mList\e[0m[\e[35mMap\e[0m[\e[35mChar\e[0m,\e\
    [35mInt\e[0m]] = paren_strs_group.mapValues(\e[36mv\e[0m => List(v.last))\n\e\
    [31m\e[31m   |\e[0m                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                         value mapValues is not a member of\
    \ List[String]\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp7vsufyl7.scala:14:62\
    \ ------------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e\
    [36mmax_level_of_group\e[0m: \e[35mList\e[0m[\e[35mInt\e[0m] = parentheses_group.mapValues(_.length).toList.max\n\
    \e[31m\e[31m   |\e[0m                                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue mapValues is not a member of List[collection.mutable.Map[Char,\
    \ Int]]\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmp7vsufyl7.scala:16:50 -----------------------------\e\
    [0m\e[0m"
  stdout: ''
  timestamp: 1660029212
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_list = paren_string.split(\" \");\n        var counter\
    \ = 0;\n        var max_counter = 0;\n        val result = mutable.MutableList[Long]()\n\
    \        val paren_counter = mutable.MutableList[Long]()\n        paren_list.foreach(x\
    \ => {\n            if (x != \"()\"){\n                val tmp = Long.valueOf(x.toInt)\n\
    \                if (tmp > max_counter)\n                    max_counter = tmp\n\
    \                result.append(tmp)\n                paren_counter.append(Long.valueOf(1))\n\
    \            }\n            else if (x == \")\"){\n                if (paren_counter(counter)\
    \ == 0)\n                    counter = counter + 1\n                else {\n \
    \                   if (paren_counter(counter) == max_counter)\n             \
    \           result.append((max_counter).toLong)\n                    else\n  \
    \                      result.append((paren_counter(counter)).toLong)\n      \
    \              counter = counter + 1\n                }\n                paren_counter(counter)\
    \ = paren_counter(counter) + 1\n            }\n        })\n        result\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmplxqagaok.scala:13:21 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.MutableList[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmplxqagaok.scala:14:28 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mparen_counter\e[0m = mutable.MutableList[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                            ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                            Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmplxqagaok.scala:17:31 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m                \e[33mval\e[0m \e[36mtmp\e[0m = Long.valueOf(x.toInt)\n\
    \e[31m\e[31m   |\e[0m                          ^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                          value valueOf is not a member of object Long\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660029208
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_levels = mutable.ListBuffer.empty[Long]\n        paren_string.split(\"\
    \ \").foreach{ s =>\n            val level_str = s.split(\"\\\\(\")\n        \
    \    val level_int = level_str.map(_.toInt)\n            val level = level_int.max\n\
    \            paren_levels.append(level)\n        }\n        paren_levels.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpcqcyc8tn.scala:10:27 ------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e[36mparen_levels\e[0m = mutable.ListBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                           ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                           Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660029206
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_list = paren_string.split(\"\\\\s+\")\n        var count\
    \ = 0\n        val result_list = new mutable.ListBuffer[Long]\n        for (paren_str\
    \ <- paren_list) {\n            val paren_count = paren_str.count('(')\n     \
    \       val open_paren_count = paren_str.count('(')\n            val close_paren_count\
    \ = paren_str.count(')')\n            if (open_paren_count == paren_count && close_paren_count\
    \ == paren_count) {\n                count += open_paren_count * close_paren_count\n\
    \                result_list += count.toLong\n                count = 0\n    \
    \        }\n        }\n        result_list += count.toLong\n        return result_list.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmps6f_5inx.scala:12:30 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mresult_list\e[0m = \e[33mnew\e\
    [0m mutable.ListBuffer[\e[35mLong\e[0m]\n\e[31m\e[31m   |\e[0m               \
    \               ^^^^^^^\e[0m\n\e[31m   |\e[0m                              Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmps6f_5inx.scala:14:46\
    \ --------------------\e[0m\e[0m\n\e[31m14 |\e[0m            \e[33mval\e[0m \e\
    [36mparen_count\e[0m = paren_str.count(\e[31m'('\e[0m)\n\e[31m\e[31m   |\e[0m\
    \                                              ^^^\e[0m\n\e[31m   |\e[0m     \
    \                                         Found:    (\e[31m'('\e[0m : Char)\n\e\
    [31m   |\e[0m                                              Required: Char => Boolean\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmps6f_5inx.scala:15:51\
    \ --------------------\e[0m\e[0m\n\e[31m15 |\e[0m            \e[33mval\e[0m \e\
    [36mopen_paren_count\e[0m = paren_str.count(\e[31m'('\e[0m)\n\e[31m\e[31m   |\e\
    [0m                                                   ^^^\e[0m\n\e[31m   |\e[0m\
    \                                               Found:    (\e[31m'('\e[0m : Char)\n\
    \e[31m   |\e[0m                                               Required: Char =>\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmps6f_5inx.scala:16:52\
    \ --------------------\e[0m\e[0m\n\e[31m16 |\e[0m            \e[33mval\e[0m \e\
    [36mclose_paren_count\e[0m = paren_str.count(\e[31m')'\e[0m)\n\e[31m\e[31m   |\e\
    [0m                                                    ^^^\e[0m\n\e[31m   |\e\
    [0m                                               Found:    (\e[31m')'\e[0m :\
    \ Char)\n\e[31m   |\e[0m                                               Required:\
    \ Char => Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660029214
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        var level : Int = 0\n        var stack : List[Int] = Nil\n      \
    \  var res : List[Long] = Nil\n        var temp_str : String = \"\"\n        for\
    \ (c <- paren_string){\n            temp_str = temp_str + c\n            if( c\
    \ == '(' || c == '{' ){\n                stack = stack :+ level\n            }else\
    \ if( c == ')' || c == '}' ){\n                if(stack.isEmpty){\n          \
    \          res.length = 0\n                    level = 0\n                   \
    \ res.reverse.foreach(x => res += x)\n                    break\n            \
    \    }else if( stack.lastOption.isDefined ){\n                    level = stack.last.get\n\
    \                    stack = stack.dropRight(1)\n                }\n         \
    \   }\n        }\n        temp_str = temp_str.substring(1)\n        temp_str.substring(1).split(\"\
    \\\\(\").map(x => x.trim).foreach(x => if(x == \"\") res += 0l else res += x.toLong)\n\
    \        return res\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmpqkb51xs3.scala:20:31 -----------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m                    res.length = \e[31m0\e[0m\n\e[31m\e\
    [31m   |\e[0m                    ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        \
    \            Reassignment to val length\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpqkb51xs3.scala:22:49 ------------------------\e[0m\e\
    [0m\n\e[31m22 |\e[0m                    res.reverse.foreach(\e[36mx\e[0m => res\
    \ += x)\n\e[31m\e[31m   |\e[0m                                             ^^^^^^\e\
    [0m\n\e[31m   |\e[0m    value += is not a member of List[Long] - did you mean\
    \ List[Long].!=?\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpqkb51xs3.scala:23:20\
    \ ------------------------\e[0m\e[0m\n\e[31m23 |\e[0m                    break\n\
    \e[31m\e[31m   |\e[0m                    ^^^^^\e[0m\n\e[31m   |\e[0m         \
    \           Not found: break\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpqkb51xs3.scala:25:39 ------------------------\e[0m\e[0m\n\e[31m25 |\e\
    [0m                    level = stack.last.get\n\e[31m\e[31m   |\e[0m         \
    \                   ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                     \
    \       value get is not a member of Int\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpqkb51xs3.scala:31:89 ------------------------\e[0m\e[0m\n\e[31m31 |\e\
    [0m        temp_str.substring(\e[31m1\e[0m).split(\e[31m\"\\\\(\"\e[0m).map(\e\
    [36mx\e[0m => x.trim).foreach(\e[36mx\e[0m => \e[33mif\e[0m(x == \e[31m\"\"\e\
    [0m) res += \e[31m0l\e[0m \e[33melse\e[0m res += x.toLong)\n\e[31m\e[31m   |\e\
    [0m                                                                          \
    \           ^^^^^^\e[0m\n\e[31m   |\e[0m    value += is not a member of List[Long]\
    \ - did you mean List[Long].!=?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpqkb51xs3.scala:31:104\
    \ -----------------------\e[0m\e[0m\n\e[31m31 |\e[0m        temp_str.substring(\e\
    [31m1\e[0m).split(\e[31m\"\\\\(\"\e[0m).map(\e[36mx\e[0m => x.trim).foreach(\e\
    [36mx\e[0m => \e[33mif\e[0m"
  stdout: ''
  timestamp: 1660029215
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        paren_string\n            .replaceAllLiterally(\"\\\\(|\\\\)\", \"\
    \")\n            .split(\" \")\n            .map(x => if (x.equals(\"()\")) x.toLong\
    \ else x.toLong - 1 )\n            .maxBy(_.toLong)\n            .toList\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()())\
    \ ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp1h3xvhsr.scala:15:13 ------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m        paren_string\n\e[31m11 |\e[0m            .replaceAllLiterally(\e\
    [31m\"\\\\(|\\\\)\"\e[0m, \e[31m\"\"\e[0m)\n\e[31m12 |\e[0m            .split(\e\
    [31m\" \"\e[0m)\n\e[31m13 |\e[0m            .map(\e[36mx\e[0m => \e[33mif\e[0m\
    \ (x.equals(\e[31m\"()\"\e[0m)) x.toLong \e[33melse\e[0m x.toLong - \e[31m1\e\
    [0m )\n\e[31m14 |\e[0m            .maxBy(_.toLong)\n\e[31m15 |\e[0m          \
    \  .toList\n\e[31m\e[31m   |\e[0m        ^\e[0m\n\e[31m   |\e[0m        value\
    \ toList is not a member of Long - did you mean Long.toInt?\n1 error found\n"
  stdout: ''
  timestamp: 1660029214
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_chars = paren_string.split(\" \").toList\n        val max_depth\
    \ = paren_chars.foldLeft(0){ (maxDepth, paren_char) => maxDepth.getOrElse(paren_char.length)\
    \ + 1 }\n        val nested_parens = paren_chars.foldRight(List.empty[List[Long]])\
    \ { (nesting_levels, paren_char) =>\n            if (nesting_levels.isEmpty) List.fill(max_depth)(1l.toLong)\n\
    \            else if (nesting_levels.last == max_depth) nesting_levels ++ List.fill(max_depth\
    \ - nesting_levels.last)(1l.toLong)\n            else nesting_levels ++ List(nesting_levels.last\
    \ + 1, nesting_levels.last + 2)\n        }\n        return nested_parens.reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpfi2cotsy.scala:11:84 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mmax_depth\e[0m = paren_chars.foldLeft(\e\
    [31m0\e[0m){ (\e[36mmaxDepth\e[0m, \e[36mparen_char\e[0m) => maxDepth.getOrElse(paren_char.length)\
    \ + \e[31m1\e[0m }\n\e[31m\e[31m   |\e[0m                                    \
    \                                       ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                                  value getOrElse is not a member of Int\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpfi2cotsy.scala:13:64 --------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m            \e[33mif\e[0m (nesting_levels.isEmpty) List.fill(max_depth)(\e\
    [31m1l\e[0m.toLong)\n\e[31m\e[31m   |\e[0m                                   \
    \                          ^^^^^^^^^\e[0m\n\e[31m   |\e[0m                   \
    \                                 Found:    Long\n\e[31m   |\e[0m            \
    \                                        Required: \e[1m\e[32mList\e[0m\e[1m\e\
    [32m[\e[0mLong\e[1m\e[32m]\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpfi2cotsy.scala:14:55 --------------------\e[0m\e[0m\n\e[31m14\
    \ |\e[0m            \e[33melse\e[0m \e[33mif\e[0m (nesting_levels.last == max_depth)\
    \ nesting_levels ++ List.fill(max_depth - nesting_levels.last)(\e[31m1l\e[0m.toLong)\n\
    \e[31m\e[31m   |\e[0m                                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                            Found:    IndexedSeq[AnyVal]\n\
    \e[31m   |\e[0m                                            Required: List[List[Long]]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpfi2cotsy.scala:15:17\
    \ --------------------\e[0m\e[0m\n\e[31m15 |\e[0m            \e[33melse\e[0m nesting_levels\
    \ ++ List(nesting_levels.last + \e[31m1\e[0m, nesting_levels.last + \e[31m2\e\
    [0m)\n\e[31m\e[31m   |\e[0m                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1660029217
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        paren_string.split(\"\\\\ \").map {\n            string => {\n  \
    \              val paren_pairs = string.trim().split(\"\\\\)\")\n            \
    \    paren_pairs.reverse.map(_.trim()).filter(_.nonEmpty).foldLeft(List.empty[Long])\
    \ { (a, p) =>\n                    val bracket_index = a.size + 1\n          \
    \          val index = p.indexOf(\"(\")\n                    val depth = if (index\
    \ >= 0) index else paren_pairs.indexOf(p) + 1\n                    a.update(bracket_index,\
    \ (depth.toLong))\n                    a\n                }\n            }\n \
    \       }\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpfwn4aur8.scala:17:22 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m                    a.update(bracket_index, (depth.toLong))\n\
    \e[31m\e[31m   |\e[0m                    ^^^^^^^^\e[0m\n\e[31m   |\e[0m    value\
    \ update is not a member of List[Long] - did you mean a.updated?\n1 error found\n"
  stdout: ''
  timestamp: 1660029216
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val depth = paren_string.split(\"(?<=\\\\()\").toList.map(_.length).toList.max\n\
    \        (1 to depth).map(x => paren_string.split(\"(?<=\\\\()\").toList.map(_.length).toList.max)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpr5ypmtwa.scala:11:24\
    \ --------------------\e[0m\e[0m\n\e[31m11 |\e[0m        (\e[31m1\e[0m to depth).map(\e\
    [36mx\e[0m => paren_string.split(\e[31m\"(?<=\\\\()\"\e[0m).toList.map(_.length).toList.max)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    IndexedSeq[Int]\n\e[31m   |\e[0m       \
    \ Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660029216
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        // Initialize the current level of nesting to 0 and max nesting to\
    \ 1.\n        var current_level = 0\n        var max_level = 1\n        val paren_chars\
    \ = paren_string.asInstanceOf[Seq[Char]]\n        // Keep track of whether the\
    \ current level of nesting has changed since the previous iteration\n        var\
    \ changed = false\n        // The depth of the parenthesis group. Start with zero.\n\
    \        val depth = paren_chars.foldLeft(0)((n, c) => {\n            // Check\
    \ if the current character is a left parenthesis. If it is, the current_level\
    \ is increased.\n            // Else, the current_level is decreased. Also note\
    \ the changed flag\n            val current_level_changed = if (c == '(') current_level\
    \ else current_level - 1\n            changed = changed || current_level_changed\n\
    \n            // Increase the max level if the character is an opening paranthesis.\n\
    \            if (c == '(') max_level += 1\n            else if (c == ')') max_level\
    \ -= 1\n            n + (if (current_level_changed > 0) current_level_changed\
    \ else -current_level_changed)\n        })\n\n        // The length of the longest\
    \ sequence to consider\n        val max_length = max_level * depth\n        val\
    \ groups = paren_chars.sliding(max_length).toList\n        // Store the resulting\
    \ list of depths because we need to return it as a List instead of Int\n     \
    \   val depths = groups.foldLeft(List[Long]())((d, c) => d :+ c(0).asInstanceOf[Long])\n\
    \        val max_depth = depths.max\n\n        // Initialize the result list to\
    \ hold all the maximum depths\n        val result = new Array[Long](max_depth\
    \ + 1)\n\n        // Start the traversal from the longest sequence\n        val\
    \ depths_index = 0\n        var last_position = 0\n        // Keep track of whether\
    \ the current longest sequence has changed since the previous iteration\n    \
    \    var changed = false\n        while (last_position < paren_string.length &&\
    \ depths_index < depths.length) {\n            // Find the longest sequence\n\
    \            val longest_seq = paren_chars.takeWhile(_ != '(')\n            val\
    \ longest_seq_length = longest_seq.length\n            changed = changed || longest_seq_length\
    \ > max_length\n            // Update the longest sequence and position\n    \
    \        last_position = last_position + longest_seq_length\n            // Store\
    \ the position of the last parenthesis character in the longest sequence\n   \
    \         val last_paren_pos = paren_chars.indexOf(')', last_position)\n     \
    \       // Check if the current longest sequence contains more than one left parenthesis\
    \ character\n            if (last_paren_pos < last_position) {\n             \
    \   // If the longest sequence contains more than one left parenthesis character,\
    \ then\n                // find the deepest level of nesting by count\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()())\
    \ ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpggjaakz3.scala:65:0 ----------------------------\e\
    [0m\e[0m\n\e[31m65 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpggjaakz3.scala:43:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m43 |\e[0m        \e[33mvar\e[0m\
    \ \e[36mchanged\e[0m = \e[31mfalse\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mchanged is already defined as \e[33mvariable\e[0m \e[35mchanged\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmpggjaakz3.scala:21:33 --------------------\e[0m\e[0m\n\
    \e[31m21 |\e[0m            changed = changed || current_level_changed\n\e[31m\e\
    [31m   |\e[0m                                 ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                                 Found:    (current_level_changed :\
    \ Int)\n\e[31m   |\e[0m                                 Required: Boolean\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpggjaakz3.scala:37:37\
    \ --------------------\e[0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e[36mresult\e\
    [0m = \e[33mnew\e[0m \e[35mArray\e[0m[\e[35mLong\e[0m](max_depth + \e[31m1\e[0m)\n\
    \e[31m\e[31m   |\e[0m                                     ^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                     Found:    Long\n\e[31m   |\e\
    [0m                                     Required: Int\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpggjaakz3.scala:44:8 ---------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m        \e[33mwhile\e[0m (last_position < paren_string.length\
    \ && depths_index < depths.length) {\n\e[31m\e[31m   |\e[0m        ^\e[0m\n\e\
    [31m   |\e[0m        Found:    Unit\n\e[31m   |\e[0m        Required: List[Long]\n\
    \e[31m45 |\e[0m            \e[34m// Find the longest sequence\e[0m\n\e[31m46 |\e\
    [0m            \e[33mval\e[0m \e[36mlongest_seq\e[0m = paren_chars.takeWhile(_\
    \ !="
  stdout: ''
  timestamp: 1660029219
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        var level : List[Long] = Nil\n        for(group <- paren_string.split(\"\
    \\\\s\")) {\n            group = group.trim\n            val temp = if (group.length\
    \ == 0)\n                Nil\n            else\n                parseNestedParensHelper(group,\
    \ level)\n            level = List(temp.size)\n        }\n        level.reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmp3j2fnruz.scala:12:18 -----------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m            group = group.trim\n\e[31m\e[31m   |\e[0m\
    \            ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            Reassignment\
    \ to val group\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp3j2fnruz.scala:16:16\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m                parseNestedParensHelper(group,\
    \ level)\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                Not found: parseNestedParensHelper\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660029211
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        // Initialize a max variable and an accumulator to count number of\
    \ open parantheses.\n        var max_level = 0\n        var count = 0\n      \
    \  // Keep traversing through each character of the string.\n        for (char\
    \ <- paren_string.toCharArray) {\n            // If the character is opening parentheses,\
    \ increment count of open parantheses.\n            if (char == '(') count +=\
    \ 1\n            // If the character is closing parentheses, decrement count of\
    \ open parantheses.\n            if (char == ')') count -= 1\n            // If\
    \ the count is 0, update the max_level variable and break out of the loop.\n \
    \           if (count == 0) max_level = count\n        }\n        // If the current\
    \ max_level value is bigger than the previous max_level value, update the max_level\
    \ value accordingly.\n        if (max_level > max_level) max_level = max_level\n\
    \        // Finally return the max_level value.\n        max_level.toList\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpug4x7aur.scala:25:18 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        max_level.toList\n\e[31m\e[31m   |\e[0m     \
    \   ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        value toList is not a member\
    \ of Int - did you mean Int.toInt?\n1 error found\n"
  stdout: ''
  timestamp: 1660029218
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val stringSet = paren_string.split(\" \").map(_.toUpperCase())\n\
    \        val paren_chars = paren_string.chars.toList\n        val paren_char_list:\
    \ List[Char] = paren_chars.filterNot(_ => '(').filterNot(_ => ')').toList\n  \
    \      val stack: List[Char] = new ListBuffer[Char]()\n        paren_char_list.foreach\
    \ { character =>\n            val is_opening = paren_char_list.contains(character)\n\
    \            val is_closing = paren_char_list.contains(character + '(')\n    \
    \        val is_open = paren_char_list.contains(character + '(')\n           \
    \ val is_close = paren_char_list.contains(character + '(')\n            val is_empty\
    \ = paren_char_list.contains(character + ')')\n\n            if (is_opening ||\
    \ is_close || is_empty || is_open || is_closing || paren_char_list.contains(character\
    \ + '(')) {\n                if (is_empty)\n                    stack.toList.reverse\n\
    \                else if (stack.size < 2)\n                    stack.toList.reverse\n\
    \                else\n                    stack.toList.reverse\n            }\
    \ else\n                stack.push(character)\n        }\n        stack.toList.reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp4_mtetm5.scala:11:45 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mparen_chars\e[0m = paren_string.chars.toList\n\
    \e[31m\e[31m   |\e[0m                          ^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m              value toList is not a member of java.util.stream.IntStream\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4_mtetm5.scala:13:32 --------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m: \e[35mList\e\
    [0m[\e[35mChar\e[0m] = \e[33mnew\e[0m \e[35mListBuffer\e[0m[\e[35mChar\e[0m]()\n\
    \e[31m\e[31m   |\e[0m                                ^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                     Found:    scala.collection.mutable.ListBuffer[Char]\n\
    \e[31m   |\e[0m                     Required: List[Char]\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmp4_mtetm5.scala:29:22 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m                stack.push(character)\n\e[31m\e[31m \
    \  |\e[0m                ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m     value push is not\
    \ a member of List[Char] - did you mean stack.last?\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmp4_mtetm5.scala:31:21 --------------------\e[0m\e[0m\n\
    \e[31m31 |\e[0m        stack.toList.reverse\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    List[\e[1m\e[31mChar\e[0m]\n\e[31m   |\e\
    [0m        Required: List[\e[1m\e[32mLong\e[0m]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660029223
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val parens = paren_string.trim().split(\"\\\\s+\").filter(_.length\
    \ != 0)\n        val paren_count = parens.length\n        val paren_stack = new\
    \ Stack[Long](paren_count)\n        parens.map(paren_stack += paren_stack.top).foldLeft[List[Long]](List.empty)((acc,\
    \ paren) => {\n            paren match {\n                case \"(\" => paren_stack.push(1l)\n\
    \                case \")\" => paren_stack.pop\n                case _ => acc\n\
    \            }\n            paren_stack\n        })\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"\
    () (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpnz0mdwyd.scala:13:19\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m        parens.map(paren_stack\
    \ += paren_stack.top).foldLeft[\e[35mList\e[0m[\e[35mLong\e[0m]](List.empty)((\e\
    [36macc\e[0m, \e[36mparen\e[0m) => {\n\e[31m\e[31m   |\e[0m                  \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m          Found:    (paren_stack\
    \ : scala.collection.mutable.Stack[Long])\n\e[31m   |\e[0m          Required:\
    \ String => Any\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- Error: /tmp/tmpnz0mdwyd.scala:13:50\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m13 |\e[0m       \
    \ parens.map(paren_stack += paren_stack.top).foldLeft[\e[35mList\e[0m[\e[35mLong\e\
    [0m]](List.empty)((\e[36macc\e[0m, \e[36mparen\e[0m) => {\n\e[31m\e[31m   |\e\
    [0m                                                  ^\e[0m\n\e[31m   |\e[0m \
    \                                         No ClassTag available for B\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m                                          where:  \
    \  B is a type variable\n2 errors found\n"
  stdout: ''
  timestamp: 1660029221
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        paren_string.split(\" \").map(x => {\n            val y = x.trim.split(\"\
    (\")\n            val z = y.map(z => z.trim.split(\")\"))\n            val n =\
    \ z.size\n            val m = y.size\n            if (n == 1 && m == 1) {\n  \
    \              y.map(z => z.trim.split(\"(\").map(x => x.trim.split(\")\").size).toList.head.toLong\n\
    \            } else if (n == m) {\n                y.map(z => z.trim.split(\"\
    (\").map(x => x.trim.split(\")\").size).toList.head.toLong + 1l.toLong\n     \
    \       } else {\n                0l.toLong\n            }\n        }).toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpx9feaa8z.scala:17:12 ---------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m            } \e[33melse\e[0m \e[33mif\e[0m (n == m)\
    \ {\n\e[31m\e[31m   |\e[0m            ^\e[0m\n\e[31m   |\e[0m            ')' expected,\
    \ but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpx9feaa8z.scala:19:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m19 |\e[0m            } \e[33melse\e\
    [0m {\n\e[31m\e[31m   |\e[0m            ^\e[0m\n\e[31m   |\e[0m            ')'\
    \ expected, but '}' found\n2 errors found\n"
  stdout: ''
  timestamp: 1660029219
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_levels = mutable.MutableList[Long]()\n        for (char\
    \ <- paren_string.toCharArray) {\n            if (char == '(') paren_levels +=\
    \ 1\n            if (char == ')') paren_levels -= 1 \n        }\n        paren_levels\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpu73uwzay.scala:10:27 ------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e[36mparen_levels\e[0m = mutable.MutableList[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                           ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                           Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660029219
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_str = paren_string.trim\n        val paren_str_length =\
    \ paren_str.length\n        var paren_depth = 0\n        var paren_level_size\
    \ = 0\n\n        // Create a list of [paren_depth, paren_level_size] pairs.\n\
    \        // The first paren_level has the highest paren_depth.\n        // The\
    \ next paren_level has the next highest paren_depth.\n        var paren_level_pairs:\
    \ List[(Long, Long)] =\n            paren_str.split(\" \").foldRight((0l, 0l))((a,b)\
    \ => \n                (a._1 + b.toLong,\n                 a._2 + 1L))\n\n   \
    \     // Iterate through the list to determine the deepest level of nesting.\n\
    \        while (paren_level_pairs.last._2 > paren_depth) {\n            paren_level_pairs\
    \ = paren_level_pairs.tail\n            paren_level_pairs.reverse.foreach { case\
    \ (_, size) => paren_level_pairs = paren_level_pairs.tail }\n        }\n\n   \
    \     // Return the list\n        val result = paren_level_pairs.last._1\n   \
    \     paren_level_pairs.dropRight(1).reverse.foreach(x => result += x._1)\n  \
    \      result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp2ofezj9h.scala:20:19 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m                (a._1 + b.toLong,\n\e[31m\e[31m   |\e\
    [0m                 ^^^^\e[0m\n\e[31m   |\e[0m                 value _1 is not\
    \ a member of String\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp2ofezj9h.scala:21:19\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m                 a._2 + \e\
    [31m1L\e[0m))\n\e[31m\e[31m   |\e[0m                 ^^^^\e[0m\n\e[31m   |\e[0m\
    \                 value _2 is not a member of String\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmp2ofezj9h.scala:31:67 ------------------------\e[0m\e[0m\n\
    \e[31m31 |\e[0m        paren_level_pairs.dropRight(\e[31m1\e[0m).reverse.foreach(\e\
    [36mx\e[0m => result += x._1)\n\e[31m\e[31m   |\e[0m                         \
    \                                   ^^^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \    value += is not a member of Long - did you mean result.!=?\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmp2ofezj9h.scala:32:8 ---------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        result\n\e[31m\e[31m   |\e[0m        ^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    (result : Long)\n\e[31m   |\e[0m       \
    \ Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660029227
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val pattern = \"\"\"(?:\\(|\\()|(?<=(?:\\)))|(?<=(?:\\()|\\)))\"\"\
    \".r\n        val paren_list = new mutable.ListBuffer[Long]()\n        var i =\
    \ 0\n        while(i < paren_string.length) {\n            val result = paren_string.find(pattern(i))\n\
    \            if (result == None) {\n                paren_list += 0\n        \
    \    } else {\n                if (result(1) == 1) {\n                    paren_list\
    \ += 0\n                } else if (result(1) == -1) {\n                    paren_list\
    \ += paren_list.length\n                }\n            }\n            i += 1\n\
    \        }\n        paren_list.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpt33dh41c.scala:11:29 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mparen_list\e[0m = \e[33mnew\e\
    [0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m             \
    \                ^^^^^^^\e[0m\n\e[31m   |\e[0m                             Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E050] Type Error: /tmp/tmpt33dh41c.scala:14:43\
    \ -----------------------------\e[0m\e[0m\n\e[31m14 |\e[0m            \e[33mval\e\
    [0m \e[36mresult\e[0m = paren_string.find(pattern(i))\n\e[31m\e[31m   |\e[0m \
    \                                          ^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                             \e[33mvalue\e[0m \e[35mpattern\e[0m does not take\
    \ parameters\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E050] Type Error: /tmp/tmpt33dh41c.scala:18:20\
    \ -----------------------------\e[0m\e[0m\n\e[31m18 |\e[0m                \e[33mif\e\
    [0m (result(\e[31m1\e[0m) == \e[31m1\e[0m) {\n\e[31m\e[31m   |\e[0m          \
    \          ^^^^^^\e[0m\n\e[31m   |\e[0m                    \e[33mvalue\e[0m \e\
    [35mresult\e[0m does not take parameters\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E050]\
    \ Type Error: /tmp/tmpt33dh41c.scala:20:27 -----------------------------\e[0m\e\
    [0m\n\e[31m20 |\e[0m                } \e[33melse\e[0m \e[33mif\e[0m (result(\e\
    [31m1\e[0m) == -\e[31m1\e[0m) {\n\e[31m\e[31m   |\e[0m                       \
    \    ^^^^^^\e[0m\n\e[31m   |\e[0m                           \e[33mvalue\e[0m \e\
    [35mresult\e[0m does not take parameters\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660029220
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_splits = paren_string.split(\" \").map(_.toLong)\n    \
    \    val parentheses_levels : List[Long] = paren_splits.foldLeft(List[Long](0l)){\
    \ (acc, el) =>\n            if(el > acc.last){\n                val l = [el -\
    \ acc.last]\n                acc.reverse ::: l\n            } else acc.reverse\n\
    \        }\n        parentheses_levels.map(_.toLong)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"\
    () (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp5mwvwnao.scala:13:28 ---------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m                \e[33mval\e[0m \e[36ml\e[0m = [el - acc.last]\n\
    \e[31m\e[31m   |\e[0m                            ^\e[0m\n\e[31m   |\e[0m     \
    \                       ']' expected, but identifier found\n\e[31m\e[31m-- [E040]\
    \ Syntax Error: /tmp/tmp5mwvwnao.scala:14:0 ----------------------------\e[0m\e\
    [0m\n\e[31m14 |\e[0m                acc.reverse ::: l\n\e[31m\e[31m   |\e[0m^^^\e\
    [0m\n\e[31m   |\e[0m'=>' expected, but 'end of statement' found\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmp5mwvwnao.scala:14:28 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m                acc.reverse ::: l\n\e[31m\e[31m   |\e\
    [0m                            ^^^^^\e[0m\n\e[31m   |\e[0m                   \
    \         value ::: is not a member of Null\n3 errors found\n"
  stdout: ''
  timestamp: 1660029229
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        paren_string.split(\" \").map { s =>\n            val brackets =\
    \ bracketPairs(s)\n            if (brackets.isEmpty) {\n                sys.error(\"\
    Parenthesis string '\" + paren_string + \"' does not contain any brackets!\")\n\
    \            }\n            s.split(\"\\\\(\").map { bracketPair =>\n        \
    \        bracketPair.split(\"\\\\)\")\n            }.flatMap { bracketPair =>\n\
    \                bracketPair.map { bracketPair =>\n                    if (bracketPair.length\
    \ == 1) {\n                        val startIndex = bracketPair.indexOf(bracketPair(0))\n\
    \                        val endIndex = bracketPair.length + startIndex + 1\n\
    \                        val currentLevel = bracketPair.length - startIndex\n\
    \                        List(startIndex, endIndex, currentLevel)\n          \
    \          } else {\n                        val startIndex = bracketPair.indexOf(bracketPair(0))\n\
    \                        val endIndex = bracketPair.length + startIndex + 1\n\
    \                        val currentLevel = bracketPair.length - startIndex\n\
    \                        List(startIndex, endIndex, currentLevel)\n          \
    \          }\n                }\n            }.maxBy(_._3) match {\n         \
    \       case (startIndex, endIndex, currentLevel) =>\n                    List(startIndex,\
    \ endIndex, currentLevel)\n                case _ =>\n                    sys.error(\"\
    Parenthesis string '\" + paren_string + \"' does not contain any brackets!\" +\
    \ \" Please check brackets!\");\n            }\n        }.maxBy(_._2)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()())\
    \ ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpzfa_hxk2.scala:11:27 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m            \e[33mval\e[0m \e[36mbrackets\e[0m = bracketPairs(s)\n\
    \e[31m\e[31m   |\e[0m                           ^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                           Not found: bracketPairs\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpzfa_hxk2.scala:31:22 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m            }.maxBy(_._3) \e[33mmatch\e[0m {\n\e[31m\e\
    [31m   |\e[0m                    ^^^^\e[0m\n\e[31m   |\e[0m                  \
    \  value _3 is not a member of List[Int]\n\e[31m\e[31m-- Error: /tmp/tmpzfa_hxk2.scala:31:25\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m31 |\e[0m       \
    \     }.maxBy(_._3) \e[33mmatch\e[0m {\n\e[31m\e[31m   |\e[0m                \
    \         ^\e[0m\n\e[31m   |\e[0mambiguous given instances: both \e[33mobject\e\
    [0m \e[35mByte\e[0m in \e[33mobject\e[0m \e[35mOrdering\e[0m and \e[33mobject\e\
    [0m \e[35mShort\e[0m in \e[33mobject\e[0m \e[35mOrdering\e[0m match type Ordering[B]\
    \ of parameter cmp of \e[33mmethod\e[0m \e[35mmaxBy\e[0m in \e[33mtrait\e[0m \e\
    [35mIterableOnceOps\e[0m\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpzfa_hxk2.scala:33:25\
    \ ------------------------\e[0m\e[0m\n\e[31m33 |\e[0m                    List(startIndex,\
    \ endIndex, currentLevel)\n\e[31m\e[31m   |\e[0m                         ^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                         Not found: startIndex\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpzfa_hxk2.scala:33:37 ------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m                    List(startIndex, endIndex, currentLevel)\n\
    \e[31m\e[31m   |\e[0m                                     ^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                                     Not found: endIndex\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpzfa_hxk2.scala:33:47 ------------------------\e\
    [0m\e[0m\n\e[31m3"
  stdout: ''
  timestamp: 1660029234
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        // Find all groups in paren_string separated by spaces\n        val\
    \ group_list : List[(String,List[String])] = paren_string.split(\"\\\\s+\".r).map(\n\
    \            x => (x.trim,List[String]())\n        ).filter(x => !x._1.isEmpty).map(x\
    \ => (x._1,x._2.map(_.trim))).toList\n        val max_nested_level = group_list.map(_.map(_(1).size).max).max\n\
    \        group_list.map(x => x(1).size - x(1).map(_.size).max)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((()))\
    \ () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp44otx_u1.scala:11:81\
    \ --------------------\e[0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mgroup_list\e\
    [0m : \e[35mList\e[0m[(\e[35mString\e[0m,\e[35mList\e[0m[\e[35mString\e[0m])]\
    \ = paren_string.split(\e[31m\"\\\\s+\"\e[0m.r).map(\n\e[31m\e[31m   |\e[0m  \
    \                                                                        ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                     Found:    scala.util.matching.Regex\n\
    \e[31m   |\e[0m                                     Required: String\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E081] Type Error: /tmp/tmp44otx_u1.scala:14:52 -----------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mmax_nested_level\e[0m =\
    \ group_list.map(_.map(_(\e[31m1\e[0m).size).max).max\n\e[31m\e[31m   |\e[0m \
    \                                                   ^\e[0m\n\e[31m   |\e[0m  \
    \ Missing parameter type\n\e[31m   |\e[0m\n\e[31m   |\e[0m   I could not infer\
    \ the type of the parameter _$3 of expanded function:\n\e[31m   |\e[0m   _$3 =>\
    \ _$3(1).size.\n\e[31m\e[31m-- Error: /tmp/tmp44otx_u1.scala:14:71 -----------------------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mmax_nested_level\e[0m =\
    \ group_list.map(_.map(_(\e[31m1\e[0m).size).max).max\n\e[31m\e[31m   |\e[0m \
    \                                                                      ^\e[0m\n\
    \e[31m   |\e[0mambiguous given instances: both \e[33mobject\e[0m \e[35mByte\e\
    [0m in \e[33mobject\e[0m \e[35mOrdering\e[0m and \e[33mobject\e[0m \e[35mDeprecatedFloatOrdering\e\
    [0m in \e[33mobject\e[0m \e[35mOrdering\e[0m match type Ordering[B] of parameter\
    \ ord of \e[33mmethod\e[0m \e[35mmax\e[0m in \e[33mtrait\e[0m \e[35mIterableOnceOps\e\
    [0m\n3 errors found\n"
  stdout: ''
  timestamp: 1660029231
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        var result: List[Long] = Nil\n        // Create a list of open and\
    \ close paren\n        val paren_list = paren_string.split(\"(?<=\\\\()|\\\\)(?=\\\
    \\))\").map(_.toLong)\n        // Create a map of (open,close) pair\n        val\
    \ open_close = paren_list.zip(paren_list).map{ case (open_close, close_open) =>\
    \ (open_close, close_open) }.toMap\n        // Get the level of nesting for each\
    \ open paren\n        for (open_close <- open_close.keys) {\n            val open_paren\
    \ = open_close._1\n            val close_paren = open_close._2\n            val\
    \ open_paren_level = open_paren.toInt - 1\n            val close_paren_level =\
    \ close_paren.toInt - 1\n            if (open_paren_level < close_paren_level)\
    \ {\n                val open_close_list = open_close.filter(_._1 <= open_paren_level).map(_._1).toList\n\
    \                val close_close_list = open_close.filter(_._2 > close_paren_level).map(_._2).toList\n\
    \                val close_list = new List(close_close_list.tail).reverse.map(x\
    \ => close_paren_level - x).toList\n                val open_list = open_close_list.map(x\
    \ => open_paren_level + x).toList\n                val result = open_close_list.zip(close_list).foldLeft(open_list)((x,\
    \ y) => x ++ y)\n            }\n        }\n        result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"\
    () (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpm9x8_3u3.scala:17:40 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m            \e[33mval\e[0m \e[36mopen_paren\e[0m = open_close._1\n\
    \e[31m\e[31m   |\e[0m                             ^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0m                             value _1 is not a member of Long\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpm9x8_3u3.scala:18:41 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m            \e[33mval\e[0m \e[36mclose_paren\e[0m = open_close._2\n\
    \e[31m\e[31m   |\e[0m                              ^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                              value _2 is not a member of Long\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpm9x8_3u3.scala:22:49 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m                \e[33mval\e[0m \e[36mopen_close_list\e\
    [0m = open_close.filter(_._1 <= open_paren_level).map(_._1).toList\n\e[31m\e[31m\
    \   |\e[0m                                      ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                                    value filter is not a member of\
    \ Long\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpm9x8_3u3.scala:23:50 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m                \e[33mval\e[0m \e[36mclose_close_list\e\
    [0m = open_close.filter(_._2 > close_paren_level).map(_._2).toList\n\e[31m\e[31m\
    \   |\e[0m                                       ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                                    value filter is not a member of\
    \ Long\n\e[31m\e[31m-- Error: /tmp/tmpm9x8_3u3.scala:24:59 -----------------------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m                \e[33mval\e[0m \e[36mclose_list\e[0m\
    \ = \e[33mnew\e[0m \e[35mList\e[0m(close_close_list.tail).reverse.map(\e[36mx\e\
    [0m => close_paren_level - x).toList\n\e[31m\e[31m   |\e[0m                  \
    \                        ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m      too\
    \ many arguments for \e[33mconstructor\e[0m \e[35mList\e[0m in \e[33mclass\e[0m\
    \ \e[35mList\e[0m: (): List[A]\n5 errors found\n"
  stdout: ''
  timestamp: 1660029233
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val stack = mutable.Stack[String]()\n        val max_level = 0\n\
    \        paren_string.split(\"\\\\s(?=\\\\()\").foreach(elem => {\n          \
    \  val cur = paren_string replace elem \"\" //replace space with empty string\n\
    \            val cur_list = parseNestedParens(cur)\n            if (cur_list.length\
    \ >= max_level)\n                max_level = cur_list.length\n            stack\
    \ push elem\n        })\n        stack map {elem => elem +: parseNestedParens(elem)}\
    \ filter { _ > 0 } map {elem => elem.length.toLong} max //get longest level\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp6339cqyt.scala:13:48 -----------------------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m            \e[33mval\e[0m \e[36mcur\e[0m = paren_string\
    \ replace elem \e[31m\"\"\e[0m \e[34m//replace space with empty string\e[0m\n\e\
    [31m\e[31m   |\e[0m                                                ^\e[0m\n\e\
    [31m   |\e[0m                      end of statement expected but string literal\
    \ found\n\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp6339cqyt.scala:19:113 --------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        stack map {\e[36melem\e[0m => elem +: parseNestedParens(elem)}\
    \ filter { _ > \e[31m0\e[0m } map {\e[36melem\e[0m => elem.length.toLong} max\
    \ \e[34m//get longest level\e[0m\n\e[31m\e[31m   |\e[0m                      \
    \                                                                            \
    \               ^\e[0m\n\e[31m   |\e[0m                                      \
    \ expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp6339cqyt.scala:10:20 ------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E134] Type Error: /tmp/tmp6339cqyt.scala:13:35 -----------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m            \e[33mval\e[0m \e[36mcur\e[0m = paren_string\
    \ replace elem \e[31m\"\"\e[0m \e[34m//replace space with empty string\e[0m\n\e\
    [31m\e[31m   |\e[0m                      ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e[35mreplace\e[0m\
    \ in \e[33mclass\e[0m \e[35mString\e[0m with types\n\e[31m   |\e[0m (x$0: CharSequence,\
    \ x$1: CharSequence): String\n\e[31m   |\e[0m (x$0: Char, x$1: Char): String\n\
    \e[31m   |\e[0mmatch arguments ((elem : String))\n\e[31m\e[31m-- [E052] Type Error:\
    \ /tmp/tmp6339cqyt.scala:16:26 -----------------------------\e[0m\e[0m\n\e["
  stdout: ''
  timestamp: 1660029227
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        def nestedParens(paren_string : String) : List[Long] = {\n      \
    \      // Initialize the list of current levels.\n            var level = 0\n\
    \            var current = 1\n            var currentString : String = \"\"\n\
    \            var paren_chars : List[Int] = paren_string.toCharArray\n        \
    \    // For each character in the string check if it's a left or right parenthesis.\n\
    \            for (c <- paren_chars) {\n                currentString += c\n  \
    \              if (c == '(') {\n                    current++\n              \
    \      if (current > level) {\n                        level = current\n     \
    \               }\n                }\n                else if (c == ')') {\n \
    \                   current--\n                }\n            }\n            val\
    \ l = new ListBuffer[Long]\n            // Add the current level to the list.\n\
    \            l += level\n            // Return the list.\n            l.toList\n\
    \        }\n\n        // Initialize the list of current levels.\n        var level\
    \ = 0\n        var current = 1\n        var currentString : String = \"\"\n  \
    \      var paren_chars : List[Int] = paren_string.toCharArray\n        // For\
    \ each character in the string check if it's a left or right parenthesis.\n  \
    \      for (c <- paren_chars) {\n            currentString += c\n            if\
    \ (c == '(') {\n                current++\n                if (current > level)\
    \ {\n                    level = current\n                }\n            }\n \
    \           else if (c == ')') {\n                current--\n            }\n \
    \       }\n        val l = new ListBuffer[Long]\n        // Add the current level\
    \ to the list.\n        l += level\n        // Return the list.\n        l.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp9kaivkxy.scala:20:29 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m                    current++\n\e[31m\e[31m   |\e[0m\
    \                             ^\e[0m\n\e[31m   |\e[0m                        \
    \     expression expected but \e[31mif\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E018] Syntax Error: /tmp/tmp9kaivkxy.scala:26:29 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m                    current--\n\e[31m\e[31m   |\e[0m\
    \                             ^\e[0m\n\e[31m   |\e[0m                        \
    \     expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E018] Syntax Error: /tmp/tmp9kaivkxy.scala:45:25 ---------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m                current++\n\e[31m\e[31m   |\e[0m    \
    \                     ^\e[0m\n\e[31m   |\e[0m                         expression\
    \ expected but \e[31mif\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmp9kaivkxy.scala:51:25 ---------------------------\e[0m\e[0m\n\e[31m51\
    \ |\e[0m                current--\n\e[31m\e[31m   |\e[0m                     \
    \    ^\e[0m\n\e[31m   |\e[0m                         expression expected but \e\
    [31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp9kaivkxy.scala:15:42\
    \ --------------------\e[0m\e[0m\n\e[31m15 |\e[0m            \e[33mvar\e[0m \e\
    [36mparen_chars\e[0m : \e[35mList\e[0m[\e[35mInt\e[0m] = paren_string.toCharArray\n\
    \e[31m\e[31m   |\e[0m                                          ^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                          Found:    Array[Char]\n\
    \e[31m   |\e[0m                                          Required: List[Int]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp9kaivkxy."
  stdout: ''
  timestamp: 1660029235
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        // Use a mutable list to store all the group lengths\n        var\
    \ max_group_length : Long = 0\n        val paren_groups : mutable.Buffer[List[Long]]\
    \ =\n            paren_string.split(\"\\\\s+\".r).map(x => x.split(\"\\\\(\".toString.r).map(y\
    \ => y.toString.toLong).grouped(x.toString.toLong).toList).toList\n        paren_groups.filter(x\
    \ => x.forall(y => y.toString.toLong > 0)).foreach(x => max_group_length = x.max().toString.toLong)\n\
    \        max_group_length\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp_hhu_9qc.scala:12:27 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mparen_groups\e[0m : mutable.Buffer[\e\
    [35mList\e[0m[\e[35mLong\e[0m]] =\n\e[31m\e[31m   |\e[0m                     \
    \      ^^^^^^^\e[0m\n\e[31m   |\e[0m                           Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp_hhu_9qc.scala:13:38\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m            paren_string.split(\e\
    [31m\"\\\\s+\"\e[0m.r).map(\e[36mx\e[0m => x.split(\e[31m\"\\\\(\"\e[0m.toString.r).map(\e\
    [36my\e[0m => y.toString.toLong).grouped(x.toString.toLong).toList).toList\n\e\
    [31m\e[31m   |\e[0m                               ^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                               Found:    scala.util.matching.Regex\n\e[31m\
    \   |\e[0m                               Required: String\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp_hhu_9qc.scala:13:73 --------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m            paren_string.split(\e[31m\"\\\\s+\"\e[0m.r).map(\e\
    [36mx\e[0m => x.split(\e[31m\"\\\\(\"\e[0m.toString.r).map(\e[36my\e[0m => y.toString.toLong).grouped(x.toString.toLong).toList).toList\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \  ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                                    \
    \ Found:    scala.util.matching.Regex\n\e[31m   |\e[0m                       \
    \              Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp_hhu_9qc.scala:13:123 -------------------\e[0m\e[0m\n\e[31m13\
    \ |\e[0m            paren_string.split(\e[31m\"\\\\s+\"\e[0m.r).map(\e[36mx\e\
    [0m => x.split(\e[31m\"\\\\(\"\e[0m.toString.r).map(\e[36my\e[0m => y.toString.toLong).grouped(x.toString.toLong).toList).toList\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                                       "
  stdout: ''
  timestamp: 1660029234
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        var result = Nil\n        var paren_stack = new mutable.Queue[String]()\n\
    \        paren_stack += paren_string\n        var nesting_level = 0\n\n      \
    \  while (paren_stack.nonEmpty) {\n            paren_string = paren_stack.poll()\n\
    \            if (paren_string == \"(\") {\n                paren_stack.enqueue(\"\
    )\")\n                nesting_level += 1\n                if (nesting_level >\
    \ 1) {\n                    result = result :+ nesting_level.toLong\n        \
    \        }\n            } else if (paren_string == \")\") {\n                paren_stack.enqueue(\"\
    (\")\n                nesting_level -= 1\n            }\n        }\n        return\
    \ result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpk0a2vjqe.scala:11:30 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mvar\e[0m \e[36mparen_stack\e[0m = \e[33mnew\e\
    [0m mutable.Queue[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                \
    \              ^^^^^^^\e[0m\n\e[31m   |\e[0m                              Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmpk0a2vjqe.scala:16:25\
    \ -----------------------------\e[0m\e[0m\n\e[31m16 |\e[0m            paren_string\
    \ = paren_stack.poll()\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m            Reassignment to val paren_string\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpk0a2vjqe.scala:21:29 --------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m                    result = result :+ nesting_level.toLong\n\
    \e[31m\e[31m   |\e[0m                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                           Found:    List[Long]\n\e[31m  \
    \ |\e[0m                           Required: scala.collection.immutable.Nil.type\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660029233
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        // Convert string into stream of characters\n        val charStream\
    \ = scala.io.Codec.ascii.getDecoder.decodeString(paren_string)\n        // Keep\
    \ track of number of open parens\n        var numOpeningParens = 0\n        //\
    \ Keep track of number of closing parens\n        var numClosingParens = 0\n \
    \       // Keep track of number of opening braces\n        var numOpeningBraces\
    \ = 0\n        // Keep track of number of closing braces\n        var numClosingBraces\
    \ = 0\n        // Keep track of number of open brackets\n        var numOpeningBrackets\
    \ = 0\n        // Keep track of number of closing brackets\n        var numClosingBrackets\
    \ = 0\n        // Keep track of number of open angles\n        var numOpeningAngles\
    \ = 0\n        // Keep track of number of closing angles\n        var numClosingAngles\
    \ = 0\n        // Keep track of number of open commas\n        var numOpeningCommas\
    \ = 0\n        // Keep track of number of closing commas\n        var numClosingCommas\
    \ = 0\n        \n        // Keep track of deepest level of nesting of parens\n\
    \        var deepestLevelOfNesting = 0\n        \n        // Keep track of number\
    \ of open parens\n        while(numOpeningParens == 0 && numClosingParens == 0\
    \ && numOpeningBraces == 0 && numClosingBraces == 0 && numOpeningBrackets == 0\
    \ && numClosingBrackets == 0 && numOpeningAngles == 0 && numClosingAngles == 0\
    \ && numOpeningCommas == 0 && numClosingCommas == 0) {\n            // Read next\
    \ character from the stream\n            val c = charStream.read()\n         \
    \   // If it is opening parentheses, increase the count\n            if(c.toInt\
    \ == '(') numOpeningParens += 1\n            // If it is closing parentheses,\
    \ decrease the count\n            else if(c.toInt == '(') numClosingParens -=\
    \ 1\n            // If it is opening braces, increase the count\n            else\
    \ if(c.toInt == '{') numOpeningBraces += 1\n            // If it is closing braces,\
    \ decrease the count\n            else if(c.toInt == '}') numClosingBraces -=\
    \ 1\n            // If it is opening brackets, increase the count\n          \
    \  else if(c.toInt == '[') numOpeningBrackets += 1\n            // If it is closing\
    \ brackets, decrease the count\n            else if(c.toInt == ']') numClosingBrackets\
    \ -= 1\n            // If it is opening angles, increase the count\n         \
    \   else if(c.toInt == '<') numOpeningAngles += 1\n            // If it is closing\
    \ angles, decrease the count\n            else if(c.toInt == '>') numClosingAngles\
    \ -= 1\n            // If it is opening commas, \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpvp0rwb32.scala:65:0 ----------------------------\e\
    [0m\e[0m\n\e[31m65 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpvp0rwb32.scala:11:40\
    \ ------------------------\e[0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e\
    [36mcharStream\e[0m = scala.io.Codec.ascii.getDecoder.decodeString(paren_string)\n\
    \e[31m\e[31m   |\e[0m                         ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                    value ascii is not a member of object scala.io.Codec\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpvp0rwb32.scala:64:1 ---------------------\e\
    [0m\e[0m\n\e[31m64 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e[0m\n\e[31m   |\e[0m Found:\
    \    Unit\n\e[31m   |\e[0m Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[33m\e[33m--\
    \ Warning: /tmp/tmpvp0rwb32.scala:58:4 ----------------------------------------\e\
    [0m\e[0m\n\e[33m58 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m\
    \   |\e[0m    Line is indented too far to the left, or a `}` is missing\n1 warning\
    \ found\n3 errors found\n"
  stdout: ''
  timestamp: 1660029237
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_list = paren_string.split(\"\\\\(|\\\\)\")\n        val\
    \ paren_list_without_empty_lists = paren_list.filter(x => x.contains(\"()\"))\n\
    \        var list_with_max_count = 0\n        val max_list = new mutable.MutableList[Long]\n\
    \        var max_list_index = 0\n        for(i <- 0 until paren_list_without_empty_lists.length){\n\
    \            if(paren_list_without_empty_lists(i).contains(\"()\")){\n       \
    \         val paren_list2 = paren_list_without_empty_lists(i).split(\"\\\\(|\\\
    \\)\")\n                val paren_list2_without_empty_lists = paren_list2.filter(x\
    \ => x.contains(\"()\"))\n                if(paren_list2_without_empty_lists.size\
    \ > max_list.length){\n                    list_with_max_count = paren_list2_without_empty_lists.size\n\
    \                    max_list = paren_list2_without_empty_lists\n            \
    \        max_list_index = i\n                }\n            }\n        }\n   \
    \     max_list.getMax\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpcx6cg49w.scala:13:27 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mmax_list\e[0m = \e[33mnew\e\
    [0m mutable.MutableList[\e[35mLong\e[0m]\n\e[31m\e[31m   |\e[0m              \
    \             ^^^^^^^\e[0m\n\e[31m   |\e[0m                           Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmpcx6cg49w.scala:21:29\
    \ -----------------------------\e[0m\e[0m\n\e[31m21 |\e[0m                   \
    \ max_list = paren_list2_without_empty_lists\n\e[31m\e[31m   |\e[0m          \
    \          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                  Reassignment to val max_list\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660029230
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n      val (parens, paren_count) = paren_string.trim().toLowerCase match {\n\
    \          case \"\" => (List(), 0)\n          case \"()\" => (List(), 0)\n  \
    \        case s =>\n            val s_idx = s.indexOf(')')\n            val sub\
    \ = s.substring(0,s_idx)\n            val sub_list = parseNestedParens(sub)\n\
    \            val open = s.substring(s_idx, s.length)\n            val open_list\
    \ = parseNestedParens(open)\n            (sub_list, open_list ++ 1)\n        }\n\
    \      val parens_idx = paren_count - 1\n      val max_level = parens_idx / 2\n\
    \      val cur_level = (parens_idx) % 2\n      val open_pos = if (cur_level ==\
    \ 0) 0 else max_level\n      val closed_pos = open_pos + 1\n      val max_open_pos\
    \ = max_level + 2\n      if (parens_idx < max_open_pos * 2) max_open_pos\n   \
    \   else if (parens_idx > max_open_pos * 3) max_open_pos * 3\n      else if (parens_idx\
    \ > max_open_pos * 4) max_open_pos * 4\n      else if (parens_idx > max_open_pos\
    \ * 5) max_open_pos * 5\n      else if (parens_idx > max_open_pos * 6) max_open_pos\
    \ * 6\n      else if (parens_idx > max_open_pos * 7) max_open_pos * 7\n      else\
    \ {\n        val max_open_pos = max_level + 2\n        val max_close_pos = max_open_pos\
    \ * 4\n        if (parens_idx > max_open_pos * 3) max_open_pos * 3\n        else\
    \ if (parens_idx > max_open_pos * 4) max_open_pos * 4\n        else if (parens_idx\
    \ > max_close_pos * 2) max_open_pos * 2\n      }\n      val open_parens = parens.take(max_open_pos)\n\
    \      val close_parens = parens.take(max_close_pos)\n      (open_parens ++ close_parens)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpkfh1ez6m.scala:19:36\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            (sub_list, open_list\
    \ ++ \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m                                    ^\e\
    [0m\n\e[31m   |\e[0m                                    Found:    (\e[31m1\e[0m\
    \ : Int)\n\e[31m   |\e[0m                                    Required: IterableOnce[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpkfh1ez6m.scala:21:35\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m      \e[33mval\e[0m \e[36mparens_idx\e\
    [0m = paren_count - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m                      \
    \ ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue - is not a member of Matchable, but\
    \ could be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mOne of the following imports might make progress towards fixing the problem:\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpkfh1ez6m.scala:41:37 ------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m      \e[33mval\e[0m \e[36mclose_parens\e[0m = parens.take(max_close_pos)\n\
    \e[31m\e[31m   |\e[0m                                     ^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                     Not found: max_close_pos\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660029239
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        var level = 0\n        var max_level = 0\n        var paren_count\
    \ = 0\n        var levels = [Long]()\n        var paren_char_count = 0\n     \
    \   var paren_char_index = 0\n        var paren_strings = paren_string.split(\"\
    \ \").toList.map(_.toChar)\n        while (paren_char_index < paren_strings.length)\
    \ {\n            if (paren_string(paren_char_index) == '(') {\n              \
    \  paren_count += 1\n                level = 0\n                paren_char_count\
    \ = 0\n                paren_char_index += 1\n                if (paren_string(paren_char_index)\
    \ != ')') {\n                    levels += 1\n                }\n            }\
    \ else {\n                paren_char_count += 1\n                level = level\
    \ + 1\n                if (paren_char_count == level) {\n                    paren_count\
    \ -= 1\n                    if (paren_count == 0 && paren_string(paren_char_index)\
    \ == '(') {\n                        max_level = level\n                    }\n\
    \                    paren_char_count = 0\n                    paren_strings =\
    \ paren_strings.dropRight(1)\n                    if (paren_strings.isEmpty) {\n\
    \                        break\n                    } else {\n               \
    \         paren_strings = paren_strings.tail\n                        levels =\
    \ [Long]()\n                    }\n                }\n            }\n        }\n\
    \        levels = levels.reverse\n        levels.foreach(l => if (max_level >\
    \ l) max_level = l)\n        levels.reverse\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmph3srffg5.scala:13:27 ---------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        \e[33mvar\e[0m \e[36mlevels\e[0m = [Long]()\n\
    \e[31m\e[31m   |\e[0m                           ^\e[0m\n\e[31m   |\e[0m      \
    \                     '=>' expected, but '(' found\n\e[31m\e[31m-- [E040] Syntax\
    \ Error: /tmp/tmph3srffg5.scala:40:39 ---------------------------\e[0m\e[0m\n\e\
    [31m40 |\e[0m                        levels = [Long]()\n\e[31m\e[31m   |\e[0m\
    \                                       ^\e[0m\n\e[31m   |\e[0m              \
    \                         '=>' expected, but '(' found\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmph3srffg5.scala:16:65 ------------------------\e[0m\e\
    [0m\n\e[31m16 |\e[0m        \e[33mvar\e[0m \e[36mparen_strings\e[0m = paren_string.split(\e\
    [31m\" \"\e[0m).toList.map(_.toChar)\n\e[31m\e[31m   |\e[0m                  \
    \                                             ^^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \                                 value toChar is not a member of String\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmph3srffg5.scala:24:27 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m                    levels += \e[31m1\e[0m\n\e[31m\e\
    [31m   |\e[0m                    ^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue += is not\
    \ a member of Null, but could be made available as an extension method.\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mOne of the following imports might fix the problem:\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.properties\
    \ AsScalaMap\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.list\
    \ asScalaBuffer\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.map\
    \ AsScalaConcurrentMap\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.set\
    \ asScala\n\e[31m   |\e[0m  import collection.convert.ImplicitConversionsToScala.list\
    \ asScalaBuffer\n\e[31m   |\e[0m  import collection.convert.ImplicitConversionsToScala.map\
    \ AsScalaConcurrentMap\n\e[31m   |\e[0m  import collection.convert.ImplicitConversionsToScala.properties\
    \ AsScalaMap\n\e[31m   |\e[0m  import collection.convert.ImplicitConversionsToScala.set\
    \ asScala\n\e[31m   |"
  stdout: ''
  timestamp: 1660029243
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        // This array has 2 elements and is initialized with 2 empty lists.\n\
    \        // The first element is the list of all nested groups,\n        // while\
    \ the second element is the list of all deepest levels.\n        // We loop over\
    \ all possible groups of the given paren_string.\n        // The code uses recursion\
    \ to explore all possible groups of nested parentheses.\n        // The final\
    \ list is the list of all deepest levels, with the last element removed.\n   \
    \     val groups: List[List[String]] = List(List(), List())\n        var group\
    \ = 0\n        var level = 0\n        val parens = paren_string.split(\" \")\n\
    \        val paren_level = paren_string.count(_ == '(')\n        var paren_group\
    \ = 0\n\n        for (i <- 0 until parens.length) {\n            val paren = parens(i)\n\
    \            if (paren == '(') {\n                groups(group) = paren_string.substring(0,\
    \ i)\n                paren_group = group\n                groups = groups.updated(group,\
    \ List(paren_string.substring(0, i)))\n                group = group + 1\n   \
    \         } else if (paren == ')') {\n                groups = groups.updated(group,\
    \ paren_string.substring(0, i).split(\" \"))\n                group = group -\
    \ 1\n                val paren_group_size = groups(group).count('(')\n       \
    \         for (j <- 0 until paren_group_size) {\n                    val paren_group_sub\
    \ = groups(group).split('(')\n                    groups = groups.updated(paren_group\
    \ - 1, List(paren_group_sub(0), paren_group_sub(j + 1)))\n                }\n\
    \                level = (paren_group - 1).toLong\n            } else {\n    \
    \            groups = groups.updated(group, paren_string.substring(0, i).split(\"\
    \ \"))\n                groups = groups.updated(group, List(paren_string.substring(0,\
    \ i)))\n                group = group + 1\n            }\n        }\n        if\
    \ (paren_level != paren_group) {\n            val tmp = groups(group)\n      \
    \      groups = groups.updated(group, tmp.substring(0, paren_level).split(\" \"\
    ))\n            groups = groups.updated(group, tmp)\n        }\n        groups(group)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpaw0bqtpx.scala:25:16 -----------------------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m            \e[33mif\e[0m (paren == \e[31m'('\e[0m) {\n\
    \e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \  Values of types String and Char cannot be compared with == or !=\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpaw0bqtpx.scala:26:16 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m                groups(group) = paren_string.substring(\e\
    [31m0\e[0m, i)\n\e[31m\e[31m   |\e[0m                ^^^^^^\e[0m\n\e[31m   |\e\
    [0mvalue update is not a member of List[List[String]] - did you mean groups.updated?\n\
    \e[31m\e[31m-- [E052] Type Error: /tmp/tmpaw0bqtpx.scala:28:23 -----------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m                groups = groups.updated(group, List(paren_string.substring(\e\
    [31m0\e[0m, i)))\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                Reassignment to val groups\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- Error: /tmp/tmpaw0bqtpx.scala:30:23 -----------------------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m            } \e[33melse\e[0m \e[33mif\e[0m (paren ==\
    \ \e[31m')'\e[0m) {\n\e[31m\e[31m   |\e[0m                       ^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Values of types String and Char cannot be compared\
    \ with == or !=\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpaw0bqtpx.scala:31:81\
    \ --------------------\e[0m\e[0m\n\e[31m31 |\e[0m                groups = groups.updated(group,\
    \ paren_string.substring(\e[31m0\e[0m, i).split(\e[31m\" \"\e[0m))\n\e[31m\e[31m\
    \   |\e[0m                                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                               Found:    \e\
    [1m\e[31mArray\e[0m[String]\n\e[31m   |\e[0m                                 \
    \              Required: \e[1m\e[32mList\e[0m[String]\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tm"
  stdout: ''
  timestamp: 1660029243
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        // Create a stack of lists\n        var nested_parens : List[List[Long]]\
    \ = Nil\n\n        // Create a stack of strings representing parenthesis\n   \
    \     var paren_strings : List[String] = Nil\n\n        // Iterate over the string\
    \ and push into stack\n        var index : Long = 1\n        while (index < paren_string.length)\
    \ {\n            // If the character is a closing parenthesis\n            if\
    \ (paren_string(index) == \"(\") {\n                // If the stack is empty (first\
    \ opening parenthesis)\n                if (nested_parens.length == 0) {\n   \
    \                 // Create a new list with index at 0 and increment index\n \
    \                   nested_parens = List((new List(index)))\n                \
    \    paren_strings = List((paren_string(index + 1)))\n                    index\
    \ += 1\n                }\n                // If the stack is not empty (nested\
    \ parenthesis)\n                else {\n                    // Find the corresponding\
    \ closing parenthesis in the string\n                    var close_paren_index\
    \ : Long = -1\n                    while (close_paren_index < paren_strings.length\
    \ - 1) {\n                        if (paren_strings(close_paren_index) == paren_string(index))\
    \ {\n                            break\n                        }\n          \
    \              close_paren_index += 1\n                    }\n               \
    \     // If found the corresponding closing parenthesis push into stack\n    \
    \                if (close_paren_index == paren_strings.length - 1) {\n      \
    \                  nested_parens = nested_parens ::: List(nested_parens(nested_parens.length\
    \ - 1).map(_.toLong).reverse)\n                        paren_strings = paren_strings\
    \ ::: List((paren_string(index + 1)))\n                        index += 1\n  \
    \                  }\n                    // Otherwise the closing parenthesis\
    \ does not belong to the nested parenthesis stack.\n                    else {\n\
    \                        // Remove the corresponding closing parenthesis from\
    \ the string stack\n                        paren_strings = paren_strings.init\n\
    \                        index += 1\n                    }\n                }\n\
    \            }\n            // If the character is a opening parenthesis\n   \
    \         else if (paren_string(index) == \"(\") {\n                // If the\
    \ stack is empty (first opening parenthesis)\n                if (nested_parens.length\
    \ == 0) {\n                    // Create a new list with index at 0 and increment\
    \ index\n                    nested_parens = List((new List(index)))\n       \
    \             paren_strings = List((paren_string(index + 1)))\n              \
    \      index += 1\n                }\n                // If the stack is not empty\
    \ (nested parenthesis)\n                else {\n                    // Find the\
    \ corresponding opening parenthesis in the string\n                    var open_paren_index\
    \ : Long = -1\n                    while (open_paren_index < paren_strings.length\
    \ - 1) {\n                        if (paren_strings(open_paren_index) == paren_string(index))\
    \ {\n                            break\n                        }\n          \
    \              open_paren_index += 1\n                    }\n                \
    \    // If found the corresponding opening parenthesis push into stack\n     \
    \               if (open_paren_index == paren_strings.length - 1) {\n        \
    \                nested_parens = nested_parens ::: List(nested_parens(nested_parens.length\
    \ - \n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpnoiwkd60.scala:73:99 ---------------------------\e\
    [0m\e[0m\n\e[31m73 |\e[0m                        nested_parens = nested_parens\
    \ ::: List(nested_parens(nested_parens.length - \n\e[31m\e[31m   |\e[0m      \
    \                                                                            \
    \                 ^\e[0m\n\e[31m   |\e[0m                                    \
    \   expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E040] Syntax Error: /tmp/tmpnoiwkd60.scala:82:0 ----------------------------\e\
    [0m\e[0m\n\e[31m82 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpnoiwkd60.scala:20:29\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m            \e[33mif\e[0m (paren_string(index)\
    \ == \e[31m\"(\"\e[0m) {\n\e[31m\e[31m   |\e[0m                             ^^^^^\e\
    [0m\n\e[31m   |\e[0m                             Found:    (index : Long)\n\e\
    [31m   |\e[0m                             Required: Int\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- Error: /tmp/tmpnoiwkd60.scala:24:51 -----------------------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m                    nested_parens = List((\e[33mnew\e\
    [0m \e[35mList\e[0m(index)))\n\e[31m\e[31m   |\e[0m                          \
    \                         ^^^^^\e[0m\n\e[31m   |\e[0m      too many arguments\
    \ for \e[33mconstructor\e[0m \e[35mList\e[0m in \e[33mclass\e[0m \e[35mList\e\
    [0m: (): List[A]\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpnoiwkd60.scala:25:55\
    \ --------------------\e[0m\e[0m\n\e[31m25 |\e[0m                    paren_strings\
    \ = List((paren_string(index + \e[31m1\e[0m)))\n\e[31m\e[31m   |\e[0m        \
    \                                               ^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                                                       Found:    Long\n\e[31m\
    \   |\e[0m                                                       Required: Int\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling wit"
  stdout: ''
  timestamp: 1660029243
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        def nestedLoop(i : Int, group : List[String], max_count : Int, count\
    \ : Int) : List[Long] = {\n            if(group.isEmpty) {\n                if(count\
    \ == max_count) {\n                    group match {\n                       \
    \ case Nil => List(1l.toLong)\n                        case head :: tail => nestedLoop(i\
    \ - 1, tail, max_count, count + 1)\n                    }\n                } else\
    \ {\n                    list match {\n                        case Nil => List(1l.toLong)\n\
    \                        case head :: tail => nestedLoop(i - 1, tail, max_count,\
    \ count)\n                    }\n                }\n            } else {\n   \
    \             max_count match {\n                    case 0 => list match {\n\
    \                        case Nil => List(1l.toLong)\n                       \
    \ case head :: tail => nestedLoop(i - 1, tail, count, count)\n               \
    \     }\n                    case head => list match {\n                     \
    \   case Nil => List(1l.toLong)\n                        case head :: tail =>\
    \ nestedLoop(i - 1, tail, count, count)\n                    }\n             \
    \   }\n            }\n        }\n        val list = paren_string.split(\" \").toList\n\
    \        list match {\n            case Nil => Nil\n            case head :: tail\
    \ => nestedLoop(0, tail, 0, 0)\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E039] Reference Error: /tmp/tmpnabmilzk.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m                    list \e[33mmatch\e[0m {\n\e[31m\e\
    [31m   |\e[0m                    ^^^^\e[0m\n\e[31m   |\e[0m       list is a forward\
    \ reference extending over the definition of list\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660029235
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        var max_level = List(0)\n        var paren_count = paren_string.length\n\
    \n        for( i <- 0 until paren_count ) {\n            if( paren_string contains\
    \ \"(\" ) {\n                if( max_level.isEmpty || max_level(0) < paren_count\
    \ ) {\n                    max_level :+= paren_count\n                }\n    \
    \            paren_count -= 1\n            } else if( paren_string contains \"\
    )\" ) {\n                if( paren_count > 0 ) {\n                    paren_count\
    \ -= 1\n                }\n            } else if( paren_string contains \" \"\
    \ ) {\n                if( paren_count > 0 ) {\n                    paren_count\
    \ -= 1\n                }\n            }\n        }\n\n        return max_level\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxn2xk6o8.scala:30:15\
    \ --------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mreturn\e[0m max_level\n\
    \e[31m\e[31m   |\e[0m               ^^^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \     Found:    (max_level : List[Int])\n\e[31m   |\e[0m               Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660029241
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        var deepest_level = 1\n\n        // Initialize all level to 1\n \
    \       val levels = mutable.LinkedHashMap[Long, Long]()\n        levels(1l.toLong)\
    \ = 1\n        levels(0l.toLong) = 1\n        \n        // Loop through all parenthesis\n\
    \        var level = 1\n        var pos = 0\n        var paren_count = 0\n   \
    \     var is_open = true\n        while((pos = paren_string.indexOf(\"(\", pos)\
    \ + 1) != -1) {\n            paren_count += 1\n            \n            // If\
    \ the level is not a sublevel of current, then count it.\n            if(levels(level)\
    \ != 1) {\n                levels(level) = paren_count\n            }\n      \
    \      \n            // Increase the level\n            level += 1\n         \
    \   \n            // Increase the parenthesis count\n            paren_count +=\
    \ 1\n            \n            // If the current level is not a sublevel of current\
    \ level, then increase the deepest level\n            if(levels(level) != 1) {\n\
    \                deepest_level += 1\n                levels(deepest_level) = paren_count\n\
    \            }\n            \n            // Check if the parenthesis is closed,\
    \ then decrease the parenthesis count.\n            if(paren_string.charAt(pos)\
    \ == ')') {\n                paren_count -= 1\n            }\n\n            //\
    \ Check if the string is closed.\n            if(paren_string.charAt(pos) == ')')\
    \ {\n                is_open = false\n            }\n            \n          \
    \  pos += 1\n        }\n        \n        // If the string is not closed, then\
    \ increase the deepest level.\n        if(paren_string.charAt(pos) != ')') {\n\
    \            deepest_level += 1\n            levels(deepest_level) = paren_count\n\
    \        }\n        \n        // If the deepest level is 1 and string is not closed,\
    \ then it means it is an empty string.\n        if(deepest_level == 1 && !is_open)\
    \ {\n            return List()\n        }\n        \n        return levels(deepest_level)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp3tdsqypp.scala:13:21 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mlevels\e[0m = mutable.LinkedHashMap[\e\
    [35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- Error: /tmp/tmp3tdsqypp.scala:22:14 -----------------------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mwhile\e[0m((pos = paren_string.indexOf(\e\
    [31m\"(\"\e[0m, pos) + \e[31m1\e[0m) != -\e[31m1\e[0m) {\n\e[31m\e[31m   |\e[0m\
    \              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0m           Values of types Unit and Int cannot be compared with == or\
    \ !=\n2 errors found\n"
  stdout: ''
  timestamp: 1660029242
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        if (paren_string.isEmpty) return Nil\n        var max : Long = 0\n\
    \        var results : List[Long] = Nil\n        var parantheses_count : Long\
    \ = 0\n        var paren_char : Char = paren_string.charAt(0)\n\n        for (i<-\
    \ 1 to paren_string.length-1) {\n            // We have reached the end of the\
    \ string without finding another parentheses.\n            if (paren_char != '(')\
    \ \n                break;\n\n            // Increment the count of open parentheses\
    \ encountered.\n            parantheses_count += 1;\n\n            // If the count\
    \ of open parentheses reaches equal to the count of closed parentheses encountered,\
    \ \n            // that means we encountered a right most parentheses.\n     \
    \       if (parantheses_count == paren_string.charAt(i) - paren_char) {\n    \
    \            // Add one to the count.\n                parantheses_count += 1;\n\
    \n                // If the max count of closing parentheses has not yet been\
    \ encountered, \n                // we encounter a left most parentheses.\n  \
    \              if (parantheses_count < max)\n                    max = parantheses_count\n\
    \            }\n\n            // Reset the count of parentheses encountered.\n\
    \            parantheses_count = 0;\n        }\n        // Add the count of closed\
    \ parentheses.\n        max += parantheses_count - 1\n        results = paren_string.drop(1).grouped(max).toList\n\
    \        results.reverse\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpojmot9i2.scala:19:16 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m                break;\n\e[31m\e[31m   |\e[0m       \
    \         ^^^^^\e[0m\n\e[31m   |\e[0m                Not found: break\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpojmot9i2.scala:41:47 --------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m        results = paren_string.drop(\e[31m1\e[0m).grouped(max).toList\n\
    \e[31m\e[31m   |\e[0m                                               ^^^\e[0m\n\
    \e[31m   |\e[0m                                               Found:    (max :\
    \ Long)\n\e[31m   |\e[0m                                               Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660029241
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        var max_count = 0\n        var max_level = IntMaxValue\n        paren_string.split(\"\
    \ \")\n            .flatMap(x => if(x.toDouble==\"()\") List() else List(x.toDouble.toLong))\n\
    \            .foreach { x =>\n            val count = x * (max_level + 1)\n  \
    \          if(count > max_count) max_count = count\n            max_level = count\n\
    \        }\n        List(max_level)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpoxti4lr6.scala:11:24 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mvar\e[0m \e[36mmax_level\e[0m = IntMaxValue\n\
    \e[31m\e[31m   |\e[0m                        ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                        Not found: IntMaxValue\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ Error: /tmp/tmpoxti4lr6.scala:13:29 -----------------------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m            .flatMap(x => \e[33mif\e[0m(x.toDouble==\e\
    [31m\"()\"\e[0m) List() \e[33melse\e[0m List(x.toDouble.toLong))\n\e[31m\e[31m\
    \   |\e[0m                             ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \      Values of types Double and String cannot be compared with == or !=\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660029241
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        // (1)\n        var max_level = 0\n        var min_level = 0\n  \
    \      var paren_index = 0\n        // (2)\n        var paren_list_with_pairs\
    \ = mutable.ListBuffer[(Int, Int)]()\n        for (i <- 0 until paren_string.length())\
    \ {\n            // (3)\n            val c = paren_string(i)\n            // (4)\n\
    \            if (c == '(') {\n                paren_index += 1\n            }\n\
    \            // (5)\n            if (c == ')') {\n                val level =\
    \ (paren_index - min_level)\n                // (6)\n                if (level\
    \ > max_level) {\n                    max_level = level\n                    //\
    \ (7)\n                    paren_list_with_pairs.clear()\n                   \
    \ paren_list_with_pairs += (paren_index, paren_index)\n                }\n   \
    \             // (8)\n                if (level < min_level) {\n             \
    \       min_level = level\n                    // (9)\n                    paren_index\
    \ += 1\n                }\n            }\n            // (10)\n            else\
    \ {\n                // (11)\n                val pair = (paren_index, paren_index)\n\
    \                // (12)\n                paren_list_with_pairs += pair\n    \
    \            paren_index += 1\n            }\n        }\n        // (13)\n   \
    \     if (max_level == 0) {\n            return paren_list_with_pairs.toList\n\
    \        }\n        else {\n            return paren_list_with_pairs.filter(_._1\
    \ <= max_level).toList\n        }\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp1in7gs49.scala:15:36 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mvar\e[0m \e[36mparen_list_with_pairs\e\
    [0m = mutable.ListBuffer[(\e[35mInt\e[0m, \e[35mInt\e[0m)]()\n\e[31m\e[31m   |\e\
    [0m                                    ^^^^^^^\e[0m\n\e[31m   |\e[0m         \
    \                           Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660029238
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_list = paren_string.split(\" +\")\n        val paren_ret_list\
    \ = paren_list.map(x => parseNestedParens(x))\n        val paren_ret_list1 = paren_ret_list.flatMap(x\
    \ => x)\n        val max1 = paren_ret_list1.maxBy(_.length)\n        val max2\
    \ = paren_ret_list1.maxBy(x => paren_ret_list1.count(y => y == x)).map(x => x.length)\n\
    \        val max3 = paren_ret_list1.maxBy(x => paren_ret_list1.count(y => y ==\
    \ x)).map(x => paren_ret_list1.count(y => y == x))\n        val max4 = paren_ret_list1.maxBy(x\
    \ => paren_ret_list1.count(y => y == x)).map(x => paren_ret_list1.count(y => y\
    \ == x)).map(x => x.toLong)\n\n        val max_list = max1 + max2 + max3 + max4\n\
    \        val max_list1 = max_list.map(x => x.toLong)\n        max_list1\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()())\
    \ ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp8l27o8hl.scala:13:43 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mmax1\e[0m = paren_ret_list1.maxBy(_.length)\n\
    \e[31m\e[31m   |\e[0m                                         ^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                                    value length is not a member\
    \ of Long\n\e[31m\e[31m-- Error: /tmp/tmp8l27o8hl.scala:13:50 -----------------------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mmax1\e[0m = paren_ret_list1.maxBy(_.length)\n\
    \e[31m\e[31m   |\e[0m                                                  ^\e[0m\n\
    \e[31m   |\e[0mambiguous given instances: both \e[33mobject\e[0m \e[35mByte\e\
    [0m in \e[33mobject\e[0m \e[35mOrdering\e[0m and \e[33mobject\e[0m \e[35mChar\e\
    [0m in \e[33mobject\e[0m \e[35mOrdering\e[0m match type Ordering[B] of parameter\
    \ cmp of \e[33mmethod\e[0m \e[35mmaxBy\e[0m in \e[33mtrait\e[0m \e[35mIterableOnceOps\e\
    [0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp8l27o8hl.scala:14:82 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mmax2\e[0m = paren_ret_list1.maxBy(\e\
    [36mx\e[0m => paren_ret_list1.count(\e[36my\e[0m => y == x)).map(\e[36mx\e[0m\
    \ => x.length)\n\e[31m\e[31m   |\e[0m                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                   value map is not a member of Long\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp8l27o8hl.scala:15:82 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mmax3\e[0m = paren_ret_list1.maxBy(\e\
    [36mx\e[0m => paren_ret_list1.count(\e[36my\e[0m => y == x)).map(\e[36mx\e[0m\
    \ => paren_ret_list1.count(\e[36my\e[0m => y == x))\n\e[31m\e[31m   |\e[0m   \
    \                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                   value map is not a member of Long\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp8l27o8hl.scala:16:82 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mmax4\e[0m = paren_ret_list1.maxBy(\e\
    [36mx\e[0m => paren_ret_list1.count(\e[36my\e[0m => y == x)).map(\e[36mx\e[0m\
    \ => paren_r"
  stdout: ''
  timestamp: 1660029248
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        paren_string\n            .split(\" \")\n            .map(x => paren_string\
    \ =~ x)\n            .foldLeft(List[Long]()) {\n            case (acc, x) => x\
    \ match {\n                case Some((_, parens)) => acc.reverse.updated(parens.size+x)\n\
    \                case None => acc.updated(x)\n            }\n        }\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()())\
    \ ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp7_rumf4s.scala:12:35 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m            .map(x => paren_string =~ x)\n\e[31m\e[31m\
    \   |\e[0m                      ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m      value\
    \ =~ is not a member of String - did you mean paren_string.==?\n\e[31m\e[31m--\
    \ Error: /tmp/tmp7_rumf4s.scala:12:40 -----------------------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m            .map(x => paren_string =~ x)\n\e[31m\e[31m\
    \   |\e[0m                                        ^\e[0m\n\e[31m   |\e[0m    \
    \                                    No ClassTag available for B\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m                                        where:    B is a type\
    \ variable\n2 errors found\n"
  stdout: ''
  timestamp: 1660029246
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \").map(x => x.split(\"\\\
    \\(\").map(y => y.split(\"\\\\)\").map(z => z.size.toLong).toSeq).flatten)\n \
    \       var max_nesting = -1\n        for (group <- paren_groups) {\n        \
    \    max_nesting = Math.max(max_nesting, group.max)\n        }\n        paren_groups.map(x\
    \ => x.max).toList\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp_t095dst.scala:13:48\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m            max_nesting = Math.max(max_nesting,\
    \ group.max)\n\e[31m\e[31m   |\e[0m                                          \
    \      ^^^^^^^^^\e[0m\n\e[31m   |\e[0m                                       \
    \         Found:    Long\n\e[31m   |\e[0m                                    \
    \            Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660029251
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_chars: List[Char] = paren_string.toCharArray\n        val\
    \ parentheses: List[Char] = paren_chars.takeWhile(_ != '(').toList\n        val\
    \ opening_parens_stack: List[String] = paren_chars.takeWhile(_ == '(').toList.reverse.takeWhile(_\
    \ != '(').toList\n        val opening_parens: String = \"\".join(opening_parens_stack.reverse)\n\
    \        val opening_parens_len = opening_parens.length\n        val paren_char_counts:\
    \ List[Long] = parentheses.foldLeft[List[Long]](Nil) { (acc, _) =>\n         \
    \   val i = acc.length\n            val c = paren_chars.toList\n            val\
    \ paren_char = paren_chars(i).toInt\n            val paren_count = opening_parens.count(x\
    \ => x == paren_char)\n            acc.updated(i, c+paren_count)\n        }\n\
    \        paren_char_counts.reverse\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp8mruw94w.scala:10:38\
    \ --------------------\e[0m\e[0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e[36mparen_chars\e\
    [0m: \e[35mList\e[0m[\e[35mChar\e[0m] = paren_string.toCharArray\n\e[31m\e[31m\
    \   |\e[0m                                      ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                      Found:    \e[1m\e[31mArray\e\
    [0m[Char]\n\e[31m   |\e[0m                                      Required: \e[1m\e\
    [32mList\e[0m[Char]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp8mruw94w.scala:12:116\
    \ -------------------\e[0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mopening_parens_stack\e\
    [0m: \e[35mList\e[0m[\e[35mString\e[0m] = paren_chars.takeWhile(_ == \e[31m'('\e\
    [0m).toList.reverse.takeWhile(_ != \e[31m'('\e[0m).toList\n\e[31m\e[31m   |\e\
    [0m                                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                                 Found:  \
    \  List[\e[1m\e[31mChar\e[0m]\n\e[31m   |\e[0m                               \
    \                  Required: List[\e[1m\e[32mString\e[0m]\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmp8mruw94w.scala:13:40 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mopening_parens\e[0m: \e\
    [35mString\e[0m = \e[31m\"\"\e[0m.join(opening_parens_stack.reverse)\n\e[31m\e\
    [31m   |\e[0m                                     ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \ value join is not a member of String - did you mean (\e[32m\"\"\e[0m : String).trim?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp8mruw94w.scala:20:28 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m            acc.updated(i, c+paren_count)\n\e[31m\e[31m\
    \   |\e[0m                           ^^\e[0m\n\e[31m   |\e[0mvalue + is not a\
    \ member of List[Char], but could be made available as an extension method.\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might make progress\
    \ toward"
  stdout: ''
  timestamp: 1660029254
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_list: List[(Long, Long)] = {\n            // Each element\
    \ in the list is a tuple containing the deepest level of nesting and the length\
    \ of the parentheses encountered at the current level.\n            val paren_length\
    \ = mutable.MutableList[Long]()\n            var paren_level = 0\n           \
    \ val parentheses_encountered = mutable.MutableList[String]()\n            def\
    \ process(paren_string : String, cur_level : Int) : Unit = {\n               \
    \ // Remove all unnecessary elements from the list of parentheses encountered\
    \ at this level.\n                val parentheses_encountered_index = parentheses_encountered.indexWhere(_\
    \ == paren_string)\n                if (parentheses_encountered_index > 0) {\n\
    \                    parentheses_encountered.remove(parentheses_encountered_index)\n\
    \                }\n\n                // Add one to the level of nesting at the\
    \ current level.\n                paren_level += 1\n\n                // If this\
    \ level of parentheses is empty, add it to the list of parentheses encountered\
    \ at this level.\n                if (paren_level == 0) {\n                  \
    \  paren_length += cur_level\n                    parenthesis_encountered.append(paren_string)\n\
    \                }\n            }\n\n            for (i <- 1 to paren_string.length\
    \ by 2) {\n                val left_paren_index = paren_string.indexOf('(', i)\n\
    \                val right_paren_index = paren_string.indexOf(')', i)\n      \
    \          val left_paren = paren_string.substring(left_paren_index + 1, right_paren_index\
    \ - 1)\n                val right_paren = paren_string.substring(right_paren_index\
    \ + 1, i)\n\n                // Add all the parentheses encountered at this level\
    \ to the list of parentheses encountered at this level.\n                parentheses_encountered.add(left_paren)\n\
    \                parentheses_encountered.add(right_paren)\n\n                //\
    \ Process this level of parentheses.\n                process(left_paren, paren_level)\n\
    \                process(right_paren, paren_level)\n            }\n          \
    \  paren_length match {\n                case Nil => Nil\n                case\
    \ (a :: b :: Nil) => List(a.toLong)\n                case (a :: b :: c :: Nil)\
    \ => List(a.toLong, b.toLong, c.toLong)\n                case (a :: b :: c ::\
    \ d :: Nil) => List(a.toLong, b.toLong, c.toLong, d.toLong)\n                case\
    \ (a :: b :: c :: d :: e :: Nil) => List(a.toLong, b.toLong, c.toLong, d.toLong,\
    \ e.toLong)\n                case (a :: b :: c :: d :: e :: f :: Nil) => List(a.toLong,\
    \ b.toLong, c.toLong, d.toLong, e.toLong, f.toLong)\n\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"\
    () (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp6_turh5_.scala:62:0 ----------------------------\e\
    [0m\e[0m\n\e[31m62 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp6_turh5_.scala:12:31\
    \ ------------------------\e[0m\e[0m\n\e[31m12 |\e[0m            \e[33mval\e[0m\
    \ \e[36mparen_length\e[0m = mutable.MutableList[\e[35mLong\e[0m]()\n\e[31m\e[31m\
    \   |\e[0m                               ^^^^^^^\e[0m\n\e[31m   |\e[0m       \
    \                        Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp6_turh5_.scala:14:42 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m            \e[33mval\e[0m \e[36mparentheses_encountered\e\
    [0m = mutable.MutableList[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m        \
    \                                  ^^^^^^^\e[0m\n\e[31m   |\e[0m             \
    \                             Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp6_turh5_.scala:28:20 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m                    parenthesis_encountered.append(paren_string)\n\
    \e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                    Not found: parenthesis_encountered\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp6_turh5_.scala:48:45 ------------------------\e\
    [0m\e[0m\n\e[31m48 |\e[0m                \e[33mcase\e[0m (a :: b :: Nil) => List(a.toLong)\n\
    \e[31m\e[31m   |\e[0m                                             ^\e[0m\n\e[31m\
    \   |\e[0m                                             Not found: a\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp6_turh5_.scala:49:50 ------------------------\e\
    [0m\e[0m\n\e[31m49 |\e[0m                \e[33mcase\e[0m (a :: b :: c :: Nil)\
    \ => List(a.toLong, b.toLong, c.toLong)\n\e[31m\e[31m "
  stdout: ''
  timestamp: 1660029255
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        var paren_list : List[Long] = Nil\n        var depth : List[Long]\
    \ = Nil\n        var group = 0\n        for (c <- paren_string.toCharArray) {\n\
    \            if (c == '(') depth += 1\n            if (c == ')') {\n         \
    \       depth -= 1\n                group += 1\n            }\n            if\
    \ (c == ' ' && depth >= 0 && group == 0) {\n                paren_list += depth\n\
    \                depth = Nil\n                group = Nil\n            }\n   \
    \     }\n        paren_list += group\n        return paren_list\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((()))\
    \ () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmph1theine.scala:14:32 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m            \e[33mif\e[0m (c == \e[31m'('\e[0m) depth\
    \ += \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m                          ^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m    value += is not a member of List[Long] - did you mean List[Long].!=?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmph1theine.scala:16:22 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m                depth -= \e[31m1\e[0m\n\e[31m\e[31m \
    \  |\e[0m                ^^^^^^^^\e[0m\n\e[31m   |\e[0m    value -= is not a member\
    \ of List[Long] - did you mean List[Long].!=?\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmph1theine.scala:19:34 ------------------------\e[0m\e[0m\n\e[31m19\
    \ |\e[0m            \e[33mif\e[0m (c == \e[31m' '\e[0m && depth >= \e[31m0\e[0m\
    \ && group == \e[31m0\e[0m) {\n\e[31m\e[31m   |\e[0m                         \
    \   ^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue >= is not a member of List[Long], but\
    \ could be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mOne of the following imports might make progress towards fixing the problem:\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Ordered.orderingToOrdered\n\e[31m\
    \   |\e[0m  import math.Ordering.Implicits.infixOrderingOps\n\e[31m   |\e[0m\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmph1theine.scala:20:27 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m                paren_list += depth\n\e[31m\e[31m   |\e\
    [0m                ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    value += is not a member\
    \ of List[Long] - did you mean List[Long].!=?\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmph1theine.scala:22:24 --------------------\e[0m\e[0m\n\e[31m22\
    \ |\e[0m                group = Nil\n\e[31m\e[31m   |\e[0m                   \
    \     ^^^\e[0m\n\e[31m   |\e[0m                        Found:    collection.immutable.Nil.type\n\
    \e[31m   |\e[0m                        Required: Int\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmph1theine.scala:25:19 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        paren_list += group\n"
  stdout: ''
  timestamp: 1660029257
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        // Convert the paren string to a char list for easier manipulation.\n\
    \        val parens = paren_string.chars.toList\n        // Initialize a hashmap\
    \ to hold the depth of each parens\n        val paren_hashMap = mutable.HashMap[Char,\
    \ Int]()\n        // Initialize a set to hold the deepest level of nesting \n\
    \        val max_depth = mutable.HashSet[Int]()\n        // Initialize the max_depth\
    \ to -1 to indicate that there are no nested parentheses in the string\n     \
    \   max_depth(0) = -1\n        // Iterate through the char list and update max_depth\
    \ if the parens count changes\n        // This ensures that max_depth is always\
    \ updated with the deepest level of nesting for each parens\n        for (ch <-\
    \ parens) {\n            if (paren_hashMap.contains(ch)) {\n                //\
    \ If the current char is the same as the previous char, then increment the count\
    \ for that char\n                paren_hashMap(ch) += 1\n            } else {\n\
    \                // Otherwise, add that char to the hashMap and start counting\
    \ chars from 0.\n                paren_hashMap(ch) = 0\n            }\n      \
    \      // If the max_depth for the current char is greater than the previous one,\
    \ \n            // set the current max depth to that value for that char\n   \
    \         if (paren_hashMap(ch) > max_depth(ch)) {\n                max_depth(ch)\
    \ = paren_hashMap(ch)\n            }\n        }\n        // Return the list of\
    \ deepest level of nesting for each paren\n        max_depth.map(_.toLong)\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp0x94ifk0.scala:11:40 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mparens\e[0m = paren_string.chars.toList\n\
    \e[31m\e[31m   |\e[0m                     ^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m              value toList is not a member of java.util.stream.IntStream\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp0x94ifk0.scala:13:28 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mparen_hashMap\e[0m = mutable.HashMap[\e\
    [35mChar\e[0m, \e[35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m                      \
    \      ^^^^^^^\e[0m\n\e[31m   |\e[0m                            Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp0x94ifk0.scala:15:24\
    \ ------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e\
    [36mmax_depth\e[0m = mutable.HashSet[\e[35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m\
    \                        ^^^^^^^\e[0m\n\e[31m   |\e[0m                       \
    \ Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660029254
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        var level = 0\n        var opening_level = 0\n        paren_string.slidingWhile(_\
    \ != \"(\").foreach { paren =>\n            val opening_open = paren.contains(\"\
    (\")\n            val opening_close = paren.contains(\")\")\n            val new_level\
    \ = if opening_open then (level + 1) else (level - 1)\n            val new_level\
    \ = if (opening_close && new_level > opening_level) new_level else opening_level\n\
    \            opening_level = new_level\n            level += 1\n        }\n  \
    \      List(level.toLong)\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpv44sggje.scala:12:21 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        paren_string.slidingWhile(_ != \e[31m\"(\"\e\
    [0m).foreach { \e[36mparen\e[0m =>\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        value slidingWhile is not a member of String\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660029255
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        var result : List[Long] = Nil\n        var counter : Long = 1\n \
    \       for (char_list <- paren_string.split(' ')) yield {\n            if (char_list.length\
    \ > counter) {\n                result ::= counter\n            }\n          \
    \  counter += char_list.length\n        }\n        result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"\
    () (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpgtc1cu4c.scala:21)\n\tat Problem.main(tmpgtc1cu4c.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660029260
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        paren_string.split(\"\\\\s+\").map(parseParen_1)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((()))\
    \ () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpikokuixz.scala:10:39 ------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m        paren_string.split(\e[31m\"\\\\s+\"\e[0m).map(parseParen_1)\n\
    \e[31m\e[31m   |\e[0m                                       ^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                       Not found: parseParen_1\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- Error: /tmp/tmpikokuixz.scala:10:52 -----------------------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m        paren_string.split(\e[31m\"\\\\s+\"\e[0m).map(parseParen_1)\n\
    \e[31m\e[31m   |\e[0m                                                    ^\e[0m\n\
    \e[31m   |\e[0m                                          No ClassTag available\
    \ for B\n\e[31m   |\e[0m\n\e[31m   |\e[0m                                    \
    \      where:    B is a type variable\n2 errors found\n"
  stdout: ''
  timestamp: 1660029257
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val groups = paren_string.split(\"\\\\s+\")\n        val max_levels\
    \ = groups.map(_ match {\n            case parens : String if parens.isEmpty()\
    \ => 0\n            case parens : String if parens.contains(\"(\") => parens.length\n\
    \            case parens : String if parens.contains(\")\")=> parens.length\n\
    \            case parens : String if parens.contains(\"(\") => parens.length\n\
    \            case _ => 0\n        }).max\n        groups.map(_ match {\n     \
    \       case parens : String if parens.isEmpty() => 0\n            case parens\
    \ : String if parens.contains(\"(\") => parens.length\n            case parens\
    \ : String if parens.contains(\")\")=> parens.length\n            case parens\
    \ : String if parens.contains(\"(\") => parens.length\n            case _ => 0\n\
    \        }).dropRight(max_levels).map { level => level.toLong }\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((()))\
    \ () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpg9z6vpb1.scala:18:8\
    \ ---------------------\e[0m\e[0m\n\e[31m18 |\e[0m        groups.map(_ \e[33mmatch\e\
    [0m {\n\e[31m\e[31m   |\e[0m        ^\e[0m\n\e[31m   |\e[0m        Found:    \e\
    [1m\e[31mArray\e[0m[Long]\n\e[31m   |\e[0m        Required: \e[1m\e[32mList\e\
    [0m[Long]\n\e[31m19 |\e[0m            \e[33mcase\e[0m parens : \e[35mString\e\
    [0m \e[33mif\e[0m parens.isEmpty() => \e[31m0\e[0m\n\e[31m20 |\e[0m          \
    \  \e[33mcase\e[0m parens : \e[35mString\e[0m \e[33mif\e[0m parens.contains(\e\
    [31m\"(\"\e[0m) => parens.length\n\e[31m21 |\e[0m            \e[33mcase\e[0m parens\
    \ : \e[35mString\e[0m \e[33mif\e[0m parens.contains(\e[31m\")\"\e[0m)=> parens.length\n\
    \e[31m22 |\e[0m            \e[33mcase\e[0m parens : \e[35mString\e[0m \e[33mif\e\
    [0m parens.contains(\e[31m\"(\"\e[0m) => parens.length\n\e[31m23 |\e[0m      \
    \      \e[33mcase\e[0m _ => \e[31m0\e[0m\n\e[31m24 |\e[0m        }).dropRight(max_levels).map\
    \ { \e[36mlevel\e[0m => level.toLong }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660029258
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        paren_string.trim().split(\"\\\\s+\").map(l => if (l.length == 0)\
    \ 0l else l.length)\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpvdphq_hs.scala:10:8\
    \ ---------------------\e[0m\e[0m\n\e[31m10 |\e[0m        paren_string.trim().split(\e\
    [31m\"\\\\s+\"\e[0m).map(\e[36ml\e[0m => \e[33mif\e[0m (l.length == \e[31m0\e\
    [0m) \e[31m0l\e[0m \e[33melse\e[0m l.length)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Array[AnyVal]\n\e[31m   |\e[0m        Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660029258
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val input = paren_string.split(\" \")\n        val paren_str = new\
    \ mutable.HashMap[Char, List[Long]]()\n        paren_str.put('(, new mutable.ListBuffer[Long])\n\
    \        paren_str.put(')', new mutable.ListBuffer[Long])\n        paren_str.put('{,\
    \ new mutable.ListBuffer[Long])\n        paren_str.put('}', new mutable.ListBuffer[Long])\n\
    \        input.foreach(x => paren_str.getOrElse(x, new mutable.ListBuffer[Long])).append(x.toLong)\n\
    \        val max_len = input.max\n        var result: List[Long] = Nil\n     \
    \   for (i <- 0 until max_len) {\n            val list = paren_str.getOrElse(input(i),\
    \ new mutable.ListBuffer[Long])\n            if (list.isEmpty) result = Nil\n\
    \            else {\n                val l = list.take(list.size - 1)\n      \
    \          if (l > result.length) result = list :: result\n                else\
    \ result = l :: result\n            }\n        }\n        result.toList\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()())\
    \ ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpkb_gxc7m.scala:12:22 -----------------------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        paren_str.put('(, new mutable.ListBuffer[Long])\n\
    \e[31m\e[31m   |\e[0m                      ^\e[0m\n\e[31m   |\e[0m           \
    \           unclosed character literal\n\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpkb_gxc7m.scala:12:37\
    \ ---------------------------\e[0m\e[0m\n\e[31m12 |\e[0m        paren_str.put('(,\
    \ new mutable.ListBuffer[Long])\n\e[31m\e[31m   |\e[0m                       \
    \              ^\e[0m\n\e[31m   |\e[0m                                     expression\
    \ expected but \e[31m'.'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E103] Syntax Error:\
    \ /tmp/tmpkb_gxc7m.scala:14:24 ---------------------------\e[0m\e[0m\n\e[31m14\
    \ |\e[0m        paren_str.put('{, \e[33mnew\e[0m mutable.ListBuffer[Long])\n\e\
    [31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m           \
    \             Illegal start of statement\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- Error:\
    \ /tmp/tmpkb_gxc7m.scala:30:4 ------------------------------------------\e[0m\e\
    [0m\n\e[31m30 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e[35mArray\e\
    [0m[\e[35mString\e[0m]) = {\n\e[31m\e[31m   |\e[0m    ^^^\e[0m\n\e[31m   |\e[0m\
    \    end of statement expected but 'def' found\n\e[31m\e[31m-- [E006] Not Found\
    \ Error: /tmp/tmpkb_gxc7m.scala:11:28 ------------------------\e[0m\e[0m\n\e[31m11\
    \ |\e[0m        \e[33mval\e[0m \e[36mparen_str\e[0m = \e[33mnew\e[0m mutable.HashMap[\e\
    [35mChar\e[0m, \e[35mList\e[0m[\e[35mLong\e[0m]]()\n\e[31m\e[31m   |\e[0m    \
    \                        ^^^^^^^\e[0m\n\e[31m   |\e[0m                       \
    \     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpkb_gxc7m.scala:16:81 ------------------------\e[0m\e[0m\n\e[31m16 |\e\
    [0m        input.foreach(\e[36mx\e[0m => paren_str.getOrElse(x, \e[33mnew\e[0m\
    \ mutable.ListBuffer[\e[35mLong\e[0m])).append(x.toLong)\n\e[31m\e[31m   |\e[0m\
    \        ^^"
  stdout: ''
  timestamp: 1660029259
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        // We want to find largest sequence of parentheses in paren_string\
    \ using recursion.\n        // We can do this by maintaining three states:\n \
    \       // 1. If there are more parentheses in current state, return current state.\n\
    \        // 2. If current state has no more parentheses, return empty list.\n\
    \        // 3. If current state has more parentheses, return the state which has\
    \ more parentheses.\n        val opening = paren_string.count(\"(\")\n       \
    \ val closing = paren_string.count(\")\")\n\n        val state = List(0)\n   \
    \     var count = 0\n        while(count < paren_string.length){\n           \
    \ if(paren_string(count) == opening)\n                count += 1\n           \
    \ else if(paren_string(count) == closing){\n                count += 1\n     \
    \           state = List(count)\n            }\n            else\n           \
    \     state = state ::: List(count)\n            count += 1\n        }\n     \
    \   if(state.length > 0){\n            count = 1\n            while(count < paren_string.length){\n\
    \                if(paren_string(count) == opening)\n                    count\
    \ += 1\n                else if(paren_string(count) == closing){\n           \
    \         count += 1\n                    state = List(count)\n              \
    \  }\n                else\n                    state = state ::: List(count)\n\
    \                count += 1\n            }\n        }\n        state\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()())\
    \ ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpgd0vuun9.scala:15:41\
    \ --------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mopening\e\
    [0m = paren_string.count(\e[31m\"(\"\e[0m)\n\e[31m\e[31m   |\e[0m            \
    \                             ^^^\e[0m\n\e[31m   |\e[0m                      \
    \                   Found:    (\e[32m\"(\"\e[0m : String)\n\e[31m   |\e[0m   \
    \                                      Required: Char => Boolean\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpgd0vuun9.scala:16:41 --------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mclosing\e[0m = paren_string.count(\e\
    [31m\")\"\e[0m)\n\e[31m\e[31m   |\e[0m                                       \
    \  ^^^\e[0m\n\e[31m   |\e[0m                                         Found:  \
    \  (\e[32m\")\"\e[0m : String)\n\e[31m   |\e[0m                              \
    \           Required: Char => Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E052]\
    \ Type Error: /tmp/tmpgd0vuun9.scala:25:22 -----------------------------\e[0m\e\
    [0m\n\e[31m25 |\e[0m                state = List(count)\n\e[31m\e[31m   |\e[0m\
    \                ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                Reassignment\
    \ to val state\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmpgd0vuun9.scala:28:22\
    \ -----------------------------\e[0m\e[0m\n\e[31m28 |\e[0m                state\
    \ = state ::: List(count)\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                Reassignment to val state\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E052] Type Error: /tmp/tmpgd0vuun9.scala:38:26 -----------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m                    state = List(count)\n\e[31m\e[31m\
    \   |\e[0m                    ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \              Reassignment to val state\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explan"
  stdout: ''
  timestamp: 1660029260
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n      val paren_count = new mutable.HashMap[String, Int]()\n      for (i\
    \ <- 0 until paren_string.length) {\n        val p = paren_string(i)\n       \
    \ if (paren_count.contains(p)) {\n          paren_count(p) += 1\n        } else\
    \ {\n          paren_count(p) = 1\n        }\n      }\n      val max_count = paren_count.values.max\n\
    \      val max_key_list = paren_count.keys.toList.sortWith((a, b) => b.compareTo(a))\n\
    \      val max_key_length = max_key_list.map(_.length)\n      val max_key = max_key_list.last\n\
    \      var max_key_index = 0\n      val output = new mutable.ArrayList[Long]()\n\
    \      for (i <- 0 until paren_count.values.size) {\n        val key = max_key_list(i).toString\n\
    \        val count = paren_count(key)\n        val len = max_key_length(i)\n \
    \       val count = paren_count(key).toInt\n        if (count > max_count * 1.0)\
    \ {\n          // We are at the deepest level of nesting so we need to append\
    \ the key to the output\n          output.append(max_key)\n        } else {\n\
    \          // Key has already been appended\n          output.append(key)\n  \
    \      }\n        // We are done with this key so it can be removed from the hashmap\n\
    \        paren_count(key) = count - 1\n        if (count > 1) {\n          max_key_index\
    \ += 1\n        }\n      }\n      output.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpaxa5be8j.scala:10:28 ------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m      \e[33mval\e[0m \e[36mparen_count\e[0m = \e[33mnew\e\
    [0m mutable.HashMap[\e[35mString\e[0m, \e[35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m\
    \                            ^^^^^^^\e[0m\n\e[31m   |\e[0m                   \
    \         Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpaxa5be8j.scala:24:23 ------------------------\e[0m\e[0m\n\e[31m24 |\e\
    [0m      \e[33mval\e[0m \e[36moutput\e[0m = \e[33mnew\e[0m mutable.ArrayList[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                       ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                       Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660029256
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        paren_string.split(\"\\\\s+\")\n            .filter(_.nonEmpty)\n\
    \            .foldLeft(List[Long]()) { (res, chars) =>\n                var max_level\
    \ = 0\n                var is_open = false\n                var index = 0\n  \
    \              while (index < chars.length ) {\n                    if (chars(index).equals(\"\
    (\")) {\n                        is_open = true\n                    }\n     \
    \               if (chars(index) == \")\") {\n                        if (is_open)\
    \ {\n                            is_open = false\n                        } else\
    \ {\n                            max_level = max_level + 1\n                 \
    \       }\n                    }\n                    index += 1\n           \
    \     }\n                res.push((max_level.toLong, chars.length))\n        \
    \    }\n            .reverse\n            .foldLeft(List[Long]()) { (res, levels)\
    \ =>\n                var max_level = 0\n                var max_level_chars =\
    \ \"\"\n                for (max_level, chars) <- levels ++ res) {\n         \
    \           if (max_level > max_level) {\n                        max_level =\
    \ max_level\n                        max_level_chars = chars\n               \
    \     }\n                }\n                res.push((max_level.toLong, max_level_chars))\n\
    \            }\n            .reverse\n            .map(levels => {\n         \
    \       val max_level = levels(0)\n                val max_level_chars = levels(1)\n\
    \                for (i <- 0 until max_level) {\n                    if (max_level_chars.charAt(i)\
    \ !=\"(\") {\n                        break\n                    }\n         \
    \       }\n                List(max_level, max_level + 1).map(_.toLong)\n    \
    \        })\n            .toList\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E020] Syntax Error: /tmp/tmpsfvk70_x.scala:35:55 ---------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m                \e[33mfor\e[0m (max_level, chars) <-\
    \ levels ++ res) {\n\e[31m\e[31m   |\e[0m                                    \
    \                   ^\e[0m\n\e[31m   |\e[0m                                  \
    \                  \e[33myield\e[0m or \e[33mdo\e[0m expected\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- Error: /tmp/tmpsfvk70_x.scala:20:24 -----------------------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m                    \e[33mif\e[0m (chars(index) == \e\
    [31m\")\"\e[0m) {\n\e[31m\e[31m   |\e[0m                        ^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Values of types Char and String cannot be compared\
    \ with == or !=\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpsfvk70_x.scala:29:20\
    \ ------------------------\e[0m\e[0m\n\e[31m29 |\e[0m                res.push((max_level.toLong,\
    \ chars.length))\n\e[31m\e[31m   |\e[0m                ^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0m       value push is not a member of List[Long] - did you mean res.last?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpsfvk70_x.scala:35:49 ------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m                \e[33mfor\e[0m (max_level, chars) <-\
    \ levels ++ res) {\n\e[31m\e[31m   |\e[0m                                    \
    \      ^^^^^^^^^\e[0m\n\e[31m   |\e[0m                                       \
    \ value ++ is not a member of Long\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpsfvk70_x.scala:41:20\
    \ ------------------------\e[0m\e[0m\n\e[31m41 |\e[0m                res.push((max_level.toLong,\
    \ max_level_chars))\n\e[31m\e[31m   |\e[0m                ^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m       value push is not a member of List[Long] - did you mean res.last?\n\
    \e[31m\e[31m-- [E050] Type Error: /tmp/tmpsfvk70_x.scala:45:32 -----------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m                \e[33mval\e[0m \e[36mmax_level\e[0m =\
    \ levels(\e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m                                ^^^^^^\e\
    [0m\n\e[31m   |\e[0m                               \e[33mparameter\e[0m \e[35mlevels\e"
  stdout: ''
  timestamp: 1660029265
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_strings = paren_string.split(\" \")\n        val paren_counts\
    \ = paren_strings.map(x => x.length)\n        val max_paren_count = paren_counts.max\n\
    \        val max_paren_level = paren_counts.indexWhere(_ == max_paren_count) +\
    \ 1 // index of largest paren count that appears\n        val levels = max_paren_level\
    \ - paren_counts.indexWhere(_ == max_paren_count - 1)\n        if (levels <= 0)\n\
    \            List(1l.toLong)\n        else\n            List(1l.toLong, max_paren_level.toLong)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpk9annmlq.scala:21)\n\tat Problem.main(tmpk9annmlq.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660029267
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\"\\\\(|\\\\)\")\n        val\
    \ result = new mutable.ListBuffer[Long]()\n        var max_level = 0\n       \
    \ for (paren_group <- paren_groups) {\n            val paren_group_list = paren_group.split(\"\
    \\\\)\")\n            if (paren_group_list.length > max_level) {\n           \
    \     max_level = paren_group_list.length\n            }\n            for (paren_string\
    \ <- paren_group_list) {\n                val paren_string_list = paren_string.split(\"\
    \\\\)\")\n                for (string_list <- paren_string_list) {\n         \
    \           val string_list = string_list.split(\"\\\\)\")\n                 \
    \   for (string <- string_list) {\n                        string_list.indexOf(string)\
    \ + 1\n                    }\n                }\n            }\n        }\n  \
    \      result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpk7ie55yl.scala:11:25 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m             \
    \            ^^^^^^^\e[0m\n\e[31m   |\e[0m                         Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660029258
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        // Define a variable for counting parantheses levels\n        var\
    \ paren_level = 0\n        // Create a stack of paren_string which we will use\
    \ to parse the input string\n        var paren_stack: List[(String, Int)] = Nil\n\
    \        // Go through each character and increment the paren_level until we see\
    \ a left paren\n        for (i <- 0 to paren_string.length - 1) {\n          \
    \  val ch = paren_string(i)\n            if (ch == \"(\") {\n                paren_level\
    \ += 1\n                paren_stack :+= (ch, \"(\")\n            } else if (ch\
    \ == \")\") {\n                paren_level -= 1\n                if (paren_level\
    \ < 0) {\n                    throw new RuntimeException(\"Mismatched parentheses\
    \ \" + paren_string)\n                }\n                paren_stack :+= (ch,\
    \ \"(\")\n            } else if (ch == \"(\") {\n                paren_level +=\
    \ 1\n                paren_stack :+= (ch, \"(\")\n            } else if (ch ==\
    \ \")\") {\n                paren_level -= 1\n                if (paren_level\
    \ < 0) {\n                    throw new RuntimeException(\"Mismatched parentheses\
    \ \" + paren_string)\n                }\n                paren_stack :+= (ch,\
    \ \"(\")\n            } else {\n                // Do nothing since paren_level\
    \ and paren_stack does not have any unmatched parentheses.\n            }\n  \
    \      }\n        // Check if there are any unmatched parentheses\n        if\
    \ (paren_level > 0) {\n            throw new RuntimeException(\"Mismatched parentheses\
    \ \" + paren_string)\n        }\n        // Get the level of nesting for each\
    \ parentheses\n        var paren_level_list : List[Long] = Nil\n        for (i\
    \ <- 0 to paren_stack.size - 1) {\n            val ch = paren_stack(i)(1)\n  \
    \          paren_level_list :+= (paren_stack(i)(0).toLong - paren_level.toLong)\n\
    \        }\n        paren_level_list.max\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp6agdoef3.scala:17:16 -----------------------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m            \e[33mif\e[0m (ch == \e[31m\"(\"\e[0m) {\n\
    \e[31m\e[31m   |\e[0m                ^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Values\
    \ of types Char and String cannot be compared with == or !=\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp6agdoef3.scala:19:28 ------------------------\e[0m\e\
    [0m\n\e[31m19 |\e[0m                paren_stack :+= (ch, \e[31m\"(\"\e[0m)\n\e\
    [31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ :+= is not a member of List[(String, Int)] - did you mean List[(String, Int)].:+?\n\
    \e[31m\e[31m-- Error: /tmp/tmp6agdoef3.scala:20:23 -----------------------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m            } \e[33melse\e[0m \e[33mif\e[0m (ch == \e\
    [31m\")\"\e[0m) {\n\e[31m\e[31m   |\e[0m                       ^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m        Values of types Char and String cannot be compared with\
    \ == or !=\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp6agdoef3.scala:25:28\
    \ ------------------------\e[0m\e[0m\n\e[31m25 |\e[0m                paren_stack\
    \ :+= (ch, \e[31m\"(\"\e[0m)\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue :+= is not a member of List[(String, Int)] - did you\
    \ mean List[(String, Int)].:+?\n\e[31m\e[31m-- Error: /tmp/tmp6agdoef3.scala:26:23\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m26 |\e[0m       \
    \     } \e[33melse\e[0m \e[33mif\e[0m (ch == \e[31m\"(\"\e[0m) {\n\e[31m\e[31m\
    \   |\e[0m                       ^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Values\
    \ of types Char and String cannot be compared with == or !=\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp6agdoef3.scala:28:28 ------------------------\e[0m\e\
    [0m\n\e[31m28 |\e[0m                paren_stack :+= (ch, \e[31m\"(\"\e[0m)\n\e\
    [31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ :+= is not a member of List[(String, Int)] - did you mean List[(String, Int)].:+?\n\
    \e[31m\e[31m-- Error: /tmp/tmp6agdoef3.scala:29:23 -----------------------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m            } \e[33melse\e[0m \e[33mif\e[0m (ch == \e\
    [31m\")\"\e["
  stdout: ''
  timestamp: 1660029268
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_list: List[String] = paren_string.split(\"\\\\s\").toList\n\
    \        val paren_list_temp: List[String] = paren_list.map(x => x.replace(\"\
    \ \", \"\"))\n        var paren_list_counter = paren_list_temp.filter(x => x !=\
    \ \"\").length\n        if (paren_list_counter == 0) paren_list_counter = 1\n\
    \        var paren_list_counter2: Int = 0\n        var paren_list_counter3: Int\
    \ = 0\n        val paren_list_temp2: List[String] = paren_list_temp.map(x => x.replace(paren_list_counter,\
    \ \"\"))\n        val paren_list_temp3 = paren_list_temp2.filter(x => x != \"\"\
    ).map(x => x.replace(paren_list_counter2, \"()\"))\n        val paren_list_temp4\
    \ = paren_list_temp3.map(x => x.replace(paren_list_counter3, \"()\"))\n      \
    \  val paren_list_temp5 = paren_list_temp4.filter(x => x != \"\").map(x => x.replace(paren_list_counter3,\
    \ \"()\"))\n        val paren_list_temp6 = paren_list_temp5.filter(x => x != \"\
    \").map(x => x.replace(paren_list_counter3, \"()\"))\n        val paren_list_temp7\
    \ = paren_list_temp6.filter(x => x != \"\").map(x => x.replace(paren_list_counter3,\
    \ \"()\"))\n        val paren_list_temp8 = paren_list_temp7.filter(x => x != \"\
    \").map(x => x.replace(paren_list_counter3, \"()\"))\n        val paren_list_temp9\
    \ = paren_list_temp8.filter(x => x != \"\").map(x => x.replace(paren_list_counter3,\
    \ \"()\"))\n        val paren_list_temp10 = paren_list_temp9.filter(x => x !=\
    \ \"\").map(x => x.replace(paren_list_counter3, \"()\"))\n        val paren_list_temp11\
    \ = paren_list_temp10.filter(x => x != \"\").map(x => x.replace(paren_list_counter3,\
    \ \"()\"))\n        val paren_list_temp12 = paren_list_temp11.filter(x => x !=\
    \ \"\").map(x => x.replace(paren_list_counter3, \"()\"))\n        val paren_list_temp13\
    \ = paren_list_temp12.filter(x => x != \"\").map(x => x.replace(paren_list_counter3,\
    \ \"()\"))\n        val paren_list_temp14 = paren_list_temp13.filter(x => x !=\
    \ \"\").map(x => x.replace(paren_list_counter3, \"()\"))\n        val paren_list_temp15\
    \ = paren_list_temp14.filter(x => x != \"\").map(\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp726kby_t.scala:29:75 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mparen_list_temp15\e[0m =\
    \ paren_list_temp14.filter(\e[36mx\e[0m => x != \e[31m\"\"\e[0m).map(\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \           ^\e[0m\n\e[31m   |\e[0m                                       expression\
    \ expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E134] Type Error:\
    \ /tmp/tmp726kby_t.scala:16:72 -----------------------------\e[0m\e[0m\n\e[31m16\
    \ |\e[0m        \e[33mval\e[0m \e[36mparen_list_temp2\e[0m: \e[35mList\e[0m[\e\
    [35mString\e[0m] = paren_list_temp.map(\e[36mx\e[0m => x.replace(paren_list_counter,\
    \ \e[31m\"\"\e[0m))\n\e[31m\e[31m   |\e[0m                                   \
    \                                   ^^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mreplace\e[0m in \e[33mclass\e\
    [0m \e[35mString\e[0m with types\n\e[31m   |\e[0m (x$0: CharSequence, x$1: CharSequence):\
    \ String\n\e[31m   |\e[0m (x$0: Char, x$1: Char): String\n\e[31m   |\e[0mmatch\
    \ arguments ((paren_list_counter : Int), (\e[32m\"\"\e[0m : String))\n\e[31m\e\
    [31m-- [E134] Type Error: /tmp/tmp726kby_t.scala:17:80 -----------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mparen_list_temp3\e[0m =\
    \ paren_list_temp2.filter(\e[36mx\e[0m => x != \e[31m\"\"\e[0m).map(\e[36mx\e\
    [0m => x.replace(paren_list_counter2, \e[31m\"()\"\e[0m))\n\e[31m\e[31m   |\e\
    [0m                                                                          \
    \    ^^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e\
    [33mmethod\e[0m \e[35mreplace\e[0m in \e[33mclass\e[0m \e[35mString\e[0m with\
    \ types\n\e[31m   |\e[0m (x$0: CharSequence, x$1: CharSequence): String\n\e[31m\
    \   |\e[0m (x$0: Char, x$1: Char): String\n\e[31m   |\e[0mmatch arguments ((paren_list_counter2\
    \ : Int), (\e[32m\"()\"\e[0m : String))\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmp726kby_t.scala:18:59 ------------------------\e[0m\e[0m\n\e[31m18 |\e\
    [0m        \e[33mval\e[0m \e[36m"
  stdout: ''
  timestamp: 1660029271
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        // Use stack to keep track of parentheses levels.\n        var paren_stack\
    \ = List[Long]()\n        var groups = paren_string.split(\"\\\\s\").toList\n\
    \        var deepest_level = Long.MaxValue\n        groups.foreach(x => {\n  \
    \          var temp_groups = x.split(\"(\").toList\n            var group_level\
    \ = 0\n            temp_groups.foreach(y => {\n                val x = y.indexOf(\"\
    )\")\n                if (x > -1) {\n                    paren_stack = paren_stack\
    \ :+ group_level\n                }\n                group_level = group_level\
    \ + 1\n            })\n            deepest_level = deepest_level if (deepest_level\
    \ < group_level)\n        })\n        return paren_stack.toList\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((()))\
    \ () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp9vuhygkm.scala:24:42 -----------------------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m            deepest_level = deepest_level \e[33mif\e\
    [0m (deepest_level < group_level)\n\e[31m\e[31m   |\e[0m                     \
    \                     ^^\e[0m\n\e[31m   |\e[0m                               \
    \ end of statement expected but 'if' found\n1 error found\n"
  stdout: ''
  timestamp: 1660029260
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_count = new mutable.HashMap[String, Long]()\n        val\
    \ paren_count_tmp = new mutable.HashMap[String, Long]()\n        for (ch <- paren_string.toList)\
    \ {\n            if (ch == \"(\") {\n                paren_count.put(ch, paren_count_tmp.get(ch)!!\
    \ + 1)\n            } else if (ch == \")\") {\n                val tmp_count =\
    \ paren_count_tmp.get(ch)!!\n                val tmp_value = paren_count.get(ch)!!\n\
    \                val tmp_min = Math.min(tmp_count, tmp_value)\n              \
    \  if (tmp_count == tmp_value) {\n                    paren_count.put(ch, tmp_count)\n\
    \                } else {\n                    paren_count_tmp.put(ch, tmp_count)\n\
    \                    paren_count.put(ch, tmp_value)\n                }\n     \
    \       }\n        }\n        val res = new mutable.LinkedHashMap[String, Long]()\n\
    \        for (key_tmp <- paren_count) {\n            val key = key_tmp._1\n  \
    \          val value = key_tmp._2\n            val tmp_value = res.get(key)\n\
    \            if (tmp_value == null || tmp_value < value) {\n                res.put(key_tmp._1,\
    \ value)\n            }\n        }\n        res.keys.toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"\
    () (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp406fd1v7.scala:16:57 ---------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m                \e[33mval\e[0m \e[36mtmp_count\e[0m =\
    \ paren_count_tmp.get(ch)!!\n\e[31m\e[31m   |\e[0m                           \
    \                              ^\e[0m\n\e[31m   |\e[0m                       \
    \   expression expected but \e[31mend of statement\e[0m found\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E018] Syntax Error: /tmp/tmp406fd1v7.scala:17:53 ---------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m                \e[33mval\e[0m \e[36mtmp_value\e[0m =\
    \ paren_count.get(ch)!!\n\e[31m\e[31m   |\e[0m                               \
    \                      ^\e[0m\n\e[31m   |\e[0m                          expression\
    \ expected but \e[31mend of statement\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp406fd1v7.scala:10:30 ------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e[36mparen_count\e[0m = \e[33mnew\e\
    [0m mutable.HashMap[\e[35mString\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m   |\e\
    [0m                              ^^^^^^^\e[0m\n\e[31m   |\e[0m               \
    \               Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp406fd1v7.scala:11:34 ------------------------\e[0m\e[0m\n\e[31m11 |\e\
    [0m        \e[33mval\e[0m \e[36mparen_count_tmp\e[0m = \e[33mnew\e[0m mutable.HashMap[\e\
    [35mString\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                   \
    \               ^^^^^^^\e[0m\n\e[31m   |\e[0m                                \
    \  Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- Error: /tmp/tmp406fd1v7.scala:13:16\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m13 |\e[0m       \
    \     \e[33mif\e[0m (ch == \e[31m\"(\"\e[0m) {\n\e[31m\e[31m   |\e[0m        \
    \        ^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Values of types Char and String\
    \ cannot be compared wit"
  stdout: ''
  timestamp: 1660029268
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_stack = mutable.Stack[String]()\n\n        def getParenCount(paren_string\
    \ : String, count : Int) : Int = {\n            if(paren_string.length > count)\
    \ {\n                paren_stack.clear()\n                paren_string.substring(0,\
    \ count).split(\"\\\\W+\").filter(_.nonEmpty).map(x => (count - paren_string.length\
    \ + x.length).asInstanceOf[Int]).foldLeft(0)(_ + _)\n            } else 0\n  \
    \      }\n\n        paren_string.split(\"\\\\W+\").map(x => (getParenCount(x,\
    \ paren_stack.size).asInstanceOf[Int]).asInstanceOf[Long]).foldLeft(0)(_ + _)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmph_qi97pc.scala:10:26 ------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e[36mparen_stack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                          ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                          Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmph_qi97pc.scala:19:131 -------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        paren_string.split(\e[31m\"\\\\W+\"\e[0m).map(\e\
    [36mx\e[0m => (getParenCount(x, paren_stack.size).asInstanceOf[\e[35mInt\e[0m]).asInstanceOf[\e\
    [35mLong\e[0m]).foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m         \
    \                                                                            \
    \                                              ^^^^^\e[0m\n\e[31m   |\e[0m   \
    \                                                       Found:    Long\n\e[31m\
    \   |\e[0m                                                          Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660029266
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        paren_string\n            .trim.replaceAll(\"[^\\\\(][^\\\\)]+\\\\\
    (|\\\\)[^\\\\(][^\\\\)]+\", \"\")\n            .split(\" \")\n            .map((paren_string)\
    \ => {\n                val depth = paren_string.length\n                val char_to_depth\
    \ = paren_string.zipWithIndex.map{case (c, i) => (if (c == '(') 1 else -1) * i}\n\
    \                val depth_to_chars = char_to_depth.map{case (d, i) => if (d ==\
    \ 1) '(' else ')'}\n                val max_depth = char_to_depth.foldRight(0l){(a,\
    \ b) => if (a > b) a else b}\n                val max_index = char_to_depth.foldRight(-1)(_\
    \ > _).or(depth)\n                depth_to_chars.inits\n                    .map(c\
    \ => char_to_depth.find(d => d == c) + 1)\n                    .takeWhile(_ <\
    \ max_index)\n                    .drop(max_index)\n                    .map {\n\
    \                        case (c, d) => (d, char_to_depth.find(_ == c))\n    \
    \                }\n                    .sorted\n                    .filter(_._1\
    \ > 1)\n                    .map(_._2)\n                    .head\n          \
    \  })\n            .filterNot(_ == 0)\n            .sorted\n            .filter(_\
    \ > 0)\n            .map(_.toLong)\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpzu62etj9.scala:18:60\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m                \e[33mval\e[0m\
    \ \e[36mmax_index\e[0m = char_to_depth.foldRight(-\e[31m1\e[0m)(_ > _).or(depth)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \    ^^^^^\e[0m\n\e[31m   |\e[0m                                             \
    \          Found:    Boolean\n\e[31m   |\e[0m                                \
    \                       Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- Error:\
    \ /tmp/tmpzu62etj9.scala:20:54 -----------------------------------------\e[0m\e\
    [0m\n\e[31m20 |\e[0m                    .map(c => char_to_depth.find(d => d ==\
    \ c) + \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m                                  \
    \                    ^^^^^^\e[0m\n\e[31m   |\e[0mValues of types Int and IndexedSeq[Char\
    \ @uncheckedVariance] cannot be compared with == or !=\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpzu62etj9.scala:21:33 ------------------------\e[0m\e\
    [0m\n\e[31m21 |\e[0m                    .takeWhile(_ < max_index)\n\e[31m\e[31m\
    \   |\e[0m                               ^^^\e[0m\n\e[31m   |\e[0mvalue < is not\
    \ a member of Any, but could be made available as an extension method.\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mOne of the following imports might make progress towards\
    \ fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Ordered.orderingToOrdered\n\
    \e[31m   |\e[0m  import math.Ordering.Implicits.infixOrderingOps\n\e[31m   |\e\
    [0m\n\e[31m\e[31m-- Error: /tmp/tmpzu62etj9.scala:30:14 -----------------------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m            })\n\e[31m\e[31m   |\e[0m              ^\e\
    [0m\n\e[31m   |\e[0m              No ClassTag available for B\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m              where:    B is a type variable\n4 errors found\n"
  stdout: ''
  timestamp: 1660029272
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        def parseParanthesisHelper(paren_string : String) : List[Long] =\
    \ {\n            def parseNest(paren_string : String, result : List[Long]) : List[Long]\
    \ = {\n                if (paren_string.isEmpty) {\n                    result\n\
    \                } else {\n                    val left_bracket = paren_string.charAt(0)\n\
    \                    val right_bracket = paren_string.charAt(paren_string.length\
    \ - 1)\n                    val new_left_bracket = if (left_bracket == '(') 1\
    \ else -1\n                    val new_right_bracket = if (right_bracket == ')')\
    \ -1 else 1\n                    val new_paren = if (new_left_bracket == -1) (new_right_bracket)\
    \ else (new_left_bracket * new_right_bracket)\n                    parseNest(paren_string.substring(1,\
    \ paren_string.length - 1), result ::: List(new_paren))\n                }\n \
    \           }\n\n            val result = List(0)\n            parseNest(paren_string,\
    \ result)\n        }\n\n        val parsed_string = paren_string.split(\" \").map(parseParanthesisHelper).toList\n\
    \        val max_level = parsed_string.foldLeft(0)(_ + _.length).toList\n    \
    \    return parsed_string.map(_ maxBy (_ length).toList).zipWithIndex.filter(i\
    \ => i._2 == max_level).toList\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpkfux4cc0.scala:30:50 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mreturn\e[0m parsed_string.map(_ maxBy (_\
    \ length).toList).zipWithIndex.filter(\e[36mi\e[0m => i._2 == max_level).toList\n\
    \e[31m\e[31m   |\e[0m                                                  ^\e[0m\n\
    \e[31m   |\e[0m                                       expression expected but\
    \ \e[31m')'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpkfux4cc0.scala:20:82\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m                    parseNest(paren_string.substring(\e\
    [31m1\e[0m, paren_string.length - \e[31m1\e[0m), result ::: List(new_paren))\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                          ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                                                Found:    List[\e[1m\e[31mAnyVal\e\
    [0m]\n\e[31m   |\e[0m                                                  Required:\
    \ List[\e[1m\e[32mLong\e[0m]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpkfux4cc0.scala:25:36 --------------------\e[0m\e[0m\n\e[31m25\
    \ |\e[0m            parseNest(paren_string, result)\n\e[31m\e[31m   |\e[0m   \
    \                                 ^^^^^^\e[0m\n\e[31m   |\e[0m               \
    \                     Found:    (result : List[Int])\n\e[31m   |\e[0m        \
    \                            Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpkfux4cc0.scala:29:64 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mmax_level\e[0m = parsed_string.foldLeft(\e\
    [31m0\e[0m)(_ + _.length).toList\n\e[31m\e[31m   |\e[0m                      \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \     value toList is not a member of Int - did you mean Int.toInt?\n\e[31m\e\
    [31m-- [E081] Type Error: /tmp/tmpkfux4cc"
  stdout: ''
  timestamp: 1660029273
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        paren_string.trim().split(\" \").map(_.toLong).reverse.dropWhile(_.isNaN).drop(1).reverse.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpbbv5o0dl.scala:10:73 ------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m        paren_string.trim().split(\e[31m\" \"\e[0m).map(_.toLong).reverse.dropWhile(_.isNaN).drop(\e\
    [31m1\e[0m).reverse.toList\n\e[31m\e[31m   |\e[0m                            \
    \                                           ^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \  value isNaN is not a member of Long.\n\e[31m   |\e[0m      An extension method\
    \ was tried, but could not be fully constructed:\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m          float2Float(_$2)\n1 error found\n"
  stdout: ''
  timestamp: 1660029268
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        var nestingLevel = List[Long]()\n        var inGroup = mutable.Queue[Long]()\n\
    \        inGroup.enqueue(0l)\n        inGroup.enqueue(0l)\n        inGroup.enqueue(0l)\n\
    \        inGroup.enqueue(0l)\n        inGroup.enqueue(0l)\n        paren_string.trim.split('\
    \ ').foreach(s => {\n            val l = s.toLong\n            if (l != ')' &&\
    \ l != '(') {\n                inGroup.enqueue(l)\n            } else {\n    \
    \            inGroup.dequeue()\n            }\n        })\n        while(!inGroup.isEmpty)\
    \ {\n            val curLevel = inGroup.removeFirst\n            nestingLevel\
    \ = nestingLevel.::(curLevel.toLong)\n            if (inGroup.isEmpty) {\n   \
    \             break\n            }\n            inGroup.enqueue(inGroup.removeFirst)\n\
    \        }\n        nestingLevel.mkString\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp7qeqxe8b.scala:11:22 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mvar\e[0m \e[36minGroup\e[0m = mutable.Queue[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp7qeqxe8b.scala:29:16 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m                break\n\e[31m\e[31m   |\e[0m        \
    \        ^^^^^\e[0m\n\e[31m   |\e[0m                Not found: break\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp7qeqxe8b.scala:33:21 --------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        nestingLevel.mkString\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    String\n\
    \e[31m   |\e[0m        Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660029275
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        if (paren_string.isEmpty) List()\n        else {\n            val\
    \ paren_list = paren_string.split(\" \").filterNot(_.isEmpty).toList\n       \
    \     val paren_list_head = paren_list(0)\n            val paren_list_tail = paren_list.tail.drop(1)\n\
    \            val result = new mutable.ListBuffer[Long]()\n            val max_level\
    \ = paren_list_head.length\n\n            def add(level : Int) : Unit = {\n  \
    \              if (level > max_level) return\n                if (paren_list_head.length\
    \ == level) {\n                    result.add( paren_list_tail.head )\n      \
    \              return\n                }\n                for (i <- 1 to level)\
    \ add(level + 1)\n            }\n\n            add(0)\n            val result_list\
    \ : mutable.List[Long] = result.toList\n            val result_list : mutable.List[Long]\
    \ = result.toList\n            val result_list : mutable.List[Long] = result.toList\n\
    \            val result_list : mutable.List[Long] = result.toList\n          \
    \  val result_list : mutable.List[Long] = result.toList\n            val result_list\
    \ : mutable.List[Long] = result.toList\n            val result_list : mutable.List[Long]\
    \ = result.toList\n            val result_list : mutable.List[Long] = result.toList\n\
    \            val result_list : mutable.List[Long] = result.toList\n          \
    \  val result_list : mutable.List[Long] = result.toList\n            val result_list\
    \ : mutable.List[Long] = result.toList\n            val result_list : mutable.List[Long]\
    \ = result.toList\n            val result_list : mutable.List[Long] = result.toList\n\
    \            val result_list : mutable.List[Long] = result.toList\n          \
    \  val result_list : mutable.List[Long] = result.toList\n            val result_list\
    \ : mutable.List[Long] = result.toList\n            val result_list : mutable.List[Long]\
    \ = result.toList\n            val result_list : mutable.List[Long] = result.toList\n\
    \            val result_list : mutable.List[Long] = result.toList\n          \
    \  val result_list : mutable.List[Long] = result.toList\n            val result_list\
    \ : mutable.List[Long] = result.toList\n            val result_list : mutable.List[Long]\
    \ = result.toList\n            val result_list : mutable.List[Long] = result.toList\n\
    \            val result_list : mutable.List[Long] = result.toList\n          \
    \  val result_list : mutable.List[Long] = result.toList\n            val result_list\
    \ : mutable.List[Long] = result.toList\n            val result_list : mutable.List[Long]\
    \ = result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp_e0v3exm.scala:63:0 ----------------------------\e\
    [0m\e[0m\n\e[31m63 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp_e0v3exm.scala:29:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m29 |\e[0m            \e[33mval\e\
    [0m \e[36mresult_list\e[0m : mutable.List[\e[35mLong\e[0m] = result.toList\n\e\
    [31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mresult_list is already defined as \e[33mvalue\e[0m \e[35mresult_list\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp_e0v3exm.scala:30:16 ---------------------------\e[0m\e[0m\n\e\
    [31m30 |\e[0m            \e[33mval\e[0m \e[36mresult_list\e[0m : mutable.List[\e\
    [35mLong\e[0m] = result.toList\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mresult_list is already defined as \e[33mvalue\e[0m \e[35mresult_list\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp_e0v3exm.scala:31:16 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m            \e[33mval\e[0m \e[36mresult_list\e[0m : mutable.List[\e\
    [35mLong\e[0m] = result.toList\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mresult_list is already defined as \e[33mvalue\e[0m \e[35mresult_list\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp_e0v3exm.scala:32:16 ---------------------------\e[0m\e[0m\n\e\
    [31m32 |\e[0m            \e[33mval\e[0m \e[36mresult_list\e[0m : mutable.List[\e\
    [35mLong\e[0m] = result.toList\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mresult_list is already defined as \e[33mvalue\e[0m \e[35mresult_list\e\
    [0m\n\e[31m   |\e[0m\n\e[31m "
  stdout: ''
  timestamp: 1660029277
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        def compute(paren_str: List[(String, String)]): List[Long] = {\n\
    \            paren_str match {\n                case Nil  => Nil\n           \
    \     case h::t => h._1 match {\n                    case \"(\" =>\n         \
    \               compute(paren_str :+ t)\n                    case \")\" =>\n \
    \                       compute(paren_str :+ h)\n                    case c =>\n\
    \                        compute(paren_str :+ (List(c, paren_str.length))) ++\
    \ compute(paren_str)\n                }\n            }\n        }\n        compute(List(paren_string))\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxgrjrghf.scala:15:45\
    \ --------------------\e[0m\e[0m\n\e[31m15 |\e[0m                        compute(paren_str\
    \ :+ t)\n\e[31m\e[31m   |\e[0m                                             ^\e\
    [0m\n\e[31m   |\e[0m                                  Found:    (\e[1m\e[31mt\e\
    [0m\e[1m\e[31m \e[0m\e[1m\e[31m:\e[0m\e[1m\e[31m \e[0m\e[1m\e[31mList\e[0m\e[1m\e\
    [31m[\e[0m\e[1m\e[31m(\e[0mString, String\e[1m\e[31m)\e[0m\e[1m\e[31m]\e[0m)\n\
    \e[31m   |\e[0m                                  Required: (String, String)\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxgrjrghf.scala:19:50\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m                        compute(paren_str\
    \ :+ (List(c, paren_str.length))) ++ compute(paren_str)\n\e[31m\e[31m   |\e[0m\
    \                                              ^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                              Found:    List[Matchable]\n\
    \e[31m   |\e[0m                                              Required: (String,\
    \ String)\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxgrjrghf.scala:23:21\
    \ --------------------\e[0m\e[0m\n\e[31m23 |\e[0m        compute(List(paren_string))\n\
    \e[31m\e[31m   |\e[0m                     ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \                    Found:    (paren_string : String)\n\e[31m   |\e[0m      \
    \               Required: (String, String)\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660029278
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_stack = mutable.Stack[String]()\n        var max_levels\
    \ : Int = 0\n        paren_string split \" \" foreach {\n            x =>\n  \
    \          if (paren_stack.nonEmpty) {\n                if (x == \"(\") paren_stack.push(x)\n\
    \                if (x == \")\") paren_stack.pop match {\n                   \
    \ case x if x == \"\"  => max_levels = max_levels - 1\n                    case\
    \ x =>\n                }\n                if (paren_stack.nonEmpty) {\n     \
    \               max_levels = max_levels + 1\n                }\n            }\n\
    \        }\n        max_levels\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp0n5itfa7.scala:10:26 ------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e[36mparen_stack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                          ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                          Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp0n5itfa7.scala:25:8 ---------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        max_levels\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    (max_levels : Int)\n\e[31m   |\e[0m    \
    \    Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660029276
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val tokens = paren_string.split(\" \")\n        val stack = mutable.Stack[Long]()\n\
    \        for (i <- 0 until tokens.length) {\n            val item = tokens(i)\n\
    \            if (item == \"(\") {\n                stack += 1\n            } else\
    \ if (item == \")\") {\n                stack -= 1\n            } else if (item\
    \ == \")\") {\n                if (stack.nonEmpty && stack.last.equals(0l)) {\n\
    \                    stack -= 1 // remove 1 from stack\n                }\n  \
    \          }\n        }\n        stack.map { x => x.toLong } //convert to long\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpno9cxdoi.scala:11:20 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660029271
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        // Use recursion over DFS to find deepest level of nesting.\n   \
    \     // We use stack to keep track of nesting level.\n        // If we have gone\
    \ too far, then we can return empty list.\n        val paren_depth_stack = mutable.Stack[Long]()\n\
    \        val paren_depth = mutable.Stack[Long]()\n        val paren_chars = mutable.Stack[Char]()\n\
    \        val paren_count = mutable.Stack[Long]()\n        val paren_map = mutable.Map[Char,\
    \ Long]()\n        val paren_str = paren_string.mkString\n        paren_str.forall(c\
    \ => paren_map.getOrElse(c, -1l) < 0l)\n        if (paren_str.forall(c => c !=\
    \ ')' && c != '(')) {\n            throw new RuntimeException(\"Invalid parenthesis\
    \ format\")\n        }\n        paren_str.split(\"\\\\(\").foreach(c => {\n  \
    \          if (c == '(') {\n                paren_depth.push(0l)\n           \
    \ } else if (c == ')') {\n                paren_depth.pop()\n            } else\
    \ {\n                paren_map.put(c.toChar, paren_count.pop())\n            }\n\
    \            paren_chars.push(c)\n        })\n        while (paren_chars.size\
    \ > 1) {\n            paren_depth.push(paren_depth.last)\n            paren_chars.pop()\n\
    \        }\n        paren_count.pop()\n        paren_count.take(paren_count.size-1).foldLeft(List[Long]())\
    \ { case (acc, x) => acc ++ paren_depth.filter(_ == x).toList }\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((()))\
    \ () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpvte1z5jw.scala:13:32 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mparen_depth_stack\e[0m =\
    \ mutable.Stack[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                    \
    \            ^^^^^^^\e[0m\n\e[31m   |\e[0m                                Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpvte1z5jw.scala:14:26\
    \ ------------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e\
    [36mparen_depth\e[0m = mutable.Stack[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m\
    \                          ^^^^^^^\e[0m\n\e[31m   |\e[0m                     \
    \     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpvte1z5jw.scala:15:26 ------------------------\e[0m\e[0m\n\e[31m15 |\e\
    [0m        \e[33mval\e[0m \e[36mparen_chars\e[0m = mutable.Stack[\e[35mChar\e\
    [0m]()\n\e[31m\e[31m   |\e[0m                          ^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                          Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpvte1z5jw.scala:16:26 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mparen_count\e[0m = mutable.Stack[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                          ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                          Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpvte1z5jw.scala:17:24 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mparen_map\e[0m = mutable.Map[\e\
    [35mChar\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                     \
    \   ^^^^^^^\e[0m\n\e[31m   |\e[0m                        Not found: mutable\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- Error: /tmp/tmpvte1z5jw.scala:24:16 -----------------------------"
  stdout: ''
  timestamp: 1660029280
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        // This regex matches nested group of parentheses separated by spaces.\n\
    \        val paren_group_regex =\n            \"\"\"\\(\\s*\\(\\s*\\)\\s*\\)\"\
    \"\".r\n        // This map maintains the stack at which each level of nesting\
    \ occurred.\n        val paren_level : mutable.Map[Long, Int] = mutable.Map(1l\
    \ -> 1)\n        // This list maintains the deepest level of nesting at each level.\n\
    \        val max_nesting_level : mutable.Map[Long, Int] = mutable.Map(1l -> 0)\n\
    \        // This list maintains the list of groups formed at each level.\n   \
    \     val group_list: mutable.List[String] = mutable.ListBuffer()\n        for\
    \ (group <- paren_string.split(\"[ ]+\"))\n            // Check if this is a nested\
    \ group of parentheses. If so, keep track of level and group details.\n      \
    \      if (paren_group_regex.findFirstIn(group) != null) {\n                val\
    \ level: Int = paren_level.get (group)\n                val group_str = s\"(${group})\"\
    \n                // If level is less than the deepest level, then add this group\
    \ to group_list.\n                if (level < max_nesting_level.get(group))\n\
    \                    group_list.append(group_str)\n                // If level\
    \ is greater than or equal to the deepest level, then add to that level.\n   \
    \             else if (level == max_nesting_level.get(group))\n              \
    \      paren_level (group) = level + 1\n                // If level is equal to\
    \ deepest level, then add this group to that level.\n                else\n  \
    \                  paren_level (group) = level\n            }\n        // Return\
    \ list of levels of nesting.\n        max_nesting_level.foreach {\n          \
    \  case (group_id, level) =>\n                val level_size: Int = level * 2\n\
    \                // Return level of nestings.\n                group_list.drop(level_size\
    \ + 1).take(level_size).mkString(\"(\", \",\", \")\")\n        }\n        // Return\
    \ list of groups with max level of nesting.\n        group_list.take(max_nesting_level.get(paren_string)).mkString(\"\
    (\", \",\", \")\")\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpx7k489eu.scala:14:26 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mparen_level\e[0m : mutable.Map[\e\
    [35mLong\e[0m, \e[35mInt\e[0m] = mutable.Map(\e[31m1l\e[0m -> \e[31m1\e[0m)\n\e\
    [31m\e[31m   |\e[0m                          ^^^^^^^\e[0m\n\e[31m   |\e[0m   \
    \                       Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpx7k489eu.scala:14:51 ------------------------\e[0m\e\
    [0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mparen_level\e[0m : mutable.Map[\e\
    [35mLong\e[0m, \e[35mInt\e[0m] = mutable.Map(\e[31m1l\e[0m -> \e[31m1\e[0m)\n\e\
    [31m\e[31m   |\e[0m                                                   ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                                   Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpx7k489eu.scala:16:32\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mmax_nesting_level\e[0m : mutable.Map[\e[35mLong\e[0m, \e[35mInt\e[0m] = mutable.Map(\e\
    [31m1l\e[0m -> \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m                          \
    \      ^^^^^^^\e[0m\n\e[31m   |\e[0m                                Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpx7k489eu.scala:16:57\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mmax_nesting_level\e[0m : mutable.Map[\e[35mLong\e[0m, \e[35mInt\e[0m] = mutable.Map(\e\
    [31m1l\e[0m -> \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m                          \
    \                               ^^^^^^^\e[0m\n\e[31m   |\e[0m                \
    \                                      Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpx7k489eu.scala:18:24 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mgroup_list\e[0m: m"
  stdout: ''
  timestamp: 1660029273
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        var paren_count : Long = 1\n        var paren_stack : List[Long]\
    \ = Nil\n        var paren_list : List[Long] = Nil\n        paren_string.split(\"\
    \\\\s\").toList.foreach { string => {\n            if (string.startsWith(\"(\"\
    )) {\n                paren_stack = paren_stack.reverse\n                paren_stack\
    \ = paren_stack :+ paren_count\n                paren_count = 1\n            }\
    \ else if ((string.startsWith(\")\")) && (paren_stack.nonEmpty)) {\n         \
    \       val popped_count = paren_stack.reverse\n                paren_stack =\
    \ paren_stack.reverse\n                paren_stack = paren_stack :+ popped_count\n\
    \                paren_count = popped_count\n            } else {\n          \
    \      paren_count += 1\n                paren_list = paren_list :+ paren_count\n\
    \            }\n        }}\n        paren_list.toList.sortBy(_.reverse)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()())\
    \ ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp77ruo7zn.scala:21:45\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m                paren_stack =\
    \ paren_stack :+ popped_count\n\e[31m\e[31m   |\e[0m                         \
    \                    ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                      \
    \             Found:    (popped_count : List[Long])\n\e[31m   |\e[0m         \
    \                          Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmp77ruo7zn.scala:22:30 --------------------\e[0m\e\
    [0m\n\e[31m22 |\e[0m                paren_count = popped_count\n\e[31m\e[31m \
    \  |\e[0m                              ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                          Found:    (popped_count : List[Long])\n\e[31m   |\e\
    [0m                              Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmp77ruo7zn.scala:28:35 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        paren_list.toList.sortBy(_.reverse)\n\e[31m\e\
    [31m   |\e[0m                                 ^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                                 value reverse is not a member of Long\n\e[31m\e\
    [31m-- Error: /tmp/tmp77ruo7zn.scala:28:43 -----------------------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        paren_list.toList.sortBy(_.reverse)\n\e[31m\e\
    [31m   |\e[0m                                           ^\e[0m\n\e[31m   |\e[0mambiguous\
    \ given instances: both \e[33mobject\e[0m \e[35mByte\e[0m in \e[33mobject\e[0m\
    \ \e[35mOrdering\e[0m and \e[33mobject\e[0m \e[35mChar\e[0m in \e[33mobject\e\
    [0m \e[35mOrdering\e[0m match type Ordering[B] of parameter ord of \e[33mmethod\e\
    [0m \e[35msortBy\e[0m in \e[33mtrait\e[0m \e[35mSeqOps\e[0m\n4 errors found\n"
  stdout: ''
  timestamp: 1660029281
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_stack : Stack[String] = new Stack[String]()\n        val\
    \ paren_list : List[Long] = new ListBuffer[Long]()\n        var paren_index =\
    \ 0\n\n        for (i <- 0 until paren_string.length) {\n            if (paren_string(i)\
    \ == '(') {\n                paren_stack.push(paren_string(i))\n            }\
    \ else if (paren_string(i) == ')') {\n                val paren_str = paren_stack.pop()\n\
    \                if (paren_stack.size > 0) {\n                    paren_list.push(paren_index.toLong)\n\
    \                }\n                paren_index += 1\n            }\n        }\n\
    \n        paren_list.last\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpy1z1arbi.scala:11:38\
    \ --------------------\e[0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mparen_list\e\
    [0m : \e[35mList\e[0m[\e[35mLong\e[0m] = \e[33mnew\e[0m \e[35mListBuffer\e[0m[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                                      ^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                     Found:    scala.collection.mutable.ListBuffer[Long]\n\
    \e[31m   |\e[0m                     Required: List[Long]\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpy1z1arbi.scala:16:45 --------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m                paren_stack.push(paren_string(i))\n\e\
    [31m\e[31m   |\e[0m                                 ^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                                 Found:    Char\n\e[31m   |\e[0m   \
    \                              Required: String\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpy1z1arbi.scala:20:31 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m                    paren_list.push(paren_index.toLong)\n\
    \e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ push is not a member of List[Long] - did you mean paren_list.last?\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpy1z1arbi.scala:26:19 --------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        paren_list.last\n\e[31m\e[31m   |\e[0m      \
    \  ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    Long\n\e[31m   |\e[0m\
    \        Required: \e[1m\e[32mList\e[0m\e[1m\e[32m[\e[0mLong\e[1m\e[32m]\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660029282
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        if (paren_string.trim().isEmpty) {\n            return Nil\n    \
    \    }\n        var levels_of_nesting = List(1)\n        val paren_levels = paren_string.groupBy(c\
    \ => c).collect { case (ch, v) => \n            val next_level = levels_of_nesting(levels_of_nesting.size)\n\
    \            if (ch == \")\")\n                next_level += 1\n            if\
    \ (ch == \"(\")\n                next_level -= 1\n            levels_of_nesting\
    \ ::: List(next_level)\n        }\n        val max_levels_of_nesting = levels_of_nesting.max\n\
    \        return List(max_levels_of_nesting.map(_.toLong).toList)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((()))\
    \ () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpikvjqo95.scala:16:16 -----------------------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m            \e[33mif\e[0m (ch == \e[31m\")\"\e[0m)\n\e\
    [31m\e[31m   |\e[0m                ^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Values\
    \ of types Char and String cannot be compared with == or !=\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpikvjqo95.scala:17:27 ------------------------\e[0m\e\
    [0m\n\e[31m17 |\e[0m                next_level += \e[31m1\e[0m\n\e[31m\e[31m \
    \  |\e[0m                ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m           value +=\
    \ is not a member of Int - did you mean next_level.!=?\n\e[31m\e[31m-- Error:\
    \ /tmp/tmpikvjqo95.scala:18:16 -----------------------------------------\e[0m\e\
    [0m\n\e[31m18 |\e[0m            \e[33mif\e[0m (ch == \e[31m\"(\"\e[0m)\n\e[31m\e\
    [31m   |\e[0m                ^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Values of\
    \ types Char and String cannot be compared with == or !=\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpikvjqo95.scala:19:27 ------------------------\e[0m\e\
    [0m\n\e[31m19 |\e[0m                next_level -= \e[31m1\e[0m\n\e[31m\e[31m \
    \  |\e[0m                ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m           value -=\
    \ is not a member of Int - did you mean next_level.!=?\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpikvjqo95.scala:23:42 ------------------------\e[0m\e\
    [0m\n\e[31m23 |\e[0m        \e[33mreturn\e[0m List(max_levels_of_nesting.map(_.toLong).toList)\n\
    \e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                    value map is not a member of Int\n5 errors found\n"
  stdout: ''
  timestamp: 1660029284
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        def loop(paren_string : String, result: List[Long]) : List[Long]\
    \ = {\n            if (paren_string.isEmpty) {\n                result\n     \
    \       } else {\n                val first_paren_index = paren_string.indexOf('(')\n\
    \                val last_paren_index = paren_string.indexOf(')')\n          \
    \      val nested_size = last_paren_index - first_paren_index\n              \
    \  val inner_result = loop(paren_string.substring(first_paren_index + 1, last_paren_index),\
    \ result :+ 0l)\n                val result_with_nested_size = inner_result :+\
    \ nested_size\n                if (nested_size == 0) {\n                    loop(paren_string.substring(last_paren_index\
    \ + 1), result_with_nested_size)\n                } else {\n                 \
    \   loop(paren_string, result_with_nested_size)\n                }\n         \
    \   }\n        }\n        loop(paren_string, Nil)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpr4r5h0j1.scala:20:71\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m                    loop(paren_string.substring(last_paren_index\
    \ + \e[31m1\e[0m), result_with_nested_size)\n\e[31m\e[31m   |\e[0m           \
    \                                                            ^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                      Found:    (result_with_nested_size :\
    \ List[AnyVal])\n\e[31m   |\e[0m                      Required: List[Long]\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpr4r5h0j1.scala:22:39\
    \ --------------------\e[0m\e[0m\n\e[31m22 |\e[0m                    loop(paren_string,\
    \ result_with_nested_size)\n\e[31m\e[31m   |\e[0m                            \
    \           ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                    \
    \  Found:    (result_with_nested_size : List[AnyVal])\n\e[31m   |\e[0m       \
    \               Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660029282
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        def levelOfNestedParen(groups: List[String]): Long = {\n        \
    \    val pairs = groups.grouped(2).map { p =>\n                val pa = p(0)\n\
    \                val pb = (p.size >= 2) ? p(1): 0 \n                val paVal\
    \ = Pair(pa, pb) \n            }\n            pairs.toSeq.maxBy { case (pa, pb)\
    \ =>\n                if (pa.isEmpty) 0\n                else pb - pa\n      \
    \      }.last._2\n        }\n\n        def recursiveSplit(groups: List[String],\
    \ acc: List[Long]): List[Long] = {\n            if (groups.length == 1) {\n  \
    \              acc :+ levelOfNestedParen(groups.toList)\n            } else {\n\
    \                val head = groups.head\n                val tail = groups.drop(1)\n\
    \                recursiveSplit(tail, acc :+ levelOfNestedParen(head))\n     \
    \       }\n        }\n\n        recursiveSplit(paren_string.split(\" \"), List(0).toLong)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp9zn4r10f.scala:13:39 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m                \e[33mval\e[0m \e[36mpb\e[0m = (p.size\
    \ >= \e[31m2\e[0m) ? p(\e[31m1\e[0m): \e[31m0\e[0m \n\e[31m\e[31m   |\e[0m   \
    \                      ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                 \
    \        value ? is not a member of Boolean\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp9zn4r10f.scala:14:28 ------------------------\e[0m\e[0m\n\e[31m14 |\e\
    [0m                \e[33mval\e[0m \e[36mpaVal\e[0m = Pair(pa, pb) \n\e[31m\e[31m\
    \   |\e[0m                            ^^^^\e[0m\n\e[31m   |\e[0m             \
    \               Not found: Pair\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmp9zn4r10f.scala:17:23 ------------------------\e[0m\e[0m\n\e[31m17 |\e\
    [0m                \e[33mif\e[0m (pa.isEmpty) \e[31m0\e[0m\n\e[31m\e[31m   |\e\
    [0m                    ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                    value\
    \ isEmpty is not a member of Any\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp9zn4r10f.scala:18:24\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m                \e[33melse\e\
    [0m pb - pa\n\e[31m\e[31m   |\e[0m                     ^^^^\e[0m\n\e[31m   |\e\
    [0mvalue - is not a member of Any, but could be made available as an extension\
    \ method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might\
    \ make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e[0m  import\
    \ math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import math.Numeric.Implicits.infixNumericOps\n\
    \e[31m   |\e[0m\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp9zn4r10f.scala:28:63\
    \ --------------------\e[0m\e[0m\n\e[31m28 |\e[0m                recursiveSplit(tail,\
    \ acc :+ levelOfNestedParen(head))\n\e[31m\e[31m   |\e[0m                    \
    \                                           ^^^^\e[0m\n\e[31m   |\e[0m       \
    \                                        Found:    (head : String)\n\e[31m   |\e\
    [0m                                               Required: "
  stdout: ''
  timestamp: 1660029287
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_list_str = paren_string.trim\n        val paren_list =\
    \ paren_list_str.split(\" \").toList\n        val paren_list_size = paren_list.length\n\
    \        val paren_list_max = paren_list_size.toLong\n        val paren_list_nesting_levels\
    \ = paren_list_size.toLong - paren_list_max\n        val paren_list_nesting_levels_sum\
    \ = paren_list_nesting_levels.toLong\n        val paren_list_nesting_levels_max_val\
    \ = paren_list_max / paren_list_nesting_levels_sum\n        val paren_list_nesting_levels_max_val_long\
    \ = paren_list_max / 2\n\n        val paren_list_nesting_levels_vals = paren_list_nesting_levels.toList.zip(paren_list_max.toList).map(x\
    \ => x._1 - x._2)\n        val paren_list_nesting_levels_vals_min_val = paren_list_nesting_levels.toList.zip(paren_list_max.toList).map(x\
    \ => x._1 - x._2)\n\n        val paren_list_nesting_levels_vals_max_val = paren_list_nesting_levels.toList.zip(paren_list_max.toList).map(x\
    \ => x._1 - x._2)\n        val paren_list_nesting_levels_vals_max_val_long = paren_list_nesting_levels.toList.zip(paren_list_max.toList).map(x\
    \ => x._1 - x._2)\n\n        val paren_list_nesting_levels_vals_min_val = paren_list_nesting_levels.toList.zip(paren_list_max.toList).map(x\
    \ => x._1 - x._2)\n        val paren_list_nesting_levels_vals_min_val_long = paren_list_nesting_levels.toList.zip(paren_list_max.toList).map(x\
    \ => x._1 - x._2)\n\n        if (paren_list_nesting_levels_vals_max_val(0) ==\
    \ paren_list_nesting_levels_vals(0)) {\n            return paren_list_nesting_levels_vals\n\
    \        } else if (paren_list_nesting_levels_vals_max_val(0) > paren_list_nesting_levels_vals(0))\
    \ {\n            val min_nest_level = paren_list_nesting_levels_vals(0)\n    \
    \        val min_nest_level_max = paren_list_nesting_levels_vals_max_val(0)\n\
    \            if (min_nest_level < min_nest_level_max) {\n                val min_nest_level_max_val\
    \ = paren_list_nesting_levels_vals(0)\n                val min_nest_level_max_val_long\
    \ = paren_list_nesting_levels_vals_max_val(0)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpit9rqqvd.scala:44:0 ----------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpit9rqqvd.scala:25:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m\
    \ \e[36mparen_list_nesting_levels_vals_min_val\e[0m = paren_list_nesting_levels.toList.zip(paren_list_max.toList).map(\e\
    [36mx\e[0m => x._1 - x._2)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mparen_list_nesting_levels_vals_min_val is already defined\
    \ as \e[33mvalue\e[0m \e[35mparen_list_nesting_levels_vals_min_val\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpit9rqqvd.scala:19:71 ------------------------\e[0m\e[0m\n\e[31m19 |\e\
    [0m        \e[33mval\e[0m \e[36mparen_list_nesting_levels_vals\e[0m = paren_list_nesting_levels.toList.zip(paren_list_max.toList).map(\e\
    [36mx\e[0m => x._1 - x._2)\n\e[31m\e[31m   |\e[0m                            \
    \                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ toList is not a member of Long - did you mean paren_list_nesting_levels.toInt?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpit9rqqvd.scala:20:79 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mparen_list_nesting_levels_vals_min_val\e\
    [0m = paren_list_nesting_levels.toList.zip(paren_list_max.toList).map(\e[36mx\e\
    [0m => x._1 - x._2)\n\e[31m\e[31m   |\e[0m                                   \
    \                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ toList is not a member of Long - did you mean paren_list_nesting_levels.toInt?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpit9rqqvd.scala:22:79 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mparen_list_nesting_levels_vals_max_val\e\
    [0m = paren_list_nesting_levels.toList.zip(paren_list_max.toLis"
  stdout: ''
  timestamp: 1660029285
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_chars = paren_string.groupBy(c => c).map { g =>\n     \
    \       val group_len = g.size\n            val group_chars = g.map { c =>\n \
    \               c.toLong\n            }.toList\n            (group_len, group_chars)\n\
    \        }.sortBy(_._1).reverse // Descending order of length\n        val depth\
    \ = 0\n        val paren_levels = paren_chars.map { g =>\n            val len\
    \ = g._1\n            if (len < depth) throw new RuntimeException(\"Mismatched\
    \ paren length\")\n            val level_chars = g._2\n            val paren_level_chars\
    \ = List.fill(len)(0)\n            paren_level_chars.zip(level_chars).map { case\
    \ (l, c) => (l - 1, c) }\n        }\n        val max_depth = paren_levels.map\
    \ { l => l.max }.max\n        paren_levels.reverse // Reverse so that deeper groups\
    \ are on top.\n        if (max_depth != depth)\n            throw new RuntimeException(\"\
    Mismatched paren length\")\n        paren_levels\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E081] Type Error: /tmp/tmptius6g5u.scala:12:38 -----------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m            \e[33mval\e[0m \e[36mgroup_chars\e[0m = g.map\
    \ { \e[36mc\e[0m =>\n\e[31m\e[31m   |\e[0m                                   \
    \   ^\e[0m\n\e[31m   |\e[0m                          Missing parameter type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m                          I could not infer the\
    \ type of the parameter c.\n1 error found\n"
  stdout: ''
  timestamp: 1660029279
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        paren_string.split(\"\\\\s+\")\n            .flatMap(x => x.length)\n\
    \            .foldLeft(0L){ (i, x) =>\n                i + (if (x == \"(\") 1\
    \ else 0)\n            }\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpj1v6lsk1.scala:11:35 -----------------------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m            .flatMap(x => x.length)\n\e[31m\e[31m   |\e\
    [0m                                   ^\e[0m\n\e[31m   |\e[0mno given instance\
    \ of type Int => Iterable[B] was found for parameter asIterable of \e[33mmethod\e\
    [0m \e[35mflatMap\e[0m in \e[33mclass\e[0m \e[35mArrayOps\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mwhere:    B is a type variable\n1 error found\n"
  stdout: ''
  timestamp: 1660029287
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        def findParen(groups: List[String], paren_string : String) : List[Long]\
    \ = {\n            val start = 0\n            val end = 0\n            for (index\
    \ <- 0 until groups.length) {\n                if (paren_string.startsWith(groups(index)))\
    \ {\n                    start = index\n                    if (paren_string.length\
    \ == start + 1) {\n                        end = paren_string.length\n       \
    \             }\n                }\n            }\n            val start = start\
    \ + 1\n            val end = end + 1\n            val paren_groups = groups.slice(start,\
    \ end).toList\n            val paren_strs = paren_string.substring(start, end)\n\
    \            val paren_groups_and_strs = paren_groups ::: List(paren_strs)\n \
    \           val groups_with_strs = paren_groups_and_strs.map(group =>\n      \
    \          if (group == \"\") {\n                    \"\"\n                } else\
    \ {\n                    group\n                }\n            )\n           \
    \ val strs_to_groups: List[List[String]] = groups_with_strs.map(\n           \
    \     group =>\n                    if (group.startsWith(\"(\")) {\n         \
    \               group.drop(1)\n                    } else if (group.startsWith(\"\
    (\")) {\n                        List(\"(\")\n                    } else {\n \
    \                       List(\")\")\n                    }\n            )\n  \
    \          val groups_with_strs_to_groups: List[List[List[String]]] = strs_to_groups.map(\n\
    \                group =>\n                    group\n            )\n        \
    \    val groups_to_strs: List[List[String]] = groups_with_strs_to_groups.map(\n\
    \                group =>\n                    if (group.head.length == group.length)\
    \ {\n                        group\n                    } else {\n           \
    \             group.reverse\n                    }\n            )\n          \
    \  val strs_to_groups_and_strs: List[List[List[String]]] = groups_to_strs.map(\n\
    \                group =>\n                    if (group.length == 1) {\n    \
    \                    group\n                    } else {\n                   \
    \     group.reverse\n                    }\n            )\n            val groups_with_strs_to_groups_and_strs:\
    \ List[List[List[List[String]]]] = strs_to_groups_and_strs.map(\n            \
    \    group =>\n                    if (group.length == 1) {\n                \
    \        group\n                    } else {\n                        group.reverse\n\
    \                    }\n            )\n            val groups_to_strs_to_strs:\
    \ List[List[List[List[List[String]]]]] = groups_with_strs_to_groups_and_strs.map(\n\
    \                group =>\n                    if (group.length == 1) {\n    \
    \                    group\n                    } else {\n                   \
    \     group.reverse\n                    }\n            )\n            val groups_and_strs_to_strs:\
    \ List[List[List[List[List[List[String]]]]]] = groups_to_strs_to_strs.map(\n \
    \               group =>\n                    if (group.length == 1) {\n     \
    \                   group\n                    } else {\n                    \
    \    group.reverse\n                    }\n            )\n            val strs_to_strs:\
    \ List[List[List[List[List[List[List[List[String]]]]]]]] = groups_and_strs_to_strs.map(\n\
    \                group =>\n                    if (group.length\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((()))\
    \ () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp11o3t58l.scala:90:4 ----------------------------\e\
    [0m\e[0m\n\e[31m90 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp11o3t58l.scala:98:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m98 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp11o3t58l.scala:21:16 ---------------------------\e[0m\e[0m\n\e\
    [31m21 |\e[0m            \e[33mval\e[0m \e[36mstart\e[0m = start + \e[31m1\e[0m\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mstart\
    \ is already defined as \e[33mvalue\e[0m \e[35mstart\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp11o3t58l.scala:22:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m22 |\e[0m            \e[33mval\e\
    [0m \e[36mend\e[0m = end + \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mend is already defined as \e[33mvalue\e[0m \e[35mend\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E052] Type Error:\
    \ /tmp/tmp11o3t58l.scala:15:26 -----------------------------\e[0m\e[0m\n\e[31m15\
    \ |\e[0m                    start = index\n\e[31m\e[31m   |\e[0m             \
    \       ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                    Reassignment to\
    \ val start\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmp11o3t58l.scala:17:28\
    \ -----------------------------\e[0m\e[0m\n\e[31m17 |\e[0m                   \
    \     end = paren_string.length\n\e[31m\e[31m   |\e[0m                       \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                        Reassignment\
    \ to val end\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp11o3t58l.scala:36:34\
    \ --------------------\e[0m\e[0m\n\e[31m36 |\e[0m           "
  stdout: ''
  timestamp: 1660029296
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        var max_depth = 0\n        var max_depth_depth = 0\n        var depth\
    \ = 0\n        var depth_depth = 0\n        \n        for(line <- paren_string.split('\
    \ ')){\n            if(line.length == 0 || line.length == 1)\n               \
    \ continue\n            \n            var depth_count = 0\n            var depth_depth_count\
    \ = 0\n            \n            for(i <- 0 until line.length){\n            \
    \    if(line(i) == '(')\n                    depth_count+=1\n                else\n\
    \                    depth_depth_count+=1\n            }\n            \n     \
    \       if(depth_count > max_depth){\n                max_depth = depth_count\n\
    \                max_depth_depth = depth_depth_count\n            }\n        \
    \    \n            if(depth_depth_count > max_depth_depth){\n                max_depth_depth\
    \ = depth_depth_count\n            }\n        }\n        \n        val result\
    \ = List(max_depth, max_depth_depth)\n        \n        return result\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()())\
    \ ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmppfzqvplh.scala:17:16 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m                continue\n\e[31m\e[31m   |\e[0m     \
    \           ^^^^^^^^\e[0m\n\e[31m   |\e[0m                Not found: continue\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmppfzqvplh.scala:41:15\
    \ --------------------\e[0m\e[0m\n\e[31m41 |\e[0m        \e[33mreturn\e[0m result\n\
    \e[31m\e[31m   |\e[0m               ^^^^^^\e[0m\n\e[31m   |\e[0m             \
    \  Found:    (result : List[Int])\n\e[31m   |\e[0m               Required: List[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660029291
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        // initialize a stack of paren levels\n        val paren_stack =\
    \ new Stack[Long]()\n        var level = 0\n        // initialize a mutable string\
    \ for holding group strings\n        val group_strs = mutable.StringBuilder.newBuilder\n\
    \        // for each character in the paren string, push it onto the stack\n \
    \       for (c <- paren_string) \n            if (c == '(') \n               \
    \ paren_stack.push(level.toLong)\n            else if (c == ')')\n           \
    \     if (paren_stack.nonEmpty && paren_stack.peek == level.toLong)\n        \
    \            paren_stack.pop()\n            else\n                group_strs.append(c)\n\
    \        // get the deepest level from the stack\n        val max_level = paren_stack.mkString(\"\
    \").length\n        // append max level to the list of groups\n        group_strs.append(max_level.toString)\n\
    \        // convert the mutable string to a list\n        val groups = group_strs.result\n\
    \        val groups_list = groups.toList\n        return groups_list\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()())\
    \ ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp5ka60gdz.scala:14:25 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mgroup_strs\e[0m = mutable.StringBuilder.newBuilder\n\
    \e[31m\e[31m   |\e[0m                         ^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                       Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp5ka60gdz.scala:20:56 ------------------------\e[0m\e\
    [0m\n\e[31m20 |\e[0m                \e[33mif\e[0m (paren_stack.nonEmpty && paren_stack.peek\
    \ == level.toLong)\n\e[31m\e[31m   |\e[0m                                    \
    \        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue peek is not a member of scala.collection.mutable.Stack[Long]\
    \ - did you mean paren_stack.head?\n2 errors found\n"
  stdout: ''
  timestamp: 1660029289
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_lengths = paren_string.split(\" \").map(x => x.length.toLong)\n\
    \        val max_length = Math.max.applyOrElse(paren_lengths.head, 0L)\n     \
    \   val paren_levels = paren_lengths.toList.takeWhile(x => x <= max_length).map((x)\
    \ => max_length - x).map(x => List(x).sum).toList\n        val max_level = paren_lengths.max\n\
    \        paren_levels.takeWhile(x => x.max == max_level).toList\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((()))\
    \ () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpirz1z_q9.scala:11:30 -----------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mmax_length\e[0m = Math.max.applyOrElse(paren_lengths.head,\
    \ \e[31m0L\e[0m)\n\e[31m\e[31m   |\e[0m                         ^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e[35mmax\e\
    [0m in \e[33mobject\e[0m \e[35mMath\e[0m with types\n\e[31m   |\e[0m (x$0: Double,\
    \ x$1: Double): Double\n\e[31m   |\e[0m (x$0: Float, x$1: Float): Float\n\e[31m\
    \   |\e[0m (x$0: Long, x$1: Long): Long\n\e[31m   |\e[0m (x$0: Int, x$1: Int):\
    \ Int\n\e[31m   |\e[0mmatch expected type ?{ applyOrElse: ? }\n\e[31m\e[31m--\
    \ Error: /tmp/tmpirz1z_q9.scala:12:127 ----------------------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mparen_levels\e[0m = paren_lengths.toList.takeWhile(\e\
    [36mx\e[0m => x <= max_length).map((\e[36mx\e[0m) => max_length - x).map(\e[36mx\e\
    [0m => List(x).sum).toList\n\e[31m\e[31m   |\e[0m                            \
    \                                                                            \
    \                       ^\e[0m\n\e[31m   |\e[0mambiguous given instances: both\
    \ \e[33mobject\e[0m \e[35mBigDecimalIsFractional\e[0m in \e[33mobject\e[0m \e\
    [35mNumeric\e[0m and \e[33mobject\e[0m \e[35mLongIsIntegral\e[0m in \e[33mobject\e\
    [0m \e[35mNumeric\e[0m match type Numeric[B] of parameter num of \e[33mmethod\e\
    [0m \e[35msum\e[0m in \e[33mtrait\e[0m \e[35mIterableOnceOps\e[0m\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpirz1z_q9.scala:14:38 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        paren_levels.takeWhile(\e[36mx\e[0m => x.max\
    \ == max_level).toList\n\e[31m\e[31m   |\e[0m                                \
    \    ^^^^^\e[0m\n\e[31m   |\e[0mvalue max is not a member of Nothing, but could\
    \ be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne\
    \ of the following imports might fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m  import math.Ordering.Implicits.seqOrdering\n\e[31m   |\e[0m  import math.Ordering.Implicits.sortedSetOrdering\n\
    \e[31m   |\e[0m  import math.Ordering.Iterable\n\e[31m   |\e[0m  import math.Ordering.Option\n\
    \e[31m "
  stdout: ''
  timestamp: 1660029295
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_list = paren_string.split(\" \").filterNot(_.isEmpty).map(x\
    \ => x.toLong).sorted\n        val paren_stack = new mutable.Stack[Int]\n    \
    \    var paren_level : Int = 1\n        var paren_stack_size = 0\n        for\
    \ (i <- 0 to paren_list.length-1) {\n            val cur = paren_list(i)\n   \
    \         if(paren_stack.size>0){\n                val ps = paren_stack.last\n\
    \                if (paren_stack.size < ps) {\n                    paren_stack.clear()\n\
    \                }\n            }\n            paren_stack.push(paren_stack.size)\n\
    \            paren_stack_size = paren_stack.size\n            if(ps >0){\n   \
    \             if(paren_stack.last==ps){\n                    paren_level += 1\n\
    \                }\n            }\n            val new_level = paren_level + 1\n\
    \            paren_stack.push(new_level)\n        }\n        paren_stack.pop\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpyxk6m232.scala:11:30 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mparen_stack\e[0m = \e[33mnew\e\
    [0m mutable.Stack[\e[35mInt\e[0m]\n\e[31m\e[31m   |\e[0m                     \
    \         ^^^^^^^\e[0m\n\e[31m   |\e[0m                              Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpyxk6m232.scala:24:15\
    \ ------------------------\e[0m\e[0m\n\e[31m24 |\e[0m            \e[33mif\e[0m(ps\
    \ >\e[31m0\e[0m){\n\e[31m\e[31m   |\e[0m               ^^\e[0m\n\e[31m   |\e[0m\
    \               Not found: ps\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660029287
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        var parens = mutable.List.empty[Long]\n        var nesting = 0\n\
    \        var i = 1\n        var next_parens = 0\n        while(i < paren_string.length){\n\
    \            if(paren_string(i) == '('){\n                parens +=( paren_string\
    \ (i).toLong)\n                nesting += 1\n                next_parens = 1\n\
    \            } else if(paren_string(i) == ')'){\n                nesting -= 1\n\
    \                next_parens = 0\n            } else if(nesting == 0 && next_parens\
    \ == 0){\n                parens +=( paren_string(i).toLong)\n            }\n\
    \            i += 1\n        }\n        return parens\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"\
    () (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmphmo65sls.scala:10:21 ------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m        \e[33mvar\e[0m \e[36mparens\e[0m = mutable.List.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660029288
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \").toList\n        val\
    \ depths = mutable.ListBuffer[Long]()\n        var depth = 0\n        var max_depth\
    \ = 0\n        var paren_group_size = 0\n        for (paren_group_i <- paren_groups.indices)\
    \ {\n            if (paren_group_size++ == paren_groups(paren_group_i).length)\
    \ {\n                max_depth = depth\n                depth = 0\n          \
    \  }\n            depth += 1\n            if (paren_group_size++ == paren_groups(paren_group_i).length)\
    \ {\n                depths += max_depth.toLong\n                max_depth = 0\n\
    \            }\n        }\n        depths += max_depth.toLong\n        depths.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpst4zwu_l.scala:11:21 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mdepths\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpst4zwu_l.scala:16:32 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m            \e[33mif\e[0m (paren_group_size++ == paren_groups(paren_group_i).length)\
    \ {\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                value ++ is not a member of Int\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmpst4zwu_l.scala:21:32 ------------------------\e[0m\e[0m\n\
    \e[31m21 |\e[0m            \e[33mif\e[0m (paren_group_size++ == paren_groups(paren_group_i).length)\
    \ {\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                value ++ is not a member of Int\n3 errors found\n"
  stdout: ''
  timestamp: 1660029296
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        // Create a list of all the groups in the input.\n        val groups\
    \ = paren_string.split(\" \").map(x => x.replaceAll(\"\\\\(\", \"\").replaceAll(\"\
    \\\\)\", \"\"))\n        // Create a map from each group to its level of nesting.\n\
    \        val group_to_level = groups.groupBy(x => x).mapValues(_.size)\n     \
    \   // Find the deepest level of nesting of each group.\n        val max_level\
    \ = group_to_level.maxBy(_._1)\n        // Find the level of the group that has\
    \ maximum nesting.\n        val max_level_group = max_level._1\n        // Get\
    \ the list of all the groups that has maximum nesting.\n        val max_level_groups\
    \ = groups.filter(x => x == max_level_group).map(x => x.replaceAll(\"\\\\(\",\
    \ \"\").replaceAll(\"\\\\)\", \"\"))\n        // Return the list of all groups\
    \ that has maximum nesting.\n        return max_level_groups\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"\
    () (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpio4wn5il.scala:21:15\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mreturn\e[0m max_level_groups\n\
    \e[31m\e[31m   |\e[0m               ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m   \
    \            Found:    (max_level_groups : Array[String])\n\e[31m   |\e[0m   \
    \            Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660029294
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        var paren_count = 0\n        var level = 0\n        paren_string.trim.split(\"\
    \\\\s+\").map { p =>\n            paren_count += 1\n            val length = p.length\n\
    \            if(p.startsWith(\"(\")) {\n                level += 1\n         \
    \   }\n            if(p.endsWith(\")\")) {\n                level -= 1\n     \
    \       }\n            if(level > 0) {\n                level\n            } else\
    \ {\n                length\n            }\n        }.max\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"\
    () (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpfczbgxou.scala:12:8\
    \ ---------------------\e[0m\e[0m\n\e[31m12 |\e[0m        paren_string.trim.split(\e\
    [31m\"\\\\s+\"\e[0m).map { \e[36mp\e[0m =>\n\e[31m\e[31m   |\e[0m        ^\e[0m\n\
    \e[31m   |\e[0m        Found:    Int\n\e[31m   |\e[0m        Required: List[Long]\n\
    \e[31m13 |\e[0m            paren_count += \e[31m1\e[0m\n\e[31m14 |\e[0m      \
    \      \e[33mval\e[0m \e[36mlength\e[0m = p.length\n\e[31m15 |\e[0m          \
    \  \e[33mif\e[0m(p.startsWith(\e[31m\"(\"\e[0m)) {\n\e[31m16 |\e[0m          \
    \      level += \e[31m1\e[0m\n\e[31m17 |\e[0m            }\n\e[31m18 |\e[0m  \
    \          \e[33mif\e[0m(p.endsWith(\e[31m\")\"\e[0m)) {\n\e[31m19 |\e[0m    \
    \            level -= \e[31m1\e[0m\n\e[31m20 |\e[0m            }\n\e[31m21 |\e\
    [0m            \e[33mif\e[0m(level > \e[31m0\e[0m) {\n\e[31m22 |\e[0m        \
    \        level\n\e[31m23 |\e[0m            } \e[33melse\e[0m {\n\e[31m24 |\e[0m\
    \                length\n\e[31m25 |\e[0m            }\n\e[31m26 |\e[0m       \
    \ }.max\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660029296
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_array = paren_string.split(\" \").map(_.toLong)\n     \
    \   val paren_array2 = paren_string.map(_.toLong)\n        var paren_array_depth\
    \ = paren_array.foldLeft(0)((max, x) => if (max > x) max else x)\n        while\
    \ (paren_array.length > 0) {\n            if (paren_array.tail.foldRight(0)((max,\
    \ x) => if (max > x) max else x)\n                > paren_array_depth)\n     \
    \           paren_array_depth = paren_array.tail.foldRight(0)((max, x) => if (max\
    \ > x) max else x)\n            paren_array = paren_array.tail\n        }\n  \
    \      paren_array_depth\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpaoeoaek0.scala:12:90\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m        \e[33mvar\e[0m \e[36mparen_array_depth\e\
    [0m = paren_array.foldLeft(\e[31m0\e[0m)((\e[36mmax\e[0m, \e[36mx\e[0m) => \e\
    [33mif\e[0m (max > x) max \e[33melse\e[0m x)\n\e[31m\e[31m   |\e[0m          \
    \                                                                            \
    \    ^\e[0m\n\e[31m   |\e[0m                                                 \
    \   Found:    (x : Long)\n\e[31m   |\e[0m                                    \
    \                Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpaoeoaek0.scala:14:71 --------------------\e[0m\e[0m\n\e[31m14\
    \ |\e[0m            \e[33mif\e[0m (paren_array.tail.foldRight(\e[31m0\e[0m)((\e\
    [36mmax\e[0m, \e[36mx\e[0m) => \e[33mif\e[0m (max > x) max \e[33melse\e[0m x)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \               ^^^\e[0m\n\e[31m   |\e[0m                                    \
    \              Found:    (max : Long)\n\e[31m   |\e[0m                       \
    \                           Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpaoeoaek0.scala:16:91 --------------------\e[0m\e\
    [0m\n\e[31m16 |\e[0m                paren_array_depth = paren_array.tail.foldRight(\e\
    [31m0\e[0m)((\e[36mmax\e[0m, \e[36mx\e[0m) => \e[33mif\e[0m (max > x) max \e[33melse\e\
    [0m x)\n\e[31m\e[31m   |\e[0m                                                \
    \                                           ^^^\e[0m\n\e[31m   |\e[0m        \
    \                                          Found:    (max : Long)\n\e[31m   |\e\
    [0m                                                  Required: Int\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E052] Type Error: /tmp/tmpaoeoaek0.scala:17:24 -----------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m            paren_array = paren_array.tail\n\e[31m\e\
    [31m   |\e[0m            ^^^"
  stdout: ''
  timestamp: 1660029299
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        //\n        // This code below is just a simple recursive depth traversing\
    \ algorithm\n        // You have to modify the code so that it stops at some point\
    \ and returns the result list.\n        // The code below is just a sample code.\
    \ You have to modify it accordingly\n        //\n        val paren_level : Int\
    \ = paren_string.count(\"(\")\n        val open_count : Int = paren_string.count(\"\
    (\") - paren_string.count(\")\")\n        val close_count : Int = paren_string.count(\"\
    )\") - paren_string.count(\"(\")\n        var opening_level : Int = 0\n      \
    \  var deepest_level : Int = 0\n        if(paren_level == open_count && close_count\
    \ > 0) {\n            opening_level = paren_level\n            deepest_level =\
    \ paren_level\n        }\n        else if(paren_level == open_count && close_count\
    \ == 0) {\n            opening_level = paren_level\n            deepest_level\
    \ = paren_level\n        }\n        else if((paren_level - open_count) == close_count)\
    \ {\n            opening_level = paren_level\n            deepest_level = open_count\n\
    \        }\n        else {\n            opening_level = paren_level\n        \
    \    deepest_level = 0\n        }\n        val result = new ArrayList[Long](deepest_level)\n\
    \        for(i <- 0 until deepest_level) {\n            result.add(i.toLong)\n\
    \        }\n        val temp : List[Long] = paren_string.split(\"\\\\(\")\n  \
    \      for(i <- 0 until temp.size) {\n            val temp1 : List[Long] = temp(i).split(\"\
    \\\\)\")\n            for(j <- 0 until temp1.size) {\n                result.add(j.toLong)\n\
    \            }\n        }\n        return result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpu55wiol8.scala:15:51\
    \ --------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mparen_level\e\
    [0m : \e[35mInt\e[0m = paren_string.count(\e[31m\"(\"\e[0m)\n\e[31m\e[31m   |\e\
    [0m                                                   ^^^\e[0m\n\e[31m   |\e[0m\
    \                                               Found:    (\e[32m\"(\"\e[0m :\
    \ String)\n\e[31m   |\e[0m                                               Required:\
    \ Char => Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpu55wiol8.scala:16:50\
    \ --------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mopen_count\e\
    [0m : \e[35mInt\e[0m = paren_string.count(\e[31m\"(\"\e[0m) - paren_string.count(\e\
    [31m\")\"\e[0m)\n\e[31m\e[31m   |\e[0m                                       \
    \           ^^^\e[0m\n\e[31m   |\e[0m                                        \
    \       Found:    (\e[32m\"(\"\e[0m : String)\n\e[31m   |\e[0m               \
    \                                Required: Char => Boolean\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpu55wiol8.scala:16:76 --------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mopen_count\e[0m : \e[35mInt\e\
    [0m = paren_string.count(\e[31m\"(\"\e[0m) - paren_string.count(\e[31m\")\"\e\
    [0m)\n\e[31m\e[31m   |\e[0m                                                  \
    \                          ^^^\e[0m\n\e[31m   |\e[0m                         \
    \                      Found:    (\e[32m\")\"\e[0m : String)\n\e[31m   |\e[0m\
    \                                               Required: Char => Boolean\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpu55wiol8.scala:17:51\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mclose_count\e\
    [0m : \e[35mInt\e[0m = paren_string.count(\e[31m\")\"\e[0m) - paren_string.count(\e\
    [31m\"(\"\e[0m)\n\e[31m\e[31m   |\e[0m                                       \
    \            ^"
  stdout: ''
  timestamp: 1660029302
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        var paren_level = 0\n        var paren_start_pos = -1\n        var\
    \ paren_end_pos = 0\n        var paren_stack = Stack.empty[Long]\n        var\
    \ paren_groups = paren_string.split(\" \")\n        var paren_groups_list = paren_groups.toList\n\
    \        var paren_groups_size = paren_groups_list.size\n        var paren_groups_cur\
    \ = 0\n        var paren_groups_remain_size = paren_groups_size\n        var max_nested_level\
    \ = 0\n        while (paren_groups_cur < paren_groups_size) {\n            paren_groups_remain_size\
    \ -= 1\n            val curr_nested_level = (paren_groups_size - paren_groups_cur)\
    \ //number of remaining parentheses levels\n            if ((curr_nested_level\
    \ > max_nested_level)) {\n                max_nested_level = curr_nested_level\n\
    \            }\n            paren_stack = paren_stack.push((paren_groups_cur,\
    \ paren_groups_remain_size))\n            paren_groups_cur += 1\n        }\n \
    \       // We use max level here as we want the deepest nesting to be the most\
    \ deeply nested (which is the max number of parentheses)\n        var deepest_level\
    \ = 0\n        while (paren_stack.size > deepest_level) {\n            val paren_level\
    \ = paren_stack.pop()\n            paren_level -= 1\n            val paren_start_pos\
    \ = paren_level.toLong\n            val paren_end_pos = paren_start_pos + 1\n\
    \            paren_groups_list.slice(paren_start_pos, paren_end_pos)\n       \
    \     val paren_groups = paren_groups_list.mkString(\" \")\n            paren_groups_list\
    \ = paren_groups.split(\" \").toList\n            paren_groups_size = paren_groups_list.size\n\
    \            paren_groups_cur = 0\n            paren_groups_remain_size = paren_groups_size\n\
    \            while (paren_groups_cur < paren_groups_size) {\n                paren_groups_remain_size\
    \ -= 1\n                val curr_nested_level = (paren_groups_size - paren_groups_cur)\
    \ //number of remaining parentheses levels\n                if ((curr_nested_level\
    \ > max_nested_level)) {\n                    max_nested_level = curr_nested_level\n\
    \                }\n                paren_stack = paren_stack.push((paren_groups_cur,\
    \ paren_groups_remain_size))\n                paren_groups_cur += 1\n        \
    \    }\n            deepest_level = paren_level\n        }\n        paren_stack.clear()\n\
    \        return paren_stack.asInstanceOf[List[Long]]\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"\
    () (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5f7i4n45.scala:26:43\
    \ --------------------\e[0m\e[0m\n\e[31m26 |\e[0m            paren_stack = paren_stack.push((paren_groups_cur,\
    \ paren_groups_remain_size))\n\e[31m\e[31m   |\e[0m                          \
    \                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                                           Found:    (Int, Int)\n\e[31m\
    \   |\e[0m                                           Required: Long\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp5f7i4n45.scala:33:24 ------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m            paren_level -= \e[31m1\e[0m\n\e[31m\e[31m\
    \   |\e[0m            ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m         value -= is\
    \ not a member of Long - did you mean paren_level.!=?\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmp5f7i4n45.scala:36:36 --------------------\e[0m\e[0m\n\
    \e[31m36 |\e[0m            paren_groups_list.slice(paren_start_pos, paren_end_pos)\n\
    \e[31m\e[31m   |\e[0m                                    ^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                    Found:    (paren_start_pos\
    \ : Long)\n\e[31m   |\e[0m                                    Required: Int\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5f7i4n45.scala:36:53\
    \ --------------------\e[0m\e[0m\n\e[31m36 |\e[0m            paren_groups_list.slice(paren_start_pos,\
    \ paren_end_pos)\n\e[31m\e[31m   |\e[0m                                      \
    \               ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                          \
    \              Found:    (paren_end_pos : Long)\n\e[31m   |\e[0m             \
    \                           Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmp5f7i4n45.scala:48:47 --------------------\e[0m\e\
    [0m\n\e[31m48 |\e[0m                paren_stack = paren_stack.push((paren_groups_cur,\
    \ paren_groups_remain_size))\n\e[31m\e[31m  "
  stdout: ''
  timestamp: 1660029302
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        var paren_stack: List[Long] = Nil\n        var parentheses = 0\n\n\
    \        paren_string.foreach(ch => {\n            if((ch == '(') || (ch == '[')\
    \ || (ch == '{')) {\n                parentheses += 1\n                paren_stack\
    \ ::= paren_stack.last + 1\n            } else if((ch == ')') || (ch == ']') ||\
    \ (ch == '}')) {\n                parentheses -= 1\n                if(parentheses\
    \ == 0) return paren_stack\n            }\n        })\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"\
    () (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphf_ootnq.scala:13:28\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m        paren_string.foreach(\e\
    [36mch\e[0m => {\n\e[31m\e[31m   |\e[0m        ^\e[0m\n\e[31m   |\e[0m       \
    \ Found:    Unit\n\e[31m   |\e[0m        Required: List[Long]\n\e[31m14 |\e[0m\
    \            \e[33mif\e[0m((ch == \e[31m'('\e[0m) || (ch == \e[31m'['\e[0m) ||\
    \ (ch == \e[31m'{'\e[0m)) {\n\e[31m15 |\e[0m                parentheses += \e\
    [31m1\e[0m\n\e[31m16 |\e[0m                paren_stack ::= paren_stack.last +\
    \ \e[31m1\e[0m\n\e[31m17 |\e[0m            } \e[33melse\e[0m \e[33mif\e[0m((ch\
    \ == \e[31m')'\e[0m) || (ch == \e[31m']'\e[0m) || (ch == \e[31m'}'\e[0m)) {\n\e\
    [31m18 |\e[0m                parentheses -= \e[31m1\e[0m\n\e[31m19 |\e[0m    \
    \            \e[33mif\e[0m(parentheses == \e[31m0\e[0m) \e[33mreturn\e[0m paren_stack\n\
    \e[31m20 |\e[0m            }\n\e[31m21 |\e[0m        })\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660029299
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_re = raw\"(\" +\n                        raw\"\\((\" +\n\
    \                        paren_string.split(\"\\\\)\").map(l => raw\"(\" + l +\
    \ \")\").mkString +\n                        raw\"\\)\" +\n                  \
    \      raw\")\"\n        val paren_matcher = paren_re.r.pattern\n        val paren_list\
    \ : List[(String, String)] = paren_string.split(\"\\\\)\").map( _ =>\n       \
    \     paren_matcher.findFirstIn(_).map( m => m.groups.last).mkString\n       \
    \ ).map {\n            case m if m != \"\" => (m, \"\")\n            case m =>\
    \ (m, m.groups.take(m.groups.size - 1).mkString)\n        }.toList\n        (paren_list.map\
    \ {\n            case (s, \"\") => (longVal(s), \"\")\n            case (m, \"\
    \") => (longVal(m), m.groups.last)\n        }.foldLeft((List.empty[Long], \"\"\
    )) {\n            case ((l, m), s) => if (m.isEmpty) ((l + longVal(s), \"\"),\
    \ \"\") else (l.head + longVal(m) + longVal(s), \"\")\n        }._1)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()())\
    \ ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E081] Type Error: /tmp/tmpgmaht2h1.scala:17:38 -----------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m            paren_matcher.findFirstIn(_).map( \e[36mm\e\
    [0m => m.groups.last).mkString\n\e[31m\e[31m   |\e[0m                        \
    \              ^\e[0m\n\e[31m   |\e[0m Missing parameter type\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m I could not infer the type of the parameter _$2 of expanded function:\n\
    \e[31m   |\e[0m _$2 => paren_matcher.findFirstIn(_$2).map(m => m.groups.last).mkString.\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpgmaht2h1.scala:17:26 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m            paren_matcher.findFirstIn(_).map( \e[36mm\e\
    [0m => m.groups.last).mkString\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m            value findFirstIn is not a member of java.util.regex.Pattern\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpgmaht2h1.scala:20:28 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m            \e[33mcase\e[0m m => (m, m.groups.take(m.groups.size\
    \ - \e[31m1\e[0m).mkString)\n\e[31m\e[31m   |\e[0m                          ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                          value groups is not a member of\
    \ Any\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpgmaht2h1.scala:23:29 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            \e[33mcase\e[0m (s, \e[31m\"\"\e[0m) => (longVal(s),\
    \ \e[31m\"\"\e[0m)\n\e[31m\e[31m   |\e[0m                             ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                             Not found: longVal\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpgmaht2h1.scala:24:29 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m            \e[33mcase\e[0m (m, \e[31m\"\"\e[0m) => (longVal(m),\
    \ m.groups.last)\n\e[31m\e[31m   |\e[0m                             ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                             Not found: longVal\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpgmaht2h1.scala:24:43 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e["
  stdout: ''
  timestamp: 1660029307
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_stack = mutable.Stack[String]()\n        var max_level\
    \ = 0\n        paren_string.split(\"\\\\s+\").foreach(\n            s => {\n \
    \               paren_stack += s\n                if (s.startsWith(\"(\") || s.startsWith(\"\
    )\")){\n                    var level = 1\n                    while (paren_stack.hasNext){\n\
    \                        val top = paren_stack.pop()\n                       \
    \ if (top == \")\") level -= 1\n                        else level++\n       \
    \                 if (level > max_level) max_level = level\n                 \
    \   }\n                }\n            }\n        )\n        max_level\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()())\
    \ ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpjq2qxz84.scala:20:36 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m                        \e[33melse\e[0m level++\n\e[31m\e\
    [31m   |\e[0m                                    ^\e[0m\n\e[31m   |\e[0m     \
    \                               expression expected but \e[31mif\e[0m found\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpjq2qxz84.scala:10:26\
    \ ------------------------\e[0m\e[0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e\
    [36mparen_stack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e\
    [0m                          ^^^^^^^\e[0m\n\e[31m   |\e[0m                   \
    \       Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpjq2qxz84.scala:26:8 ---------------------\e[0m\e[0m\n\e[31m26\
    \ |\e[0m        max_level\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m        Found:    (max_level : Int)\n\e[31m   |\e[0m        Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660029302
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        def getMaxNestingLevel(nesting : Seq[String], level : Int) : Long\
    \ = {\n            val max_nesting_level = nesting.foldLeft[Long](0)((max_nesting_level,\
    \ level) => max_nesting_level + level * max_nesting_level)\n            max_nesting_level\n\
    \        }\n        def getMaxLevelParens(nesting : Seq[String], level : Int)\
    \ : Seq[String] = {\n            val max_nesting_level = getMaxNestingLevel(nesting,\
    \ level)\n            if (max_nesting_level > 1) nesting else Seq.empty\n    \
    \    }\n        val parens = paren_string.split(\" \")\n        val nesting =\
    \ parens.map(paren => paren.split(\"(\")).toSeq\n        val max_nesting_level\
    \ = getMaxNestingLevel(nesting, 0)\n        if (max_nesting_level > 1) nesting\
    \ else Seq.empty\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpf0xon022.scala:11:120\
    \ -------------------\e[0m\e[0m\n\e[31m11 |\e[0m            \e[33mval\e[0m \e\
    [36mmax_nesting_level\e[0m = nesting.foldLeft[\e[35mLong\e[0m](\e[31m0\e[0m)((\e\
    [36mmax_nesting_level\e[0m, \e[36mlevel\e[0m) => max_nesting_level + level * max_nesting_level)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                                                ^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                    Found:    (max_nesting_level\
    \ : Long)\n\e[31m   |\e[0m                                    Required: Int\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpf0xon022.scala:20:51\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mmax_nesting_level\e\
    [0m = getMaxNestingLevel(nesting, \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m       \
    \                                            ^^^^^^^\e[0m\n\e[31m   |\e[0m   \
    \                             Found:    (nesting : Seq[Array[String]])\n\e[31m\
    \   |\e[0m                                Required: collection.mutable.Seq[String]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpf0xon022.scala:21:35\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mif\e[0m (max_nesting_level\
    \ > \e[31m1\e[0m) nesting \e[33melse\e[0m Seq.empty\n\e[31m\e[31m   |\e[0m   \
    \                                ^^^^^^^\e[0m\n\e[31m   |\e[0m               \
    \                 Found:    (nesting : Seq[Array[String]])\n\e[31m   |\e[0m  \
    \                              Required: List[Long]\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpf0xon022.scala:21:48 --------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mif\e[0m (max_nesting_level > \e[31m1\e\
    [0m) nesting \e[33melse\e[0m Seq.empty\n\e[31m\e[31m   |\e[0m                \
    \                                ^^^^^^^^^\e[0m\n\e[31m   |\e[0m           "
  stdout: ''
  timestamp: 1660029306
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_array_string = paren_string.split(\" \").filter(_.nonEmpty).toArray\n\
    \        var paren_array_depth = 0\n        var paren_level = 0\n        var paren_level_list\
    \ = []\n        paren_array_string.foreach(elem => {\n            if((elem.toDouble\
    \ > 0).isOdd)\n            {\n                paren_array_depth = paren_array_depth\
    \ + 1\n            }\n            else\n            {\n                paren_array_depth\
    \ = paren_array_depth - 1\n            }\n            if(paren_array_depth <=\
    \ 0)\n            {\n                paren_level_list.clear()\n              \
    \  paren_array_depth = 0\n            }\n            if(paren_array_depth <= 0)\n\
    \            {\n                paren_level_list.append(paren_level)\n       \
    \         paren_level = 0\n            }\n            paren_level = paren_level\
    \ + 1\n            paren_level_list.append(paren_level)\n        })\n        return\
    \ paren_level_list.toList\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpa_pwfcs5.scala:13:32 ---------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        \e[33mvar\e[0m \e[36mparen_level_list\e[0m =\
    \ []\n\e[31m\e[31m   |\e[0m                                ^\e[0m\n\e[31m   |\e\
    [0m                                an identifier expected, but ']' found\n\e[31m\e\
    [31m-- [E040] Syntax Error: /tmp/tmpa_pwfcs5.scala:14:0 ----------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        paren_array_string.foreach(\e[36melem\e[0m =>\
    \ {\n\e[31m\e[31m   |\e[0m^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m'=>' expected,\
    \ but 'end of statement' found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpa_pwfcs5.scala:15:35\
    \ ------------------------\e[0m\e[0m\n\e[31m15 |\e[0m            \e[33mif\e[0m((elem.toDouble\
    \ > \e[31m0\e[0m).isOdd)\n\e[31m\e[31m   |\e[0m               ^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m               value isOdd is not a member of Boolean\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpa_pwfcs5.scala:25:33 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m                paren_level_list.clear()\n\e[31m\e[31m\
    \   |\e[0m                ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue clear\
    \ is not a member of Null, but could be made available as an extension method.\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might fix the problem:\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.buffer\
    \ AsJavaList\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.properties\
    \ AsScalaMap\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.list\
    \ asScalaBuffer\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.map\
    \ AsJavaConcurrentMap\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.map\
    \ AsScalaConcurrentMap\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.mutableSet\
    \ AsJavaSet\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.set\
    \ asScala\n\e[31m   |\e[0m  import collection.convert.ImplicitConversionsToJava.buffer\
    \ AsJavaList\n\e[31m   |\e[0m  import collection.convert.ImplicitConversionsToJava.map\
    \ AsJavaConcurrentMap\n\e[31m   |\e[0m  import coll"
  stdout: ''
  timestamp: 1660029309
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val levels : Map[String, Int] = paren_string.trim.split(\"\\\\W+\"\
    )\n        levels.map(l => (l.head.length, l.length.toLong)).toMap.toList.sortBy(-_._1)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpp5sq7hxh.scala:10:63\
    \ --------------------\e[0m\e[0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e[36mlevels\e\
    [0m : \e[35mMap\e[0m[\e[35mString\e[0m, \e[35mInt\e[0m] = paren_string.trim.split(\e\
    [31m\"\\\\W+\"\e[0m)\n\e[31m\e[31m   |\e[0m                                  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                 \
    \          Found:    Array[String]\n\e[31m   |\e[0m                          \
    \ Required: collection.mutable.Map[String, Int]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpp5sq7hxh.scala:11:42 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        levels.map(\e[36ml\e[0m => (l.head.length, l.length.toLong)).toMap.toList.sortBy(-_._1)\n\
    \e[31m\e[31m   |\e[0m                                        ^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                           value length is not a member of (String,\
    \ Int)\n2 errors found\n"
  stdout: ''
  timestamp: 1660029306
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val result = new mutable.ListBuffer[Long]()\n        paren_string.split(\"\
    \\\\s+\").foreach { elem =>\n            val depth = elem.lastIndexOf(\"(\") -\
    \ elem.lastIndexOf(\")\")\n            result.add(depth)\n        }\n        result.sortWith(_\
    \ < (0l, _))\n        result.reverse.drop(1).reverse.toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"\
    () (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpc4d_gvpu.scala:10:25 ------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m             \
    \            ^^^^^^^\e[0m\n\e[31m   |\e[0m                         Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660029299
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        def countNestings(paren_string: String, counter:mutable.Set[Long]):Long\
    \ = {\n            val level = 0\n            val char_count = paren_string.filterNot(paren_string\
    \ => paren_string == \"(\").length\n            val last_char = paren_string(paren_string.length-1)\n\
    \            val open_paren_count = paren_string.filterNot(paren_string => paren_string\
    \ == \"(\").length\n\n            val new_counter = mutable.Set(0l)\n        \
    \    val new_counter2 = mutable.Set(0l)\n\n            if(char_count == 0 && open_paren_count\
    \ == 0) counter(0)\n            else if(open_paren_count == 0) counter(level+1)\n\
    \            else if(char_count == 0) counter(level)\n            else if(open_paren_count\
    \ == 0) {\n                if(last_char == \"(\" || last_char == \")\") counter(level+1)\n\
    \                else counter(level)\n            }\n            else counter(level+1)\n\
    \        }\n\n        val counter = mutable.Set(0l)\n\n        var last_level\
    \ = 0\n        var i = 0\n        while(i < paren_string.length) {\n         \
    \   if(paren_string(i) == \"(\") {\n                last_level = countNestings(paren_string,\
    \ counter)\n                i -= 1\n            }\n            else {\n      \
    \          val new_counter = mutable.Set(0l)\n                val new_counter2\
    \ = mutable.Set(0l)\n                if(counter.contains(last_level)) counter.remove(last_level)\n\
    \                countNestings(paren_string, new_counter)\n                last_level\
    \ = new_counter\n                countNestings(paren_string, new_counter2)\n \
    \               last_level = new_counter\n                i = paren_string.length\n\
    \                if(counter.contains(last_level)) counter.remove(last_level)\n\
    \            }\n            i += 1\n        }\n\n        counter.toList\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()())\
    \ ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpriezfrrb.scala:10:56 ------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m        \e[33mdef\e[0m \e[36mcountNestings\e[0m(\e[36mparen_string\e\
    [0m: \e[35mString\e[0m, \e[36mcounter\e[0m:mutable.Set[\e[35mLong\e[0m]):\e[35mLong\e\
    [0m = {\n\e[31m\e[31m   |\e[0m                                               \
    \         ^^^^^^^\e[0m\n\e[31m   |\e[0m                                      \
    \                Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- Error: /tmp/tmpriezfrrb.scala:12:68\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m12 |\e[0m       \
    \     \e[33mval\e[0m \e[36mchar_count\e[0m = paren_string.filterNot(\e[36mparen_string\e\
    [0m => paren_string == \e[31m\"(\"\e[0m).length\n\e[31m\e[31m   |\e[0m       \
    \                                                             ^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Values of types Char and String cannot be compared\
    \ with == or !=\n\e[31m\e[31m-- Error: /tmp/tmpriezfrrb.scala:14:74 -----------------------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m            \e[33mval\e[0m \e[36mopen_paren_count\e[0m\
    \ = paren_string.filterNot(\e[36mparen_string\e[0m => paren_string == \e[31m\"\
    (\"\e[0m).length\n\e[31m\e[31m   |\e[0m                                      \
    \                                    ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \        Values of types Char and String cannot be compared with == or !=\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpriezfrrb.scala:16:30 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m            \e[33mval\e[0m \e[36mnew_counter\e[0m = mutable.Set(\e\
    [31m0l\e[0m)\n\e[31m\e[31m   |\e[0m                              ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                              Not found: mutable\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpriezfrrb.scala:17:31 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m            \e[33mval\e[0m \e[36mnew_counter2\e[0m =\
    \ mutable.Set(\e[31m0l\e[0m)\n\e[31m\e[31m   |\e[0m                          \
    \     ^^^^^^^"
  stdout: ''
  timestamp: 1660029310
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        var paren_count = paren_string.length\n        var paren_level =\
    \ 1\n\n        var nested_list: List[Long] = Nil\n\n        for (i <- 1 to paren_count)\
    \ {\n            val ch1 = paren_string(i).asInstanceOf[Char]\n            var\
    \ level = 1\n            var j = i\n            while (j > 0) {\n            \
    \    val ch2 = paren_string(j).asInstanceOf[Char]\n                if (ch1 !=\
    \ ch2) {\n                    level -= 1\n                }\n                j\
    \ -= 1\n            }\n            nested_list ::= level.toLong\n        }\n \
    \       nested_list\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.StringIndexOutOfBoundsException: String index out of range: 27\n\
    \tat java.base/java.lang.StringLatin1.charAt(StringLatin1.java:48)\n\tat java.base/java.lang.String.charAt(String.java:1515)\n\
    \tat scala.collection.StringOps$.apply$extension(StringOps.scala:185)\n\tat Problem$.parseNestedParens$$anonfun$1(tmpg5am3mxv.scala:16)\n\
    \tat scala.runtime.java8.JFunction1$mcVI$sp.apply(JFunction1$mcVI$sp.scala:18)\n\
    \tat scala.collection.immutable.Range.foreach(Range.scala:190)\n\tat Problem$.parseNestedParens(tmpg5am3mxv.scala:27)\n\
    \tat Problem$.main(tmpg5am3mxv.scala:31)\n\tat Problem.main(tmpg5am3mxv.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660029311
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        def recurse(paren_string : String) : List[Long] = {\n           \
    \ val stack = new mutable.Stack[Long]()\n            for (c <- paren_string) {\n\
    \                val next_c = if (c == '(') '(' else ')'\n                if (c\
    \ == next_c) {\n                    stack push c\n                } else if (c\
    \ == ')') {\n                    while (!stack.last.isEmpty) {\n             \
    \           val top = stack.pop()\n                        if (stack.isEmpty)\
    \ {\n                            stack push top\n                            return\
    \ stack\n                        }\n                    }\n                } else\
    \ if (c == ' ') {\n                    stack push -1\n                }\n    \
    \        }\n            return stack.toList\n        }\n        return recurse(paren_string).toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpz9m09ny9.scala:11:28 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m            \e[33mval\e[0m \e[36mstack\e[0m = \e[33mnew\e\
    [0m mutable.Stack[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                  \
    \          ^^^^^^^\e[0m\n\e[31m   |\e[0m                            Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660029304
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        var level = 0\n        paren_string.foreach { c =>\n            if\
    \ (c == '(') level += 1\n            if (c == ')') level -= 1\n        }\n   \
    \     if (level < 0) level = 0\n        val result = new mutable.MutableList[Long]()\n\
    \        result.push(level)\n        while (level >= 0) {\n            val new_level\
    \ = level - 1\n            result.push(new_level)\n            level -= 1\n  \
    \      }\n        return result.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp_gxps4jt.scala:16:25 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m mutable.MutableList[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m            \
    \             ^^^^^^^\e[0m\n\e[31m   |\e[0m                         Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660029306
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        var level = 0\n        var levelCount = 0\n        var stack = mutable.Stack[Int]()\n\
    \        for (i <- paren_string) {\n            level += 1\n            if ((i\
    \ == ')') && (levelCount == 0)) levelCount += 1\n            else if ((i == ')')\
    \ && (levelCount != 0)) levelCount -= 1\n            else stack.push(i)\n    \
    \    }\n        val nestedParens = stack.foldLeft(List[Long]()) { (a, e) =>\n\
    \            if (e == ')') a.toLong\n            else a.toLong :: parseNestedParens(e.toString.replaceFirst(\"\
    \\\\)\",\"\"))\n        }\n        return nestedParens.reverse\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((()))\
    \ () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpl13gp4nx.scala:12:20 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mvar\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660029305
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        // We use paren_string instead of parantheses because paren_string\
    \ is not actually a parenthesis.\n        val paren_string_list = paren_string.split(\"\
    \ \").filter(_.nonEmpty).toList\n        val parens_set = paren_string_list.toSet\n\
    \        var parens = 0\n        var max_nesting_level = paren_string_list.count(f\
    \ => parens_set.contains(f))\n        var current_level = max_nesting_level\n\
    \        while(parens < paren_string_list.length) {\n            var current_level\
    \ = max_nesting_level\n            val current_group = paren_string_list\n   \
    \         val current_level_index = current_group.indexOfFirst(f => parens_set.contains(f))\n\
    \            val current_group_list = current_group.toList.drop(current_level_index).take(current_group.size\
    \ - current_level_index)\n            val current_group_string = current_group_list.toString\
    \ // current_group_string will be a String()()\n            val current_group_size\
    \ = current_group.size\n            val current_group_set_size = current_group_list.size\
    \ // current_group_set_size will be a Long()()()\n            while(parens < current_group_size)\
    \ {\n                var current_level = max_nesting_level\n                var\
    \ current_group_size = current_group.size\n                val current_group_list\
    \ = current_group.toList.drop(current_level_index).take(current_group_size - current_level_index)\n\
    \                val current_group_string = current_group_list.toString // current_group_string\
    \ will be a String()()\n                val current_group_size = current_group.size\n\
    \                val current_group_set_size = current_group_list.size // current_group_set_size\
    \ will be a Long()()()\n                while(parens < current_group_set_size)\
    \ {\n                    var current_level = max_nesting_level\n             \
    \       var current_group_size = current_group.size\n                    val current_group_list\
    \ = current_group.toList.drop(current_level_index).take(current_group_size - current_level_index)\n\
    \                    val current_group_string = current_group_list.toString //\
    \ current_group_string will be a String()()\n                    val current_group_size\
    \ = current_group.size\n                    val current_group_set_size = current_group_list.size\
    \ // current_group_set_size will be a Long()()()\n                    while(parens\
    \ < current_group_set_size) {\n                        var current_level = max_nesting_level\n\
    \                        var current_group_size = current_group.size\n       \
    \                 val current_group_list = current_group.toList.drop(current_level_index).take(current_group_size\
    \ - current_level_index)\n                        val current_group_string = current_group_list.toString\
    \ // current_group_string will be a String()()\n                        val current_group_size\
    \ = current_group.size\n                        val current_group_set_size = current_group_list.size\
    \ // current_group_set_size will be a Long()()()\n                        while(parens\
    \ < current_group_set_size) {\n                            var current_\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()())\
    \ ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmphm7yutvp.scala:47:4 ----------------------------\e\
    [0m\e[0m\n\e[31m47 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmphm7yutvp.scala:55:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m55 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmphm7yutvp.scala:19:52 ------------------------\e[0m\e[0m\n\
    \e[31m19 |\e[0m            \e[33mval\e[0m \e[36mcurrent_level_index\e[0m = current_group.indexOfFirst(\e\
    [36mf\e[0m => parens_set.contains(f))\n\e[31m\e[31m   |\e[0m                 \
    \                     ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m       \
    \               value indexOfFirst is not a member of List[String]\n\e[31m\e[31m--\
    \ [E161] Naming Error: /tmp/tmphm7yutvp.scala:29:20 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m                \e[33mval\e[0m \e[36mcurrent_group_size\e\
    [0m = current_group.size\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mcurrent_group_size is already defined as \e[33mvariable\e\
    [0m \e[35mcurrent_group_size\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmphm7yutvp.scala:36:24 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m                    \e[33mval\e[0m \e[36mcurrent_group_size\e\
    [0m = current_group.size\n\e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mcurrent_group_size is already defined as \e[33mvariable\e\
    [0m \e[35mcurrent_group_size\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmphm7yutvp.scala:43:28 ---------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m                        \e[33mval\e[0m \e[36mcurrent_group_size\e\
    [0m = current_group.size\n\e[31m\e[31m   |\e[0m                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    ["
  stdout: ''
  timestamp: 1660029311
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val num_levels\
    \ = paren_groups.size\n        val max_levels = 2\n        val levels = mutable.ListBuffer.empty[Long]\n\
    \        var i = 0\n        while(i < paren_groups.length) {\n            val\
    \ groups = paren_groups(i).split(\",\")\n            while(i < groups.length)\
    \ {\n                val level = groups.count(f => f == \"(\")\n             \
    \   if(level >= max_levels) {\n                    levels += level.toLong\n  \
    \              }\n                i += level + 1\n            }\n            i\
    \ += 1\n        }\n        levels.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp2o94ul9c.scala:13:21 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mlevels\e[0m = mutable.ListBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660029307
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_array = paren_string.split(\" \");\n        val max_levels\
    \ = paren_array.map{\n            s => parseNestedParens(s)\n        }.foldLeft(0l)\
    \ {\n            (max, list) =>\n                if (list.size > max) list.size\
    \ else max\n        }\n\n        max_levels.toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"\
    () (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpt3_z453n.scala:18:19 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        max_levels.toList\n\e[31m\e[31m   |\e[0m    \
    \    ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m   value toList is not a member of\
    \ Long - did you mean max_levels.toInt?\n1 error found\n"
  stdout: ''
  timestamp: 1660029312
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        var paren_count = 0\n        val nesting_levels = mutable.ListBuffer.empty[Long]\n\
    \        var paren_count : Long = 0\n        var depth : Long = 0\n        for\
    \ (c <- paren_string.toList) {\n            if (c == '(') {\n                paren_count\
    \ += 1\n                nesting_levels += paren_count\n            } else if (c\
    \ == ')') {\n                paren_count -= 1\n                if (paren_count\
    \ == 0) {\n                    depth += 1\n                    nesting_levels\
    \ += paren_count\n                }\n            } else {\n                paren_count\
    \ = 0\n                depth += 1\n                nesting_levels += paren_count\n\
    \            }\n        }\n        val max_level = nesting_levels.max\n      \
    \  nesting_levels.toList.drop(max_level + 1).reverse\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"\
    () (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpmkkwglpq.scala:12:12 ---------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mvar\e[0m \e[36mparen_count\e[0m : \e[35mLong\e\
    [0m = \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mparen_count is already defined as \e[33mvariable\e[0m \e[35mparen_count\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E006] Not\
    \ Found Error: /tmp/tmpmkkwglpq.scala:11:29 ------------------------\e[0m\e[0m\n\
    \e[31m11 |\e[0m        \e[33mval\e[0m \e[36mnesting_levels\e[0m = mutable.ListBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                             ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                             Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660029310
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        var max_level = Long.MaxValue\n        var stack = mutable.Stack[String]()\n\
    \        var paren_group_level = Long.MaxValue\n        for (paren \u2190 paren_string.split('\
    \ ') ; paren != \"\") {\n            if (paren.length < 2) {\n               \
    \ continue\n            }\n            paren = paren.trim\n            if (paren.length\
    \ == 1) {\n                if (paren_group_level < max_level) {\n            \
    \        max_level = paren_group_level\n                }\n                paren_group_level\
    \ = Long.MaxValue\n                stack = mutable.Stack[String]()\n         \
    \       stack.toList.reverse.foreach(s \u21D2 paren_group_level = math.max(paren_group_level,\
    \ s.length))\n            } else {\n                paren.drop(1).dropRight(1).foreach\
    \ { s \u21D2\n                    val level = (paren.length - s.length)\n    \
    \                val length = s.length\n                    paren_group_level\
    \ = math.max(paren_group_level, length)\n                    if (level > max_level)\
    \ {\n                        max_level = level\n                    }\n      \
    \              stack :+= s\n                }\n            }\n        }\n    \
    \    stack.toList.reverse.foreach(s \u21D2 max_level = math.max(max_level, s.length))\n\
    \        val result = List(max_level.toLong)\n        return result.toList\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpys81o6fa.scala:13:58 ---------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        \e[33mfor\e[0m (paren \u2190 paren_string.split(\e\
    [31m' '\e[0m) ; paren != \e[31m\"\"\e[0m) {\n\e[31m\e[31m   |\e[0m           \
    \                                               ^\e[0m\n\e[31m   |\e[0m      \
    \                                      '<-' expected, but ')' found\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpys81o6fa.scala:11:20 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mvar\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\nthere were\
    \ 8 deprecation warnings; re-run with -deprecation for details\n1 warning found\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660029311
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        paren_string.split(\" \").toList.flatMap {\n            if (paren_string\
    \ contains \"(\") {\n                parseNestedParens(paren_string.replaceAll(\"\
    \\(\", \"\")) \n            } else if (paren_string contains \"(\") {\n      \
    \          parseNestedParens(paren_string.replaceAll(\"\\)\", \"\"))\n       \
    \     } else {\n                List(1L)\n            }\n        }\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((()))\
    \ () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmptg64igxv.scala:12:60 -----------------------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m                parseNestedParens(paren_string.replaceAll(\e\
    [31m\"\\(\"\e[0m, \e[31m\"\"\e[0m)) \n\e[31m\e[31m   |\e[0m                  \
    \                                          ^\e[0m\n\e[31m   |\e[0m           \
    \                                     invalid escape character\n\e[31m\e[31m--\
    \ Error: /tmp/tmptg64igxv.scala:14:60 -----------------------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m                parseNestedParens(paren_string.replaceAll(\e\
    [31m\"\\)\"\e[0m, \e[31m\"\"\e[0m))\n\e[31m\e[31m   |\e[0m                   \
    \                                         ^\e[0m\n\e[31m   |\e[0m            \
    \                                    invalid escape character\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmptg64igxv.scala:16:20 --------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m                List(\e[31m1L\e[0m)\n\e[31m\e[31m   |\e\
    [0m                ^^^^^^^^\e[0m\n\e[31m   |\e[0m                Found:    List[Long]\n\
    \e[31m   |\e[0m                Required: String => IterableOnce[Long]\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1660029315
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val parentheses_array = paren_string.split(\" \").toArray\n     \
    \   val result_list: List[Long] = Nil\n        parentheses_array.foreach(elem\
    \ => {\n            if(elem.startsWith(\"(\") && elem.endsWith(\")\")) {\n   \
    \             result_list ::= List(1l.toLong)\n            } else {\n        \
    \        result_list ::= List(elem.toLong)\n            }\n        })\n      \
    \  result_list\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp0w0sxyvs.scala:14:28 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m                result_list ::= List(\e[31m1l\e[0m.toLong)\n\
    \e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  value\
    \ ::= is not a member of List[Long] - did you mean result_list.::?\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmp0w0sxyvs.scala:16:28 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m                result_list ::= List(elem.toLong)\n\e\
    [31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  value\
    \ ::= is not a member of List[Long] - did you mean result_list.::?\n2 errors found\n"
  stdout: ''
  timestamp: 1660029317
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        // If paren_string is a number, return List(paren_string.toLong)\n\
    \        if(paren_string.isDigit) List(paren_string.toLong)\n        else if(paren_string.matches(\"\
    ^\\\\s*\\\\(.+?\\\\)\\\\s*$\")) {\n            // Find the deepest level of paren_string\
    \ using stack\n            // If the level of parentheses are less than the current\
    \ level, we have found our level of nesting\n            val stack = new mutable.Stack[Int]()\n\
    \            val levelOfNesting = paren_string.size // paren_string has leading\
    \ space\n            for(i <- 1 to levelOfNesting) {\n                stack +=\
    \ i\n            }\n            val deepestParenLevel = stack.head\n\n       \
    \     // If paren_string is of length levelOfNesting then return List(deepestParenLevel.toLong)\n\
    \            if(deepestParenLevel == levelOfNesting) {\n                List(deepestParenLevel.toLong)\n\
    \            }\n\n            else {\n                // If the level of parentheses\
    \ are greater than current level, remove one from stack\n                while(stack.length()\
    \ > levelOfNesting) {\n                    stack = stack.pop()\n             \
    \   }\n                // Add the next level of parentheses to stack and add it\
    \ to the return List\n                stack += levelOfNesting\n              \
    \  val currentLevelOfNesting = stack.head\n                List(currentLevelOfNesting.toLong)\n\
    \            }\n        }\n        else {\n            // If paren_string doesn't\
    \ match any of our criteria, return an empty List\n            List[Long]()\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpil0owtlr.scala:11:24 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mif\e[0m(paren_string.isDigit) List(paren_string.toLong)\n\
    \e[31m\e[31m   |\e[0m           ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m   \
    \        value isDigit is not a member of String\n\e[31m\e[31m-- [E006] Not Found\
    \ Error: /tmp/tmpil0owtlr.scala:15:28 ------------------------\e[0m\e[0m\n\e[31m15\
    \ |\e[0m            \e[33mval\e[0m \e[36mstack\e[0m = \e[33mnew\e[0m mutable.Stack[\e\
    [35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m                            ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                            Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E052] Type Error: /tmp/tmpil0owtlr.scala:30:26 -----------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m                    stack = stack.pop()\n\e[31m\e[31m\
    \   |\e[0m                    ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \              Reassignment to val stack\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660029315
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val stack = new mutable.Stack[Char]\n        val groups = paren_string.split(\"\
    \ \").map(x => x).toList\n        val output = new mutable.ListBuffer[Long]()\n\
    \        for (charToPush \u2190 groups) {\n            val popped = stack.pop()\n\
    \            val newOutput = if (charToPush == '(') 1 else 0\n            if (charToPush\
    \ == ')') {\n                if (popped == '(')\n                    output.append(output.lastOption.getOrElse(0)\
    \ + newOutput)\n                else\n                    output.append(newOutput)\n\
    \            } else {\n                stack += charToPush\n                output.append(newOutput)\n\
    \            }\n        }\n        output.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpbkiyvl94.scala:10:24 ------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = \e[33mnew\e\
    [0m mutable.Stack[\e[35mChar\e[0m]\n\e[31m\e[31m   |\e[0m                    \
    \    ^^^^^^^\e[0m\n\e[31m   |\e[0m                        Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpbkiyvl94.scala:12:25\
    \ ------------------------\e[0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e\
    [36moutput\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e\
    [31m   |\e[0m                         ^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \               Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- Error: /tmp/tmpbkiyvl94.scala:15:32\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m15 |\e[0m       \
    \     \e[33mval\e[0m \e[36mnewOutput\e[0m = \e[33mif\e[0m (charToPush == \e[31m'('\e\
    [0m) \e[31m1\e[0m \e[33melse\e[0m \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m        \
    \                        ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Values\
    \ of types String and Char cannot be compared with == or !=\n\e[31m\e[31m-- Error:\
    \ /tmp/tmpbkiyvl94.scala:16:16 -----------------------------------------\e[0m\e\
    [0m\n\e[31m16 |\e[0m            \e[33mif\e[0m (charToPush == \e[31m')'\e[0m) {\n\
    \e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \       Values of types String and Char cannot be compared with == or !=\nthere\
    \ were 3 deprecation warnings; re-run with -deprecation for details\n1 warning\
    \ found\n4 errors found\n"
  stdout: ''
  timestamp: 1660029318
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        // Use a mutable data structure to track the level of nesting for\
    \ each opening parentheses\n        val levels : mutable.HashMap[Char, Int] =\
    \ mutable.HashMap()\n        val parens : mutable.HashSet[Char] = mutable.HashSet()\n\
    \        val nested_levels : mutable.Map[Char, Int] = mutable.HashMap()\n\n  \
    \      // Iterate over the string\n        paren_string.foreach{ ch =>\n     \
    \       // We only care about opening parentheses\n            if(levels.getOrElse(ch)\
    \ == null) {\n                // Add the level\n                levels(ch) = 0\n\
    \            }\n            levels(ch) += 1\n        }\n        // Traverse the\
    \ string\n        paren_string.foreach{ ch =>\n            // We only care about\
    \ closing parentheses\n            if(levels.getOrElse(ch) == null) {\n      \
    \          // Add the level\n                levels(ch) = 0\n            }\n \
    \           levels(ch) -= 1\n        }\n\n        // Traverse the string\n   \
    \     paren_string.foreach{ ch =>\n            if(levels.getOrElse(ch) == 0) {\n\
    \                parens.add(ch)\n            }\n        }\n\n        // Reverse\
    \ the string so we traverse it in reverse order\n        parens.reverse.foreach{\
    \ ch => nested_levels(ch) += 1}\n\n        val depths = mutable.ListBuffer[Int]()\n\
    \        parens.foreach{ ch => depths.append(nested_levels(ch))}\n\n        //\
    \ Find the deepest level of nesting for the whole string\n        val max_depth\
    \ = depths.max\n\n        // Sort the depths\n        depths.sortBy(_.reverse).reverse\n\
    \n        // Iterate over the sorted depths and output the deepest level group\
    \ of parentheses\n        depths.foreach{ depth => if (depth ==0) paren_string\
    \ else paren_string.drop(max_depth-depth)}\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpvetj9sz_.scala:11:21 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mlevels\e[0m : mutable.HashMap[\e\
    [35mChar\e[0m, \e[35mInt\e[0m] = mutable.HashMap()\n\e[31m\e[31m   |\e[0m    \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpvetj9sz_.scala:11:50\
    \ ------------------------\e[0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e\
    [36mlevels\e[0m : mutable.HashMap[\e[35mChar\e[0m, \e[35mInt\e[0m] = mutable.HashMap()\n\
    \e[31m\e[31m   |\e[0m                                                  ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                                  Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpvetj9sz_.scala:12:21\
    \ ------------------------\e[0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e\
    [36mparens\e[0m : mutable.HashSet[\e[35mChar\e[0m] = mutable.HashSet()\n\e[31m\e\
    [31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m              \
    \       Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpvetj9sz_.scala:12:45 ------------------------\e[0m\e[0m\n\e[31m12 |\e\
    [0m        \e[33mval\e[0m \e[36mparens\e[0m : mutable.HashSet[\e[35mChar\e[0m]\
    \ = mutable.HashSet()\n\e[31m\e[31m   |\e[0m                                 \
    \            ^^^^^^^\e[0m\n\e[31m   |\e[0m                                   \
    \          Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpvetj9sz_.scala:13:28 ------------------------\e[0m\e[0m\n\e[31m13 |\e\
    [0m        \e[33mval\e[0m \e[36mnested_levels\e[0m : mutable.Map[\e[35mChar\e\
    [0m, \e[35mInt\e[0m] = mutable.HashMap()\n\e[31m\e[31m   |\e[0m              \
    \              ^^^^^^^\e[0m\n\e[31m   |\e[0m                            Not found:\
    \ mutable\n\e"
  stdout: ''
  timestamp: 1660029314
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        var groups: List[List[String]] = Nil\n        for (group <- paren_string.split(\"\
    \ \")) {\n            // remove all leading and trailing parenthesis\n       \
    \     val temp = group.stripLeft(\"(\").stripRight(\")\")\n            // add\
    \ this group to the list if it's not empty and it's not the last one\n       \
    \     if (temp.length > 0 && groups.last == \"\" ) {\n                groups =\
    \ groups ::: List(temp)\n            } else {\n                groups = groups\
    \ ::: List(temp)\n            }\n        }\n        // for each group of nested\
    \ parentheses, find the deepest level of nesting\n        var level = 0\n    \
    \    var group_index = 0\n        for (group <- groups) {\n            // find\
    \ the number of opening parenthesis\n            val opening_paren = group.count(ch\
    \ => ch == \"(\")\n            if (opening_paren > level) {\n                level\
    \ = opening_paren\n                group_index = groups.indexOf(group)\n     \
    \       }\n        }\n        // return the deepest level of nesting\n       \
    \ groups.drop(group_index).take(level).map(_.toLong).sorted\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"\
    () (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmptcdp3jkh.scala:13:29 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m            \e[33mval\e[0m \e[36mtemp\e[0m = group.stripLeft(\e\
    [31m\"(\"\e[0m).stripRight(\e[31m\")\"\e[0m)\n\e[31m\e[31m   |\e[0m          \
    \             ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                       value\
    \ stripLeft is not a member of String\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmptcdp3jkh.scala:33:51 ------------------------\e[0m\e[0m\n\e[31m33 |\e\
    [0m        groups.drop(group_index).take(level).map(_.toLong).sorted\n\e[31m\e\
    [31m   |\e[0m                                                 ^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mvalue toLong is not a member of List[String], but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e\
    [0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import\
    \ math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e[31m-- Error:\
    \ /tmp/tmptcdp3jkh.scala:33:65 -----------------------------------------\e[0m\e\
    [0m\n\e[31m33 |\e[0m        groups.drop(group_index).take(level).map(_.toLong).sorted\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \         ^\e[0m\n\e[31m   |\e[0mambiguous given instances: both \e[33mobject\e\
    [0m \e[35mByte\e[0m in \e[33mobject\e[0m \e[35mOrdering\e[0m and \e[33mobject\e\
    [0m \e[35mChar\e[0m in \e[33mobject\e[0m \e[35mOrdering\e[0m match type Ordering[B]\
    \ of parameter ord of \e[33mmethod\e[0m \e[35msorted\e[0m in \e[33mtrait\e[0m\
    \ \e[35mStrictOptimizedSeqOps\e[0m\n3 errors found\n"
  stdout: ''
  timestamp: 1660029319
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        // For each group, find the depth of the group and store in map\n\
    \        var depths = mutable.Map[Int, Int]()\n        var depth = 1\n       \
    \ paren_string.split(\"( )\").toList foreach { p =>\n            depth += 1\n\
    \            // If not existing, add a new entry to map\n            depths +=\
    \ depth -> depth\n        }\n        // Find max depth\n        var max_depth\
    \ = depths.values.max\n        // Create empty list of list\n        var nested_list\
    \ : List[List[Long]] = Nil\n        depths.keys foreach { d =>\n            if\
    \ (d <= max_depth)\n                nested_list ::= (paren_string.split(s\"( )\"\
    ).toList filterNot { ps => ps.toString.trim.nonEmpty }).take(depths(d).toInt).toList\n\
    \        }\n        return nested_list\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp96h28h8h.scala:11:21 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mvar\e[0m \e[36mdepths\e[0m = mutable.Map[\e\
    [35mInt\e[0m, \e[35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp96h28h8h.scala:26:15 --------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mreturn\e[0m nested_list\n\e[31m\e[31m \
    \  |\e[0m               ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m               Found:\
    \    (nested_list : List[List[Long]])\n\e[31m   |\e[0m               Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660029320
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        // Keep track of the nesting depth\n        var nested_depth = 0\n\
    \        // The deepest level of nesting encountered.\n        var max_nested_depth\
    \ = Long.MaxValue\n        // The current stack depth of parentheses encountered.\n\
    \        var current_nested_depth = Long.MaxValue\n        // The parenthesis\
    \ stack\n        var parentheses_stack: List[(Long, Long, Long)] = Nil\n     \
    \   parentheses_stack = parentheses_stack + parseParenthesisStack(paren_string)\n\
    \        // Record the level of nesting that is encountered\n        var max_nested_depth\
    \ = 0\n        for (nested_depth <- parentheses_stack.reverse) {\n           \
    \ if (nested_depth._3 > max_nested_depth) {\n                max_nested_depth\
    \ = nested_depth._3\n            }\n        }\n        // The deepest level found\n\
    \        return max_nested_depth.toLong\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpmw908v2d.scala:20:12 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mvar\e[0m \e[36mmax_nested_depth\e[0m =\
    \ \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mmax_nested_depth is already defined as \e[33mvariable\e[0m \e[35mmax_nested_depth\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmpmw908v2d.scala:18:46 ------------------------\e[0m\e[0m\n\
    \e[31m18 |\e[0m        parentheses_stack = parentheses_stack + parseParenthesisStack(paren_string)\n\
    \e[31m\e[31m   |\e[0m                            ^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mvalue + is not a member of List[(Long, Long, Long)], but could be\
    \ made available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne\
    \ of the following imports might make progress towards fixing the problem:\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpmw908v2d.scala:18:48 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        parentheses_stack = parentheses_stack + parseParenthesisStack(paren_string)\n\
    \e[31m\e[31m   |\e[0m                                                ^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                        Not found: parseParenthesisStack\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpmw908v2d.scala:27:32\
    \ --------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mreturn\e[0m max_nested_depth.toLong\n\
    \e[31m\e[31m   |\e[0m               ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m               Found:    Long\n\e[31m   |\e[0m               Required: \e[1m\e\
    [32mList\e[0m\e[1m\e[32m[\e[0mLong\e[1m\e[32m]\e[0m\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain"
  stdout: ''
  timestamp: 1660029321
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        paren_string.splitIterator.map(paren => {\n            var level\
    \ = paren.indexOf('(')\n            if(level < 0) {\n                level = 0\n\
    \            }\n            val level_string = paren.substring(0,level).trim()\n\
    \            if(level_string == \"\") {\n                level_string = \"0\"\n\
    \            }\n            val levelLong = level_string.toLong\n            if(level\
    \ > 0) {\n                val levelString = paren.substring(level).trim()\n  \
    \              if(levelString == \"\") {\n                    levelString = \"\
    0\"\n                }\n                val levelLongString = levelString.toLong\n\
    \                if(levelLongString > levelLong) {\n                    level\
    \ = levelLongString\n                }\n            }\n            val result\
    \ = mutable.ListBuffer(levelLong.toString)\n            var nextLevel = level\n\
    \            while(nextLevel > 0) {\n                val nextLevelString = paren.substring(nextLevel).trim()\n\
    \                if(nextLevelString == \"\") {\n                    nextLevelString\
    \ = \"0\"\n                }\n                val nextLevelLong = nextLevelString.toLong\n\
    \                result.add(nextLevelLong.toString)\n                nextLevel\
    \ = nextLevelLong\n            }\n            List(levelLong.toLong + 1 -> result)\n\
    \        }).flatMap(_.toList).toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpyydpip1_.scala:10:21 ------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m        paren_string.splitIterator.map(\e[36mparen\e\
    [0m => {\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m        value splitIterator is not a member of String\n1 error found\n"
  stdout: ''
  timestamp: 1660029319
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_char = \"()\".toList\n        var max_level = 0\n     \
    \   val paren_groups = paren_string.split(\" \").filter(_ != \"\").map(paren_char\
    \ ::: _)\n        val paren_levels = paren_groups.map(paren => paren.foldLeft(0)((max:\
    \ Long, char: Char) => {\n            if (char == paren_char) max + 1\n      \
    \      else max\n        }))\n        paren_levels.foldLeft(0)((max: Long, level:\
    \ Long) => {\n            if (level > max_level) max_level = level\n        })\
    \ + 1 // for the last group\n        paren_levels.map(level => paren_groups.map(level\
    \ ::: _)).flatten.toList\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpj8aaop4r.scala:12:82 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mparen_groups\e[0m = paren_string.split(\e\
    [31m\" \"\e[0m).filter(_ != \e[31m\"\"\e[0m).map(paren_char ::: _)\n\e[31m\e[31m\
    \   |\e[0m                                                                   \
    \               ^^^^^\e[0m\n\e[31m   |\e[0m                                  \
    \   value ::: is not a member of String\n\e[31m\e[31m-- Error: /tmp/tmpj8aaop4r.scala:12:88\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m12 |\e[0m       \
    \ \e[33mval\e[0m \e[36mparen_groups\e[0m = paren_string.split(\e[31m\" \"\e[0m).filter(_\
    \ != \e[31m\"\"\e[0m).map(paren_char ::: _)\n\e[31m\e[31m   |\e[0m           \
    \                                                                            \
    \ ^\e[0m\n\e[31m   |\e[0m                                          No ClassTag\
    \ available for B\n\e[31m   |\e[0m\n\e[31m   |\e[0m                          \
    \                where:    B is a type variable\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpj8aaop4r.scala:18:47 --------------------\e[0m\e[0m\n\e[31m18\
    \ |\e[0m            \e[33mif\e[0m (level > max_level) max_level = level\n\e[31m\e\
    [31m   |\e[0m                                               ^^^^^\e[0m\n\e[31m\
    \   |\e[0m                                               Found:    (level : Long)\n\
    \e[31m   |\e[0m                                               Required: Int\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660029321
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        var count : Long = 0\n        var nesting : Long = 0\n        paren_string.split(\"\
    \ \").toList.foreach(s => {\n            if (s.equals(\"(\")) {\n            \
    \    nesting++\n            } else if (s.equals(\")\")) {\n                nesting--\n\
    \            }\n            if (nesting == 0) count++\n        })\n        List(count.toLong)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp81zlaxwx.scala:14:25 ---------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m                nesting++\n\e[31m\e[31m   |\e[0m    \
    \                     ^\e[0m\n\e[31m   |\e[0m                         expression\
    \ expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmp81zlaxwx.scala:16:25 ---------------------------\e[0m\e[0m\n\e[31m16\
    \ |\e[0m                nesting--\n\e[31m\e[31m   |\e[0m                     \
    \    ^\e[0m\n\e[31m   |\e[0m                         expression expected but \e\
    [31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp81zlaxwx.scala:18:37\
    \ ---------------------------\e[0m\e[0m\n\e[31m18 |\e[0m            \e[33mif\e\
    [0m (nesting == \e[31m0\e[0m) count++\n\e[31m\e[31m   |\e[0m                 \
    \                    ^\e[0m\n\e[31m   |\e[0m                                 \
    \    expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660029318
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        var level : Int = 0\n        var open_paren = 0\n        val paren_stack\
    \ = new Stack[Int]\n\n        paren_string.split(\"\\\\s+\").foreach(x => {\n\
    \            if (open_paren == 0) {\n                paren_stack.push(level)\n\
    \                if (x == \"(\")\n                    open_paren++\n         \
    \       else\n                    open_paren--\n            } else if (open_paren\
    \ > 0 && x == \"(\")\n                level++\n            else if (open_paren\
    \ > 0 && x == \")\")\n                level--\n            else if (open_paren\
    \ > 0 && x == \")\") {\n                if (level > 0)\n                    level--\n\
    \                else\n                    level++\n                open_paren--\n\
    \            }\n        })\n\n        paren_stack.size match {\n            case\
    \ 0 => Nil\n            case _ => paren_stack.toList\n        }\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((()))\
    \ () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp0d7jjpgn.scala:18:32 ---------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m                    open_paren++\n\e[31m\e[31m   |\e\
    [0m                                ^\e[0m\n\e[31m   |\e[0m                   \
    \             expression expected but \e[31munindent\e[0m found\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp0d7jjpgn.scala:20:32 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m                    open_paren--\n\e[31m\e[31m   |\e\
    [0m                                ^\e[0m\n\e[31m   |\e[0m                   \
    \             expression expected but \e[31munindent\e[0m found\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp0d7jjpgn.scala:22:23 ---------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m                level++\n\e[31m\e[31m   |\e[0m      \
    \                 ^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31munindent\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmp0d7jjpgn.scala:24:23 ---------------------------\e[0m\e[0m\n\e[31m24\
    \ |\e[0m                level--\n\e[31m\e[31m   |\e[0m                       ^\e\
    [0m\n\e[31m   |\e[0m                       expression expected but \e[31munindent\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp0d7jjpgn.scala:27:27\
    \ ---------------------------\e[0m\e[0m\n\e[31m27 |\e[0m                    level--\n\
    \e[31m\e[31m   |\e[0m                           ^\e[0m\n\e[31m   |\e[0m      \
    \                     expression expected but \e[31munindent\e[0m found\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp0d7jjpgn.scala:29:27 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m                    level++\n\e[31m\e[31m   |\e[0m  \
    \                         ^\e[0m\n\e[31m   |\e[0m   "
  stdout: ''
  timestamp: 1660029321
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        // We need a stack to keep the count of parantheses.\n        var\
    \ par_count = 0\n        var stack = mutable.Stack[String]()\n        // Iterate\
    \ through all the characters of paren_string\n        for (c <- paren_string.toCharArray)\
    \ {\n            par_count = par_count\n            stack += c\n        }\n  \
    \      \n        // Now we need to add the count of parantheses to keep track\
    \ of levels of nesting in the paren_string\n        var max_count = 0\n      \
    \  // Go through the stack and find the level of nesting by comparing each character\
    \ with the current highest count character\n        for (c <- stack) {\n     \
    \       if (par_count > max_count) {\n                max_count = par_count\n\
    \            }\n            par_count = par_count - 1\n        }\n        \n \
    \       \n        // Finally add the count of parantheses to calculate the final\
    \ output\n        return max_count :: par_count\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp0g71gbui.scala:12:20 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mvar\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp0g71gbui.scala:31:25 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mreturn\e[0m max_count :: par_count\n\e\
    [31m\e[31m   |\e[0m                         ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                         value :: is not a member of Int\n2 errors found\n"
  stdout: ''
  timestamp: 1660029321
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        var nesting_level : Long = 0\n        var max_level_of_nesting :\
    \ Long = 0\n        var stack : List[Long] = Nil\n        for (c <- paren_string.charAt(0))\
    \ {\n            if (c == ')') {\n                stack.reverse.tail.foreach(x\
    \ => {\n                    nesting_level -= 1\n                    max_level_of_nesting\
    \ = Math.max(nesting_level, max_level_of_nesting)\n                })\n      \
    \          nesting_level += 1\n                if (nesting_level > max_level_of_nesting)\
    \ {\n                    max_level_of_nesting = nesting_level\n              \
    \  }\n                stack.reverse.tail.foreach(x => {\n                    nesting_level\
    \ -= 1\n                    max_level_of_nesting = Math.max(nesting_level, max_level_of_nesting)\n\
    \                })\n                stack.reverse.foreach(x => {\n          \
    \          nesting_level -= 1\n                    max_level_of_nesting = Math.max(nesting_level,\
    \ max_level_of_nesting)\n                })\n            } else {\n          \
    \      stack += c.toLong\n            }\n        }\n        stack.reverse.tail.foreach(x\
    \ => {\n            nesting_level -= 1\n            max_level_of_nesting = Math.max(nesting_level,\
    \ max_level_of_nesting)\n        })\n        max_level_of_nesting\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((()))\
    \ () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpk3xua_0a.scala:13:18 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        \e[33mfor\e[0m (c <- paren_string.charAt(\e[31m0\e\
    [0m)) {\n\e[31m\e[31m   |\e[0m                  ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                  value foreach is not a member of Char\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpk3xua_0a.scala:39:8 ---------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m        max_level_of_nesting\n\e[31m\e[31m   |\e[0m \
    \       ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    (max_level_of_nesting\
    \ : Long)\n\e[31m   |\e[0m        Required: List[Long]\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660029322
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_list : List[String] = paren_string.split(\" \").filter(_\
    \ != \"\").toList\n        var max_level : Long = 0\n        var current_level\
    \ = 0\n\n        for (i <- 0 until paren_list.length) {\n            if (paren_list(i)\
    \ == \"(\") {\n                current_level += 1\n            } else if (paren_list(i)\
    \ == \")\") {\n                current_level -= 1\n            }\n           \
    \ if (current_level > max_level) {\n                max_level = current_level\n\
    \            }\n        }\n        val max_level_list = List(1l.toLong, 3l.toLong,\
    \ 1l.toLong, 3l.toLong).take(max_level).toList\n        return max_level_list\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmplrq2yuo1.scala:24:83\
    \ --------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mmax_level_list\e\
    [0m = List(\e[31m1l\e[0m.toLong, \e[31m3l\e[0m.toLong, \e[31m1l\e[0m.toLong, \e\
    [31m3l\e[0m.toLong).take(max_level).toList\n\e[31m\e[31m   |\e[0m            \
    \                                                                       ^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                            Found:    (max_level\
    \ : Long)\n\e[31m   |\e[0m                                            Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660029322
