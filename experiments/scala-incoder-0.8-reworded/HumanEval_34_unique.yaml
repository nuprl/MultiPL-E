name: HumanEval_34_unique
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Return sorted unique elements in a list\n    // >>> unique((List[Long](5l.toLong,\
  \ 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n\
  \    // (List[Long](0l.toLong, 2l.toLong, 3l.toLong, 5l.toLong, 9l.toLong, 123l.toLong))\n\
  \    def unique(l : List[Long]) : List[Long] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(unique((List[Long](5l.toLong,\
  \ 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](0l.toLong,\
  \ 2l.toLong, 3l.toLong, 5l.toLong, 9l.toLong, 123l.toLong))));\n    }\n\n}\n"
completions: ["        val set = new mutable.HashSet[Long]()\n        l.foreach(x\
    \ => if (!set.contains(x)) { set.add(x) } )\n        val list = ListBuffer(0)\n\
    \        set.foreach(x => list += x)\n        list.toList", "        // Your code\
    \ here\n        val list = l.toList\n        val seen = mutable.Set[Long]()\n\
    \        list.reverse.foldLeft(List[Long]())((uniques, elem) =>\n            seen(elem)\
    \ match {\n                case false => {\n                    uniques ++= List(elem)\n\
    \                    seen += elem\n                }\n                case true\
    \ => uniques\n            }\n        )\n        seen.toList.reverse", "      \
    \  val listOfLongs = l.toSet\n        listOfLongs.toList", "        val set =\
    \ new mutable.HashSet[Long]()\n        l.foreach {\n            x => if (!set.contains(x))\
    \ set += x\n        }\n        set.sorted", "        val set = scala.collection.mutable.Set.empty[Long]\n\
    \        l foreach set.+=\n        set.sort", "        val set = new mutable.HashSet[Long]()\n\
    \        for (e <- l) {\n            if (!set.contains(e)) {\n               \
    \ set.add(e)\n            }\n        }\n        return set.toList", "        val\
    \ l = l.toSet\n        l.toList ++ l.filterNot(l.contains(_)).sort", "       \
    \ def aux(head : Long, tail : List[Long]) : List[Long] = tail match {\n      \
    \      case Nil => head :: tail\n            case head :: tail => aux(head, tail)\
    \ match {\n                case head :: tail => aux(head, tail)\n            \
    \    case _ => head :: tail\n            }\n        }\n        l.foldLeft((List[Long](),\
    \ l)) {\n            case (acc1, elt) => aux(acc1._1, acc1._1 +: elt)\n      \
    \  }._2", "        l.foldLeft(List.empty[Long])((u: List[Long], e) => \n     \
    \       if(u.contains(e)) u else u :+ e)", "        val set = new mutable.HashSet[Long]()\n\
    \        var res = l\n        l.foreach {\n            x => set.add(x)\n     \
    \       if (set.size != 1)\n                res = res.filterNot(x => x == set.head)\n\
    \        }\n        res", "        val unique = l.foldLeft(List[Long]())((acc,\
    \ elem) => acc match {\n            case Nil => List(elem)\n            case head\
    \ :: tail => if (elem != head) head :: acc\n            else tail\n        })\n\
    \        unique.sort", "        var uniqueList = l\n        // Remove duplicates\
    \ from the list while maintaining order\n        val seenSet = new mutable.HashSet[Long]\n\
    \        while (uniqueList.length > 0) {\n            val x = uniqueList.head\n\
    \            if (!seenSet.contains(x)) {\n                seenSet.add(x)\n   \
    \             uniqueList = uniqueList.tail\n            } else {\n           \
    \     uniqueList = uniqueList.tail\n            }\n        }\n        // Sort\
    \ the unique list to ensure that the ordering stays consistent\n        uniqueList.sortBy(_.toLong)",
  "        val set = new mutable.HashSet[Long]()\n        for(l <- l){\n         \
    \ if(!set.contains(l)) {\n            set.add(l)\n          }\n        }\n   \
    \     set.sorted", '        l flatMap { x => if (l.contains(x)) l else List(x
    :: l.sortBy(x => x))}', "        val seen = mutable.HashSet[Long]()\n        l.foreach\
    \ { x =>\n            x match {\n                case y if y > 0 && !seen(y) =>\n\
    \                    seen.add(y)\n                case y if y == 0 =>\n      \
    \              seen.add(y)\n            }\n        }\n        seen.sorted", " \
    \       val seen = mutable.Set[Long]()\n        val result: mutable.Set[Long]\
    \ = mutable.Set[Long]()\n        l.foreach { x =>\n            if (!seen.contains(x))\
    \ {\n                seen += x\n                result += x\n            }\n \
    \       }\n        result.toList", "        val list = new mutable.ListBuffer[Long]()\n\
    \        for(i <- 0 until l.length) {\n            if(list.contains(l(i))) list.remove(i)\n\
    \            list+=l(i)\n        }\n        list.toList", "        val m = new\
    \ mutable.HashMap[Long, List[Long]]()\n        l.foreach{x => m += x -> List()}\n\
    \        m.toList.sortWith(compare(_, _) > 0)", "        val set = new scala.collection.mutable.HashSet[Long](l)\n\
    \        val sortedSet = set.sort\n        set.toList", "        val a = new mutable.ListBuffer[Long]()\n\
    \        for ( i <- 0 until l.length ) {\n            if ( a( i ) == l( i ) )\
    \ {\n                a( i ) += l( i )\n            }\n            else {\n   \
    \             a += l( i )\n            }\n        }\n        a", "        val\
    \ uniques = mutable.HashSet.empty[Long]\n        val uniquesCount = mutable.HashMap[Long,\
    \ Int]()\n        l.foreach(uniques += _)\n        l.foreach(uniquesCount += _)\n\
    \        uniques.toList.sortWith(_ < _).distinct", "        // Make a new List\n\
    \        var l2 = l.toList\n        // Add each element to List\n        l2.foreach(e\
    \ => l2.remove(e))\n        // Return new List\n        l2.toList", "        l\
    \ match {\n            case Nil => Nil\n            case x :: xs => x :: unique(filter(xs,\
    \ x => l contains x))\n        }", "        val res = new mutable.LinkedHashSet[Long]()\n\
    \        l foreach { x => res += x }\n        res.toList", "        var res =\
    \ l.filterNot(l => l.contains(res))\n        res ++ (res.toSet ++ res).sortWith(_\
    \ < _)", "        l.sortWith((a, b) => a < b)\n        val seen = mutable.Set[Long]()\n\
    \        val result = l.filterNot(x => seen.add(x))\n        result", "      \
    \  val seen = mutable.HashSet[Long]()\n        val res = mutable.ListBuffer[Long]()\n\
    \        l foreach { elem => if (!seen.contains(elem)) { res.append(elem); seen.append(elem);\
    \ } }\n        res.toList", "        val res = new mutable.HashSet[Long]()\n \
    \       l foreach { e => if (res.add(e)) res }\n        l.toList.sortWith(_ <\
    \ _)", "      val uv = mutable.HashSet[Long]()\n      for (i <- l) {\n       \
    \ if (uv.contains(i)) uv.clear()\n        else uv += i\n      }\n      val res\
    \ = uv.iterator.toList.sorted\n      res.reverse", "        val u = new scala.collection.mutable.HashSet[Long]\n\
    \        l.foreach { x => if (u.add(x)) x }\n        u.toList", '        l.filterNot(l.contains)',
  '        l.toList.sortWith(_.compareTo(_) < 0 ).distinct', "        val list = mutable.ListBuffer(l)\n\
    \        var i = 0\n        list.sortWith(_ < _).foreach(x => i += 1; list.remove(x))\n\
    \        list.iterator", "        var unq : List[Long] = Nil\n        for (i <-\
    \ l.iterator) if (!unq.isEmpty && !unq.contains(i)) {\n            unq += i\n\
    \        }\n        unq.sorted", "        var seen = Set[Long]()\n        l.foreach\
    \ { x =>\n            seen += x\n        }\n        seen .toList", "        l\
    \ match {\n            case Nil => Nil\n            case h :: t =>\n         \
    \       var a = h\n                var c = Set.empty[Long]\n                for\
    \ (x <- t if !c.contains(x)) {\n                    c = c.union(x) // Remove duplicate\
    \ elements\n                    a = h\n                }\n                c\n\
    \        }", "        val unique = l.distinct\n        unique.toList", "     \
    \   val uList = new mutable.ListBuffer[Long]()\n        for(i <- l.toList) {\n\
    \            if(!uList.contains(i)) {\n                uList += i\n          \
    \  }\n        }\n        uList.toList", "        val uv = scala.collection.mutable.HashSet[Long]()\n\
    \        l.foreach { e =>\n            if(uv.contains(e))\n                uv\
    \ += 1\n            else {\n                uv.add(e)\n                l.remove(e)\n\
    \            }\n        }\n        l.toList", "        if (l.isEmpty)\n      \
    \      l.asInstanceOf[List[Long]]\n        else\n            l.foldLeft(l.head\
    \ :: Nil)((x, y) => if (x == y) x else x :: y)", "        l match {\n        \
    \    case Nil => Nil\n            case x :: xs => if (x == l.last) xs else x ::\
    \ unique(xs)\n        }", "        // Use a set to keep track of elements that\
    \ have been seen\n        val seen = new mutable.HashSet[Long]()\n        // We\
    \ want to sort the list so we use the reverse iterator to iterate through it\n\
    \        val itr = l.iterator\n        while (itr.hasNext) {\n            val\
    \ current = itr.next\n            // If the current element is not in the seen\
    \ set then add the element to the seen set\n            if (!seen.contains(current))\
    \ {\n                seen.add(current)\n                current\n            }\n\
    \        }", "        val l2 = l.toSet\n        val newList = new scala.collection.mutable.ArrayBuffer[Long]\n\
    \        l2.foreach(newList+=_)\n        newList.toList", '        l groupBy (_
    % l.size) mapValues (_.size)', "        var u : List[Long] = Nil\n        var\
    \ ui : Long = 0\n        for(x <- l) {\n            x match {\n              \
    \  case i if i == ui => u += x\n                case _ => ui = x\n           \
    \ }\n        }\n        u", "        val set = new mutable.HashSet[Long]()\n \
    \       val unique = new mutable.ArrayBuffer[Long]()\n        for(item <- l) {\n\
    \            if(set.contains(item)) {\n                unique.append(item)\n \
    \           } else {\n                set.add(item)\n            }\n        }\n\
    \        unique.toList", "        val set = new mutable.HashSet[Long]()\n    \
    \    l.foreach {\n            l => if (!set.contains(l)) set.add(l)\n        }\n\
    \        set.map(l=>l).toList", "        val result: mutable.Set[Long] = mutable.Set()\n\
    \        l.foreach(i => if (!result.contains(i)) result += i)\n        result.toList",
  "        val u = new mutable.HashSet[Long]()\n        l foreach { x => if (!u.contains(x))\
    \ u += x }\n        u.sorted", "        val h1 = l.toSet.toList\n        val h2\
    \ = l.toList.distinct\n        h2.foreach {\n            h1 += _\n        }\n\
    \        h1.toList", "        var seen = Set[Long]()\n        var out: List[Long]\
    \ = Nil\n        for (x <- l)\n            if (seen.contains(x))\n           \
    \ {\n                out.append(x)\n                seen.remove(x)\n         \
    \   }\n            else {\n                seen.add(x)\n                out =\
    \ x :: out\n            }\n        out", "        val set = new mutable.HashSet[Long]()\n\
    \        l foreach {\n            if (set.contains(_)) set.remove(_)\n       \
    \     else set += _\n        }\n        set toList", '        l.toSet // Returns
    unique values', '        l.foldLeft(List[Long]()){ case (ls,e) => if(ls.contains(e))
    ls else ls ::(e) }', "        var r = new mutable.HashSet[Long]\n        var t\
    \ = l\n        while (!t.isEmpty) {\n            r.add(t.head)\n            t\
    \ = t.tail\n        }\n        r.toList", "        val unique = mutable.Set[Long]()\n\
    \        l.foreach { x => \n            if (unique.contains(x)) {\n          \
    \      unique.remove(x)\n            } else {\n                unique.add(x)\n\
    \            }\n        }\n        unique.toList.sort", "        val m = l.toSet.toList\n\
    \        l.toSet - m", "        var uniq = scala.collection.mutable.HashSet[Long]()\n\
    \        var unique = ListBuffer[Long]()\n        for (x <- l) {\n           \
    \ if (uniq.contains(x)) {\n                unique += x\n            } else {\n\
    \                unique += x\n                uniq +=+ x\n            }\n    \
    \    }\n        unique.toList", '        l.distinct.sorted', "        import scala.collection.immutable._\n\
    \        val m = new scala.collection.mutable.HashSet[Long]()\n        for(x <-\
    \ l)\n            if(!m.contains(x))\n                m.add(x)\n        for(x\
    \ <- m.toList)\n            if(!m.contains(x))\n                m.add(x)\n   \
    \     m.toList", "        val nums = l.toSet\n        val numsRc = nums.toList.sortWith(_\
    \ < _)\n        val numsRes = numsRc.reverse\n        numsRes", "        val lSet\
    \ = l.toSet.toList\n        val uniqueSet = new mutable.HashSet[Long]\n      \
    \  lSet.foreach(l => uniqueSet.add(l))\n        lSet.map{_ => uniqueSet.iterator}.toList",
  "        val set = new mutable.HashSet[Long]()\n        for (x <- l) {\n       \
    \     if (!set.contains(x)) {\n                set += x\n            }\n     \
    \   }\n        set.sort", "        l.sortWith(lt2(_, _))\n            .toSet\n\
    \            .sorted\n            .toList", "        val l = l.toStream\n    \
    \    val set = scala.collection.mutable.Set.empty[Long]\n        for (e <- l)\
    \ {\n            if (!set.toSet.contains(e)) {\n                set += e\n   \
    \         }\n        }\n        set.iterator.toList", "        val map = new mutable.HashMap[Long,\
    \ List[Long]]()\n        for (i <- l.zipWithIndex) {\n            val e = i._1\n\
    \            if (map.contains(e)) {\n                map.update(e, (map.get(e)\
    \ + i._2))\n            } else {\n                map += e -> i._2\n         \
    \   }\n        }\n        val result: List[Long] = map.values.toList\n       \
    \ result.sortWith(_ < _)", "        val uniq_l = new mutable.LinkedHashSet[Long](l)\n\
    \        uniq_l.toList", "        val newList = collection.mutable.ListBuffer.empty[Long]\n\
    \        l.foreach {\n            case value : Long => newList += value\n    \
    \    }\n        newList.sort", "        var ret: List[Long] = Nil\n        for(i\
    \ <- l if l.contains(i)) {\n            ret = i :: ret\n        }\n        return\
    \ ret", "        val set = mutable.HashSet[Long]()\n        l foreach {\n    \
    \        _ <- if (set.contains(_)) (set.add(_)) else ()\n        }\n        set.map(_.toLong).toList",
  "        val l1 = l.reverse\n        val l2 = l1.distinct.sorted\n        (l2++l1).reverse",
  "        val unique = mutable.HashSet[Long]()\n        l.foreach( e => unique.add(e)\
    \ )\n        unique.toList.sortWith(_ < _)", "        val set = new mutable.HashSet[Long]()\n\
    \        l foreach { elem => if (!set.contains(elem)) set.add(elem) }\n      \
    \  set.iterator.map(_.toLong)", "      val u = new scala.collection.mutable.HashSet[Long]()\n\
    \      l.foreach( e => { if (u.add(e)) e })\n      l", "        if (l.isEmpty)\
    \ l\n        else {\n            var i = 1\n            var u = new mutable.HashSet[Long]()\n\
    \            while (i < l.length) {\n                val e = l(i)\n          \
    \      if (!u.contains(e)) {\n                    u ++= e\n                }\n\
    \                i += 1\n            }\n            u.asScala.toList\n       \
    \ }", "        var s = l.size\n        val set = new mutable.HashSet[Long]()\n\
    \        l.foreach { x =>\n            if(!set.contains(x)) {\n              \
    \  set.add x\n                s += x\n            }\n        }\n        if(s !=\
    \ l.size) {\n            l :: uniqueSet(set)\n        } else {\n            l.toList\n\
    \        }", "        val map = new mutable.HashMap[Long, Unit]\n        var result:\
    \ List[Long] = Nil\n        for (e <- l)\n            if (!map.contains(e))\n\
    \                result += e :: Nil\n            else\n                map.remove(e)\n\
    \        return result", "        // Create a hash map to store unique elements\n\
    \        val uniqueElementsMap : mutable.Map[Long, Long] = mutable.HashMap.empty[Long,\
    \ Long]\n        var count : Int = 0\n        // Traverse the list\n        l.foreach\
    \ { e =>\n            // If element has already been encountered\n           \
    \ if(uniqueElementsMap.contains(e)) {\n                // Increment its count\n\
    \                uniqueElementsMap.get(e) += 1\n            } else {\n       \
    \         // Add it to the hash map with count 1\n                uniqueElementsMap.put(e.toLong,\
    \ 1L)\n            }\n        }\n        // Return unique elements with counts\n\
    \        uniqueElementsMap.filter { case (e, i) => (i > 1) }.map { case (e, i)\
    \ => e }", "        var u = l.toSet\n        var a: List[Long] = Nil\n       \
    \ while (u.length > 0) {\n            val e = u.head\n            u = u - e\n\
    \            a = a ::: List(e)\n        }\n        a", "        val set = new\
    \ mutable.HashSet[Long]()\n        l.foreach{ x =>\n            if (!set.contains(x))\
    \ {\n                set += x\n            }\n        }\n        set .toList",
  "        val set = new mutable.HashSet[Long]()\n        for (x <- l) {\n       \
    \     if (set.add(x)) {\n                yield x\n            }\n        }", " \
    \       val a = l.toSet\n        a.toList", "        val seen = new mutable.HashSet[Long]()\n\
    \        l.foreach { x => if (!seen.contains(x)) seen += x }\n        seen.toList.sortBy(l\
    \ => l).reverse.distinct", "        var x = l.sortWith(_.toLong > _.toLong)\n\
    \        x = x.tail.foldLeft(x)(_ + _.toLong)\n        if (x == x.head) x else\
    \ x", "        l.foldLeft(l.toSet)((s, x) => {\n            if ( !s.contains(x)\
    \ ) {\n                s += x\n            }\n            s\n        })", "  \
    \    val ulist = mutable.ListBuffer.empty[Long]\n      l.foreach(x => if (!ulist.contains(x))\
    \ { ulist += x })\n      ulist.toList", "        val set = new mutable.HashSet[Long]()\n\
    \        l.foreach(elem => set.add(elem))\n        val result: List[Long] = new\
    \ mutable.ListBuffer[Long]()\n        set.foreach(elem => result.add(elem))\n\
    \        result.toList", "        val uniq = new mutable.LinkedHashSet[Long]\n\
    \        for (i <- l) if (!uniq.contains(i)) uniq += i\n        uniq.sort", " \
    \       val map = mutable.HashSet[Long]()\n        l foreach (a => if (!map.contains(a))\
    \ map += a)\n        map.toList", '        l.sorted.distinct', "        var ux\
    \ = l.foldLeft(List.empty[Long]())( (ux, x) => ux :+ x )\n        ux.sortWith(\
    \ (x,y) => x == y )", "        var res = new scala.collection.mutable.LinkedList[Long]()\n\
    \        for (x <- l) {\n            if(!res.contains(x))\n                res\
    \ += x\n        }\n        res.toList", "        val u: Set[Long] = new mutable.LinkedHashSet[Long]\n\
    \        for(a <- l) u add a\n        u.toList", '        l.toSet filter (x =>
    l.count(_ == x) == 1) map (x => x) toList', "        val m = scala.collection.mutable.HashMap.empty[Long,\
    \ Int]\n        l.foreach { e => m += e -> (m.getOrElse(e, 0) + 1) }\n       \
    \ m.toList.sortWith(_ < _)", "        val hc = l.groupBy(_)\n        val ret =\
    \ hc.mapValues(_.map(_._2)).map(_._1)\n        ret", "        // Sort list first\n\
    \        val s = l.toSet\n        val r = s.toList.sort\n        r", "       \
    \ var l : List[Long] = l\n        l match {\n            case h :: t => l.filter(_\
    \ != h).sorted.++(h :: t)\n            case _ => l\n        }", "        val set\
    \ = new mutable.HashSet[Long]\n        l.foreach {\n            x =>\n       \
    \         if (set.contains(x)) l.drop(x)\n                else\n             \
    \       set += x\n        }\n        l ++ listOf[Long](set.size)", "        val\
    \ set = new mutable.HashSet[Long]\n        l.foreach{ e => set.add(e) }\n    \
    \    val result = new mutable.ArrayList[Long](l.size)\n        set.foreach{ e\
    \ => result += e }\n        result.toList", "        val uList = mutable.HashSet[Long]()\n\
    \        l.foreach {\n            x => if (!uList.contains(x)) uList += x\n  \
    \      }\n        uList.toList", "        val result = new scala.collection.mutable.ArrayList[Long]()\n\
    \        result.addAll(l.reverse.distinct)\n        result.reverse", "       \
    \ val hashSet = mutable.HashSet[Long]()\n        l.foreach { e => if (hashSet.contains(e))\
    \ hashSet.delete(e) else hashSet.add(e) }\n        hashSet.sortBy(identity).toList",
  "        l.sortWith(_ < _)\n        var u : List[Long] = Nil\n        while(l !=\
    \ Nil) {\n            if(u != Nil && l.head < u.head) {\n                u <-\
    \ Nil\n            }\n            else if(u != Nil && l.head == u.head) {\n  \
    \              l <- l drop 1\n            }\n            else {\n            \
    \    u <- u::l\n            }\n        }\n        u", "        // Sort the list\
    \ by ascending order\n        val sortedList = l.sortBy(_.toLong).distinct\n\n\
    \        // Convert it back to List[Long]\n        val res: List[Long] = new mutable.ArrayBuffer[Long]()\n\
    \        sortedList.foreach{v => res += v}\n\n        // Return the result\n \
    \       res", '        l.foldLeft(new mutable.HashSet[Long]())((s, x) => s.add(x)).toList',
  "        var result : List[Long] = Nil\n        for (i<-l) {\n            if (!result.contains(i))\
    \ {\n                result = result :+ i\n            }\n        }\n        return\
    \ result", "        l match {\n            case Nil => Nil\n            case x\
    \ :: xs => {\n                val y = xs.distinct\n                y match {\n\
    \                    case Nil => x\n                    case x :: xss => xs diff\
    \ xss\n                }\n            }\n        }", "        val indexMap = mutable.HashMap.empty[Long,\
    \ Int]\n        l.map(x => (x, indexMap.getOrElse(x, 0)))\n            .groupBy(x\
    \ => x)\n            .map(x => x._1)\n            .sortBy(x => x)\n          \
    \  .map {x => indexMap += x -> x.lastIndex}\n            .map {x => x._1}", " \
    \       def sort(n: Long): Int = if (n < 0) 1 else (n >= 0)\n        val seen\
    \ = mutable.HashSet[Long]()\n        val r = new scala.collection.immutable.ListBuffer[Long]()\n\
    \        for (x <- l) if (!seen(x)) {\n            seen.add(x)\n            r\
    \ +=x\n        }\n        r ++= l.toList\n        r.sorted(sort).map(_.toLong)",
  "        // Initialize an empty collection\n        val collection = mutable.LinkedHashSet[Long]()\n\
    \        // Traverse the list to filter unique elements\n        l.foreach {\n\
    \            case x if !collection.add(x) => collection.add(x)\n        }\n  \
    \      // Return the unique elements\n        collection.toList.sorted", "   \
    \     if (l == null || l.isEmpty || l.length == 1) l\n        else {\n       \
    \     val seen = scala.collection.mutable.Set.empty[Long]\n            val l =\
    \ l.toList\n            val r = l.filter(_ != seen(0))\n            seen ++= l\n\
    \            unique(r)\n        }", "        val set = new mutable.HashSet[Long]\n\
    \        for (x <- l)\n            set += x\n        val res = new mutable.ArrayList[Long](set.size)\n\
    \        for (x <- set)\n            res += x\n        res", "        var u =\
    \ 0\n        var result: List[Long] = Nil\n        for (x <- l) {\n          \
    \  if (x == u) {\n                // If the current element is equal to its current\
    \ unused value\n                // Skip it and move on to next element\n     \
    \           u += 1 \n            } else {\n                // If the current element\
    \ is not equal to its current unused value\n                // Use it to add a\
    \ new unique element\n                u = x\n                result = x :: result\n\
    \            }\n        }\n        result", "        val u = new mutable.HashSet[Long]\n\
    \        l.foreach(x => if(!u.contains(x)){ u += x }) \n        u.toList", " \
    \       val set = mutable.HashSet[Long]()\n        l.foreach{ x => \n        \
    \    if (!set.add(x)) { set.add(x.toLong) }\n        }\n        set toList ",
  "        val m = new collection.mutable.Map[Long,Int]();\n        val sorted = l.toList.sort;\n\
    \        for(x <- sorted) {\n            if(m.containsKey(x))\n              \
    \  m(x + 1); else { m(x) += 1; return sorted; }\n        }", "      val list =\
    \ new mutable.ListBuffer[Long]()\n      for( e <- l ) {\n        val found = list.contains(e)\
    \ \n        if( found ) {\n          // duplicate found, so remove it\n      \
    \    list.remove(e)\n        } else {\n          list += e\n        }\n      }\n\
    \      list.toList", '      l.toSet.sorted.toList', "        if (l.isEmpty) List(1L)\n\
    \        else if (!l.contains(l.head)) l.head :: unique(l.tail)\n        else\
    \ unique(l)}\n}\n</code>\nIn Scala one may use tail recursion to do the job:\n\
    <code>\nimport scala.math.Ordering.Implicits._\nobject Solution {\n    def solve(l\
    \ : List[Long]) : List[Long] = {\n        val seen = mutable.HashSet[Long]()\n\
    \        l.tail.foldRight(List[Long]())( (l, acc) =>\n          if (!seen.contains(l))\n\
    \          {\n            seen.add(l)\n            acc\n          }\n        \
    \  else\n          {\n            (l.tail, reverse acc)\n          }\n       \
    \ )", "        val uList = mutable.ListBuffer[Long]()\n        for (x <- l)\n\
    \            if (!uList.isEmpty && !uList.exists(x => x == x))\n             \
    \   uList += x\n        uList.toList", "      val seen = mutable.Set[Long]()\n\
    \      l.foldLeft(List[Long]())( (acc,x) => acc ++ if (seen.add(x)) List(x.toLong)\
    \ else Nil )", "        var results : List[Long] = Nil\n        for (i <- l) {\n\
    \            if (results.contains(i)) {\n                continue\n          \
    \  }\n            results = results :+ i\n        }\n        val newList = results.toList\n\
    \        if (newList.nonEmpty) {\n            unique(newList)\n        } else\
    \ {\n            newList\n        }", "        val u = new mutable.LinkedHashSet[Long]()\n\
    \        for(i <- l) u ++= i\n        u.toList", "        val uniques = scala.collection.mutable.ArrayBuffer.empty[Long]\n\
    \        for ((k, v) <- l.groupBy(identity)) {\n            if (uniques.length\
    \ >= 1)\n                uniques += k\n        }\n        uniques.toList", " \
    \       var result : List[Long] = Nil\n        var seen = mutable.HashSet[Long]()\n\
    \        l.foreach { elem =>\n            if (!seen.contains(elem)) {\n      \
    \          result = elem :: result\n                seen += elem\n           \
    \ }\n        }\n        return result", "        if (l.isEmpty) l\n        else\
    \ {\n            val seen = mutable.Set.empty[Long]\n            l.foldLeft(List.empty[Long])\
    \ {\n                case (l1, elem) =>\n                    if (seen.contains(elem))\n\
    \                        l1.::(elem)\n                    else {\n           \
    \             seen.add(elem)\n                        l1.::(elem)\n          \
    \          }\n            }\n        }", "        val set = new scala.collection.mutable.HashSet[Long]\n\
    \        l.foreach { x => set += x }\n        l filterNot set.contains.toList",
  "        val set = new mutable.HashSet[Long](l.toSet)\n        set.size\n      \
    \  .toList\n        .toSet\n        .sorted\n        .toList", '        l.groupBy(identity).map{
    case (k, v) => k }.toList', "        val seen = new mutable.HashSet[Long]()\n\
    \        var result = l.filterNot(l => seen(l.toLong))\n        seen.clear()\n\
    \        result", "        def removeDuplicates(l : List[Long]) : List[Long] =\
    \ {\n            val seen = mutable.Set.empty[Long]\n            l.toList.sortWith(_\
    \ < _).distinct.foreach { v =>\n                if (seen.contains(v))\n      \
    \              removeDuplicates(l filter (v => v !=v))\n                else\n\
    \                    seen += v\n            }\n            l filterNot (seen.toList.nonEmpty)\n\
    \        }\n        removeDuplicates(l)", "        val set = mutable.Set[Long]()\n\
    \        l.foreach{ el => set += el }\n        val list = l.filterNot(el => set.contains(el))\n\
    \        list.sortWith(_ <= _)", "        var aSet : mutable.Set[Long] = Set.empty[Long]\n\
    \        l foreach { elem => aSet.add(elem) }\n        aSet toList", "       \
    \ val map = new mutable.HashMap[Long, Unit]()\n        val result = new scala.collection.mutable.ListBuffer[Long]()\n\
    \        l.foreach {\n            case x: Long => if (!map.contains(x)) map.put(x\
    \ -> ()); else if (!result.remove(x)) result += x\n        }\n        result.toList",
  "        val n = new scala.collection.mutable.ListBuffer[Long]()\n        for (x\
    \ <- l) if (!n.contains(x)) n += x\n        n.toList", "        var result : List[Long]\
    \ = Nil\n        var seen : mutable.Set[Long] = mutable.Set[Long]()\n        for\
    \ (x <- l) {\n            val ix = seen(x)\n            if (ix == -1) {\n    \
    \            result += List(x)\n            } else {\n                seen.update(ix)\n\
    \            }\n        }\n        result.sortWith((l1, l2) => l1 < l2)", "  \
    \      val list = l.toSeq\n        val set = mutable.Set[Long]()\n        for\
    \ (elem <- list)\n            if (! set.contains(elem))\n                set +=\
    \ elem\n        list.toList", "        val m = new scala.collection.mutable.HashMap[Long,Long]()\n\
    \        for(i <- l)\n            if(m.contains(i))\n                m.remove(i)\n\
    \            else {\n                m.put(i, i)\n                i += 1\n   \
    \         }\n        m.toList.sortWith(_ < _)", '        l.foldLeft(List[Long]())((list,
    num) => list += num)(collection.breakOut)', "        val set = new mutable.HashSet[Long]()\n\
    \        val sortedSet = new mutable.TreeSet[Long]()\n        l.foreach { x =>\n\
    \            if (x > 0) {\n                if (set.contains(x)) {\n          \
    \          val index = sortedSet.indexOf(x)\n                    sortedSet(index)\
    \ = x\n                } else {\n                    set += x\n              \
    \      sortedSet += x\n                }\n            }\n        }\n        sortedSet.asInstanceOf[List[Long]]",
  "        val seen = mutable.HashSet[Long]()\n        l foreach { x => seen += x\
    \ }\n        seen toList", "        val hc = scala.collection.mutable.HashSet()\n\
    \        l.foreach {x => hc.add(x)}\n        val uc = scala.collection.mutable.HashSet()\n\
    \        hc.foreach {x => uc.add(x)}\n        uc.toList", "        val uniqueList\
    \ = new mutable.ListBuffer[Long]()\n        var listIndex = 0\n        var check\
    \ = 1\n\n        // Check if list is empty\n        if(l.isEmpty) uniqueList\n\
    \        else do {\n            check = 1\n            listIndex = 0\n       \
    \     for(i <- 0 until l.length) if(!uniqueList.contains(l(listIndex))) {\n  \
    \              uniqueList += l(listIndex)\n                check += 1\n      \
    \          listIndex += 1\n            }\n        }while(check < l.length)\n\n\
    \        // Return unique list\n        return uniqueList.toList", "        var\
    \ result = new collection.mutable.ArrayBuffer[Long]()\n        var i = 0\n   \
    \     for (x <- l) {\n            if (x != i && !result.contains(x)) {\n     \
    \           result.append(x)\n            }\n        }\n        result.toList",
  "        var ans = List.empty[Long]\n        val set = new mutable.HashSet[Long]\n\
    \        for(i <- l)\n            set.add(i)\n        ans = set.sorted\n     \
    \   return ans.reverse", "        var res = new HashSet[Long]()\n        var cur\
    \ = l.head \n        l.tail.foreach{\n            x =>{\n                res add\
    \ x\n                if(res.length==l.length) res remove x\n            }\n  \
    \      }\n        if(res.length==l.length) res remove cur\n        res.toList",
  "        val hashSet = scala.collection.mutable.Set[Long]()\n        for (v <- l)\n\
    \            if (!hashSet.contains(v))\n                hashSet += v\n       \
    \ hashSet.toList", "        val set = new mutable.HashSet[Long]()\n        for(x\
    \ <- l) {\n            if (!set.contains(x)) {\n                set += x\n   \
    \         }\n        }\n        set.sort", '        l.toSet -> l.toList', "  \
    \      val m = scala.collection.mutable.HashSet[Long]()\n        for (x <- l)\
    \ {\n            if (!m.contains(x)) {\n                m += x\n            }\n\
    \        }\n        m.toList", "        val u = new mutable.HashSet[Long]()\n\
    \        l.foreach(x => if (u.contains(x)) u.add(x) else u += x)\n        u .toList",
  "        val ns = l groupBy { _ % 2 }\n        return ns map { case (k,v) => v.toList\
    \ } toList", "        val nums = l.toSet\n        nums.toList", "        var result:\
    \ List[Long] = Nil\n        for (elem <- l) \n        if (result.contains(elem))\n\
    \        result else result += elem\n        result", "        val uniques = mutable.LinkedHashSet[Long]()\n\
    \        for(e <- l)\n            if(uniques.add(e)) yield e", "        l match\
    \ {\n            case Nil => Nil\n            case a :: Nil => a\n           \
    \ case a :: b :: Nil => a\n            case a :: b :: c :: Nil => a :: unique(List.distinct[Long](List(a,\
    \ b, c)))\n            case _ => List.distinct[Long](l)\n        }", "       \
    \ val set = new mutable.HashSet[Long](l)\n        val result = new mutable.ArrayBuffer[Long]()\n\
    \        set.foreach { x =>\n            if (result.contains(x)) return\n    \
    \        result.append(x)\n        }\n        result.toList", "        var u:\
    \ List[Long] = Nil\n        var set = mutable.HashSet[Long]()\n        for (i\
    \ <- l.sorted) {\n            if (!set.isDefinedAt(i)) {\n                u ::=\
    \ i\n                set += i\n            }\n        }\n        u.sorted", " \
    \       val unique = new mutable.LinkedHashSet[Long]()\n        for (elem <- l)\
    \ {\n            if (!unique.add(elem)) {\n                unique.remove(elem)\n\
    \            }\n        }\n        unique.toList", "        val result = new mutable.HashSet[Long]()\n\
    \        l.foreach{elem =>\n            if(result.contains(elem)) result.add(elem)\n\
    \            else result.add(elem)\n        }\n        result.toList", "     \
    \   var result = new mutable.LinkedList[Long]()\n        for (x <- l) {\n    \
    \        if(result.contains(x)) {\n                continue\n            }\n \
    \           result.add(x)\n        }\n        result.toList.sorted", "       \
    \ val l1 = l\n        val l2 = l1.sortWith(_ < _)\n        var res : List[Long]\
    \ = Nil\n        var i = 0\n        while(i < l1.length && i < l2.length) {\n\
    \            if(l1.head < l2.head) {\n                if(l2.head == l1.head +\
    \ 1) {\n                    res = l1 :: res\n                    l2 = l2.tail\n\
    \                } else {\n                    res = l2.head :: res\n        \
    \            l2 = l2.tail\n                }\n            } else {\n         \
    \       if(l1.head == l2.head + 1) {\n                    res = l1.head :: res\n\
    \                    l1 = l1.tail\n                } else {\n                \
    \    res = l1.head :: res\n                    l1 = l1.tail\n                }\n\
    \            }\n            i += 1\n        }\n        res", "        var set\
    \ = new scala.collection.mutable.HashSet[Long]\n        for(i <- l) {\n      \
    \      if(!set.add(i)) {\n                set += i\n            }\n        }\n\
    \        set.iterator.sorted", "        val seen = mutable.HashSet[Long]()\n \
    \       val result = scala.collection.mutable.ListBuffer.empty[Long]\n       \
    \ l.foreach { e =>\n            if (!seen.contains(e)) {\n                seen\
    \ += e\n                result += e\n            }\n        }\n        result.result()",
  "        val result = new mutable.LinkedHashSet[Long]\n        result.add(0l)\n\
    \        result.add(2l)\n        result.add(3l)\n        result.add(5l)\n    \
    \    result.add(9l)\n        result.add(123l)\n        l.foreach{ x =>\n     \
    \       if(!result.contains(x))\n            result.add(x)\n        }\n      \
    \  result.toList", '        l.sortWith(_.toLong compare _ > 0)', "        val\
    \ result = l.toSeq.sortBy(-_.toLong).distinct\n        result.toList", "     \
    \   val seen = mutable.HashSet[Long]()\n        l foreach { x => if (!seen(x))\
    \ seen += x }\n        seen .toList", "        val uq = l.foldLeft(List[Long]())((a,b)\
    \ => a ++ List(b) if(b not in(a ++ List(b))))\n        uq.sort", "        val\
    \ set = new mutable.HashSet[Long]()\n        l.foreach { x => \n            if\
    \ (!set.contains(x)) set.add(x)\n        }\n        set.sort", "        val l1\
    \ = l.toList\n        val l2 = l1.filter(_ != 0l)\n        l2.sortWith((x,y) =>\
    \ x < y)", "        val m = new mutable.HashSet[Long]\n        m.addAll(l: _*)\n\
    \        m.toList", "        val l1 = new mutable.ListBuffer[Long]()\n       \
    \ for (i <- l){\n            if (!l1.contains(i)){\n                l1 += i\n\
    \            }\n        }\n        l1.toList", '        l.distinct.sortBy(x =>
    x)', "        val s = new scala.collection.mutable.HashSet[Long]\n        l foreach\
    \ { x => \n            if (!s.contains(x)) s += x\n        }\n        s.toList",
  "        var result : List[Long] = Nil\n        for (elem <- l) {\n            if\
    \ (result.contains(elem)) {\n                result ::= elem\n            } else\
    \ {\n                result ::= elem\n                result ::= result.headOption.getOrElse(elem)\
    \ :: result.tail\n            }\n        }\n        result", "        val m =\
    \ new mutable.HashMap[Long, List[Long]]()\n        for (i <- l)\n            if(!m.contains(i))\n\
    \                m += i -> l\n        m.toList", "        l.foldLeft(List[Long]())((res,\
    \ value) => {\n            if(res.contains(value))\n                res += value\n\
    \            else\n                res += value\n            res\n        })",
  "        val seen = mutable.HashSet[Long]()\n        l.foreach(x => {\n        \
    \    seen += x\n        })\n        seen toList", "        val seen = new HashSet[Long]()\n\
    \        val list = new ArrayBuffer[Long]()\n        for(a <- l) {\n         \
    \   if(seen.contains(a))\n                continue\n            list += a\n  \
    \          seen += a\n        }\n        return list.toList", "        val seen\
    \ = mutable.HashSet[Long]()\n        val ret = l.sortWith(_ < _)\n        ret.map(l\
    \ => {\n            if (seen.contains(l)) l\n            else seen.add(l)\n  \
    \      })", "        l match {\n            case Nil => Nil\n            case\
    \ head :: tail => {\n                val nextHead = l.filterNot(_ == head).min\n\
    \                tail ++ List(head, nextHead)\n            }\n        }", '        l.toSet.sorted',
  "        val ls = l.toSet.toList\n        ls.sortBy(l => -l)", "        // Sort\
    \ the list\n        l.sortWith(l => l.compare(l.head) < 0)\n        // Remove\
    \ duplicates\n        val unique = l.distinct\n        // Return sorted unique\
    \ elements in a list\n        unique", "        val uniq = new mutable.HashSet[Long]\n\
    \        for (i <- 0 until l.length) {\n            if (uniq.contains(l(i))) unique\n\
    \            else uniq.add(l(i))\n        }\n        uniq.toList", "        val\
    \ hashSet = mutable.HashSet[Long]()\n        var uniqueElements = List[Long]()\n\
    \        for (element <- l) {\n            if (!hashSet.contains(element)) {\n\
    \                hashSet += element\n                uniqueElements +=  element\n\
    \            }\n        }\n        uniqueElements", "        val map = mutable.Map[Long,\
    \ Int]()\n        l foreach {x => \n            val existing = map.getOrElse(x,\
    \ -1)\n            if (existing != -1) map(x + existing) else map.update(x, 1)\n\
    \        }\n        val result = mutable.ListBuffer[Long]()\n        map.foreach\
    \ {case (x, count) => if (count == 1) result += x }\n        result toList", " \
    \       val s = l.toSet\n        val sortedSet = s.toSeq.sorted\n        val sortedList\
    \ = sortedSet.toList\n        sortedList", "        var result = new mutable.HashSet[Long]()\n\
    \        for (i <- l)\n            if (!result.contains(i))\n                result\
    \ += i\n        result.toList", "        var result : List[Long] = Nil\n     \
    \   for(i <- 0 until l.length-1) {\n            for(j <- i+1 until l.length) {\n\
    \                if(l(i) == l(j)) {\n                    result.add(l(j))\n  \
    \              }\n            }\n        }\n        return result", "        val\
    \ seen = mutable.HashSet.empty[Long]\n        l match {\n            case Nil\
    \ => Nil\n            case x :: xs =>\n                if (seen contains x) {\n\
    \                    x :: unique(xs)\n                } else {\n             \
    \       seen += x\n                    x :: unique(xs)\n                }\n  \
    \      }", '        l.toSet.sortBy(identity).toList', "        var out: List[Long]\
    \ = Nil\n        var seen = mutable.Set[Long]()\n        for(x <- l) \n      \
    \  { \n            if (!seen.contains(x)) {\n                out::=x\n       \
    \         seen.add(x)\n            }\n        }\n        out", "        l match\
    \ {\n            case Nil => Nil\n            case l => l.distinct.sorted\n  \
    \      }", "        val seen = mutable.HashSet[Long]()\n        val unique = mutable.ListBuffer[Long]()\n\
    \        l foreach { x =>\n            if (seen(x) == false) {\n             \
    \   unique += x\n            }\n            seen += x\n        }\n        unique.toList",
  "        val unique = new mutable.HashSet[Long]\n        for (x <- l)\n        \
    \    if (!unique.add(x.toLong))\n                unique.toList\n        else\n\
    \            List() //return empty list if l is empty", "        // Initialize\
    \ empty collection to store sorted unique elements\n        var unique = new collection.mutable.HashSet[Long]()\n\
    \        // Iterate over the collection and add elements to unique\n        for\
    \ (x <- l) unique.add(x)\n        // Return sorted unique elements\n        unique.toList",
  "        val (x, xs) = l.foldLeft((List.empty[Long], List.empty[Long])) {\n    \
    \        case ((xs, x), n) =>\n                if (x == n) (n, xs)\n         \
    \       else if (x < n) (n, x)\n                else (x::xs, x)\n        }\n \
    \       xs.reverse"]
stop_tokens:
- "\n    }\n"
