name: HumanEval_152_compare
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // I think we all remember that feeling when the result of some long-awaited\n\
  \    // event is finally known. The feelings and thoughts you have at that moment\
  \ are\n    // definitely worth noting down and comparing.\n    // Your task is to\
  \ determine if a person correctly guessed the results of a number of matches.\n\
  \    // You are given two lists of scores and guesses of equal length, where each\
  \ index shows a match. \n    // Return a list of the same length denoting how far\
  \ off each guess was. If they have guessed correctly,\n    // the value is 0, and\
  \ if not, the value is the absolute difference between the guess and the score.\n\
  \    // example:\n    // >>> compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
  \ 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
  \ 4l.toLong, 2l.toLong, -2l.toLong)))\n    // (List[Long](0l.toLong, 0l.toLong,\
  \ 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))\n    // >>> compare((List[Long](0l.toLong,\
  \ 5l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 4l.toLong)), (List[Long](4l.toLong,\
  \ 1l.toLong, 1l.toLong, 0l.toLong, 0l.toLong, -2l.toLong)))\n    // (List[Long](4l.toLong,\
  \ 4l.toLong, 1l.toLong, 0l.toLong, 0l.toLong, 6l.toLong))\n    def compare(game\
  \ : List[Long], guess : List[Long]) : List[Long] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong,\
  \ 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
  \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
  \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
  \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
  \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
  \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
  \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
completions: ["        var guessesCount : Int = 1\n        var result : List[Long]\
    \ = Nil\n        for (game <- game) {\n            if (game == guess(guessesCount))\
    \ {\n                result = result :+ 0\n            } else {\n            \
    \    val diff = abs(guess - game)\n                result = result :+ diff\n \
    \           }\n            guessesCount = guessesCount + 1\n        }\n      \
    \  result", "        var guesses = new mutable.HashSet[Long]()\n        var scores\
    \ = new mutable.HashMap[Long, Long]()\n\n        for (gen <- game) {\n       \
    \     if (guesses.contains(gen)) continue\n            var diff = 0\n        \
    \    for (guess <- guess) {\n                if (scores.contains(guess)) diff\
    \ = diff + abs(gen - scores.get(guess))\n                else scores.put(guess,\
    \ gen)\n                guesses.add(guess)\n            }\n            guesses.clear()\n\
    \            if (diff == 0) return (diff.toLong)\n            else  return (diff.toLong\
    \ - diff/guesses.size.toLong)\n        }", "        // your code here\n      \
    \  val guessed_correctly = game.zipWithIndex.map {\n            case (g,i) =>\
    \ if (g==guess) i else -1\n        }.maxBy(identity)\n        guessed_correctly.map(_-game)",
  "        val n = game.length\n        var miss = 0\n        var win =  0\n     \
    \   var guess = 0\n        var guesses = guess.map(x => Math.abs(x)).distinct\n\
    \        var scores = game.map(x => Math.abs(x)).distinct\n        var total =\
    \ 0\n        guesses.foreach { x =>\n            total += scores(x) + win + miss\n\
    \        }\n        val wrong = n - total\n        if (wrong >= guesses.length)\
    \ {\n            guesses.foreach { x =>\n                if (scores(x) != guess)\
    \ {\n                    miss += miss + 1\n                } else {\n        \
    \            win += win + 1\n                }\n            }\n        }\n   \
    \     guesses.map { x =>\n            if (scores(x) != guess) {\n            \
    \    miss += miss + 1\n            } else {\n                win += win + 1\n\
    \            }\n        }", "        if (game.size != guess.size) {\n        \
    \    List(\"Game and guess lists do not have the same length!\")\n        } else\
    \ {\n            val result = game.toList.zip(guess.toList).map {\n          \
    \      case (game : Long, guess : Long) => Math.abs(guess - game)\n          \
    \  }.toList\n            result\n        }", "        var diff = game diff guess\
    \ map abs\n        var list = game ++ guess\n        if (diff == game) list else\
    \ list", "        // First, sort the lists of scores and guesses into descending\
    \ order.\n        val scoresSorted = game.sortWith(_.compareTo(_) < 0)\n     \
    \   val guessesSorted = guess.sortWith(_.compareTo(_) < 0)\n\n        // Then\
    \ find the highest number of scores that matched.\n        val maxScore = scoresSorted.last\n\
    \        val maxGuess = guessesSorted.last\n        val bestScores: List[Long]\
    \ = new collection.mutable.ListBuffer[Long]()\n        val bestGuesses: List[Long]\
    \ = new collection.mutable.ListBuffer[Long]()\n\n        var foundMatch = false\n\
    \        for ((score: Long, guess: Long) <- scoresSorted zip guessesSorted) {\n\
    \            val delta = (guess - score).abs \n            if (foundMatch) {\n\
    \                // When a match was found, the difference between the first guess\
    \ and the best guess is incremented.\n                if (delta > bestGuesses.last)\
    \ {\n                    bestGuesses = bestGuesses :+ delta\n                }\n\
    \            } else {\n                // When a match was not found, the difference\
    \ between the first guess and the best guess is added.\n                if (delta\
    \ > bestScores.last) {\n                    bestScores  = bestScores :+ delta\n\
    \                }\n            }\n\n            // Every time a match was found,\
    \ if the best guesses were already filled, add the difference\n            //\
    \ between the current guess and the best guess to the best guesses.\n        \
    \    if (bestGuesses.last >= maxGuess) {\n                bestGuesses = bestGuesses\
    \ :+ maxGuess - (bestGuesses.last - maxGuess)\n            }\n\n            //\
    \ Every time a match was not found, add the difference between the current guess\
    \ and the best guess\n            // to the best scores.\n            if (bestScores.last\
    \ >= maxScore) {\n                bestScores  = bestScores :+ maxScore - (bestScores.last\
    \ - maxScore)\n            }\n        }\n\n        // The difference between the\
    \ first guess and the best guess is added to the best guesses.\n        if (bestGuesses.last\
    \ >= maxGuess) {\n            bestGuesses = bestGuesses :+ maxGuess - (bestGuesses.last\
    \ - maxGuess)\n        }\n\n        // The difference between the first guess\
    \ and the best guess is added to the best scores.\n        if (bestScores.last\
    \ >= maxScore) {\n            bestScores  = bestScores :+ maxScore - (bestScores.last\
    \ - maxScore)\n        }\n\n        // Finally, return a list of differences between\
    \ the best guesses and the best scores.\n        bestGuesses.zip(bestScores)",
  "        val n = game.length\n        val m = guess.length\n        if (m != n)\
    \ throw new IllegalArgumentException(\"The lists do not have the same lengths.\"\
    )\n        if (game.lastOption.isDefined) throw new IllegalArgumentException(\"\
    The last element of the game list may not be undefined.\")\n        if (guess.lastOption.isDefined)\
    \ throw new IllegalArgumentException(\"The last element of the guess list may\
    \ not be undefined.\")\n        val score = game.toStream\n            .zip(guess.toStream)\n\
    \            .map{ case ((g,g2), (h,h2)) => (g-h) }\n            .toList\n   \
    \         .reduce( (a,b) => if (a>b) a-b else b-a )\n            .map(abs => if\
    \ (abs == 0) 0 else abs)\n            .toList\n        score :+ game.last", " \
    \       var result: List[Long] = List[Long](0.0).toLong\n        var i = 0\n \
    \       game.foreach {\n            value =>\n            var j = 0\n        \
    \    guess.foreach {\n                g =>\n                val difference = abs(value\
    \ - g)\n                if (difference > result) {\n                    result\
    \ = result :+ difference\n                }\n                j++\n           \
    \ }\n            i++\n        }\n        result", "        def isGameWon(game:\
    \ List[Long], guess: List[Long]): (List[Long], List[Long]) = {\n            val\
    \ gameResult = game.foldLeft((true, List()))(_ ++ _)\n            val guessResult\
    \ = guess.foldLeft((true, List()))(_ ++ _)\n\n            val result = gameResult\
    \ ++ guessResult\n\n            (result._1.foldLeft((gameResult, guessResult))((x,\
    \ y) => x match {\n                case (true, x) => x\n                case (false,\
    \ z) => z\n            }), result._2.foldLeft((gameResult, guessResult))((x, y)\
    \ => x match {\n                case (true, x) => x\n                case (false,\
    \ z) => z\n            }))\n        }\n\n        val winningGuesses, winningScores\
    \ = isGameWon(game, guess)\n\n        val winningGuessesWithinScores = winningGuesses.map\
    \ { guess => guess(game) - guess(guess) }\n        val winningScoresWithinScores\
    \ = winningScores.map { score => score(game) - score(guess) }\n\n        val gameWonWithinScores\
    \ = winningScoresWithinScores.map { score => if (score > 0) 0 else abs(score)\
    \ }\n\n        winningGuessesWithinScores ++ gameWonWithinScores", "        val\
    \ matchSet = new mutable.HashSet[Long]()\n        val scoreSet = new mutable.HashSet[Long]()\n\
    \        game foreach {\n            case x => scoreSet.add(x) }\n        guess\
    \ foreach {\n            case x => matchSet.add(x) }\n        matchSet.toList\
    \ zip scoreSet.toList map {\n            case ((guess, score), (otherGuess, otherScore))\
    \ => Math.abs(guess - otherGuess)\n        }", "        val gameList = game.toList\n\
    \        val guessList = guess.toList\n        val guessLength = guessList.length\n\
    \        val gameLength = gameList.length\n        val diffList = mutable.ArrayBuffer.empty[Long]\n\
    \        gameList.foreach { x => diffList += abs(x - guessList(0)) }\n       \
    \ gameList.zip(guessList).foreach { x => diffList += abs(x._1 - x._2) }\n    \
    \    diffList", "        def sub(a, b: List[Long]): (List[Long], List[Long]) =\
    \ {\n            if (a.isEmpty && b.isEmpty)\n                (List[Long](), List[Long]())\n\
    \            else if (a.isEmpty || b.isEmpty)\n                (List[Long](),\
    \ List[Long]())\n            else {\n                val aAhead = a.head\n   \
    \             val bAhead = b.head\n                if (aAhead == bAhead)\n   \
    \                 (List[Long](aAhead), List[Long]())\n                else if\
    \ (aAhead < bAhead)\n                    (List[Long](), List[Long](aAhead, bAhead))\n\
    \                else\n                    (List[Long](), List[Long](bAhead, aAhead))\n\
    \            }\n        }\n        def scoreSub(a, b: List[Long]): (List[Long],\
    \ List[Long]) = {\n            if (a.isEmpty && b.isEmpty)\n                (List[Long](),\
    \ List[Long]())\n            else if (a.isEmpty || b.isEmpty)\n              \
    \  (List[Long](), List[Long]())\n            else {\n                val aAhead\
    \ = a.head\n                val bAhead = b.head\n                if (aAhead ==\
    \ bAhead)\n                    (List[Long](aAhead), List[Long]())\n          \
    \      else\n                    (List[Long](aAhead, bAhead), List[Long](aAhead\
    \ - bAhead))\n            }\n        }\n        val scoreAndGuess = sub(game ,\
    \ guess)\n        val score = scoreAndGuess._1\n        val guesses = scoreAndGuess._2\n\
    \        if (score.isEmpty || guesses.isEmpty)\n            List[Long]()\n   \
    \     else if (guesses.size == score.size)\n            guesses\n        else\n\
    \            guesses.tail.zip(score.tail).map { x => Math.abs(x._1 - x._2) }",
  "        val scoreList = game.zipWithIndex.filter { case (score,index) =>\n    \
    \        guess.contains(index)\n        }\n        val scoreListSize = scoreList.length\n\
    \        val wrongIndexList = guess.zipWithIndex.filter { case (guessedIndex,index)\
    \ =>\n            !scoreList.contains(guessedIndex)\n        }\n        val wrongIndexListSize\
    \ = wrongIndexList.length\n        val totalScore = scoreList.sum { case (score,index)\
    \ =>\n            score\n        }\n        val wrongIndexListTotalScore = wrongIndexList.sum\
    \ { case (guessedIndex,index) =>\n            scoreList(guessedIndex)\n      \
    \  }\n        val errorList = (wrongIndexListSize - totalScore) - (scoreListSize\
    \ - wrongIndexListTotalScore)\n        var sum = 0\n        var index = 0\n  \
    \      while (index < scoreListSize) {\n            val score = scoreList(index)\n\
    \            val guessedIndex = wrongIndexList(index)\n            if (score ==\
    \ guessedIndex) {\n                sum += 0\n            } else {\n          \
    \      sum += abs(score - guessedIndex)\n            }\n            index += 1\n\
    \        }\n        val totalError = errorList.sum\n        val averageError =\
    \ totalError / scoreListSize.toDouble\n        val errorListList = new collection.mutable.ListBuffer[Long]()\n\
    \        for (i <- 0 to errorList) {\n            errorListList += i.toLong\n\
    \        }\n        return errorListList.toList", "        val games = game.map\
    \ { case i => (game(i), i) }\n        val guesses = guess.map { case i => (guess(i),\
    \ i) }\n        val map = games ++ guesses.groupBy(x => x._1) ++\n           \
    \ guesses.groupBy(x => x._1).map(x => (x._2, x._2.last)).mapValues(x => x._1 -\
    \ x._2)\n\n        guess.map { x => if (map.contains(x)) 0 else abs(x - map.get(x))\
    \ }", "        var result : List[Long] = Nil\n        var diff : Int = 0\n   \
    \     for { x <- game.indices; y <- guess.indices;\n               if (x != y)\
    \ diff += abs(game(x) - guess(y)) }\n        if (diff == 0) result = game\n  \
    \      else result = game diff :: result\n        result", "        if (game.isEmpty)\
    \ guess\n        else {\n            var ix =0\n            var correct = 0\n\
    \            var score = 0\n            // Iterate through every possible score\n\
    \            // Iterate through every possible guess\n            game.foreach(score\
    \ += _)\n            guess.foreach(correct += _)\n            // Calculate number\
    \ of offenses\n            val offenses = correct - score\n            // If number\
    \ of offenses is a positive number, return that number\n            if (offenses\
    \ > 0) offenses\n            // Otherwise, return how many offenses there were\
    \ that were negative\n            else (-offenses).drop(1).map(_*-1).toList\n\
    \        }", "        game.zipWithIndex.flatMap {\n            case (score, index)\
    \ =>\n                val guess = guess(index)\n                val difference\
    \ = guess - score\n                guess match {\n                    case 0 =>\
    \ List(difference)\n                    case _ => List(0l.toLong, difference absDiff)\n\
    \                }\n        }.flatten.toList", "        val gameLength = game.size\n\
    \        val guessesLength = guess.size\n        val gameList = List.fill(gameLength)(0l)\n\
    \        val guessesList = List.fill(guessesLength)(0l)\n        for (i<-0 to\
    \ guessesLength-1) {\n            val gameValue = game(i)\n            val guessValue\
    \ = guess(i)\n            if (guessValue == gameValue) {\n                gameList(i)\
    \ = 0l\n            } else {\n                val newValue = abs(guessValue -\
    \ gameValue)\n                gameList(i) = newValue\n            }\n        }\n\
    \        gameList", "        var wrong = 0\n        var correct : List[Long] =\
    \ List()\n        var i = 0\n        var g = 1\n        var g = 0\n        var\
    \ j = 0\n        var guessed = List.empty[Long]\n        var guessedCorrect =\
    \ List.empty[Long]\n        while (i < game.size && j < guess.size && g < guessed.size\
    \ && j < guessCorrect.size) {\n            if (game(i) == guess(j)) {\n      \
    \          correct :+= game(i)\n                guessedCorrect :+= guess(j)\n\
    \                guessed :+= guess(j)\n                g += 1\n              \
    \  i += 1\n                j += 1 \n            }\n            else if (guess(j)\
    \ < game(i)) {\n                wrong += abs(game(i) - guess(j))\n           \
    \     g += 1\n                i += 1\n                j += 1 \n            }\n\
    \            else {\n                wrong += abs(guess(j) - game(i))\n      \
    \          g += 1 \n                j += 1\n            }\n        }\n       \
    \ if (i < game.size && j < guess.size && g < guessed.size && j < guessCorrect.size)\
    \ {\n            if (guess(j) == guess(j)) {\n                correct :+= game(i)\n\
    \                guessedCorrect :+= guess(j)\n                guessed :+= guess(j)\n\
    \                g += 1\n                i += 1\n                j += 1 \n   \
    \         }\n            else if (guess(j) < game(i)) {\n                wrong\
    \ += abs(game(i) - guess(j))\n                g += 1\n                i += 1\n\
    \                j += 1 \n            }\n            else {\n                wrong\
    \ += abs(guess(j) - game(i))\n                g += 1 \n                j += 1\n\
    \            }\n        }\n        if (j < guess.size && j < guessCorrect.size)\
    \ {\n            wrong += guess(j) - guessCorrect(j)\n            g += 1\n   \
    \         j += 1\n        }\n        if (i < game.size && i < guessCorrect.size)\
    \ {\n            wrong += game(i) - guessCorrect(i)\n            g += 1\n    \
    \        i += 1\n        }\n        if (g < guessed.size) {\n            wrong\
    \ += (guessed.size - g) * (guessCorrect.size - g)\n            g += 1\n      \
    \  }\n        if (g < guessCorrect.size) {\n            wrong += guessCorrect.size\
    \ - g\n        }\n        if (guessed.size < guessCorrect.size) {\n          \
    \  wrong += guessed.size\n        }\n        if (guessed.size > guessCorrect.size)\
    \ {\n            wrong += guessCorrect.size\n        }\n        wrong", "    \
    \    val matchCounter = new mutable.HashMap[Long, Int]()\n        for (i <- game.indices)\
    \ {\n            if (game(i) == guess(i)) {\n                matchCounter.get(game(i))\
    \ = matchCounter.get(game(i)) + 1\n            } else {\n                matchCounter.get(game(i))\
    \ = matchCounter.get(game(i)) + 1\n            }\n        }\n        val result\
    \ = new mutable.ArrayList[Long]\n        for (i <- game.indices) {\n         \
    \   if (matchCounter.get(i) == game.size) {\n                result.add(i)\n \
    \           } else {\n                val score = abs(game(i) - guess(i))\n  \
    \              if (score < 0) {\n                    result.add(i + score)\n \
    \               } else {\n                    result.add(i + score * -1)\n   \
    \             }\n            }\n        }\n        result.toList", "        val\
    \ gameScores = game.zipWithIndex.map{case (score, index) => score}\n        val\
    \ guesses = guess.zipWithIndex.map{case (guess, index) => guess}\n        val\
    \ difference = gameScores.zip(guesses).zipWithIndex.map{\n            case (score,\
    \ guess, index) => (guess - score)\n        }.filter(_ > 0).map{case (diff, index)\
    \ => (diff * -1)}\n        gameScores.zip(difference).filter(_ > 0).map{case (game,\
    \ diff) => game + diff}", "        \n        def compare(a : List[Long], b : List[Long],\
    \ i : Int, j : Int) : List[Long] = {\n            if (i < 0) {\n             \
    \   List(0)\n            } else if (j < 0) {\n                List(0)\n      \
    \      } else if (j > i) {\n                List(0)\n            } else {\n  \
    \              val a1 = a(i)\n                val b1 = b(i)\n                val\
    \ a2 = a(i + 1)\n                val b2 = b(i + 1)\n                if (a1 ==\
    \ b1 && b2 == a2) {\n                    List(0)\n                } else if (a1\
    \ == b1 && b2 != a2) {\n                    List(a1 - b1)\n                } else\
    \ if (a1 != b1 && b1 == a2) {\n                    List(a2 - b2)\n           \
    \     } else if (a1 != b1 && b2 != a2) {\n                    List(a2 - b1 + a1\
    \ - b2)\n                } else {\n                    val c = compare(a, b, i\
    \ + 1, j + 1)\n                    if (c.size == 1) c(0) else c\n            \
    \    }\n            }\n        }\n\n        compare(game, guess, 0, 0)", "   \
    \     val gameMap = game.zipWithIndex.toMap\n        val guesses = guess.map{x\
    \ => x - gameMap.getOrElse(x, 0l).toLong}\n        guesses", "        val gameAsList\
    \ = game.toList\n        val guessAsList = guess.toList\n        val listSizeGuess\
    \ = guessAsList.size\n        var list : List[Long] = Nil\n        var gameIndex\
    \ = 0\n        var guessIndex = 0\n        while (gameIndex < listSizeGuess &&\
    \ guessIndex < listSizeGuess) {\n            val guessValue = guessAsList(guessIndex)\n\
    \            val gameValue = gameAsList(gameIndex)\n            if (gameValue\
    \ == guessValue) {\n                list += 0\n            } else {\n        \
    \        list += math.abs(gameValue - guessValue)\n            }\n           \
    \ gameIndex += 1\n            guessIndex += 1\n        }\n        while (gameIndex\
    \ < listSizeGuess) {\n            list += gameAsList(gameIndex)\n            gameIndex\
    \ += 1\n        }\n        while (guessIndex < listSizeGuess) {\n            list\
    \ += guessAsList(guessIndex)\n            guessIndex += 1\n        }\n       \
    \ list", "        var result : List[Long] = game.size\n        val score : mutable.Map[Int,\
    \ Int] = mutable.Map.empty\n        for (g <- game) {\n            val key = (game.indexOf(g),\
    \ game.indexOf(g))\n            if (score.contains(key)) score.getOrElse(key,\
    \ 0)\n            else\n            score(key, abs(game.indexOf(g) - guess(game.indexOf(g))))\n\
    \        }\n        for (k <- score.keys) {\n            val key = score.getOrElse(k,\
    \ 0).toInt\n            if (key == game.length) result\n            else result(result)\n\
    \        }", "        val list = game.toList\n        val guessesLength = guess.size\n\
    \        val scoreLength = list.size\n        val result = (for (i <- 0 until\
    \ scoreLength; g1 <- guessesLength until (guessesLength - g1)) yield {\n     \
    \       val a = (i until scoreLength).map(x => game(x))\n            val b = (0\
    \ until guessesLength).map(x => guess(x))\n            val c = a.zip(b)\n    \
    \        val d = c.map {\n                case (x, y) => if (x == y) 0 else abs(x\
    \ - y)\n            }\n            d.sum\n        })\n        List(result.sum)",
  "        var sum = 0L\n        game.zipAll(guess, (x, y) => x + y).foreach(x =>\
    \ sum += x)\n        sum", "        val list = game.toList ++ guess.toList\n \
    \       var result = new Array[Long](guess.length)\n        var maxScore = Long.MinValue\n\
    \        var maxScoreIndex = -1\n        var maxGuess = -1\n        val guess\
    \ = list.last\n        val game = list.init\n        var index = 0\n        while\
    \ (index < guess.length ) {\n            if (game(index) == guess) {\n       \
    \         result(index) = 0\n            } else {\n                result(index)\
    \ = Math.abs (game(index) - guess)\n            }\n            if (result[index]\
    \ > maxScore) {\n                maxScore = result[index]\n                maxScoreIndex\
    \ = index\n                maxGuess = game(maxScoreIndex)\n            }\n   \
    \         index = index + 1\n        }\n        result(maxScoreIndex) = maxGuess\
    \ - guess(maxScoreIndex)\n        result", "        var g : List[Long] = game\n\
    \        var g2 : List[Long] = guess\n        val l1 = g.size\n        val l2\
    \ = g2.size\n        if(l1 <> l2){\n            val a = g2.toList\n          \
    \  val b = a.drop(g.size)\n            val l = g2.toList.drop(g.size)\n      \
    \      val d = l.toList\n            val f = d.drop(g.size)\n            val o\
    \ = g.toList.drop(g.size)\n            val t = f.toList\n            val y = o.drop(g.size)\n\
    \            val j = t.drop(g.size)\n            val r = y.drop(g.size)\n    \
    \        val k = j.drop(g.size)\n            val m = k.drop(g.size)\n        \
    \    val n = m.drop(g.size)\n            val p = n.drop(g.size)\n            val\
    \ q = p.drop(g.size)\n            val r = q.drop(g.size)\n            val t =\
    \ q.drop(g.size)\n            val k = r.drop(g.size)\n            val m = k.drop(g.size)\n\
    \            val n = m.drop(g.size)\n            val p = n.drop(g.size)\n    \
    \        val q = p.drop(g.size)\n            val r = q.drop(g.size)\n        \
    \    val t = q.drop(g.size)\n            val k = r.drop(g.size)\n            val\
    \ m = k.drop(g.size)\n            val n = m.drop(g.size)\n            val p =\
    \ n.drop(g.size)\n            val q = p.drop(g.size)\n            val r = q.drop(g.size)\n\
    \            val t = q.drop(g.size)\n            val k = r.drop(g.size)\n    \
    \        val m = k.drop(g.size)\n            val n = m.drop(g.size)\n        \
    \    val p = n.drop(g.size)\n            val q = p.drop(g.size)\n            val\
    \ r = q.drop(g.size)\n            val t = q.drop(g.size)\n            val k =\
    \ r.drop(g.size)\n            val m = k.drop(g.size)\n            val n = m.drop(g.size)\n\
    \            val p = n.drop(g.size)\n            val q = p.drop(g.size)\n    \
    \        val r = q.drop(g.size)\n            val t = q.drop(g.size)\n        \
    \    val k = r.drop(g.size)\n            val m = k.drop(g.size)\n            val\
    \ n = m.drop(g.size)\n            val p = n.drop(g.size)\n            val q =\
    \ p.drop(g.size)\n            val r = q.drop(g.size)\n            val t = q.drop(g.size)\n\
    \            val k = r.", "        var j = 0\n        var j2 = game.length\n \
    \       val list = mutable.ListBuffer[Long]()\n        for (i <- 0 until j2) {\n\
    \            var a = 0\n            var b = 0\n            while (j < j2) {\n\
    \                a += game(j)\n                j += 2\n            }\n       \
    \     while (j2 < j) {\n                b += guess(j)\n                j2 += 2\n\
    \            }\n            if (guess == game) {\n                a += guess(j)\n\
    \                b += game(j)\n                list.+=((a - b).toLong)\n     \
    \       } else {\n                a += abs(guess(j) - game(j))\n             \
    \   b += abs(guess(j2) - game(j2))\n                list.+=((a - b).toLong)\n\
    \            }\n        }\n        list.toList", "        var numGuesses = guess.size\n\
    \        var numScores = game.size\n\n        val scores = new scala.collection.mutable.HashMap[Long,\
    \ Int]\n        val guesses = new scala.collection.mutable.HashMap[Long, Int]\n\
    \        \n        for(i <- 0 until numScores) {\n            scores.put(game(i),\
    \ i)\n        }\n\n        for(i <- 0 until numGuesses) {\n            guesses.put(guess(i),\
    \ i)\n        }\n            \n        guesses.foreach { case (guess, guessId)\
    \ =>\n            var maxScore = -1L\n            var maxGuess = -1L\n       \
    \     var maxScoreIdx = -1L\n            var maxGuesseIdx = -1L\n            var\
    \ maxScoreDifference = -1L\n            var maxGuesseDifference = -1L\n      \
    \      \n            for(score <- scores.values) {\n                val guesses\
    \ = scores.get(score)\n                if(guesses != null) {\n               \
    \     var scoreDiff = score - guess\n                    var guesseDiff = 0\n\
    \                    var scoreGuess = guesses - guess\n\n                    for(idx\
    \ <- 0 until guesses.size) {\n                        if(scoreGuess(idx) != -1)\
    \ {\n                            scoreGuess(idx) -= 1\n                      \
    \  }\n                    }\n\n                    for(idx <- 0 until scores.size)\
    \ {\n                        if(guesses.contains(idx)) {\n                   \
    \         guesses.put(idx, guesses(idx) - 1)\n                        }\n    \
    \                }\n                    \n                    scoreGuess = scoreGuess.foldLeft(0)((accum,\
    \ a) => accum + a)\n                    scoreDiff = scoreDiff - scoreGuess\n \
    \                   \n                    if(scoreDiff > maxScoreDifference) {\n\
    \                        maxScoreIdx = score\n                        maxScore\
    \ = score\n                        maxScoreDifference = scoreDiff\n          \
    \          }\n                    if(guesseDiff > maxGuesseDifference) {\n   \
    \                     maxGuesseIdx = guess\n                        maxGuess =\
    \ guess\n                        maxGuesseDifference = guesseDiff\n          \
    \          }\n                }\n            }\n\n            if(maxScoreIdx >=\
    \ 0) {\n                scores.put(maxScore, maxScoreIdx)\n                scores\
    \ -= maxScore\n                numScores -= 1\n                guesses.put(maxGuess,\
    \ maxGuesseIdx)\n                guesses -= maxGues\n                numGuesses\
    \ -= 1\n            }\n        }\n\n        for(score <- scores.values) {\n  \
    \          val guesses = scores.get(score)\n            if(guesses != null) {\n\
    \                guesses.foreach { case (guess, guessId) =>\n                \
    \    if(guessId == score.toLong", "        var scoreDiff = game(0) -  guess(0)\n\
    \        var scoreDiff2 = game(2) -  guess(1)\n        var scoreDiff3 = game(3)\
    \ -  guess(2)\n        var scoreDiff4 = game(4) -  guess(3)\n        var scoreDiff5\
    \ = game(5) -  guess(4)\n        var scoreDiff6 = game(6) -  guess(5)\n      \
    \  var scoreDiff7 = game(7) -  guess(6)\n        var scoreDiff8 = game(8) -  guess(7)\n\
    \        var scoreDiff9 = game(9) -  guess(8)\n        var scoreDiff10 = game(10)\
    \ -  guess(9)\n        var scoreDiff11 = game(11) -  guess(10)\n        var scoreDiff12\
    \ = game(12) -  guess(11)\n        var scoreDiff13 = game(13) -  guess(12)\n \
    \       var scoreDiff14 = game(14) -  guess(13)\n        var scoreDiff15 = game(15)\
    \ -  guess(14)\n        var scoreDiff16 = game(16) -  guess(15)\n        var scoreDiff17\
    \ = game(17) -  guess(16)\n        var scoreDiff18 = game(18) -  guess(17)\n \
    \       var scoreDiff19 = game(19) -  guess(18)\n        var scoreDiff20 = game(20)\
    \ -  guess(19)\n        var scoreDiff21 = game(21) -  guess(20)\n        var scoreDiff22\
    \ = game(22) -  guess(21)\n        var scoreDiff23 = game(23) -  guess(22)\n \
    \       var scoreDiff24 = game(24) -  guess(23)\n        var scoreDiff25 = game(25)\
    \ -  guess(24)\n        var scoreDiff26 = game(26) -  guess(25)\n        var scoreDiff27\
    \ = game(27) -  guess(26)\n        var scoreDiff28 = game(28) -  guess(27)\n \
    \       var scoreDiff29 = game(29) -  guess(28)\n        var scoreDiff30 = game(30)\
    \ -  guess(29)\n        var scoreDiff31 = game(31) -  guess(30)\n        var scoreDiff32\
    \ = game(32) -  guess(31)\n        var scoreDiff33 = game(33) -  guess(32)\n \
    \       var scoreDiff34 = game(34) -  guess(33)\n        var scoreDiff35 = game(35)\
    \ -  guess(34)\n        var scoreDiff36 = game(36) -  guess(35)\n        var scoreDiff37\
    \ = game(37) -  guess(36)\n        var scoreDiff38", "        var total = 0\n\
    \        var score = 0\n        var count = 0\n        var result: List[Long]\
    \ = List[Long]()\n        for(i <- 0 until guess.size) {\n            total +=\
    \ guess(i)\n            score += game(i)\n            count += 1\n        }\n\
    \        val result: List[Long] = if(count == 0) List(0) else {\n            val\
    \ diff = abs(total - score)\n            guess.zip(game).map { case (g,s) => diff-g}\n\
    \        }\n        result", "        val guessedCorrectly = game.zipWithIndex.filter\
    \ {\n            case (score: Long, index: Long) => guess(index) == score\n  \
    \      }.map(i => i._2).count\n        if (guessedCorrectly == game.length)\n\
    \            guessedCorrectly\n        else\n            game.zipWithIndex.filter(g\
    \ => guessedCorrectly < game.length && guess(g._2) == g(1)).map(g => g(1) - g._2).sum",
  "        var score = 0l\n        var correct = 0l\n        var miss = 0l\n     \
    \   for(i <- 0 until game.size) {\n            if(game(i) == guess(i)) {\n   \
    \             score += 1\n                if(guess(i) == game(i)) {\n        \
    \            correct += 1\n                } else {\n                    miss\
    \ += 1\n                }\n            }\n        }\n        if(game.size == guess.size)\
    \ {\n            return correct\n        } else {\n            return miss * abs(score-correct)\n\
    \        }", "        // Your code here\n        // val game = List(1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)\n        // val guess\
    \ = List(1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong)\n\
    \        // return List(1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong,\
    \ -2l.toLong)\n\n        // val game = List(1l, 2l, 3l, 4l, 5l, 1l)\n        //\
    \ val guess = List(1l, 2l, 3l, 4l, 2l, -2l)\n        // return List(1l, 2l, 3l,\
    \ 4l, 2l, -2l)\n        \n        //val game = List(1l, 2l, 3l, 4l, 5l, 1l)\n\
    \        //val guess = List(1l, 2l, 3l, 4l, 2l, -2l)\n        //return List(1l,\
    \ 2l, 3l, 4l, 2l, -2l)\n        \n        val game = game.toList\n        val\
    \ guess = guess.toList\n        val diffs = game.zip(guess).map { case (game,\
    \ guess) => Math.abs(guess - game) }\n        val wins = diffs.count(_ == 0)\n\
    \        // We have wins out of all guesses.\n        // Since we already know\
    \ how many matches are possible we can easily know how many matches are wins.\n\
    \        wins.toLong.zip(diffs).map { case (win, diff) => win * diff }.toList",
  "        val result = new Array[Long](guess.size)\n        val errors = mutable.Map[Int,\
    \ Double]()\n        guesses.zipWithIndex.foreach{ case (guess, index) => {\n\
    \            val score = game(index)\n            // if the guess is correct,\
    \ score is 0\n            if (guess == score) result(index) <- 0\n           \
    \ else result(index) <- abs(guess - score)\n            errors + (index -> abs(guess\
    \ - score))\n        }}\n        errors.foldLeft(new Array[Long](guess.size))\
    \ { \n            case (acc, (key, value)) => \n                if (key.isDefined)\
    \ acc else acc :+ key -> value\n        }", "        // Write your code here\n\
    \        val gameSize = game.size\n        val guessSize = guess.size\n      \
    \  val result = new mutable.ListBuffer[Long]()\n        for (i <- 0 until guessSize)\
    \ {\n            val gameGuess = game(i)\n            val guessValue = guess(i)\n\
    \            val diff = abs(guessValue - gameGuess)\n            val error = if\
    \ (guessValue == gameGuess) 0 else diff\n            result.add(error)\n     \
    \   }\n        if (result.size == guessSize) result else result.toList", "   \
    \     // first of all, find out if each guess is correct\n        val correctGuess\
    \ : mutable.Map[Long, Boolean] = guess.zipWithIndex.map { case (g, i) => if (g\
    \ == game(i)) i -> true else i -> false}\n        // now compare each guess with\
    \ the corresponding score to determine the difference \n        val differences\
    \ : mutable.Map[Long, Double] = game.zipWithIndex.map { case (s, i) => if (correctGuess(i))\
    \ 0l else (s - guess(i)).abs }\n        // and now we just need to return the\
    \ difference for each guess\n        correctGuess.map { case (g, i) => differences(i)\
    \ }", "        // Solution 1\n        // O(n^2)\n        val diff = new mutable.HashMap[Long,\
    \ Long]\n        for (gen <- guess) {\n            for (score <- game) {\n   \
    \             if (gen == score) diff.set(score, gen)\n            }\n        }\n\
    \        diff.values.toList", "        val gameLen = game.size\n        val guessesLen\
    \ = guess.size\n        if (gameLen != guessesLen) {\n            throw new RuntimeException(\"\
    There should be the same amount of scores and guesses.\")\n        }\n       \
    \ val result = new mutable.ListBuffer[Long]\n        val gameMap = game.toMap\n\
    \        val guessesMap = guess.toMap\n        var bestScore = -1.0\n        var\
    \ bestGuess = -1.0\n        var bestDiff = -1.0\n        for (x <- 0 until gameLen)\
    \ {\n            var gameScore = 0\n            var gameGuess = 0\n          \
    \  var gameDiff = 0\n            var guessesScore = 0\n            var guessesGuess\
    \ = 0\n            var guessesDiff = 0\n            for (y <- 0 until guessesLen)\
    \ {\n                if (gameMap(x) == guessesMap(y)) {\n                    gameScore\
    \ += gameMap(x)\n                    gameGuess += guessesMap(y)\n            \
    \        gameDiff += abs(gameMap(x) - guessesMap(y)) * 100\n                }\n\
    \                if (guessesMap(y) == gameMap(x)) {\n                    guessesScore\
    \ += guessesMap(x)\n                    guessesGuess += gameMap(y)\n         \
    \           guessesDiff += abs(guessesMap(y) - gameMap(x)) * 100\n           \
    \     }\n            }\n            val guessesDiffAbs = abs(guessesGuess - guessesScore)\
    \ * 100\n            val gameDiffAbs = abs(gameGuess - gameScore) * 100\n    \
    \        if (gameScore == guessesScore) {\n                result.append((guessesGuess\
    \ + guessesDiffAbs) * 100)\n            } else if (gameScore < guessesScore) {\n\
    \                result.append((bestGuess + bestDiff) * 100)\n            } else\
    \ {\n                result.append((bestScore + bestDiff) * 100)\n           \
    \ }\n            bestScore = gameScore\n            bestGuess = gameGuess\n  \
    \          bestDiff = gameDiff\n        }\n        result.toList", "        val\
    \ diff = game zip guess map {\n            case (x: Long, y: Long) => Math.abs(x\
    \ - y)\n        }\n        diff.toList", '      game.map(x => if (x == guess)
    0 else abs(x - guess))', "        game.zip(guess).map { case (gameScore, guess)\
    \ =>\n            val isGameCorrect = gameScore == guess\n            val gameScoreDiff\
    \ = math.abs(gameScore - guess) \n            (if (isGameCorrect) 0 else gameScoreDiff)\n\
    \        }.sortWith(_ < _).map(_.toLong)", "        val scoreList: mutable.List[Long]\
    \ = game.zip(guess).map { case (gameScore, guessScore) => Math.abs(guessScore\
    \ - gameScore) }\n        val resultList: mutable.List[Long] = game.length match\
    \ {\n            case 1 => scoreList\n            case _ => scoreList.zip(scoreList.drop(1))\n\
    \        }\n        resultList.sortBy(_._1).map(x => game(x(0)).toLong)", "  \
    \      val (numGames, numGuesses) = game.length, guess.length\n        var correct\
    \ = 0\n        val guessesList = mutable.ArrayBuffer[Long]()\n        for (i <-\
    \ 0 until numGames) {\n            // for each game number in game\n         \
    \   // see if there is a match with any guess in guess\n            var wrong\
    \ = 0\n            for (j <- 0 until numGuesses) {\n                val g = guess(j)\n\
    \                if (game(i) == g) {\n                    correct += 1\n     \
    \               guessesList += g\n                    wrong += 1\n           \
    \     }\n            }\n            // if there is a match then it is correct,\
    \ otherwise wrong\n            if (wrong == 0)\n                correct += 1\n\
    \        }\n        // return list of correct guesses divided by number of games\n\
    \        List(correct / numGames)", "        if (game.length != guess.length)\
    \ throw new IllegalArgumentException(\"Game and guess are of different lengths\"\
    )\n        var result = List()\n        for (i <- 0 until game.size) {\n     \
    \       var temp = 0\n            if (guess contains game(i)) {\n            \
    \    temp = -1\n            }\n            else {\n                temp = 1\n\
    \            }\n            result = result :+ (Math.abs(guess(i) - game(i)).toLong\
    \ + temp * i)\n        }\n        result", "        // For each index of guess\
    \ list check if game list index equals guess value\n        // For each index\
    \ on game list check if that index equals guess value\n        // For each index\
    \ on game list check if that index equals guess value\n        // For each index\
    \ on game list check if that index equals guess value\n        // For each index\
    \ on game list check if that index equals guess value\n        // For each index\
    \ on game list check if that index equals guess value\n        // For each index\
    \ on game list check if that index equals guess value\n        // For each index\
    \ on game list check if that index equals guess value\n        // For each index\
    \ on game list check if that index equals guess value\n        // For each index\
    \ on game list check if that index equals guess value\n        // For each index\
    \ on game list check if that index equals guess value\n        // For each index\
    \ on game list check if that index equals guess value\n        // For each index\
    \ on game list check if that index equals guess value\n        // For each index\
    \ on game list check if that index equals guess value\n        // For each index\
    \ on game list check if that index equals guess value\n        // For each index\
    \ on game list check if that index equals guess value\n        // For each index\
    \ on game list check if that index equals guess value\n        // For each index\
    \ on game list check if that index equals guess value\n        // For each index\
    \ on game list check if that index equals guess value\n        // For each index\
    \ on game list check if that index equals guess value\n        // For each index\
    \ on game list check if that index equals guess value\n        // For each index\
    \ on game list check if that index equals guess value\n        // For each index\
    \ on game list check if that index equals guess value\n        // For each index\
    \ on game list check if that index equals guess value\n        // For each index\
    \ on game list check if that index equals guess value\n        // For each index\
    \ on game list check if that index equals guess value\n        // For each index\
    \ on game list check if that index equals guess value\n        // For each index\
    \ on game list check if that index equals guess value\n        // For each index\
    \ on game list check if that index equals guess value\n        // For each index\
    \ on game list check if that index equals guess value\n        // For each index\
    \ on game list check if that index equals guess value\n        // For each index\
    \ on game list check if that index equals guess value\n        // For each index\
    \ on game list check if that index equals guess value\n        // For each index\
    \ on game list check if that index equals guess value\n        // For ", "   \
    \     // We will keep track of the guesses you have seen and how many you see.\n\
    \        // We know that the number of guesses is equal to the length of the list\
    \ we're working on\n        // and that each element of a list corresponds to\
    \ an element in game.\n        // The difference between the guess and what we\
    \ see is our error!\n        var seen = guess.length\n        var correct = guess.length\n\
    \        // We will store our answer by keeping a running total of the differences\
    \ between guesses.\n        // For each guess, we add the difference from the\
    \ guess and the score that matches it.\n        val diff = new mutable.ListBuffer[Long]()\n\
    \        for (i <- 0 until guess.length) {\n            val correct = game(i)\
    \ match {\n                case 0L => 0L\n                case 1L => 0L\n    \
    \            case 2L => 0L\n                case 3L => 0L\n                case\
    \ 4L => game(i) - guess(i)\n                case _ => Math.abs(game(i) - guess(i))\n\
    \            }\n            diff += correct\n            correct += 0\n      \
    \  }\n        diff :+ 0L", "        val nMatches  = game.length\n        val nGuesses\
    \ = guess.length\n        val allGuesses = mutable.LinkedHashSet[Long]()\n   \
    \     for (i <- 0 until nGuesses) allGuesses += guess(i)\n        val diffs =\
    \ mutable.ArrayBuffer.empty[Long]\n        val errors = mutable.ArrayBuffer.empty[Long]\n\
    \        // now check each guess\n        for (g <- 0 until nGuesses) {\n    \
    \        val error = (game(g) - guess(g))\n            if (error < 0) { errors\
    \ += error }\n            if (error > 0) { diffs += error }\n        }\n     \
    \   // now check each possible match\n        for (g1 <- 0 until nMatches) {\n\
    \            var allGuesses2 = mutable.LinkedHashSet[Long]()\n            for\
    \ (g2 <- 0 until nGuesses) {\n                val error = (game(g1) - game(g2))\n\
    \                if (error < 0) { errors += error }\n                if (error\
    \ > 0) { diffs += error }\n                allGuesses2 += guess(g2)\n        \
    \    }\n            // now check that all possible matches were found\n      \
    \      if (allGuesses2.size < nGuesses)\n                errors += 0\n       \
    \     else\n                for (g2 <- 0 until nGuesses) {\n                 \
    \   val error = (game(g1) - guess(g2))\n                    if (error < 0) { errors\
    \ += error }\n                    if (error > 0) { diffs += error }\n        \
    \        }\n        }\n        // now compute final answer\n        val result\
    \ = (diffs.size + errors.size) * nMatches / nGuesses\n        (diffs.toList ++\
    \ errors.toList).distinct", "        // your code goes here\n        val result\
    \ = mutable.ArrayBuffer.empty[Long]\n        val scores = new mutable.ArrayBuffers.ArrayBuffer[Long]\n\
    \        val guesses = new mutable.ArrayBuffers.ArrayBuffer[Long]\n        for\
    \ ((gameScore <- game) zip (guess zip guesses)) {\n            scores += (gameScore\
    \ - game._2)\n            guesses += game._1\n        }\n        if (scores.length\
    \ == guesses.length) {\n            for ((gameScore <- game) zip (guess zip guesses))\
    \ {\n                if (gameScore == guesses(gameScore)) {\n                \
    \    result += (0l)\n                } else {\n                    result += abs(guesses(gameScore)\
    \ - gameScore)\n                }\n            }\n        }\n        result.toList",
  "        var index = 0\n        var score = 0\n        val correct = game.toSet\n\
    \        val incorrect = guess.toSet\n        val differences = mutable.ListBuffer.empty[Long]\n\
    \        while (incorrect.nonEmpty) {\n            if (incorrect.contains(index))\
    \ {\n                score += game(index) - guess(index)\n                differences\
    \ += abs(score - game(index))\n                incorrect.remove(index)\n     \
    \       } else {\n                score += guess(index)\n                differences\
    \ += abs(score - guess(index))\n                correct -= guess.drop(index +\
    \ 1)\n            }\n            index += 1\n        }\n        if (incorrect.isEmpty)\
    \ 0\n        else differences.reverse", "        val gameList = game.map{case\
    \ i => i.toLong}.toList\n        val guessList = guess.map{case i => i.toLong}.toList\n\
    \        val gameCount = gameList.size\n        val guessCount = guessList.size\n\
    \        val count = guessList.zip(gameList).count(_ == 0)\n        val list =\
    \ guessList.zip(gameList).map {case (g, gs) =>\n            val diff = (gs.toLong\
    \ - g).toInt\n            if (diff < 0)\n                diff\n            else\n\
    \                diff\n        }\n        list :+ count * gameCount", "      \
    \  var index = 0\n        var correctIndex = 0\n        var total = 0l\n     \
    \   while(index < game.size) {\n            val score = game(index)\n        \
    \    val guess = guess(index)\n            if(guess == score) \n             \
    \   correctIndex += index \n            total += Math.abs(score - guess)\n   \
    \         index += 1\n        }\n        if(correctIndex == game.size) \n    \
    \        game.toList \n        else game.toList ++ List(total - game(correctIndex))",
  "        if (game.size != guess.size)\n            throw new IllegalArgumentException(\"\
    Size of game and guesses differs\")\n        if (game.size < 1)\n            throw\
    \ new IllegalArgumentException(\"Size of game must be greater than 0\")\n    \
    \    if (guess.size < 1)\n            throw new IllegalArgumentException(\"Size\
    \ of guesses must greater than 0\")\n        val result = new ListBuffer[Long]()\n\
    \        for ((index, score) <- game.zip(guess).zipWithIndex) {\n            val\
    \ diff = Math.abs(score - game(index))\n            result.+=diff\n        }\n\
    \        return result.toList", "        if (game.length != guess.length) {\n\
    \            List(game.length - guess.length)\n        } else {\n            var\
    \ difference = scala.collection.mutable.ArrayBuffer[Long]()\n            game.zipWithIndex.foreach\
    \ { case (gameElement, gameIndex) =>\n                var difference = scala.collection.mutable.ArrayBuffer[Long]()\n\
    \                guess.zipWithIndex.foreach { case (guessElement, guessIndex)\
    \ =>\n                    if (gameElement == guessElement) {\n               \
    \         difference += gameIndex\n                    }\n                }\n\
    \                difference += game.size - difference.length\n            }\n\
    \            difference\n        }", "        val numMatches = game.length\n \
    \       if (numMatches != guess.length) throw new IllegalArgumentException(\"\
    Incorrect length for game and guess\")\n        val gameMap : Map[Long, Int] =\
    \ game.zipWithIndex.toMap\n        val guessMap : Map[Long, Int] = guess.zipWithIndex.toMap\n\
    \        var result = 0\n        guessMap.foreach { case (guess, guessIndex) =>\n\
    \            val score = gameMap(guess)\n            if (guessIndex != numMatches)\
    \ throw new IllegalArgumentException(\"Incorrect length for game and guess\")\n\
    \            result += (guess - score)\n        }\n        result.toList.map((_,\
    \ numMatches))", "        val gameLen = game.size\n        val guessedLen = guess.size\n\
    \        val output = new collection.mutable.ListBuffer[Long]()\n        val diff\
    \ = game.zip(guess).map { case (g, gs) =>\n            if (gs == 0l.toLong) {\n\
    \                0\n            } else {\n                abs(g - gs)\n      \
    \      }\n        }\n        diff foreach { e => output += e }\n        if (guessedLen\
    \ == gameLen) {\n            output // Return the correct answer.\n        } else\
    \ {\n            output // Return the diff between the guess and the score\n \
    \       }", "        var miss : List[Long] = Nil\n        for (_ <- 0 until guess.size)\
    \ {\n            val score = game(guess(_))\n            val diff = if (score\
    \ < 0) -score else score\n            val gv = if (diff > 0) 1 else -1\n     \
    \       val miss = gv::miss\n        }\n        miss", "        // write code\
    \ here\n        val a = game.zipWithIndex.filter(x => x._1 == guess(x._2))\n \
    \       val b = game.zipWithIndex.filter(x => x._1 == x._2)\n        val c = game.zipWithIndex.filter(x\
    \ => x._2 == guess(x._2))\n        val d = game.zipWithIndex.filter(x => x._2\
    \ == x._1)\n        val e = game.zipWithIndex.filter(x => guess(x._2) == x._1)\n\
    \        val f = game.zipWithIndex.filter(x => guess(x._2) == x._2)\n        val\
    \ g = game.zipWithIndex.filter(x => x._2 == guess(x._1))\n        val h = game.zipWithIndex.filter(x\
    \ => guess(x._2) == x._1)\n        val i = game.zipWithIndex.filter(x => guess(x._2)\
    \ == x._2)\n        val j = game.zipWithIndex.filter(x => x._1 == guess(x._1))\n\
    \        val k = game.zipWithIndex.filter(x => x._1 == guess(x._2))\n        val\
    \ l = game.zipWithIndex.filter(x => guess(x._1) == guess(x._2))\n        val m\
    \ = game.zipWithIndex.filter(x => x._1 != guess(x._2))\n        val n = game.zipWithIndex.filter(x\
    \ => x._1 != guess(x._1))\n        val o = game.zipWithIndex.filter(x => guess(x._2)\
    \ == guess(x._1))\n        val p = game.zipWithIndex.filter(x => guess(x._2) ==\
    \ guess(x._2))\n        val q = game.zipWithIndex.filter(x => x._2 == guess(x._2))\n\
    \        val r = game.zipWithIndex.filter(x => x._2 == guess(x._1))\n        val\
    \ s = game.zipWithIndex.filter(x => guess(x._2) == guess(x._1))\n        val t\
    \ = game.zipWithIndex.filter(x => guess(x._2) == guess(x._2))\n        val u =\
    \ game.zipWithIndex.filter(x => x._1 != guess(x._2))\n        val v = game.zipWithIndex.filter(x\
    \ => x._1 != guess(x._1))\n        val w = game.zipWithIndex.filter(x => guess(x._2)\
    \ == guess(x._1))\n        val x = game.zipWithIndex.filter(x => guess(x._2) ==\
    \ guess(x._2))\n        val y = game.zipWithIndex.filter(x => guess(x._2) == gues",
  "        var correct = 0\n        for (i <- 0 until guess.size) {\n            var\
    \ diff = abs(guess - game(i))\n            if (guess - game(i) == 0) {\n     \
    \           correct = 0\n            } else {\n                correct = correct\
    \ + diff\n            }\n        }\n        return List(correct)", "        def\
    \ distance(x : Long, y : Long) : Long = math.abs(x - y)\n        var scores :\
    \ List[Long] = game.clone\n        var guesses : List[Long] = guess.clone\n  \
    \      // loop until all guesses have been found\n        while !(guesses.forall(x\
    \ => x != 0l.toLong)) {\n            // loop through all scores and check if all\
    \ guesses have been found\n            var i : Int = 0\n            while (i <\
    \ scores.length && !guesses.contains(scores(i))) i += 1\n            // found\
    \ all scores; score them all and remove guesses from guesses\n            scores\
    \ ++= score(i).toLong\n            guesses -+= guess(i).toLong\n        }\n  \
    \      return scores.toList", "        game.zip(guess).map{\n            case\
    \ (score, guess) => (score - guess) match {\n                case 0 => 0\n   \
    \             case x => x\n            }\n        }.map(math.abs)", "        //\
    \ first, let's find the difference between the guess and the scores\n        var\
    \ diff : List[Long] = List[Long]()\n        var sum : Long = 0\n        for(g\
    \ in guess){\n            val diffScore = abs(game(g) - guess(g))\n          \
    \  diff :+= diffScore\n            sum += diffScore\n        }\n        // now\
    \ we need to find the sum of differences between guesses and sums\n        var\
    \ diffSum : List[Long] = List[Long]()\n        val diffSumSum = (sum * game.length).toLong\n\
    \        for(g in guess){\n            val diffScore = abs(game(g) - diffSumSum)\n\
    \            diffSum :+= diffScore\n        }\n        // now we just need to\
    \ check if the difference between guess and sum is 0\n        var sumDifference:\
    \ List[Long] = List[Long]()\n        for(g in guess){\n            sumDifference\
    \ :+= abs(game(g) - diffSumSum)\n        }\n        // now we need to find how\
    \ many different numbers we have\n        var differentNumbers : List[Long] =\
    \ List[Long]()\n        for(n <- 0 until game.length){\n            if(diffSum.exists(g\
    \ => abs(g) == n)){\n                differentNumbers :+= n\n            }\n \
    \       }\n        // now we just need to return the differences\n        val\
    \ differentNumbersAndDifferences = diffSum.toList.zip(diffSum diff differentNumbers)\n\
    \        differentNumbersAndDifferences.filter(_._2 > 0).flatMap(_._1)", "   \
    \     val diff = game.zip(guess).map {\n            case (guess, score) if (score\
    \ == 0) 0 else guess.abs - score\n        }\n        diff.init.toList.sorted",
  "        val diffs = mutable.MutableList[Long]()\n        val guesses = game.zipWithIndex.filter{case\
    \ (_, idx) => idx % 2 == 0}\n        guesses.foreach { guess => \n           \
    \ val score = game.zip(guesses).map{case (score, idx) => score}.reduce(_ + _)\n\
    \            diffs += (if (guess == score) 0 else abs(guess - score))\n      \
    \  }\n        diffs", "        // your implementation here\n        return guess",
  "        game.zip(guess).map {\n            case (gameScore, guess) => (gameScore\
    \ - guess)\n        }.map(math.abs)", "        val len = guess.size\n        var\
    \ off = 0\n        var correct = 0\n        for(i <- 0 until len) {\n        \
    \    if (game(i) == guess(i)) {\n                off += 1\n            } else\
    \ {\n                val tmp = abs(game(i) - guess(i))\n                if (tmp\
    \ == 0)\n                    off += 1\n                else\n                \
    \    off += tmp\n            }\n            if (off == len)\n                correct\
    \ += 1\n        }\n        correct.toList :+ abs(off.toDouble).toLong", "    \
    \    // 1. sort by score\n        val sortedScore = game.sortBy(x => x)\n    \
    \    // 2. sort by guess \n        val sortedGuess = guess.sortBy(x => x)\n  \
    \      // 3. calculate the difference\n        var i = 0\n        var j = 0\n\
    \        var distance = 0\n        var diff = 0\n        var newGame = List[Long]()\n\
    \        while (i < sortedScore.length && j < sortedGuess.length) {\n        \
    \    if (sortedScore(i) < sortedGuess(j)) {\n                distance = sortedScore(i)\
    \ - sortedGuess(j)\n                diff = Math.abs(distance)\n              \
    \  newGame = game :+ diff\n                i += 1\n                j += 1\n  \
    \          } else {\n                distance = sortedGuess(j) - sortedScore(i)\n\
    \                diff = Math.abs(distance)\n                newGame = game :+\
    \ diff\n                i += 1\n                j += 1\n            }\n      \
    \  }\n        // 4. return the results\n        return newGame", "        game\
    \ match {\n          case head :: tail => guess match {\n            case head\
    \ :: tail => List(head - tail).zip(game)\n            case Nil => Nil\n      \
    \    }\n          case Nil => Nil\n        }", "      val difference = game.zip(guess).map\
    \ { case (gameScore, guessScore) => Math.abs(gameScore - guessScore) }\n     \
    \ val guessedCorrectly = difference.map(x => x != 0).toList.forall(x => x == 0)\n\
    \      (if (guessedCorrectly) 0 else difference :+ 0)", '        game.indices.zip(guess).map
    {case (i, g) => abs(g - game(i)) }', "        val scoreSet = mutable.HashSet[Long]()\n\
    \        // loop through all guesses\n        for (guess <- guess) {\n       \
    \     // if the guess is correct\n            if(game contains guess) {\n    \
    \            // increment the correct score\n                scoreSet += guess\n\
    \            }\n            // otherwise the guess was wrong\n            else\
    \ {\n                // set the new score\n                scoreSet += game\n\
    \                // the difference between the new guess and the old guess\n \
    \               val diff = Math.abs(guess - game.last)\n                // the\
    \ new guess is off the end of the game\n                scoreSet += game.last\n\
    \                // the new guess is off the end of the correct guesses\n    \
    \            scoreSet -= game.last\n                // the new guess is on the\
    \ correct guesses list\n                scoreSet -= guess\n            }\n   \
    \     }\n        // return the scoreSet\n        scoreSet.toList", "        val\
    \ guessesCount = guess.size\n        val guesses = guess.toList\n        val guessesList\
    \ = guesses.map( _ + game(guesses.indexOf(_))).sorted //sort to avoid losing order\n\
    \        val diffs = new mutable.ListBuffer[Long]()\n        val guessesIter =\
    \ guessesList.iterator\n        var count = 1\n        while(count < guessesCount)\
    \ {\n            val guessVal = guessesIter.next()\n            val diffVal =\
    \ abs(guessVal - game(guesses.indexOf(guessVal)))\n            diffs += diffVal\n\
    \            count += 1\n        }\n        diffs.toList", "        val guesses\
    \ = guess.grouped(3).toList\n        var result = game.grouped(3).toList\n   \
    \     // The two following lines implement the \"not equal\" condition\n     \
    \   val scoreDiff = guess diff game\n        val scoreDiffMinusGuess = guess diff\
    \ (guess map {_ diff _})\n        val guessesDiff = guesses diff game\n      \
    \  val guessesDiffMinusGuess = guesses diff (guesses map {_ diff _})\n       \
    \ for (i <- 0 to game.size) {\n            val guessDiff = guess map {_ diff _}\
    \ diff game(i)\n            val guessDiffMinusGuess = guess map {_ diff _} diff\
    \ (guess map {_ diff _})\n            val scoreDiff = scoreDiff(i)\n         \
    \   val scoreDiffMinusGuess = scoreDiffMinusGuess(i)\n            val guessesDiff\
    \ = guessesDiff(i)\n            val guessesDiffMinusGuess = guessesDiffMinusGuess(i)\n\
    \            val guessDiff = guess map {_ diff _} diff game(i)\n            val\
    \ guessDiffMinusGuess = guess map {_ diff _} diff (guess map {_ diff _})\n   \
    \         val scoreDiff = scoreDiff(i)\n            val scoreDiffMinusGuess =\
    \ scoreDiffMinusGuess(i)\n            val guessesDiff = guessesDiff(i)\n     \
    \       val guessesDiffMinusGuess = guessesDiffMinusGuess(i)\n            val\
    \ guessesDiffMinusGuess = guess map {_ diff _} diff (guess map {_ diff _})\n \
    \           val guessesDiffMinusGuess = guess map {_ diff _} diff (guess map {_\
    \ diff _})\n            val scoreDiff = scoreDiff(i)\n            val scoreDiffMinusGuess\
    \ = scoreDiffMinusGuess(i)\n            val guessesDiff = guessesDiff(i)\n   \
    \         val guessesDiffMinusGuess = guessesDiffMinusGuess(i)\n            val\
    \ guessDiff = guess map {_ diff _} diff game(i)\n            val guessDiffMinusGuess\
    \ = guess map {_ diff _} diff (guess map {_ diff _})\n            val scoreDiff\
    \ = scoreDiff(i)\n            val scoreDiffMinusGuess = scoreDiffMinusGuess(i)\n\
    \            val guessesDiff = guessesDiff(i)\n            val guessesDiffMinusGuess\
    \ = guessesDiffMin", "        val differences = guess.length match {\n       \
    \     case x if x == 0 => 0 :: 0\n            case x if x < 0 => 0 :: 0 \n   \
    \         case x => 0 :: 0\n        }\n        game match {\n            case\
    \ l => guess match {\n                case gl => \n                    l foreach\
    \ {\n                        case n => {\n                            val difference\
    \ = n - game(0)\n                            val score = difference - game(l)\n\
    \                            differences(n) = difference\n                   \
    \         differences(x) = difference\n                            differences(y)\
    \ = difference\n                        }\n                    }\n           \
    \     case _ => game\n            }\n        }", "        def compare(currentGuess:\
    \ List[Long], score: List[Long]) : List[Long] = {\n            if (currentGuess.length\
    \ != guess.length)\n                throw new IllegalArgumentException(\"Game\
    \ and guess lists must contain the same number of elements!\")\n            var\
    \ currentGuess = 0\n            var score = 0\n            var error = 0\n   \
    \         currentGuess = currentGuess.toList.zipWithIndex.map{\n             \
    \   case (g, i) => g + i\n            }\n            score = score.toList.zipWithIndex.map{\n\
    \                case (s, i) => s + i\n            }\n            if (currentGuess.size\
    \ != score.size)\n                throw new IllegalArgumentException(\"Game and\
    \ score lists must contain the same number of elements!\")\n            if (currentGuess.size\
    \ == 0)\n                error += 1\n            if (score.size == 0)\n      \
    \          error += 2\n            val n = score.size\n            var scoreArray\
    \ = score.toArray\n            scoreArray = scoreArray.drop(n).reverse.drop(n)\n\
    \            var currentGuessArray = currentGuess.toArray\n            currentGuessArray\
    \ = currentGuessArray.drop(n).reverse.drop(n)\n            scoreArray.zipWithIndex.foldLeft(scoreArray.toArray)\
    \ {\n                case ((curr, i), (s, k)) =>\n                    if (curr(k)\
    \ != s(k))\n                        error += 1\n                    else\n   \
    \                     error += 2\n                    curr\n            }\n  \
    \          currentGuessArray.zipWithIndex.foldLeft(currentGuessArray.toArray)\
    \ {\n                case ((curr, i), (g, k)) =>\n                    if (curr(k)\
    \ != g(k))\n                        error += 1\n                    else\n   \
    \                     error += 2\n                    curr\n            }\n  \
    \          if (error > 0)\n                error - 2\n            else if (error\
    \ < 0)\n                error + 2\n            else\n                0\n     \
    \   }\n        guess.length == 0 ?\n            game.map(_.toLong) :\n       \
    \     game.zipWithIndex.foldLeft((0l.toLong, game.map(_ + _))((c, (g, n))) =>\n\
    \                (c, compare(guess, g)))", "        val gameList = game.zip(guess).map((e)\
    \ => e._1.abs - e._2).zipWithIndex\n        val sum = (0.until(gameList.size).map(_\
    \ + 0.toLong)).sum\n        val finalList = (0.until(gameList.size).map(_ + (gameList(_)\
    \ / sum.toLong))).map(_.toLong)\n        return finalList", "        if (game.size\
    \ != guess.size) return List(game.size)\n        var result = 0l\n        var\
    \ guess = 0l\n        var game = 0l\n        var found = 0\n        while (guess\
    \ < game.size && !found ) {\n            if (game == 0l) game = game(guess)\n\
    \            if (guess == game.size -1) found = game == guess\n            else\
    \ game = game(guess + 1l) \n            guess = guess + 1l\n        }\n      \
    \  if (found) result = game - guess\n        else         result = 0l\n      \
    \  result :: Nil", "        var i = 0\n        val games = game.size // 5\n  \
    \      val guesses = guess.size // 5\n        val numMatched = games * guesses\
    \ // 10\n        var totalDiff = 0\n        while (i < numMatched) {\n       \
    \     if (game(i) == guess(i)) {\n                i += 1\n                totalDiff\
    \ += games(i)\n            } else {\n                val difference = game(i)\
    \ - guess(i)\n                val differenceAbs = Math.abs(difference)\n     \
    \           totalDiff += differenceAbs\n                i += 1\n            }\n\
    \        }\n        val outList = for (i <- 0 until guesses) yield (totalDiff\
    \ - guess(i))\n        outList", "        val guesses = gues\n        val scores\
    \ = game\n        var result: List[Long] = List[Long](0l)\n        var guess =\
    \ 0l\n        var score = 0l\n        var wrong = 0l\n        var wrongIndex =\
    \ 0\n        while (guess < guesses.length) {\n            if (scores == guess)\
    \ {\n                result = result::score\n            }\n            guess\
    \ = guess + 1\n            while (wrongIndex < wrong && guess < guesses.length)\
    \ {\n                if (scores(wrongIndex) == guess(wrongIndex)) {\n        \
    \            score = score\n                } else {\n                    score\
    \ = abs(score-scores(wrongIndex))\n                    wrongIndex = wrongIndex\
    \ + 1\n                }\n            }\n            if (scores == guess) {\n\
    \                score = abs(score-scores(wrongIndex))\n                wrongIndex\
    \ = wrongIndex + 1\n            }\n            result.append(score)\n        }\n\
    \        result", "        val scoreList = game zip (guess map { _.toLong } toList)\n\
    \        val scoreListSet = scoreList.toSet\n        val totalScoreList = scoreList.filter(a\
    \ => scoreListSet.contains(a))\n        val scoreListUnsetted = totalScoreList.filter(a\
    \ => !scoreListSet.contains(a))\n        val setScoreList = scoreList.filter(a\
    \ => !scoreListSet.contains(a))\n        val scoreDiffList = totalScoreList.filter(a\
    \ => setScoreList.contains(a))\n        (scoreListUnsetted zip scoreDiffList).map(tuple\
    \ => tuple._2 - tuple._1)", "        def scoreMatch(game : List[Long], guess :\
    \ List[Long], start : Int, end : Int) : List[Long] = game match {\n          \
    \  case Nil => Nil\n            case _ => {\n                val match = game(start)\
    \ match {\n                    case -1 => guess match {\n                    \
    \    case Nil => List[Long](0l)\n                        case _ => Nil\n     \
    \               }\n                    case g =>\n                        val\
    \ i = start\n                        val j = end\n                        guess\
    \ match {\n                            case Nil => {\n                       \
    \         scoreMatch(game - guess, guess + game, i, j)\n                     \
    \       }\n                            case _ => {\n                         \
    \       val r = g - g(j)\n                                if (r > 0) Nil else\
    \ scoreMatch(game - guess, guess + game, i, j)\n                            }\n\
    \                        }\n                }\n                if (match == Nil)\
    \ scoreMatch(game - guess, guess + game, start, end)\n                else scoreMatch(game\
    \ - guess, guess + game, start, start + match.length)\n            }\n       \
    \ }\n        val m = game.length\n        val n = guess.length\n        val gameLen\
    \ = game match {\n            case Nil => Nil\n            case _ => game.length\n\
    \        }\n        val guessLen = guess match {\n            case Nil => Nil\n\
    \            case _ => guess.length\n        }\n        val scores = new mutable.ArrayList[Long](m)\n\
    \        for ((i, j) <- 0 until m) {\n            if (j < n) {\n             \
    \   if (game(j) != -1L) {\n                    val score: Int = Math.abs(game(j)\
    \ - guess(i))\n                    if (score < scores.get(i)) scores.set(i, score)\n\
    \                }\n            }\n            if (j == n) {\n               \
    \ if (game(j) != -1L) {\n                    val score: Int = Math.abs(game(j)\
    \ - guess(i))\n                    if (score > scores.get(i)) scores.set(i, score)\n\
    \                }\n            }\n        }\n        if (gameLen == scores.size)\
    \ Nil\n        else scores.map(x => Math.abs(x - 0)).filter(x => x > 0).map(_\
    \ => 0).toList", "        // Write your comparison function here\n        // We\
    \ assume guess and game are both sorted and of equal length.\n        val difference\
    \ = game.zip(guess).map{case (g,g1) => g1-g}.map(x => if(x < 0) -x else x)\n \
    \       val correct = difference zip (0 until game.size).collect{case (_, i) =>\
    \ game.size - i}\n        correct.toList", "        // I hope that all of this\
    \ code can get folded into one line\n        val gameSize = game.size\n      \
    \  val guessSize = guess.size\n        var result = 0L\n        var last = 0L\n\
    \        var i = 0\n        var j = 0\n        // we know the size of the game\
    \ and guess lists are equal or greater\n        // so we don't have to worry about\
    \ that case here.\n        // We also know that they both have the same number\
    \ of elements,\n        // so we can use one loop\n        while (i < gameSize\
    \ && j < guessSize) {\n            if (game(i) > guess(j)) {\n               \
    \ result = result + 1\n                last = game(i)\n                i = i +\
    \ 1\n            }\n            else {\n                result = result + 1\n\
    \                last = game(i)\n                i = i + 1\n                j\
    \ = j + 1\n            }\n        }\n        // at this point, we know we found\
    \ a correct match\n        // if we didn't find a match we return 0 as last guesses\n\
    \        // if it doesn't matter what we return result\n        result match {\n\
    \            case 0 => last\n            case _ => result\n        }", "     \
    \   val gameSize = game.size\n        val guesses = guess.toList\n        val\
    \ result = game.zip(guesses).map { case (score, guess) =>\n            if (score\
    \ == guess) 0\n            else Math.abs(score - guess)\n        }\n        (result.toList).slice(0,\
    \ gameSize)", "        val guesses  = guess.toList\n        val scores = game.toList\n\
    \        val result = scores.zip(guesses)\n            .filter{ case (s1,s2) =>\
    \ s2 == s1 }\n            .map{ case (s1,s2) => abs(s1-s2) }\n        \n     \
    \   result.filterNot(_.isZero)", "        val numGames = game.length\n       \
    \ val numGuesses = guess.length\n        if (numGames == 0) return guess\n   \
    \     if (numGuesses == 0) return game\n        val result = game.zip(guess).foldLeft(0l){\
    \ (acc, curr) =>\n            val score1 = curr._1 - curr._2\n            val\
    \ score2 = -curr._1 - curr._2\n            if (score1 == 0) 0\n            else\
    \ score1 + score2\n        }\n        result.toList.sortWith((a, b) => a < b)",
  "        // Your code goes here\n        val guessesLen = guess.length\n       \
    \ val gameLen = game.length\n        var total = 0\n        var correct = 0\n\
    \        for (i<- 0 until guessesLen)\n        {\n            val guess = guess(i)\n\
    \            val game = game(i)\n            if (guess == game)\n            \
    \    correct += 1\n            total += (guess - game)\n        }\n        val\
    \ results = new scala.collection.mutable.ListBuffer[Long]()\n        for (i<-\
    \ 0 until guessesLen)\n        {\n            val guess = guess(i)\n         \
    \   val game = game(i)\n            val result = abs((guess - game) / game)\n\
    \            if (guess == game)\n            {\n                total += (guess\
    \ - game)\n                correct += 1\n            }\n            results.add(result)\n\
    \        }\n        val diff = correct / total\n        return results.toList",
  "        var i : Int = 0\n        var result : List[Long] = Nil\n        val length\
    \ = game.size\n        while (i < length) {\n            val diff = game.apply(i)\
    \ - guess.apply(i)\n            if (diff < 0) {\n                result += diff\
    \ :: Nil\n            } else if (diff > 0) {\n                result += diff ::\
    \ result \n            } else {\n                result += 0 :: result \n    \
    \        }\n            i += 1\n        }\n        return result", "        val\
    \ map = game.toMap\n        val guesses = guess.toList\n        var i : Long =\
    \ 0\n        var j : Long = 0\n        var diff : Long = 0\n        var diff :\
    \ List[Long] = Nil\n        val result: List[Long] = Nil\n\n        while (i <\
    \ guesses.length && j < game.length) {\n            if (guesses(i) == game(j))\
    \ {\n                diff = abs(guesses(i) - game(j))\n                diff ::\
    \ diff\n            } else if (guesses(i) > game(j)) {\n                j+=1\n\
    \            } else {\n                i += 1\n            }\n        }\n    \
    \    result", "      val game2 = game.zip(guess).map{ case (score,guess) => abs(guess\
    \ - score) }\n      game2.map{ case score if score > 0 => 0\n                \
    \  case score if score < 0 => score\n                  case _ => game2.sum }",
  "        val diffs = mutable.ListBuffer.empty[Long]\n        for (i <- 0 until game.size)\
    \ {\n            val guess = guess(i)\n            val score = game(i)\n     \
    \       diffs += abs(guess - score)\n        }\n        diffs", "       var diffs\
    \ = mutable.Map[Long, Long]()\n        var i = 1\n        while (i < game.length)\
    \ {\n            val score = game(i).toLong\n            val guess = guess(i)\n\
    \            diffs += (guess, math.abs(score - guess))\n            i += 1\n \
    \       }\n        val res = List(diffs.keys) ++ diffs.values.toList\n       \
    \ res", "        val score = new mutable.HashMap[Int, Long]()\n        for ( (a,\
    \ b) <- game.zip(guess).zip(game)) {\n            if ((a != b) &&  (!score.contains(a)))\
    \ {\n                score.put(a, a - b)\n            }\n        }\n        val\
    \ correct = new mutable.HashMap[Int, Long]()\n        for ( (a, b) <- game.zip(guess))\
    \ {\n            if ((a == b) && (!score.contains(a))) {\n                correct.put(a,\
    \ 0)\n            }\n            else {\n                correct.put(a, correct(a)\
    \ + a - b)\n            }\n        }\n        for ( (a, b) <- game.zip(correct))\
    \ {\n            if (!(score.contains(a))) {\n                score.put(a, correct(b)\
    \ - b)\n            }\n        }\n        score.toList.sortWith((a, b) => a._2\
    \ - b._2)", "        var i = 0\n        var j = 0\n        var answer = 0\n  \
    \      \n        var gameSet = Set(game.toList)\n        var guess = Set(guess.toList)\n\
    \        var gameCount = game.size\n        var guessCount = guess.size\n    \
    \    \n        while(i < gameCount && j < guessCount) {\n            if(!gameSet.isEmpty)\
    \ {\n                val gamePlayer = game(i).toLong\n                if(guess.contains(gamePlayer))\
    \ {\n                    val guessPlayer = guess(j).toLong\n                 \
    \   val score = gamePlayer - guessPlayer\n                    answer = answer\
    \ + abs(score)\n                    gameSet.subtract(guessPlayer)\n          \
    \          guess = guess.subtract(gamePlayer)\n                    i = i + 1\n\
    \                } else {\n                    i = i + 1\n                }\n\
    \            } else {\n                j = j + 1\n            }\n        }\n \
    \       \n        if(gameSet.isEmpty || guesseSet.isEmpty) {\n            return\
    \ List()\n        } else {\n            answer = answer / gameCount\n        }",
  "        if (game.length != guess.length)\n            throw new Exception(\"Not\
    \ same length\")\n        var diffs = mutable.ArrayBuffer.empty[Long]\n      \
    \  var i = 0\n        while (i < game.length)\n            diffs += abs(guess(i)\
    \ - game(i))\n            i += 1\n        diffs", "        // The list to hold\
    \ the correct answers\n        var ans : List[Long] = Nil\n        // The list\
    \ to hold the incorrect answers\n        var incorrect = Nil\n        // The current\
    \ score\n        var curScore = 0\n        // We go through each guess at which\
    \ a person got wrong\n        for (g <- guess) {\n            // The score for\
    \ a correct guess\n            var curGuess = 0\n            // We go through\
    \ each possible score for a correct guess\n            while (curGuess < game.length)\
    \ {\n                // The difference between the current guess and the current\
    \ score\n                var diff = (g - curScore).toLong\n                //\
    \ The difference between the current guess and the current correct guess\n   \
    \             var curGuess = g - curGuess\n                // If we can make the\
    \ difference, great\n                if (diff == 0l) {\n                    curScore\
    \ = g\n                    // We can stop here because the current score is what\
    \ we need\n                    ans = g :: ans :: Nil\n                }\n    \
    \            // If we can't make the difference, let's keep going\n          \
    \      else if (curGuess == 0l) {\n                    incorrect = g :: incorrect\
    \ :: Nil\n                }\n                // If we make it, we have to go on\n\
    \                else {\n                    curScore = diff\n               \
    \ }\n            }\n        }\n        // If there is an incorrect guess, add\
    \ the difference to the incorrect answers\n        if (incorrect.nonEmpty) {\n\
    \            incorrect = incorrect :: Nil\n        }\n        // If there were\
    \ no incorrect guesses, add the difference to the correct answers\n        if\
    \ (ans.nonEmpty) {\n            ans = ans :: Nil\n        }\n        // Return\
    \ the list of answers that is correct if any answer was incorrect\n        ans.filter(_\
    \ == Nil).map(_.toLong)", "        if(game.length != guess.length){\n        \
    \    return game\n        }\n        val result = game.toList.zip(guess).map {\
    \ case (x, y) => x != y }\n        result.foldLeft(List[Long](0l.toLong))((acc,\
    \ next) => if (next._1) acc.drop(next) else acc.dropRight(next+1))", "       \
    \ var result: List[Long] = Nil\n        var diffs: List[Long] = Nil\n        var\
    \ index : Int = 0\n        while (index < guess.length) {\n            var guessedCorrectly\
    \ = false\n            while (index < game.length) {\n                if (abs(game(index)\
    \ - guess(index)) < abs(guess(index) - game(index))) {\n                    if\
    \ (diffs.isEmpty) {\n                        diffs = List(abs(guess(index) - game(index)))\n\
    \                        result = (result :+ guess(index))\n                 \
    \       guessedCorrectly = true\n                    } else {\n              \
    \          diffs = diffs :+ (abs(guess(index) - game(index))) :: List(abs(guess(index)\
    \ - game(index)))\n                        result = (result :+ guess(index))\n\
    \                        guessedCorrectly = true\n                    }\n    \
    \            } else {\n                    if (diffs.isEmpty) {\n            \
    \            diffs = List(abs(guess(index) - game(index)))\n                 \
    \       result = (result :+ guess(index))\n                        guessedCorrectly\
    \ = false\n                    } else {\n                        diffs = diffs\
    \ :+ (abs(guess(index) - game(index))) :: List(abs(guess(index) - game(index)))\n\
    \                        result = (result :+ guess(index))\n                 \
    \       guessedCorrectly = false\n                    }\n                }\n \
    \               index += 1\n            }\n            index += 1\n        }\n\
    \        if (guessedCorrectly) {\n            List(result) \n        } else {\n\
    \            diffs\n        }", "        val g1 = game.toList\n        val g2\
    \ = guess.toList\n        val len = g1.length \n        var res = new Array[Long](len)\n\
    \        var i = 0\n        val g1Sorted = g1.sorted\n        val g2Sorted = g2.sorted\n\
    \        while (i < len) {\n            if (g2(i) == g1(i)) {\n              \
    \  res(i) =  0\n                i += 1\n            }\n            else{\n   \
    \             val absDiff = math.abs(g2(i) - g1(i))\n                val absDiffList\
    \ = List(absDiff.toLong)\n                val absDiffVal = absDiffList.toList\n\
    \                val diffList = List(absDiffVal.toLong)\n                val diffVal\
    \ = diffList.toList\n                res(i) = diffVal\n                i += 1\n\
    \            }\n        }\n        res", "        val guessesWithCorrect = game\n\
    \            .zip(guess)\n            .collect { case (x, y) if (x == y) => x\
    \ }\n\n        val guessesWithIncorrect = game\n            .zip(guess)\n    \
    \        .filter(_ != 0)\n            .map { case (x, y) => Math.abs(x - y) }\n\
    \            .toList\n\n        (guessesWithCorrect + guessesWithIncorrect)",
  "        val scoreList = game.map(x => x * x)\n        val guessList = guess.map(x\
    \ => x * x)\n        val diff = guessList diff scoreList\n        diff.zip(game).map(x\
    \ => if (x._2 == 0) 0 else x._1 - x._2)", "        val count = game.length\n \
    \       val guessed = guess.filter(x => game.contains(x)).size\n        // return\
    \ zero if the number of guessed is zero\n        if (guessed == 0) List(0l.toLong)\n\
    \        // return zero if the number of guessed is one\n        else if (guessed\
    \ == 1) List(0l.toLong)\n        // if number of guessed is greater than 1\n \
    \       else if (guessed > 1) List(abs(game.last) - game.last)\n        else game.zip(guess).map\
    \ { case (game, guess) =>\n            if (game == guess) 0 else abs(game - guess)\n\
    \        }.map(x => x.toLong).sum", "        val r = new scala.collection.mutable.ArrayBuffer[Long](guess.length)\n\
    \        game.toStream.foreach{ g : Long => if(g==0) r.update(0)  else if (g!=guess)\
    \ r.update(abs(g - guess.head))}\n        return r.toList", "        game match\
    \ {\n            case x :: y :: _ => guess(x) + guess(y) match {\n           \
    \     case _ if x > y => x - y\n                case _ if x < y => y - x\n   \
    \             case _ => 0\n            }\n            case _ => 0\n        }",
  "        if (game.size == guess.size) game.toList.zip(guess)\n        else {\n \
    \           def compare(game : List[Long], guess : List[Long], acc : List[Long])\
    \ : List[Long] = {\n                if (game.size == guess.size) {\n         \
    \           if (game.toList.zip(guess).toList == game.toList.zip(guess).toList)\
    \ {\n                        acc.toList\n                    } else {\n      \
    \                  compare(game :: guess, guess, acc :: guess)\n             \
    \       }\n                } else {\n                    if (game.toList.zip(guess).toList\
    \ == game.toList.zip(guess).toList) {\n                        acc.toList\n  \
    \                  } else {\n                        compare(game :: guess, guess,\
    \ acc :: guess)\n                    }\n                }\n            }\n\n \
    \           compare(game, guess, List.empty[Long])\n        }", "        var result:\
    \ List[Long] = Nil\n        var difference = 0\n        var index = 0\n      \
    \  var isCorrect = true\n        while(index < game.size){\n            difference\
    \ = Math.abs(game(index) - guess(index))\n            if(difference == 0){\n \
    \               isCorrect = false\n                break\n            }\n    \
    \        result :+ difference\n            index += 1\n        }\n        if(isCorrect){\n\
    \            result :+ 0\n        }\n        else {\n            result :+ Math.signum(difference.abs)\n\
    \        }\n        result", '        game zip guess map {case (g, gs) => abs(g
    - gs)}', "        val differences = guess, scores = game\n        val n = differences.size\n\
    \        val listOfList = new Array[List[Long]](n)\n        var i = 0\n      \
    \  while (i < n) {\n            listOfList(i / 2) = differences(i) - scores(i)\n\
    \            i += 1\n        }\n        listOfList", "        // first, let's\
    \ get a handle on the length\n        val gameLength = game.size\n        val\
    \ guessLength = guess.size\n\n        // then let's create a 'count' list to hold\
    \ the result\n        val count = new mutable.ListBuffer[Long]()\n        // and\
    \ let's create the result list from the guess list with some default value (0)\n\
    \        val result = guess.toList.map { guess => count.append(0) }.toList\n\n\
    \        // now, let's go through the game, starting with index 0\n        for(gameIndex\
    \ <- 0 until gameLength) {\n            // if the game doesn't have any more guesses\
    \ for this game, let's just return the result list\n            val hasGuesses\
    \ = guess.size > 0\n            if(!hasGuesses) result\n            else {\n \
    \               // otherwise, let's loop through the guesses for this game, starting\
    \ with index 0\n                for(guessIndex <- 0 until guessLength) {\n   \
    \                 // if the guesses aren't valid, just return the result list\n\
    \                    if(guessIndex >= game.size) result\n                    else\
    \ {\n                        // otherwise, let's see if this is a correct guess\n\
    \                        val correct = gameIndex(guessIndex) == guess\n      \
    \                  // and if it is, we'll increment the count by 1\n         \
    \               if(correct) count.append(count.head.toLong + 1)\n            \
    \        }\n                }\n            }\n        }\n        result", "  \
    \      // Your code goes here\n        val resultList = mutable.ArrayBuffer.empty[Long]\n\
    \        var index = 0\n        while (index < guess.size) {\n            val\
    \ currentGuess = guess(index)\n            var flag = false\n            var score\
    \ = 0\n            if (game(index) == currentGuess) {\n                flag =\
    \ true\n                score = 0\n            } else {\n                val newScore\
    \ = game(index) - currentGuess\n                if (flag) {\n                \
    \    newScore += currentGuess\n                } else {\n                    newScore\
    \ += newGuess\n                }\n                score = newScore\n         \
    \   }\n            resultList.append(score)\n            index++\n        }\n\
    \        resultList.toList", "        // TODO Complete this!\n        val scoreCount\
    \ = game.zipWithIndex.map({ case (score, index) => score })\n        val guesses\
    \ = guess.zipWithIndex.map({ case (guess, index) => guess })\n        var totalGuesses\
    \ = guess.size\n        val scoreIndexMap = scoreCount.toList.zipWithIndex.toMap\n\
    \        val guesseIndexMap = guesses.toList.zipWithIndex.toMap\n        var difference\
    \ = List.empty[Long]\n        val totalScore = List.empty[Long]\n        for (totalScore\
    \ <- totalScore; guess <- guess) {\n            val guessedScore = scoreIndexMap(guess)\n\
    \            val totalGuesses = totalGuesses - 1\n            val guessedGuesses\
    \ = guesseIndexMap(totalGuesses)\n            val difference = guess.toLong -\
    \ totalGuesses.toLong\n            difference :: totalScore\n        }", "   \
    \     val guesses = guess map (gs => gs.toLong) zip (game map (g => g.toLong))\n\
    \        val scores = guesses map (g => abs(g - _))\n        scores.foldLeft(List[Long](0l))((accu,\
    \ score) => accu.updated(score, accu.get(score) + 1))", "        // The goal is\
    \ to compare each item in guess to each item in game, \n        // but then only\
    \ keep comparing the items that had an exact match\n        // We want to do this\
    \ as fast as possible so we don't waste time comparing\n        // items that\
    \ don't have an exact match that we'll have to check later.\n        // We also\
    \ want to keep track of the partial matches so that we can return\n        //\
    \ the absolute difference between them.\n        // The first thing we will do\
    \ is convert the inputs to sets which will make\n        // things much easier\
    \ later.\n        // Once we have sets of the exact matches, we can quickly check\
    \ whether an\n        // item in game was an exact match by checking if every\
    \ item in the guess set\n        // was in the game set.\n        // If the guess\
    \ set does not contain all items in the game set, then we know \n        // that\
    \ some item in the guess set was not a perfect match. So we know that\n      \
    \  // the absolute difference between those items is more than the absolute\n\
    \        // difference between the score and the actual score.\n        // Once\
    \ we have these two sets of exact and partial matches, we can start comparing\n\
    \        // the items in game to the items in the guess. If the game item is in\
    \ the exact \n        // match set then we will compare it with the item in the\
    \ partial match set.\n        // If both items are in the exact match set then\
    \ we will compare them with the\n        // actual score.\n        // If the game\
    \ item is not in the exact match set then we will keep comparing \n        //\
    \ it with the item in the partial match set.\n        // If the game item is not\
    \ in the exact match set then we will keep comparing \n        // it with the\
    \ actual score.\n        // Once we get to a point where we can either compare\
    \ the game to the guess\n        // or to the actual score, we will keep track\
    \ of the partial matches and update \n        // them accordingly.\n        val\
    \ setGame  = Set(game.toList)\n        val setGuess = Set(guess.toList)\n    \
    \    var partialMatches    : List[Long] = Nil\n        var exactMatches      :\
    \ List[Long] = Nil\n        var actualScore       : List[Long] = Nil\n       \
    \ var actualScoreDiff   : List[Long] = Nil\n\n        while(setGuess.length >\
    \ 0) {\n            var isPartialMatch = false\n            val setGameItem =\
    \ setGame.head\n            val setGuessItem = setGuess.head\n            val\
    \ gameItem     = setGameItem - setGuessItem\n            val guessItem    = setGuessItem\
    \ - setGameItem\n            val gameScore    = setGameItem\n            val guessScore\
    \   = setGuessItem\n            val actualScore  = setGuessItem - gameScore\n\
    \            val actualScoreDiff = guessScore - gameScore\n\n            if (gameItem\
    \ == ", "        val totalScore = game.reduceLeft(_ + _)\n        val totalGuess\
    \ = guess.reduceLeft(_ + _)\n        val result = guess.zip(game).map { case (guess,\
    \ score) => ((guess - score) abs(guess)) }\n        result.map(_.max).zip(game)",
  "        val len = game.length\n        val correct = game.zip(guess).map(x => x(0)\
    \ - x(1))\n        val guessedCorrect = guess.zip(correct).map(x => x(0))\n  \
    \      val wrong = game.zip(guessedCorrect).map(x => x(1) - x(0))\n        val\
    \ wrongDistance = wrong.zip(guessedCorrect).map(x => x(0) - x(1))\n        wrongDistance.map(x\
    \ => if (x == 0) 0 else x).map(x => Math.abs(x))", "        val gsize = game.size\n\
    \        val gn = guess.size\n        val gdiff = gsize - gn\n        if(gdiff\
    \ <= 0) game else game.map(x => abs(x - guess(x)))", "        var result: List[Long]\
    \ = game\n        var guesses = 0\n        val gameArray = game.toArray\n    \
    \    var guessesArray = guess.toArray\n        while(gameArray.length != guessesArray.length){\n\
    \            gameArray.zip(guessesArray).map{ case (a,b) => \n               \
    \ if(a.isEmpty || b.isEmpty){\n                    result\n                }\n\
    \                else{\n                    result(0) = guesses += a.toLong -\
    \ b.toLong\n                    result\n                }\n            }\n   \
    \     }\n        result", "        val list = game.zip(guess).map { case (g, gs)\
    \ => Math.abs(g - gs) }\n        val maxList = list.maxBy(_)._1\n        val newList\
    \ = list -- maxList\n        newList.map(x => if (x == 0) 0 else x)", "      \
    \  val guesses = mutable.Set[Long](guess.toSet)\n        val answers = mutable.Set[Long](game.toSet)\n\
    \        guesses.retain { case x => answers.contains(x) }\n            .map(x\
    \ => guess - x).map(x => if (x == 0) 0 else x)", "        var diff : List[Long]\
    \ = Nil\n        game.zipWithIndex.map { x =>\n            val index = x._2\n\
    \            if (guess(index) != game(index)) {\n                diff = x\n  \
    \          }\n        }\n        diff", "        val gameList = game.toSeq\n \
    \       val guessList = guess.toSeq\n        val differenceList = gameList.zip(guessList).map\
    \ { case (game,guess) => \n            (game-guess)\n        }\n        val correctnessList\
    \ = differenceList.filter(x => x != 0)\n        correctnessList.sortWith(_ > _)",
  "        // Write your solution here\n", "        // write your code here\n    \
    \    val diff = new mutable.ListBuffer[Long]()\n        var correctGuess = 0\n\
    \        var correctScore = 0\n        var wrongScore = 0\n        var wrongGuess\
    \ = 0\n        var isCorrect = false\n        val count = game.length\n      \
    \  for (i <- 0 until count) {\n            if (game(i) == guess(i)) {\n      \
    \          correctScore += game(i)\n                correctGuess = game(i)\n \
    \           } else {\n                wrongScore += abs(game(i) - guess(i))\n\
    \                wrongGuess = abs(game(i) - guess(i))\n            }\n       \
    \ }\n        val result = (0 until count).map{i => if(correctGuess == game(i))\
    \ 0 else abs(wrongGuess - correctGuess)}.toList\n        if(correctScore == game(count)){\n\
    \            isCorrect = true\n        }\n        if (isCorrect){\n          \
    \  result\n        }else{\n            result.filter(_ != 0)\n        }", '        //
    TODO: Implement this function', "        val n = game.length\n        val m =\
    \ guess.size\n        var off = 0\n        var sum = 0\n        for(i <- 0 until\
    \ n){ \n            for(j <- 0 until m){\n                val g = game(i)\n  \
    \              val g = if(j<m) guess(j) else g\n                val off = if (g\
    \ == game(i)) 0 else abs(g - game(i))\n                sum+=off\n            }\n\
    \        }\n        if (n!=m) {\n            throw new RuntimeException(\"The\
    \ size of game and guess should be equal\")\n        }\n        sum", "      \
    \  val ns = game.length\n        val gns = guess.length\n        val result =\
    \ new mutable.ArrayList[Long](ns)\n        var c = 0\n        while (gns > 0)\
    \ {\n            // add one to our counter\n            c += 1\n            //\
    \ if we don't guess the right answer, subtract the score\n            if (c !=\
    \ gns) {\n                result -= guess(c)\n            }\n            // if\
    \ we guessed right, add one to the counter\n            if (c == gns) {\n    \
    \            c += 1\n            }\n        }\n        result", "        val scoreMap\
    \ = mutable.Map.empty[Long, Int]\n        var i = 0\n        guess.length.times\
    \ { \n            val score = game(i)\n            val guess = guess(i)\n    \
    \        scoreMap(guess) = scoreMap(guess) + 1\n            i += 1\n        }\n\
    \        var j = 0\n        var k = guess.length\n        var result = List[Long]()\n\
    \        // iterate over all the guesses to see which one is closest\n       \
    \ guess.length.times { \n            val guess = guess(j)\n            var bestScore\
    \ = 0\n            // iterate over the list of possible scores to see if they\
    \ match\n            k.times { \n                val score = game(j)\n       \
    \         if(score == scoreMap(guess) && scoreMap(guess) > bestScore) {\n    \
    \                bestScore = scoreMap(guess)\n                    result = result\
    \ :+ guess\n                }\n                j += 1\n            }\n       \
    \     k -= 1\n        }\n        result", "        // Your code here\n       \
    \ // TODO: use scala.util.parsing.math for math\n\n        val gameCopy = game.clone()\n\
    \        val guessCopy = guess.clone()\n        val result = gameCopy.zip(guessCopy).filter({case\
    \ (g,g2) => g==g2}).map(x=> x._2-x._1).distinct\n\n        result.foreach(println)\n\
    \n        //return result", "        val scoreList = game map { n => abs(n-guess)\
    \ }\n        if (scoreList.length == game.length) scoreList\n        else scoreList\
    \ :+ scoreList.foldLeft(0)(_ + _)", "        if (game.size != guess.size) throw\
    \ new ArithmeticException(\"Not enough guesses: \" + guess.size + \" - \" + game.size)\n\
    \        val guesses = guess.length\n        val scores = game.size\n        val\
    \ results = new mutable.ArrayBuffer.ofDim[Long](guesses)\n        var i : Int\
    \ = 0\n        while (i < guesses) {\n            val score = game(i)\n      \
    \      val guess = guess(i)\n            val diff = Math.abs(guess - score)\n\
    \            results(i) = diff\n            i += 1\n        }\n        results.toList",
  "        val score = new HashMap[Long, Int]()\n        for (i <- 0 until game.size)\
    \ {\n            score.put(game(i), guess(i) - game(i))\n        }\n        val\
    \ maxScore = score.max\n        val maxScoreEntry = score.get(maxScore)\n    \
    \    val result = new ArrayList[Long](game.size)\n        for (i <- 0 until game.size)\
    \ {\n            val diff = Math.abs(maxScoreEntry.getOrElse(game(i), 0) - guess(i))\n\
    \            if (diff != 0) {\n                result.add(i)\n            }\n\
    \        }\n        result", "        val maxScore = game.max\n        val minScore\
    \ = game.min\n        val maxGuess = guess.max\n        val minGuess = guess.min\n\
    \n        // Your code here\n        var finalScore = game.foldLeft(maxScore)\
    \ { \n            (a, b) => a \n        }\n        var finalGuess = guess.foldLeft(maxGuess)\
    \ { \n            (a, b) => a \n        }\n\n        while (finalScore < minScore\
    \ || finalScore > maxScore || finalGuess < minGuess || finalGuess > maxGuess)\
    \ {\n            finalScore = maxScore\n            finalGuess = maxGuess\n  \
    \      }\n\n        return List(finalScore)", "        var result: List[Long]\
    \ = Nil\n        val gameLen = game.size\n        val guessLen = guess.size\n\
    \        val guessRange = guessLen / 2\n        for (i <- guessRange.toLong to\
    \ guessLen + guessRange.toLong) {\n            val guessedCorrectly = game.contains(guess(i\
    \ + (game.size / 2 - guessRange)))\n            if (guessedCorrectly) {\n    \
    \            result = result :+ 0l.toLong\n            } else {\n            \
    \    result = result :+ (abs(guess(i) - game(i)) * (game.size - (game.size / 2\
    \ - guessRange))).toLong\n            }\n        }\n        result", "       \
    \ var result : List[Long] = List[Long](Nil)\n        var lastResult : List[Long]\
    \ = List[Long](Nil)\n        var gameCount : Long = 0\n        var lastGameCount\
    \ : Long = 0\n        var gameNumber : Int = 0\n        var lastGameNumber : Int\
    \ = 0\n        var lastGuessed : Long = -1\n        var currentGuessed : Long\
    \ = 0\n        var i : Int = 0\n        var j : Int = 0\n\n        while (i <\
    \ game.size && j < guess.size) {\n            if (game(i) == guess(j)) {\n   \
    \             gameCount += 1\n                currentGuessed += 1\n          \
    \  }\n            if (currentGuessed > lastGuessed) {\n                lastGuessed\
    \ = currentGuessed\n                if (lastResult == Nil) {\n               \
    \     lastGameCount = gameCount\n                    lastGameNumber = gameNumber\n\
    \                    lastResult = List[Long](game(i))\n                    result\
    \ = (gameNumber - lastGameNumber).map(x => x * lastGameCount + lastGuessed)\n\
    \                } else {\n                    lastResult = lastResult.map(x =>\
    \ x * gameCount + currentGuessed)\n                    result = lastResult.map(x\
    \ => x * gameCount + currentGuessed)\n                }\n            }\n     \
    \       i += 1\n            j += 1\n        }\n        if (game.size == 0 && guess.size\
    \ != 0) {\n            gameNumber += 1\n        }\n        if (game.size != 0\
    \ && guess.size == 0) {\n            gameNumber -= 1\n        }\n        return\
    \ result", "        if(game.size != guess.size){\n            throw new Error(\"\
    Lengths don't match\")\n        }\n        \n        var result: List[Long] =\
    \ Nil\n        var scoreDiff = game(0)\n        var guesser : List[Long] = guess\n\
    \        \n        while(game.nonEmpty) {\n            \n            var scoreDiff\
    \ = scoreDiff.min(game(0))\n            \n            if(guesser.nonEmpty){\n\
    \                scoreDiff = scoreDiff - guesser(0)\n                if(scoreDiff\
    \ < 0){\n                    scoreDiff = scoreDiff + game(0)\n               \
    \     guesser = guesser.drop(1)\n                }\n            }\n          \
    \  \n            result = result :+ scoreDiff\n            \n            if(game.size\
    \ != guesser.size){ // guess was wrong\n                guesser = guesser.drop(1)\
    \ // guesser will hold a guess that was wrong\n            }\n            \n \
    \           game = game.drop(1) // game will hold the next guess\n        }\n\
    \        \n        result", "        val diffs = mutable.ListBuffer.empty[Long]\n\
    \        var score = 0\n        for( i <- 0 to game.length - 1) {\n          \
    \  score += game(i)\n            if (guess(i) == game(i)) {\n                diffs\
    \ += 0\n            } else {\n                diffs += abs(guess(i) - game(i))\n\
    \            }\n        }\n        diffs", "        if (game.size != guess.size)\
    \ throw new RuntimeException(\"The two lists must have the same length.\")\n \
    \       var result = game.zip(guess).map(x => (x._1 - x._2).abs)\n        result.zipWithIndex.map\
    \ {\n        case (x, i) => if (x == 0) 0 else x\n        }.toList", '        //
    your code goes here', "        val result = game.zip(guess).map{ case (score:\
    \ Long, guess: Long) => math.abs(guess - score) }\n        val correct = game.zip(result).filter(\
    \ case (score: Long, result: Long) => result == 0l)\n        correct.map{ case\
    \ (guess: Long, result: Long) => guess - result }", "        val l = game.size\n\
    \        val r = guess.size\n        if (l == 0) return guess\n        if (l >\
    \ r) compare(guess, game.drop(l - r))\n        else {\n            val result\
    \ = new mutable.ArrayBuilder[Long](r)\n            for (i <- 0 until r)\n    \
    \            if (game(i) == guess(i)) result.updated(i, 0)\n                else\n\
    \                    result.updated(i, game(i) - guess(i)) + (if (game(i) < guess(i))\
    \ 1 else 0)\n            val ans = result.toList match {\n                case\
    \ List(1) -> 0\n                case _ -> result.sum\n            }\n        \
    \    result.toList\n        }", "        def getDiff(s1 : Long, s2 : Long) : Long\
    \ = {\n            if(s1 > s2) { s1 - s2 } else { s2 - s1 }\n        }\n     \
    \   var diff = 0\n        var result: List[Long] = Nil\n        var correct =\
    \ false\n        for(i <- 0 until game.size) {\n            if(game(i) == guess(i))\
    \ { correct = true }\n            diff += getDiff(game(i), guess(i))\n       \
    \     result = result :+ diff\n        }\n        if(correct) { List(0) } else\
    \ { result }", "        val gameSize   = game.length\n        val guessSize =\
    \ guess.length\n        val gameDiff = gameSize - guessSize\n        var newGuesses\
    \ : List[Long] = guess\n        var newScores  : List[Long] = game\n        val\
    \ tempList = newScores.init\n        val resultList = newGuesses.init\n      \
    \  var count = 1\n        while(count < gameSize && count < guessSize){\n    \
    \        var score : Long = 0\n            var guess : Long = 0\n            var\
    \ count : Long = 0\n            if(tempList.headOption.contains(guess))\n    \
    \        {\n                if(newScores.tail.isEmpty)\n                    score\
    \ = 0\n                else\n                    score = tempList.headOption.get.asInstanceOf[Long]\n\
    \                if(newGuesses.tail.isEmpty)\n                    guess = 0\n\
    \                else\n                    guess = newGuesses.headOption.get.asInstanceOf[Long]\n\
    \                val diff = (guess - score)\n                if(diff < 0)\n  \
    \              {\n                    score = -diff\n                }\n     \
    \           resultList += score\n                tempList += score\n         \
    \       count = count + 1\n            }\n        }\n        return resultList",
  "        var correctCount = 0\n        val gameScores = game.map(x => if (x > 0)\
    \ x; else -x).toList\n        val guessesScores = guess.map(x => if (x > 0) x;\
    \ else -x).toList\n        for (i <- 0 until gameScores.size) {\n            if\
    \ (gameScores(i) == guessesScores(i)) {\n                correctCount += 1\n \
    \           }\n        }\n        gameScores ++ guessesScores.map(x => Math.abs(x))",
  '        // Complete this method!', "        val guessesCount = guess.size\n   \
    \     val gamesCount = game.size\n        if (guessesCount == gamesCount) {\n\
    \            return game\n        } else {\n            var score = 0\n      \
    \      var g = 0\n            var c = 0\n            var gc = 1\n            var\
    \ guesses = mutable.Queue[Long]()\n            for (i <- 0 until guessesCount)\
    \ {\n                guesses.enqueue(guess(i))\n                val guessed =\
    \ g\n                g += 1\n                val guess = guesses.dequeue()\n \
    \               val score = game(guess)\n                if (score > 0) {\n  \
    \                  c += 1\n                } else {\n                    gc +=\
    \ 1\n                }\n            }\n            var diff = 0\n            if\
    \ (c == guessesCount) {\n                diff = 0\n            } else if (gc >\
    \ c) {\n                diff = c\n            } else {\n                diff =\
    \ gc\n            }\n            var list = new ArrayList[Long](guessesCount)\n\
    \            val list = list.asInstanceOf[List[Long]]\n            val list =\
    \ list.asInstanceOf[List[Long]]\n            var i = list.size\n            while\
    \ (i > 0) {\n                list.remove(i)\n                i -= 1\n        \
    \    }\n            list.add(guessesCount)\n            for (i <- 0 until diff)\
    \ {\n                list.add(0)\n            }\n            return list\n   \
    \     }", '        // TODO your answer goes here', "        // return an empty\
    \ list if the guess is empty\n        if(guess.isEmpty) List[Long]() else // otherwise,\
    \ calculate the difference between each guess and score\n            game.toList\
    \ zip guess\n            // zip returns the list of matching pairs and we take\
    \ the first element from each pair and\n            // subtract it from the guess\n\
    \            .map {\n                case (guess, score) => if (guess == score)\
    \ 0l else Math.abs(guess - score)\n            }\n            // map converts\
    \ each element in the list to a different type\n            // the elements before\
    \ are in fact (guess, score)\n            // the elements after are in fact either\
    \ 0l or absolute difference of guess and score\n            .map {\n         \
    \       case 0l => 0l\n                case diff => diff\n            }\n    \
    \        // The elements of the list are either 0l or diff. map converts each\
    \ element to either 0l or diff\n            // and then the list is flattened\
    \ into a list\n            .toList", "        // Avoid mutable data structures\
    \ \n        val gameScores = mutable.Map[Long, Long]()\n        for (i <- 0 until\
    \ game.length)\n            gameScores += (i -> game(i))\n        val guesses\
    \ = mutable.Map[Long, Long]()\n        for (i <- 0 until guess.length)\n     \
    \       guesses += (i -> guess(i))\n\n        val gameLen = gameScores.size\n\
    \        val guessLen = guesses.size\n        val result = new Array[Long](guessLen)\n\
    \        val gameWasCorrect = false // flag to indicate if all games had a correct\
    \ answer\n        // the result can be empty if the guesses match the scores\n\
    \        for (i <- 0 until guessLen)\n            result(i) = if (gameScores.contains(guesses(i)))\
    \ 0 else abs(guesses(i) - gameScores(guesses(i)))\n        // if all guesses match,\
    \ then all games were correct\n        if (!gameWasCorrect) result.fill(Math.abs(0l.toLong\
    \ - gameScores(0l.toLong)))\n        result", "        val scores =\n        \
    \    game ++\n            guess.distinct\n\n        // if they are the same length,\
    \ then they are correctly guessed.\n        if (game.length == guess.length)\n\
    \            scores -- guess.distinct\n        else scores.filter(_ < 0l).map(_\
    \ - game(0))\n", "        val gameCopy = game.deepCopy\n        val guessCopy\
    \ = guess.deepCopy\n        for (i1 <- 0 until guessCopy.size) {\n           \
    \ val i2 = i1 + 1\n            for (j1 <- 0 until guessCopy.size) {\n        \
    \        val j2 = j1 + 1\n                if (i1 == j1 && i2 == j2)\n        \
    \            continue\n                if (i1 == j1 || i2 == j1)\n           \
    \         gameCopy(i1) = gameCopy(i1) - guessCopy(j1)\n                else if\
    \ (i1 == j2 || i2 == j2)\n                    gameCopy(i1) = gameCopy(i1) + guessCopy(j1)\n\
    \                else\n                    gameCopy(i1) = gameCopy(i1) - guessCopy(j1)\
    \ - guessCopy(j2)\n            }\n        }\n        gameCopy.deepCopy", "   \
    \     val guessesSize = guess.size\n        val guessedSize = game.size\n    \
    \    val guessedCorrectly = mutable.Set.empty[Long]\n        for (i <- 0 until\
    \ guessesSize) {\n            val g = game(i)\n            val h = guess(i)\n\
    \            guessedCorrectly += if (g == h) 0 else Math.abs(g - h)\n        }\n\
    \        val guessedCorrectlySize = guessedCorrectly.size\n        val result:\
    \ mutable.List[Long] = if (guessedCorrectlySize == 0) 0 else guessedCorrectly\
    \ diff game\n        result.size", "        var correct = 0\n        var total\
    \ = 0\n        for (i <- 0 until guess.size)\n            total += guess(i)\n\
    \        for (i <- 0 until game.size)\n            correct += game(i)\n      \
    \  val list = guess.map(x => abs(x - correct)).sorted\n        val list2 = game.map(x\
    \ => abs(x - correct)).sorted\n        val ans = list.zip(list2).map(_._2 - _._2).sorted\n\
    \        ans", "        game.zip(guess).foldLeft(List[Long]()){ (res, v) =>\n\
    \            val diff = v._2 - v._1\n            if (diff < 0) res :+ v._2\n \
    \           else res :+ (v._1 - diff)\n        }", "        val score = game.reverse.foldLeft(0L)(\
    \ (acc, next) => {\n            if (guess contains next) acc + 1L else acc\n \
    \       })\n        // For each guess, if the guess is equal to the game, we're\
    \ off by one, otherwise it's off by more\n        val off = guess.map(guess =>\
    \ {\n            if (guess == game(0)) -1L\n            else guess.abs - score\n\
    \        })\n        // Return the list with the offsets of each guess in it\n\
    \        off.toList", "        // sort both lists\n        val sortedGame = game.sorted\n\
    \        val sortedGuess = guess.sorted\n        val numMatches = sortedGame.size\n\
    \        val numGuesses = sortedGuess.size\n        // create an array to store\
    \ the distance between each guess\n        val guesses = Array.ofDim[Double](numGuesses)\n\
    \        // create a mutable list to store the result\n        val result = new\
    \ mutable.ListBuffer[Long]()\n        // iterate over the guesses, updating the\
    \ distance to 0 if necessary\n        val i = 0\n        while (i < numGuesses)\
    \ {\n            val thisGuess = sortedGuess(i)\n            if (thisGuess ==\
    \ sortedGame(i)) {\n                guesses(i) = 0\n            } else {\n   \
    \             guesses(i) = math.abs(sortedGuess(i) - sortedGame(i))\n        \
    \    }\n            i += 1\n        }\n        // add all guesses to the result\
    \ list, sorted by distance from guess\n        result.addAll(guesses.sorted)\n\
    \        // done\n        return result.toList", "        // The function below\
    \ computes the score for a guess guess and a game game and returns the sum.\n\
    \        def score(game : List[Long], guess : List[Long]) : Double = game map\
    \ { score => if (guess == game) 0 else abs(guess - game) }.reduce(_ + _)\n   \
    \     // The function below generates a sequence of indices, and for each index\
    \ randomly chooses one of the values from the game list to put in that index position.\n\
    \        def chooseIndices(n : Int, game : List[Long]) : List[Int] = 0 until n\
    \ map { i => math.random choose game }.toList\n        // The function below randomly\
    \ chooses a value from the game list to put into the given index.\n        def\
    \ chooseValue(i : Int, game : List[Long]) : Long = game random chooseIndices\n\
    \        // The function below chooses a guess at random from the game list, and\
    \ inserts it into the game list. \n        def chooseGuess(game : List[Long])\
    \ : Long = game random chooseIndices\n        // The function below computes the\
    \ score of a given game. \n        def score(game : List[Long]) : Double = game\
    \ map { score => if (guess == game) 0 else abs(guess - game) }.reduce(_ + _)\n\
    \        // The function below generates a sequence of indices, and for each index\
    \ randomly chooses one of the values from the guess list to put in that index\
    \ position.\n        def chooseIndicesGuess(n : Int, guess : List[Long]) : List[Int]\
    \ = 0 until n map { i => math.random choose guess }.toList\n        // The function\
    \ below randomly chooses a value from the guess list to put into the given index.\n\
    \        def chooseValueGuess(i : Int, guess : List[Long]) : Long = guess random\
    \ chooseIndicesGuess(i, guess)\n        // The function below chooses a guess\
    \ at random from the guess list, and inserts it into the guess list.\n       \
    \ def chooseGuessGuess(guess : List[Long]) : Long = guess random chooseIndicesGuess(0,\
    \ guess)\n        // The function below computes the score of a given guess guess.\
    \ \n        def scoreGuess(guess : List[Long]) : Double = guess map { score =>\
    \ if (guess == game) 0 else abs(guess - game) }.reduce(_ + _)\n        // The\
    \ function below generates a sequence of indices, and for each index randomly\
    \ chooses one of the values from the game list to put in that index position.\n\
    \        def chooseIndicesGuess(n : Int, game : List[Long]) : List[Int] = 0 until\
    \ n map { i => math.random choose game }.toList\n        // The function below\
    \ randomly chooses a value from the game list to put into the given index.\n \
    \       def chooseValueGuess(i ", "        // your code here\n        ", '        game.zip(guess).map(p
    => p._1 - p._2)', "        game.zipWithIndex.filter(_._1 == guess.zipWithIndex).map(_._2).map\
    \ { case(score, index) =>\n            val delta = if (index == 0) 0l else abs(score\
    \ - guess(index))\n            delta\n        }", "        game match {\n    \
    \        case Nil => guess\n            case _ => {\n                val diff\
    \ = new mutable.ListBuffer[Long]()\n                val size = game.size\n   \
    \             var i = 0\n                while (i < size && i < guess.size) {\n\
    \                    diff += Math.abs(game(i) - guess(i))\n                  \
    \  i += 1\n                }\n                diff.take(guess.size).take(game.size).toList\n\
    \            }\n        }", "        val scoreMap = game.toMap\n        val guessedMap\
    \ = guess.toMap\n        guessedMap.foreach {\n            case (guess, score)\
    \ => (guess, score)\n        }\n        game.zip(guess).map {\n            case\
    \ (score, _) => score\n        }.zipWithIndex.foreach {\n            case (score,\
    \ index) =>\n                val guess = guessedMap(index)\n                val\
    \ result = if (guess == score) 0 else abs(guess - score)\n                guessedMap.update(index,\
    \ result)\n        }\n        guessedMap.values.toList", "        var result:\
    \ List[Long] = game.map{t => 0l}\n        // For each match, we will see if the\
    \ guess is close enough to the score\n        // If so, we'll mark it as correct.\n\
    \        var correct = 0\n        var lastCorrect = 0\n        for (i <- 0 to\
    \ game.length - 1) {\n            if (game(i) == guess(i)) {\n               \
    \ correct += 1\n            }\n            else {\n                if (correct\
    \ > 1) {\n                    val difference = guess(i) - game(i)\n          \
    \          val absDifference = math.abs(difference)\n                    // if\
    \ the difference is greater than the last correct\n                    if (absDifference\
    \ > lastCorrect) {\n                        // We have missed a lot!\n       \
    \                 // Set the correct counter to 0\n                        correct\
    \ = 0\n                        // Set the difference counter to the last correct\
    \ guess\n                        lastCorrect = absDifference\n               \
    \     }\n                }\n                lastCorrect = 0\n                correct\
    \ += 1\n            }\n            // Set the ith result to 0 if it was previously\
    \ correct\n            result(i) = if (result(i) > 0) 1l.toLong else 0l.toLong\n\
    \        }\n        return result", "        // Write your code here\n       \
    \ val result = mutable.ArrayBuffer.empty[Long]\n        val correct = mutable.Set[Long]()\n\
    \        for (h <- 0 until guess.size)\n            if(game.contains(guess(h)))\n\
    \                correct += guess(h)\n        if(correct.isEmpty) result else\
    \ result ++= correct.map((-_))\n        result", "        // 1. Get a list of\
    \ all possible pair-wise differences.\n        // We call pairs to mean a pair\
    \ of values from both lists\n        val pairs = for ( a <- game.indices; b <-\
    \ game.indices if b < a) yield (a,b) diff guessed\n\n        // 2. Get the absolute\
    \ difference\n        val differences = pairs map {case (a,b) => Math.abs(game(a)\
    \ - guess(b)) }\n\n        // 3. Return the results\n        differences.toList",
  "        if (guess.size == game.size) guess.zip(game).collect { case (x: Long, y:\
    \ Long) => Math.abs(x - y) }.toList\n        else guess", "        val r = game.zip(guess).map\
    \ { case (h, g) => (h - g) }.sum\n        if(r == 0) {\n            List(game.length)\n\
    \        } else {\n            List(r.toLong)\n        }", "      val guesses\
    \ = mutable.LinkedHashSet[Long](guess.toSeq)\n      var i = 0\n      var j = 0\n\
    \      val results = (game.toSeq.zip(guess).toList)\n        .filter(_._2.toLong\
    \ > _._1.toLong)\n        .map(_._2)\n      val correct = game.toSeq.zip(guess).toList\n\
    \        .map(_._2.toLong == _._1.toLong)\n        .reduce((x, y) => x || y)\n\
    \      for(result <- results) {\n        if(correct) {\n          i += 1\n   \
    \     } else {\n          j += result.abs\n        }\n      }\n      if(correct\
    \ || i == game.length) {\n        results.toList\n      } else {\n        List(i.toLong,\
    \ j.toLong)\n      }", "        // TODO: Write the code here\n        var i =\
    \ 0\n        var j = 0\n        var correct = 0\n        var wrong = 0\n     \
    \   val len = game.size\n        var sum = 0\n        while i < len && j < len\
    \ {\n            if(game(i) == guess(j)) {\n                sum += game(i)\n \
    \               i += 1\n                j += 1\n            } else if(game(i)\
    \ != guess(j)) {\n                wrong += abs(game(i)-guess(j))\n           \
    \     i += 1\n            } else {\n                correct += abs(game(i)-guess(j))\n\
    \                i += 1\n                j += 1\n            }\n        }\n  \
    \      if(correct == 0) {\n            List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong)\n        }\n        if(wrong == 0){\n     \
    \       List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)\n\
    \        }\n        else{\n            List[Long](abs(sum-correct), abs(sum-wrong),\
    \ abs(sum-correct), abs(sum-wrong))\n        }", "        // TODO: Implement your\
    \ code\n        return game", "        // Sort both lists on first element in\
    \ list.\n        val gs = game.zipWithIndex.toList.sortBy(_._1).reverse\n    \
    \    val gm = guess.zipWithIndex.toList.sortBy(_._1).reverse\n        val gs1\
    \ = gs.map(a => (a._2 + 1, a._1))\n        val gm1 = gm.map(a => (a._2 + 1, a._1))\n\
    \        var j = 0\n        var i = 0\n        var list: List[Long] = Nil\n  \
    \      while i < gs.length && j < gm.length {\n            list ::= (gs1.get(i)._1\
    \ - gm1.get(j)._1)\n            i += 1\n            j += 1\n        }\n      \
    \  if (i < gs.length)\n            list ::= (gs1.get(i)._1 - gm1.get(j)._1)\n\
    \        if (j < gm.length)\n            list ::= (gs1.get(i)._1 - gm1.get(j)._1)\n\
    \        list.reverse", "        val difference = game.zip(guess)\n        val\
    \ result = difference.foldLeft(List.empty[Long]){ case (result, (a,b)) => result\
    \ ::\n            List.fill(abs(a-b))(a-b).sum\n        }\n        result", " \
    \       // Write your code in here\n        var result = new mutable.ArrayList[Long]()\n\
    \        var guess = 0\n        var score = 0\n        val count = game.length\n\
    \        var correct = 0\n\n        while (guess < count){\n            val gameScore\
    \ = game(guess)\n            val guessesScore = guess(guess)\n            if (gameScore\
    \ == guessesScore){\n                correct += 1\n                score += 1\n\
    \            }\n            else {\n                result += (guess - correct)\n\
    \                guess += 1\n            }\n        }\n        result", "    \
    \    val result: List[Long] = game.map(_.toInt)\n            .zip(guess)\n   \
    \         .map {\n                case (a, b) => if(a == b) 0 else math.abs(a\
    \ - b)\n            }\n        result", "        var g : List[Long] = game\n \
    \       var gIndex : List[Long] = game\n        var gIndexGuessed : mutable.ListBuffer[Long]\
    \ = new mutable.ListBuffer[Long]()\n        var gIndexGuessedIndex : List[Long]\
    \ = game\n        var guessed : mutable.ListBuffer[Long] = new mutable.ListBuffer[Long]()\n\
    \        var guessedIndex : List[Long] = game\n        var gGuessed : mutable.ListBuffer[Long]\
    \ = new mutable.ListBuffer[Long]()\n        var gGuessedIndex : List[Long] = game\n\
    \        var gameGuessed : mutable.ListBuffer[Long] = new mutable.ListBuffer[Long]()\n\
    \        var gameGuessedIndex : List[Long] = game\n        var gGuessedMatch :\
    \ mutable.ListBuffer[Long] = new mutable.ListBuffer[Long]()\n        var gGuessedMatchIndex\
    \ : List[Long] = game\n        var gGuessedMatchIndexGuessed : mutable.ListBuffer[Long]\
    \ = new mutable.ListBuffer[Long]()\n        var gGuessedMatchIndexGuessedIndex\
    \ : List[Long] = game\n        var gGuessedMatchIndexGuessedIndexGuessed : mutable.ListBuffer[Long]\
    \ = new mutable.ListBuffer[Long]()\n        var gGuessedMatchIndexGuessedIndexGuessedIndex\
    \ : List[Long] = game\n        var gGuessedMatchIndexGuessedIndexGuessedIndexGuessed\
    \ : mutable.ListBuffer[Long] = new mutable.ListBuffer[Long]()\n        var gGuessedMatchIndexGuessedIndexGuessedIndexGuessedIndex\
    \ : List[Long] = game\n        var gGuessedMatchIndexGuessedIndexGuessedIndexGuessedIndexGuessed\
    \ : mutable.ListBuffer[Long] = new mutable.ListBuffer[Long]()\n        var gGuessedMatchIndexGuessedIndexGuessedIndexGuessedIndexGuessedIndex\
    \ : List[Long] = game\n        var gGuessedMatchIndexGuessedIndexGuessedIndexGuessedIndexGuessedIndexGuessed\
    \ : mutable.ListBuffer[Long] = new mutable.ListBuffer[Long]()\n        var gGuessedMatchIndexGuessedIndexGuessedIndexGuessedIndexGuessedIndexGuessedIndex\
    \ : List[Long] = game\n        var gGuessedMatchIndexGuessedIndexGuessedIndex",
  "        val diffList = new mutable.MutableList[Long]()\n        game foreach {\
    \ score =>\n            guess foreach { guess =>\n                val diff = abs(guess\
    \ - score)\n                diffList.append(diff)\n            }\n        }\n\
    \        diffList.toList", "        val guesses = gues\n        .groupBy(i =>\
    \ (gte (i), guess map ((j, i) => j - i)))\n        .mapValues(_.map(_._2).sum)\n\
    \        .filter(_._2 == 0l)\n        .map(_._1)\n        .toList\n        val\
    \ scores = game\n        .groupBy(i => (gte (i), guess map ((j, i) => j - i)))\n\
    \        .mapValues(_.map(_._2).sum)\n        .filter(_._2 > 0l)\n        .map(_._1)\n\
    \        .toList\n        guesses.zip(scores)", "        val gm = game.toSet\n\
    \        val gs = guess.toSet\n        val guesses = gm.filter (gs contains _)\n\
    \        if (guesses.size != game.size) {\n            val diffs = guesses.map\
    \ (guess - game)\n            List(guesses.size)\n        }\n        else {\n\
    \            diffs\n        }", "        val score = game.toSet.intersect(guess.toSet)\n\
    \        game.zip(guess).map { case (score1,score2) => score1 - score2 }.zip(score).map\
    \ { case (a,b) => if (a == b) 0 else abs(a-b) }", "        val gameScores = game.zipWithIndex.map\
    \ { case (score, index) => (score, index) }\n        val guessScores = guess.zipWithIndex.map\
    \ { case (score, index) => (score, index) }\n        val differences = guessScores\
    \ diff gameScores\n        differences.map(difference => {\n            if (guess(difference._1)\
    \ < game(difference._2)) 0\n            else Math.abs(guess(difference._1) - game(difference._2))\n\
    \        })", "        val matchCount = game.length\n        var sum = 0\n   \
    \     var numGuessesNotCorrect = 0\n        for (i <- 0 until matchCount) {\n\
    \            if (guess(i) != game(i)) {\n                num += 1\n          \
    \      sum += game(i) - guess(i)\n            } else {\n                numGuessesNotCorrect\
    \ += 1\n            }\n        }\n        sum / matchCount", "        val numGuesses\
    \ = guess.size\n        val numScores = game.size\n        val result = new ArrayList[Long](numGuesses)\n\
    \        val scoreArray = game.zip(guess).map { case (g,gs) => gs - g }\n    \
    \    val numCorrect = scoreArray.filter(x => x == 0).size\n        val numCorrectPerGuess\
    \ = scoreArray.filter(x => x == 0).size / numGuesses\n        for (i <- 0 until\
    \ numGuesses) {\n            if (numCorrect == i) {\n                result(i)\
    \ = numCorrectPerGuess\n            } else {\n                val diff = abs(scoreArray(i)\
    \ - scoreArray(i-numCorrect))\n                result(i) = diff\n            }\n\
    \        }\n        result", "        val score = game.toList.foldLeft(0L) { case\
    \ (a,b) => (if (b < a) a else b) }\n        val guess = guess.toList.foldLeft(0L)\
    \ { case (a,b) => (if (b < a) a else b) }\n        guess.length match {\n    \
    \        case 0 => game.length\n            case _ => guess match {\n        \
    \        case a if a == 0L => game.length\n                case _ if a > 0L =>\
    \ guess - score\n                case _ if a < 0L => -guess + score\n        \
    \    }\n        }", "        def diff(x: List[Long], y: List[Long]) : List[Long]\
    \ = {\n            if (x.isEmpty) y.toList\n            else x.map(x => if (x\
    \ < y) x else y).reduceLeft((x, y) => if (x == y) x else x - y)\n        }\n\n\
    \        if (game.isEmpty) guessedCorrectly(guess, 0)\n        else game.map(x\
    \ => if (x == guess(0)) 0 else diff(game - x, guess - x)).distinct", "       \
    \ val gameLen = game.size\n        val guessLen = guess.size\n        val gameScores\
    \ = game.zipWithIndex.filter { case (s, _) => s == 1 }\n        val guessScores\
    \ = guess.zipWithIndex.filter { case (s, _) => s == 1 }\n\n        // We start\
    \ by comparing all guesses to all game scores\n        // and as soon as one matches,\
    \ we return that index\n        val resultIndices = Array.ofDim[Int](guessLen)\n\
    \        var i = 0\n        var gScore = 0\n        gameScores.foreach { case\
    \ (s, i) => gScore = s}\n        guessScores.foreach { case (s, i) => resultIndices(i)\
    \ = i}\n        i <- 0 until guessLen\n        val gScore = gameScores(i)\n  \
    \      if (gScore == 1) resultIndices(i)\n        else {\n            val result\
    \ = guessScores(i) - gScore\n            resultIndices(i) = result\n         \
    \   for (j <- 0 until guessLen) {\n                if (resultIndices(j) != i)\
    \ {\n                    resultIndices(i) = result\n                    break\n\
    \                }\n            }\n        }\n\n        // Now we look at the\
    \ remainder of the guesses to see which game scores match the guess\n        var\
    \ i = 1\n        gameScores.foreach { case (s, i) => if (s == gameScores(i)) {\
    \ resultIndices(i) = i} }\n        guessScores.foreach { case (s, i) => if (s\
    \ == guessScores(i)) { resultIndices(i) = i} }\n\n        // Now we just return\
    \ the list of scores corresponding to the matches\n        resultIndices.toList",
  "        var correct : List[Long] = List(1l.toLong)\n        var mismatch : List[Long]\
    \ = List(1l.toLong)\n        var index = 0\n        while(index < game.length){\n\
    \            var currentGuess = guess.take(index).toList\n            var currentScore\
    \ = game.take(index).toList\n            var total = 0\n            for(i <- 0\
    \ until currentGuess.length){\n                total += abs(currentGuess(i) -\
    \ currentScore(i))\n            }\n            if(total == currentScore.length){\n\
    \                correct += List(1l.toLong)\n            } else {\n          \
    \      mismatch += List(1l.toLong)\n            }\n            index += 1\n  \
    \      }\n        correct.reverse\n        mismatch.reverse", "        var totalDiff\
    \ = 0\n        var numGuesses = 0\n        val gameList = mutable.ArrayBuffer.empty[Long]\n\
    \        val guesses = mutable.ArrayBuffer.empty[Long]\n        for (i <- 0 until\
    \ game.size) {\n            val difference = abs(game(i) - guess(i))\n       \
    \     if (difference <= gameList.length)\n                gameList += difference\n\
    \            else\n                gameList.cons(difference)\n        }\n    \
    \    for (i <- 0 until guess.size) {\n            val difference = abs(guess(i)\
    \ - gameList(i))\n            if (difference <= guesses.length)\n            \
    \    guesses += difference\n            else\n                guesses.cons(difference)\n\
    \        }\n        gameList.zipWithIndex.map { case (difference, i) => difference\
    \ * i }.toList", "        var list = new scala.collection.mutable.ListBuffer[Long]()\n\
    \        for (i <- 0 until game.length)\n            if (game(i) == guess(i))\n\
    \                list += 0\n            else {\n                var diff = Math.abs(game(i)\
    \ - guess(i))\n                list += diff * (diff < 0 ? -1 : 1)\n          \
    \  }\n        list.toList", "        val n = game.size\n        val matches =\
    \ mutable.ArrayBuffer(game.size)\n        var correct = 0\n        var diff =\
    \ 0\n        var i = 0\n        for (score <- game) {\n            if (guess(i)\
    \ == score) {\n                correct = correct + 1\n                diff = 0\n\
    \            } else {\n                diff = diff + abs(score - guess(i))\n \
    \           }\n            i = i + 1\n        }\n        val guesses = mutable.ArrayBuffer(guess)\n\
    \        val scores = mutable.ArrayBuffer(game)\n        var j = 0\n        while\
    \ (j < guesses.size) {\n            if (guesses(j) == scores(j)) {\n         \
    \       correct = correct + 1\n                diff = 0\n            } else {\n\
    \                diff = diff + abs(guesses(j) - scores(j))\n            }\n  \
    \          j = j + 1\n        }\n        if (correct == n) {\n            List[Long](0l.toLong)\n\
    \        } else {\n            List[Long](diff)\n        }", "        var scores\
    \ : List[Long] = game\n        var guesses : List[Long] = guess\n        var numGuesses\
    \ : Int = 0\n        var index = 0\n        while index < guesses.size{\n    \
    \        val score: Long = scores.apply(index).toLong\n            val guess:\
    \ Long = guesses.apply(index).toLong\n            val diff = abs(guess - score)\n\
    \            if(diff < 0){\n                // the guess is too far off\n    \
    \            guesses = guesses.drop(index)\n                numGuesses = numGuesses\
    \ + 1\n            }\n            index = index + 1\n        }\n        guesses",
  "        val diff = game.zip(guess)\n        diff.foldLeft(List[Long](0))(\n   \
    \             (e, s) => e match {\n                    case (a: Long, b: Long)\
    \ => if (Math.abs(a.toLong - b) == 0) 0\n                                    \
    \    else if (Math.abs(a.toLong - b) < 1) a.toLong - b\n                     \
    \                   else a.toLong - b.abs()\n                }\n            )",
  "        val map = mutable.HashMap[Long, Long]()\n        for (i <- 0 until game.size)\
    \ {\n            val val = game.drop(i).sum\n            if (guess contains val)\
    \ {\n                map += ((game.drop(i).sum, i))\n            }\n        }\n\
    \        map.toList.map(_._1).zipped.map(_ - game(_._2))", "        // Write your\
    \ solution here!\n        val map = new mutable.HashMap[Long, Int]\n        \n\
    \        for(i <- game.indices) {\n            val score = game(i)\n         \
    \   val guess = guess(i)\n            \n            if(map.contains(guess) &&\
    \ map.get(guess) == score) map.remove(guess)\n            else map.put(guess,\
    \ score)\n        }\n        \n        val list = map.values.toList\n        list.sortWith(_\
    \ < 0)", "        var gameScore = 0\n        val gameLength = game.size\n    \
    \    val guessLength = guess.size\n        var gameIndex = gameLength - 1\n  \
    \      var guessIndex = guessLength - 1\n        val resultList : List[Long] =\
    \ for (gameIndex >= 0; gameIndex >= 0; gameIndex -= 1){\n            var gameScoreTemp\
    \ = 0\n            var guessScoreTemp = 0\n            for (guessIndex >= 0; guessIndex\
    \ >= 0; guessIndex -= 1){\n                if (game(gameIndex) == guess(guessIndex))\
    \ {\n                    gameScoreTemp = gameScoreTemp + 1\n                 \
    \   guessScoreTemp = guessScoreTemp + 1\n                }\n            }\n  \
    \          if (gameScoreTemp == guessScoreTemp) {\n                gameScore =\
    \ gameScore + 1\n            }\n        }\n        resultList", '        game.zip(guess).filter{case
    (sc, gc) => sc.equals(gc)}.map{case (sc, gc) => sc.abs - gc}.flatten', "     \
    \   var result: List[Long] = Nil\n        val gameSize = game.size\n        val\
    \ guessSize = guess.size\n        val matchScore = game.zip(guess).foldLeft(0l)\
    \ { (acc, _) =>\n            val score = (_._1 - _._2).abs\n            acc +\
    \ (score - acc.toLong)\n        }\n        // if there are more games than guesses,\
    \ just compare them all to the guess\n        if (guessSize > gameSize) result\
    \ = (0.until(guessSize)).map(guess => (guess, gameSize)).sortWith((a, b) => a._2\
    \ < b._2).map(_._1).flatMap(_.zip(game).map(x => x._1 - x._2))\n        else {\n\
    \            // if there are less games than guesses, try to score the guesses\n\
    \            val guessMap = (0 until (guessSize - gameSize)).map(guess => (guess,\
    \ guessSize)).sortWith((a, b) => a._1 < b._1).map(_._2)\n            val gameMap\
    \ = (0 until (gameSize - guessSize)).map(game => (game, guessSize)).sortWith((a,\
    \ b) => a._1 < b._1).map(_._2)\n            // game map has all guesses scored,\
    \ but not necessarily ordered from least to greatest\n            val scores =\
    \ gameMap.zip(guessMap).foldLeft(List.empty[Long]) { case (acc, (game, guess))\
    \ =>\n                var maxScore = -1l\n                for (x <- game.toInt)\
    \ {\n                    // find the max score from all possible guesses, starting\
    \ with max\n                    val maxScore = acc match {\n                 \
    \       case Nil => 0l\n                        case _ =>\n                  \
    \          (gameSize - guess) - x match {\n                                case\
    \ 0 => acc.last\n                                case n => acc drop n\n      \
    \                      }\n                    }\n                    // find the\
    \ score from all possible guesses, starting with score\n                    val\
    \ score = acc match {\n                        case Nil => 0l\n              \
    \          case _ =>\n                            (gameSize - guess) - x match\
    \ {\n                                case 0 => acc.last\n                    \
    \            case n => acc drop n\n                            }\n           \
    \         }\n                    // if the score is higher than the max, add the\
    \ guess to the guesses list and add the score\n                    if (score >\
    \ maxScore) acc :+ (guess - game) :: Nil\n                    else if (score ==\
    \ maxScore) acc :+ (guess - game) :: Nil\n                    else acc :+ (guess\
    \ - game) :: acc drop 1\n                }\n                acc\n            }\n\
    \            // if the guesses were already scored, just append the score", " \
    \       // First sort each list\n        val gameWithOrder = game.zipWithIndex.sortBy(_._1).zipWithIndex.toList\n\
    \        val guessWithOrder = guess.zipWithIndex.sortBy(_._1).zipWithIndex.toList\n\
    \        // Then count how many guesses are correct and which are not\n      \
    \  var correctedGuessCount : Int = 0\n        var incorrectGuessCount : Int =\
    \ 0\n        var correctedGuess : Long = 0\n        var incorrectGuess : Long\
    \ = 0\n        for (gameIndex, guessIndex) <- gameWithOrder, guessWithOrder {\n\
    \            val gameScore = game(gameIndex)\n            val guessScore = guess(guessIndex)\n\
    \            if (gameScore == guessScore) {\n                correctedGuessCount+=1\n\
    \                correctedGuess+=gameScore\n            } else {\n           \
    \     incorrectGuessCount+=1\n                incorrectGuess+=gameScore-guessScore\n\
    \            }\n        }\n        // Then compute the scores\n        var correctedGuessSum\
    \ : Long = correctedGuess\n        var incorrectGuessSum : Long = incorrectGuess\n\
    \        for (guessIndex, gameIndex) <- guessWithOrder, gameWithOrder {\n    \
    \        val gameScore = game(gameIndex)\n            val guessScore = guess(guessIndex)\n\
    \            if (gameScore == guessScore) {\n                correctedGuessSum\
    \ -= gameScore\n                incorrectGuessSum -= guessScore\n            }\
    \ else {\n                val deltaScore = gameScore - guessScore\n          \
    \      correctedGuessSum+=deltaScore\n                incorrectGuessSum+=deltaScore\n\
    \            }\n        }\n        List(correctedGuessCount.toLong, incorrectGuessCount.toLong,\
    \ correctedGuessSum.toLong, incorrectGuessSum.toLong)"]
stop_tokens:
- "\n    }\n"
