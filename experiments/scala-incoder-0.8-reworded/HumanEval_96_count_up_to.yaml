name: HumanEval_96_count_up_to
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Implement a function that takes an non-negative integer and returns a list\
  \ of the first n\n    // integers that are prime numbers and less than n.\n    //\
  \ for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n\
  \    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong,\
  \ 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n\
  \    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong,\
  \ 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n\
  \    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong,\
  \ 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) :\
  \ List[Long] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong,\
  \ 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong,\
  \ 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong,\
  \ 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong,\
  \ 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n\
  \    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong,\
  \ 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n\
  \    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong,\
  \ 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong,\
  \ 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong,\
  \ 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n\
  \    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong,\
  \ 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong,\
  \ 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong,\
  \ 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong,\
  \ 97l.toLong))));\n    }\n\n}\n"
completions: ["        val numbers = scala.collection.mutable.ListBuffer[Long]()\n\
    \        var counter = 2\n        var last = 2\n        while(counter < n) {\n\
    \            counter = counter * 2\n            numbers ++= last\n           \
    \ last = last.zip(counter).map {case (a,b) => b}.toList\n        }\n        numbers",
  "        val counts = mutable.Map.empty[Long,Int]\n        for (i <- 2l*i.toLong\
    \ to n) { if (i.toLong == n) Nil else counts(i) = counts(i) + 1l*counts(i).toLong}\n\
    \        counts.filter { case (v, k) => v >= 2 && v < n }.toList.sortBy(_._1).toList",
  "        val count = mutable.List[Long]()\n        for (i <- 2 to n) \n        \
    \    if ((i.toInt % 2) == 0) count.add(i)\n            else \n               \
    \ for (j until i.toInt by i.toInt) \n                    if ((j.toInt % 2) ==\
    \ 0) \n                        count.add(j)\n                        else \n \
    \                           count.remove(i)\n        count.toList", "        var\
    \ primesFound = 0\n        var list: List[Long] = Nil\n        var currentPrime\
    \ = 2\n        var currentPrimeFound = false\n\n        for(i <- 1 to n) {\n \
    \           currentPrimeFound = false\n            for(ii <- 1 to currentPrime)\
    \ {\n                currentPrimeFound =  n % currentPrime == 0\n            \
    \    if(currentPrimeFound) {\n                    primesFound = primesFound +\
    \ 1\n                    currentPrime = 2\n                    break\n       \
    \         }\n                currentPrime = currentPrime + 1\n            }\n\
    \            if(!currentPrimeFound) {\n                primesFound = primesFound\
    \ + 1\n                list = list :+ i\n            }\n        }\n        if(primesFound\
    \ == 0) {\n            list = Nil\n        }\n        list", "        val primes\
    \ = mutable.Set[Long]()\n        for (i <- 2 to n) if (!primes.contains(i)) {\n\
    \            val nextPrime = isPrime(i)\n            if (nextPrime) primes +=\
    \ i\n        }\n        primes.take(n).toList", "      val primes = List[Long](2,\
    \ 3, 5)\n      val counts = mutable.HashMap[Long, Int]()\n      for (i <- primes)\
    \ {\n        if(n <= i) counts += (n->0)\n        else if(n == i || n % i == 0)\
    \ {\n          counts(i) = counts.getOrElse(i, 0) + 1\n          if(counts(i)\
    \ <= counts.getOrElse(n,0)) {\n            n += 1\n            counts += (n->0)\n\
    \          }\n        }\n      }\n      val result = counts(n-1).map(k=>k.asInstanceOf[Long])\n\
    \      result.flatten.filterNot(k=>k==1)", "        val l = scala.collection.mutable.ListBuffer[Long]()\n\
    \        for (i <- 0 until n) if (!isPrime(i)) l += i\n        l.toList", "  \
    \      val nums = 0 #:: 1 #:: 2 #:: 3 #:: 5 #:: 7 #:: 11 #:: 13 #:: 17 #:: 19\
    \ #:: n #:: n\n        val resNums = nums.takeWhile((num: Long) => nums.forall((nums:\
    \ Long) => num != nums))\n        resNums.toList.sortWith((num: Long) => num >\
    \ n)", "        require(n >= 0, \"n must be greater than 0.\")\n        val result\
    \ = mutable.ArrayBuffer.empty[Long]\n        val isPrime = (n: Long) => {\n  \
    \          require(n > 0, \"n must be greater than 0.\")\n            require(n\
    \ == 1 || n % 2 == 0, \"n must be odd.\")\n            val a = 2\n           \
    \ a until Math.sqrt(n) match {\n                case nt if nt > a => (n / nt)\
    \ until n / a match {\n                    case nt if nt <= a => (a until nt /\
    \ a map {\n                            nt => nt % a\n                        })\
    \ filter (_ == 0) map {\n                            nt => nt + 1\n          \
    \              }\n                    case _ => List()\n                }\n  \
    \              case _ => List()\n            }\n        }\n        if (isPrime(n))\
    \ {\n            result += n\n            n / 2 match {\n                case\
    \ nt if nt > 1 => result :+ n\n                case _ => ()\n            }\n \
    \       }\n        n / 2 match {\n            case nt if nt > 1 => result :+ n\n\
    \            case _ => ()\n        }\n        if (n > 2) result :+ (n / 2)\n \
    \       result.toList", "        val primeList: List[Long] = 2 until Math.sqrt(n).toInt\n\
    \        val primeNums: List[Long] = primeList.filter(p => n / p > 1)\n\n    \
    \    if (primeNums.isEmpty) {\n            return List()\n        }\n        val\
    \ n = n - primeNums.last\n        val nextPrimes = primeNums.filter(_ != n).map(p\
    \ => (n, p))\n        val finalList: List[Long] = primeNums.flatMap(p => nextPrimes.filter(_._1\
    \ == p).map(p => p -> n)).flatten.toList\n        finalList.sortBy(x => (x))",
  "        def check(i: Long) : Boolean = {\n            val p = prime(i);\n     \
    \       if (i == n) {\n                return true;\n            }\n         \
    \   if (p != 1) {\n                check(i + 1)\n            } else {\n      \
    \          return false;\n            }\n        }\n        val list = List(n);\n\
    \        list(0) = 0;\n        for (i <- 1 to list.size) {\n            if (check(i))\
    \ {\n                list(i)\n            } else {\n                list(0)\n\
    \            }\n        }", "        val primes = PrimeLists.primes\n        val\
    \ lowPrimes = PrimeLists.lowPrimes\n        val list = mutable.ArrayBuffer(nl.toLong)\n\
    \        var i = 0\n        var j = 0\n        while (nl.toLong > i) {\n     \
    \       val prime = primes(i)\n            val lowPrime = lowPrimes(i)\n     \
    \       var isPrime = true\n            while (prime.isPrime && (prime.toLong\
    \ < n)) {\n                prime = primes(prime.toLong)\n                isPrime\
    \ = true\n            }\n            if (prime.isPrime && !isPrime)\n        \
    \        i += 1\n            else {\n                j += 1\n                if\
    \ (j > highPrimes(i)) {\n                    list += lowPrimes(i)\n          \
    \          j += 1\n                }\n            }\n        }\n        list +=\
    \ lowPrimes(i)\n        list.toList", "        // Your code here\n        val\
    \ l = 2l\n        var ls = List.empty[Long]\n        for(x <- 2 until n){\n  \
    \          if(l % x == 0) ls = ls :+ x\n            l = l + 1\n        }\n   \
    \     ls.toList", "        (1 to n).flatMap { x => \n            val l = new collection.mutable.ListBuffer[Long]()\n\
    \            x foreach { i =>\n                if (isPrime(i) && i < n) l += i\n\
    \            }\n            l\n        }", "        val list = new mutable.ArrayBuffer[Long]()\n\
    \        for (i <- 2l..n) {\n            val p = (i / 2) match {\n           \
    \     case 0 => false\n                case _ => isPrime(i)\n            }\n \
    \           if (p) list.toList ::= i\n        }\n        list.toList", "     \
    \   val primes = mutable.PriorityQueue[Long]()\n        val factors = mutable.PriorityQueue[Long]()\n\
    \        primes += 2\n        factors += 2\n        factors += 3\n        factors\
    \ += 5\n        factors += 7\n        primes.foreach {p =>\n            if (n%p\
    \ == 0) factors += p\n        }\n        while (factors.length != 0) {\n     \
    \       primes.enqueue(factors.dequeue());\n        }\n        primes.toList",
  "        if(n < 2l) {\n            List()\n        }\n        else {\n         \
    \   var primes : List[Long] = List()\n            for(x <- 2 until (2l)) {\n \
    \               if(n % x == 0l) {\n                    primes ::= x\n        \
    \        }\n            }\n            primes\n        }", "        val primes\
    \ = mutable.ArrayBuffer.empty[Long]\n        val max = (n /: 1).toLong\n     \
    \   for (num <- 2 to max) {\n            if (num % prime == 0) {\n           \
    \     primes += num\n            }\n        }\n        if (primes.size == 0) {\n\
    \            List[Long]()\n        } else {\n            List[Long](primes.last.toLong)\n\
    \        }", "        val list = List[Long]()\n        for(i <- 2l..n-1) {\n \
    \           if((i.toInt % 2l) != 0) {\n                if(list.isEmpty || (i >\
    \ (list._1+list._2)/2))\n                    list :+= i \n            }\n    \
    \    }\n        list.toList", "        val count = mutable.Buffer[Long]()\n  \
    \      for (i <- 2l to n by 2l) if (n % i == 0) count(i :: count)\n        count.toList",
  "        val result = new mutable.MutableList[Long]\n        for (i <- 2 until n)\
    \ {\n            if (i.isPrime) {\n                result += i\n             \
    \   if (result.size < n) result ++= Seq(i)\n            }\n        }\n       \
    \ result.take(n)", "        val nums = List() // create an empty list\n      \
    \  val primes = ArrayList() // create a prime list from 2 to n\n        for(i\
    \ <- 2 to n) {\n            // if n is divisible by any prime number less than\
    \ n, then n is divisible by all the primes\n            // and we don't have to\
    \ check the remainder of n by any of them\n            for(p <- primes if n %\
    \ p == 0) {\n                nums = nums :+ i\n                break // no need\
    \ to check the remainder of n by any of them\n            }\n        }\n     \
    \   nums.toList", "        var list: List[Long] = List()\n        var prime: Boolean\
    \ = false\n        var i: Long = 1\n        var j: Long = 2\n        while (i\
    \ < n) {\n            prime = true\n            for (j <- 2 to Math.sqrt(i)) {\n\
    \                if (i % j == 0) {\n                    prime = false\n      \
    \              break\n                }\n            }\n            if (prime)\
    \ {\n                list :+= j\n            }\n            i += 1\n        }\n\
    \        return list", "        val list = mutable.ListBuffer(2l.toLong)\n   \
    \     for( x <- 3l to n) list+=((x-1).toLong)\n        list.distinct", "     \
    \   def isPrime(n: Long) : Boolean =\n            for (i <- 0 until Math.sqrt(n))\
    \ {\n                if (n % i == 0)\n                    return false\n     \
    \       }\n            true\n\n        val primes = scala.collection.mutable.ListBuffer[Long]()\n\
    \        val limit = (2l to n).toList\n        for (i <- limit) {\n          \
    \  if (!isPrime(i))\n                primes.append(i)\n        }\n        primes.take(n).toList",
  "        if (n < 2l) {\n            Nil\n        } else if (n <= 3l) {\n       \
    \     List(2l.toLong, 3l.toLong)\n        } else if (n % 2 == 0) {\n         \
    \   List(2l.toLong)\n        } else if (n % 3 == 0) {\n            List(3l.toLong)\n\
    \        } else {\n            val r = 3 + sqrt(n)\n            val list = 2 until\
    \ r\n            val list2 = list filter (n%_==0)\n            list2.foldLeft[List[Long]](Nil)\
    \ { (result, element) => element :: result }\n        }", "        var ans = ListBuffer[Long]()\n\
    \        val counter = mutable.ListBuffer(2l)\n        for (a <- 1 to n){\n  \
    \          // if the counter is less than n then its a prime number\n        \
    \    if (counter.size < n){\n                if ((counter.head + a).equals(counter.last)){\n\
    \                    counter = counter :+ counter.head + a\n                }\
    \ else {\n                    counter = counter :+ counter.head + a\n        \
    \        }\n            } else {\n                // if the counter is less than\
    \ n then its a prime number\n                if (counter.size < n){\n        \
    \            counter = counter :+ counter.head + a\n                    ans =\
    \ ans :+ counter.head.toLong\n                } else {\n                    ans\
    \ = ans :+ (counter.last).toLong\n                }\n                counter =\
    \ mutable.ListBuffer()\n            }\n        }\n        ans = ans ++ counter.map(x\
    \ => x.toLong)\n        ans.toList", "        // base case\n        if ((n <=\
    \ 0l)) {\n            return Nil\n        }\n\n        // recursive case\n   \
    \     var l : List[Long] = Nil\n        // count primes\n        for (i = n.toInt;\
    \ i > 0; i /= 2) {\n            if (isPrime(i)) {\n                l = l :+ i\n\
    \            }\n        }\n        \n        // drop n primes\n        for (i\
    \ <- l until n by -1) {\n            if (!isPrime(i)) {\n                l = l\
    \ :+ i\n            }\n        }\n        \n        l :+ n", "        val primes\
    \ = mutable.Buffer[Long]()\n        for (i = 1 to n) {\n            val p = math.floor(math.sqrt(i\
    \ * 2.toDouble))\n            if (primes.contains(p) == false) primes += p\n \
    \       }\n        primes.toList", "        def isPrime(n: Long, primes: List[Long])\
    \ : Boolean = { //isPrime(n: Long, primes: List[Long]) : Boolean\n           \
    \ for (prime <- primes) if (n % prime == 0) return false\n            primes :::\
    \ List(n % prime)\n        }\n\n        var primes: List[Long] = List(2, 3)\n\
    \        while(primes.nonEmpty && n < primes.last.toLong) primes = primes.filter(!isPrime(n,\
    \ primes))\n        primes.takeWhile(_ < n).reverse // reverse is necessary since\
    \ take will remove elements from primes if they are less than n.", "        def\
    \ isPrime(i : Long) : Boolean = {\n            if (i == 1) false else (for (j\
    \ <- 2 to math.ceil(math.sqrt(i.toDouble))) yield {\n                if (i%j ==\
    \ 0) false\n                else {\n                    for (k <- 3 to math.ceil(math.sqrt(i.toDouble\
    \ / j)) if k*j > i) false\n                    else true\n                }\n\
    \            })\n        }\n\n        def isPrime2(i: Long): Boolean = { for (j\
    \ <- 2 to math.ceil(math.sqrt(i.toDouble))) yield {\n            if (i%j == 0)\
    \ false\n            else { for (k <- 3 to math.ceil(math.sqrt(i.toDouble / j))\
    \ if k*j > i) false }\n        }; true}\n\n        def isPrime3(i: Long): Boolean\
    \ = { if (i <= 1) false; else { if (i%2 == 0) false; else { if (i%3 != 0) false\
    \ else { if (i%5 == 0) false; else { if (i%7 == 0) false; else { if (i%11 == 0)\
    \ false; else { if (i%13 == 0) false; else { if (i%17 == 0) false; else { if (i%19\
    \ == 0) false; else { if (i%23 != 0) false } } } } } } } } } }; true}\n\n    \
    \    val primes = mutable.Stack[Long]()\n\n        for (i <- 0 to n) {\n     \
    \       if (isPrime(i)) {\n                primes.push(i)\n            }\n   \
    \     }\n        val result = primes.take(n)\n\n        val result2 = primes.toList\n\
    \        val result3 = primes.toIterable.toList\n        val result4 = primes.toStream.toList\n\
    \        val result5 = primes.toIterable.asInstanceOf[scala.collection.mutable.Buffer[Long]].toList\n\
    \        val result6 = primes.toIterator.toList\n        result\n        result2\n\
    \        result3\n        result4\n        result5\n        result6", "      \
    \  val primes = mutable.ArrayBuffer.empty[Long]\n        val numbers = mutable.ArrayBuffer.empty[Long]\n\
    \        primes.append(2l)\n        primes.append(3l)\n        primes.append(5l)\n\
    \        primes.append(7l)\n        for (i <- 3l..n) yield {\n            if (primes.contains(i))\
    \ numbers += i\n            else primes += i\n        }\n        numbers.toList",
  "        var a = 0\n        var list = List[Long]()\n        for(i <- 2l..n){\n\
    \            if((n % i) == 0) {\n                a += 1\n                list(a.toLong)\n\
    \            }\n        }\n        return list", "        // write your code here\n\
    \        if (n < 2)\n            Nil\n        else if (n < 4)\n            List(2l.toLong,\
    \ 3l.toLong)\n        else n % 2 == 0 || n % 3 == 0", "      var result : List[Long]\
    \ = List()\n      var flag : List[Boolean] = List()\n      \n      var n = n.toInt\n\
    \      \n      val div : List[Int] = List.range(1, (n))\n      \n      for (i\
    \ <- 0 to (n-1)) {\n        if (flag(i)) {\n          result ::= i :: flag\n \
    \       }\n        flag = List(false)\n        \n        var j = 1\n        while\
    \ (j < (div(i))) {\n          if (!flag(div(i))) {\n            j += 1\n     \
    \     }\n          flag ::= true\n        }\n      }\n      \n      result ::=\
    \ n :: flag\n      \n      result", "        val primes = List(2, 3, 5, 7)\n \
    \       val smallerPrimes = primes.filter(_ < n)\n        val primeSum = smallerPrimes.sum\n\
    \        val primeNumbers = primes.filter(_ == primeSum)\n        val primeNumbersLessThanN\
    \ = (primeNumbers diff List(n)).map(_ + 1).toList\n        primeNumbersLessThanN.take(smallerPrimes.length)",
  "        val primes = prime :: new scala.collection.mutable.ListBuffer[Long]\n \
    \       val current = 1\n        var remaining = n\n        while (remaining !=\
    \ 0) {\n            current += 1\n            if (remaining.isPrime) {\n     \
    \           primes += current\n                remaining -= current\n        \
    \    }\n        }\n        primes.toList", "        val nums = scala.collection.mutable.ArrayBuffer.empty[Long]\n\
    \        for (i <- 2 to n by 2)\n            if (n % i == 0)\n               \
    \ nums += i\n        if (nums.isEmpty)\n            nums += n\n        val l =\
    \ nums.toList\n        val n = l length\n        (0 until n).map(i => l(n - i\
    \ - 1)) toList", "        val counter = mutable.ListBuffer.empty[Long]\n     \
    \   val primes = scala.util.Primes.primesUpTo(n)\n        primes foreach { p =>\n\
    \            val i = scala.math.ceil(p.toDouble / 2)\n            val a = p.toDouble\
    \ - i * 2\n            val prime = primes(i)\n            val count = counter.lastOption.map(counter\
    \ => counter + prime).orElse(0)\n            counter.push(a)\n        }\n    \
    \    counter.toList", "      if (n <= 0l) List()\n      else if ((2l...n).exists(!isPrime))\
    \ List(2l...n) \n      else countUpTo(n-2)", "        if (n == 0l) return List()\n\
    \        var list : List[Long] = List()\n        var m = 2\n        while (n >\
    \ m) {\n            list += m\n            if (list.contains(n)) list.filterNot(_\
    \ == n)\n            m += 1\n        }\n        list", "        val primes = scala.collection.mutable.ListBuffer[Long]()\n\
    \        for(i <- 2l ; i <= n ; i = i + (i-1l)) {\n            if (primes.contains(i.toLong))\
    \ {\n                primes += i.toLong\n            }\n            else if(i.toLong\
    \ > Math.sqrt(n)) {\n                primes += i.toLong\n            }\n     \
    \   }\n        primes.toList", "        var list = List[Long]()\n        for (i\
    \ <- 2 to n by 2)\n            list = list :+ (i.toLong).toInt\n        list",
  "        var primes: List[Long] = Nil\n        var count = 0\n        for (i <-\
    \ 2 to n) {\n            if (primes.contains(i)) {\n                count += 1\n\
    \            } else {\n                primes = primes ::: List(i.toLong)\n  \
    \              count += 1\n            }\n        }\n        if (primes.isEmpty)\
    \ {\n            Nil\n        } else {\n            primes.take(count).toList\n\
    \        }", "        def isprime(n: Long): Boolean = n match {\n            case\
    \ 0 => true\n            case 1 => false\n            case _ => {\n          \
    \      var i = 2\n                var res = true\n                while (i <=\
    \ n / 2) {\n                    if (n % i == 0) res = false\n                \
    \    i += 1\n                }\n                res\n            }\n        }\n\
    \        val res = new mutable.ListBuffer[Long]()\n        var prime = 2 // first\
    \ 2 primes are easy\n        while (n + prime < n) {\n            if (isprime(n\
    \ + prime)) res += n + prime\n            prime += 1\n        }\n        res",
  "        if (n == 0) List()\n        else primeFactors(n).filter(p => p > 0).take(n).toList",
  "        val liftings = scala.collection.mutable.ListBuffer[Long]()\n        var\
    \ primes = List[Long](2l).iterator\n        primes += 3l\n        var i = 3l\n\
    \        var count = 0\n        while (i < n) {\n            if (primes.contains(i))\
    \ {\n                count += 1\n                liftings += i.toLong\n      \
    \      }\n            i += 1\n        }\n        primes += 5l\n        i = 3l\n\
    \        count = 0\n        while (i < n) {\n            if (primes.contains(i))\
    \ {\n                count += 1\n                liftings += i.toLong\n      \
    \      }\n            i += 1\n        }\n        primes += 7l\n        i = 11l\n\
    \        count = 0\n        while (i < n) {\n            if (primes.contains(i))\
    \ {\n                count += 1\n                liftings += i.toLong\n      \
    \      }\n            i += 1\n        }\n        primes += 13l\n        i = 17l\n\
    \        count = 0\n        while (i < n) {\n            if (primes.contains(i))\
    \ {\n                count += 1\n                liftings += i.toLong\n      \
    \      }\n            i += 1\n        }\n        primes += 19l\n        i = 23l\n\
    \        count = 0\n        while (i < n) {\n            if (primes.contains(i))\
    \ {\n                count += 1\n                liftings += i.toLong\n      \
    \      }\n            i += 1\n        }\n        liftings.toList", "        require(n\
    \ >= 0L, \"n must be non-negative\")\n        if (n == 0L) return List()\n   \
    \     else if (n % 2 == 0L) return List(2L, n)\n        val list1 = countUpTo((n\
    \ / 2L).toLong)\n        val list2 = list1.filter(_ % 3L == 0L)\n        list1\
    \ ++ list2", "        val primes = mutable.ArrayBuffer.empty[Long]\n        val\
    \ i = 2l\n        while(i < n){\n            val isPrime = i.toInt <= math.sqrt(n).toInt\n\
    \            if(isPrime){\n                primes += i.toLong\n              \
    \  i += 1\n            }\n        }\n        primes.toList", "        if(n < 2l)\
    \ List()\n        if(n >= 2l && n < 3l) List(n.toLong)\n        if(n >= 3l &&\
    \ n <= 5l) List(2l.toLong, 3l.toLong, n.toLong)\n        if(n >= 5l && n <= 7l)\
    \ List(2l.toLong, 3l.toLong, 5l.toLong, n.toLong)\n        if(n >= 7l && n <=\
    \ 11l) List(2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, n.toLong)\n        if(n\
    \ >= 11l && n <= 13l) List(2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong,\
    \ n.toLong)\n        if(n >= 13l && n <= 17l) List(2l.toLong, 3l.toLong, 5l.toLong,\
    \ 7l.toLong, 11l.toLong, 13l.toLong, n.toLong)\n        if(n >= 17l && n <= 19l)\
    \ List(2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong,\
    \ n.toLong)\n        if(n >= 19l) List(2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong,\
    \ 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong)", "        val list = scala.collection.mutable.MutableList[Long]()\n\
    \        for (i<- 2 to n by 2){\n            val a = i.toLong\n            var\
    \ b = i.toLong + 1\n            while (scala.util.math.sqrt(b) <= (scala.util.math.sqrt(a)))\
    \ {\n                b+=1\n            }\n            if (b > n / i){\n      \
    \          list.add(b)\n            }\n        }\n        list.filter(x => ((n\
    \ / x) % 1 ==0 )).toList", "        val a = math.max(n.toLong,2) #:: scala.collection.immutable.Range.from(n.toLong\
    \ + 1 ).filter{ _ =>\n            ((math.sqrt(_) + 1).sqrt).mod(_) != 1\n    \
    \    }.map(_ - n.toLong).toList\n        if (a.length > 0)\n            a\n  \
    \      else\n            List[Long]()", "       var primes: List[Long] = Nil\n\
    \       var primesIndex = 0\n       var count : Long = 1\n       var i : Long\
    \ = 2\n       while (i < n) {\n          if ((i.toLong > n).toBoolean) {\n   \
    \          break\n          }\n          primesIndex = n + 1\n          while\
    \ ((primesIndex % i) == 0) {\n             primesIndex += 1\n          }\n   \
    \       primes = primes.filter(_ % i == 0)\n          if (primes.isEmpty) {\n\
    \             count += 1\n             if (count < n) {\n                i +=\
    \ 1\n             } else {\n                primesIndex += 1\n               \
    \ i = 2\n             }\n          }\n       }\n       primesIndex", "      val\
    \ primes = (2 to n).filter (p => !p.toLong %2).toList // only odd numbers\n  \
    \    primes.map (p => if (n == p) n else p - 1) // find prime less than n", " \
    \     require(n >= 0, \"n must be greater than or equal to zero\")\n      n match\
    \ {\n        case 0 => List()\n        case 1 => List(2l.toLong)\n        case\
    \ x => primeFactors(n)\n      }", "        val list = scala.collection.mutable.ListBuffer[Long]()\n\
    \        if(n > 2l) {\n            for (i <- 2l until (n-1l)) {\n            \
    \    val j = (n / i).toInt\n                if(j > 0){\n                    list\
    \ += i.toLong\n                    if(j % 1 == 0) {\n                        list\
    \ += (n-i)*2\n                    }\n                }\n            }\n      \
    \  }\n        if(n > 2l){\n            for (i <- 3l until (n-1l)) {\n        \
    \        val j = (n / i).toInt\n                if(j > 0){\n                 \
    \   list += i.toLong\n                    if(j % 1 == 0) {\n                 \
    \       list += (n-i)*2\n                    }\n                }\n          \
    \  }\n        }\n        if(n > 2l){\n            for (i <- 5l until (n-1l)) {\n\
    \                val j = (n / i).toInt\n                if(j > 0){\n         \
    \           list += i.toLong\n                    if(j % 1 == 0) {\n         \
    \               list += (n-i)*2\n                    }\n                }\n  \
    \          }\n        }\n        if(n > 2l){\n            for (i <- 7l until (n-1l))\
    \ {\n                val j = (n / i).toInt\n                if(j > 0){\n     \
    \               list += i.toLong\n                    if(j % 1 == 0) {\n     \
    \                   list += (n-i)*2\n                    }\n                }\n\
    \            }\n        }\n        if(n > 2l){\n            for (i <- 11l until\
    \ (n-1l)) {\n                val j = (n / i).toInt\n                if(j > 0){\n\
    \                    list += i.toLong\n                    if(j % 1 == 0) {\n\
    \                        list += (n-i)*2\n                    }\n            \
    \    }\n            }\n        }\n        if(n > 2l){\n            for (i <- 13l\
    \ until (n-1l)) {\n                val j = (n / i).toInt\n                if(j\
    \ > 0){\n                    list += i.toLong\n                    if(j % 1 ==\
    \ 0) {\n                        list += (n-i)*2\n                    }\n     \
    \           }\n            }\n        }\n        if(n > 2l){\n            for\
    \ (i <- 17l until (n-1l)) {\n                val j = (n / i).toInt\n         \
    \       if(j > 0){\n                    list += i.toLong\n                   \
    \ if(j % 1 == 0) {\n                        list += (n-i)*2\n                \
    \    }\n                }\n            }\n        }\n        if(n > 2l){\n   \
    \         for (i <- 19l until (n-1l)) {\n                val j = (n / i).toInt\n\
    \                if(j > 0){\n                    ", "        val primes = List.fill(n.toInt\
    \ / 2l)(2l.toLong)\n        primes.zip(List(2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong,\
    \ 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong)).foreach {\n        case (p,\
    \ x) =>\n            val n = n.toInt\n            val m = (p*2l).toLong\n    \
    \        val d = (m+p.toInt).toInt\n            val r = n.toInt-(p*2l).toInt\n\
    \            val g = p.toInt\n            val q = g.toInt\n            val r =\
    \ g.toInt\n            val y = ((p+2)/(p+2)).toInt\n            val z = p\n  \
    \          val q = ((p+3)/(p+3)).toInt\n            val r = ((p+5)/(p+5)).toInt\n\
    \            val w = ((p+7)/(p+7)).toInt\n            val v = ((p+11)/(p+11)).toInt\n\
    \            val w = ((p+13)/(p+13)).toInt\n            val y = ((p+17)/(p+17)).toInt\n\
    \            val z = ((p+19)/(p+19)).toInt\n            val r = ((p+29)/(p+29)).toInt\n\
    \            val g = ((p+41)/(p+41)).toInt\n            val q = ((p+53)/(p+53)).toInt\n\
    \            val r = ((p+77)/(p+77)).toInt\n            val w = ((p+109)/(p+109)).toInt\n\
    \            val v = ((p+147)/(p+147)).toInt\n            val w = ((p+173)/(p+173)).toInt\n\
    \            val y = ((p+207)/(p+207)).toInt\n            val z = ((p+247)/(p+247)).toInt\n\
    \            val r = ((p+291)/(p+291)).toInt\n            val g = ((p+331)/(p+331)).toInt\n\
    \            val q = ((p+379)/(p+379)).toInt\n            val r = ((p+423)/(p+423)).toInt\n\
    \            val w = ((p+461)/(p+461)).toInt\n            val v = ((p+529)/(p+529)).toInt\n\
    \            val w = ((p+587)/(p+587)).toInt\n            val ", "        var\
    \ primes = Set[Long]()\n        var result = List[Long]()\n        for(i <- 2l;\
    \ primes.isEmpty) primes ++= primes.filter(x => i % x == 0l).map(x => x.toLong)\n\
    \        while (primes.size < n) {\n            primes ++= primes.filter(x =>\
    \ n % x == 0l).map(x => x.toLong)\n            result :+= primes.filter(x => n\
    \ % x == 0l).map(x => x.toLong)\n        }\n        result", "        val primesUpToN\
    \ = scala.collection.mutable.ListBuffer.empty[Long]\n        var nextPrime = 2L\n\
    \        var prime: Option[Long] = None\n        primesUpToN += nextPrime\n  \
    \      while (n>0L && prime.isEmpty) {\n            prime = Some(nextPrime)\n\
    \            nextPrime += 1\n            primesUpToN += nextPrime\n        }\n\
    \        primesUpToN.takeWhile(_ < n).map(_+2).toList", "        var primes: mutable.Set[Long]\
    \ = mutable.Set()\n        var lst: List[Long] = List(n)\n\n        for ( i <-\
    \ 0 until lst.size ) {\n            if ( primes.contains(lst(i))==false ) {\n\
    \                primes = primes.union(lst.filter((x) => x%_==0).map((x) => x+1))\n\
    \                lst += primes\n            }\n        }\n        lst", "    \
    \    val primes: List[Long] = Array()\n        var total = 0L\n        val limit:\
    \ Long = n.toInt\n        while (prime < limit) {\n            var temp: List[Long]\
    \ = List[Long]()\n            val prime: Long = scala.math.math.prime(prime).toLong\n\
    \            while (prime < limit) {\n                if (scala.math.math.prime(prime).toLong\
    \ > prime) {\n                    val tempPrime: Long = scala.math.math.prime(prime).toLong\n\
    \                    if (!primes.contains(tempPrime)) {\n                    \
    \    temp = temp :+ tempPrime\n                    }\n                }\n    \
    \            prime = prime + 1\n            }\n            primes = primes :+\
    \ temp\n            total = total + temp.length\n        }\n        return primes",
  "      var primesAsList = List(2, 3, 5)\n      var primesAsList2 = List(2, 3, 5)\n\
    \      var primesAsList3 = List(2, 3, 5)\n      var primesAsList4 = List(2, 3,\
    \ 5)\n      var primesAsList5 = List(2, 3, 5)\n      var primesAsList6 = List(2,\
    \ 3, 5)\n      var primesAsList7 = List(2, 3, 5)\n      var primesAsList8 = List(2,\
    \ 3, 5)\n      var primesAsList9 = List(2, 3, 5)\n      var primesAsList10 = List(2,\
    \ 3, 5)\n      var primesAsList11 = List(2, 3, 5)\n      var primesAsList12 =\
    \ List(2, 3, 5)\n      var primesAsList13 = List(2, 3, 5)\n      var primesAsList14\
    \ = List(2, 3, 5)\n      var primesAsList15 = List(2, 3, 5)\n      var primesAsList16\
    \ = List(2, 3, 5)\n      var primesAsList17 = List(2, 3, 5)\n      var primesAsList18\
    \ = List(2, 3, 5)\n      var primesAsList19 = List(2, 3, 5)\n      var primesAsList20\
    \ = List(2, 3, 5)\n\n      var primesAsList21 = List(2, 3, 5)\n      var primesAsList22\
    \ = List(2, 3, 5)\n      var primesAsList23 = List(2, 3, 5)\n      var primesAsList24\
    \ = List(2, 3, 5)\n      var primesAsList25 = List(2, 3, 5)\n      var primesAsList26\
    \ = List(2, 3, 5)\n      var primesAsList27 = List(2, 3, 5)\n      var primesAsList28\
    \ = List(2, 3, 5)\n      var primesAsList29 = List(2, 3, 5)\n      var primesAsList30\
    \ = List(2, 3, 5)\n      var primesAsList31 = List(2, 3, 5)\n      var primesAsList32\
    \ = List(2, 3, 5)\n      var primesAsList33 = List(2, 3, 5)\n      var primesAsList34\
    \ = List(2, 3, 5)\n      var primesAsList35 = List(2, 3, 5)\n      var primesAsList36\
    \ = List(2, 3, 5)\n      var primesAsList37 = List(2, 3, 5)\n      var primesAsList38\
    \ = List(2, 3, 5)\n      var primesAsList39 = List(2, 3, 5)\n      var primesAsList40\
    \ = List(2, 3, 5)\n      var primesAsList41 = List(2, 3, 5)\n      var primesAsList42\
    \ = List(2, 3, 5)\n      var primesAsList43 = List(2, 3, 5)\n      var primesAsList44\
    \ = List(2, ", "        val primeList = new ListBuffer[Long]()\n        val counter\
    \ = math.ceil(math.sqrt(n).toLong)\n        var counter : Int = 1\n        for(i\
    \ <- 2 to counter) {\n            for(j <- 2 to counter) {\n                if(i\
    \ * j <= n) {\n                    if(n % i == 0 && n % j == 0) {\n          \
    \              primeList += i * j\n                        counter += 1\n    \
    \                }\n                }\n            }\n        }\n        if(counter\
    \ < math.ceil(math.sqrt(n).toLong)) {\n            primeList += counter\n    \
    \    }\n        primeList.toList", "        val result = mutable.ListBuffer.empty[Long]\n\
    \        for (i <- 2 to n) yield {\n            if (isPrime(i) && isPrime(i+2))\
    \ result += i.toLong\n        }\n        result.toList", "        // implement\
    \ the countUpTo function here\n", "        val nums = List((2l, n))\n        var\
    \ primes = List((2l, n))\n        var i = 0\n        while (i < nums.length -\
    \ 1) {\n            primes = primes filter (nums(i) <= nums(i + 1))\n        \
    \    i += 1\n        }\n        primes", "        val lit = n.toInt;\n       \
    \ if(lit <= 1l) List()\n        else {\n            val first = lit.toInt;\n \
    \           val next = first + 1l;\n            val rem = n - 1l;\n          \
    \  var list: List[Long] = Nil\n            for(i <- 0 until rem){\n          \
    \      if (next % first != 0) {\n                    list :+= next\n         \
    \       }\n                next += 1l\n            }\n            list\n     \
    \   }", "        val primes = mutable.Set[Long]()\n        val result = mutable.ListBuffer[Long]()\n\
    \        for (i <- 2 to n) {\n            if (primes.contains(i)) {\n        \
    \        result += i\n            }\n            else {\n                primes\
    \ += i\n            }\n        }\n        return result.toList", "        if (n\
    \ < 2)\n          Nil\n        else {\n          val res = List(n); var k = 1l\n\
    \          while (k <= n) {\n            if (isPrime(k)) {\n              if (!res.contains(k))\
    \ {\n                res += k\n              }\n            }\n            k +=\
    \ 1l\n          }\n          res\n        }", "        if (n == 0L) List(1L)\n\
    \        else primeFactorization(n).take(n - 1).toList ::: countUpTo(n-1)", " \
    \       val list = new mutable.MutableList[Long]()\n        val primes = 2 to\
    \ n\n        primes.foreach{ e =>\n            val prime = true\n            for(i\
    \ <- 2 to n){\n                if(e % i == 0){\n                    prime = false\n\
    \                    break\n                }\n            }\n            if(prime)\n\
    \                list += e\n        }\n        list.toList", "        val nums\
    \ = Vector.tabulate(math.ceil(n/2l.toLong).toInt)(x => 2l.toLong*x+2l.toLong).takeWhile(x\
    \ => x<n).reverse\n        nums ::: List.fill(math.ceil(n/2l.toLong).toInt)(2l.toLong).toList",
  "        if (n == 0) List()\n        else {\n            val primes = primeFactors(n)\n\
    \            val listOfPrimes = primes.toList.filter(_ < n).map(_.toLong)\n  \
    \          listOfPrimes.map(l => n / l.toLong * l).takeWhile(_ > n).map(l => n\
    \ * l.toLong)\n        }", "        val ls = scala.collection.mutable.ListBuffer[Long]()\n\
    \        for (i <- 2 until n){\n            if(!isPrime(i)){\n               \
    \ ls += i.toLong\n                if((i.toLong) < n){\n                    ls\
    \ += i+1\n                }\n            }\n        }\n        ls.toList", " \
    \       def isPrime(n : Long) : Boolean = {\n            var i : Long = 0\n  \
    \          while ( i < n ) {\n                if ( n % i == 0 ) false\n      \
    \          i += 1\n            }\n            true\n        }\n        val primes\
    \ = mutable.ArrayBuffer(2l.toLong)\n        var i = 2l.toLong\n        while (\
    \ i < n ) {\n            if ( isPrime(i) ) {\n                primes += i\n  \
    \              i += 1\n            }\n        }\n        if ( primes.isEmpty()\
    \ ) List() else primes.take(n).toList", "        var list : List[Long] = List()\
    \ \n        if (n == 0 || n == 1) {\n            list = List(n);\n        }\n\
    \        else {\n            var startPrime : Long = 2\n            while (startPrime\
    \ <= n) {\n                var endPrime : Long = startPrime + 2\n            \
    \    while (endPrime <= n) {\n                    if (n % startPrime == 0 && n\
    \ % endPrime == 0) {\n                        list ::= startPrime\n          \
    \              startPrime += 2\n                        endPrime += 2\n      \
    \              }\n                    endPrime += 2\n                }\n     \
    \           startPrime += 2\n            }\n        }\n        list", "      \
    \  val ans: List[Long] = List(nl.toLong) //create empty list\n        for(i <-\
    \ 2 to n) //from 2 to n\n            if (nl.modulo(i) == 0) //if the modulo of\
    \ the current number with i equals zero\n                ans ::= nl.toLong //\
    \ append the number to the list\n                ans ::= i.toLong // append the\
    \ number to the list\n        ans", "        if (n <= 0l) List()\n        else\
    \ {\n            var primes = Set()\n            var count = 0\n            var\
    \ currentNumber: Long = n\n            while (count < n) {\n                val\
    \ isPrime = currentNumber % primes.isEmpty\n                if (isPrime) primes\
    \ += currentNumber\n                count += isPrime\n                currentNumber\
    \ = currentNumber + 1\n            }\n            primes.toList\n        }", " \
    \       val a = 2l\n        val b = 3l\n        var list: List[Long] = List()\n\
    \        while (n > 0 ){\n            var count = 0\n            var temp = a\n\
    \            while(temp != 0){\n                if(temp % b == 0){\n         \
    \           count += 1\n                }\n                temp = temp +1\n  \
    \          }\n            list = list :+ count \n            n = n - 1\n     \
    \   }\n        list", "        if (n == 0 || n == 1L) return List()\n        if\
    \ (n < 2L) return List()\n        val primes = primeList(n)\n        val l = new\
    \ mutable.ListBuffer[Long]()\n        primes.foreach { prime =>\n            if\
    \ (n >= prime) l.append(prime)\n            else { l.append(prime) ; l.append(prime)\
    \ ; l.append(prime) ; l.append(prime) ; l.append(prime) }\n        }\n       \
    \ if (l.isEmpty) List()\n        else l.toList", "        if (n == 0) List()\n\
    \        val r = primesUpTo(n)\n        val nums = r.filter(_ < n)\n        r.toList\
    \ filter (_ >= n) ++\n        nums.map (_ + n).toList filter (_ % _ == 0)", " \
    \       val list = new mutable.ListBuffer[Long]()\n        for (i = (2l*(i.toInt)).toLong\
    \ until n) if (i.toInt % 2 == 0 && i.toInt % i != 0) list += i.toLong\n      \
    \  list", "        // Complete the implementation of this function\n        if\
    \ (n == 0) \n            return Nil\n        if (n == 1) \n            return\
    \ List(n.toLong)\n        if (n % 2 == 0) \n            return countUpTo(n/2)\
    \ + List(n.toLong)\n        else \n            return (countUpTo(n/2) + List(n.toLong))",
  "        val primes = mutable.ListBuffer[Long]()\n        for (i <- 2 to n){\n \
    \           if (i % 2 == 0){\n                if (i != 2){\n                 \
    \   primes.append(i)\n                }\n            }\n            else if (primes.contains(i)){\n\
    \                primes.append(i)\n            }\n        }\n        primes.toList",
  '        // TODO: Write this function', "        val result = new mutable.ListBuffer[Long]\n\
    \        val divisor = 2 until n\n        divisor.foreach { d =>\n           \
    \ val isPrime = true\n            for (i <- 2 to n) {\n                if (d %\
    \ i ==0)\n                    isPrime = false\n            }\n            if (isPrime)\
    \ {\n                result += d.toLong\n            }\n        }\n        result.toList",
  "        val primes = List(2, 3)\n        val remainder = n % primes.head == 0 &&\
    \ (n - 1) % primes.head == 0\n        val list = for (i<- 1 to n) yield primes.head\
    \ + ((i-primes.head) * primes.head) % primes.head\n        list ++ List(if (remainder)\
    \ 1 else 0)", "        val list: List[Long] = Nil\n        for (i<-0 to (n)) {\n\
    \            if(i%2==0) {\n            list+=i.toLong\n            }\n       \
    \     else{\n                for (j<-(i+2 to n)) {\n                if(j%2==0)\
    \ {\n                    list+=j.toLong\n                }\n                }\n\
    \            }\n        }\n        list.toList", "        val primes = List(2l)\
    \ ++ (for {\n            p <- primes.takeWhile(_ < n)\n        } yield p) ++ (for\
    \ {\n            p <- primes.takeWhile(_ < n)\n        } yield p + (n-p))\n  \
    \      primes.filter(_ <= n).takeWhile(_ <= n).map(n => n + (n-n)).toList", " \
    \       // Your code here\n        val li = Vector.empty[Long]\n        var i\
    \ = 2l\n        while (i <= n)\n        {\n            if (isPrime(i))\n     \
    \       {\n                li :+= i.toLong\n                i += 2l\n        \
    \    }\n            else i += 1\n        }\n        li.sortWith(_ < _)", "   \
    \     var primes: List[Long] = List() // list of primes\n        var counter =\
    \ 2 // prime counter\n        // search for a prime in first n numbers\n     \
    \   for(i <- 0 until n){\n            if(isPrime(counter)){\n                primes\
    \ = primes :+ counter\n            }\n            counter += 1\n        }\n  \
    \      // sort primes and remove duplicates\n        val sortedPrimes = primes.sorted\n\
    \        val deduplicatedPrimes = sortedPrimes.distinct\n        // remove primes\
    \ which are less than n\n        val primesLessThanN = deduplicatedPrimes.filter(_\
    \ <= n)\n        // append n to primes\n        primes ::: List(primes.head.toLong)",
  "        val results: mutable.Buffer[List[Long]] = mutable.Buffer.empty\n      \
    \  var counter = 1\n        while (counter <= n) {\n            counter += 1 //\
    \ Increment counter\n            results = results :+ (counter % 2) :: Nil\n \
    \       }\n        results.toList", "        val buffer = new scala.collection.mutable.ListBuffer[Long]()\n\
    \        def helper(i : Long) : Unit = {\n            if (i >= n) buffer.clear()\n\
    \            else if (buffer.contains(i)) buffer.remove(i)\n            else {\n\
    \                val j = i+2\n                while (j < n && buffer.contains(j))\
    \ j += 2\n                if (j > n || buffer.contains(j)) buffer.clear()\n  \
    \              else buffer.add(j)\n            }\n        }\n        for (i =\
    \ 2; i <=n ; i+=2) {\n            helper(i)\n        }\n        buffer.toList",
  "        def isPrime(x : Long) : Boolean = {\n            if (x < 2 || x == 2) true\n\
    \            else if (x % 2 == 0) false\n            else if (x % 3 == 0) false\n\
    \            else x % 2 == 0 && x % 3 != 0\n        }\n        if (n <= 1) Nil\n\
    \        else n match {\n            case n @ n if (n > 1) => (for {\n       \
    \         x <- 2 to n by 2\n                if (isPrime(x)) yield x\n        \
    \    } yield n).tail\n            case _ => Nil\n        }", "        var primesList\
    \ = new ListBuffer[Long]()\n        var nIsPrime = true\n        var counter :\
    \ Long = 0\n        while (counter < n && (nIsPrime)) {\n            for (x <-\
    \ 2 to n) {\n                if ((n % x) == 0) {\n                    primesList.append(x.toLong)\n\
    \                    nIsPrime = false\n                }\n            }\n    \
    \        counter += 1\n        }\n        primesList.toList", "        val numbers\
    \ = new mutable.ListBuffer[Long]()\n        var i : Long = 1\n\n        while\
    \ (i<=n) {\n            i = i+1\n            if (i.toLong == 2) {\n          \
    \      numbers += i.toLong\n            }\n        }\n        numbers.toList",
  "        val primes = mutable.ListBuffer[Long]()\n        val counter = mutable.ListBuffer[Long]()\n\
    \        while(n > 1) {\n            val r = 2l\n            while(true) {\n \
    \               if(r > n) break\n                if(r in primes) counter.append(r)\n\
    \                if(n % r == 0) break\n                r += 1\n            }\n\
    \            primes.append(r)\n            n -= r\n        }\n        primes.reverse",
  "       val primeList: List[Long] = List();\n       val counter = n / 2l.toLong;\n\
    \       for (i<-0 until counter) {\n           for (j <-0 until n) {\n       \
    \        if (i%j == 0) {\n                   primeList += j.toLong;\n        \
    \           break;\n               }\n           }\n       }\n       primeList\
    \ ++ List((counter.toLong)*2l.toLong)", "        val list = new mutable.ListBuffer[Long]()\n\
    \        for (i <- 2l to n) if (isPrime(i)) { list.+= i }\n        list.iterator.toList",
  "        val primeNumbers: List[Long] = primeNumbersUntil(n)\n        primeNumbers.takeWhile(p\
    \ => p <= n).reverse", "        def isPrime(n: Int): Boolean = {\n          for(\
    \ i <- 1 to n / 2 )\n              if( n % i == 0 )\n                  return\
    \ false\n          true\n        }\n\n        def nextPrime(n: Int): Int = {\n\
    \          var i: Int = 0\n          while(i < n) if( isPrime(i) ) i = i + 2\n\
    \          i\n        }\n\n        var primes: List[Long] = List(n)\n        primes\
    \ = primes ::: List(n + 1)\n\n        // The loop keeps dividing the last number\
    \ in primes by two,\n        // so if the last number is less than or equal to\
    \ n, then primes\n        // contains only n.\n        while( primes.last <= n\
    \ ) {\n            primes = primes ::: List( nextPrime(primes.last) )\n      \
    \  }\n\n        // If n is greater than the greatest prime in the list, primes\
    \ contains only n.\n        primes.reverse", "        def isPrime(n: Long, primes:\
    \ mutable.Set[Long]) : Boolean = {\n            if (n < 2) false\n           \
    \ else\n            {\n                if (primes.contains(n))\n             \
    \       true\n                else\n                {\n                    primes.update(n)\n\
    \                    val i = 2\n                    for (j <- 3 to i by 2)\n \
    \                   {\n                        if (n%j == 0)\n               \
    \         {\n                            isPrime(n, primes)\n                \
    \            break\n                        }\n                    }\n       \
    \         }\n            }\n        }\n\n        val primes = mutable.Set()\n\
    \        for (i <- 2 to n)\n        {\n            isPrime(i, primes)\n      \
    \      if (primes.size == n) break\n        }\n        primes.toList", "     \
    \   val primes = scala.collection.mutable.ArrayBuffer.empty[Long]\n        primes\
    \ ++= 2l.toLong until n\n        primes.takeWhile(p => { val l = scala.math.sqrt((p*p).toLong).toInt;\
    \ l != 1 && primes.indexOf(l) == -1})", "        // Write your solution here\n\
    \        if(n < 2) List()\n        else if(n % 2 == 0 || n <= 5) return List(n.toLong)\n\
    \        else if(n % 3 == 0 || n % 2 == 0 || n <= 5) return List(n.toLong)\n \
    \       else {\n            val factors = List(3,5)\n            val temp = factors.filter(x\
    \ => n <= x)\n            if(temp.length > 0) temp.reverse.tail :: List(n.toLong)\n\
    \            else List()\n        }", "        val l = n.toLong\n        val rem\
    \ = if (l < 2) 0 else l % 2\n        val lim = l - rem\n        val primes = primesAndFactors(lim)\n\
    \        primes.filter(p => p._2 < lim)", "        // TODO: Fill in the blanks\n\
    \        if (n < 2) List()\n        val primes = List(2, 3, 5)\n        val numbers\
    \ = List(n)\n        numbers.foreach(n => {\n            val prime = primes.find(n%_\
    \ == 0)\n            if (prime == primes.last) primes.last\n            else primes\n\
    \        })", "        if (n <= 2l) List()\n        else {\n            val isPrime\
    \ = \n                (n-1l) match {\n                    case n if n % 2l ==\
    \ 0l => false\n                    case n if n % 3l == 0l => false\n         \
    \           case n if n % 5l == 0l => false\n                    case n if n %\
    \ 7l == 0l => false\n                    case n if n % 11l == 0l => false\n  \
    \                  case n if n % 13l == 0l => false\n                    case\
    \ n if n % 17l == 0l => false\n                    case n if n % 19l == 0l =>\
    \ false\n                    case n if n % 23l == 0l => true\n               \
    \     case n if n % 29l == 0l => true\n                    case n if n % 31l ==\
    \ 0l => true\n                    case n if n % 37l == 0l => true\n          \
    \          case n if n % 41l == 0l => true\n                    case n if n %\
    \ 47l == 0l => true\n                    case n if n % 53l == 0l => true\n   \
    \                 case n if n % 59l == 0l => true\n                    case n\
    \ if n % 61l == 0l => true\n                    case n if n % 67l == 0l => true\n\
    \                    case n if n % 71l == 0l => true\n                    case\
    \ n if n % 73l == 0l => true\n                    case n if n % 79l == 0l => true\n\
    \                    case n if n % 83l == 0l => true\n                    case\
    \ n if n % 89l == 0l => true\n                    case n if n % 97l == 0l => true\n\
    \                    case n if n % 101l == 0l => true\n                    case\
    \ n if n % 103l == 0l => true\n                    case n if n % 107l == 0l =>\
    \ true\n                    case n if n % 111l == 0l => true\n               \
    \     case n if n % 117l == 0l => true\n                    case n if n % 123l\
    \ == 0l => true\n                    case n if n % 129l == 0l => true\n      \
    \              case n if n % 139l == 0l => true\n                    case n if\
    \ n % 147l == 0l => true\n                    case n if n % 151l == 0l => true\n\
    \                    case n if n % 157l == 0l => true\n                    case\
    \ n if n % 163l == 0l => true\n                    case n if n % 167l == 0l =>\
    \ true\n                    case n if n % 173l == 0l => true\n               \
    \     case n if n % 179l == 0l => true\n                    case n if n % 185l\
    \ == 0l => true\n                    case n if n % 19", "      var nextPrime =\
    \ 1\n      var primes = mutable.ListBuffer(nextPrime)\n      while ( primes.length\
    \ < n){\n        val prime = nextPrime\n        primes += prime\n        nextPrime\
    \ = prime + 2\n        primes.find(_ > n)\n      }\n      primes", "        val\
    \ lst : mutable.ListBuffer[Long] = mutable.ListBuffer[Long]()\n        for(i <-\
    \ 2 to n){\n            if((i.toInt)%2 == 0){\n                val isPrime = i.toInt/2\
    \ #> 2\n                if(isPrime){\n                    if(i <= n){\n      \
    \                  lst += i.toLong\n                    }\n                }\n\
    \            }\n        }\n        if(lst.size > 0){\n            lst.sort\n \
    \       }", "        val result = new mutable.ListBuffer[Long]()\n        for(i\
    \ <- 2 to n) {\n            if(isPrime(i)) result += i\n        }\n        result.toList",
  "        val primesUpToN = Primes.primes.takeWhile(p => p <= n).toList\n       \
    \ val factorsUpToN = Factors.factors.takeWhile(p => p <= n).toList\n        if\
    \ (primesUpToN.isEmpty || factorsUpToN.isEmpty) return List()\n        else {\n\
    \            val n = n + 1\n            val primesDownToN = primesUpToN\n    \
    \        val factorsDownToN = factorsUpToN\n            primesDownToN.map(_ *\
    \ factorsDownToN.last).toList\n        }", "        val counts = mutable.HashMap.empty[Long,\
    \ Int]\n        for (i <- 1 to n) counts += i -> counts.getOrElse(i, 0)\n    \
    \    val res = (1 to n).filter( x => counts.contains(x)).filter( x => counts(x)\
    \ <= counts.getOrElse(x, 0)).map(x => x * counts(x).toLong).toList\n        counts",
  "        var primes : List[Long] = null\n        var counts : List[Long] = null\n\
    \n        // Primes up to 2^31 are easy to test.\n        val maxPrime = 2l\n\
    \        var maxCount = 1l\n        var count = 0\n\n        // Keep going until\
    \ we reach the limit or we find some composite number.\n        while (n >= maxPrime\
    \ || count <= maxCount) {\n            val next = n + 1\n\n            // If the\
    \ current number is greater than or equal to the square root of n\n          \
    \  // then the number is not prime\n            if (isPrime(next)) {\n       \
    \         // Add it to the list of primes.\n                primes = primes ++\
    \ List(n + 1.toLong)\n\n                // Add the current count to the list of\
    \ counts.\n                counts = counts ++ List(count)\n\n                //\
    \ Update the max and current numbers, as we haven't exceeded the limit.\n    \
    \            if (next >= maxPrime) {\n                    maxPrime = next\n  \
    \                  maxCount = count\n                }\n            }\n\n    \
    \        count = count + 1\n        }\n\n        if (count > maxCount) {\n   \
    \         // Make sure that the list of primes is in descending order.\n     \
    \       primes.sortWith((x, y) => x.toLong > y.toLong)\n        }\n        else\
    \ {\n            primes\n        }", "        var primes = List((2l).toLong);\n\
    \        var remaining = n\n        var found = False\n        while(!found &&\
    \ remaining > 0) {\n            var found = True;\n            for(prime <- primes){\n\
    \                if(remaining % prime == 0) {\n                    found = False\n\
    \                    break;\n                }\n            }\n            if((found))\
    \ {\n                primes = primes :+ (remaining / prime).toLong;\n        \
    \        remaining = (remaining - remaining / prime).toLong\n            }\n \
    \       }\n        if(remaining > 0) {\n            primes = primes :+ (remaining).toLong\n\
    \        }\n        return primes;", "        if (n <= 0L)\n            Nil\n\
    \        else if (n == 2L)\n            List(2L)\n        else\n            n\
    \ match {\n                case 2L | 3L => List(2L) :: (3L :: List.empty)\n  \
    \              case n if n < 4L => List(n :: 4L)\n                case 2L => List(3L)\n\
    \                case n+1 => List(n)\n                case n+2 if n%2==0 => List(n)\n\
    \                case n+3 if n%3==0 => List(n)\n                case n+4 if n%5==0\
    \ => List(n)\n                case n+5 => List(2L)\n                case n =>\
    \ countUpTo((n+1L))\n            }", "        val primes = scala.collection.mutable.ArrayBuffer.empty[Long]\n\
    \        for (i <- 2l; j < n; j+=i)\n            if (n % i == 0) primes += i.toLong\n\
    \n        if (primes.isEmpty) List() else\n            primes.takeWhile { p =>\n\
    \                !primes.exists(n => n % p == 0)\n            }.toList", "   \
    \     val max = (math.sqrt(n).toInt) + 1\n        (2 to max).filter(x => isPrime(x)).take(n\
    \ - 1).toList", "        if (n <= 1l) {\n            return List()\n        }\n\
    \        else {\n            val nums = List() // list of numbers less than n\n\
    \            // now loop over numbers less than n and check if it is divisible\
    \ by primes\n            val numsInDivisors = n / 2l\n            val primeFactors\
    \ = primeFactors(numsInDivisors)\n            val remainingPrimes = primeFactors.filter(_\
    \ > 1)\n            val remainders = primeFactors.filter(_ == 1)\n           \
    \ val maxPrimes = remainingPrimes.max\n            val minPrime = primeFactors.min\n\
    \            val maxDivisor = maxPrimes.toLong\n            val minDivisor = minPrime.toLong\n\
    \            val divisors = 0 until maxDivisor\n            val divisorFactors\
    \ = divisors.map(n => n * (n + 1l).toLong)\n            var divisorIndex = divisorFactors.indexOf(divisorFactors.max)\n\
    \            while (divisorIndex < divisorFactors.length) {\n                if\
    \ (numsInDivisors > divisorFactors(divisorIndex)) {\n                    nums\
    \ += divisorFactors(divisorIndex)\n                    divisorIndex += 1\n   \
    \             }\n                else {\n                    numsInDivisors -=\
    \ divisorFactors(divisorIndex)\n                    divisorIndex += 1\n      \
    \          }\n            }\n            // now loop over the remaining divisors\
    \ and add the prime factors to nums\n            val primes = 0 until maxDivisor\n\
    \            val primeFactors = primes.map(n => n * (n + 1l).toLong)\n       \
    \     val remainingPrimes = primeFactors.filter(_ > 1)\n            val remainders\
    \ = primeFactors.filter(_ == 1)\n            val maxPrimes = remainingPrimes.max\n\
    \            val minPrime = primeFactors.min\n            val maxDivisor = maxPrimes.toLong\n\
    \            val minDivisor = minPrime.toLong\n            val divisors = 0 until\
    \ maxDivisor\n            val divisorFactors = divisors.map(n => n * (n + 1l).toLong)\n\
    \            var divisorIndex = divisorFactors.indexOf(divisorFactors.max)\n \
    \           while (divisorIndex < divisorFactors.length) {\n                if\
    \ (numsInDivisors > divisorFactors(divisorIndex)) {\n                    nums\
    \ += divisorFactors(divisorIndex)\n                    divisorIndex += 1\n   \
    \             }\n                else {\n                    numsInDivisors -=\
    \ divisorFactors(divisorIndex)\n                    divisorIndex += 1\n      \
    \          }\n            }\n            return nums\n        }", "        val\
    \ list = new mutable.ListBuffer[Long]\n        val i = 2L\n        val s = math.sqrt(n)\n\
    \        while (i <= s) {\n            if (n % i == 0) {\n                list.toList.append(i)\n\
    \                n /= i\n            }\n            i += 1\n        }\n      \
    \  list.toList.map(_.toLong)", "        val list = List(n)\n        if (list.isEmpty)\
    \ list\n        else (2 to list.head filter (_ % _ == 0) map (_+2) ++ countUpTo((list.head\
    \ - 1l)))", "        // ((n: Long) => if (n < 2) Nil else {\n        // val nums\
    \ = (2 to n).toList\n        // val primes = nums.filter(_ % _ == 0)\n       \
    \ // val primesLessN = (primes takeWhile { p => p <= n } ++ (primes dropWhile\
    \ { p => p > n } )).filter(_ <= n)\n        // primesLessN.map(_.toLong).sum\n\
    \        // })\n        val nums = (2 to n).toList\n        val primes = nums.filter(_\
    \ % _ == 0)\n        val primesLessN = (primes takeWhile { p => p <= n } ++ (primes\
    \ dropWhile { p => p > n } )).filter(_ <= n)\n        primesLessN.map(_.toLong).sum",
  "        val li = ListBuffer[Long]()\n        var m = 2\n        while ( m <= n\
    \ ) {\n            if ( n % m == 0 ) {\n                li +=m\n             \
    \   li += n\n            }\n            m+=2\n        }\n        return li.dropWhile(\
    \ _ == 0)", "        val p: List[Long] = List(2l.toLong, 3l.toLong, 5l.toLong,\
    \ 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong)\n        val r: List[Long]\
    \ = 0 until n\n        val r: List[Long] = r.toList\n        for (i <- 0 until\
    \ n) {\n            val p: List[Long] = List(2l.toLong, 3l.toLong, 5l.toLong,\
    \ 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong)\n            val\
    \ p: List[Long] = p.toList\n            val primeNumbers = r filter (p contains\
    \ _)\n            if (primeNumbers.isEmpty)\n                List()\n        \
    \    else\n                List(primeNumbers.toList)\n        }", "        def\
    \ isPrime(x: Long): Boolean = {\n            val sqrt = math.sqrt((x*x).toLong)\n\
    \            for( i <- 1 to sqrt ) {\n                if ( (x % i) == 0 ) {\n\
    \                    return false\n                }\n            }\n        \
    \    true\n        }\n        val primes = mutable.ListBuffer[Long]()\n      \
    \  var low = n * 2 // n is prime if n is odd or > 2\n        var high = n // n\
    \ is prime if n is even\n        while (low <= high) {\n            if (isPrime(low))\
    \ {\n                primes += low\n                if (low == high) break\n \
    \           }\n            low += 2\n        }\n        primes", "        if (n\
    \ == 1l) Nil\n        else if (n == 0l) Nil\n        else {\n            def prime\
    \ = List(2l,3l,5l,7l,11l,13l,17l,19l)\n            val list = new mutable.ListBuffer[Long]()\n\
    \            val factors = prime\n            while (factors.nonEmpty && (n %\
    \ factors.head == 0)) {\n                list += factors.head\n              \
    \  factors = factors.tail\n            }\n            list += n\n            list.toList\n\
    \        }", "        var list = List[Long]()\n        var current = n\n     \
    \   var prime = scala.util.Prime.nextPrime\n\n        while (current.toInt < n)\
    \ {\n            if (scala.util.Prime.primesBetween(current, prime).count(_ %\
    \ current) == 0) {\n                list ::= current\n                current\
    \ = prime\n                prime += 2\n            } else {\n                current\
    \ += 1\n            }\n        }\n        list", "        var result : List[Long]\
    \ = List[Long]()\n        for (i <- 2l to n) if (isPrime(i) && n < i) {\n    \
    \        result = (result :+ i).toList\n            n = n + 1\n        }\n   \
    \     result", "        var result : List[Long] = List()\n        var isPrime\
    \ : Boolean = true\n        var i = 2\n        // loop while i is less than or\
    \ equal to n and is not prime\n        while( i < n && !isPrime) {\n         \
    \   // is i's integer a factor of n?\n            isPrime = n % i == 0\n     \
    \       if( isPrime) {\n                // add i to result\n                result\
    \ = i :: result\n                // increment i\n                i += 1\n    \
    \        }\n        }\n        // return result\n        result.reverse", "  \
    \      val lis = for (i <- 0 until n) yield i\n        lis.filter(_ => prime_(_)).toList",
  "        require( n >= 0) \n        val limit = n / 2\n        val res = []\n  \
    \      val lowPrimes = Primes(limit)\n        lowPrimes foreach { x =>\n     \
    \       val primesUpToLimit = Primes(x until limit)\n            if (primesUpToLimit.forall(x\
    \ => n % x == 0)) res += x\n        }\n        if (limit == n) res else countUpTo(limit)",
  "        var list : List[Long] = Nil\n        for (i <- 2 until n) if (isPrime(i)\
    \ && i < n) list :+= i\n        list", "        def countUpToHelper(n: Long) :\
    \ List[Long] = {\n            if (n <= 0) {\n                List()\n        \
    \    } else if (n % 2 == 0 || n % 3 == 0) {\n                val count = countUpToHelper(n\
    \ - 1l).map(n -> n.toLong).filter(n => n % 2 == 0 || n % 3 == 0).length\n    \
    \            if (count == 0) List()\n                else {\n                \
    \    List(n -> count.toLong)\n                }\n            } else {\n      \
    \          val count = countUpToHelper(n - 1l).map(n -> n.toLong).filter(n =>\
    \ n % 2 == 0 && n % 3 == 0).length\n                if (count == 0) List()\n \
    \               else {\n                    List(n -> count.toLong)\n        \
    \        }\n            }\n        }\n        countUpToHelper(n).map { case (n,\
    \ count) => (n.toLong, count) }.toList", "        require(n >= 0)\n        val\
    \ list = new mutable.ListBuffer[Long]()\n        def checkPrime(x : Long, y :\
    \ Long) : Unit = {\n            if (y > x) {\n                list.+= x\n    \
    \        }\n            x += 1\n        }\n        val i = 2l\n        while (i\
    \ < n) {\n            if (checkPrime(2l, i)) {\n                checkPrime(3l,\
    \ i)\n            }\n            i += 1\n        }\n        list.toList", "  \
    \      def isPrime(n: Long) : Boolean = {\n            val i = 2L\n          \
    \  while (i < n) {\n                if (n % i == 0) {\n                    return\
    \ false\n                }\n                i += 1\n            }\n          \
    \  true\n        }\n\n        val res = new mutable.ListBuffer[Long]\n       \
    \ if (n < 1L) {\n            return res\n        }\n        for (i <- 2L to n)\
    \ {\n            if (isPrime(i)) {\n                res += i\n            }\n\
    \        }\n        res", "        val primes = mutable.Set[Long]()\n        val\
    \ primesList = mutable.ListBuffer.empty[Long]\n        val counter = scala.collection.mutable.ListBuffer.empty[Long]\n\
    \        for (x <- 2l.toLong until (n / 2l.toLong)) {\n            val test =\
    \ n.toString.toLong\n            while (test > 1l) {\n                if (test\
    \ % x != 0l) {\n                    break\n                } else {\n        \
    \            primes += test\n                    test--\n                }\n \
    \           }\n            primesList :+= test\n        }\n        for (x <- primes\
    \ ) {\n            for (y <- primesList if x != y) {\n                if (x !=\
    \ y && y != (n - 1l) && n % y != 0l) {\n                    break\n          \
    \      } else {\n                    counter :+= x\n                }\n      \
    \      }\n        }\n        counter.toList", "        if (n<2) List();\n    \
    \    if (n%2==0) List(n)\n        else {\n            var primes = List();\n \
    \           for (i <- 3l*3l*3l*3l*3l to n.toLong) {\n                if ((n%i)==0)\
    \ primes += i.toLong\n            }\n            primes\n        }", "       \
    \ // TODO: Replace this with your code\n        val arr = new Array[Long](n+1)\n\
    \        for(i<-1 to n){\n            arr(i) = i.toLong\n            if(arr(i).mod(1)\
    \ == 0){\n                arr(i+1) = i.toLong\n            }else{\n          \
    \      arr(i+1) = arr(i+1)+1\n            }\n            \n        }\n       \
    \ val primes = arr.filter{x=>x % 2 == 0}\n        val rem = arr.filter{x => x\
    \ % 2 == 1}.filter{x=>x % 2 != 0}\n        primes.toList ++ rem", "      val aList\
    \ = for (a <- 2 until n) yield {\n        if (n % a > 0) n / a else a\n      }\n\
    \      aList.distinct", "        var lst = List[Long]()\n        for(i<-2 until\
    \ n){\n            val f = i*(i+1)/2\n            for(j<-2 until n){\n       \
    \         if (f+j > n && f+j < n && i%j == 0){\n                    lst += i.toLong\n\
    \                    lst += j.toLong\n                    break\n            \
    \    }\n            }\n        }\n        if (lst.isEmpty) lst += 0l\n       \
    \ lst", "        val primes = Primes.primes\n        val smaller = n / primes.toList\n\
    \        primes.filter(x => x < smaller).takeWhile(x => x < n)", "        require(n\
    \ > 0)\n        var l = new scala.collection.mutable.ListBuffer[Long]()\n    \
    \    var i = 3l\n        while (i <= n) {\n            if (isPrime(i)) {\n   \
    \             l.+=i\n            }\n            i += 1l\n        }\n        l.toList",
  "        var primes = scala.collection.mutable.ArrayBuffer.empty[Long]\n       \
    \ primes = primes.toList\n        for (i <- 2 to n) {\n            if (isPrime(i))\
    \ {\n                primes = primes + i.toLong\n            }\n        }\n  \
    \      primes.toList", "        val ns: Stream[Long] = 1 #:: Stream.from(2 * n\
    \ + 1)\n        if (n % 2 == 1) {\n            ns.takeWhile(_ <= n).reverse.dropWhile(_\
    \ <= n).reverse ++ ns.takeWhile(_ <= n)\n        } else {\n            ns.takeWhile(_\
    \ <= n).reverse.dropWhile(_ <= n).reverse ++ ns.takeWhile(_ <= n).drop(1)\n  \
    \      }", "      n match {\n        case 0l => List()\n        case _ =>\n  \
    \        n match {\n            case n1 if n1 % 2 == 0 => List(n1.toLong)\n  \
    \          case n1 if (n1 - 1l) % 2l*2 == 0 => List(1l.toLong)\n            case\
    \ _ =>\n              val primes = findPrimes(n)\n              primes.map(n =>\
    \ nl.toLong(n))\n          }\n      }", "        val ans = Vector.empty[Long]\n\
    \        val limit = n % 2\n        for (i <- 0 until n / 2) if isPrime(i) {\n\
    \            if (limit == 0) {\n                ans ++= Seq(i)\n            }\
    \ else {\n                limit -= 1\n                ans ++= Seq(i + 2, i + 3)\n\
    \            }\n        }\n        if (n > 1) {\n            ans ++= Seq(n + 2,\
    \ n + 3)\n        }\n        ans.toList", "        var nList: List[Long] = List();\n\
    \        if(n < 2l) nList.add(n.toLong);\n        else {\n            for( i =\
    \ 3l to n ; i += 2l) {\n                if (n % i == 0) nList += (i.toLong);\n\
    \            }\n        }\n        return nList;", "        val factors = new\
    \  mutable.HashSet[Long]()\n        factors.add((2l))\n        factors.add((3l))\n\
    \        while(n > 2l) {\n            var j = 1\n            while(factors.contains((2l\
    \ * j))) {\n                j += 1\n            }\n            factors.add((2l\
    \ * j))\n            n -= (2l * j)\n        }\n        if(n > 1l) {\n        \
    \    factors.add((n-1l))\n        }\n        val ret = new scala.collection.mutable.ListBuffer[Long]()\n\
    \        ret.append(2l)\n        ret.append(3l)\n        while(factors.contains((2l)))\
    \ {\n            ret.append(2l)\n            ret.append(3l)\n        }\n     \
    \   ret", "        // Your code here\n        val primes = scala.collection.mutable.Set.empty[Long]\n\
    \        for( x <- 1 to n )\n        {\n            if( primes.contains(x))\n\
    \            {\n                val n = x % 2\n                if( n == 0)\n \
    \                   primes.update(x)\n            }\n            else\n      \
    \      {\n                primes.add(x)\n            }\n        }\n        primes.toList",
  "        (1 to n) filter {\n            n => isPrime(n)\n        } toList", "  \
    \      val primes = mutable.ListBuffer.empty[Long]\n        for (i <- 2 to n)\
    \ primes ::= i\n        primes", "        val primes = mutable.ListBuffer[Long]()\n\
    \        for (i <- 2 to n by 2)\n            if (n % i == 0)\n               \
    \ primes += i\n        primes ::: List(n.toLong)", "      if (n < 2) List(n)\n\
    \      else {\n        val count: List[Long] = List.empty\n        for (x <- 2\
    \ until (n + 1)) {\n          if (isPrime(x)) {\n            count :+= x\n   \
    \       }\n        }\n        count :+ n\n      }", "        if (n <= 1l) List()\n\
    \        else {\n            val isPrime = List.fill(2l)(2l == n).forall(x =>\
    \ n % x == 0)\n            if (!isPrime) List()\n            else (for (xs <-\
    \ List(n+1l,n+2l,n+3l,n+4l,n+5l,n+6l,n+7l,n+8l,n+9l)) yield {\n              \
    \  val isPrime2 = (xs % 3l == 0)\n                if (!isPrime2) List(xs)\n  \
    \              else {\n                    val isPrime3 = (xs % 5l == 0)\n   \
    \                 if (!isPrime3) List(xs)\n                    else {\n      \
    \                  val isPrime5 = (xs % 7l == 0)\n                        if (!isPrime5)\
    \ List(xs)\n                        else {\n                            val isPrime7\
    \ = (xs % 11l == 0)\n                            if (!isPrime7) List(xs)\n   \
    \                         else {\n                                val isPrime11\
    \ = (xs % 13l == 0)\n                                if (!isPrime11) List(xs)\n\
    \                                else {\n                                    val\
    \ isPrime13 = (xs % 17l == 0)\n                                    if (!isPrime13)\
    \ List(xs)\n                                    else {\n                     \
    \                   val isPrime17 = (xs % 19l == 0)\n                        \
    \                if (!isPrime17) List(xs)\n                                  \
    \      else List(xs.toLong)\n                                    }\n         \
    \                       }\n                            }\n                   \
    \     }\n                    }\n                }\n            })\n        }",
  "        require(n >= 0)\n        val primes = primesInRange(BigInt(n))\n      \
    \  val primeCounts = primes.foldLeft[Map[Long,Long]](Map[Long,Long]()){case (counts,p)\
    \ =>\n            if (p > n) counts else counts + (p -> counts.get(p.toLong) +\
    \ 1)\n        }\n        primeCounts.filter{case (count, num) => (count == num.toLong)}\n\
    \            .map{case (num, count) => (num.toLong, count.toLong)}\n         \
    \   .sortBy(_._1)", "        val l = (2 to n)\n        val m = l.reduceLeft((x,y)\
    \ => if (gcd(x,y) == 1) x else y)\n        m :: l", "        var l : List[Long]\
    \ = List()\n        if (n<2)\n            l\n        else {\n            for (p\
    \ <- 2 to n)\n                if ((n%p)==0)\n                    l :+ p\n    \
    \            else if ((n%p<2)&&(n%p>0))\n                    l :+ p\n        }",
  "      val i = 2l\n      val a = (1 to i).filter(i => n % i == 0).dropWhile(i %\
    \ _ != 0)\n      a.takeWhile(x => x < n).toList.sorted", "        if (n < 2) List(n)\n\
    \        else {\n            val primes = List(2,3l)\n            val numbers\
    \ = List(n-1l)\n            while (numbers.nonEmpty) {\n                val nextPrime\
    \ = numbers.head * primes.head\n                if (numbers.tail.exists(x => primes.contains(x)))\
    \ {\n                    primes = primes.drop(1)\n                    numbers\
    \ = numbers.tail\n                } else {\n                    numbers = numbers\
    \ ::: List(nextPrime)\n                    break\n                }\n        \
    \    }\n            primes.takeWhile(x => x <= n).toList\n        }", "      \
    \  if(n < 3) {\n            List(n)\n        }\n        else {\n            var\
    \ counter : Long = 1\n            val list = new mutable.LinkedList[Long]()\n\
    \            while(counter <= n) {\n                if(isPrime(counter)) {\n \
    \                   list += counter\n                    counter += 2\n      \
    \          }\n                else {\n                    counter += 1\n     \
    \           }\n            }\n            list.toList\n        }", "        def\
    \ count(x : (Long, Long)) = x match {\n            case (x, y ) if x > y => (x,\
    \ y+1)\n            case _ => (x, 1)\n        }\n        var l : List[Long] =\
    \ Nil\n        for (x <- 2l to n) yield {\n            var c : Long = count(x)\n\
    \            while (c < x) l += c\n            c\n        }", "        def isPrime(x\
    \ : Long) : Boolean = {\n            val sqrt = Math.sqrt(x)\n            sqrt\
    \ <= 1 &&\n                sqrt != 0 &&\n                (x % sqrt < 2)\n    \
    \    }\n\n        def checkPrime(n: Long) : Boolean = {\n            var i = 2\n\
    \            while (i <= sqrt(n)) {\n                if (isPrime(i)) {\n     \
    \               return true\n                }\n                i += 1\n     \
    \       }\n            false\n        }\n\n        def isPrimeRec(n : Long) :\
    \ List[Long] = {\n            if (n < 2) {\n                return Nil\n     \
    \       }\n            if (checkPrime(n)) {\n                return (n :: Nil)\n\
    \            }\n            return isPrimeRec(n - 1) ++ checkPrime(n)\n      \
    \  }\n\n        return isPrimeRec(n)", "        var primes = mutable.List.empty[Long]\n\
    \        for (i <- 2 to n) {\n            primes ++= if (isPrime(i)) i :: Nil\
    \ else primes.dropWhile(i => i % i != 0)\n        }\n        primes", "      \
    \  // Your code goes here\n        var primeList: List[Long] = Nil\n        var\
    \ lastPrime: Long = 2\n        \n        while(lastPrime < n){\n            primeList\
    \ = primeList :+ (lastPrime :+ lastPrime)\n            lastPrime = lastPrime +\
    \ 1\n        }\n        \n        return primeList", "        n match {\n    \
    \        case 0 :: _ | 1 :: Nil => Nil\n            case _ if n % 2 == 0 =>\n\
    \                n :: countUpTo(n / 2)\n            case _ if n % 3 == 0 =>\n\
    \                n :: countUpTo(n / 3)\n            case n =>\n              \
    \  n :: countUpTo(n / 2) ++ countUpTo(n / 3)\n        }", "        var result\
    \ : List[Long] = List[Long]()\n        var p = 3l\n        var j = 0\n       \
    \ while (j < n) {\n            while (p <= (n-j) && p != 1) { p += 2l }\n    \
    \        if (p == 1) { j += 1; result += j }\n            p -= 1\n        }\n\
    \        result", "        val primeList: List[Long] = 2l..n\n        val result:\
    \ mutable.List[Long] = mutable.ListBuffer[Long]()\n        var currentPrime: Long\
    \ = 1l\n        for (prime <- primeList) {\n            var i = 1\n          \
    \  var primeCheck : Boolean = true\n            var primeChecker : Long = 1\n\
    \            while (primeCheck) {\n                if ((primeChecker*prime) <\
    \ (currentPrime)) {\n                    if ((n % prime) == 0) {\n           \
    \             primeCheck = false\n                    } else {\n             \
    \           primeChecker = primeChecker + 1\n                    }\n         \
    \       } else {\n                    primeChecker = primeChecker + 1\n      \
    \          }\n                i += 1\n                if (i == currentPrime) {\n\
    \                    result.add(prime.toLong)\n                    currentPrime\
    \ += 1\n                }\n            }\n        }\n        result.toList", " \
    \       var nextPrime : Long = 1\n        val prime : List[Long] = List[Long]()\n\
    \        val nums = List[Long]()\n        var i = 2\n        while (i < n){\n\
    \            nums = nums :+ i\n            if (isPrime(nextPrime) && nums.lastPrimeTo(n)\
    \ < nextPrime) {\n                prime :+= nextPrime\n                nextPrime\
    \ += 1\n            }\n            i += 1\n        }\n        if (nums.lastPrimeTo(n)\
    \ < n) {\n            prime :+= n\n        }\n        return prime", "       \
    \ if((n<2))\n            List()\n        else {\n            var result : List[Long]\
    \ = List(n.toLong)\n            var i : Long = 2\n            while(result.length<=i)\n\
    \                if((i%result.length)==0)\n                    result ::: List(n.toLong)\n\
    \                else {\n                    result ::: List(n/i)\n          \
    \          i = i*i\n                }\n            result\n        }", "     \
    \ var primes: List[Long] = List(0)\n      for(i <- 2 to n){\n        if(isPrime(i)){\n\
    \          primes = primes ::: List(i)\n        }\n      }\n      primes", " \
    \       def isPrime(x : Long) : Boolean = {\n            if (x < 2) false\n  \
    \          if (x > n/2) false\n            var prime = x*x\n            var isPrime\
    \ = true\n            while (prime <= n) {\n                if (n % prime == 0)\
    \ isPrime = false\n                prime += x\n            }\n            isPrime\n\
    \        }\n        if (n < 1) return Nil\n        var list : List[Long] = Nil\n\
    \        for (prime <- 2 to n) {\n            if (!isPrime(prime)) list = list\
    \ ::: List(prime)\n        }\n        list", "        var result: List[Long] =\
    \ List() // start with a blank list\n        var i = 2l\n        while (i * i\
    \ <= n) {\n            for (j <- 2l; j < (i * i); j += i) {\n                if\
    \ (n % j == 0) {\n                    result.append(j.toLong)\n              \
    \      break\n                }\n            }\n            i += 1\n        }\n\
    \        result", "        var l = []\n        if(n < 2) l += n\n        else\
    \ if(n > 2) l += 2\n        else\n        for(i <- 3 to n/2-1 by 2)\n        if(n\
    \ % i == 0) l += i\n        else if(n % i == 1)\n            l += i\n        else\n\
    \            l += n/i\n        l ++ (n until 2 by -1).map( n => (n to (n-1)).filter(_\
    \ % _ == 0).takeWhile(x => x < n).map( n => (n to (n-1)).filter(_ % _ == 0).takeWhile(x\
    \ => x < n).filter(_ % _ != 0).map( i => (n to (n-1)).filter(_ % _ == 0).takeWhile(x\
    \ => x < n).filter(_ % _ != 0).takeWhile(x => x < i).map( i => (n to (n-1)).filter(_\
    \ % _ == 0).takeWhile(x => x < n).filter(_ % _ != 0).takeWhile(x => x < i).map(\
    \ i => (n to (n-1)).filter(_ % _ == 0).takeWhile(x => x < n).filter(_ % _ != 0).takeWhile(x\
    \ => x < i).map( i => (n to (n-1)).filter(_ % _ == 0).takeWhile(x => x < n).filter(_\
    \ % _ != 0).takeWhile(x => x < i).map( i => (n to (n-1)).filter(_ % _ == 0).takeWhile(x\
    \ => x < n).filter(_ % _ != 0).takeWhile(x => x < i).map( i => (n to (n-1)).filter(_\
    \ % _ == 0).takeWhile(x => x < n).filter(_ % _ != 0).takeWhile(x => x < i).map(\
    \ i => (n to (n-1)).filter(_ % _ == 0).takeWhile(x => x < n).filter(_ % _ != 0).takeWhile(x\
    \ => x < i).map( i => (n to (n-1)).filter(_ % _ == 0).takeWhile(x => x < n).filter(_\
    \ % _ != 0).takeWhile(x => x < i).map( i => (n to (n-1)).filter(_ % _ == 0).takeWhile(x\
    \ => x < n).filter(_ % _ != 0).takeWhile(x => x < i).map( i => (n to (n-1)).filter(_\
    \ % _ == 0).takeWhile(x => x < n).filter(_ % _ != 0).takeWhile(x => x < i).map(\
    \ i => (n to (n-1)).filter(_ % _ == 0).takeWhile(x => x < ", "        require(n\
    \ > 0)\n        var l = n.toLong\n        if (n == 1) List(2l.toLong)\n      \
    \  else {\n            while (l < n / 2) l += 2\n            val primes = Primes.primes(l)\n\
    \            if (primes.isEmpty || primes.exists(_ < l)) List()\n            else\
    \ {\n                val r = new collection.mutable.ArrayBuffer[Long]()\n    \
    \            primes.foreach {\n                    case p => if (p > l) r else\
    \ r.+(p)\n                }\n                r\n            }\n        }", " \
    \       var isPrime : Boolean = false\n        var isDivisible : Boolean = true\n\
    \        var list : List[Long] = Nil\n        var currentNumber : Long = n.toLong\n\
    \        while (!isPrime) {\n            currentNumber += 1\n            for (number\
    \ <- 2 until currentNumber) {\n                if (isDivisible && (n % number\
    \ == 0)) {\n                    isPrime = false\n                    isDivisible\
    \ = false\n                    list = list :+ number\n                }\n    \
    \            if (!isDivisible && (n % number != 0)) {\n                    isPrime\
    \ = true\n                    isDivisible = true\n                }\n        \
    \    }\n        }\n        list", '        // TODO: Implement', "        if (n\
    \ < 2) List() else {\n            val counts = mutable.HashMap[Long, Long]()\n\
    \            val primes = mutable.ArrayBuffer.empty[(Long, Long)]\n          \
    \  val result = mutable.ArrayBuffer.empty[Long]\n            var lastPrime = 0\n\
    \            while (n > 0) {\n                val next = math.ceil(n/2).toLong\n\
    \                lastPrime = next\n                n -= next\n               \
    \ \n                // check if it is a prime and append to counts\n         \
    \       def isPrime(x: Long) = x % next == 0\n                for (x <- 2 to next)\
    \ if (!isPrime(x)) {\n                    val c = counts.put(lastPrime, x) + 1\n\
    \                    if (c > 2) {\n                        prime += lastPrime\n\
    \                        primes += ((lastPrime, lastPrime))\n                \
    \    }\n                }\n            }\n            \n            // Now we\
    \ have primes, sorted in decreasing order\n            // Now take top n from\
    \ counts\n            val res = primes.toSeq.sortWith((_,b) => b._1 < a._1)\n\
    \            \n            // And append the rest from counts\n            val\
    \ rem = counts.keySet.toSeq.sortWith((_,b) => b._1 < a._1)\n            for (x\
    \ <- rem.take(n)) result += x\n            result.toList\n        }", "      \
    \  val buffer = new mutable.ListBuffer[Long]()\n        for (i <- 1l to n) yield\
    \ {\n            if (isPrime(i) && i % 2l == 0l) {\n                if (i >= n)\n\
    \                    buffer += i.toLong\n            } else buffer += i.toLong\n\
    \        }\n        buffer.toList", "        val primes = mutable.MutableList[Long]()\n\
    \        primes.add(2)\n        primes.add(3)\n        while (primes.size < n)\
    \ {\n            val nextPrime = primes.takeWhile(p => p * p <= n).head\n    \
    \        primes.add(nextPrime)\n        }\n        primes.take(n).toList", " \
    \       val l = List(2 to n)\n        l.filterNot(_ % _ == 0).takeWhile(_ <= n).toList",
  "      // TODO\n      var l : List[Long] = List()\n      for(i <- 1 to n){\n   \
    \     l :+= i.toLong\n        for(j <- 2 to i){\n          if(i % j == 0){\n \
    \           l :+= j.toLong\n          }\n        }\n      }\n      l", "     \
    \   val nums = for (i <- 2 to n) yield i.toLong\n        val n = nums.size\n \
    \       val list = nums.filter{ x => primeFactors(x)==n}.toList\n        if(list.isEmpty)\
    \ List(n.toLong) \n        else list", "        val list = ListBuffer[Long]()\n\
    \        val primes = ListBuffer[Long]()\n        val i = 2\n        while(n>0)\
    \ {\n            if(n%i == 0) {\n                primes += i.toLong\n        \
    \        list.+=(i.toLong)\n            }\n            i +=1\n            n -=\
    \ 1\n        }\n        return primes ++ list.map(x => x + n).toList", "     \
    \   val ps = List(n * 2l, (3 * n) - 2l, n - 2l)\n        if (ps.exists(p => n\
    \ % p == 0 || n % p == -1l)) {\n            ps\n        } else {\n           \
    \ ps\n        }", "      val (prime, factors) = primeFactorize(n)\n      (for\
    \ {\n        p <- prime\n        l <- factors\n        if p <= n\n        if n\
    \ / l == n\n      } yield p).toList", "        require(!n.isZero, \"Cannot count\
    \ up to zero\")\n        require(n>0, \"Cannot count up to negative numbers\"\
    )\n        val l = new mutable.ListBuffer[Long]\n        var i = 2\n        val\
    \ primes = List.from(2 to n)\n        while (primes.contains(i) && primes.contains(n))\
    \ {\n            l.+=(i)\n            if (l.size > n) l.take(n-l.size)\n     \
    \       i = i + 2\n        }\n        l.toList", "        var res: List[Long]\
    \ = Nil\n        for (i <- 2 to n) {\n            if (isPrime(i)) {\n        \
    \        if (i <= n.toLong) {\n                    res = i :: res\n          \
    \      }\n            } else {\n                res = res\n            }\n   \
    \     }\n        res", "        require(n>=0)\n        var result: List[Long]\
    \ = List()\n        for( x <- 2 to n by 2){\n            if(isPrime(x)){\n   \
    \             if(result.length==0){\n                    result += List(x.toLong)\n\
    \                }else{\n                    result += (x to result.last.last).toList\n\
    \                }\n            }\n        }\n        result", "        if (n\
    \ == 0) Nil\n        else if (n % 2 == 0) List(n) :: countUpTo((n + 1l))\n   \
    \     else (for (p <- 2 to sqrt(n) by 2) if (n % p == 0) && (p < n / p)) List(n\
    \ + p) :: countUpTo((n + p + 1l))", "        if (n==0) Nil\n        else List(n:).sliding(2,2)\n\
    \                .map(_.filter(_._1==0 || _._2==1).map(_.sum))\n             \
    \   .map(_.filter(_>0).toList)\n                .toList.flatten", "        var\
    \ list = List[Long]()\n        var num = 2\n        while (n > num) {\n      \
    \      val rem = n % num\n            if (rem == 0) {\n                list +=\
    \ num\n            }\n            num += 1\n        }\n        list", "      \
    \  var counter = n\n        var primes: List[Long] = List()\n        while (counter\
    \ > 0) {\n            val prime = scala.math.remainder(counter, 2l)\n        \
    \    if (!primes.contains(prime)) {\n                primes ++= List(counter)\n\
    \            }\n            counter -= 1\n        }\n        primes", "      \
    \  var result : List[Long] = List()\n        var i = 2\n        while (n>0 &&\
    \ n>i.toLong) {\n            if (isPrime(i.toLong)) {\n                result\
    \ = result :+ i.toLong\n                i += 1\n            }\n            n -=\
    \ 1\n        }\n        if (n>0)\n            result :+= n\n        result", " \
    \       val primeList = PrimeList.primes\n        val primesLessThanN = primeList.takeWhile(p\
    \ => p < n).toList\n        val primesLessThanNPlusOne = primesLessThanN.head\
    \ :: primesLessThanN\n        val primesLessThanNMinusOne = primesLessThanN.tail\
    \ :+ primesLessThanN.head - 1\n        val divisors = primesLessThanNMinusOne.map(divisor\
    \ => (divisor * divisor).toInt)\n        val numPrimes = primes.count\n      \
    \  val numDivisors = divisors.count\n        val sumDivisors = divisors.sum\n\
    \        val primesLessThanNList = primesLessThanN.tail\n        val primesLessThanNListPlusOne\
    \ = primesLessThanNList.tail\n        val primesLessThanNListMinusOne = primesLessThanNList.head\
    \ :: primesLessThanNList\n        val primesLessThanNListMinusOnePlusOne = primesLessThanNListMinusOne.tail\n\
    \        val primesLessThanNListMinusOneMinusOne = primesLessThanNListMinusOne.head\
    \ :: primesLessThanNListMinusOne\n        val primesLessThanNListMinusOnePlusOneMinusOne\
    \ = primesLessThanNListMinusOnePlusOne.head :: primesLessThanNListMinusOnePlusOne\n\
    \        val primesLessThanNListMinusOnePlusOnePlusOne = primesLessThanNListMinusOnePlusOne.tail\n\
    \n        if (numPrimes == 0) {\n            primesLessThanNListMinusOnePlusOnePlusOne\n\
    \        } else if (numDivisors == 0) {\n            primesLessThanNListMinusOnePlusOneMinusOne\n\
    \        } else {\n            val nextPrimesLessThanN = primesLessThanNListMinusOnePlusOnePlusOne.last\n\
    \            val nextDivisors = divisors.last\n            val nextDivisorsPlusOne\
    \ = nextDivisors.map(divisor => (divisor + 1).toInt)\n            val nextDivisorsMinusOne\
    \ = nextDivisors.map(divisor => (divisor - 1).toInt)\n            val nextPrimesLessThanNPlusOne\
    \ = nextPrimesLessThanN.head :: nextPrimesLessThanN\n            val nextPrimesLessThanNMinusOne\
    \ = nextPrimesLessThanN.tail :+ nextPri", "        val primes = Primes.primes\n\
    \        val primesIndexes = primes.zipWithIndex.toList\n        val primesIndexesSortedByPrime\
    \ = primesIndexes.sortBy(_._1).reverse\n        val result: List[Long] = List[Long]()\n\
    \        val max = primesIndexes.last\n        val min: Long = 0\n        var\
    \ currentPrimeIndex = 0\n        val index = primesIndexesSortedByPrime.filter(p\
    \ => p._1 < n).last._2\n        primesIndexesSortedByPrime.foreach(p => {\n  \
    \          if (p._2 <= index) {\n                return\n            }\n     \
    \       val current = p._2\n            if (p._1 == currentPrimeIndex && current.toLong\
    \ == 1) {\n                result.add(max + ((current.toLong - 1) * index))\n\
    \                currentPrimeIndex = currentPrimeIndex + 1\n            }\n  \
    \      })\n        result", "        val primes = List(2)\n        for (p <- primes)\
    \ {\n            val q = n/p\n            if (q==0) continue\n            val\
    \ isPrime = true\n            if (q>0) {\n                for (i <- 0 until q)\
    \ {\n                    if (n%(i+p)==0) {\n                        isPrime =\
    \ false\n                        break\n                    }\n              \
    \  }\n            }\n            if (isPrime) primes ::: List(p)\n        }\n\
    \        primes.reverse", "        if (n == 0l) Nil\n        else (for (p <- 2\
    \ to n) yield if (n % p == 0) p else 0l).toList", "        val primeList: List[Long]\
    \ = List(n+2l).takeWhile(_ <= math.sqrt(n).toInt).toList\n        if (primeList.isEmpty)\
    \ List() else primeList", "        val count = (2 to n).filter(x => n / x < (n\
    \ / x).floor)\n        count.map(x => n * x).filter(_ < n).map(n => n.toLong).toList",
  "        var count = new mutable.HashMap[Long, Long]()\n        var list = new mutable.LinkedList[Long]()\n\
    \        for (i <- 2l to n) if (count.contains(i)) \n            list.add(count)\n\
    \        else count += i -> 1\n        list.filter(i => i.get < n).map(i => i.get\
    \ -> list.remove(i.key))", "        val primes = mutable.ListBuffer[Long]()\n\
    \        var primeCount : Long = 0\n        primes ++= primes.filter(_ <= n).filter\
    \ { n =>\n            primeCount += 1\n            val isPrime = n % _ == 0 &&\
    \ (n <= (sqrt(n).toLong - 1.0))\n            if (isPrime) primeCount += 1\n  \
    \          isPrime\n        }\n        primes.takeWhile(_ < n).reverse"]
stop_tokens:
- "\n    }\n"
