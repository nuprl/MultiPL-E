name: HumanEval_16_count_distinct_characters
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Given a string, find out how many distinct characters (regardless of case)\
  \ does it consist of\n    // >>> countDistinctCharacters((\"xyzXYZ\"))\n    // (3l)\n\
  \    // >>> countDistinctCharacters((\"Jerry\"))\n    // (4l)\n    def countDistinctCharacters(string\
  \ : String) : Long = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(countDistinctCharacters((\"\
  \")) == (0l));\n    assert(countDistinctCharacters((\"abcde\")) == (5l));\n    assert(countDistinctCharacters((\"\
  abcdecadeCADE\")) == (5l));\n    assert(countDistinctCharacters((\"aaaaAAAAaaaa\"\
  )) == (1l));\n    assert(countDistinctCharacters((\"Jerry jERRY JeRRRY\")) == (5l));\n\
  \    }\n\n}\n"
completions: ["        var count = 0\n        for (char <- string) {\n           \
    \ if (string.contains(char)) {\n                count += 1\n            }\n  \
    \      }\n        count", "        var distinctCharacters = Set.empty[Char]\n\
    \        var count = 1\n        for (character <- string) {\n            distinctCharacters\
    \ += character\n            count += 1\n        }\n        return distinctCharacters.toList.distinct\
    \ + count", "        val count = mutable.HashMap.empty[String, Long]\n       \
    \ string.foreach(char=>{\n            var counter: Long = 0\n            if(!count.contains(char.toLowerCase))\
    \ counter += 1 else counter = counter + 1\n            if(!count.contains(char.toUpperCase))\
    \ counter += 1 else counter = counter + 1\n            count.put(char, counter)\n\
    \        })\n        count.values.sum", "        var countDistinctCharacters =\
    \ 1\n        string.foreach(s => {\n            s match {\n                case\
    \ char => countDistinctCharacters = countDistinctCharacters + 1\n            \
    \    case _ => countDistinctCharacters = countDistinctCharacters + countDistinctCharacters\n\
    \            }\n        })\n        countDistinctCharacters", '        string.foldLeft(1L)((a,
    b) => (a.asInstanceOf[Long] + b.asInstanceOf[Long]).asInstanceOf[Long])', "  \
    \      val charSet = new mutable.HashSet[Char]()\n        string.foreach(charSet.update(_))\n\
    \        charSet.size()", "        val charArray = string.toLowerCase().toCharArray\n\
    \        val countMap = mutable.HashMap[Char,Int]()\n        charArray.foreach(char=>{\n\
    \            countMap += (char)=>countMap.getOrElse(char,0)+1\n        })\n  \
    \      countMap.size", "        var distinctCharacters = 0L\n        string.foreach\
    \ { x =>\n            if(!string.exists(y => x == y))\n                distinctCharacters\
    \ += 1\n        }\n        return distinctCharacters", "        var count = 0\n\
    \        var chars = new mutable.HashSet[Char]()\n        for (i <- 0 to string.length\
    \ - 1) {\n            if (chars.contains(string.charAt(i))) {\n              \
    \  count += 1\n            } else {\n                chars.add(string.charAt(i))\n\
    \            }\n        }\n        count", "        var counter = 0\n        for(character\
    \ <- string.toCharArray) {\n            if(string.count(_ == character) != 0)\
    \ {\n                counter += 1\n            }\n        }\n        counter.toLong",
  "        val counts = HashMap[Char, Long]()\n        for (x <- string.toList) counts(x)\
    \ += 1\n        counts.foldLeft(0)((x, y) => x + y)", "        def countChar(character\
    \ : Char) : Long = {\n            val counter = mutable.LinkedHashMap.empty[Char,\
    \ Int]\n            for (c <- string) {\n                if (c != character) {\n\
    \                    counter(c) += 1\n                }\n            }\n     \
    \       counter.values.toSet.size // number of distinct characters\n        }\n\
    \        return string.map(x => x.toUpperCase()).map(x => countChar(x)).reduceLeft(_\
    \ + _)", "        val distinctCounts = mutable.TreeMap[Char, Long]()\n       \
    \ for(i <- 0 until string.length){\n            val char = string.charAt(i)\n\
    \            distinctCounts(char) match {\n                case None => {\n  \
    \                  distinctCounts += (char -> 1)\n                }\n        \
    \        case Some(_) => {\n                    distinctCounts += (char -> distinctCounts(char)\
    \ + 1)\n                }\n            }\n        }\n        distinctCounts.valuesIterator.map(_.toLong).sum",
  "        val chars = string.map(c => c.toChar)\n        val unique = chars.distinct\n\
    \        unique.length", "        val charArray = string.toLowerCase().toCharArray\n\
    \        val charSet = new mutable.HashSet[Char]()\n        charArray.foreach{\
    \ c => \n            c match {\n                case c if charSet.contains(c)\
    \ => charSet.remove(c)\n                case _ => charSet.add(c)\n           \
    \ }\n        }\n        return charSet.size ", "        if(string.isEmpty){\n\
    \            return 0\n        }\n        val distinctCharacterSet = mutable.Set.empty[Char]\n\
    \        string.foreach(distinctCharacterSet += _)\n        return distinctCharacterSet.length",
  "        val charSet = string.map(_.toLower)\n        val uniqueCharSet = charSet.toSet\n\
    \        uniqueCharSet.size", "        string.map { c =>\n            val toUpper\
    \ = c.toUpperCase()\n            val toLower = c.toLowerCase()\n            if\
    \ (toUpper == toLower) 1\n            else if (toUpper < toLower) toUpper.toString.length\
    \ + (toLower.toString.length - 1)\n            else toLower.toString.length +\
    \ (toUpper.toString.length - 1)\n        }.distinct\n", "        string.foldLeft[Long](0)\
    \ { case (acc, char) =>\n            char match {\n                case c if c.isUpperCase\
    \ => acc + Character.isUpperCase(c) ?? 0\n                case c if c.isLowerCase\
    \ => acc + Character.isLowerCase(c) ?? 0\n                case _             \
    \    => acc + 0\n            }\n        }", "        val distinctCount = scala.collection.mutable.HashMap.empty[String,\
    \ Int]\n        for (c <- string) {\n            distinctCount.getOrElseUpdate(c,\
    \ 0) += 1\n        }\n        distinctCount.values.sum", "        val chars =\
    \ string.toSet\n        val distinct = chars.distinct\n        distinct.size",
  "        val buffer = new collection.mutable.ArrayBuffer[Char]\n        var count\
    \ = 0L\n        for (c <- string) {\n            buffer += c\n            count\
    \ += 1\n        }\n        return buffer.distinct.length", "        var charCount\
    \ = string.size\n        var distinctCharCount = charCount\n        for (letter\
    \ <- string) {\n            charCount -= 1\n            if (charCount == 0) {\n\
    \                distinctCharCount += 1\n            }\n        }\n        distinctCharCount",
  "        val set = new mutable.HashSet[Char]()\n        for (char : String <- string.toCharArray)\
    \ {\n            set.add(char)\n        }\n        return set.size", "       \
    \ val mutableSet = scala.collection.mutable.Set[Char]()\n        for (i <- 0 until\
    \ string.length) {\n            val current = string.charAt(i)\n            if\
    \ (!mutableSet.contains(current)) {\n                mutableSet += current\n \
    \           }\n        }\n        mutableSet.length", "        val hashSet = new\
    \ mutable.HashSet[Char]()\n        var count = 0\n        for(str <- string){\n\
    \            hashSet+=str\n            count += 1\n        }\n        return hashSet.size",
  "        val distinct = scala.collection.mutable.HashSet[Char]()\n        string.foreach(x\
    \ => distinct.add(x))\n        distinct.size", "        val charSet = mutable.Set[Char]()\n\
    \        for(i <- 0 until string.length){\n            val c = string.charAt(i)\n\
    \            if(!charSet.contains(c)){\n                charSet += c\n       \
    \     }\n        }\n        return charSet.size", "        var result : Long =\
    \ 0\n        var lowerChars = string.lower\n        var upperChars = string.upper\n\
    \n        while(lowerChars.length != 0 && upperChars.length != 0) {\n        \
    \    if(lowerChars(0) == upperChars(0)) {\n                lowerChars = lowerChars.substring(1);\n\
    \                upperChars = upperChars.substring(1);\n                result\
    \ += 1\n            }\n            else {\n                if(lowerChars(0) >\
    \ upperChars(0)) {\n                    result += 1\n                }\n     \
    \           else {\n                    result -= 1\n                }\n     \
    \       }\n        }\n        result", "        val uniqueChars = string.toLowerCase\
    \ +: string.toUpperCase +: string.dropRight(1)\n        uniqueChars.distinct\n\
    \            .foldLeft((0,0)){\n                case ((count, prevChar), nextChar)\
    \ => (count+1, prevChar +: nextChar)\n            }._1", "        val charCounts\
    \ : mutable.HashMap[Char, Long] = mutable.HashMap.empty\n        for (char <-\
    \ string.toCharArray){\n            if (charCounts.contains(char)) charCounts(char)\
    \ += 1\n            else charCounts += char -> 1\n        }\n        charCounts.size",
  "        var chars = mutable.Set.empty[Char]\n        for(c <- string.toCharArray)\
    \ chars += c\n        chars.size", "        val unique = mutable.HashSet[String]()\n\
    \        for( c <- string.toCharArray ) {\n            if( unique.contains(c)\
    \ ) {\n                unique(c) = unique(c) + 1\n            } else {\n     \
    \           unique.add(c)\n            }\n        }\n        return unique.length",
  "        var distinctCharacters : Long = 0\n        string.foreach(char=>{\n   \
    \         val isCharInSet = Set(\"a\"...\"z\").contains(char)\n            if\
    \ (isCharInSet) distinctCharacters = distinctCharacters + 1\n        })\n    \
    \    return distinctCharacters", "        val charArray = string.map(c => c.toLowerCase).toCharArray\n\
    \        val distinctCharacters = mutable.Set.empty[Char]\n        for (c <- charArray)\
    \ {\n            if (!distinctCharacters.contains(c)) {\n                distinctCharacters\
    \ += c\n            }\n        }\n        distinctCharacters.size", "        if(string.length\
    \ == 0) {\n            return 0\n        }\n        var count = 0\n        var\
    \ isUpper = true\n        for(c <- string) {\n            if(!isUpper && c.toUpper\
    \ != c.toLowerCase) {\n                count++\n                isUpper = !isUpper\n\
    \            }\n            if(!isUpper && c.toLower != c.toUpper) {\n       \
    \         count++\n                isUpper = !isUpper\n            }\n       \
    \ }\n        count", "        var count = 0; val strArray = string.toLowerCase\
    \ // convert the string to all lower case\n        for (char <- strArray) {\n\
    \            if (strArray.contains(char)) {\n                count = count + 1\n\
    \            }\n        }\n        return count", "        if (string.length ==\
    \ 0) return 1\n        var chars = \"\"\n        for (x <- string) chars = x +\
    \ chars\n        return chars.distinct", "        var unique = 0L\n        for\
    \ (c <- string) {\n            if (string.count(_ == c) == 1) unique += 1L\n \
    \       }\n        unique", "        // Convert input string to a mutable set\n\
    \        val chars = string.toSet\n\n        // Compute the number of distinct\
    \ characters\n        val distinct = chars.size\n\n        // Return the result\n\
    \        distinct", "        var distinctCharacters = \"\"\n        var count\
    \ = 0\n        for (i<-0 until string.length){\n            val character = string.charAt(i)\n\
    \            if (character.toUpperCase == character) {\n                distinctCharacters\
    \ += character\n            } else {\n                distinctCharacters = distinctCharacters.toLowerCase\n\
    \                distinctCharacters += character\n            }\n            if\
    \ (distinctCharacters.toLowerCase.length == 1){\n                count +=1\n \
    \           }\n            distinctCharacters = distinctCharacters.toLowerCase\n\
    \        }\n        count", "        var count = mutable.Map[Char, Long]()\n \
    \       var c = -1\n        for(i <- string.toCharArray){\n            c += 1\n\
    \            if(count.contains(i)){\n                count(i) += 1\n         \
    \   } else {\n                count(i) = 1\n            }\n        }\n       \
    \ count.map(_._2).sum", "        string match {\n            case \"[\\\\W\\\\\
    D]+\" => string.count(\"[\\\\W\\\\D]+\")\n            case _ => 0\n        }",
  "        var charArray = Array[Char](string.toCharArray)\n        var distinctCharacterCount\
    \ : Long = 1\n        charArray.filter(x => x != ' ').foreach { x =>\n       \
    \     if (charArray.contains(x.toString)) {\n                distinctCharacterCount\
    \ = distinctCharacterCount + 1\n            }\n        }\n        distinctCharacterCount",
  "        val charArray = string.map(x => x.toLower).map(_.toInt).toArray\n     \
    \   val charSet = scala.collection.mutable.Set[Char]()\n        charArray.foreach(x\
    \ => charSet += x)\n        charSet.size", "        val count = mutable.HashSet.empty[Char]\n\
    \        var count = 0\n        for (letter <- string) {\n            if(!count.contains(letter))\
    \ count += letter\n        }\n        count", "        def count(string : String,\
    \ prefix : String) : Long = {\n            val stringLength = string.length\n\
    \            val newPrefix = prefix + string(0)\n            if (stringLength\
    \ == 1) 1\n            else count(string.substring(1), newPrefix) + (newPrefix.toLowerCase.indexOf(string(1)).toLong\
    \ - newPrefix.toLowerCase.indexOf(string(0)).toLong)\n        }\n        return\
    \ count(string, \"a\")", "        val map = mutable.Map.empty[Char, Long]\n  \
    \      for( character <- string )\n            map( character.toChar ) += 1\n\
    \        map.toSeq.map( c => c._1 ).distinct\n            .foldLeft(0l) { (l,\
    \ char) => l += map.getOrElse(char, 0l) }", "        string.filterNot(_ == '-').foldLeft(0)\
    \ { (sum, s) =>\n            if (sum > s.length) sum\n            else sum + s.length\n\
    \        }", "        var count = 0\n        for (character <- string) {\n   \
    \         count += (character)\n        }\n        count", "        string.foldLeft(0L)((count,\
    \ letter) =>\n            if (letter.equalsIgnoreCase(string.head)) (count + 1L)\
    \ else (count))", "        val characterSet = new mutable.HashSet[Char]()\n  \
    \      var count = 0\n        for(c <- string) if (characterSet.contains(c)) count\
    \ += 1\n        count", "        var unique = Set.empty[Char]\n        for (c\
    \ <- string) {\n            unique += c\n        }\n        return unique.length",
  "        def getCharacter(string: String) : String = {\n            def getChar(str:\
    \ String) : String = {\n                str.substring(0,1)\n            }\n  \
    \          getChar(string)\n        }\n        def count(string : String) : Long\
    \ = {\n            def count(chars : String) : Long = {\n                chars.count{\
    \ char =>\n                    string.count(getCharacter(char))\n            \
    \    }\n            }\n            count(string)\n        }\n        count(string)",
  "        if(string.isEmpty) return 0\n        val chars = string.flatMap(_.toChar).distinct\n\
    \        chars.size", "        var uniqueCharsCount = 0L\n        for(x <- string.toCharArray)\
    \ {\n            uniqueCharsCount += 1\n            if(uniqueCharsCount > 1) {\n\
    \                uniqueCharsCount = 1\n            }\n        }\n        return\
    \ uniqueCharsCount", "        val ret = new mutable.HashSet[Char]()\n        string.foreach(c\
    \ => if (ret.contains(c.toLower)) ret.remove(c.toLower) else ret.add(c.toLower))\n\
    \        ret.size", "        val uniqueCharacters = string.distinct\n        var\
    \ count = 1\n        var newString = \"\"\n        for (c <- uniqueCharacters)\
    \ {\n            if (newString.contains(c)) {\n                count += 1\n  \
    \          } else {\n                newString += c\n                count +=\
    \ 1\n            }\n        }\n        return count", "        // TODO: write\
    \ code here\n        val chars = string.map(c => c.toLower)\n        val uniqueChars\
    \ = mutable.Set.empty[Char]\n        chars foreach { c =>\n            uniqueChars\
    \ += c\n        }\n        uniqueChars.size", "        var distinct_chars = Map[Char,\
    \ Int]()\n        for(i <- string.toCharArray) {\n            distinct_chars(i)\
    \ = distinct_chars(i) match {\n            case 0 => 1\n            case x =>\
    \ x + 1\n            }\n        }\n        distinct_chars.size", "        if (string.length\
    \ == 0)\n            return 0L\n        var distinctChar = 0L\n        string.foreach(char\
    \ => distinctChar += if (char.toLowerCase() != char) 1 else 0)\n        distinctChar",
  "        var result : Long = 0\n        for (i <- 0 until string.length) {\n   \
    \         var count : Long = 1\n            var char = string(i)\n           \
    \ for (j <- i + 1 until string.length)\n                if (string(i) == string(j))\
    \ {\n                    count += 1\n                }\n            if (count\
    \ > 1) {\n                result += count\n            }\n        }\n        result",
  "        var distinctCharsCount = 0\n        for (i <- 0 to string.length-1){\n\
    \            var charToAdd = string.charAt(i)\n            if(!distinctCharsCount.contains(charToAdd)){\n\
    \                distinctCharsCount += 1\n            }\n        }\n        distinctCharsCount",
  "        val counts = mutable.HashMap.empty[Char, Int]\n        for (ch <- string)\n\
    \            counts.update(ch, counts(ch)+1)\n        counts.size", "        var\
    \ count = 0\n        for (i <- string.toCharArray) {\n            count += string.count(_\
    \ == i)\n        }\n        count", "        var count : Long = 0\n        for\
    \ (char <- string) {\n            count = count + 1\n        }\n        return\
    \ count", "        var distinctCharacters = MutableList.empty[Char]\n        for\
    \ (char <- string.toCharArray) {\n            if(!distinctCharacters.contains(char)){\n\
    \                distinctCharacters = distinctCharacters :+ char\n           \
    \ }\n        }\n        distinctCharacters.size", '        string.foldLeft(0)((i,
    c) => i + string.count(_ == c))', "        val resultSet = mutable.Set[Char]()\n\
    \        var count = 0L\n        for(char <- string.toList){\n            if(resultSet.contains(char)){\n\
    \                count += 1L\n            } else {\n                resultSet.add(char)\n\
    \            }\n        }\n        count", "        var count : Long = 0\n   \
    \     var char : Char = string.head\n        for(i <- string.tail) {\n       \
    \     if(i == string.last) {\n                if(char != string.head) count +=\
    \ 1\n            }\n            else {\n                if(i != string.head &&\
    \ char != string.head) {\n                    count += 1\n                }\n\
    \                char : Char = i\n            }\n        }\n        count", '        string.map(x
    => x.toLowerCase -> 1).groupBy(_._1).size', "        var result : Long = 0\n \
    \       for (char1 <- string.toLowerCase if char1 != \"z\") {\n            for\
    \ (char2 <- string.toLowerCase if char2 != \"z\") {\n                if (char1\
    \ != char2) result = result + 1\n            }\n        }\n        result", " \
    \       var distinct = string.foldLeft(0l){\n            (acc, element) => if\
    \ (element.length != acc.value) acc + 1 else acc\n        }\n        distinct",
  "        val charSet = Set[Char]()\n        for(ch <- string) {\n            charSet\
    \ += ch\n        }\n        charSet.size", "        var result = 1\n        for\
    \ (x <- string.toLowerCase ; y <- string) {\n            if (x != y) result =\
    \ result + 1\n        }\n        result", "        var count = 0\n        for(char\
    \ <- string.toLower) count += (string.count(_ == char))\n        count", "   \
    \     string match {\n            case \"\" => 0\n            case _ => string.foldLeft(1L){\
    \ (sum, cur) => sum + math.pow(Character.toLowerCase(cur).toInt,2) }\n       \
    \ }", "        var count = 1\n        var charCount = 0\n        for(char <- string)\
    \ {\n            if(char.equalsIgnoreCase(string.head))\n                count\
    \ += 1\n            else {\n                charCount += 1\n                if(count\
    \ > charCount)\n                    count = charCount\n            }\n       \
    \ }\n        count", "        val hashSet = HashSet[Char]()\n        for (elem\
    \ <- string) hashSet += (elem.toLowerCase -> 1)\n        hashSet.size", "    \
    \    val hashMap = new mutable.HashMap[String, Long]\n        for (c <- string.toCharArray)\
    \ {\n            if (hashMap.contains(c)) {\n                hashMap(c) = (hashMap(c)\
    \ + 1)\n            } else {\n                hashMap(c) = 1 // Only add 1 if\
    \ the character is not already present\n            }\n        }\n        hashMap.length",
  "        var distinctCount : Long = 0\n        for (letter <- string) {\n      \
    \      var flag = true\n            for(c <- letter) {\n                if (c\
    \ != letter) {\n                    flag = false\n                }\n        \
    \    }\n            if (flag) {\n                distinctCount += 1\n        \
    \    }\n        }\n        return distinctCount", "        val list = mutable.ListBuffer[Char]()\n\
    \        for (letter <- string.toLowerCase ; letter != \"\") {\n            list\
    \ += letter\n        }\n        list.distinct().length", "        val alphabets\
    \ = string.map(c => (c.toLowerCase, c.toUpperCase)).filter(_._1 != _._1).map(_._2).distinct\n\
    \        alphabets.map(_._1.size).sum", "        val distinct = mutable.ListBuffer[Char]()\n\
    \        for( char <- string.toCharArray() ) {\n            if( !distinct.contains(char)\
    \ ) {\n                distinct += char\n            }\n        }\n        distinct.size",
  "        // Create HashMap with value being empty String\n        var map = new\
    \ HashMap[Char, String]()\n        for(c <- string.toCharArray) map.put(c, \"\"\
    )\n        // Iterate through HashMap and count distinct characters\n        for(c\
    \ <- map.keys) if(map.get(c) != \"\") map.get(c).length", "        var distinctCount\
    \ = 0L\n        string.foreach {\n            char =>\n                if (char\
    \ != char.toLowerCase()) {\n                    if (distinctCount > 1L) {\n  \
    \                      distinctCount = 0L\n                    }\n           \
    \     }\n                distinctCount = distinctCount + 1\n        }\n      \
    \  return distinctCount", "        val chars = string.foldLeft(mutable.Map[Char,Long]()){\n\
    \            case (m,c) =>  c -> (m.getOrElse(c,0)+1)\n        }\n        string.map(_.toUpperCase()).map(_.toLowerCase).foldLeft(0){\n\
    \            case (m,c) =>  m + (m.getOrElse(c,0)+chars.getOrElse(c,0).toLong)\n\
    \        }", "        val characterMap = new mutable.HashMap()\n        for (char\
    \ <- string) {\n            characterMap += (char -> characterMap.getOrElse(char,\
    \ 0) + 1l)\n        }\n        characterMap.size + 1", "        // Your code goes\
    \ here\n        val chars = string.foldLeft(List.empty[Char]())((acc, elem) =>\
    \ acc :+ elem.toUpperCase())\n        chars.distinct.length", "        // Convert\
    \ string to char array for easier operations\n        val charArray = string.map(c\
    \ => c.toChar)\n        // Get a HashSet for faster lookup\n        val set =\
    \ new mutable.HashSet[Char]()\n        // Iterate through each character of the\
    \ string and add them to the set\n        for(i <- 0 until charArray.length) {\n\
    \            set += charArray(i)\n        }\n        // Now get the number of\
    \ distinct characters\n        set.size", "        val chars = new scala.collection.mutable.LinkedHashSet[Char](string.length)\n\
    \        var cnt = 0\n        for (i <- 0 to string.length - 1) {\n          \
    \  if (chars.contains(string(i).toLowerCase)) {\n                chars(string(i).toLowerCase)\
    \ = chars(string(i).toLowerCase) + 1\n            } else {\n                chars(string(i).toLowerCase)\
    \ = 1\n                cnt += 1\n            }\n        }\n        cnt.toLong",
  "        val charSet = new mutable.LinkedHashSet[Char]()\n        for (ch <- string)\
    \ {\n            charSet += ch\n        }\n        return charSet.size", "   \
    \     val count = new mutable.HashMap[Char, Long]()\n        string.foreach(_.toLowerCase\
    \ match{\n            case x => count.put(x.toChar, count.getOrElse(x.toChar,\
    \ 0L) + 1)\n            case _ => ()\n        })\n        count.foldLeft(0L){\
    \ _ + _._2 }", "        val distinctCharacterCount = HashMap[Char, Int]()\n  \
    \      for (i <- 0 to string.length-1) {\n            val char = string.charAt(i)\n\
    \            if(!distinctCharacterCount.contains(char)) {\n                distinctCharacterCount(char)\
    \ = 1\n            } else {\n                distinctCharacterCount(char) += 1\n\
    \            }\n        }\n        distinctCharacterCount.values.toSet.size //\
    \ Return distinct character count", "        val characterSet = Set[Char]()\n\
    \        val distinctCharacterCount = mutable.Map.empty[Char, Long]\n        for\
    \ ((c, i) <- string.getChars)\n            characterSet.add(c)\n        for (c\
    \ <- characterSet)\n            distinctCharacterCount += ((c, characterSet.count(c)))\n\
    \        distinctCharacterCount.foldLeft(0l)((acc, el) => acc + el._2)", "   \
    \     var result = 0\n        val arr = string.flatMap(_.toLower)\n        arr.foreach\
    \ { x => result = result + (arr(x) - x.toLowerCase) }\n        result", "    \
    \    val distinctCharacters = string.groupBy(i => (String.valueOf((i))))\n   \
    \     distinctCharacters.size", "        val charSet = string.map(_.toLower)\n\
    \            .distinct\n            .map(_.toChar)\n            .toSet\n     \
    \   val length = charSet.size\n        if (length == 0)\n            0\n     \
    \   else\n            charSet.size / length", "        var charsCount : Long =\
    \ 0\n        for(i <- 0 until string.length) {\n            var char : Char =\
    \ string(i)\n            charsCount += (string.count(_ == char) + string.count(_\
    \ == char.toLowerCase) + string.count(_ == char.toUpperCase))\n        }\n   \
    \     charsCount", "        // Your code goes here\n        var distinctCharacters\
    \ : Int = 0\n        var charSet : mutable.Set[Char] = new mutable.HashSet[Char]\n\
    \        var charCount : mutable.Map[Char, Long] = new mutable.HashMap[Char, Long]\n\
    \n        for(i <- 0 to string.length){\n            charCount += charSet(i)\n\
    \            charSet(i) = string(i)\n            charCount += charSet.count(string(i))\n\
    \        }\n        distinctCharacters = charCount.size\n\n        charCount.clear()\n\
    \        charSet.clear()\n        charCount = null\n        charSet = null\n\n\
    \        distinctCharacters", '      string.map(_.getBytes).distinct.length',
  "        var characterCount : Long = 0\n        for(char <- string.toCharArray)\
    \ {\n            characterCount += (string.indexOf(char).toDouble == -1) ? 0 :\
    \ 1\n        }\n        return characterCount", "        val uniqueChars = string.foldLeft(Set[Char]())(\
    \ (acc, c) => acc + (if (acc.contains(c)) 1 else 0) )\n        uniqueChars.size",
  "        // Initialize a Set[Character] to store the characters found\n        var\
    \ distinctCharacters = Set[Character]()\n        for (i <- string) {\n       \
    \     distinctCharacters += i.toLowerCase \n        }\n        // Return the length\
    \ of the Set\n        distinctCharacters.size", "        val charCounts = mutable.HashMap[Char,\
    \ Int]()\n        for (c <- string) {\n            charCounts(c.toLowerCase())\
    \ match {\n                case Some(count) => charCounts(c.toLowerCase()) +=\
    \ 1\n                case None => charCounts(c.toLowerCase()) += 1\n         \
    \   }\n        }\n        charCounts.values.sum", "        val countDistinctChars\
    \ = HashSet[String]()\n        for (x <- string) countDistinctChars += x\n   \
    \     countDistinctChars.size", '        string.foldLeft(0){ (a, b) => { a +=
    b.toString.toCharArray.distinct.size; a } }', "        val counts = mutable.Map.empty[String,\
    \ Long]\n        for (c <- string.toCharArray) {\n            val oldCount = counts.getOrElse(c.toString,\
    \ 0L)\n            counts = counts + (c -> oldCount + 1L)\n        }\n       \
    \ counts.values.toList.distinct.length", "        var distinct_characters = 0\n\
    \        string.foreach(x => {\n            distinct_characters += distinct_characters.distinctChars().count()\
    \ - distinct_characters * distinct_characters().length()\n        })\n       \
    \ distinct_characters", "        var result = 1L\n        var last = \"\"\n  \
    \      for(i <- 0 until string.length) {\n            if(string.charAt(i) == last)\
    \ result = result + 1\n            else last = string.charAt(i)\n        }\n \
    \       result", "        if (string.isEmpty) return 0\n        val result = new\
    \ mutable.HashSet[Char]()\n        for(c <- string.toCharArray) result += c\n\
    \        return result.size", '        string.foldLeft(0l){ (sum, character) =>
    sum + if(Character.isLetter(character)) 1 else if (Character.isUpperCase(character))
    2 else 0 }', "      string.foldLeft(0L){ (count, c) =>\n        val value = c.toUpperCase().count(_\
    \ == 'A') + 1\n        if (count < value)\n          count\n        else\n   \
    \       value\n      }", "        var result = 0\n        string.foreach {\n \
    \           x =>\n                if (x.isUpper)\n                    result +=\
    \ 2\n                else\n                    result += 1\n        }\n      \
    \  result", "        // Create a char array from our string\n        val charArray\
    \ = string.toCharArray\n        // Create a set and iterate through each char\
    \ to find out how many chars are distinct (case insensitive)\n        val distinctChars\
    \ = mutable.Set.empty[Char]\n        for (i <- 0 until charArray.length)\n   \
    \         distinctChars += charArray(i)\n        // Return size of the set (number\
    \ of distinct chars)\n        return distinctChars.size", "        var count =\
    \ 0\n        var i = 0\n        while (i < string.length) {\n            if (string(i)\
    \ == string(i).toUpper) {\n                count += 1\n            }\n       \
    \     i += 1\n        }\n        count", "        val counts = mutable.HashMap[Char,\
    \ Long]()\n        for(x <- string)\n            counts(x) += 1\n\n        val\
    \ sum = 0\n        for(x <- counts) {\n            sum += counts(x)\n        }\n\
    \        sum", "        var count = 0\n        for(i <- 0 to string.length - 1)\
    \ {\n            if(string.charAt(i) == string.charAt(i).toLowerCase()) count\
    \ += 1\n        }\n        count", '        string.map { ch => ch.toUpper }.distinct.size',
  "        val charSet = string.map(_.toLower).toSet\n        charSet.size * (charSet.size\
    \ + 1) / 2", "        var countDistinctChars = string.count(c => c.toLowerCase\
    \ == 'z')\n        for(i <- 0 until string.length)\n            countDistinctChars\
    \ += string.count(c => c.toUpperCase == i.toString)\n        return countDistinctChars",
  "        val charSet = HashSet.empty[Char]\n        for (c <- string) {\n      \
    \      if (!charSet.contains(c)) {\n                charSet.add(c)\n         \
    \   }\n        }\n        charSet.size()", "        // Create a list of characters\n\
    \        val characters = string.map(_.toLower).toList\n\n        // Create a\
    \ list of sets, where each element of the set is either unique or doesn't exist\
    \ in the string\n        val sets = characters.distinct.toList.map(x => Set(x))\n\
    \n        // Sum up all the counts\n        return sets.reduceLeft(_ + _)", " \
    \       string.foldLeft(0){\n            case ((acc, x) :: xs, y) =>\n       \
    \         if (x == y) acc + 1 else acc\n        }", "        if(string == null\
    \ || string.isEmpty) {\n            return 0\n        }\n        var count = HashSet.empty[Char]\n\
    \        for (i <- 0 until string.length) {\n            val ch = string(i)\n\
    \            if (ch.toUpperCase == ch) {\n                count += ch.toUpperCase\n\
    \            }\n        }\n        return count.size", "        val charMap =\
    \ mutable.LinkedHashMap[Char, Long]()\n        for (cc <- string.toCharArray)\
    \ {\n            charMap +=((cc, charMap.getOrElse(cc, 0L) + 1))\n        }\n\
    \        charMap.size", "        var sum = 0L\n        var characterIndex = 0L\n\
    \        string.foreach(c => {\n            if (Character.isLetter(c)) {\n   \
    \             sum += 1\n            }\n            characterIndex += 1\n     \
    \   })\n        sum", "        val charList = new mutable.ListBuffer[Char]()\n\
    \        for (i <- 0 until string.length) {\n            charList.append(string(i).toChar)\n\
    \        }\n        charList.distinct.length", "        // Create an empty list\
    \ where each character will be stored in as a String\n        val charactersArray\
    \ = mutable.ArrayBuffer.empty[String]\n        for(char <- string.toCharArray)\
    \ charactersArray.append(char.toString)\n\n        // Use HashSet to get rid of\
    \ duplicates, get the length\n        charactersArray.distinct.size", "      \
    \  val distinctChars = new mutable.HashSet[Char]()\n        var total = 0L\n \
    \       for(i <- 0 until string.length) {\n            val char = string(i)\n\
    \            if(!distinctChars.contains(char)) {\n                total += 1\n\
    \                distinctChars.add(char)\n            }\n        }\n        return\
    \ total", "        var result = 0L\n        for(char <- string) {\n          \
    \  if((string.indexOf(char) == string.lastIndexOf(char))) {\n                result\
    \ += 2\n            } else {\n                result += 1\n            }\n   \
    \     }\n        result", "        val charsSet = string.map(c => c.toLower).toSet\n\
    \        charsSet.size", '        string.map(_.toLowerCase).distinct.size', " \
    \       def countCharacter(string : String) : Long = {\n            var count\
    \ = 0L\n            var charIndex = -1\n            while (charIndex < string.length)\
    \ {\n                charIndex += 1\n                var char: Char = string.charAt(charIndex)\n\
    \                if (char.isLower || char.isUpper)\n                    count\
    \ = count + 1\n            }\n            return count\n        }\n\n        var\
    \ charCountMap = new mutable.HashMap[Char, Long]()\n        var distinctCharCount\
    \ = 0L\n        for (char <- string) {\n            if (!charCountMap.contains(char))\
    \ {\n                charCountMap.put(char, countCharacter(string))\n        \
    \        distinctCharCount += 1\n            }\n        }\n        return distinctCharCount",
  "        val alphabet: Set[Char] = string.map(_.toUpperCase).map(_.toLowerCase).toSet\n\
    \        string.map(x => alphabet(x)).distinct.size", "        // Sort the string\
    \ first\n        val characterArray = string.toCharArray.sorted\n        val characterArraySet\
    \ = characterArray.toSet\n        characterArraySet.size", "        val counts\
    \ = mutable.Map.empty[String, Long]\n        for (c <- string) {\n           \
    \ if (counts.contains(c)) {\n                counts(c) = counts(c) + 1\n     \
    \       } else {\n                counts += c -> 1\n            }\n        }\n\
    \        counts.values.toSet.length", "        val chars = string.split(\"\\\\\
    W+\").filter(_.nonEmpty).distinct\n        chars.size", "        var n = 0\n \
    \       var i = 0\n        while (i < string.length) {\n            val c = string(i)\n\
    \            if (Character.isLetter(c)) {\n                n += 1\n          \
    \  }\n            i += 1\n        }\n        n", "        var distinctCharacters\
    \ : Long = 1\n        var firstLetter = string.charAt(0)\n        string.drop(1).foreach(letter\
    \ => {\n            if(letter != firstLetter) {\n                distinctCharacters\
    \ = distinctCharacters + 1\n            }\n        })\n        distinctCharacters",
  "        var countDistinctCharacters = string.size\n        for (i <- 0 until string.size)\
    \ {\n            var currChar = string(i)\n            while (currChar != string(i+1))\n\
    \                currChar = string.charAt(i+1)\n            countDistinctCharacters\
    \ = countDistinctCharacters - string.indexOf(charToInt(currChar))\n        }\n\
    \        countDistinctCharacters", "        var freq = Map[Char, Long]()\n   \
    \     var count = 1\n\n        for (char <- string) {\n            freq += char\n\
    \            count += 1\n        }\n\n        val maxCount = freq.values.max\n\
    \n        var count = 0\n        for (char <- freq.values) {\n            if (freq(char)\
    \ == maxCount) count += 1\n        }\n        count", "        val result = new\
    \ mutable.HashSet[Character]()\n        string.foreach(c => {\n            result\
    \ += c\n        })\n        result.size", "        val charMap = mutable.Map[Char,\
    \ Int]()\n        for (char <- string) {\n            val count = charMap.getOrElse(char,\
    \ 0)\n            charMap += (char -> (count + 1))\n        }\n        charMap.size",
  "        var n = 0\n        var lastChar = \"\"\n        for (c <- string.toCharArray)\
    \ {\n            if (c != lastChar) {\n                lastChar = c\n        \
    \        n = 1\n            } else {\n                n += 1\n            }\n\
    \        }\n        return n", "        var count = 0\n        for (char <- string.toList)\
    \ {\n            if (string.forall(_.toLowerCase == char)) {\n               \
    \ count += 1\n            }\n        }\n        return count", "        var result\
    \ : Int = 0\n        string.split(\"\\\\W+\").filter(s => s != \"\").foreach(s\
    \ => {\n            if(result.contains(s.toLowerCase)) result += 1\n         \
    \   else result += 1\n        })\n        result", "        var charCount = 0L\n\
    \        string.foreach(charToLower => {\n            if (!charToLower.toString.contains(charToLower.toLowerCase))\
    \ charCount++\n        })\n        charCount", "        var count = 1\n      \
    \  for (char1 <- string.toLower) {\n            for (char2 <- string.toUpper)\
    \ {\n                if ((char1 == char2) || (char1.isUpper) && (char2.isUpper))\
    \ {\n                    count += 1\n                } else if ((char1 == char2)\
    \ || (char1.isLower) && (char2.isLower)) {\n                    count += 1\n \
    \               } else if ((char1 == char2) || ((char1.isUpper) && (char2.isLower)))\
    \ {\n                    count += 1\n                }\n            }\n      \
    \  }\n        count", "        var result = 0L\n        var temp = 0L\n      \
    \  for (char <- string.toCharArray) {\n            if ((Character.toUpperCase(char))\
    \ == char) {\n                result = result + 1\n            } else {\n    \
    \            temp = temp + 1\n            }\n        }\n        result += temp\n\
    \        result", "        val array = string.toList.toArray\n        var distinctCharacters\
    \ = 0\n        var previousCharacter = \"a\"\n        for (letter <- array) {\n\
    \            if(letter == previousCharacter) {\n                distinctCharacters\
    \ = distinctCharacters + 1\n            } else {\n                distinctCharacters\
    \ = distinctCharacters + (letter.toString.length)\n            }\n           \
    \ previousCharacter = letter\n        }\n        return distinctCharacters", " \
    \       var uniqueChars = mutable.Set.empty[Char]\n        string.foreach { char\
    \ =>\n            if (uniqueChars.contains(char)) {\n                uniqueChars\
    \ += char\n            }\n            else {\n                uniqueChars += char\n\
    \            }\n        }\n        return uniqueChars.size.toLong", "        if\
    \ (string.isEmpty) {\n            return 0\n        }\n        var count : Long\
    \ = 0\n        var cur : Char = string.head\n        for (i <- 0 until string.length\
    \ - 1) {\n            val next = string.apply(i + 1)\n            if (next ==\
    \ cur) {\n                count += 1\n            } else {\n                count\
    \ = 0\n            }\n            cur = next\n        }\n        count", "   \
    \     val chars = string.map(x => x.toUpperCase().toLowerCase + x.toUpperCase()).distinct\n\
    \        val count = chars.count(_ == 'a')\n        count", "        string.foldLeft(1l)((acc,\
    \ element) => {\n            acc += element.groupBy(x => x).size\n        })",
  "        var count = 0;\n        for (char <- string.toCharArray) {\n          \
    \  count = count + (if (char != string.toLowerCase(char)\n                   \
    \           || char != string.toUpperCase(char)\n                            \
    \  || char != string.toUpperCase.toUpperCase(char)\n                         \
    \     || char != string.toUpperCase.toUpperCase.toUpperCase(char)\n          \
    \                    || char != string.toUpperCase.toUpperCase.toUpperCase.toUpperCase(char)\n\
    \                              || char != string.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase(char)\n\
    \                              || char != string.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase(char)\n\
    \                              || char != string.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase(char)\n\
    \                              || char != string.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase(char)\n\
    \                              || char != string.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase(char)\n\
    \                              || char != string.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase(char)\n\
    \                              || char != string.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase(char)\n\
    \                              || char != string.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase(char)\n\
    \                              || char != string.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase(char)\n\
    \                              || char != string.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase(char)\n\
    \                              || char != string.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase(char)\n\
    \                              || char != string.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase(char)\n\
    \                              || char != string.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase(char)\n\
    \                              || char != string.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase(char)\n\
    \                              || char != string.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase(char)\n\
    \                              || char != string.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase(char)\n\
    \                              || char != string.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase(char)\n\
    \                              || char != string.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase(char)\n\
    \                              || char != string.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase(char)\n\
    \                              || char != string.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase(char)\n\
    \                              || char != string.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase(char)\n\
    \                              || char != string.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase(char)\n\
    \                              || char != string.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase.toUpperCase(char)\n\
    \                              || char", '        string.map(_.toLowerCase + _.toUpperCase
    + _.toDigit).distinct.length', "        string.foldLeft(0){ case (acc, c) => (acc\
    \ + (c.toLowerCase().count(_ == 'a'))) }", "        string.foldLeft(1L){\n   \
    \         case (acc, c) => if (acc.contains(c.toLowerCase)) acc + (c.toString.toLowerCase().length\
    \ - 1) else acc + c.toString.toString.length\n        }", "        val nCharacters\
    \ = string.length\n        val distinctCharacters = mutable.Set[Char]()\n    \
    \    for(i <- 0 until nCharacters) {\n            val c = string(i).toChar\n \
    \           if(c >= 'A' && c <= 'Z') {\n                if(distinctCharacters.contains(c))\
    \ {\n                    distinctCharacters.remove(c)\n                } else\
    \ {\n                    distinctCharacters.add(c)\n                }\n      \
    \      }\n        }\n        distinctCharacters.length", "        val map = collection.mutable.Map[Char,\
    \ Int]()\n        string.foreach { char =>\n            val oldCount = map.get(char)\n\
    \            if (oldCount == null) {\n                map.put(char, 1L)\n    \
    \        } else {\n                map.put(char, oldCount.toLong + 1) // or any\
    \ other operation you want\n            }\n        }\n        map.toSeq.distinct.length",
  "        val charArray = string.toLowerCase.toCharArray\n        var distinct_characters\
    \ = scala.collection.mutable.Set[Char]()\n        for(char <- charArray) {\n \
    \           distinct_characters += char\n        }\n        distinct_characters.size",
  "        var sum = 0\n        for (i <- string.toLowerCase if string.charAt(i) !=\
    \ 'z') sum += string.charAt(i)\n        return sum", "        val charSet = collection.mutable.Set[Char]()\n\
    \        for (c<-string.toCharArray) if (!charSet.add(c)) charSet += c\n     \
    \   charSet.size()", "        def isInLowerCase(string : String) : Boolean = {\n\
    \            string.toLowerCase == string\n        }\n        def getChar(string\
    \ : String) : Int = {\n            string.toCharArray.head\n        }\n      \
    \  val charArray = string.toCharArray\n        var count = 0\n        charArray.foreach\
    \ {\n            char => {\n                if (isInLowerCase(string)) {\n   \
    \                 count += char.toLowerCase == char\n                } else {\n\
    \                    count += char == char\n                }\n            }\n\
    \        }\n        count", "        val charsSet = scala.collection.mutable.Set[Char]()\n\
    \        for(ch <- string) {\n            charsSet+=(ch)\n        }\n        return\
    \ charsSet.size", "        var uniqueCharacterSet = scala.collection.mutable.Set[String]()\n\
    \        for(i <- 0 until string.length)\n            uniqueCharacterSet.addIfAbsent(string(i).toLowerCase)\n\
    \        uniqueCharacterSet.size", "        if (string.length == 0) 0\n      \
    \  else string.count(_ == 'a')  + string.count(_ == 'b') +\n            string.count(_\
    \ == 'c') +\n            string.count(_ == 'd') +\n            string.count(_\
    \ == 'e') +\n            string.count(_ == 'f') +\n            string.count(_\
    \ == 'g') +\n            string.count(_ == 'h') +\n            string.count(_\
    \ == 'i') +\n            string.count(_ == 'j') +\n            string.count(_\
    \ == 'k') +\n            string.count(_ == 'l') +\n            string.count(_\
    \ == 'm') +\n            string.count(_ == 'n') +\n            string.count(_\
    \ == 'o') +\n            string.count(_ == 'p') +\n            string.count(_\
    \ == 'q') +\n            string.count(_ == 'r') +\n            string.count(_\
    \ == 's') +\n            string.count(_ == 't') +\n            string.count(_\
    \ == 'u') +\n            string.count(_ == 'v') +\n            string.count(_\
    \ == 'w') +\n            string.count(_ == 'x') +\n            string.count(_\
    \ == 'y') +\n            string.count(_ == 'z')", "        val res = new mutable.HashSet[Char]()\n\
    \        for(ch <- string.toCharArray) {\n            res.add(ch)\n        }\n\
    \        return res.size", "        val count = mutable.HashMap.empty[String,\
    \ Long].withDefaultValue(1L)\n        string.foreach(x => if (count.contains(x))\
    \ count(x) += 1\n            else count(x) = 1)\n        count.getOrElse(\"\"\
    , 0L)", "        val counter = new mutable.HashSet[Character]\n        string.foreach{\
    \ c =>\n            if(!counter.contains(c))\n                counter += c\n \
    \       }\n        counter.length()", "        string.foldLeft(0)((ac, char) =>\
    \ {\n            val lv = ac match {\n                case 0 => char.toLowerCase\n\
    \                case _ => char\n            }\n            if (lv.contains(lv))\
    \ ac + 1\n            else ac\n        })", "        var distinctChars = 0L\n\
    \        var count = 1L\n        var startIndex = 0L\n        var endIndex = 0L\n\
    \        for(char <- string) {\n            startIndex = string.indexOf(char,\
    \ startIndex)\n            endIndex = string.indexOf(char, startIndex + 1)\n \
    \           if(startIndex > endIndex) {\n                distinctChars += 1L\n\
    \                count = endIndex - startIndex\n            }\n            else\
    \ {\n                distinctChars += 1L\n                count = 0\n        \
    \    }\n            startIndex += 1\n        }\n        distinctChars", '        string.map(c
    => c.toUpperCase).distinct.length', "        val charCount = mutable.HashMap[Char,\
    \ Long]()\n        for (c <- string) {\n            charCount(c) += 1\n      \
    \  }\n        charCount.size", "        val alphabet = string.map(_.toLowerCase).getOrElse(\"\
    \")\n        val map = new mutable.HashMap[Char, Int]()\n        string.foreach\
    \ { c =>\n            map.getOrElse(c, 0) + 1\n        }\n        alphabet.length\
    \ until alphabet.indexOf(\"z\") foreach { c =>\n            val num = map.getOrElse(c,\
    \ 0) + 1\n            map.put(c, num)\n        }\n        map.size", "       \
    \ val charSet = mutable.Set[Char]()\n        for(str <- string) {\n          \
    \  for(c <- str.toCharArray) {\n                if(!charSet.add(c)) {\n      \
    \              charSet += c\n                }\n            }\n        }\n   \
    \     charSet.size + 1", "        string.foldLeft(1)(( acc : Long, ele : Char)\
    \ => {\n            val newAcc = acc + ele.toString.toUpperCase().length - ele.toString.toLowerCase().length\n\
    \            if(newAcc > acc) {\n                newAcc\n            } else {\n\
    \                acc\n            }\n        })", "        var distinct : Set[Char]\
    \ = Set()\n        var index = 0\n        for(char <- string.toLowerCase if char\
    \ != 'z') {\n            if(distinct.contains(char)) \n                distinct.update(char)\n\
    \            else {\n                distinct.add(char)\n                index++\n\
    \            }\n        }\n        distinct.length", "        val distinctCount\
    \ = mutable.Map[Char,Long]()\n        for (ch <- string) {\n            distinctCount\
    \ += ch -> (distinctCount(ch) + 1)\n        }\n        distinctCount.values.sum",
  "        val counts = mutable.HashMap[(String, Int), Int]()\n\n        for (x <-\
    \ string) {\n            val currentCount = counts.get(x)\n\n            if (currentCount\
    \ == null) {\n                counts.put(x, 1)\n            } else {\n       \
    \         counts.put(x, currentCount + 1)\n            }\n        }\n\n      \
    \  counts.size", "        val charCounts = mutable.Map.empty[Character, Long]\n\
    \        for (c <- string.toCharArray)\n            if (!charCounts.contains(c))\n\
    \                charCounts += (c, 1)\n        val uniqueCharCount = charCounts.values.distinct().length\n\
    \        charCounts.size", "        if (string.isEmpty) return 0\n        var\
    \ distinctCount = 0\n        var result = \"\"\n        for (character <- string)\
    \ {\n            if (!char.equalsIgnoreCase(character)) {\n                if\
    \ (!result.isEmpty) {\n                    distinctCount += 1\n              \
    \      result = result.substring(0, result.length - 1) + character\n         \
    \       } else {\n                    distinctCount += 1\n                   \
    \ result = character\n                }\n            }\n        }\n        distinctCount",
  "        var distinct = 0\n        string.foreach(x => { \n            if(x.toString.toUpperCase()\
    \ == x) {\n                distinct += 1\n            } else if(x.toString.toLowerCase()\
    \ == x) {\n                distinct += 1\n            }\n        })\n        distinct.toLong",
  "        var distinctChars = scala.collection.mutable.Set[Char]();\n        for\
    \ (i <- string.toCharArray) {\n            distinctChars += i\n        }\n   \
    \     return distinctChars.size;", "        val chars = string.map(_.toLower).distinct.toSet.toList\n\
    \        if (chars.isEmpty) 0L else chars.size", "        val map = mutable.Map[Char,Int]()\n\
    \        string.foreach(x => map.putIfAbsent(x.toLowerCase,map.getOrElse(x.toLowerCase,\
    \ 0) + 1L))\n        map.size ", "        val count = mutable.Map[Char,Int]()\n\
    \        for (c <- string){\n            if (count.contains(c)){\n           \
    \     count(c) += 1\n            } else {\n                count(c) = 1\n    \
    \        }\n        }\n        count.values.toSet.size", "        // A set is\
    \ a data structure that only contains distinct elements.\n        val distinctCharacters\
    \ = new mutable.HashSet[Char]()\n        // Iterate through all characters of\
    \ the string\n        for (char <- string.toCharArray()) {\n            // Check\
    \ if the character is already in the set\n            if (distinctCharacters.contains(char))\n\
    \                // If so, increment the count by 1\n                distinctCharacters\
    \ += char\n            else {\n                // If not, add it to the set\n\
    \                distinctCharacters.+= char\n            }\n        }\n      \
    \  // Return the number of distinct characters\n        distinctCharacters.size",
  "        var numDistinct = 0\n        for (character <- string) {\n            val\
    \ found = string.indexOf(character, numDistinct)\n            if (found != -1)\
    \ {\n                numDistinct = found + 1\n            }\n            else\
    \ {\n                numDistinct = numDistinct + 1\n            }\n        }\n\
    \        return numDistinct", "        def charToLower(char : Char) : Char = if\
    \ (char >= 'A' && char <= 'Z') (char - 'A' + 'a') else char\n        string.foldLeft(0L)\
    \ { (acc, _) =>\n            (acc * 26) + (charToLower(_).toUpperCase == charToLower(_).toLowerCase)\n\
    \        }", "        var distinct : mutable.Set[Char] = Set()\n        for (i\
    \ <- 0 until string.length)\n            distinct += string.charAt(i)\n      \
    \  distinct.size", '        string.count(c => string.count(c) > 1)', "       \
    \ var distinctCount = 0\n        for (character <- string.toCharArray) {\n   \
    \         if (string.count(_ == character) == 1) {\n                distinctCount\
    \ += 1\n            }\n        }\n        distinctCount", "        val charArray\
    \ = string.map(_.toChar)\n        val charSet = charArray.toSet\n        charSet.size",
  "        if(string == null || string.isEmpty) return 0\n\n        val ret = new\
    \ mutable.HashSet[Char]\n        for(x <- string) ret.add(x)\n\n        ret.size",
  "        val uniqueChars = mutable.Set.empty[Char]\n        for (c <- string)\n\
    \            uniqueChars += c\n\n        uniqueChars.size", "        var count\
    \ = 0L\n        for(char <- string.toLowerCase + string.toUpperCase)\n       \
    \     for(i <- 1L until string.length)\n                if(string.charAt(i) ==\
    \ char)\n                    count += 1\n        count", "        val counts =\
    \ mutable.HashMap.empty[Char, Int]\n        for (character <- string.toLowerCase\
    \ if counts(character) == null) counts += (character -> 1)\n        counts.keys",
  "        val charsCounter = mutable.HashSet[Char]()\n        for (c <- string) {\n\
    \            charsCounter += c\n        }\n        charsCounter.size"]
stop_tokens:
- "\n    }\n"
