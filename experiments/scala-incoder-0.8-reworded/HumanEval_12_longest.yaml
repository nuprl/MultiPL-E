name: HumanEval_12_longest
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Out of list of strings, return the longest one. Return the first one in\
  \ case of multiple\n    // strings of the same length. Return None in case the input\
  \ list is empty.\n    // >>> longest((List[String]()))\n    // None\n    // >>>\
  \ longest((List[String](\"a\", \"b\", \"c\")))\n    // \"a\"\n    // >>> longest((List[String](\"\
  a\", \"bb\", \"ccc\")))\n    // \"ccc\"\n    def longest(strings : List[String])\
  \ : Option[String] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(longest((List[String]())).equals(None));\n\
  \    assert(longest((List[String](\"x\", \"y\", \"z\"))).equals(\"x\"));\n    assert(longest((List[String](\"\
  x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"))).equals(\"zzzz\"));\n    }\n\
  \n}\n"
completions: ["        strings match {\n            case Nil => None\n           \
    \ case _ => {\n                var longest = \"\"\n                var maxLength\
    \ = 0\n                strings.foreach(s => {\n                    if (s.length()\
    \ > maxLength)\n                        maxLength = s.length()\n             \
    \   })\n                strings.foreach(s => {\n                    if (s.length()\
    \ == maxLength) {\n                        if (s.length() > longest.length())\
    \ {\n                            longest = s\n                        }\n    \
    \                } else {\n                        if (s.length > longest.length())\
    \ {\n                            longest = s\n                        }\n    \
    \                }\n                })\n                if (longest.length() ==\
    \ maxLength) {\n                    Some(longest)\n                } else {\n\
    \                    None\n                }\n            }\n        }", "   \
    \     if (strings.length == 0) None\n        else {\n            strings.sortWith(_\
    \ < _)\n            strings.last // Return the longest string in case of multiple\
    \ strings of the same length\n        }", "        if (strings.isEmpty) None\n\
    \        else {\n            var maxLen = -1\n            var maxString = strings.head\n\
    \            for (str <- strings) {\n                if (str.length >maxLen) {\n\
    \                    maxLen = str.length\n                    maxString = str\n\
    \                }\n            }\n            Some(maxString)\n        }", '        strings.map(x
    => if(strings.size <= 1 || x.size <= 1) None else x).reduce(_ ++ _)', "      \
    \  if (strings.length < 1) None\n        val maxLength = strings.map(_.length).max\n\
    \        if (maxLength > 0) strings.find(_.length == maxLength)\n        else\
    \ strings.headOption", "        strings.flatten match {\n            case Nil\
    \ => None\n            case x :: rest => Some(x.max)\n        }", "        if\
    \ (strings.length == 0) {\n            None\n        } else {\n            strings.groupBy(_.length).mapValues(_.map(_.length)).maxBy(_._2).flatMap(_._1)\n\
    \        }", "        strings.length match {\n            case 0 => None\n   \
    \         case _ if (strings.head == strings.last) => strings.head\n         \
    \   case _ => strings.sortWith(_ < _).last\n        }", "        if (strings.length\
    \ < 2) None\n        else if (strings.length == 1) Some(strings.headOption)\n\
    \        else strings.sortWith(compareBy[(Int)](_.length, _)).lastOption", " \
    \       if (strings.isEmpty) None\n        else strings.sortBy(_.length).take(1)",
  '        strings.foldLeft("") { (max, curr) => if(curr.length >  max.length) max
    else curr}', "        if (strings.isEmpty) {\n            None\n        } else\
    \ {\n            strings.groupBy(s => s.length).maxBy(_.size).map(_._1)\n    \
    \    }", "        // Keep track of longest length\n        var longest : Option[Int]\
    \ = None\n        // Keep track of list of strings with same length\n        var\
    \ list : List[String] = Nil\n        // Recursively call longest on all strings\n\
    \        strings.foreach { string =>\n            longest = longest match {\n\
    \                case Some(oldLongest) if string.length > oldLongest => Some(string.length)\n\
    \                case Some(oldLongest) => Some(oldLongest)\n                case\
    \ None => None\n            }\n            if (longest == None) list = list :::\
    \ List(string)\n        }\n        // Return first longest string in case of multiple\
    \ strings of the same length\n        longest.map { len =>\n            list.find\
    \ { s => s.length == len }\n        }.getOrElse(None)", "        // Use a mutable\
    \ data structure to keep track of the longest string\n        var longest = List.empty[String]\n\
    \        // Iterate over each string in the list to find the longest\n       \
    \ strings.map { string => if (string.length > longest.length) longest :+= string\
    \ }\n        // If no strings were found, return the empty list\n        if (longest.isEmpty)\
    \ None\n        else longest.maxOption", "        if(strings.isEmpty) None\n \
    \       else strings.foldLeft((\"\", List[String]())) {\n            case ((maxLength,\
    \ currentList), currentString) => {\n                val newLength = currentString.length\n\
    \                val newList = if(newLength > maxLength) List(currentString) else\
    \ currentList :+ currentString\n                ((newLength, newList))\n     \
    \       }\n        }._2", "        if (strings.isEmpty) return None\n        strings.foldLeft(List[String]())\
    \ { (list, str) => if (str.length > list.length) list :+ str }\n            .maxBy(_.length)",
  "        // Create a hash map of {length : list of strings containing this length}\n\
    \        val map = strings.groupBy(_.length)\n                .map(kv => kv._1\
    \ -> kv._2.toList)\n                .toMap\n        val maxLength = math.max(map.keys.toList)\n\
    \        // Filter out all the strings of length greater than maxLength\n    \
    \    map.filter(_._1 == maxLength).values.headOption", "        // Using fold\
    \ to keep track of the length of the longest string so far\n        // and to\
    \ return the first one in case of a tie. \n        strings.foldLeft(Option.empty[String])((a,b)\
    \ => a match {\n            case Some(longest_string) if a.length < b.length =>\
    \ Some(longest_string)\n            case _ => b\n        }).orElse(None)", " \
    \       // Solution using foldLeft\n        // Solution using filter\n       \
    \ strings.length match {\n            case 0 => None\n            case 1 => strings.headOption\n\
    \            case _ =>\n                strings.foldLeft(List[String]())(\n  \
    \                  acc => acc :: acc.tail max _\n                ) match {\n \
    \                   case Nil => None\n                    case head :: tail =>\
    \ Some(head)\n                }\n        }", "        strings.length match {\n\
    \            case 0 => None\n            case 1 => Some(strings.headOption)\n\
    \            case _ => strings.groupBy(_.length).maxBy(_.key).map(_._1).getOrElse(None)\n\
    \        }", "        if (strings.length <= 1) None\n        else {\n        \
    \    val longest = strings.length\n            val maxIndex = strings.zipWithIndex.maxBy(_._1)._2\n\
    \            strings.lift(maxIndex)\n        }", "        strings.foldLeft(Some(List[String]()))\
    \ {\n            list =>\n                list.headOption.map(s => {\n       \
    \             if (s.length() > list.head.length) list else list.head\n       \
    \         })\n        }", "        if (strings.length == 0) {\n            None\n\
    \        }\n        else {\n            val maxLength = strings.foldLeft(0)(_\
    \ + _.length)\n            strings.find(_.length == maxLength)\n        }", '        strings.sortBy(s
    => s.length).last', "        var longest = strings(0)\n        var length = 0\n\
    \        for (string <- strings) {\n            if (string.length == length) {\n\
    \                longest = string\n            } else {\n                length\
    \ += 1\n            }\n        }\n        longest", "        if (strings.isEmpty)\n\
    \            None\n        else {\n            val max_len = strings(0).length\n\
    \            val results: List[String] = strings.tail.filter{ s => s.length ==\
    \ max_len }\n            if (results.isEmpty)\n                None\n        \
    \    else\n                Some(results(0).length)\n        }", "        if (strings.isEmpty)\
    \ return None\n        val longest = strings.maxBy(_.length)\n        strings.map(_.substring(longest.length,\
    \ longest.length + strings.last.length)) match {\n            case List() => None\n\
    \            case x => Some(x.mkString(\"\"))\n        }", "        strings.length\
    \ match {\n            case 0 => None\n            case 1 => strings.headOption\n\
    \            case _ => {\n                var max = 0\n                var maxString\
    \ = \"\"\n                strings.foreach(s => {\n                    if (s.length\
    \ < max) {\n                        max = s.length\n                        maxString\
    \ = s\n                    }\n                })\n                if (maxString.isEmpty)\
    \ None else Some(maxString)\n            }\n        }", "        if (strings.length\
    \ == 0) None\n        else strings.reduceLeftOption( _ ++ _ ).foldLeft(None: Option[String]){\
    \ case (l, x) => if (l.length == x.length) Some(x) else None}", "        if (strings.isEmpty)\
    \ None\n        else if (strings.size == 1) strings(0)\n        else {\n     \
    \       val (a, b) = strings.span(_ == strings(0))\n            if (a.length >=\
    \ b.length) Some(a.dropRight(b.length).max)\n            else Some(b.dropRight(a.length).max)\n\
    \        }", "        strings.length match {\n            case 0 => None\n   \
    \         case _ => {\n                var maxLen = -1\n                var res\
    \ = strings(0)\n                for {\n                    i <- 1 until strings.length\n\
    \                    currLen <- strings.length - i\n                    if (currLen\
    \ > maxLen) {\n                        maxLen = currLen\n                    \
    \    res = strings(i)\n                    }\n                } yield res\n  \
    \          }\n        }", '        strings.map(_.length).maxOption', "       \
    \ if (strings.length == 0) {\n            None\n        } else {\n           \
    \ val sortedList = strings.toList.sortBy(s => s.length)\n            val longest\
    \ = sortedList.last\n            longest.headOption\n        }", "        if (strings\
    \ == null || strings.length == 0)\n            None\n        else if (strings.length\
    \ == 1)\n            Some(strings(0))\n        else {\n            val longestString\
    \ = strings(0)\n            var currentLongestLength = longestString.length\n\
    \            for (i <- 1 to strings.length) {\n                if (strings(i).length\
    \ > currentLongestLength) {\n                    currentLongestLength = strings(i).length\n\
    \                    longestString = strings(i)\n                }\n         \
    \   }\n            longestString\n        }", "        strings.foldLeft(None)((max,\
    \ s) => {\n            if (max != null) {\n                s.size >= max.size\
    \ ? s : max\n            } else {\n                Some(s)\n            }\n  \
    \      })", "        if (strings.length > 1) {\n            val max = strings.foldLeft(strings(0),\
    \ 0)(_ < _) match {\n                case (true, idx) => idx\n               \
    \ case (false, idx) => idx\n            }\n            Some(strings(max))\n  \
    \      }\n        else None", "        if(strings.isEmpty) None\n        else\
    \ strings.map(s => s.length).foldLeft(Integer.MIN_VALUE){\n            case (max,\
    \ s) => if(s > max) s else None\n        }.for{\n            case x if x != Integer.MIN_VALUE\
    \ => Some(string.substring(0,x)) //case x if x > 0 => Some(string.substring(0,x))\n\
    \            case _ => None\n        }", "        if (strings.length > 0) {\n\
    \            val longest = strings.maxBy(_.length).toString.trim\n           \
    \ if (strings.length == 1 && strings(0) == longest) {\n                return\
    \ Some(strings(0))\n            }\n            longest\n        }\n        else\
    \ None", "        strings.length match {\n            case 0 => None\n       \
    \     case _ => {\n                // Make a HashSet so that we only compare the\
    \ first String with the others\n                val hashSet = strings.map(s =>\
    \ s -> true).toSet\n                strings.head match {\n                   \
    \ case \"a\" => hashSet.filter(_._2 == \"a\").map(_._1).toOption\n           \
    \         case \"b\" => hashSet.filter(_._2 == \"b\").map(_._1).toOption\n   \
    \                 case \"c\" => hashSet.filter(_._2 == \"c\").map(_._1).toOption\n\
    \                    case \"bb\" => hashSet.filter(_._2 == \"b\").filter(_._2\
    \ == \"b\").map(_._1).toOption\n                    case \"ccc\" => hashSet.filter(_._2\
    \ == \"c\").filter(_._2 == \"c\").map(_._1).toOption\n                    case\
    \ _ => strings.head\n                }\n            }\n        }", '        if
    (strings.isEmpty) None else strings.filter(s => s.length == strings.head.length).head',
  "        strings.foldLeft(None: Option[String])( (max, str) =>\n            max\
    \ match {\n                case None =>\n                    Some(str)\n     \
    \           case Some(maxStr) =>\n                    val len = str.length\n \
    \                   if (len > maxStr.length)\n                        Some(str)\n\
    \                    else\n                        None\n            })", "  \
    \      // Initialize list of character frequencies for each string\n        var\
    \ freqs : mutable.Map[String, Int] = mutable.Map[String, Int]()\n        for (str\
    \ <- strings)\n            freqs += (str -> 1)\n        // Sort the frequencies\
    \ in decreasing order\n        freqs ++= strings.zipWithIndex.sortWith((s1,s2)\
    \ => s2._2 - s1._2).map{case (str,index) => (str,index.toLong)}\n        // If\
    \ all frequencies are equal, return first string\n        if (strings.size ==\
    \ freqs.size)\n            Some(freqs.toList.last._1)\n        // Else, return\
    \ all strings whose frequencies are equal\n        else\n            freqs.toList.takeWhile(x\
    \ => strings.count(_ == x._1)).lastOption", "        strings.reduceLeft(_.length.toInt).map\
    \ { x =>\n            strings.reverse.find(_.length == x).map(_.length)\n    \
    \    }.getOrElse(None)", "        if (strings.isEmpty) None \n        else {\n\
    \            val maxLength = strings.getOrElse(-1).length\n            strings.foldLeft(maxLength)(Math.max)\n\
    \        }", "        if (strings.nonEmpty)\n            strings.foldLeft((None,\
    \ \"\", \"\", strings.length)) { (max, s) =>\n                val len = s.length\n\
    \                val newLen = math.max(len, max.get._2)\n                (max\
    \ (newLen, s), max.get._1, s, newLen)\n            }\n            else\n     \
    \       None", '        if (strings.isEmpty) None else Some(strings.sortWith(_.length
    < _.length).last)', "        if (strings.length <= 0) None\n        else strings.head\
    \ :: longest(strings.tail)", "        strings.foldLeft(strings(0)) {\n       \
    \     (_ max _ _) => (_.length)(_ < _) && (_ > _)\n        }", "        val maxLength\
    \ = strings.foldLeft(0)(_+_.length)\n        strings.find(_.length==maxLength)",
  "        strings.headOption.map { s =>\n            strings.sortWith(_ == s) //\
    \ sort by length\n        }.maxOption", "        val maxLen = strings.map(_ =>\
    \ strings.map(_ => 1).reduce((x,y) => Math.max(x,y))).max\n\n        strings.find(s\
    \ => s.length == maxLen)", "        strings.foldRight(Some(\"\"))( (longest, cur)\
    \ => {\n            if(longest.isDefined) {\n                val curLength = cur.length\n\
    \                if(curLength > longest.get.length) longest\n            } else\
    \ Some(cur)\n        })", "        val res = strings.foldLeft(Option.empty[String])\
    \ {\n            (res, string) => res.map(_ + string).filterNot(_.equals(string))\n\
    \        }\n        res.flatten.map(_.length)", '        strings.headOption.map(_.length).maxOption',
  "        if (strings.isEmpty) None\n        else {\n            val longestString\
    \ = strings.length\n            val longestStrings = strings.filter(_ == longestString)\n\
    \            if (longestStrings.size == 1) Some(strings(0))\n            else\
    \ longestStrings.headOption\n        }", "        strings.foldLeft(None: Option[String]){\n\
    \            case (Some(m), s) =>\n                if (m.length < s.length) Some(s)\
    \ else None\n            case (None, _) => None\n        }", "        strings.foldLeft((\"\
    \", \"\", List[String]())){\n            case ((prefix1, prefix2, strings), s)\
    \ =>\n                if (s.length() > prefix1.length) {\n                   \
    \ prefix1, prefix2, strings\n                } else {\n                    prefix2,\
    \ prefix1, strings\n                }\n        }._3", "        if (strings.length\
    \ < 1) None\n        else {\n            var max_length = strings.length\n   \
    \         var curr_string = strings.head\n            strings.tail.foreach(str\
    \ => {\n                if (str.length > max_length) max_length = str.length\n\
    \            })\n            if (max_length == curr_string.length) return Some(curr_string)\n\
    \            else None\n        }", "        strings.max match {\n           \
    \ case None => None\n            case Some(str) => Some(str.toUpper)\n       \
    \ }", "        // Find all combinations of the elements in the list\n        val\
    \ (combos, rest) = strings.span(x => x != strings(strings.indexOf(x) + 1))\n \
    \       // If there are no more elements in the list, return None\n        if\
    \ (rest.size == 0) Some(strings.max)\n        // Otherwise find the longest substring\n\
    \        else {\n            // The longest substring starts where the strings\
    \ combos end\n            def longestSubstringStart(strings: List[String], stringIndex\
    \ : Int) : Int = {\n                val index = stringIndex(stringIndex + 1)\n\
    \                if (index < 0) index else longestSubstringStart(strings, index)\n\
    \            }\n            // The longest substring ends where the strings combos\
    \ start\n            def longestSubstringEnd(strings: List[String], stringIndex\
    \ : Int) : Int = {\n                val index = stringIndex(stringIndex + 1)\n\
    \                if (index < 0) index else longestSubstringEnd(strings, index)\n\
    \            }\n            // The longest substring that starts and ends at a\
    \ given index\n            def longestSubstring(strings: List[String], stringIndex\
    \ : Int) : (Int, Int) = {\n                (longestSubstringStart(strings, stringIndex),\
    \ longestSubstringEnd(strings, stringIndex))\n            }\n            // Find\
    \ the longest substring\n            val longestSubstring = longest_substring_from(combos,\
    \ rest)\n            // Return the first one if there are multiple longest substrings\n\
    \            if (longestSubstring.size >= 2) longestSubstring.head\n         \
    \   else None\n        }", "        strings.length match {\n            case 0\
    \ => None\n            case 1 => Some(strings.head)\n            case _ => {\n\
    \                val maxLength: Int = -1\n                strings.map(_.length).reduce((x,\
    \ y) => if (x > y) { x } else { y }).\n                    zipWithIndex.filter(_._1\
    \ == maxLength).map(_._2).head match {\n                        case None => strings.head\n\
    \                        case Some(x) => x\n                    }\n          \
    \  }\n        }", '        strings.maxBy(length => strings.length)', '        strings.headOption.map
    { longest(longest(strings.tail)) }', "        if (strings.length == 0) return\
    \ None\n        var maxLength = 0\n        strings.foreach {s =>\n           \
    \ if (s.length() > maxLength) {\n                maxLength = s.length()\n    \
    \        }\n        }\n        strings.find(s => s.length() == maxLength)", '        strings.toList.sortWith(_
    < _).headOption', "        strings.foldLeft((None, strings.length)) {\n      \
    \      case ((longest, length), string) =>\n                if (string.length\
    \ > length) (strings.updated(longest, string), length)\n                else {\
    \ (longest, length) }\n        }._1.getOrElse((None, strings.length))", "    \
    \    // A simple O(N) algorithm to find the longest string in input\n        if\
    \ (strings.isEmpty) {\n            None\n        } else {\n            strings.sortWith(_\
    \ > _)\n                .takeWhile(_ < strings.max)\n                .headOption\n\
    \        }", "        if (strings.isEmpty) return None\n        val longest =\
    \ strings.foldLeft(List[String]())((res, str) => res match {\n            case\
    \ Nil => List(str)\n            case _ => {\n                if (str.length()\
    \ > res.length()) res :+ str\n                else str\n            }\n      \
    \  })\n        if (longest.length == strings.length) longest.head else longest.lastOption",
  '        strings.maxBy(_.length)', "        strings.length match {\n           \
    \ case 0 => None\n            case 1 => strings.headOption\n            case _\
    \ => {\n                val (_longest, _first) = strings.partition(_.length ==\
    \ strings.length)\n                _longest.maxOption\n            }\n       \
    \ }", "        strings.headOption\n            .map(s => strings.map(s => s match\
    \ {\n                case x @ _ if x == s => x\n                case _ => s\n\
    \            }).maxBy(_.length))\n            .orElse(None)", "        strings.maxBy(_.length)\
    \ match {\n            case None => None\n            case Some(s) => s\n    \
    \    }", "        strings.foldLeft(None, mutable.ListBuffer[(Int, String)])((acc,\
    \ el) => {\n            if (el.length <= acc._1._1)\n                Some((el.length,\
    \ el))\n            else {\n                val candidate = acc._2.lastOption\n\
    \                if (candidate.isDefined && candidate._1 == el.length)\n     \
    \               Some(candidate._2, el)\n                else\n               \
    \     Some((el.length, el), acc._2)\n            }\n        })", '        strings.maxBy(_.length)',
  "      val lengths = strings.map(_.length).toList\n      strings.maxBy(lengths)",
  "        if (strings.nonEmpty) {\n            var longest = strings(0)\n       \
    \     for (index <- 1 until strings.length) {\n                if (strings(index).length\
    \ == strings(index-1).length) {\n                    if (strings(index).length\
    \ > longest.length) longest = strings(index)\n                } else {\n     \
    \               if (strings(index).length < longest.length) longest = strings(index)\n\
    \                }\n            }\n            if (longest != strings(0)) longest\n\
    \            else Some(strings(0))\n        }\n        else None", '        strings.sortBy(x
    => x.length).lastOption', '        if (strings.length == 0) None else strings.map(_.length).max.toOption',
  "        if(strings.length == 0)\n            None\n        else\n            strings.foldLeft(Option.empty[String])\
    \ { (option, current) => {\n                if(current.length() > option.get.length)\n\
    \                    option = Some(current)\n                else\n          \
    \          option\n            }}.getOrElse(None)", "        if (strings.isEmpty)\
    \ {\n            None\n        } else {\n            var largest = strings.head\n\
    \n            // Search strings in reversed order\n            for (i <- strings.reverse)\
    \ {\n                if (i <= largest || largest.equals(i)) {\n              \
    \      largest = i\n                }\n            }\n            Some(largest)\n\
    \        }", "        strings.sizeMatchOrElse({ (n: Int, ls: List[String]) =>\
    \ ls match {\n                case h :: t => if (h.length == n) Some(h) else longest(t)\n\
    \                case Nil => None\n                }\n            }, None)", '      strings.toList.groupBy(s
    => s.length).maxBy(_._1).getOrElse(None)', "        strings.foldLeft((List.empty,\
    \ List.empty)) {\n            (accum: (List[String], List[String]), current: String)\
    \ =>\n                accum._1 diff accum._2 exists { currentString => current.length\
    \ < currentString.length }\n                    match {\n                    \
    \    case (true, left) => (current :: left, List.empty)\n                    \
    \    case (true, right) => left.tail diff right.tail exists { currentString =>\
    \ current.length < currentString.length }\n                            match {\n\
    \                                case (true, left) => (current :: left, right)\n\
    \                                case (true, right) => (left.head :: current,\
    \ right.head :: right)\n                                case (false, left) =>\
    \ left.tail\n                                case (false, right) => right.head\n\
    \                            }\n                        case (false, left) =>\
    \ (List.empty, current :: left)\n                        case (false, right) =>\
    \ (left :+ current, right)\n                    }\n        }._2.head", "     \
    \   strings.length match {\n            case 0 => None\n            case _ =>\n\
    \                strings.sortWith(_.length < _.length) match {\n             \
    \       case x :: y => Some(x.head)\n                    case x => None\n    \
    \            }\n        }", "        var longest = strings(0)\n        var count\
    \ = 0\n        for (str <- strings) {\n            count = str.length\n      \
    \      if (count > longest.length) {\n                longest = str\n        \
    \    }\n        }\n        if (count > longest.length) {\n            None\n \
    \       } else {\n            Some(longest)\n        }", "        strings.foldRight[Option[String]](None)((x,\
    \ y) => {\n            if (x.length <= y.length) x else y\n        })", "    \
    \    strings.length match {\n            case 0 => None\n            case _ =>\
    \ {\n                var result = strings(0)\n                for (i = 1 until\
    \ strings.length) if (!strings(i).equals(result)) result = strings(i)\n      \
    \          Some(result)\n            }\n        }", "        if (strings.length\
    \ == 0) None\n        else {\n            val len = strings(0).length\n      \
    \      val res = strings.filter(_ => _.length == len)\n            if (res.length\
    \ == 1) res.head\n            else longest(res)\n        }", "        strings.sizeOption\
    \ match {\n            case 0 => None\n            case size => strings.sortWith((s1,\
    \ s2) => s1.length < s2.length).lastOption\n        }", "        if (strings.length\
    \ == 0) None\n        else {\n            var bestLength = 1\n            var\
    \ maxString: String = strings.head\n            var maxStringLen: Int = maxString.length\n\
    \            strings.foreach { string =>\n                var stringLen = string.length\n\
    \                if (stringLen > maxStringLen) {\n                    maxStringLen\
    \ = stringLen\n                    maxString = string\n                }\n   \
    \         }\n            if (maxStringLen > bestLength) {\n                bestLength\
    \ = maxStringLen\n                Some(maxString)\n            } else {\n    \
    \            longest(strings.tail)\n            }\n        }", "        if (strings.length\
    \ == 0) {\n            None\n        } else if (strings.length == 1) {\n     \
    \       Some(strings.head)\n        } else {\n            strings.foldRight(List[String]())((xs,\
    \ ys) => {\n                if (xs.size == 0) Some(ys) else xs\n            }).maxBy(length\
    \ => length).getOrElse(None)\n        }", "        if (strings.isEmpty) None\n\
    \        else strings.head match{\n            case \"a\"| \"b\"| \"c\"| \"d\"\
    | \"e\"| \"f\"| \"g\"| \"h\"| \"i\"| \"j\"| \"k\"| \"l\"| \"m\"| \"n\"| \"o\"\
    | \"p\"| \"q\"| \"r\"| \"s\"| \"t\"| \"u\"| \"v\"| \"x\"| \"y\"| \"z\" => Some(strings.head)\n\
    \            case _ => longest(strings.tail).maxBy(strings.head)\n        }",
  "        if (strings.length == 0) {\n            None\n        } else {\n      \
    \      strings.reduceLeft((a, b) => (a.length >= b.length ? a : b)).headOption\n\
    \        }", "        if (strings.length == 0)\n            None\n        else\n\
    \            strings.foldLeft(None)((max, current) => if (current.length() > max.length)\
    \ max else current)", "        strings.length match {\n            case 1 => Some(strings(0))\n\
    \            case _ =>\n                val longest = strings.sortBy(s => s.length).head\n\
    \                val remainingToBeFound = strings.filterNot(longest.equals(s))\n\
    \                longest.exists(s => longest.equals(s))\n                    \
    \    .getOrElse(longest.exists(remainingToBeFound.forall(s => longest.equals(s))))\n\
    \                        .getOrElse(strings.length == 1)\n                   \
    \     .getOrElse(strings(0))\n        }", "        val n = strings.length\n  \
    \      if (n == 0) None\n        else {\n            var maxLength = 0\n     \
    \       var longestString = None\n            for (s <- strings) {\n         \
    \       val length = s.length\n                if (length >= maxLength) {\n  \
    \                  if (length == maxLength) {\n                        longestString\
    \ = s\n                    }\n                    else { // A shorter string with\
    \ the same length is duplicated, therefore return the first one encountered.\n\
    \                        longestString = Some(s)\n                        break\n\
    \                    }\n                }\n                maxLength = length\n\
    \            }\n            longestString\n        }", "        if(strings.isEmpty)\
    \ {\n            None\n        } else {\n            // Sort the list by length\n\
    \            val sorted = strings.sortBy(_.length)\n            // return the\
    \ first string in the sorted list\n            if(sorted.length == 1) {\n    \
    \            Some(sorted.head)\n            } else { // return longest\n     \
    \           val lastIndex = sorted.length-1\n                val longest = sorted.take(lastIndex).last\n\
    \                Some(longest)\n            }\n        }", "        if (strings.length\
    \ == 0) return None\n        if (strings.size <= 1) return strings.headOption\n\
    \        strings.foldLeft(List[String]())( (list, item) => list match {\n    \
    \        case head :: tail => if (head.length <= item.length) item :: head else\
    \ head :: tail\n            case _ => list :+ item\n        }).lastOption", " \
    \       if (strings.length == 0) None\n        else {\n            var maxLength\
    \ = 0\n            var maxString: String = null\n            strings.foreach(str\
    \ => {\n                if (str.length > maxLength) {\n                    maxLength\
    \ = str.length\n                    maxString = str\n                }\n     \
    \       })\n            if (maxLength > 0) Some(maxString)\n            else longest(strings.tail)\n\
    \        }", "        if(strings.isEmpty) None // No strings\n        else {\n\
    \            val maxLen = strings.map(_.length).max\n            val longest =\
    \ strings.find(_.length == maxLen)\n            longest.map(_.toString)\n    \
    \    }", "        strings.foldLeft(\"\") {\n            (x: String, y: String)\
    \ => if (x.length > y.length) x else y\n        }", "        strings.toList match\
    \ {\n            case Nil => None\n            case x :: rest => x.length.maxOption\
    \ match {\n                case Some(i) if i == x.length => Some(x)\n        \
    \        case _ => longest(rest)\n            }\n        }", '        strings.sortBy(-_.length).lastOption',
  "        var maxSize = -1\n        var maxString = \"\"\n        var maxStringSize\
    \ = 0\n        for (str <- strings) {\n            val newSize = str.size\n  \
    \          if (maxSize == -1)\n                maxString = str\n            if\
    \ (newSize > maxStringSize)\n                maxStringSize = newSize\n       \
    \     if (newSize > maxSize)\n                maxSize = newSize\n        }\n \
    \       maxStringSize match {\n            case 1 => Some(maxString)\n       \
    \     case _ => longest(strings.dropRight(1))\n        }", '        strings.maxBy(strings.length)',
  "        strings.length match {\n            case 0 => None\n            case 1\
    \ => Some(strings.head)\n            case n => {\n                val res = strings.sortBy(x\
    \ => x.length).take(n)\n                res.forall(_.length == n)\n          \
    \          ? Some(res.max)\n                    : longest(res)\n            }\n\
    \        }", '        strings.toSet.maxBy(_.length)', "        val longest = strings.foldLeft(List[String]())(_:::_).maxBy(strings.length)\n\
    \        if (longest.length > 0) longest else None ", '        if (strings.isEmpty)
    None else strings.maxBy(s => s.length)', "        if (strings.isEmpty)\n     \
    \       None\n        else {\n            val longest = strings.foldRight((0,\"\
    \"))((x, y) => if (x.length > y.length) x else y)\n            longest._1.length\
    \ > longest._2.length match {\n                case true => longest\n        \
    \        case false => longest._2\n            }\n        }", '        strings.groupBy(_.length).maxBy(_._2).headOption',
  "        if (strings.length == 0)\n            None\n        else strings.foldLeft(strings.headOption)\
    \ {\n            (_, s) => if (s.toString.length == strings.length.max)\n    \
    \            s\n            else\n                None\n        }", "        strings.length\
    \ match {\n            case 0 => None\n            case _ =>\n               \
    \ val lengths : Seq[Int] = strings.map(_.length)\n                lengths match\
    \ {\n                    case 0 | 1 => strings.headOption\n                  \
    \  case 2 if lengths.last > lengths.head => strings.lastOption\n             \
    \       case _ =>\n                        val maxIndex = lengths.max\n      \
    \                  strings.find(_.length == maxIndex) match {\n              \
    \              case Some(string) => Some(string)\n                           \
    \ case _ => longest(strings.takeRight(maxIndex))\n                        }\n\
    \                }\n        }", "        if (strings.length == 0) return None\n\
    \        var longest = strings(0)\n        for (str <- strings) {\n          \
    \  if (longest.length < str.length) {\n                longest = str\n       \
    \     }\n        }\n        if (longest.length == 0) return None\n        longest",
  "        if (strings.length == 0) None\n        else strings.sorted(lengthCompare).take(1)",
  "        if(strings.isEmpty) None else {\n            var maxLen = strings.head.length\n\
    \            var longest = strings.head\n            for(s <- strings) {\n   \
    \             val len = s.length\n                if(len > maxLen) {\n       \
    \             maxLen = len\n                    longest = s\n                }\n\
    \            }\n            longest\n        }", "        strings.foldLeft((\"\
    \", \"\"))((maxLen, str) => {\n            (str.length max maxLen) match {\n \
    \               case (len, maxLen) if len == maxLen => Some(str)\n           \
    \     case (len, maxLen) => None\n            }\n        })", "        strings\
    \ match {\n            case Nil => None\n            case _ =>\n             \
    \   // Find maximum\n                var maxIndex = 0\n                var maxLength\
    \ = strings(0)\n                var maxStrings = List[String]()\n            \
    \    for (x <- strings) {\n                    if (x.length > maxLength) {\n \
    \                       maxLength = x.length\n                        maxIndex\
    \ = x\n                    }\n                    if (x.length == maxLength) {\n\
    \                        maxStrings = maxStrings :+ x\n                    }\n\
    \                }\n                // If maximum length is 1, just return the\
    \ first one\n                if (maxStrings.length == 1) {\n                 \
    \   Some(maxStrings(0))\n                } else {\n                    // Else,\
    \ return the longest one\n                    Some(maxStrings(maxIndex))\n   \
    \             }\n        }", "      strings match {\n        case Nil => None\n\
    \        case _ =>\n          strings.foldRight(\"\")((acc, string) => if (string.length()\
    \ > acc.length) string else acc)\n      }", '      strings.foldRight(Option.empty[String])(longest(_.length))(_
    max _)', "        if (strings.length == 0) None\n        else {\n            var\
    \ max = \"\"\n            var maxLength = 0\n            var i = 0\n         \
    \   while (i < strings.length && !max.isEmpty) {\n                max = strings.tail.filterNot(x\
    \ => x == max).foldLeft[String](\"\"){ (result, x) => if (result.length < x.length)\
    \ result else x; x }\n                maxLength = strings.length - strings.length.filter(x\
    \ => x == max).length\n                i += 1\n            }\n            if (maxLength\
    \ > strings.length) Some(max)\n            else longest(strings.init)\n      \
    \  }", "        if (strings.length == 0) None else\n            strings.head match\
    \ {\n                case x if strings.length == 1  => Some(x)\n             \
    \   case x if strings.length == 2 => Some(x.substring(0,strings.length-1))\n \
    \               case x if strings.length == 3 => Some(x.substring(0,strings.length-2))\n\
    \                case x if strings.length == 4 => Some(x.substring(0,strings.length-3))\n\
    \                case x if strings.length == 5 => Some(x.substring(0,strings.length-4))\n\
    \                case x if strings.length == 6 => Some(x.substring(0,strings.length-5))\n\
    \                case x if strings.length == 7 => Some(x.substring(0,strings.length-6))\n\
    \                case x if strings.length == 8 => Some(x.substring(0,strings.length-7))\n\
    \                case x if strings.length >= 9 => Some(x.substring(0,strings.length-8))\n\
    \                case x if strings.length >= 10 => Some(x.substring(0,strings.length-9))\n\
    \                case x if strings.length >= 11 => Some(x.substring(0,strings.length-10))\n\
    \                case x if strings.length >= 12 => Some(x.substring(0,strings.length-11))\n\
    \                case x if strings.length >= 13 => Some(x.substring(0,strings.length-12))\n\
    \                case x if strings.length >= 14 => Some(x.substring(0,strings.length-13))\n\
    \                case x if strings.length >= 15 => Some(x.substring(0,strings.length-14))\n\
    \                case x if strings.length >= 16 => Some(x.substring(0,strings.length-15))\n\
    \                case x if strings.length >= 17 => Some(x.substring(0,strings.length-16))\n\
    \                case x if strings.length >= 18 => Some(x.substring(0,strings.length-17))\n\
    \                case x if strings.length >= 19 => Some(x.substring(0,strings.length-18))\n\
    \                case x if strings.length >= 20 => Some(x.substring(0,strings.length-19))\n\
    \                case x if strings.length >= 21 => Some(x.substring(0,strings.length-20))\n\
    \                case x if strings.length >= 22 => Some(x.substring(0,strings.length-21))\n\
    \                case x if strings.length >= 23 => Some(x.substring(0,strings.length-22))\n\
    \                case x if strings.length >= 24 => Some(x.substring(0,strings.length-23))\n\
    \                case x if strings.length >= 25 => Some(x.substring(0,strings.length-24))\n\
    \                case x if strings.length >= 26 => Some(x.substring(0,strings.length-25))\n\
    \                case x if strings.length >= 27 => Some(x.substring(0,strings.length-26))\n\
    \                case x if strings.length >= 28 => Some(x.substring(0,strings.length-27))\n\
    \                case x ", '        if (strings.length == 0) None else Some(max(strings))',
  "        // Create empty mutable string list to hold longest string\n        val\
    \ longest = mutable.StringBuilder(\"\")\n        for (s <- strings) {\n      \
    \      if (s.length >= longest.length) {\n                longest.clear()\n  \
    \              longest.append(s)\n            } else {\n                longest.append(s)\n\
    \            }\n        }\n        longest.headOption", "        if (strings.isEmpty)\
    \ return None\n        if (strings.size <= 1) return strings.headOption\n    \
    \    val longest = strings.length\n        val sorted = strings.toArray.sortWith((s1,\
    \ s2) => s1.length < s2.length)\n        Some(sorted(0, longest).last)", "   \
    \     strings.length match {\n            case 0 => None\n            case 1 =>\
    \ Some(strings.head)\n            case n => {\n                val mn = strings.map(_.length).max\n\
    \                strings.find(_.length == mn) match {\n                    case\
    \ None => None\n                    case Some(i) => Some(strings.take(1).head(i))\n\
    \                }\n            }\n        }", '        if (strings.isEmpty) None
    else strings.sortWith(_.length < _.length).last', "        val m = strings.foldLeft(List[Int]()){\
    \ (res, x) => res :+ x.length }\n        val indexList = m.map(m => m._2).indexWhere(_\
    \ == m.max)\n        val max = m.max\n        if (indexList.size > 0) {\n    \
    \        val result = strings.lift(indexList(1))\n            Some(result)\n \
    \       }\n        else {\n            None\n        }", "        strings.length\
    \ match {\n            case 0 => None\n            case _ => {\n             \
    \   strings.sortWith( (s1, s2) => s2.length < s1.length )\n                strings(0)\n\
    \            }\n        }", "        if (strings.length > 0) {\n            val\
    \ longest = strings.groupBy(_.length).map(_._2.max).head\n            if (longest\
    \ == strings.last.length) {\n                Some(strings.last)\n            }\
    \ else {\n                longest\n            }\n        } else {\n         \
    \   None\n        }", "        strings.sizeOption match {\n            case None\
    \ => None\n            case _ => {\n                val max = strings.toList.sortBy(_.length).last\n\
    \                if (max.length == strings.size) {\n                    Some(max)\n\
    \                } else {\n                    strings.toList.filter(_.length\
    \ == max.length).headOption\n                }\n            }\n        }", " \
    \       if(strings.isEmpty)\n            None\n        else\n            strings.find(_.length\
    \ == strings.map(_.length).max)", "        // The idea is simple: find the longest\
    \ string, and see whether any other string shares the same length\n        //\
    \ If they do, we just use that one\n        strings.sortBy { _.length }.lastOption",
  "        strings.foldLeft(List.empty[String]) { case (a, b) =>\n            if (a.length\
    \ < b.length) a :: b else b :: a\n        }.maxBy(_.length)", "        // We will\
    \ store the longest string in the result list and keep a map of seen lengths (so\n\
    \        // that the longest string will be the first one in the result list).\n\
    \        val longest = scala.collection.mutable.ListBuffer[String]()\n       \
    \ val seen = scala.collection.mutable.Map[Int, String]()\n        // We first\
    \ add all the strings in the list and sort them by their length in descending\
    \ order\n        // and we only keep strings with the same length into the result\
    \ list.\n        strings.sortBy(s => -s.length)\n            .filterNot(s => seen(s.length)\
    \ == null)\n            .foreach { s =>\n                if (s.length == seen(s.length).length)\
    \ {\n                    // If the length of the string is equal to the previously\
    \ seen length, we are done\n                    // with this string. Otherwise\
    \ we keep the previous string, and add the current string\n                  \
    \  // with the new length.\n                    seen.update(s.length, s)\n   \
    \                 longest += s\n                } else {\n                   \
    \ // If the length of the string is different, we keep the current string, with\
    \ the length\n                    // equal to the previously seen length. We keep\
    \ this string if the current string is\n                    // longer than the\
    \ previous one.\n                    seen.update(s.length, s)\n              \
    \      longest += seen(s.length)\n                }\n            }\n        //\
    \ In case the length of the longest string is equal to the length of any of the\
    \ previous\n        // strings in the list, we return the last one. We return\
    \ the string with the highest length\n        // to make sure the longest string\
    \ is returned in the event of having multiple strings of the\n        // same\
    \ length.\n        if (longest.forall(s => seen(s.length) == s) && longest.size\
    \ == strings.size) {\n            Some(longest.max)\n        } else {\n      \
    \      None\n        }", "        strings.sizeOption match {\n            case\
    \ 0 => None\n            case x if x == 1 => strings.headOption\n            case\
    \ x => strings.groupBy(_.length).mapValues(_.size).maxBy(_._2)._2\n        }",
  "        if(strings.isEmpty) {\n            None\n        } else {\n           \
    \ val longest = strings.foldLeft(\"\"){\n                case(maxValue, rest)\
    \ => rest.length >= maxValue.length ? (rest -> maxValue) : ((rest -> maxValue).length);\
    \ \n            }._1\n            if(longest == strings(0)) {\n              \
    \  Some(strings(0))\n            } else {\n                Some(longest)\n   \
    \         }\n        }", "        strings.foldLeft((\"\", \"\")) { ((lon, cur)\
    \ , (cur, s) ) =>\n            if(cur.length < s.length)\n                (cur,\
    \ s)\n            else if(cur.length > s.length)\n                (lon, s)\n \
    \           else\n                (lon, cur)\n        }", "        strings.foldLeft((\"\
    \", List[String]())) { case ((longest, current), string) => {\n            if\
    \ (string.length() > longest.length)\n                (longest, string :: current)\n\
    \            else {\n                if (string.length() == longest.length)\n\
    \                    Some(string)\n                else\n                    (longest,\
    \ current)\n            }\n        }}._2.head", "        if (strings.isEmpty)\
    \ None\n        else strings.sortWith(_ < _).last ", "        strings.toList match\
    \ {\n            case Nil => None\n            case head :: tail => {\n      \
    \          val longestString = head :: tail.foldLeft(head)(_.length max _)\n \
    \               val duplicates = tail.filter(x => x.length sameElements longestString.length)\n\
    \                val sameLength = tail.filter(x => x.length sameElements longestString.length)\n\
    \                if (duplicates.nonEmpty) longestString\n                else\
    \ if (sameLength.nonEmpty) sameLength.head\n                else longestString\n\
    \            }\n        }", "        strings.foldLeft(Option[String](\"\")) {\n\
    \          case (Some(longest), element) => longest.take(element.length).length\
    \ match {\n            case x if x < element.length => Some(element)\n       \
    \     case x => longest\n          }\n        }", "        if (strings.length\
    \ == 0) {\n            None\n        } else {\n            strings.maxBy(_.length)\n\
    \        }", "        var longest = strings.head\n        var max_len = longest.length\n\
    \        var max_len_index = -1\n        for {\n            s <- strings\n   \
    \         i <- 0 until s.length\n            if max_len < s.length\n        }\
    \ yield {\n            longest = s\n            max_len = s.length\n         \
    \   max_len_index = i\n        }\n        if (max_len == 0) return None\n    \
    \    Some(longest.substring(0, max_len_index))", "        if (strings.length ==\
    \ 0)\n            None\n        else strings.foldLeft((None,\"\")) { (res, string)\
    \ =>\n            val (longest, longestLength) = res._1\n            val (newLon,\
    \ newLonLength) = longest.length.max(string.length)\n            if (newLonLength\
    \ == string.length)\n                (res, new String + string)\n            else\
    \ if (newLonLength < string.length)\n                (res, new String + string\
    \ + strings.last)\n            else\n                (longest, new String + string)\n\
    \        }._2", '        strings.maxBy(_.length)', "        strings = strings\
    \ match {\n            case Nil => None\n            case stringList => stringList\n\
    \        }\n        strings.sortWith((s1, s2) => s1.length < s2.length)\n    \
    \    strings.get(strings.length - 1)", "        strings.length match {\n     \
    \       case 0 => None\n            case _ =>\n                var longest = \"\
    \"\n                var index = 0\n                for (i <- 0 until strings.length)\
    \ yield {\n                    if (longest.length < strings(i).length) {\n   \
    \                     longest = strings(i)\n                        index = i\n\
    \                    }\n                }\n                longest\n        }",
  "        strings.size.toDouble match {\n            case 0.0 => None\n         \
    \   case size if size < strings.size.toDouble => Some(strings.sorted.last)\n \
    \           case size if size >= strings.size.toDouble => longest(List.fill(size)(strings.last))\n\
    \        }", "        strings.length match {\n            case 0 => None\n   \
    \         case _ =>\n                val len = strings.foldLeft(0)(_ + _.length)\n\
    \                strings.map(_.length).indexOf(len) match {\n                \
    \    case -1 => None\n                    case i => Some(strings(i))\n       \
    \         }\n        }", "        strings.length match {\n            case 0 =>\
    \ None\n            case _ => strings.foldLeft(None)((max, string) =>\n      \
    \          if (string.length > max.length) Some(string) else None\n          \
    \      )\n        }", "        strings.length match {\n            case 0 => None\n\
    \            case 1 => strings.head\n            case _ =>\n                val\
    \ sorted = strings.sortWith(_ < _)\n                sorted.takeWhile(s => strings.count(_\
    \ == s) > 1).maxBy(strings.size)\n        }", "        if (strings.length == 0)\n\
    \            None\n        else {\n            strings.sortWith(_ < _).lastOption\n\
    \        }", "        var longest = \"\"\n        var longest_length = 0\n   \
    \     var current_longest = \"\"\n\n        strings.foreach{\n            string\
    \ => {\n                val length = string.length\n                if (length\
    \ > longest_length) {\n                    longest_length = length\n         \
    \           current_longest = string\n                }\n            }\n     \
    \   }\n\n        if (longest_length == 0)\n            None\n        else if (longest_length\
    \ == strings(0).length)\n            current_longest\n        else\n         \
    \   longest(List.tail(strings).filter{s => s.length == longest_length})", '        stringList.sortWith(_.length
    compare _.length).lastOption', '        strings.sortWith(_.length < _.length).lastOption',
  '        strings.sortBy(_.length).take(1)', "        strings.lengthOption match\
    \ {\n            case None => None\n            case Some(length) => strings.find(length\
    \ <= strings.length).map(s => s.take(length)).orElse(strings.head)\n        }",
  "        strings.sortWith(_.length < _.length) match {\n            case Nil =>\
    \ None\n            case x :: xs => Some(xs.headOption)\n        }", "       \
    \ var longest : Option[String] = None\n        for (str <- strings) {\n      \
    \      if (longest == None) longest = str\n            else longest = str.takeWhile(_.length\
    \ == longest.length).getOrElse(longest)\n        }\n        longest", '        strings.foldRight((None,
    List[String]())){case ((max, strings), string) => if (string.length <= max._1)
    (Some(string), List[String]()) else if (string.length == max._1) (Some(max), string::strings)
    else (Some(max), string::string::strings)}', "        strings.getOrElse(List[String]())\n\
    \            .zipWithIndex\n            .maxBy(_._2.length).getOrElse(_._1)",
  "        strings.reduce(List.empty, (a: String, b: String) =>\n            if (a.length\
    \ < b.length) a else b)", "        // Make a list of strings sorted by length\n\
    \        val stringLengths = strings.map(_.length).sort\n\n        // Return the\
    \ first element of listLengths that is equal to the greatest length so far\n \
    \       // If no such element exists, return None\n        stringLengths.takeWhile(_.length\
    \ > stringLengths.last).headOption", "        if(strings.isEmpty) {\n        \
    \    None\n        } else if(strings.length == 1) {\n            Some(strings.head)\n\
    \        } else {\n            val longest = strings.foldRight(Some(strings.head)){\
    \ case (acc, elem) =>\n                if(acc.length < elem.length) {\n      \
    \              Some(elem)\n                } else if(acc.length == elem.length)\
    \ {\n                    Some(acc.getOrElse(\"\") + elem)\n                } else\
    \ {\n                    None\n                }\n            }\n            if(longest.isDefined)\
    \ {\n                longest\n            } else {\n                None\n   \
    \         }\n        }", "        strings.length match {\n            case 0 =>\
    \ None\n            case 1 => strings(0)\n            case _ => {\n          \
    \      var m = strings.length\n                var x = strings(0)\n          \
    \      for (i <- 1 until m) {\n                    if (strings(i).length <= x.length)\
    \ x = strings(i)\n                }\n                Some(x)\n            }\n\
    \        }", "        if (strings.length == 0) {\n            None\n        }\n\
    \        else {\n            val m = strings.foldLeft(List.empty[String])((acc,\
    \ curr) =>\n            if (acc.length < curr.length) {\n                acc +\
    \ curr\n            }\n            else {\n                acc\n            }\n\
    \            )\n            if (m.length == strings.length) {\n              \
    \  Some(m(0))\n            }\n            else {\n                val longest_string\
    \ = m.max\n                Some(longest_string)\n            }\n        }", " \
    \       if (strings.length < 1) None\n        else {\n            var longest\
    \ : String = \"\"\n            var longestIndex : Int = 0\n            for (i\
    \ <- 0 until strings.length) {\n                if (strings(i).length >= longest.length)\
    \ {\n                    longest = strings(i)\n                    longestIndex\
    \ = i\n                }\n            }\n            longest\n        }", "  \
    \      if (strings.length == 0) {\n            None\n        }\n        val longest\
    \ = strings.toList.sortWith(_.length == _.length)\n        val result = longest.lastOption\n\
    \        result", '        strings.sortBy(_.length).lastOption', '        if (strings.isEmpty)
    None else strings.head.takeWhile(x => strings.map(_.length).max == x.length).headOption',
  "        if (strings.isEmpty) None else\n            strings.sortBy(_.length).reverse.headOption",
  "        strings.sortBy(_.length)\n        strings.lastOption", "        if(strings.isEmpty)\
    \ {\n            None\n        } else {\n            var maxLen : Int = Int.MaxValue\n\
    \            strings.foreach { str =>\n                val len  = str.length\n\
    \                if(len > maxLen) {\n                    maxLen = len\n      \
    \          }\n            }\n            strings.find( str => str.length == maxLen)\n\
    \        }", "        if (strings.isEmpty)\n            None\n        else if\
    \ (strings.nonEmpty)\n            strings.find(_.length == strings.head.len).map\
    \ { i => strings(i).length }\n        else\n            None", "        strings.length\
    \ match {\n            case 0 => None\n            case _ => {\n             \
    \   var longest = strings(0)\n                for (i <- 1 to strings.length -1)\
    \ {\n                    if (strings(i).length <= longest.length)\n          \
    \              longest = strings(i)\n                }\n                Some(longest)\n\
    \            }\n        }", "        var max = 0\n        var longest = List.empty[String]\n\
    \        strings.foreach{s =>\n            if (s.length > (max = s.length) &&\
    \ s.nonEmpty) {\n                longest = longest :+ s\n            }\n     \
    \   }\n        longest.exists(longest.length <= max) ? longest else None", " \
    \       strings.length match {\n            case 0 => None\n            case x\
    \ if x > 0 => Some(strings.max)\n            case x if x < 0 => longest(strings.reverse)\n\
    \        }", "        if (strings.isEmpty)\n            None\n        else\n \
    \           strings.fold(None, strings.length => strings.takeRight(strings.length))",
  "      if (strings.length < 1) None // Empty list is a valid input\n      else {\n\
    \        strings.length match {\n          case 1 => strings.headOption // single\
    \ element\n          case _ => strings.foldLeft(ListBuffer[String]()) { (buffer,\
    \ s) =>\n            if (buffer.length < s.length) buffer += s\n            else\
    \ buffer\n          }.lastOption\n        }\n      }", "        strings.length\
    \ match {\n            case 0 => None\n            case 1 => Some(strings.head)\n\
    \            case _ => {\n                val stringSet = mutable.HashSet[String]()\n\
    \                strings.foreach(s => {\n                    if (stringSet.contains(s))\
    \ {\n                        stringSet += s\n                    } else {\n  \
    \                      stringSet = stringSet :+ s\n                    }\n   \
    \             })\n                stringSet match {\n                    case\
    \ Nil => None\n                    case stringSet => Some(stringSet.max)\n   \
    \             }\n            }\n        }", "        if (strings.length == 0)\
    \ None\n        else {\n            val longest = strings.sortWith(_ > _).head\n\
    \            longest.isEmpty match {\n                case true => None\n    \
    \            case false => longest\n            }\n        }", "        strings.foldRight(strings.headOption):\
    \ Option[String] => strings.headOption match {\n            case None => None\n\
    \            case Some(first) => strings.head :: strings.tail.foldRight(first)\
    \ match {\n                case None => None\n                case Some(first)\
    \ => Some(first)\n            }\n        }", '        strings.sortWith(_._2.length
    == _.length).lastOption', '        strings.sortBy(length => length).lastOption',
  "        if (strings.length == 0) {\n            None\n        }\n        else {\n\
    \            val longestStrings : List[String] = strings.foldLeft(List[String]())((a,b)\
    \ => {\n                val length : Int = b.length\n                if (a.length\
    \ < length) {\n                    a :+ b\n                }\n               \
    \ else {\n                    a\n                }\n            })\n         \
    \   longestStrings.reverse.headOption\n        }", "        strings.foldLeft((\"\
    \", List[String]())){case (acc, elem) => elem match {\n            case (lastElem,\
    \ lastList) => acc match {\n                case (\"aaa\" :: lastList, _) => lastElem\n\
    \                case (_ :: lastList, _) => \"bbb\" :: lastElem\n            \
    \    case (_, _) => \"ccc\" :: lastElem\n                case _ => throw new IllegalArgumentException(\"\
    Unexpected input\")\n            }\n            case _ => throw new IllegalArgumentException(\"\
    Unexpected input\")\n        }}", "        strings.foldRight(None)((s, t) => t.length\
    \ match {\n            case l if l > s.length => Some(t)\n            case _ =>\
    \ Some(s)\n        })", "        strings.length match {\n            case 0 =>\
    \ None\n            case 1 => strings.head\n            case _ =>\n          \
    \      var max_string = \"\"\n                var max_string_len = -1\n      \
    \          var found_longest_string = False\n                strings.foreach {\
    \ s =>\n                    val len = s.length\n                    if (len >\
    \ max_string_len) {\n                        found_longest_string = True\n   \
    \                     max_string = s\n                        max_string_len =\
    \ len\n                    }\n                }\n                if (found_longest_string)\
    \ {\n                    Some(max_string)\n                } else {\n        \
    \            None\n                }\n        }", "        def longestRec(strings:\
    \ List[String], longest: String) = {\n            if(strings.length == 0) {\n\
    \                Some(longest)\n            }\n            else if(strings.length\
    \ > 0 ) {\n                val currentLongest = strings.head\n               \
    \ val otherStrings = strings.tail\n                val otherLongest = longestRec(otherStrings,\
    \ currentLongest)\n                if(otherLongest.isDefined) {\n            \
    \        if(currentLongest.length < otherLongest.get.length) { \n            \
    \            Some(currentLongest)\n                    }\n                   \
    \ else { \n                        val first = strings.head\n                \
    \        val rest = strings.tail\n                        val second = longestRec(rest,first)\n\
    \                        if(second.isDefined) { \n                           \
    \ Some(second.get) \n                        } else { \n                     \
    \       None \n                        }\n                    }\n            \
    \    }\n                else { \n                    None \n                }\n\
    \            }\n            else { \n                None \n            }\n  \
    \      }\n\n        longestRec(strings,\"\") ", "        if (strings.length >\
    \ 0) {\n            val lens = strings.map( s => s.length )\n            lens.max\n\
    \        }\n        else None", "        strings.length match {\n            case\
    \ 0 => None\n            case _ =>\n                strings.head match {\n   \
    \                 case null | \"\" => longest(strings.tail)\n                \
    \    case s => longest(strings.tail :+ s)\n                }\n        }", "  \
    \      strings.foldLeft((\"\", List[String]())) { \n            case ((longest,\
    \ current), s) => {\n                if (s.length > longest.length)\n        \
    \            (longest, current)\n                else if (s.length == longest.length)\n\
    \                    (current :+ s, longest)\n                else\n         \
    \           (\"\", List[String]())\n            }\n        }._1.headOption", '        if(strings.length
    == 0) None else Some(strings.maxBy(_.length))', "        if (strings.isEmpty)\
    \ return None\n        val counts = strings.map(s => 1 -> s.toDouble).foldLeft(Map[String,\
    \ Double]())((m, s) => if (m.contains(s)) m else m + (s -> m.get(s) + 1.0))\n\
    \        strings.map(s => s.toDouble).maxBy(x => counts(x) + 1.0).toString ->\
    \ strings.size", '        strings.sortBy { s => (s.length, s) }.lastOption', " \
    \       if(strings.isEmpty) {\n            None\n        } else {\n          \
    \  val longest = strings.headOption\n            val others = strings.tail\n\n\
    \            val sameLength = others.foldLeft(longest) {\n                case\
    \ (longest, next) => (next.length < longest.length) ? next : longest\n       \
    \     }\n\n            if(others.size == 1) {\n                Some(sameLength)\n\
    \            } else {\n                Some(longest)\n            }\n        }",
  "        // Sort the strings according to length\n        strings.sortWith(_.length\
    \ < _.length)\n            // Get the length of each string in strings\n     \
    \       .toList.flatMap { s => s.length }\n            // Get the length of the\
    \ longest string in strings\n            .max\n            // Return the longest\
    \ string if length of longest string in strings is equal to length of the\n  \
    \          // longest string in strings\n            .ifPresent { lengthOfLongest\
    \ =>\n                // If length of the longest string in strings is equal to\
    \ the length of the longest string in\n                // strings, then return\
    \ the longest string in strings\n                if (lengthOfLongest == strings.last.length)\
    \ {\n                    strings.last\n                } else {\n            \
    \        // If length of the longest string in strings is different from the length\
    \ of the longest\n                    // string in strings, then return None\n\
    \                    None\n                }\n            }", "        if (strings\
    \ == Nil) {\n            None\n        } else {\n            val lengths = strings.map(_.length).toArray\n\
    \            if (lengths.sorted.last == lengths.last)\n                strings.find(_.length\
    \ == lengths.last).getOrElse(Nil)\n            else\n                strings.find(_.length\
    \ == lengths.sorted.last).getOrElse(Nil)\n        }", "        strings.length\
    \ match {\n            case 0 => None\n            case 1 => strings.headOption\n\
    \            case _ => {\n                var longest = strings(0)\n         \
    \       for ((string1, string2) <- strings.zipWithIndex) {\n                 \
    \   if (string1.length <= longest.length && string2.length <= longest.length)\
    \ {\n                        longest = string1\n                    }\n      \
    \          }\n                longest\n            }\n        }"]
stop_tokens:
- "\n    }\n"
