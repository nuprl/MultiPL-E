language: scala
name: HumanEval_73_smallest_change
results:
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val min_arr = arr.reverse.sliding(2).map(_.reverse).zipWithIndex.filter(_._2\
    \ == 0).map(_._1).size\n        (min_arr == arr.size)\n            ? 0\n     \
    \       : min_arr\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpjddxnir2.scala:18:14 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m            : min_arr\n\e[31m\e[31m   |\e[0m        \
    \      ^^^^^^^\e[0m\n\e[31m   |\e[0m              Not found: type min_arr\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpjddxnir2.scala:17:12\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        (min_arr == arr.size)\n\
    \e[31m17 |\e[0m            ? \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m        ^\e[0m\n\
    \e[31m   |\e[0m        value ? is not a member of Boolean.\n\e[31m   |\e[0m  \
    \      Note that `?` is treated as an infix operator in Scala 3.\n\e[31m   |\e\
    [0m        If you do not want that, insert a `;` or empty line in front\n\e[31m\
    \   |\e[0m        or drop any spaces behind the operator.\n2 errors found\n"
  stdout: ''
  timestamp: 1660010501
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        if (arr.isEmpty) return 0\n        var min_changes = 0\n\
    \        var min_changes_i = arr.size - 1\n        while (min_changes_i >= 0)\
    \ {\n            var i = min_changes_i\n            val next_i = i + 1\n     \
    \       var last_i = min_changes_i - 1\n            if (i + 1 < arr.size && arr(i)\
    \ == arr(next_i)) {\n                last_i = i\n                i = next_i\n\
    \            }\n            var count = 1\n            for (i;  i <= last_i; \
    \ ++i) {\n                count += arr(i) - arr(i)\n            }\n          \
    \  count += 1\n            if (count < min_changes) {\n                min_changes\
    \ = count\n                min_changes_i = i\n            }\n        }\n     \
    \   return min_changes\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpzuu1bn2q.scala:27:18 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m            \e[33mfor\e[0m (i;  i <= last_i;  ++i) {\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   ')' expected, but ';' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpzuu1bn2q.scala:27:32\
    \ ---------------------------\e[0m\e[0m\n\e[31m27 |\e[0m            \e[33mfor\e\
    [0m (i;  i <= last_i;  ++i) {\n\e[31m\e[31m   |\e[0m                         \
    \       ^\e[0m\n\e[31m   |\e[0m                                '<-' expected,\
    \ but ';' found\n\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpzuu1bn2q.scala:27:38\
    \ ---------------------------\e[0m\e[0m\n\e[31m27 |\e[0m            \e[33mfor\e\
    [0m (i;  i <= last_i;  ++i) {\n\e[31m\e[31m   |\e[0m                         \
    \             ^\e[0m\n\e[31m   |\e[0m                                      pattern\
    \ expected\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010500
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val l1 = arr.toArray\n        val l2 = l1.reverse\n    \
    \    val res = l1\n        val len = arr.length\n\n        for (i <- len to 0\
    \ by -1) {\n            val j = (len + i - 1) \\ 2\n            var min = i\n\
    \            var m1 = arr(i).toLong\n            var m2 = arr(l1(0).toLong).toLong\n\
    \            var m3 = arr(l1(1).toLong).toLong\n            var m4 = arr(l1(2).toLong).toLong\n\
    \            var m5 = arr(l1(3).toLong).toLong\n            var m6 = arr(l1(4).toLong).toLong\n\
    \            var m7 = arr(l1(5).toLong).toLong\n            var m8 = arr(l1(6).toLong).toLong\n\
    \            var m9 = arr(l1(7).toLong).toLong\n            var m10 = arr(l1(8).toLong).toLong\n\
    \            var m11 = arr(l1(9).toLong).toLong\n            var m12 = arr(l1(10).toLong).toLong\n\
    \            var m13 = arr(l1(11).toLong).toLong\n            var m14 = arr(l1(12).toLong).toLong\n\
    \            var m15 = arr(l1(13).toLong).toLong\n            var m16 = arr(l1(14).toLong).toLong\n\
    \            var m17 = arr(l1(15).toLong).toLong\n            var m18 = arr(l1(16).toLong).toLong\n\
    \            var m19 = arr(l1(17).toLong).toLong\n            var m20 = arr(l1(18).toLong).toLong\n\
    \            var m21 = arr(l1(19).toLong).toLong\n            var m22 = arr(l1(20).toLong).toLong\n\
    \            var m23 = arr(l1(21).toLong).toLong\n            var m24 = arr(l1(22).toLong).toLong\n\
    \            var m25 = arr(l1(23).toLong).toLong\n            var m26 = arr(l1(24).toLong).toLong\n\
    \            var m27 = arr(l1(25).toLong).toLong\n            var m28 = arr(l1(26).toLong).toLong\n\
    \            var m29 = arr(l1(27).toLong).toLong\n            var m30 = arr(l1(28).toLong).toLong\n\
    \            var m31 = arr(l1(29).toLong).toLong\n            var m32 = arr(l1(30).toLong).toLong\n\
    \            var m33 = arr(l1(31).toLong).toLong\n            var m34 = arr(l1(32).toLong).toLong\n\
    \            var m35 = arr(l1(33).toLong).toLong\n            var m36 = arr(l1(34).toLong).toLong\n\
    \            var m37 = arr(l1(35).toLong).to\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp1mmwjo7x.scala:73:0 ----------------------------\e\
    [0m\e[0m\n\e[31m73 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp1mmwjo7x.scala:21:34\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m            \e[33mval\e[0m\
    \ \e[36mj\e[0m = (len + i - \e[31m1\e[0m) \\ \e[31m2\e[0m\n\e[31m\e[31m   |\e\
    [0m                    ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                 \
    \   value \\ is not a member of Int\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmp1mmwjo7x.scala:24:31 --------------------\e[0m\e[0m\n\e[31m24 |\e[0m\
    \            \e[33mvar\e[0m \e[36mm2\e[0m = arr(l1(\e[31m0\e[0m).toLong).toLong\n\
    \e[31m\e[31m   |\e[0m                         ^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                         Found:    Long\n\e[31m   |\e[0m                  \
    \       Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp1mmwjo7x.scala:25:31\
    \ --------------------\e[0m\e[0m\n\e[31m25 |\e[0m            \e[33mvar\e[0m \e\
    [36mm3\e[0m = arr(l1(\e[31m1\e[0m).toLong).toLong\n\e[31m\e[31m   |\e[0m     \
    \                    ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                      \
    \   Found:    Long\n\e[31m   |\e[0m                         Required: Int\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp1mmwjo7x.scala:26:31\
    \ --------------------\e[0m\e[0m\n\e[31m26 |\e[0m            \e[33mvar\e[0m \e\
    [36mm4\e[0m = arr(l1(\e[31m2\e[0m).toLong).toLong\n\e[31m\e[31m   |\e[0m     \
    \                    ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                      \
    \   Found:    Long\n\e[31m   |\e[0m                         Required: Int\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp1mmwjo7x.scala:27:31\
    \ --------------------\e[0m\e[0m\n\e[31m27 |\e[0m            \e[33mvar\e[0m \e\
    [36mm5\e[0m = arr(l1(\e[31m3\e[0m).toLong).toLong\n\e[31m\e[31m   |\e[0m     \
    \                    ^^^^^^^^^^^^\e[0m\n\e[3"
  stdout: ''
  timestamp: 1660010507
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val minChange = arr.foldLeft(0) {\n            (i, elem)\
    \ => {\n                if (elem < i.toLong) {\n                    i.toLong\n\
    \                } else {\n                    i\n                }\n        \
    \    }\n        }\n        minChange\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpu8hkx4q3.scala:18:22\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m                    i.toLong\n\
    \e[31m\e[31m   |\e[0m                    ^^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \              Found:    Long\n\e[31m   |\e[0m                    Required: Int\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010503
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val lv = arr.toList.reverse\n        if(lv.tail.forall(_.toLong\
    \ == lv.head.toLong)) 0L else lv.head + smallestChange(lv.tail)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpbw_1t7su.scala:19)\n\tat Problem.main(tmpbw_1t7su.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010505
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        // sort the list in descending order\n        val sorted_arr\
    \ = arr.sortBy(-_)\n        var i : Int = 0\n        var j : Int = 1\n       \
    \ // check even number\n        while (i < arr.length) {\n            if (sorted_arr(i)\
    \ == sorted_arr(j)) {\n                i += 1\n                j += 1\n      \
    \      } else {\n                if (sorted_arr(i) < sorted_arr(j)) {\n      \
    \              i += 1\n                } else {\n                    j += 1\n\
    \                }\n            }\n        }\n        return j\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 8\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.smallestChange(tmp7nn4kbeb.scala:21)\n\tat Problem$.main(tmp7nn4kbeb.scala:35)\n\
    \tat Problem.main(tmp7nn4kbeb.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010505
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val len = arr.length\n        var i = 0\n        var count\
    \ = 0\n        var minimum = 0L\n        while (i < len) {\n            var last\
    \ = i + 1\n            while (last < len) {\n                if (arr(i) != arr(last))\
    \ {\n                    val temp = arr(i)\n                    arr(i) = arr(last)\n\
    \                    arr(last) = temp\n                    last = i + 1\n    \
    \            } else {\n                    last += 1\n                }\n    \
    \            i += 1\n            }\n            count += 1\n            if (count\
    \ < minimum) {\n                minimum = count\n            }\n        }\n  \
    \      return minimum\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpp2dzrt8t.scala:24:20 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m                    arr(i) = arr(last)\n\e[31m\e[31m\
    \   |\e[0m                    ^^^\e[0m\n\e[31m   |\e[0m  value update is not a\
    \ member of List[Long] - did you mean arr.updated?\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmpp2dzrt8t.scala:25:20 ------------------------\e[0m\e[0m\n\
    \e[31m25 |\e[0m                    arr(last) = temp\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^\e[0m\n\e[31m   |\e[0m  value update is not a member of List[Long]\
    \ - did you mean arr.updated?\n2 errors found\n"
  stdout: ''
  timestamp: 1660010504
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        arr.foldLeft(0){\n            (acc:Long, i:Long, list:List[Long])\
    \ => {\n                if (list.isEmpty || list.isDefined && list.head != i)\
    \ {\n                    acc += 1\n                }\n                else {\n\
    \                    acc += list.size - 1\n                }\n            }\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpmv8745oz.scala:17:41 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m                \e[33mif\e[0m (list.isEmpty || list.isDefined\
    \ && list.head != i) {\n\e[31m\e[31m   |\e[0m                                \
    \    ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue isDefined is not a member of List[Long]\
    \ - did you mean list.isDefinedAt?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpmv8745oz.scala:18:24\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m                    acc +=\
    \ \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m                    ^^^^^^\e[0m\n\e[31m \
    \  |\e[0m                 value += is not a member of Long - did you mean acc.!=?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpmv8745oz.scala:21:24 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m                    acc += list.size - \e[31m1\e[0m\n\
    \e[31m\e[31m   |\e[0m                    ^^^^^^\e[0m\n\e[31m   |\e[0m        \
    \         value += is not a member of Long - did you mean acc.!=?\n3 errors found\n"
  stdout: ''
  timestamp: 1660010503
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        if(arr.isEmpty) 0\n        else arr.reverse.diff(arr).length\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp3ikagx17.scala:19)\n\tat Problem.main(tmp3ikagx17.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010504
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        var ans = Long.MaxValue\n        arr.foreach { x =>\n  \
    \          if (x == arr.last) ans = x\n            else {\n                if\
    \ (x % 2 == 0) ans = Math.min(ans, x - 1)\n                else {\n          \
    \          if (x % 3 == 0) ans = Math.min(ans, x - 3)\n                    else\
    \ {\n                        if (x % 5 == 0) ans = Math.min(ans, x - 5)\n    \
    \                    else ans = Math.min(ans, x - 2)\n                    }\n\
    \                }\n            }\n        }\n        ans.toLong\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpx5z6grhk.scala:32)\n\tat Problem.main(tmpx5z6grhk.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010504
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.reverse\n        val n = arr.size\n      \
    \  val min = n*(n+1)/2\n        val max = arr.last\n        for (i <- 1 to max)\
    \ {\n            val sublist = arr(i-1) ++ arr(i) ++ arr(i+1)\n            if\
    \ (sublist.equals(reverse(sublist)))\n                return i\n        }\n  \
    \      return 0\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpry4t46nj.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.reverse\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660010500
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val changed = arr.filter(_ < 0).length\n        val unchanged\
    \ = arr.filter(_ > 0).length\n        if (unchanged == 0) {\n            0\n \
    \       } else if (changed < unchanged) {\n            changed + 1\n        }\
    \ else {\n            1\n        }\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp8_8kttbe.scala:26)\n\tat Problem.main(tmp8_8kttbe.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010505
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val length = arr.length\n\
    \        var index = 0\n        var min = 0\n        var max = length - 1\n  \
    \      while(min < max) {\n            val mid = (min + max) / 2\n           \
    \ val leftArr = arr.take(mid)\n            val rightArr = arr.drop(mid)\n    \
    \        if(isPalindromic(leftArr) && isPalindromic(rightArr))\n             \
    \   min = mid\n            else max = mid\n        }\n        min\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp03hthjdq.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp03hthjdq.scala:24:15 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m            \e[33mif\e[0m(isPalindromic(leftArr) && isPalindromic(rightArr))\n\
    \e[31m\e[31m   |\e[0m               ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \         Not found: isPalindromic\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010500
- exit_code: -1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        // O(N^2)\n        def isPalindromic(arr : List[Long], i\
    \ : Int, j : Int) : Boolean = arr.take(i).reverse == arr.drop(j)\n        def\
    \ solve(arr : List[Long], i : Int, j : Int, n : Long) : Long = {\n           \
    \ if (i == j) n\n            else if (isPalindromic(arr, i, j)) solve(arr, i +\
    \ 1, j - 1, n + 2)\n            else solve(arr, i, j, n)\n        }\n        solve(arr,\
    \ 0, arr.size - 1, 0)\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1660010507
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.sort\n        var max = 0\n        var min\
    \ = 1000\n        var counter = 0\n        for ( i <- 0 until arr.length-1 ) {\n\
    \            if (arr(i) != arr(arr.length-i-1) )\n            {\n            \
    \    max = arr.length\n                min = i\n                counter = 0\n\
    \            }\n            else\n            {\n                counter += 1\n\
    \            }\n        }\n        max = arr.length\n        min = counter\n \
    \       println(max)\n        println(min)\n        println(counter)\n       \
    \ return min\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpp1yyczce.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sort\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660010500
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        var min: Long = 0\n        var max: Long = 0\n\n       \
    \ var i = arr.length - 1\n        var j = arr.length - 1\n\n        while (i >=\
    \ 0) {\n            while (arr(i) != arr(j)) {\n                j -= 1\n     \
    \       }\n\n            if (arr(i) < arr(j)) {\n                min = i + 1\n\
    \            } else {\n                max = j\n            }\n\n            i\
    \ -= 1\n            j -= 1\n        }\n\n        min + (max - min + 1) / 2\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmplvhb8i7w.scala:39)\n\tat Problem.main(tmplvhb8i7w.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010505
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        if (arr.size <= 1) {\n            return 0\n        }\n\
    \        var l = arr(0)\n        var r = arr(arr.size - 1)\n\n        while(l\
    \ * 10 + r * 10 < arr.size) {\n            var temp = l * 10 + r * 10\n      \
    \      l = arr(temp % arr.size)\n            r = arr(temp / arr.size)\n      \
    \  }\n        r += 1\n\n        if (l * 10 == r * 10) {\n            var l2 =\
    \ l - 1\n            var r2 = r + 1\n\n            while(l2 * 10 + r2 * 10 < arr.size)\
    \ {\n                var temp2 = l2 * 10 + r2 * 10\n                l2 = arr(temp2\
    \ % arr.size)\n                r2 = arr(temp2 / arr.size)\n            }\n   \
    \         r2 += 1\n            l2 = l - r2\n            while(l2 * 10 + r2 * 10\
    \ < arr.size) {\n                var temp3 = l2 * 10 + r2 * 10\n             \
    \   l2 = arr(temp3 % arr.size)\n                r2 = arr(temp3 / arr.size)\n \
    \           }\n            l += l2 + 1\n        }\n        if (l * 10 > r * 10)\
    \ {\n            var l2 = l + 1\n            var r2 = r - 1\n\n            while(l2\
    \ * 10 + r2 * 10 < arr.size) {\n                var temp2 = l2 * 10 + r2 * 10\n\
    \                l2 = arr(temp2 % arr.size)\n                r2 = arr(temp2 /\
    \ arr.size)\n            }\n            r2 -= 1\n            l2 = l + r2\n   \
    \         while(l2 * 10 + r2 * 10 < arr.size) {\n                var temp3 = l2\
    \ * 10 + r2 * 10\n                l2 = arr(temp3 % arr.size)\n               \
    \ r2 = arr(temp3 / arr.size)\n            }\n            r += r2 - 1\n       \
    \ }\n        val c = l - r\n        c + 1\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp62vkgqp7.scala:23:20\
    \ --------------------\e[0m\e[0m\n\e[31m23 |\e[0m            l = arr(temp % arr.size)\n\
    \e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                    Found:    Long\n\e[31m   |\e[0m                    Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp62vkgqp7.scala:24:20\
    \ --------------------\e[0m\e[0m\n\e[31m24 |\e[0m            r = arr(temp / arr.size)\n\
    \e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                    Found:    Long\n\e[31m   |\e[0m                    Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp62vkgqp7.scala:34:25\
    \ --------------------\e[0m\e[0m\n\e[31m34 |\e[0m                l2 = arr(temp2\
    \ % arr.size)\n\e[31m\e[31m   |\e[0m                         ^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                         Found:    Long\n\e[31m   |\e[0m \
    \                        Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmp62vkgqp7.scala:35:25 --------------------\e[0m\e\
    [0m\n\e[31m35 |\e[0m                r2 = arr(temp2 / arr.size)\n\e[31m\e[31m \
    \  |\e[0m                         ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                    Found:    Long\n\e[31m   |\e[0m                         Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp62vkgqp7.scala:41:25\
    \ --------------------\e[0m\e[0m\n\e[31m41 |\e[0m                l2 = arr(temp3\
    \ % arr.size)\n\e[31m\e[31m   |\e[0m                         ^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                         Found:    Long\n\e[31m   |\e[0m \
    \                        Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatc"
  stdout: ''
  timestamp: 1660010505
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val min = (arr.length / 2).toInt\n        var i = min +\
    \ 1\n        val max = (arr.length / 2).toInt\n        var j = max - 1\n     \
    \   while(i < j){\n            var n = 0\n            if(arr.length % 2 == 0){\n\
    \                n = arr(i).toLong\n            }\n            else{\n       \
    \         n = arr(j).toLong\n            }\n            var x = n\n          \
    \  while(x < 0){\n                x = x * 10 + 1\n            }\n            var\
    \ y = x\n            while(y > 0){\n                y = y / 10\n            }\n\
    \            if(y == x){\n                i += 1\n                j --\n     \
    \       }\n            else{\n                j --\n            }\n        }\n\
    \        if (arr.length % 2 != 0){\n            return arr(min).toLong\n     \
    \   }\n        else{\n            return arr(max).toLong\n        }\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp2tcnczn3.scala:37:20 ---------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m                j --\n\e[31m\e[31m   |\e[0m         \
    \           ^\e[0m\n\e[31m   |\e[0m                    expression expected but\
    \ \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp2tcnczn3.scala:40:20\
    \ ---------------------------\e[0m\e[0m\n\e[31m40 |\e[0m                j --\n\
    \e[31m\e[31m   |\e[0m                    ^\e[0m\n\e[31m   |\e[0m             \
    \       expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmp2tcnczn3.scala:22:27 --------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m                n = arr(i).toLong\n\e[31m\e[31m   |\e\
    [0m                    ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                   \
    \ Found:    Long\n\e[31m   |\e[0m                    Required: Int\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp2tcnczn3.scala:25:27 --------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m                n = arr(j).toLong\n\e[31m\e[31m   |\e\
    [0m                    ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                   \
    \ Found:    Long\n\e[31m   |\e[0m                    Required: Int\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1660010503
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val count = arr.filter(x => x % 2 == 0).length\n       \
    \ val n = arr.length\n\n        var j = n / 2\n\n        var change = 0\n\n  \
    \      while (j <= n) {\n            val k = j + j\n            var minDiff =\
    \ math.max(math.abs(arr(k) - arr(n - j)), math.abs(arr(n + j) - arr(n - j)))\n\
    \n            for (i = 1 until count) {\n                val d = math.abs(arr(k)\
    \ - arr(n - i))\n                if (d == minDiff) break\n                minDiff\
    \ = math.max(d, minDiff)\n            }\n\n            change += 1\n         \
    \   j += minDiff\n        }\n        change\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpyphbggfq.scala:26:19 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m            \e[33mfor\e[0m (i = \e[31m1\e[0m until count)\
    \ {\n\e[31m\e[31m   |\e[0m                   ^\e[0m\n\e[31m   |\e[0m         \
    \          ')' expected, but '=' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpyphbggfq.scala:26:36\
    \ ---------------------------\e[0m\e[0m\n\e[31m26 |\e[0m            \e[33mfor\e\
    [0m (i = \e[31m1\e[0m until count) {\n\e[31m\e[31m   |\e[0m                  \
    \                  ^\e[0m\n\e[31m   |\e[0m                                   \
    \ '<-' expected, but '{' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpyphbggfq.scala:33:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m33 |\e[0m            j += minDiff\n\
    \e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'<-' expected, but 'end of statement'\
    \ found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpyphbggfq.scala:34:8 ----------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        }\n\e[31m\e[31m   |\e[0m        ^\e[0m\n\e[31m\
    \   |\e[0m        '<-' expected, but '}' found\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmpyphbggfq.scala:30:13 ------------------------\e[0m\e[0m\n\e[31m30\
    \ |\e[0m            }\n\e[31m\e[31m   |\e[0m             ^\e[0m\n\e[31m   |\e\
    [0mvalue foreach is not a member of Null, but could be made available as an extension\
    \ method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might\
    \ fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import Option.option2Iterable\n\
    \e[31m   |\e[0m  import collection.LazyZip2.lazyZip2ToIterable\n\e[31m   |\e[0m\
    \  import collection.LazyZip3.lazyZip3ToIterable\n\e[31m   |\e[0m  import collection.LazyZip4.lazyZip4ToIterable\n\
    \e[31m   |\e[0m  import collection.convert.ImplicitConversions.list asScalaBuffer\n\
    \e[31m   |\e[0m  import collection.convert.ImplicitConversions.properties AsScalaMap\n\
    \e[31m   |\e[0m  import collection.convert.ImplicitConversions.enumeration AsScalaIterator\n\
    \e[31m   |\e[0m  import collection.convert.ImplicitConversions.iterator asScala\n\
    \e[31m   |\e[0m  import collection.convert.ImplicitConversions.map AsScalaConcurrentMap\n\
    \e[31m   |\e[0m  import collection.convert.Impl"
  stdout: ''
  timestamp: 1660010504
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        arr.filter( l => l==arr.takeWhile( a=>a==arr.last).reverse\
    \ ).size\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpgigmdi1o.scala:15:25 -----------------------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        arr.filter( \e[36ml\e[0m => l==arr.takeWhile(\
    \ \e[36ma\e[0m=>a==arr.last).reverse ).size\n\e[31m\e[31m   |\e[0m           \
    \              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \    Values of types Long and List[Long] cannot be compared with == or !=\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660010503
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.sort\n        var i = 0\n        var count\
    \ = 0\n        while(i < arr.length) {\n            if(arr(i) == arr[arr.length\
    \ - 1 - i])\n                count += 1\n            else { \n               \
    \ if(count == 1)\n                    return arr(i)\n                count = 0\n\
    \            }\n            i += 1\n        }\n        arr.length\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpmqtj2ys4.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sort\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660010500
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.size\n        if (n == 0) 0\n        else if\
    \ (n == 1) arr.head\n        else arr(n / 2)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpmr2yazw1.scala:22)\n\tat Problem.main(tmpmr2yazw1.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010504
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        if(arr.length < 2) 0\n        else {\n            var min\
    \ = arr.head\n            var minIndex = 1\n\n            val middle = arr.length\
    \ / 2\n\n            for (i <- 1 until middle) {\n                var temp = arr.head\n\
    \                var tempIndex = i\n\n                val currentMin = temp\n\
    \                val currentMinIndex = tempIndex\n\n                if(tempIndex\
    \ < middle - 1 && currentMin == arr.last){\n                    temp = arr.head\n\
    \                    tempIndex = 1\n                    val currentMin = temp\n\
    \                    val currentMinIndex = tempIndex\n                }\n\n  \
    \              if(tempIndex == middle){\n                    val currentMin =\
    \ temp\n                    val currentMinIndex = tempIndex\n                }\n\
    \n                for(tempIndex <- 1 until middle){\n                    if(tempIndex\
    \ < middle){\n                        val temp = arr.last\n                  \
    \      val tempIndex = middle\n                        if(tempIndex == middle){\n\
    \                            val temp = arr.last\n                           \
    \ val tempIndex = middle\n                        }\n\n                      \
    \  if(currentMin != arr.last){\n                            min = currentMin\n\
    \                            minIndex = currentMinIndex\n                    \
    \    }\n\n                        val currentMin = temp\n                    \
    \    val currentMinIndex = tempIndex\n                    }\n                }\n\
    \            }\n            minIndex\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E039] Reference Error: /tmp/tmp_nrnv_xa.scala:52:39 ------------------------\e\
    [0m\e[0m\n\e[31m52 |\e[0m                            minIndex = currentMinIndex\n\
    \e[31m\e[31m   |\e[0m                                       ^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mcurrentMinIndex is a forward reference extending over the\
    \ definition of currentMin\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010501
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.reverse\n        val arrSize = arr.length\n\
    \        var i = 0\n        var min = Integer.MAX_VALUE\n        var minIdx =\
    \ 0\n        for (i <- 0 until arrSize-1) {\n            val idx = i+1\n     \
    \       val value = arr(idx)\n            if (value <= arr(arrSize-1)) {\n   \
    \             if (min == Integer.MAX_VALUE || value < min) {\n               \
    \     min = value\n                    minIdx = idx\n                }\n     \
    \       }\n        }\n        minIdx\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp2g3ojg3p.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.reverse\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660010507
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val len = arr.length\n        val arr = arr ++ ArrayBuffer(arr.last,\
    \ arr(0))\n        var index = 0\n        var left = 0\n        var right = (arr.length\
    \ - 1L)\n        var changes = 0\n        var isPalindromic = true\n        while\
    \ (left < right) {\n            if (arr(left) == arr(right)) {\n             \
    \   index = index + 1\n                left = left + 1\n                right\
    \ = right - 1\n            } else {\n                if (arr(left) != arr(right))\
    \ {\n                    isPalindromic = false\n                    break\n  \
    \              }\n                left = left + 1\n                right = right\
    \ - 1\n            }\n        }\n        if (isPalindromic) {\n            changes\
    \ = left * 2\n        }\n        return changes\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp5eeczw6g.scala:16:18 ---------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr ++ ArrayBuffer(arr.last,\
    \ arr(\e[31m0\e[0m))\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m  \
    \ |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp5eeczw6g.scala:30:20\
    \ ------------------------\e[0m\e[0m\n\e[31m30 |\e[0m                    break\n\
    \e[31m\e[31m   |\e[0m                    ^^^^^\e[0m\n\e[31m   |\e[0m         \
    \           Not found: break\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010507
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        var arr = arr.sortWith( (x,y) => x-y)\n        var smallestChange\
    \ = 0l\n        var p = 0\n        while(p < arr.length) {\n            if (arr(p)\
    \ == arr(arr.length - p - 1)) {\n                smallestChange = smallestChange+1\n\
    \            } else {\n                break\n            }\n            p+=1\n\
    \        }\n        smallestChange\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpqplfn0a4.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mvar\e[0m \e[36marr\e[0m = arr.sortWith(\
    \ (\e[36mx\e[0m,\e[36my\e[0m) => x-y)\n\e[31m\e[31m   |\e[0m                 \
    \ ^\e[0m\n\e[31m   |\e[0m                  Recursive \e[33mvariable\e[0m \e[35marr\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpqplfn0a4.scala:22:16\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m                break\n\e\
    [31m\e[31m   |\e[0m                ^^^^^\e[0m\n\e[31m   |\e[0m               \
    \ Not found: break\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010507
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val changes = arr.scanLeft(1l){(a,b)=>\n            val\
    \ last = a\n            val c = b\n            if(last>c || (last==c && a>b))\
    \ a+1 else a\n        }\n        changes.headOption.getOrElse(0l)\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpdpz1hind.scala:23)\n\tat Problem.main(tmpdpz1hind.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010512
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        // Write your code here\n        val s = arr.reverse\n \
    \       val len = s.length\n        val arr1 = Array.fill(len)(0)\n        var\
    \ count = 1\n        for(i <- 0 until len) {\n            if(i != 0) {\n     \
    \           if(s(i) != s(i - 1)) {\n                    count += 1\n         \
    \       }\n                arr1(i - 1) = arr(i)\n            }\n        }\n  \
    \      return count\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpzdxrvblh.scala:25:33\
    \ --------------------\e[0m\e[0m\n\e[31m25 |\e[0m                arr1(i - \e[31m1\e\
    [0m) = arr(i)\n\e[31m\e[31m   |\e[0m                              ^^^^^^\e[0m\n\
    \e[31m   |\e[0m                              Found:    Long\n\e[31m   |\e[0m \
    \                             Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010511
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        var count = 1\n        val set = mutable.HashSet[Long]()\n\
    \        var smallest = 0L\n        for (i<-arr.indices){\n            if (arr.get\
    \ (i) == arr.get(i + 1) && !set.add(i)) {\n                count += 1\n      \
    \          if (count > smallest || smallest == 0L) {\n                    smallest\
    \ = count\n                }\n            }\n        }\n        smallest\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpybuhh_tl.scala:16:18 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mset\e[0m = mutable.HashSet[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                  ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                  Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpybuhh_tl.scala:19:20 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m            \e[33mif\e[0m (arr.get (i) == arr.get(i +\
    \ \e[31m1\e[0m) && !set.add(i)) {\n\e[31m\e[31m   |\e[0m                ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m         value get is not a member of List[Long] - did you\
    \ mean arr.seq?\n2 errors found\n"
  stdout: ''
  timestamp: 1660010511
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.size\n        val max = Long.MinValue\n    \
    \    var i = 0\n        while (i < n) {\n            var cur = arr(i)\n      \
    \      while (i < n) {\n                val next  = arr(i+1)\n               \
    \ val diff  = cur - next\n                if (diff > max)\n                  \
    \  max = diff\n                i += 2\n            }\n            i += 1\n   \
    \     }\n        max + (if (arr.size == n && arr.head < arr.last) 1 else 0)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmp9ixaidmg.scala:24:24 -----------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m                    max = diff\n\e[31m\e[31m   |\e[0m\
    \                    ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                    Reassignment\
    \ to val max\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010508
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        var left = 0\n        var right = arr.length - 1\n     \
    \   while(left < right) {\n            var m = math.min(left, right)\n       \
    \     var j = m\n            while(j > left && arr(j - 1) < arr(m)) {\n      \
    \          j -= 1\n            }\n            var k = m\n            while(k >\
    \ right && arr(k - 1) > arr(m)) {\n                k += 1\n            }\n   \
    \         arr(m) <- arr(m)\n            left <- j + 1\n            right <- k\
    \ - 1\n        }\n        arr.takeRight(arr.length).length\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmposgkeaj4.scala:27:19 -----------------------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m            arr(m) <- arr(m)\n\e[31m\e[31m   |\e[0m \
    \                  ^^\e[0m\n\e[31m   |\e[0m                   end of statement\
    \ expected but '<-' found\n\e[31m\e[31m-- Error: /tmp/tmposgkeaj4.scala:28:17\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m28 |\e[0m       \
    \     left <- j + \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m                 ^^\e[0m\n\
    \e[31m   |\e[0m                 end of statement expected but '<-' found\n\e[31m\e\
    [31m-- Error: /tmp/tmposgkeaj4.scala:29:18 -----------------------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m            right <- k - \e[31m1\e[0m\n\e[31m\e[31m \
    \  |\e[0m                  ^^\e[0m\n\e[31m   |\e[0m                  end of statement\
    \ expected but '<-' found\n3 errors found\n"
  stdout: ''
  timestamp: 1660010510
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        var i = 0\n        var j = 0\n        var ans = 0\n    \
    \    while(i < arr.size) {\n            while(j < arr.size && arr(i) == arr(j))\
    \ {\n                j += 1\n            }\n            if(j == arr.size)\n  \
    \              ans += 1\n            j = 0\n            i += 1\n        }\n  \
    \      if(j == arr.size)\n            ans += 1\n        ans\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmphoqza6xg.scala:32)\n\tat Problem.main(tmphoqza6xg.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010515
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        var min_changes = 1\n        val arr = arr.sortBy(x => x)\n\
    \        val len = arr.size\n        for (i<- 0 until len) {\n            val\
    \ low = arr(i)\n            val high = arr[len - i - 1]\n            if (high\
    \ < low) {\n                min_changes = min_changes + 1\n                val\
    \ new_arr = arr.reverse\n                val len = new_arr.size\n            \
    \    for (j <- 0 until len) {\n                    if (new_arr(j) < low) {\n \
    \                       val tmp = new_arr(j)\n                        new_arr(j)\
    \ = new_arr(len - j)\n                        new_arr(len - j) = tmp\n       \
    \             }\n                }\n                arr = new_arr\n          \
    \  } else {\n                break\n            }\n        }\n        min_changes\
    \ == len ? 0l : min_changes\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpgiph3p9o.scala:16:18 ---------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(\e\
    [36mx\e[0m => x)\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e\
    [0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpgiph3p9o.scala:20:35\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m            \e[33mval\e[0m\
    \ \e[36mhigh\e[0m = arr[\e[35mlen\e[0m \e[35m-\e[0m \e[35mi\e[0m \e[35m-\e[0m\
    \ \e[31m1\e[0m]\n\e[31m\e[31m   |\e[0m                                   ^\e[0m\n\
    \e[31m   |\e[0m                                   Not found: type -\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E052] Type Error: /tmp/tmpgiph3p9o.scala:32:20 -----------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m                arr = new_arr\n\e[31m\e[31m   |\e[0m\
    \                ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                Reassignment\
    \ to val arr\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpgiph3p9o.scala:34:16\
    \ ------------------------\e[0m\e[0m\n\e[31m34 |\e[0m                break\n\e\
    [31m\e[31m   |\e[0m                ^^^^^\e[0m\n\e[31m   |\e[0m               \
    \ Not found: break\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpgiph3p9o.scala:37:34\
    \ ------------------------\e[0m\e[0m\n\e[31m37 |\e[0m        min_changes == len\
    \ ? \e[31m0l\e[0m : \e[35mmin_changes\e[0m\n\e[31m\e[31m   |\e[0m            \
    \                      ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                     \
    \             Not found: type min_changes\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n5 errors found\n"
  stdout: ''
  timestamp: 1660010510
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n      val minSize = 1\n      val rev = arr.init.reverse\n      val\
    \ len = arr.length\n      var current = 0\n\n      while (current < len && current\
    \ < minSize) {\n        current += 1\n        if (rev.get(current) != rev.get(len\
    \ - 1)) {\n          minSize = current + 1\n        }\n      }\n\n      return\
    \ minSize\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpyb48xjek.scala:22:16 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mif\e[0m (rev.get(current) != rev.get(len\
    \ - \e[31m1\e[0m)) {\n\e[31m\e[31m   |\e[0m            ^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m         value get is not a member of List[Long] - did you mean rev.seq?\n\
    \e[31m\e[31m-- [E052] Type Error: /tmp/tmpyb48xjek.scala:23:18 -----------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m          minSize = current + \e[31m1\e[0m\n\e[31m\e\
    [31m   |\e[0m          ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m          Reassignment\
    \ to val minSize\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010513
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n      val minChange = arr.size\n      val currentLength = (arr.size)\n\
    \      val arrCopy = arr.toList\n      val arr2 = arrCopy.reverse\n      val list\
    \ = new mutable.ListBuffer[Long]()\n      val list2 = new mutable.ListBuffer[Long]()\n\
    \      var c = 0\n      while (c < currentLength && c < minChange) {\n       \
    \ if (arrCopy(c) != arr2(c)) {\n          list(c) = arrCopy(c)\n        }\n  \
    \      list2 += arrCopy(c)\n        c += 1\n      }\n      val p1 = new mutable.ListBuffer[Long]()\n\
    \      val p2 = new mutable.ListBuffer[Long]()\n      val c = 0\n      while (c\
    \ < currentLength) {\n        if (list(c) != list2(c)) {\n          if (list(c)\
    \ != 0) {\n            p1.append(list(c))\n          }\n          if (list2(c)\
    \ != 0) {\n            p2.append(list2(c))\n          }\n        }\n        c\
    \ += 1\n      }\n      if (p1.length < p2.length) {\n        minChange = p1.length\n\
    \      } else if (p1.length > p2.length) {\n        minChange = p2.length\n  \
    \    }\n      minChange\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpk4x72kub.scala:31:10 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m      \e[33mval\e[0m \e[36mc\e[0m = \e[31m0\e[0m\n\e\
    [31m\e[31m   |\e[0m      ^^^^^^^^^\e[0m\n\e[31m   |\e[0mc is already defined as\
    \ \e[33mvariable\e[0m \e[35mc\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpk4x72kub.scala:19:21 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m      \e[33mval\e[0m \e[36mlist\e[0m = \e[33mnew\e[0m\
    \ mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m               \
    \      ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found: mutable\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpk4x72kub.scala:20:22\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m      \e[33mval\e[0m \e[36mlist2\e\
    [0m = \e[33mnew\e[0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e\
    [0m                      ^^^^^^^\e[0m\n\e[31m   |\e[0m                      Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpk4x72kub.scala:29:19\
    \ ------------------------\e[0m\e[0m\n\e[31m29 |\e[0m      \e[33mval\e[0m \e[36mp1\e\
    [0m = \e[33mnew\e[0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e\
    [0m                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                   Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpk4x72kub.scala:30:19\
    \ ------------------------\e[0m\e[0m\n\e[31m30 |\e[0m      \e[33mval\e[0m \e[36mp2\e\
    [0m = \e[33mnew\e[0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e\
    [0m                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                   Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmpk4x72kub.scala:44:18\
    \ -----------------------------\e[0m\e[0m\n\e[31m44 |\e[0m        minChang"
  stdout: ''
  timestamp: 1660010511
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        var cur = arr(0)\n        var left = 0\n        var right\
    \ = 0\n        while (left < right) {\n            cur = math.min(cur, arr[right])\n\
    \            right -= 1\n            cur = math.min(cur, arr[left])\n        \
    \    left += 1\n        }\n        cur\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpae1cxvji.scala:19:36 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m            cur = math.min(cur, arr[\e[35mright\e[0m])\n\
    \e[31m\e[31m   |\e[0m                                    ^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                                    Not found: type right\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpae1cxvji.scala:21:36 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m            cur = math.min(cur, arr[\e[35mleft\e[0m])\n\
    \e[31m\e[31m   |\e[0m                                    ^^^^\e[0m\n\e[31m   |\e\
    [0m                                    Not found: type left\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660010511
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val size = arr.size\n        val largest = arr.max\n   \
    \     var count = 0\n        var previous = 0\n        var next = 0\n        for\
    \ (i<-0 until size) {\n            while (next < size) {\n                val\
    \ currentCount = arr[next] - arr[previous]\n                if (currentCount ==\
    \ 1 && current != largest) {\n                    count += currentCount\n    \
    \                break\n                }\n                next += 1\n       \
    \     }\n            previous = next\n            next = 0\n        }\n      \
    \  count * largest\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpi_jnc0w9.scala:22:39 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m                \e[33mval\e[0m \e[36mcurrentCount\e[0m\
    \ = arr[\e[35mnext\e[0m] - arr[\e[35mprevious\e[0m]\n\e[31m\e[31m   |\e[0m   \
    \                                    ^^^^\e[0m\n\e[31m   |\e[0m              \
    \                         Not found: type next\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpi_jnc0w9.scala:25:20 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m                    break\n\e[31m\e[31m   |\e[0m    \
    \                ^^^^^\e[0m\n\e[31m   |\e[0m                    Not found: break\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010512
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        if (arr.length == 0) {\n            return 0;\n        }\n\
    \        val startIndex = arr.head\n        val reversedArr = arr.reverse\n\n\
    \        if (reversedArr.head != arr.last) throw new ArithmeticException(\"Lists\
    \ are not equal lengths\")\n        var totalChanges = 0\n        var changeIndex\
    \ = 0\n        var startIndexInReverse = 0\n\n        while (reversedArr.nonEmpty)\
    \ {\n            val currentValue = reversedArr.head\n            reversedArr\
    \ = reversedArr.tail\n\n            // move forward\n            val nextValue\
    \ = reversedArr.head\n            reversedArr = reversedArr.tail\n           \
    \ val nextIndex = reversedArr.head\n            val nextIndexInReverse = reversedArr.last\n\
    \            val nextReversedValue = reversedArr.last\n            val nextReversedIndexInReverse\
    \ = reversedArr.last\n            val nextReversedValue = reversedArr.last\n \
    \           val nextReversedIndexInReverse = reversedArr.last\n            val\
    \ nextReversedValue = reversedArr.last\n            val nextReversedIndexInReverse\
    \ = reversedArr.last\n\n            if (currentValue == nextValue) {\n       \
    \         startIndexInReverse = reversedArr.head\n                changeIndex\
    \ = startIndexInReverse\n                totalChanges += 1\n            }\n\n\
    \            val indexOfNextValueInReverse = reversedArr.indexWhere(_ == nextValue)\n\
    \            val indexOfNextValueInReverse = indexOfNextValueInReverse.last\n\
    \            val indexOfNextValueInReverseInReverse = indexOfNextValueInReverse\
    \ - startIndexInReverse - 1\n\n            if (indexOfNextValueInReverseInReverse\
    \ == -1) {\n                val indexOfNextValueInReverseInReverseInReverse =\
    \ indexOfNextValueInReverse - startIndexInReverse\n                if (indexOfNextValueInReverseInReverseInReverse\
    \ == -1) {\n                    // Nothing to do here\n                } else\
    \ if (indexOfNextValueInReverseInReverseInReverse == 0) {\n                  \
    \  // move back one step\n                    reversedArr = reversedArr.tail\n\
    \                    val nextIndexInReverse = reversedArr.head\n             \
    \       val nextIndexInReverseInReverse = reversedArr.last\n                 \
    \   val nextReversedIndexInReverseInReverse = reversedArr.last\n             \
    \       val nextReversedIndexInReverseInReverseInReverse = reversedArr.last\n\
    \                    val nextReversedValue = reversedArr.last\n              \
    \      val nextReversedValueInReverse = reversedArr.last\n                   \
    \ val nextReversedValueInReverseInReverse = reversedArr.\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpreihle20.scala:66:4 ----------------------------\e\
    [0m\e[0m\n\e[31m66 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tmpreihle20.scala:79:0 ----------------------------\e[0m\e[0m\n\e[31m79\
    \ |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpreihle20.scala:37:16 ---------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m            \e[33mval\e[0m \e[36mnextReversedValue\e\
    [0m = reversedArr.last\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mnextReversedValue is already defined as \e[33mvalue\e[0m \e\
    [35mnextReversedValue\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpreihle20.scala:38:16 ---------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m            \e[33mval\e[0m \e[36mnextReversedIndexInReverse\e\
    [0m = reversedArr.last\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mnextReversedIndexInReverse is already defined as \e[33mvalue\e\
    [0m \e[35mnextReversedIndexInReverse\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpreihle20.scala:39:16 ---------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m            \e[33mval\e[0m \e[36mnextReversedValue\e\
    [0m = reversedArr.last\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mnextReversedValue is already defined as \e[33mvalue\e[0m \e\
    [35mnextReversedValue\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpreihle20.scala:40:16 ---------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m            \e[33mval\e[0m \e[36mnextReversedIndexInReverse\e\
    [0m = reversedArr.last\n\e[31m\e[31m   |\e[0m          "
  stdout: ''
  timestamp: 1660010514
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        def isPalindromic(arr : List[Long]) : Boolean = {\n    \
    \        if (arr.length == 0)\n                true\n            else if (arr.head\
    \ == arr.last)\n                isPalindromic(arr.tail)\n            else\n  \
    \              false\n        }\n        def removeElementToMakePalindromic(arr\
    \ : List[Long], removeFromEnd : Int) : List[Long] = {\n            if (arr.length\
    \ == 0)\n                arr\n            else if (arr.head == arr.last)\n   \
    \             removeElementToMakePalindromic(arr.tail, removeFromEnd)\n      \
    \      else if (isPalindromic(arr.tail))\n                removeElementToMakePalindromic(arr.tail,\
    \ (removeFromEnd + 1))\n            else\n                removeElementToMakePalindromic(arr.tail,\
    \ (removeFromEnd + 1))\n        }\n        val minPalindromic = arr.take(1).head\n\
    \        val palindromics = arr.filter(_ != minPalindromic).map(_ - minPalindromic).distinct\n\
    \        val maxPalindromic = arr.last\n        val palindromicsWithoutMin = removeElementToMakePalindromic(arr.filter(_\
    \ != minPalindromic), 1)\n        val palindromicsWithoutMax = removeElementToMakePalindromic(arr.filter(_\
    \ != maxPalindromic), 1)\n        if (arr.length == 0)\n            0\n      \
    \  else if (palindromics.length == 1)\n            palindromicsWithoutMin.sum\n\
    \        else if (palindromics.length == 2)\n            palindromicsWithoutMin.sum\
    \ + palindromicsWithoutMax.sum\n        else\n            smallestChange(palindromicsWithoutMin.sum\
    \ + smallestChange(palindromicsWithoutMax.sum))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpc9mw78y7.scala:45:71\
    \ --------------------\e[0m\e[0m\n\e[31m45 |\e[0m            smallestChange(palindromicsWithoutMin.sum\
    \ + smallestChange(palindromicsWithoutMax.sum))\n\e[31m\e[31m   |\e[0m       \
    \                                                                ^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                                    Found:\
    \    Long\n\e[31m   |\e[0m                                                   \
    \ Required: \e[1m\e[32mList\e[0m\e[1m\e[32m[\e[0mLong\e[1m\e[32m]\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010515
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.sorted\n        val len = arr.length\n   \
    \     var i = 0\n        var min = len\n        var j = len - 1\n        while(i\
    \ < j) {\n            val temp = arr(i)\n            arr(i) = arr(j)\n       \
    \     arr(j) = temp\n            i += 1\n            j -= 1\n        }\n     \
    \   val maxIndex = arr.lastIndexOf(0)\n        val maxElement = arr(maxIndex)\n\
    \        for(i <- 0 until maxIndex) {\n            val temp = arr(i)\n       \
    \     arr(i) = arr(maxIndex)\n            arr(maxIndex) = temp\n            val\
    \ curr = maxIndex - i\n            if(arr(curr) < arr(curr + 1)) {\n         \
    \       min = Math.min(min, curr + 1)\n            }\n        }\n        arr(maxIndex)\
    \ = 0l.toLong\n        min.toLong\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp44p8i0tv.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sorted\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660010512
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        var i = 0\n        val size = arr.size\n        val arr\
    \ = new Array[Long](size)\n        arr.clear()\n        while (i < size) {\n \
    \           arr(i) = arr(i).asInstanceOf[Long]\n            i += 1\n        }\n\
    \        val reversedArr = new Array[Long](size)\n        reversedArr.clear()\n\
    \        i = size - 1\n        while (i >= 0) {\n            reversedArr(i) =\
    \ arr(i).asInstanceOf[Long]\n            i -= 1\n        }\n        var changes\
    \ = 0\n        while (reversedArr.toList != arr.reverse.toList) {\n          \
    \  changes += 1\n            reversedArr.clear()\n            for (i = size -\
    \ 2; i >= 0; i -= 1) {\n                if (arr(i) != arr(i + 1)) {\n        \
    \            reversedArr(i) = arr(i)\n                }\n                else\
    \ {\n                    reversedArr(i) = arr(i + 1)\n                }\n    \
    \        }\n        }\n        changes\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmprkvsqt_q.scala:34:19 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m            \e[33mfor\e[0m (i = size - \e[31m2\e[0m;\
    \ i >= \e[31m0\e[0m; i -= \e[31m1\e[0m) {\n\e[31m\e[31m   |\e[0m             \
    \      ^\e[0m\n\e[31m   |\e[0m                   ')' expected, but '=' found\n\
    \e[31m\e[31m-- [E040] Syntax Error: /tmp/tmprkvsqt_q.scala:34:37 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m            \e[33mfor\e[0m (i = size - \e[31m2\e[0m;\
    \ i >= \e[31m0\e[0m; i -= \e[31m1\e[0m) {\n\e[31m\e[31m   |\e[0m             \
    \                        ^\e[0m\n\e[31m   |\e[0m                             \
    \        '<-' expected, but ';' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmprkvsqt_q.scala:34:45\
    \ ---------------------------\e[0m\e[0m\n\e[31m34 |\e[0m            \e[33mfor\e\
    [0m (i = size - \e[31m2\e[0m; i >= \e[31m0\e[0m; i -= \e[31m1\e[0m) {\n\e[31m\e\
    [31m   |\e[0m                                             ^\e[0m\n\e[31m   |\e\
    [0m                                            '<-' expected, but ')' found\n\e\
    [31m\e[31m-- [E045] Cyclic Error: /tmp/tmprkvsqt_q.scala:17:34 ---------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = \e[33mnew\e[0m\
    \ \e[35mArray\e[0m[\e[35mLong\e[0m](size)\n\e[31m\e[31m   |\e[0m             \
    \                     ^\e[0m\n\e[31m   |\e[0m                                \
    \  Recursive \e[33mvalue\e[0m \e[35msize\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmprkvsqt_q.scala:18:12 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        arr.clear()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m    value clear is not a member of Array[Long] - did you mean\
    \ arr.clone?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmprkvsqt_q.scala:24:20\
    \ ------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        reversedArr.clear()\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue clear\
    \ is not a member of Array[Long] - did you mean reversedArr.clone?\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmprkvsqt_q.scala:33:24 -----------------"
  stdout: ''
  timestamp: 1660010518
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val list = arr.toList\n        val stack = ListBuffer.empty[Long]\n\
    \        var result = 0\n        val reverseStack = ListBuffer.empty[Long]\n \
    \       val changed = new mutable.HashSet[Long]\n        def dfs(index : Int)\
    \ : Unit = {\n            if (index >= list.size) {\n                result +=\
    \ 1\n            } else {\n                val curr = list.getOrElse(index, 0)\n\
    \                if (curr % 2 == 0) stack.push(curr)\n                else if\
    \ (curr % 2 != 0) reverseStack.push(curr)\n                if (index == list.size\
    \ - 1) result += 1\n                else dfs(index + 1)\n                if (curr\
    \ % 2 == 0) stack.pop\n                else if (curr % 2 != 0) reverseStack.pop\n\
    \            }\n        }\n        dfs(0)\n        val isPalindromic = stack.toList\
    \ == reverseStack.toList\n        if (isPalindromic) result else 1\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpqmlz3xph.scala:19:26 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mchanged\e[0m = \e[33mnew\e\
    [0m mutable.HashSet[\e[35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                  \
    \        ^^^^^^^\e[0m\n\e[31m   |\e[0m                          Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpqmlz3xph.scala:24:32\
    \ ------------------------\e[0m\e[0m\n\e[31m24 |\e[0m                \e[33mval\e\
    [0m \e[36mcurr\e[0m = list.getOrElse(index, \e[31m0\e[0m)\n\e[31m\e[31m   |\e\
    [0m                           ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m           \
    \                value getOrElse is not a member of List[Long]\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpqmlz3xph.scala:25:41 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m                \e[33mif\e[0m (curr % \e[31m2\e[0m ==\
    \ \e[31m0\e[0m) stack.push(curr)\n\e[31m\e[31m   |\e[0m                      \
    \             ^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue push is not a member of scala.collection.mutable.ListBuffer[Long]\
    \ - did you mean stack.last?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpqmlz3xph.scala:26:53\
    \ ------------------------\e[0m\e[0m\n\e[31m26 |\e[0m                \e[33melse\e\
    [0m \e[33mif\e[0m (curr % \e[31m2\e[0m != \e[31m0\e[0m) reverseStack.push(curr)\n\
    \e[31m\e[31m   |\e[0m                                        ^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue push is not a member of scala.collection.mutable.ListBuffer[Long]\
    \ - did you mean reverseStack.last?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpqmlz3xph.scala:29:41\
    \ ------------------------\e[0m\e[0m\n\e[31m29 |\e[0m                \e[33mif\e\
    [0m (curr % \e[31m2\e[0m == \e[31m0\e[0m) stack.pop\n\e[31m\e[31m   |\e[0m   \
    \                                ^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue pop is not\
    \ a member of scala.collection.mutable.ListBuffer[Long] - did you mean stack.drop?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpqmlz3xph.scala:30:53 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m                \e[33melse\e[0m \e[33mif\e[0m (curr %\
    \ \e[3"
  stdout: ''
  timestamp: 1660010516
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        // Write your code here.\n        var min = -1\n       \
    \ var i = arr.length\n        while (i > 0) {\n            var current = arr[i\
    \ - 1] \n            var previous = arr[i]\n            var changes = 0\n    \
    \        if (current > previous)\n                changes = 1\n            while\
    \ (current != previous) {\n                previous = current\n              \
    \  current = arr[i - 1]\n                var i = i - changes\n            }\n\
    \            min = Math.min(min, changes)\n        }\n        min\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp0k9s431u.scala:19:32 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m            \e[33mvar\e[0m \e[36mcurrent\e[0m = arr[\e\
    [35mi\e[0m \e[35m-\e[0m \e[31m1\e[0m] \n\e[31m\e[31m   |\e[0m                \
    \                ^\e[0m\n\e[31m   |\e[0m                                Not found:\
    \ type -\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp0k9s431u.scala:20:31\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m            \e[33mvar\e[0m\
    \ \e[36mprevious\e[0m = arr[\e[35mi\e[0m]\n\e[31m\e[31m   |\e[0m             \
    \                  ^\e[0m\n\e[31m   |\e[0m                               Not found:\
    \ type i\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp0k9s431u.scala:26:32\
    \ ------------------------\e[0m\e[0m\n\e[31m26 |\e[0m                current =\
    \ arr[\e[35mi\e[0m \e[35m-\e[0m \e[31m1\e[0m]\n\e[31m\e[31m   |\e[0m         \
    \                       ^\e[0m\n\e[31m   |\e[0m                              \
    \  Not found: type -\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp0k9s431u.scala:27:24\
    \ ---------------------------\e[0m\e[0m\n\e[31m27 |\e[0m                \e[33mvar\e\
    [0m \e[36mi\e[0m = i - changes\n\e[31m\e[31m   |\e[0m                        ^\e\
    [0m\n\e[31m   |\e[0m                        Recursive \e[33mvariable\e[0m \e[35mi\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660010512
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        var result = 1\n        var stack = mutable.Stack[Long](arr(0))\n\
    \        var rev = List(arr.last)\n        for (i <- 1 to arr.size) {\n      \
    \      val left = stack.pop()\n            val right = stack.pop()\n         \
    \   val newElement = left * right\n            val oldElement = stack.pop()\n\
    \            if (newElement == oldElement && newElement != 0) {\n            \
    \    result = result+1\n            }\n            rev ::= newElement\n      \
    \      stack ::= newElement\n        }\n        result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp77wz1ya4.scala:16:20 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mvar\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mLong\e[0m](arr(\e[31m0\e[0m))\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660010513
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        arr.sortWith( (a,b) => { if (a>b) a else b })\n        if(arr.isEmpty)\n\
    \            return 0\n        var num = 0\n        var min = arr(0)\n       \
    \ for(i <- 1 to arr.length-1){\n            if(arr(i) != arr(i-1))\n         \
    \       num += 1\n            else\n                num -= 1\n            if(num\
    \ == 0){\n                min = i\n                break\n            }\n    \
    \    }\n        min\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp7jy67qm6.scala:15:42\
    \ --------------------\e[0m\e[0m\n\e[31m15 |\e[0m        arr.sortWith( (\e[36ma\e\
    [0m,\e[36mb\e[0m) => { \e[33mif\e[0m (a>b) a \e[33melse\e[0m b })\n\e[31m\e[31m\
    \   |\e[0m                                          ^\e[0m\n\e[31m   |\e[0m  \
    \                                        Found:    (a : Long)\n\e[31m   |\e[0m\
    \                                          Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp7jy67qm6.scala:15:49 --------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        arr.sortWith( (\e[36ma\e[0m,\e[36mb\e[0m) =>\
    \ { \e[33mif\e[0m (a>b) a \e[33melse\e[0m b })\n\e[31m\e[31m   |\e[0m        \
    \                                         ^\e[0m\n\e[31m   |\e[0m            \
    \                                     Found:    (b : Long)\n\e[31m   |\e[0m  \
    \                                               Required: Boolean\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp7jy67qm6.scala:27:16 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m                break\n\e[31m\e[31m   |\e[0m        \
    \        ^^^^^\e[0m\n\e[31m   |\e[0m                Not found: break\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1660010519
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toSet.toList\n        val changeNum = arr.toSet.size\n\
    \        val changeSet = new mutable.HashSet[Long]\n        changeNum = changeNum\
    \ - 1\n        val arrLength = len(arr)\n        val arrLength = arrLength - 1\n\
    \        var i = arrLength\n        var change = 0\n        val arrLength = arr.length\n\
    \        val arrLength = arrLength - 1\n        var j = 0\n        while (i >=\
    \ 0) {\n            if (j < arrLength && arr(i) == arr(arrLength-j)) {\n     \
    \           j = j + 1\n            }\n            val temp = arr(i)\n        \
    \    arr(i) = arr(arrLength-j-1)\n            arr(arrLength-j-1) = temp\n    \
    \        change = change + 1\n            if (change >= changeNum) {\n       \
    \         return change\n            }\n            i = i - 1\n            j =\
    \ j - 1\n        }\n        0\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmptrluj8i7.scala:20:12 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36marrLength\e[0m = arrLength\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0marrLength is already defined as \e[33mvalue\e[0m \e[35marrLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmptrluj8i7.scala:23:12 ---------------------------\e[0m\e[0m\n\e\
    [31m23 |\e[0m        \e[33mval\e[0m \e[36marrLength\e[0m = arr.length\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marrLength\
    \ is already defined as \e[33mvalue\e[0m \e[35marrLength\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmptrluj8i7.scala:24:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m\
    \ \e[36marrLength\e[0m = arrLength - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m     \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marrLength is already defined\
    \ as \e[33mvalue\e[0m \e[35marrLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmptrluj8i7.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toSet.toList\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmptrluj8i7.scala:17:28 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mchangeSet\e[0m = \e[33mnew\e\
    [0m mutable.HashSet[\e[35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                  \
    \          ^^^^^^^\e[0m\n\e[31m   |\e[0m                            Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compilin"
  stdout: ''
  timestamp: 1660010515
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        var min = Long.MaxValue - 1\n        arr.foreach { e =>\n\
    \            val count = arr.count(v => v == e) //number of times element e occurs\
    \ in arr\n            if (count > min && count > arr.count(e => e == e))\n   \
    \             min = count\n        }\n        min\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmprm4fle3o.scala:24)\n\tat Problem.main(tmprm4fle3o.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010520
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val reversed = arr.filter(_ != arr.last).reverse\n     \
    \   reversed.zip(arr).map(x => (x._1 - x._2).abs).min\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpcdsymd4t.scala:19)\n\tat Problem.main(tmpcdsymd4t.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010521
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val a = arr.toList\n        val l = a.length\n        val\
    \ b = new Array[Boolean](l)\n        val index = new Array[Long](l)\n        val\
    \ r = new Array[Long](l)\n        val x = new Array[Long](l)\n        val c =\
    \ new Array[Long](l)\n        var j = 0\n        var k = 0\n        var m = 0\n\
    \        var t = 0\n        for (i <- 0 until l) {\n            a(i) = a(i).toLong\n\
    \            b(i) = true\n            index(i) = i\n            r(i) = a(i).reverse\n\
    \            c(0) = a(i)\n            x(0) = a(i)\n        }\n        for (j <-\
    \ 0 to l / 2)\n            for (k <- 0 to l / 2 by -1)\n                if (c(b(k))\
    \ && c(b(k + 1))) m(k) = index(b(k))\n        for (m <- 0 to l / 2)\n        \
    \    if (m(k) == index(b(m)))\n                if (x(m) != r(m))\n           \
    \         for (t <- m(k + 1) + 1 to l / 2)\n                        if (b(index(b(t)))\
    \ && r(b(index(b(t)))))\n                            if (x(b(t)) != r(b(t))) c\
    \ += index(b(t))\n                        else c += index(b(t))\n        for (x\
    \ <- 0 to l / 2)\n            if (x(k) == c(b(x)))\n                if (r(x) !=\
    \ r(b(x))) x += 1\n                else x += 1\n        var count = 0\n      \
    \  for (x <- 0 to l / 2)\n            if (x(k) == index(b(x)))\n             \
    \   if (x(k) != r(b(x))) {\n                    count += 1\n                 \
    \   x(k) = r(b(x)) // change the element with the smallest index to make the list\
    \ palindromic\n                    x(k) = r(b(x)) // change the element with the\
    \ smallest index to make the list palindromic\n                }\n        count\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp1qoubcwh.scala:27:12 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m            a(i) = a(i).toLong\n\e[31m\e[31m   |\e[0m\
    \            ^\e[0m\n\e[31m   |\e[0m    value update is not a member of List[Long]\
    \ - did you mean a.updated?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp1qoubcwh.scala:30:24\
    \ ------------------------\e[0m\e[0m\n\e[31m30 |\e[0m            r(i) = a(i).reverse\n\
    \e[31m\e[31m   |\e[0m                   ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m   \
    \                value reverse is not a member of Long\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmp1qoubcwh.scala:36:23 --------------------\e[0m\e\
    [0m\n\e[31m36 |\e[0m                \e[33mif\e[0m (c(b(k)) && c(b(k + \e[31m1\e\
    [0m))) m(k) = index(b(k))\n\e[31m\e[31m   |\e[0m                      ^^^^\e[0m\n\
    \e[31m   |\e[0m                      Found:    Boolean\n\e[31m   |\e[0m      \
    \                Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp1qoubcwh.scala:36:34 --------------------\e[0m\e[0m\n\e[31m36\
    \ |\e[0m                \e[33mif\e[0m (c(b(k)) && c(b(k + \e[31m1\e[0m))) m(k)\
    \ = index(b(k))\n\e[31m\e[31m   |\e[0m                                 ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                 Found:    Boolean\n\e[31m\
    \   |\e[0m                                 Required: Int\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmp1qoubcwh.scala:36:44 ------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m                \e[33mif\e[0m (c(b(k)) && c(b(k + \e\
    [31m1\e[0m))) m(k) = index(b(k))\n\e[31m\e[31m   |\e[0m                      \
    \                      ^\e[0m\n\e[31m   |\e[0m                               \
    \      value update is not a member of Int\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp1qoubcwh.scala:36:58 --------------------\e[0m\e[0m\n\e[31m36\
    \ |\e[0m                \e[33mif\e[0m (c(b(k)) && c(b(k + \e[31m1\e[0m))) m(k)\
    \ = index(b(k))\n\e[31m\e[31m   |\e[0m                                       \
    \                 "
  stdout: ''
  timestamp: 1660010521
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n      var i = arr.length\n      val max1 = Math.max(arr(i-1), arr(i))\n\
    \      val max2 = Math.max(arr(i-1), arr(i+1))\n      if (max1 < max2)\n     \
    \   return max2\n      else\n        return 0\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 8\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.smallestChange(tmpnzcqae2f.scala:16)\n\tat Problem$.main(tmpnzcqae2f.scala:24)\n\
    \tat Problem.main(tmpnzcqae2f.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010521
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        var minChange = 0\n        val n = arr.size\n        var\
    \ p = 1\n        var change = 0\n        var flag = false\n        while (change\
    \ < n && minChange < n) {\n            if (arr[change] == arr[change-n]) {\n \
    \               if (change == 0) {\n                    minChange = p\n      \
    \              p = 1\n                    change = change + 1\n              \
    \  }\n                else {\n                    p += 1\n                   \
    \ change = change + 1\n                }\n            }\n            else {\n\
    \                if (change == n-1) {\n                    minChange = p\n   \
    \                 change = 0\n                }\n                else {\n    \
    \                p += 1\n                    change = change + 1\n           \
    \     }\n            }\n        }\n        if (minChange < n) {\n            minChange\
    \ = n - minChange\n        }\n        if (minChange == n) minChange = 0\n    \
    \    flag = minChange == 0\n        minChange\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpf5ukpigy.scala:21:20 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m            \e[33mif\e[0m (arr[\e[35mchange\e[0m] ==\
    \ arr[\e[35mchange-n\e[0m]) {\n\e[31m\e[31m   |\e[0m                    ^^^^^^\e\
    [0m\n\e[31m   |\e[0m                    Not found: type change\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010519
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val map = mutable.HashMap[Int, Long]()\n        val list\
    \ = arr.toList\n        var p = 0\n        \n        for (i<-1 to (arr.size-1))\n\
    \        {\n            map.put(i, list(i).toLong)\n        }\n        \n    \
    \    for (i <- 0 to (arr.size-1))\n        {\n            for (j <- (arr.size\
    \ - i - 1).toLong to (arr.size - i).toLong)\n            {\n                if\
    \ (map.get(i+j) == map.get(i))\n                {\n                    p += 1\n\
    \                }\n            }\n        }\n        \n        if (arr.size ==\
    \ p)\n        {\n            0\n        }\n        else\n        {\n         \
    \   p\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp0dbqalli.scala:15:18 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mmap\e[0m = mutable.HashMap[\e\
    [35mInt\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                  ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                  Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660010519
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        def compare(xs : List[Long], ys : List[Long]) : Boolean\
    \ = {\n            if (xs.head > ys.head) return true\n            if (xs.head\
    \ < ys.head) return false\n            compare(xs.tail, ys.tail)\n        }\n\
    \        var change = 0\n        val len = arr.length\n        for (xs <- arr.drop(len\
    \ - 1)){\n            for (ys <- arr.reverse.drop(len - 1)){\n               \
    \ if (compare(xs, ys)) {\n                    change += 1\n                }\n\
    \            }\n        }\n        change\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphws3zt0i.scala:24:28\
    \ --------------------\e[0m\e[0m\n\e[31m24 |\e[0m                \e[33mif\e[0m\
    \ (compare(xs, ys)) {\n\e[31m\e[31m   |\e[0m                            ^^\e[0m\n\
    \e[31m   |\e[0m                            Found:    (xs : Long)\n\e[31m   |\e\
    [0m                            Required: List[Long]\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmphws3zt0i.scala:24:32 --------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m                \e[33mif\e[0m (compare(xs, ys)) {\n\e\
    [31m\e[31m   |\e[0m                                ^^\e[0m\n\e[31m   |\e[0m  \
    \                              Found:    (ys : Long)\n\e[31m   |\e[0m        \
    \                        Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010523
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        var changes = 0\n        var len = arr.length\n        var\
    \ i = 0\n        var start = 0\n        while (i < len) {\n            if (i %\
    \ 2 == 1) {\n                start += arr(i).toLong\n                val end =\
    \ start + arr(i).toLong\n                while (i < len && arr(i).toLong < end)\
    \ {\n                    i += 2\n                }\n                if (i == len)\
    \ {\n                    changes += 1\n                }\n            }\n    \
    \        i += 1\n        }\n        if (changes == 0) {\n            return 0\n\
    \        }\n        changes - 1\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp5crttli0.scala:21:22 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m                start += arr(i).toLong\n\e[31m\e[31m\
    \   |\e[0m                ^^^^^^^^\e[0m\n\e[31m   |\e[0m                value\
    \ += is not a member of Int - did you mean Int.!=?\n1 error found\n"
  stdout: ''
  timestamp: 1660010522
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val palindromicArr: List[Long] = arr.map(arrValue => arrValue\
    \ * arrValue).toList\n        val reversedArr: List[Long] = arr.map(arrValue =>\
    \ arrValue * arrValue).reverse\n        val changedArr: List[Long] = reversedArr\
    \ diff palindromicArr\n        reversedArr.length\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpd4ag6at3.scala:21)\n\tat Problem.main(tmpd4ag6at3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010524
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        var count = (0 until arr.length).map{ i => 0 }.toList\n\
    \        var i = 0\n        while (i < arr.length) {\n            count += arr(i)\
    \ - arr(i-1)\n            i += 1\n        }\n        return count.min\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp61v4bp4y.scala:18:18 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m            count += arr(i) - arr(i-\e[31m1\e[0m)\n\e\
    [31m\e[31m   |\e[0m            ^^^^^^^^\e[0m\n\e[31m   |\e[0m      value += is\
    \ not a member of List[Int] - did you mean List[Int].!=?\n1 error found\n"
  stdout: ''
  timestamp: 1660010523
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val map = mutable.LinkedHashMap[Long, Int]()\n        arr.foreach\
    \ { e =>\n            if (map.contains(e)) {\n                map.put(e, map.get(e)\
    \ + 1)\n            } else {\n                map.put(e, 1)\n            }\n \
    \       }\n        val max = map.max.toInt\n        val result: List[Long] = map.keys.toList.sortWith((x:\
    \ Long) => x < max).toList\n        result.size match {\n            case 0 =>\
    \ 0l\n            case 1 => arr(0l).toLong\n            case n =>\n          \
    \      val first = arr(0l).toLong\n                val last = result.last\n  \
    \              val left = (first - last) match {\n                    case x if\
    \ x > 0 => 0l\n                    case _ => 1l\n                }\n         \
    \       val right = (last - first) match {\n                    case x if x >\
    \ 0 => 1l\n                    case _ => 0l\n                }\n             \
    \   min {\n                    case 0 => 0l\n                    case x if x <\
    \ left + right => x + smallestChange(arr.drop(1))\n                }\n       \
    \ }\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpn_h2z0s_.scala:15:18 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mmap\e[0m = mutable.LinkedHashMap[\e\
    [35mLong\e[0m, \e[35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m                  ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                  Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpn_h2z0s_.scala:27:26 --------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m            \e[33mcase\e[0m \e[31m1\e[0m => arr(\e[31m0l\e\
    [0m).toLong\n\e[31m\e[31m   |\e[0m                          ^^\e[0m\n\e[31m  \
    \ |\e[0m                          Found:    (\e[31m0L\e[0m : Long)\n\e[31m   |\e\
    [0m                          Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpn_h2z0s_.scala:29:32 --------------------\e[0m\e\
    [0m\n\e[31m29 |\e[0m                \e[33mval\e[0m \e[36mfirst\e[0m = arr(\e[31m0l\e\
    [0m).toLong\n\e[31m\e[31m   |\e[0m                                ^^\e[0m\n\e\
    [31m   |\e[0m                                Found:    (\e[31m0L\e[0m : Long)\n\
    \e[31m   |\e[0m                                Required: Int\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E134] Type Error: /tmp/tmpn_h2z0s_.scala:39:16 -----------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m                min {\n\e[31m\e[31m   |\e[0m        \
    \        ^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e\
    [0m \e[35mmin\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e\
    [31m   |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m (x: Float, y: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m   |\e[0m (x: Int, y:\
    \ Int): Int\n\e[31m   |\e[0mmatch arguments (<?>)\n4 errors found\n"
  stdout: ''
  timestamp: 1660010524
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        var p = new mutable.ListBuffer[Long]()\n        var i =\
    \ 0\n        var j = 0\n        var min = Integer.MAX_VALUE\n        // While\
    \ i < length of arr\n        while (i < arr.length) {\n            if (j > 0)\
    \ \n                p.insert(j, arr(i))\n            i += 1\n        }\n     \
    \   p.reverse()\n        var j = 0\n        i = p.length\n        while(i-- >\
    \ 0){\n            if (arr(i) != p(j)) {\n                min = Math.min(min,\
    \ j-i)\n            }\n            j += 1\n        }\n        min\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpyrnxcyrl.scala:28:20 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mwhile\e[0m(i-- > \e[31m0\e[0m){\n\e[31m\e\
    [31m   |\e[0m                    ^\e[0m\n\e[31m   |\e[0m                    ')'\
    \ expected, but integer literal found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpyrnxcyrl.scala:26:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mvar\e[0m\
    \ \e[36mj\e[0m = \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mj is already defined as \e[33mvariable\e[0m \e[35mj\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpyrnxcyrl.scala:15:20 ------------------------\e[0m\e[0m\n\e[31m15 |\e\
    [0m        \e[33mvar\e[0m \e[36mp\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpyrnxcyrl.scala:28:15 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mwhile\e[0m(i-- > \e[31m0\e[0m){\n\e[31m\e\
    [31m   |\e[0m              ^^^\e[0m\n\e[31m   |\e[0m              value -- is\
    \ not a member of Int\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpyrnxcyrl.scala:28:18\
    \ ------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mwhile\e[0m(i--\
    \ > \e[31m0\e[0m){\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e\
    [0m                  Not found: >\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n5 errors found\n"
  stdout: ''
  timestamp: 1660010522
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val list = arr.filter(_ % 2 == 0).reverse.toList.sortWith(_\
    \ < _)\n        val change = list.length * 2 - list\n        if (change == 0)\
    \ 0\n        else list.length * 2 - change\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpgz5d81pa.scala:16:37 -----------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mchange\e[0m = list.length\
    \ * \e[31m2\e[0m - list\n\e[31m\e[31m   |\e[0m                     ^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m None of the overloaded alternatives of \e[33mmethod\e[0m\
    \ \e[35m-\e[0m in \e[33mclass\e[0m \e[35mInt\e[0m with types\n\e[31m   |\e[0m\
    \  (x: Double): Double\n\e[31m   |\e[0m  (x: Float): Float\n\e[31m   |\e[0m  (x:\
    \ Long): Long\n\e[31m   |\e[0m  (x: Int): Int\n\e[31m   |\e[0m  (x: Char): Int\n\
    \e[31m   |\e[0m  (x: Short): Int\n\e[31m   |\e[0m  (x: Byte): Int\n\e[31m   |\e\
    [0m match arguments ((list : List[Long]))\n1 error found\n"
  stdout: ''
  timestamp: 1660010521
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        // Write your solution here\n        val n = arr.length\n\
    \        val len = arr.foldLeft(0) { (i, a) => i + a.length}\n        if(len <\
    \ n)\n            smallestChange(arr)\n        else\n            if((arr.tail.filter(x\
    \ => x == arr.head).take(len).forall(x => x != arr.head)) && (arr.tail.forall(x\
    \ => x == arr.head)))\n                0\n            else if((arr.tail.filter(x\
    \ => x == arr.head).take(len).forall(x => x == arr.head)))\n                1\n\
    \            else if((arr.tail.filter(x => x == arr.head).take(len).forall(x =>\
    \ x != arr.head)) && (arr.tail.forall(x => x != arr.head)))\n                smallestChange(arr.tail.filter(x\
    \ => x != arr.head))\n            else\n                smallestChange(arr.tail.filter(x\
    \ => x != arr.head).take(len - 1))\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpwz5u4sa6.scala:17:52 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mlen\e[0m = arr.foldLeft(\e\
    [31m0\e[0m) { (\e[36mi\e[0m, \e[36ma\e[0m) => i + a.length}\n\e[31m\e[31m   |\e\
    [0m                                                  ^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                                    value length is not a member of Long\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010524
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        // Initialize our best result\n        var best = 0L;\n\n\
    \        // Initialize our best result\n        var current = arr[arr.length -\
    \ 1]\n\n        // Loop from end\n        for (i = arr.length - 2; i >= 0; i -=\
    \ 1) {\n            val value = arr(i);\n\n            // Increment current by\
    \ any value less than current value\n            if (current > value) {\n    \
    \            current += value;\n            } else {\n                // If current\
    \ is equal to value, no changes needed\n                if (current == value)\
    \ {\n                    current = current + 1\n                }\n          \
    \  }\n\n            // If current is greater than best, update best\n        \
    \    if (current > best) {\n                best = current;\n            }\n \
    \       }\n\n        // Return best value\n        return best\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp73pibu_h.scala:22:15 ---------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mfor\e[0m (i = arr.length - \e[31m2\e[0m;\
    \ i >= \e[31m0\e[0m; i -= \e[31m1\e[0m) {\n\e[31m\e[31m   |\e[0m             \
    \  ^\e[0m\n\e[31m   |\e[0m               ')' expected, but '=' found\n\e[31m\e\
    [31m-- [E040] Syntax Error: /tmp/tmp73pibu_h.scala:22:39 ---------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mfor\e[0m (i = arr.length - \e[31m2\e[0m;\
    \ i >= \e[31m0\e[0m; i -= \e[31m1\e[0m) {\n\e[31m\e[31m   |\e[0m             \
    \                          ^\e[0m\n\e[31m   |\e[0m                           \
    \            '<-' expected, but ';' found\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tmp73pibu_h.scala:22:47 ---------------------------\e[0m\e[0m\n\e[31m22\
    \ |\e[0m        \e[33mfor\e[0m (i = arr.length - \e[31m2\e[0m; i >= \e[31m0\e\
    [0m; i -= \e[31m1\e[0m) {\n\e[31m\e[31m   |\e[0m                             \
    \                  ^\e[0m\n\e[31m   |\e[0m                                   \
    \         '<-' expected, but ')' found\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp73pibu_h.scala:19:37 ------------------------\e[0m\e[0m\n\e[31m19 |\e\
    [0m        \e[33mvar\e[0m \e[36mcurrent\e[0m = arr[arr.length \e[35m-\e[0m \e\
    [31m1\e[0m]\n\e[31m\e[31m   |\e[0m                                     ^\e[0m\n\
    \e[31m   |\e[0m                                     Not found: type -\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp73pibu_h.scala:22:31 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mfor\e[0m (i = arr.length - \e[31m2\e[0m;\
    \ i >= \e[31m0\e[0m; i -= \e[31m1\e[0m) {\n\e[31m\e[31m   |\e[0m             \
    \                  ^\e[0m\n\e[31m   |\e[0mvalue foreach is not a member of Null,\
    \ but could be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mOne of the following imports might fix the problem:\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m  import Option.option2Iterable\n\e[31m   |\e[0m  import collection.LazyZip2.lazyZip2ToIterable\n\
    \e[31m   |\e[0m  import collection.LazyZip3.lazyZip3ToIterable\n\e[31m   |\e[0m\
    \  import collecti"
  stdout: ''
  timestamp: 1660010525
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        if (arr.isEmpty) 0\n        else {\n            val list1\
    \ = arr.tail\n            val list2 = arr.init\n            val list3 = arr.tail.reverse\n\
    \            val list4 = arr.init.reverse\n\n            val list5 = (list1, list2,\
    \ list3, list4)\n\n            val list6 = list5.foldLeft(0) { (acc, tuple) =>\n\
    \                val a = tuple._1\n                val b = tuple._2\n        \
    \        val c = tuple._3\n                val d = tuple._4\n                if\
    \ (a > b) acc + c else acc + d\n            }\n\n            return list6.min\
    \ * 2\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpdws2n8ol.scala:24:30 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m            \e[33mval\e[0m \e[36mlist6\e[0m = list5.foldLeft(\e\
    [31m0\e[0m) { (\e[36macc\e[0m, \e[36mtuple\e[0m) =>\n\e[31m\e[31m   |\e[0m   \
    \                     ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue foldLeft is not\
    \ a member of (List[Long], List[Long], List[Long], List[Long])\n1 error found\n"
  stdout: ''
  timestamp: 1660010525
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        // Write your code here.\n        var lenArr = arr.length\n\
    \        var result = 0L\n        var tmp = 0\n        for(i <- 0 until lenArr){\n\
    \            tmp = arr(i)\n            var isPalindrome = true\n            for(j\
    \ <- i+1 until lenArr){\n                if(arr(j) != tmp){\n                \
    \    isPalindrome = false\n                }\n            }\n            if(isPalindrome){\n\
    \                result += 1\n            }\n        }\n        result\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmplmtosm8u.scala:20:21\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m            tmp = arr(i)\n\e\
    [31m\e[31m   |\e[0m                  ^^^^^^\e[0m\n\e[31m   |\e[0m            \
    \      Found:    Long\n\e[31m   |\e[0m                  Required: Int\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010525
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n       // Write your code here\n        val len = arr.size\n   \
    \     val minChange = len / 2\n        var i = minChange\n        var j = len\
    \ - minChange\n\n        // Find the minimum number of changes needed.\n     \
    \   var change = 0\n        for (k <- 1 to len) {\n            change += 1\n \
    \           i = j\n            j -= 1\n        }\n        // Now we have found\
    \ minimum number of changes.\n        change\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp455ohqhj.scala:32)\n\tat Problem.main(tmp455ohqhj.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010529
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        var i = 0\n        var j = 0\n        var k = arr.length\n\
    \        var count = 0\n        var largest = 0\n        while(i < k && j < k)\n\
    \        {\n            if(arr(i) == arr(j))\n            {\n                i\
    \ = i + 1\n                j = j + 1\n                count = count + 1\n    \
    \        }\n            else if(arr(i) < arr(j))\n            {\n            \
    \    j = j + 1\n            }\n            else\n            {\n             \
    \   i = i + 1\n            }\n        }\n        while(i < k && j >= k)\n    \
    \    {\n            if(arr(i) == arr(j))\n            {\n                i = i\
    \ + 1\n                count = count + 1\n            }\n            else if(arr(i)\
    \ < arr(j))\n            {\n                largest = arr(i)\n               \
    \ i = i + 1\n            }\n            else\n            {\n                largest\
    \ = arr(j)\n                j = j - 1\n            }\n        }\n        if(largest\
    \  == 0)\n        {\n            return 0\n        }\n        else\n        {\n\
    \            return count\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpbnsnikpf.scala:46:29\
    \ --------------------\e[0m\e[0m\n\e[31m46 |\e[0m                largest = arr(i)\n\
    \e[31m\e[31m   |\e[0m                          ^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                        Found:    Long\n\e[31m   |\e[0m                     \
    \     Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpbnsnikpf.scala:51:29\
    \ --------------------\e[0m\e[0m\n\e[31m51 |\e[0m                largest = arr(j)\n\
    \e[31m\e[31m   |\e[0m                          ^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                        Found:    Long\n\e[31m   |\e[0m                     \
    \     Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010527
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length\n        val dp = Array.ofDim[Long](n+1,\
    \ n)\n        dp.apply(0, 0) = 0\n\n        for ((i1, i2) <- arr.view.zipWithIndex)\
    \ {\n            val l1 = dp(i1, i1+1)\n            val l2 = dp(i1+1, i2)\n  \
    \          dp(i1+1, i2) = math.min(l1, l2)\n        }\n        (dp(n-1, n)).min\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp3ps5mli8.scala:17:8 -------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        dp.apply(\e[31m0\e[0m, \e[31m0\e[0m) = \e[31m0\e\
    [0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^\e[0m\n\e[31m   |\e[0m        value\
    \ update is not a member of Int => Array[Long]\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp3ps5mli8.scala:20:24 --------------------\e[0m\e[0m\n\e[31m20\
    \ |\e[0m            \e[33mval\e[0m \e[36ml1\e[0m = dp(i1, i1+\e[31m1\e[0m)\n\e\
    [31m\e[31m   |\e[0m                        ^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                    Found:    (Long, Long)\n\e[31m   |\e[0m                 \
    \       Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp3ps5mli8.scala:21:24\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m            \e[33mval\e[0m \e\
    [36ml2\e[0m = dp(i1+\e[31m1\e[0m, i2)\n\e[31m\e[31m   |\e[0m                 \
    \       ^^^^^^^^\e[0m\n\e[31m   |\e[0m                        Found:    (Long,\
    \ Int)\n\e[31m   |\e[0m                        Required: Int\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E134] Type Error: /tmp/tmp3ps5mli8.scala:22:32 -----------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m            dp(i1+\e[31m1\e[0m, i2) = math.min(l1, l2)\n\
    \e[31m\e[31m   |\e[0m                           ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone\
    \ of the overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments ((l1 : Array[Long]), (l2 : Array[Long]))\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmp3ps5mli8.scala:22:15 --------------------\e[0m\e[0m\n\
    \e[31m22 |\e[0m            dp(i1+\e[31m1\e[0m, i2) = math.min(l1, l2)\n\e[31m\e\
    [31m   |\e[0m               ^^^^\e[0m\n\e[31m   |\e[0m               Found:  \
    \  Long\n\e[31m   |\e[0m               Required: Int\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer expl"
  stdout: ''
  timestamp: 1660010529
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length\n        val arr = arr.sortBy(_.reverse)\n\
    \        var res = -1L\n        var i = 0\n        while(i < n) {\n          \
    \  if(arr(i) == arr(n)) {\n                res++\n                n -= 1\n   \
    \             i -= 1\n            }\n            i += 1\n        }\n        res\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpsc6q5yk8.scala:16:18 ---------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(_.reverse)\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpsc6q5yk8.scala:21:19 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m                res++\n\e[31m\e[31m   |\e[0m        \
    \        ^^^^^\e[0m\n\e[31m   |\e[0m                value ++ is not a member of\
    \ Long\n2 errors found\n"
  stdout: ''
  timestamp: 1660010527
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.size\n        val p = new Array[Long](n)\n \
    \       var count = 0\n        for(i <- 0 to (n-1)) {\n            p(i) = arr(i)\n\
    \            if(i == n-1 || arr(i) != arr(i+1)) count = count + 1\n        }\n\
    \        count\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp8kdms4zn.scala:25)\n\tat Problem.main(tmp8kdms4zn.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010532
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val length = arr.size\n  \
    \      val leftmostChangeIndex = length - 1\n        val rightmostChangeIndex\
    \ = -1\n        var leftmostChangeValue = 0l\n        var rightmostChangeValue\
    \ = 0l\n        var leftmostChangeIsChange = false\n        var rightmostChangeIsChange\
    \ = false\n        var leftmostChangeIsInPlace = false\n        var rightmostChangeIsInPlace\
    \ = false\n        var leftmostChangeIsReadBackwards = false\n        var rightmostChangeIsReadBackwards\
    \ = false\n        \n        // For all pairs of consecutive pairs, see if there\
    \ is any change in the two consecutive elements\n        // If so, make the change\
    \ as minimum as possible and update leftmostChangeIndex and rightmostChangeIndex\n\
    \        // If not, ignore this pair.\n        // If there are more than two consecutive\
    \ pairs, update the leftmostChangeIndex and rightmostChangeIndex\n        // with\
    \ maximum possible pairs.\n        // A pair of consecutive pairs is a valid pair.\n\
    \        for( i <- 0 until length - 2) {\n            val currentLeft = arr(i).toLong\n\
    \            val currentRight = arr(i + 1).toLong\n            if( currentLeft\
    \ != currentRight && !leftmostChangeIsChange) {\n                // If there is\
    \ any change in the current left and current right,\n                // ignore\
    \ the pair.\n                if( currentLeft < currentRight) {\n             \
    \       leftmostChangeIsChange = true\n                    leftmostChangeIndex\
    \ = i\n                    leftmostChangeValue = currentLeft\n               \
    \ } else if( currentLeft > currentRight) {\n                    rightmostChangeIsChange\
    \ = true\n                    rightmostChangeIndex = i + 1\n                 \
    \   rightmostChangeValue = currentRight\n                } else {\n          \
    \          leftmostChangeIsChange = true\n                    leftmostChangeIndex\
    \ = i\n                    leftmostChangeValue = currentRight\n              \
    \  }\n            }\n        }\n\n        // If there is no change in the list\
    \ at all, then return the number of elements that can be changed\n        // without\
    \ changing the list palindromic or not\n        if(leftmostChangeIsChange == false)\
    \ return length\n\n        // If there are only two consecutive pairs and they\
    \ are same, then the list can be made palindromic\n        // If there are more\
    \ than two consecutive pairs, then update the leftmostChangeIndex and rightmostChangeIndex\n\
    \        // with maximum possible pairs.\n        for( i <- 0 until length - 2)\
    \ {\n            val currentLeft = arr(i).toLong\n            val currentRight\
    \ = arr(i + 1).toLong\n            if( currentLeft != currentRight && leftmostChangeIsChange)\
    \ {\n                if( currentLeft < currentRight) {\n                    rightmostChangeIsChange\
    \ = true\n                    rightmostChangeIndex = i + 1\n                 \
    \   rightmostChangeValue = currentRight\n                } else {\n          \
    \          \n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpkq9wtz45.scala:86:0 ----------------------------\e\
    [0m\e[0m\n\e[31m86 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpkq9wtz45.scala:15:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\
    \e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmpkq9wtz45.scala:42:40\
    \ -----------------------------\e[0m\e[0m\n\e[31m42 |\e[0m                   \
    \ leftmostChangeIndex = i\n\e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                    Reassignment to val leftmostChangeIndex\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmpkq9wtz45.scala:46:41 -----------------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m                    rightmostChangeIndex = i + \e[31m1\e\
    [0m\n\e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                    Reassignment to val rightmostChangeIndex\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmpkq9wtz45.scala:50:40 -----------------------------\e\
    [0m\e[0m\n\e[31m50 |\e[0m                    leftmostChangeIndex = i\n\e[31m\e\
    [31m   |\e[0m                    ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                    Reassignment to val leftmostChangeIndex\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E052] Type Error: /tmp/tmpkq9wtz45.scala:69:41 -----------------------------\e\
    [0m\e[0m\n\e[31m69 |\e[0m                    rightmostChangeIndex = i + \e[31m1\e\
    [0m\n\e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                    Reassignment to val rightmostChangeIndex\n\e\
    [31m   |\e[0m\n\e[3"
  stdout: ''
  timestamp: 1660010527
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val len = arr.length\n        val minPalindromic = 0\n \
    \       var changes = 0\n        var left = 0\n        var right = (len-1)\n \
    \       var changeCount = 0\n        while (left<right) {\n            if (arr(left)>arr(right))\
    \ {\n                right--\n                changeCount++\n            } else\
    \ {\n                left++\n                changeCount++\n            }\n  \
    \          if (changeCount > minPalindromic) {\n                minPalindromic\
    \ = changeCount\n            }\n        }\n        minPalindromic\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp1trj3b70.scala:24:29 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m                changeCount++\n\e[31m\e[31m   |\e[0m\
    \                             ^\e[0m\n\e[31m   |\e[0m                        \
    \     expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E018] Syntax Error: /tmp/tmp1trj3b70.scala:27:29 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m                changeCount++\n\e[31m\e[31m   |\e[0m\
    \                             ^\e[0m\n\e[31m   |\e[0m                        \
    \     expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp1trj3b70.scala:23:21 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m                right--\n\e[31m\e[31m   |\e[0m      \
    \          ^^^^^^^\e[0m\n\e[31m   |\e[0m                value -- is not a member\
    \ of Int\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp1trj3b70.scala:26:20\
    \ ------------------------\e[0m\e[0m\n\e[31m26 |\e[0m                left++\n\e\
    [31m\e[31m   |\e[0m                ^^^^^^\e[0m\n\e[31m   |\e[0m              \
    \  value ++ is not a member of Int\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmp1trj3b70.scala:30:31\
    \ -----------------------------\e[0m\e[0m\n\e[31m30 |\e[0m                minPalindromic\
    \ = changeCount\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                Reassignment to val minPalindromic\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    5 errors found\n"
  stdout: ''
  timestamp: 1660010531
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        if (arr.isEmpty) return 0\n        val stack = arr.toStack\n\
    \        val min = arr.head + arr.tail.last\n        var change = 0\n        while(stack.nonEmpty)\
    \ {\n            val x = stack.last\n            stack -= x\n            val y\
    \ = stack.last\n            stack -= y\n            val z = stack.last\n     \
    \       stack -= z\n            if (x==y && x==z) change += 1\n            else\
    \ if (z==y && x==z) change -= 1\n            else stack += x\n        }\n    \
    \    min\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp84lcaaer.scala:16:24 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = arr.toStack\n\
    \e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m   \
    \                 value toStack is not a member of List[Long]\n1 error found\n"
  stdout: ''
  timestamp: 1660010530
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val length = arr.length\n        var minChange = 0l\n  \
    \      \n        while(length > 0) {\n            if(minChange >= length) {\n\
    \                minChange = 0l\n            }\n            val element = arr(minChange)\n\
    \            if(element == arr(length-1)) {\n                length -= 1\n   \
    \         } else {\n                length += 1\n                minChange +=\
    \ 1\n            }\n        }\n        minChange\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp30ty3bgu.scala:22:30\
    \ --------------------\e[0m\e[0m\n\e[31m22 |\e[0m            \e[33mval\e[0m \e\
    [36melement\e[0m = arr(minChange)\n\e[31m\e[31m   |\e[0m                     \
    \         ^^^^^^^^^\e[0m\n\e[31m   |\e[0m                              Found:\
    \    (minChange : Long)\n\e[31m   |\e[0m                              Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp30ty3bgu.scala:24:23\
    \ ------------------------\e[0m\e[0m\n\e[31m24 |\e[0m                length -=\
    \ \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m               value -= is not a member of Int - did you mean length.!=?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp30ty3bgu.scala:26:23 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m                length += \e[31m1\e[0m\n\e[31m\e[31m\
    \   |\e[0m                ^^^^^^^^^\e[0m\n\e[31m   |\e[0m               value\
    \ += is not a member of Int - did you mean length.!=?\n3 errors found\n"
  stdout: ''
  timestamp: 1660010533
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.size\n        val m = arr.last\n        if (n\
    \ % 2 == 0) {\n            val even1 = arr.take(n/2)\n            val even2 =\
    \ arr.drop(n/2)\n            smallestChange(even1) + smallestChange(even2)\n \
    \       } else {\n            val odd1 = arr.takeRight(n/2).reverse\n        \
    \    val odd2 = arr.dropRight(n/2).reverse\n            smallestChange(odd1) +\
    \ smallestChange(odd2)\n        }\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.util.NoSuchElementException: last of empty list\n\tat scala.collection.immutable.Nil$.last(List.scala:665)\n\
    \tat scala.collection.immutable.Nil$.last(List.scala:661)\n\tat Problem$.smallestChange(tmpvv43ew45.scala:16)\n\
    \tat Problem$.smallestChange(tmpvv43ew45.scala:24)\n\tat Problem$.smallestChange(tmpvv43ew45.scala:20)\n\
    \tat Problem$.smallestChange(tmpvv43ew45.scala:20)\n\tat Problem$.smallestChange(tmpvv43ew45.scala:20)\n\
    \tat Problem$.main(tmpvv43ew45.scala:28)\n\tat Problem.main(tmpvv43ew45.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010534
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        var largest = arr.last\n        var count = 0\n        for(\
    \ l <- arr.reverse ) {\n            if(l != largest) {\n                if(count\
    \ == 0) {\n                    count = arr.lastIndexOf(l) + 1\n              \
    \  } else {\n                    count = count\n                }\n          \
    \  }\n            largest = l\n        }\n        count.toLong\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp79p_xt4b.scala:30)\n\tat Problem.main(tmp79p_xt4b.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010535
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val map = new collection.mutable.HashMap[Long, Long]()\n\
    \        arr.foreach(x => map.updated(x, map.getOrElse(x, 0) + 1))\n        val\
    \ minChange = map.minEntry match {\n            case None => 0\n            case\
    \ Some((x, xMin)) => x - xMin\n        }\n        minChange\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp687o4ug3.scala:16:60 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        arr.foreach(\e[36mx\e[0m => map.updated(x, map.getOrElse(x,\
    \ \e[31m0\e[0m) + \e[31m1\e[0m))\n\e[31m\e[31m   |\e[0m                      \
    \                  ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue + is not a\
    \ member of AnyVal, but could be made available as an extension method.\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mOne of the following imports might make progress towards\
    \ fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp687o4ug3.scala:17:28 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mminChange\e[0m = map.minEntry\
    \ \e[33mmatch\e[0m {\n\e[31m\e[31m   |\e[0m                        ^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue minEntry is not a member of scala.collection.mutable.HashMap[Long,\
    \ Long]\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp687o4ug3.scala:19:36 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m            \e[33mcase\e[0m Some((x, xMin)) => x - xMin\n\
    \e[31m\e[31m   |\e[0m                                    ^\e[0m\n\e[31m   |\e\
    [0m                                    Not found: x\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010534
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        if (arr.isEmpty) 0\n        else {\n            def findMin(arr\
    \ : List[Long], acc : Long) : Long = {\n                if (arr.isEmpty) acc\n\
    \                else {\n                    def findMinHelper(arr : List[Long],\
    \ acc : Long, pos : Int) : Long = {\n                        if (pos == arr.size)\
    \ {\n                            acc\n                        } else {\n     \
    \                       def findMinHelperHelper(arr : List[Long], acc : Long,\
    \ pos : Int) : Long = {\n                                if (pos == arr.size)\
    \ {\n                                    acc\n                               \
    \ } else {\n                                    def findMinHelperHelperHelper(arr\
    \ : List[Long], acc : Long, pos : Int) : Long = {\n                          \
    \              if (pos == arr.size) {\n                                      \
    \      acc\n                                        } else {\n               \
    \                             val nextMinPos = pos + 1\n                     \
    \                       val nextMaxPos = arr.size - 1\n                      \
    \                      findMinHelperHelperHelper(arr, Math.min(acc, arr[nextMinPos]),\
    \ nextMinPos) + 1\n                                        }\n               \
    \                     }\n                                    findMinHelperHelperHelper(arr,\
    \ acc, pos) + 1\n                                }\n                         \
    \   }\n                            findMinHelperHelper(arr, acc, pos) + 1\n  \
    \                      }\n                    }\n                    findMinHelper(arr,\
    \ acc, 0)\n                }\n            }\n            findMin(arr, 1)\n   \
    \     }\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmppbgsuarz.scala:34:93 ------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m                                            findMinHelperHelperHelper(arr,\
    \ Math.min(acc, arr[\e[35mnextMinPos\e[0m]), nextMinPos) + \e[31m1\e[0m\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \                             ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m               \
    \                               Not found: type nextMinPos\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660010529
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        var changes = 0\n        var cur = 0\n        var min =\
    \ Long.MaxValue\n        var max = Long.MinValue\n        for(i <- arr.iterator){\n\
    \            val curr = i\n            val next = arr.last\n            val len\
    \ = next - curr\n            if (cur > len) return\n            if (cur < min){\n\
    \                min = curr\n            }\n            if (cur > max){\n    \
    \            max = curr\n            }\n        }\n        if (max != min){\n\
    \            changes = 1\n        }\n        max - 1\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp_ekpduy_.scala:23:27\
    \ --------------------\e[0m\e[0m\n\e[31m23 |\e[0m            \e[33mif\e[0m (cur\
    \ > len) \e[33mreturn\e[0m\n\e[31m\e[31m   |\e[0m                           ^^^^^^\e\
    [0m\n\e[31m   |\e[0m                           Found:    Unit\n\e[31m   |\e[0m\
    \                           Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010532
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        // Write your code here\n        val arr = arr.sorted\n\
    \        var low = 0\n        var high = arr.size - 1\n        while(low < high){\n\
    \            while(arr[low] == arr[low+1])\n                low+=1\n         \
    \   while(arr[high] == arr[high-1])\n                high-=1\n            if(low>high)\n\
    \                return 0\n            low+=1\n            high-=1\n        }\n\
    \        arr.size\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpc345i2j8.scala:16:18 ---------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sorted\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpc345i2j8.scala:20:22 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m            \e[33mwhile\e[0m(arr[\e[35mlow\e[0m] == arr[\e\
    [35mlow+\e[31m1\e[0m])\n\e[31m\e[31m   |\e[0m                      ^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: type low\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpc345i2j8.scala:22:22 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m            \e[33mwhile\e[0m(arr[\e[35mhigh\e[0m] ==\
    \ arr[\e[35mhigh-\e[31m1\e[0m])\n\e[31m\e[31m   |\e[0m                      ^^^^\e\
    [0m\n\e[31m   |\e[0m                      Not found: type high\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1660010530
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        if(arr.length == 1){\n            return arr(0)\n      \
    \  }\n        val newArr = arr.sorted\n        var flag = 0\n        var count\
    \ = 0\n        var left = 0\n        var right = newArr.length - 1\n        var\
    \ current: Long = 0\n        while(count <= newArr.length){\n            current\
    \ = newArr(flag)\n            while(current != newArr(flag + 1)){\n          \
    \      if(left == right && current == newArr(flag)) {\n                    count\
    \ += 1\n                }else if(left == right && current != newArr(flag + 1)){\n\
    \                    count -= 1\n                }\n                flag += flag\
    \ + 1\n            }\n            flag = 0\n            count -= 1\n         \
    \   flag += flag + 1\n            left += 1\n            flag += flag + 1\n  \
    \          right -= 1\n            flag += flag + 1\n        }\n        count\
    \ -= 1\n        newArr.length\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 8\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.smallestChange(tmp0o0s5_9v.scala:26)\n\tat Problem$.main(tmp0o0s5_9v.scala:46)\n\
    \tat Problem.main(tmp0o0s5_9v.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010536
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val newArr = arr.map(_.toLong)\n        var newArr2 = newArr.reverse\n\
    \        var minNum = Long.MaxValue\n        for ( i <- 0 to newArr2.length-1\
    \ ; j <- (i+1) to newArr2.length-1 ) {\n            val tempNewArr2 = newArr2.take(i)\n\
    \            val tempNewArr1 = newArr2.drop(i)\n            val tempNewArr = tempNewArr2.zip(tempNewArr1).map{case\
    \ (a,b) => a + b}\n            val min = tempNewArr.min\n            if ( min\
    \ < minNum ) {\n                minNum = min\n            }\n        }\n     \
    \   minNum\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.UnsupportedOperationException: empty.min\n\tat scala.collection.IterableOnceOps.min(IterableOnce.scala:914)\n\
    \tat scala.collection.IterableOnceOps.min$(IterableOnce.scala:912)\n\tat scala.collection.AbstractIterable.min(Iterable.scala:926)\n\
    \tat Problem$.smallestChange$$anonfun$1$$anonfun$1(tmppa23rl0v.scala:22)\n\tat\
    \ scala.runtime.java8.JFunction1$mcVI$sp.apply(JFunction1$mcVI$sp.scala:18)\n\t\
    at scala.collection.immutable.Range.foreach(Range.scala:190)\n\tat Problem$.smallestChange$$anonfun$1(tmppa23rl0v.scala:26)\n\
    \tat scala.runtime.java8.JFunction1$mcVI$sp.apply(JFunction1$mcVI$sp.scala:18)\n\
    \tat scala.collection.immutable.Range.foreach(Range.scala:190)\n\tat Problem$.smallestChange(tmppa23rl0v.scala:26)\n\
    \tat Problem$.main(tmppa23rl0v.scala:30)\n\tat Problem.main(tmppa23rl0v.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner."
  stdout: ''
  timestamp: 1660010537
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr1 = arr.toList\n        val arr2 = arr.reverse\n\n\
    \        val diffList = (arr2.length - arr1.length).max(0)\n\n        var start\
    \ = 0\n        var end = diffList\n        var i = 0\n        while (i <= arr1.length)\
    \ {\n            if (arr1(i) == arr2(end - 1)) {\n                end -= 1\n \
    \           } else if (arr1(i) != arr2(end - 1)) {\n                start = i\n\
    \                end = diffList\n                while (i <= arr1.length && arr1(i)\
    \ != arr2(end - 1)) {\n                    i +=1\n                }\n        \
    \        end -= 1\n            }\n            i += 1\n        }\n        arr2.size\
    \ - start\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: -1\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:115)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.smallestChange(tmp43krzryi.scala:24)\n\tat Problem$.main(tmp43krzryi.scala:39)\n\
    \tat Problem.main(tmp43krzryi.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010537
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val map = new scala.collection.mutable.HashMap[Long, Long]()\n\
    \        arr.foreach { el => map.put(el, el) }\n        val newMap = map.toMap\n\
    \        val reverseMap = newMap.reverse\n        reverseMap.size match {\n  \
    \          case 0 => 0\n            case 1 => 1\n            case _ => {\n   \
    \             val diffCount = reverseMap.size - newMap.size\n                val\
    \ minDiffCount = diffCount.min(arr)\n                minDiffCount.product\n  \
    \          }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmptst9w_4_.scala:18:32 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mreverseMap\e[0m = newMap.reverse\n\
    \e[31m\e[31m   |\e[0m                         ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mvalue reverse is not a member of Map[Long, Long] - did you mean newMap.reversed?\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010534
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val set = arr.foldLeft(Set.empty[Long])((set, v) => if (set.add(v))\
    \ set else set.union(v))\n        val reverseSet = arr.reverse.foldLeft(Set.empty[Long])((set,\
    \ v) => if (set.add(v)) set else set.union(v))\n        if(set.size == arr.size)\n\
    \            0\n        else set.size\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphcuozna_.scala:15:95\
    \ --------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mset\e\
    [0m = arr.foldLeft(Set.empty[\e[35mLong\e[0m])((\e[36mset\e[0m, \e[36mv\e[0m)\
    \ => \e[33mif\e[0m (set.add(v)) set \e[33melse\e[0m set.union(v))\n\e[31m\e[31m\
    \   |\e[0m                                                                   \
    \                            ^\e[0m\n\e[31m   |\e[0m                         \
    \           Found:    (v : Long)\n\e[31m   |\e[0m                            \
    \        Required: scala.collection.Set[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmphcuozna_.scala:16:110 -------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mreverseSet\e[0m = arr.reverse.foldLeft(Set.empty[\e\
    [35mLong\e[0m])((\e[36mset\e[0m, \e[36mv\e[0m) => \e[33mif\e[0m (set.add(v)) set\
    \ \e[33melse\e[0m set.union(v))\n\e[31m\e[31m   |\e[0m                       \
    \                                                                            \
    \           ^\e[0m\n\e[31m   |\e[0m                                    Found:\
    \    (v : Long)\n\e[31m   |\e[0m                                    Required:\
    \ scala.collection.Set[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010536
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val ans = arr.head\n        val index = 0\n        while(index\
    \ < arr.length -1){\n            if(arr(index) != arr(index+1)){\n           \
    \     ans = ans + 1\n            }\n            index++\n        }\n        ans\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmph5ikmjl7.scala:21:19 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m            index++\n\e[31m\e[31m   |\e[0m          \
    \         ^\e[0m\n\e[31m   |\e[0m                   expression expected but \e\
    [31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmph5ikmjl7.scala:19:20\
    \ -----------------------------\e[0m\e[0m\n\e[31m19 |\e[0m                ans\
    \ = ans + \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                Reassignment to val ans\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010533
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        if (arr.isEmpty) 0\n        val n = arr.size\n        //\
    \ If n is odd, we need to add one element and reverse the list before returning\n\
    \        if (n % 2 == 0) (1 + smallestChange(List(rev(arr)))) % n\n        else\
    \ (smallestChange(List(arr.reverse, arr.reverse))) // If n is even, we simply\
    \ need to reverse the list twice\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpa3w6zk2a.scala:18:49 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (n % \e[31m2\e[0m == \e[31m0\e\
    [0m) (\e[31m1\e[0m + smallestChange(List(rev(arr)))) % n\n\e[31m\e[31m   |\e[0m\
    \                                                 ^^^\e[0m\n\e[31m   |\e[0m  \
    \                                               Not found: rev\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpa3w6zk2a.scala:19:38 --------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33melse\e[0m (smallestChange(List(arr.reverse,\
    \ arr.reverse))) \e[34m// If n is even, we simply need to reverse the list twice\e\
    [0m\n\e[31m\e[31m   |\e[0m                                  ^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                  Found:    \e[1m\e[31mList\e[0m\e\
    [1m\e[31m[\e[0mLong\e[1m\e[31m]\e[0m\n\e[31m   |\e[0m                        \
    \          Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpa3w6zk2a.scala:19:51 --------------------\e[0m\e[0m\n\e[31m19\
    \ |\e[0m        \e[33melse\e[0m (smallestChange(List(arr.reverse, arr.reverse)))\
    \ \e[34m// If n is even, we simply need to reverse the list twice\e[0m\n\e[31m\e\
    [31m   |\e[0m                                               ^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                               Found:    \e[1m\e\
    [31mList\e[0m\e[1m\e[31m[\e[0mLong\e[1m\e[31m]\e[0m\n\e[31m   |\e[0m         \
    \                                      Required: Long\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[33m\e\
    [33m-- [E129] Potential Issue Warning: /tmp/tmpa3w6zk2a.scala:15:25 ----------------\e\
    [0m\e[0m\n\e[33m15 |\e[0m        \e[33mif\e[0m (arr.isEmpty) \e[31m0\e[0m\n\e\
    [33m\e[33m   |\e[0m                         ^\e[0m\n\e[33m   |\e[0mA pure expression\
    \ does nothing in statement position; you may be omitting necessary parentheses\n\
    \e[33m   |\e[0m\n\e[33m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 w"
  stdout: ''
  timestamp: 1660010537
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.size\n        if (n <= 1) 0\n        else smallestChangeHelper(arr,\
    \ n)\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpusrlobx4.scala:17:13 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33melse\e[0m smallestChangeHelper(arr, n)\n\
    \e[31m\e[31m   |\e[0m             ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \            Not found: smallestChangeHelper\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010533
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val leftmost = arr.head\n        val rightmost = arr.last\n\
    \        val min = math.min(rightmost-leftmost+1, arr.length-1)\n        val set\
    \ = HashSet[Long]()\n        for (i <- 0 until min) {\n            set.add(arr(i))\n\
    \        }\n        if (min < arr.length) 0 else {\n            var right = 0\n\
    \            var left = arr.length\n            var change = 0\n            while\
    \ (left < right) {\n                if (set.contains(arr(left))) change = change\
    \ + 1\n                left = left + 1\n            }\n            change = min\
    \ - change\n            if (change < 0) change else change = 0\n        }\n  \
    \      change\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpk2eu9ijj.scala:19:26\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mfor\e[0m (i <-\
    \ \e[31m0\e[0m until min) {\n\e[31m\e[31m   |\e[0m                          ^^^\e\
    [0m\n\e[31m   |\e[0m                          Found:    (min : Long)\n\e[31m \
    \  |\e[0m                          Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpk2eu9ijj.scala:30:21 --------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m            change = min - change\n\e[31m\e[31m   |\e\
    [0m                     ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                   \
    \  Found:    Long\n\e[31m   |\e[0m                     Required: Int\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpk2eu9ijj.scala:33:8 -------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        change\n\e[31m\e[31m   |\e[0m        ^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Not found: change\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010540
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length\n        val m = n/2\n        var i =\
    \ 0\n        val plist = arr.iterator.toList\n        plist.reverse foreach (x\
    \ => plist.insert(i, x))\n        if(plist.size < 2) return 0l\n        for(i\
    \ <- 1 until plist.size) {\n            var j = 0\n            val rlist = plist.iterator.toList\n\
    \            val xlist = plist.iterator.toList\n            xlist.reverse.drop(i).take(j).foreach(x\
    \ => rlist.insert(j, x))\n            rlist.reverse.take(i).foreach(x => xlist.insert(j,\
    \ x))\n            val temp = xlist\n            val y = rlist\n            val\
    \ z = temp\n            if(y.head < z.head) return y.head - z.head\n         \
    \   if(y.head > z.head) return z.head - y.head\n        }\n        return 0l\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp4oucucxj.scala:19:42 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        plist.reverse foreach (\e[36mx\e[0m => plist.insert(i,\
    \ x))\n\e[31m\e[31m   |\e[0m                                    ^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m   value insert is not a member of List[Long] - did you mean\
    \ plist.init?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp4oucucxj.scala:25:61\
    \ ------------------------\e[0m\e[0m\n\e[31m25 |\e[0m            xlist.reverse.drop(i).take(j).foreach(\e\
    [36mx\e[0m => rlist.insert(j, x))\n\e[31m\e[31m   |\e[0m                     \
    \                                  ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m   value\
    \ insert is not a member of List[Long] - did you mean rlist.init?\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmp4oucucxj.scala:26:53 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m            rlist.reverse.take(i).foreach(\e[36mx\e[0m\
    \ => xlist.insert(j, x))\n\e[31m\e[31m   |\e[0m                              \
    \                 ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m   value insert is not a member\
    \ of List[Long] - did you mean xlist.init?\n3 errors found\n"
  stdout: ''
  timestamp: 1660010538
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        if (arr.length < 2) {\n            return 0\n        }\n\
    \        val newArr = (arr.head / 2).toLong\n        val change = smallestChange(arr.tail)\n\
    \        if (newArr < change) {\n            change\n        } else {\n      \
    \      change + smallestChange(newArr.toInt - 1)\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp1wtx7d5h.scala:23:36\
    \ --------------------\e[0m\e[0m\n\e[31m23 |\e[0m            change + smallestChange(newArr.toInt\
    \ - \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m                                    ^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                    Found:    Int\n\e[31m\
    \   |\e[0m                                    Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010539
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        var n = arr.length\n        var i = 0\n        var j = 1\n\
    \        var temp = List[Long]()\n        var currentValue = arr(i)\n\n      \
    \  while (i < n) {\n            while(j < n && currentValue > arr(j)) {\n    \
    \            j+=1\n            }\n            i += 1\n            temp = temp.drop(j+1).concat(currentValue\
    \ - arr(j)).take(j+1).reverse\n            currentValue = arr(i)\n        }\n\
    \        arr.take(i).foldLeft(0) { (acc, x) => acc.min }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphjm36jbn.scala:26:41\
    \ --------------------\e[0m\e[0m\n\e[31m26 |\e[0m            temp = temp.drop(j+\e\
    [31m1\e[0m).concat(currentValue - arr(j)).take(j+\e[31m1\e[0m).reverse\n\e[31m\e\
    [31m   |\e[0m                                         ^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                         Found:    Long\n\e\
    [31m   |\e[0m                                         Required: IterableOnce[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphjm36jbn.scala:29:46\
    \ --------------------\e[0m\e[0m\n\e[31m29 |\e[0m        arr.take(i).foldLeft(\e\
    [31m0\e[0m) { (\e[36macc\e[0m, \e[36mx\e[0m) => acc.min }\n\e[31m\e[31m   |\e\
    [0m                                              ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                                              Found:    Int => Int\n\e[31m  \
    \ |\e[0m                                              Required: Int\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660010541
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        var n = arr.length\n        var m = 0\n        var c = 0\n\
    \        var k = arr.length\n        while (k >= 0 && m == 0) {\n            n\
    \ -= 1\n            if (n > 0) {\n                arr(n) = arr(n)\n          \
    \      m += 1\n                k -= 1\n                c += 1\n            }\n\
    \        }\n        var ret = 0\n        while (k > 0 && m > 0) {\n          \
    \  k -= 1\n            m -= 1\n            ret += c\n        }\n        ret +=\
    \ m\n        ret\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpsbhsqhgl.scala:22:16 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m                arr(n) = arr(n)\n\e[31m\e[31m   |\e[0m\
    \                ^^^\e[0m\n\e[31m   |\e[0m  value update is not a member of List[Long]\
    \ - did you mean arr.updated?\n1 error found\n"
  stdout: ''
  timestamp: 1660010541
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val len = arr.length\n        var smallest = 0\n       \
    \ val arr = arr.reverse\n        for(i <- 0 to arr.length - 1){\n            val\
    \ currentElement = arr(i)\n            if(currentElement == arr[len - 1 - i]){\n\
    \                smallest = smallest + 1\n            }\n        }\n        smallest\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp2p0rxln7.scala:17:18 ---------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.reverse\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660010538
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val m  = arr.size\n        val n  = arr.size % 2\n     \
    \   val left = arr.init\n        val right = arr.tail\n        var l = 0\n   \
    \     val r = 0\n        while (l <= (m / 2) ) {\n            val mid = (l + r)\
    \ / 2\n            if ( left > right ) {\n                val temp = right\n \
    \               right = left\n                left = temp\n            }\n   \
    \         if ( left < right ) {\n                val temp = left\n           \
    \     left = right\n                right = temp\n            }\n            if(\
    \ left == right) {\n                if( left == mid ) {\n                    l++\
    \ ;\n                }\n                if ( right == mid ) {\n              \
    \      r++ ;\n                }\n            }\n        }\n        ( r - l )\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmps35p61zw.scala:35:24 ---------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m                    l++ ;\n\e[31m\e[31m   |\e[0m    \
    \                    ^\e[0m\n\e[31m   |\e[0m                        expression\
    \ expected but \e[31m';'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmps35p61zw.scala:38:24 ---------------------------\e[0m\e[0m\n\e[31m38\
    \ |\e[0m                    r++ ;\n\e[31m\e[31m   |\e[0m                     \
    \   ^\e[0m\n\e[31m   |\e[0m                        expression expected but \e\
    [31m';'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmps35p61zw.scala:23:22\
    \ ------------------------\e[0m\e[0m\n\e[31m23 |\e[0m            \e[33mif\e[0m\
    \ ( left > right ) {\n\e[31m\e[31m   |\e[0m                 ^^^^^^\e[0m\n\e[31m\
    \   |\e[0mvalue > is not a member of List[Long], but could be made available as\
    \ an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports\
    \ might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m  import math.Ordered.orderingToOrdered\n\e[31m   |\e[0m  import math.Ordering.Implicits.infixOrderingOps\n\
    \e[31m   |\e[0m\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmps35p61zw.scala:25:22\
    \ -----------------------------\e[0m\e[0m\n\e[31m25 |\e[0m                right\
    \ = left\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                Reassignment to val right\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E052] Type Error: /tmp/tmps35p61zw.scala:26:21 -----------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m                left = temp\n\e[31m\e[31m   |\e[0m  \
    \              ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                Reassignment to\
    \ val left\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmps35p61zw.scala:28:22\
    \ ------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        "
  stdout: ''
  timestamp: 1660010544
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val changes = arr.foldRight(List[Long]())(\n           \
    \ (arr, acc) => arr.foldRight(acc.reverse)(\n                (arr, acc) => if\
    \ (acc.head == acc.last) acc + 1 else acc\n            ))\n\n        val length\
    \ = arr.size\n        val result = changes.length\n        if (result > length)\n\
    \            changes.length\n        else if (result < length)\n            result\n\
    \        else\n            0\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpv34a9f9g.scala:16:30 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m            (\e[36marr\e[0m, \e[36macc\e[0m) => arr.foldRight(acc.reverse)(\n\
    \e[31m\e[31m   |\e[0m                          ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                          value foldRight is not a member of Long\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660010541
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        var arr = arr\n        val maxCount = arr.length - 1\n \
    \       // Scan the array once\n        var min = maxCount\n        var changes\
    \ = 0\n        while(arr.nonEmpty) {\n            val first = arr.head\n     \
    \       val second = arr.last\n            val third = arr.take(2).last\n    \
    \        if (first.equals(second) && first.equals(third) || second.equals(third))\
    \ {\n                arr.remove(first)\n                arr.remove(second)\n \
    \               arr.remove(third)\n                changes += 1\n            }\n\
    \            else if(first.equals(second)) {\n                arr.remove(first)\n\
    \                changes += 1\n            }\n            else {\n           \
    \     arr.remove(second)\n                changes += 1\n            }\n      \
    \      if(changes > min) {\n                min = changes\n            }\n   \
    \     }\n        min\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp10456dgo.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mvar\e[0m \e[36marr\e[0m = arr\n\e[31m\e\
    [31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                  Recursive\
    \ \e[33mvariable\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010540
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.sortBy(x => x)\n        var count = 0\n  \
    \      var start = 0\n        while (start < arr.length - 1) {\n            if\
    \ (arr[start] == arr[arr.length - 1 - start]) {\n                count += 1\n\
    \            } else {\n                count = 0\n            }\n            start\
    \ = start + count\n        }\n        arr.length\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpxzuijzdm.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(\e\
    [36mx\e[0m => x)\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e\
    [0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpxzuijzdm.scala:19:20\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m            \e[33mif\e[0m\
    \ (arr[\e[35mstart\e[0m] == arr[arr.length \e[35m-\e[0m \e[31m1\e[0m \e[35m-\e\
    [0m \e[35mstart\e[0m]) {\n\e[31m\e[31m   |\e[0m                    ^^^^^\e[0m\n\
    \e[31m   |\e[0m                    Not found: type start\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010540
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        arr.foldLeft((0, List[Long]()))((acc, val) => {\n      \
    \      val minChange = acc._1 + 1\n            val newList = (acc._2 :+ val).reverse\n\
    \            val isPalendromic = newList == newList.reverse\n            if(isPalendromic)\
    \ minChange else minChange\n        })\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpcw7s6hux.scala:15:46 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        arr.foldLeft((\e[31m0\e[0m, List[\e[35mLong\e\
    [0m]()))((\e[36macc\e[0m, \e[33mval\e[0m) => {\n\e[31m\e[31m   |\e[0m        \
    \                                      ^^^\e[0m\n\e[31m   |\e[0m             \
    \                          expression expected but \e[31mval\e[0m found\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpcw7s6hux.scala:17:37 ---------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m            \e[33mval\e[0m \e[36mnewList\e[0m = (acc._2\
    \ :+ \e[33mval\e[0m).reverse\n\e[31m\e[31m   |\e[0m                          \
    \           ^^^\e[0m\n\e[31m   |\e[0m                                     expression\
    \ expected but \e[31mval\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpcw7s6hux.scala:19:30 --------------------\e[0m\e[0m\n\e[31m19\
    \ |\e[0m            \e[33mif\e[0m(isPalendromic) minChange \e[33melse\e[0m minChange\n\
    \e[31m\e[31m   |\e[0m                              ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                              Found:    (minChange : Int)\n\e[31m   |\e[0m\
    \                              Required: (Int, List[Long])\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpcw7s6hux.scala:19:45 --------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m            \e[33mif\e[0m(isPalendromic) minChange \e\
    [33melse\e[0m minChange\n\e[31m\e[31m   |\e[0m                               \
    \              ^^^^^^^^^\e[0m\n\e[31m   |\e[0m                               \
    \              Found:    (minChange : Int)\n\e[31m   |\e[0m                  \
    \                           Required: (Int, List[Long])\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n4 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010544
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n       var ans = 1\n       var len = arr.length\n       var maxLen\
    \ = len\n       var changes = 1\n       var i = len - 1\n       while(i >= 0){\n\
    \          if((arr(i) != arr(len - 1 - i))  && (arr(i) != (arr[len - 1 - i]))\
    \  && (arr(i) != (arr(i) + 1))) {\n            ans = ans + 1\n          }\n  \
    \        else {\n            changes = changes + 1\n          }\n          maxLen\
    \ = maxLen - 1\n          i = i - 1\n       }\n       (ans + changes)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpjanqze15.scala:21:70 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m          \e[33mif\e[0m((arr(i) != arr(len - \e[31m1\e\
    [0m - i))  && (arr(i) != (arr[\e[35mlen\e[0m \e[35m-\e[0m \e[31m1\e[0m \e[35m-\e\
    [0m \e[35mi\e[0m]))  && (arr(i) != (arr(i) + \e[31m1\e[0m))) {\n\e[31m\e[31m \
    \  |\e[0m                                                                    \
    \  ^\e[0m\n\e[31m   |\e[0m                                                   \
    \    Not found: type -\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010541
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val newSet = arr.groupBy(x => x % 10).mapValues(x => x).mapValues(x\
    \ => x).map(x => x._2.size).min\n        var count : Long = 0\n        for (x\
    \ <- newSet) {\n            if (x == 2) {\n                count += 1\n      \
    \      }\n        }\n        return count\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpuqktbuqp.scala:17:18 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mfor\e[0m (x <- newSet) {\n\e[31m\e[31m\
    \   |\e[0m                  ^^^^^^\e[0m\n\e[31m   |\e[0m                  value\
    \ foreach is not a member of Int\n1 error found\n"
  stdout: ''
  timestamp: 1660010545
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        def minSwap(i : Long, j : Long, arr : List[Long], result\
    \ : Long): Long = {\n            // base case\n            if (i < 0 || j >= arr.length)\
    \ return result\n            val swap = arr(i)\n            arr(i) = arr(j)\n\
    \            arr(j) = swap\n            minSwap(i + 1, j - 1, arr, result)\n \
    \       }\n        minSwap(0, 0, arr, arr.size)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmptiuxqjhr.scala:18:27\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m            \e[33mval\e[0m \e\
    [36mswap\e[0m = arr(i)\n\e[31m\e[31m   |\e[0m                           ^\e[0m\n\
    \e[31m   |\e[0m                           Found:    (i : Long)\n\e[31m   |\e[0m\
    \                           Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmptiuxqjhr.scala:19:12 ------------------------\e[0m\e\
    [0m\n\e[31m19 |\e[0m            arr(i) = arr(j)\n\e[31m\e[31m   |\e[0m       \
    \     ^^^\e[0m\n\e[31m   |\e[0m  value update is not a member of List[Long] -\
    \ did you mean arr.updated?\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmptiuxqjhr.scala:19:25\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            arr(i) = arr(j)\n\
    \e[31m\e[31m   |\e[0m                         ^\e[0m\n\e[31m   |\e[0m        \
    \                 Found:    (j : Long)\n\e[31m   |\e[0m                      \
    \   Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmptiuxqjhr.scala:20:12\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m            arr(j) = swap\n\
    \e[31m\e[31m   |\e[0m            ^^^\e[0m\n\e[31m   |\e[0m  value update is not\
    \ a member of List[Long] - did you mean arr.updated?\n4 errors found\n"
  stdout: ''
  timestamp: 1660010546
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val maxChanges = arr.map(_.toString.toLong).map (x => ArrayBuffer(x.reverse).map(_.toString.toLong).filterNot(_\
    \ => x == 0)).flatten.min\n        arr.map(_.toString.toLong).filterNot(x => x\
    \ == 0).toString.toLong(maxChanges)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpofa7nawz.scala:15:76 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mmaxChanges\e[0m = arr.map(_.toString.toLong).map\
    \ (\e[36mx\e[0m => ArrayBuffer(x.reverse).map(_.toString.toLong).filterNot(_ =>\
    \ x == \e[31m0\e[0m)).flatten.min\n\e[31m\e[31m   |\e[0m                     \
    \                                                     ^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0m                                   value reverse is not a member of Long\n\
    \e[31m\e[31m-- [E050] Type Error: /tmp/tmpofa7nawz.scala:16:67 -----------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        arr.map(_.toString.toLong).filterNot(\e[36mx\e\
    [0m => x == \e[31m0\e[0m).toString.toLong(maxChanges)\n\e[31m\e[31m   |\e[0m \
    \       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m        \e[33mmethod\e[0m \e[35mtoLong\e[0m in \e[33mclass\e[0m\
    \ \e[35mStringOps\e[0m does not take parameters\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010546
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val size = arr.length\n        val palindromicList = arr.toSet.toList.sorted\n\
    \n        def getMinimumChangeCount(startIndex : Int, endIndex : Int, changeCount\
    \ : Int) : Int\n            = if (startIndex == endIndex) changeCount\n      \
    \      else if (palindromicList.take(startIndex).reverse != palindromicList.drop(endIndex))\
    \ changeCount\n            else getMinimumChangeCount(startIndex + 1, endIndex,\
    \ changeCount + 1)\n\n        getMinimumChangeCount(0, size - 1, 0)\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpc6f13kx7.scala:26)\n\tat Problem.main(tmpc6f13kx7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010548
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        // Solution using a mutable TreeSet\n        val map = new\
    \ mutable.TreeSet[Long]()\n        val mapIter = map.iterator\n        var counter\
    \ = 0\n        for(x <- arr) {\n            if(map.contains(x))\n            \
    \    mapIter = map.remove(x)\n            else {\n                counter += 1\n\
    \                map += x\n            }\n        }\n        mapIter.last\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp5oigg54y.scala:16:22 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mmap\e[0m = \e[33mnew\e[0m\
    \ mutable.TreeSet[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                  \
    \    ^^^^^^^\e[0m\n\e[31m   |\e[0m                      Not found: mutable\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmp5oigg54y.scala:21:24 -----------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m                mapIter = map.remove(x)\n\e[31m\e[31m\
    \   |\e[0m                ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \          Reassignment to val mapIter\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010543
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val lenArr = arr.length\n        var min = lenArr\n    \
    \    var cur = 0\n        var next = 0\n        while (cur < lenArr) {\n     \
    \       next += 1\n            val mid = (cur + next) / 2 // mid = (cur + next)\
    \ / 2\n            // val mid = cur + next\n            val tempArr = arr.take(mid).reverse\
    \ + arr.drop(mid).reverse\n            if (tempArr == arr) min = (mid * 2)\n \
    \           else min = (Math.min(min, arr.size - mid))\n            cur = mid\n\
    \        }\n        require(min != 0)\n        lenArr * 2\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp1prpgnnk.scala:23:48 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            \e[33mval\e[0m \e[36mtempArr\e[0m = arr.take(mid).reverse\
    \ + arr.drop(mid).reverse\n\e[31m\e[31m   |\e[0m                          ^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue + is not a member of List[Long], but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e\
    [0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import\
    \ math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n1 error found\n"
  stdout: ''
  timestamp: 1660010547
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        var i = 0\n        var min_val = 0l\n        var max_val\
    \ = arr.last\n        while(i < arr.length) {\n            if(max_val == arr(i))\
    \ {\n                max_val = arr(i)\n            }\n            if(min_val >\
    \ max_val){\n                min_val = max_val\n            }\n            else{\n\
    \                max_val = min_val\n            }\n            i = i + 1\n   \
    \     }\n        return min_val\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpb9hqo885.scala:33)\n\tat Problem.main(tmpb9hqo885.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010549
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length\n        val m = arr.head\n        val\
    \ count = (0 until n).filter (x => x != m).map (x => 1 until n).map (x => x diff\
    \ m by -1).filter (x => x == 0).sum\n        if (n == 1)\n            0\n    \
    \    else if (count < m)\n            -1\n        else\n            m\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp_puh0317.scala:17:91\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mcount\e\
    [0m = (\e[31m0\e[0m until n).filter (\e[36mx\e[0m => x != m).map (\e[36mx\e[0m\
    \ => \e[31m1\e[0m until n).map (\e[36mx\e[0m => x diff m by -\e[31m1\e[0m).filter\
    \ (\e[36mx\e[0m => x == \e[31m0\e[0m).sum\n\e[31m\e[31m   |\e[0m             \
    \                                                                            \
    \  ^\e[0m\n\e[31m   |\e[0m                                     Found:    (m :\
    \ Long)\n\e[31m   |\e[0m                                     Required: scala.collection.Seq[Int]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- Error: /tmp/tmp_puh0317.scala:17:124 ----------------------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mcount\e[0m = (\e[31m0\e\
    [0m until n).filter (\e[36mx\e[0m => x != m).map (\e[36mx\e[0m => \e[31m1\e[0m\
    \ until n).map (\e[36mx\e[0m => x diff m by -\e[31m1\e[0m).filter (\e[36mx\e[0m\
    \ => x == \e[31m0\e[0m).sum\n\e[31m\e[31m   |\e[0m                           \
    \                                                                            \
    \                     ^\e[0m\n\e[31m   |\e[0mambiguous given instances: both \e\
    [33mobject\e[0m \e[35mShortIsIntegral\e[0m in \e[33mobject\e[0m \e[35mNumeric\e\
    [0m and \e[33mobject\e[0m \e[35mIntIsIntegral\e[0m in \e[33mobject\e[0m \e[35mNumeric\e\
    [0m match type Numeric[B] of parameter num of \e[33mmethod\e[0m \e[35msum\e[0m\
    \ in \e[33mtrait\e[0m \e[35mIterableOnceOps\e[0m\n2 errors found\n"
  stdout: ''
  timestamp: 1660010548
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        var ans = 0\n        var temp = 0l\n        var i = 0\n\
    \        var j = 0\n        var lastIndex = arr.length - 1\n        while (i <\
    \ lastIndex && j < lastIndex) {\n            ans = min(ans, temp + arr(i) - arr(j))\n\
    \            temp = temp + arr(i)\n            i += 1\n            j += 1\n  \
    \      }\n        ans\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpevdndcpz.scala:21:27\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m            ans = min(ans, temp\
    \ + arr(i) - arr(j))\n\e[31m\e[31m   |\e[0m                           ^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                           Found:    Long\n\e[31m   |\e[0m\
    \                           Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010548
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        var palindromicLength = 0\n        for(i<- arr.length) {\n\
    \            val temp = arr(i)\n            for(j<- i until (arr.length)) {\n\
    \                if(arr(j) > temp) {\n                    palindromicLength +=\
    \ 1\n                    arr(j) = temp\n                }\n            }\n   \
    \     }\n        if(palindromicLength == 1) palindromicLength else\n         \
    \   if(arr.length == palindromicLength) 0\n            else palindromicLength\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpw8hwddto.scala:16:16 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mfor\e[0m(i<- arr.length) {\n\e[31m\e[31m\
    \   |\e[0m                ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                value\
    \ foreach is not a member of Int\n1 error found\n"
  stdout: ''
  timestamp: 1660010549
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        var n = arr.length\n        var min = arr.head\n       \
    \ var ans = 0\n        while(n > 1) {\n            ans += (arr.head - min)\n \
    \           min = arr.last\n            n -= 1\n        }\n        ans\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpyf_k783m.scala:19:16 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m            ans += (arr.head - min)\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^\e[0m\n\e[31m   |\e[0m            value += is not a member\
    \ of Int - did you mean Int.!=?\n1 error found\n"
  stdout: ''
  timestamp: 1660010548
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val result = mutable.HashSet[Long]()\n        var index\
    \ = 0\n        while(index < arr.length) {\n            val tmp = arr(index)\n\
    \            if(result.contains(tmp)) {\n                val min = result.iterator\n\
    \                        .zip(arr.iterator)\n                        .takeWhile(t\
    \ => t._1 < t._2)\n                        .map(t => t._2)\n                 \
    \       .mkString(\"\")\n                if(min != arr(index)) {\n           \
    \         index = index + 1\n                }\n                result.clear()\n\
    \                result += tmp\n            }\n            else {\n          \
    \      result.clear()\n                result += tmp\n            }\n        }\n\
    \        if(result.size != arr.length)\n            0\n        else\n        \
    \    result.size\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmplkfo9k5w.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.HashSet[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010546
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val l = arr.reverse\n        var count = 0\n        for\
    \ (i<-0 until arr.size) {\n            if (l.forall(x=>x<arr(i) && arr(i) != x))\
    \ {\n                count += 1\n                if (count > 1) return count\n\
    \            }\n        }\n        return 0\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpr4afu5yu.scala:26)\n\tat Problem.main(tmpr4afu5yu.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010551
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val maxElementsRequired = arr.length\n        val maxElementsRequiredToMakePalindromic\
    \ = maxElementsRequired / 2\n        val result = maxElementsRequiredToMakePalindromic\n\
    \        val changeList = mutable.ListBuffer[Long]()\n        val backwards =\
    \ new java.util.TreeSet[Long]()\n        val forwards = new java.util.TreeSet[Long]()\n\
    \        val backwardsSetSize = backwards.size\n        val forwardsSetSize =\
    \ forwards.size\n        val maxSetSize = backwardsSetSize + forwardsSetSize\n\
    \n        if (backwardsSetSize == 0) {\n            if (forwardsSetSize == 0)\
    \ {\n                result = 0\n            } else {\n                result\
    \ = forwardsSetSize - 1\n            }\n        } else if (forwardsSetSize ==\
    \ 0) {\n            result = backwardsSetSize - 1\n        }\n\n        for( i\
    \ <- 0 until arr.length ) {\n            val currentValue = arr(i)\n         \
    \   if (backwards.contains(currentValue)) {\n                val index = backwards.indexOf(currentValue)\n\
    \                val change = maxElementsRequired - index\n                backwards.remove(currentValue)\n\
    \                changeList.add (change.toLong)\n                maxElementsRequired\
    \ -= change.toLong\n            } else {\n                val index = forwards.indexOf(currentValue)\n\
    \                val change = maxElementsRequired - index\n                forwards.remove(currentValue)\n\
    \                changeList.add (change.toLong)\n                maxElementsRequired\
    \ -= change.toLong\n            }\n        }\n        if(changeList.size > 0)\
    \ {\n            result = math.min(changeList.min(), result)\n        }\n    \
    \    result\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq6szomm8.scala:18:25 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mchangeList\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                         ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                         Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E052] Type Error: /tmp/tmpq6szomm8.scala:27:23 -----------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m                result = \e[31m0\e[0m\n\e[31m\e[31m \
    \  |\e[0m                ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                Reassignment\
    \ to val result\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmpq6szomm8.scala:29:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m29 |\e[0m                result\
    \ = forwardsSetSize - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                Reassignment to val result\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E052] Type Error: /tmp/tmpq6szomm8.scala:32:19 -----------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m            result = backwardsSetSize - \e[31m1\e[0m\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m            Reassignment to val result\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpq6szomm8.scala:38:38 ------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m                \e[33mval\e[0m \e[36mindex\e[0m = backwards.indexOf(currentValue)\n\
    \e[31m\e[31m   |\e[0m                            ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                value indexOf is not a member of java.util.TreeSet[Long]\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpq6szomm8.scala:42:36 ------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m                maxElementsRequired -= change.toLong\n\
    \e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e["
  stdout: ''
  timestamp: 1660010552
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length\n        val nums = arr.reverse.tail.filter(_\
    \ > 0).reverse\n        val palinNums = nums.toList\n        val palinNumsLen\
    \ = palinNums.length\n        val changes = (palinNumsLen - palinNums.lastIndexWhere(_\
    \ == palinNums(palinNumsLen - 1)) ) / n\n        val n = palinNumsLen / 2\n  \
    \      val leftNums = palinNums.take(n)\n        val rightNums = palinNums.drop(n)\n\
    \        val leftChange = smallestChange(leftNums)\n        val rightChange =\
    \ smallestChange(rightNums)\n        val result = leftChange + changes + rightChange\n\
    \        leftChange + changes + rightChange\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpl646z5pi.scala:20:12 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = palinNumsLen /\
    \ \e[31m2\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mn is already defined as \e[33mvalue\e[0m \e[35mn\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n1 error found\n"
  stdout: ''
  timestamp: 1660010548
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val len = arr.length\n        val arr2 = arr.toList\n  \
    \      val len = arr.length\n        val arr2reversed = arr2.reverse\n       \
    \ var count = 0\n        var index = len - 1 \n        while(index >=0 && count\
    \ < len / 2) \n        {\n            if(arr2reversed(index) != arr(index)) \n\
    \            {\n                count = count + 1\n                index = index\
    \ - 1\n            } else \n            {\n                index = index - 1\n\
    \            }\n        }\n        if (count < len / 2) \n        {\n        \
    \    count = count + 1\n        }\n        count\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpvujetee8.scala:17:12 ---------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mlen\e[0m = arr.length\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mlen is already\
    \ defined as \e[33mvalue\e[0m \e[35mlen\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010549
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val maxLength = arr.max\n        var changes = mutable.ListBuffer.empty[Int]\n\
    \        var currentMax = 0l\n        var i = 0\n        while(i < maxLength){\n\
    \            currentMax = arr(i)\n            var j = 0\n            while(j <\
    \ i){\n                if(arr(j) < currentMax){\n                    if(changes(0)\
    \ < j-i){\n                        changes.update(0, j)-i\n                  \
    \  }\n                    else{\n                        currentMax = arr(j)\n\
    \                    }\n                }\n                else{\n           \
    \         if(arr(j) == currentMax){\n                        currentMax = arr(j)\n\
    \                    }\n                    else{\n                        if(arr(j)\
    \ > currentMax){\n                            currentMax = arr(j)\n          \
    \              }\n                    }\n                }\n                j+=1\n\
    \            }\n            changes += currentMax - i\n            i+=1\n    \
    \    }\n        changes.length\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp92id4cp0.scala:16:22 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mvar\e[0m \e[36mchanges\e[0m = mutable.ListBuffer.empty[\e\
    [35mInt\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660010549
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        // O(n) time and space\n        var i = 0\n        var j\
    \ = 0\n        while(i < arr.length){\n            if(arr(i).equals(arr(arr.length\
    \ - 1 - i))){\n                i++;\n            } else {\n                j =\
    \ j + 1;\n                if(j >= arr.length - i){\n                    i = j;\n\
    \                    j = 0;\n                }\n            }\n        }\n   \
    \     return j;\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpvznusnn7.scala:20:19 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m                i++;\n\e[31m\e[31m   |\e[0m         \
    \          ^\e[0m\n\e[31m   |\e[0m                   expression expected but \e\
    [31m';'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010549
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        // Your code here\n        var count = 0\n        for (i\
    \ <- arr.indices){\n            if (arr(i) < arr(arr.length-i-1)) count += 1\n\
    \        }\n        if (count > 1) count - 1\n        else {\n            val\
    \ a = arr.sortWith(_ <=> _)\n            if (a(0) != a(a.length-1))\n        \
    \        count\n            else\n                0\n        }\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpa6qlezjo.scala:22:35 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m            \e[33mval\e[0m \e[36ma\e[0m = arr.sortWith(_\
    \ <=> _)\n\e[31m\e[31m   |\e[0m                                 ^^^^^\e[0m\n\e\
    [31m   |\e[0m                value <=> is not a member of Long - did you mean\
    \ _$1.<=?\n1 error found\n"
  stdout: ''
  timestamp: 1660010552
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val palindromics = arr.groupBy(x => x)\n            .map(x\
    \ => x._2.size).min\n        val changes = arr.length - palindromics\n       \
    \ changes * palindromics\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpq1jxuhrk.scala:21)\n\tat Problem.main(tmpq1jxuhrk.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010555
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val result = scala.math.min(arr.length, arr.length)\n  \
    \      var i : Int = 0\n        var j : Int = 0\n        val resultList = mutable.ArrayBuffer(arr)\n\
    \        while (i < arr.length) {\n            while (j < arr.length) {\n    \
    \            if (arr(i) == arr(j)) {\n                    resultList.insert(i,\
    \ arr(j))\n                    resultList.insert(j, arr(i))\n                \
    \    resultList.remove(i)\n                    resultList.remove(j)\n        \
    \        }\n                j++\n            }\n            i += 1\n         \
    \   j = 0\n        }\n        resultList.min\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp3svlv7io.scala:27:19 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m                j++\n\e[31m\e[31m   |\e[0m          \
    \         ^\e[0m\n\e[31m   |\e[0m                   expression expected but \e\
    [31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp3svlv7io.scala:18:25\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mresultList\e[0m = mutable.ArrayBuffer(arr)\n\e[31m\e[31m   |\e[0m        \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                         Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010550
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val palindromicList = arr.sliding(2).map(_.map(x => x +\
    \ x).toSet).toList.sorted\n        palindromicList.takeWhile(x => arr.count(_\
    \ == x) > 0).reduceLeft(_ + _)\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpuztva12t.scala:16:49 -----------------------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        palindromicList.takeWhile(\e[36mx\e[0m => arr.count(_\
    \ == x) > \e[31m0\e[0m).reduceLeft(_ + _)\n\e[31m\e[31m   |\e[0m             \
    \                                    ^^^^^^\e[0m\n\e[31m   |\e[0m     Values of\
    \ types Long and Set[Long] cannot be compared with == or !=\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpuztva12t.scala:16:77 --------------------\e[0m\e\
    [0m\n\e[31m16 |\e[0m        palindromicList.takeWhile(\e[36mx\e[0m => arr.count(_\
    \ == x) > \e[31m0\e[0m).reduceLeft(_ + _)\n\e[31m\e[31m   |\e[0m             \
    \                                                                ^\e[0m\n\e[31m\
    \   |\e[0m                                             Found:    (_$4 : Set[Long])\n\
    \e[31m   |\e[0m                                             Required: Long\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010555
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val maxSize = arr.size\n        var smallestChange = 0\n\
    \        var newArr: List[Long] = null\n        if (arr.isEmpty) {\n         \
    \   return 0\n        } else {\n            val midIndex = arr.size / 2\n    \
    \        val midVal = arr.head\n            val leftPart = arr.drop(midIndex)\n\
    \            val rightPart = arr.take(midIndex)\n            val changeLeft =\
    \ smallestChange(leftPart)\n            val changeRight = smallestChange(rightPart)\n\
    \            val maxChange = max(changeLeft, changeRight)\n            if (maxChange\
    \ > 0) {\n                val middlePart = if (maxSize % 2 == 1) arr.take(maxSize/2)\
    \ else arr.take(maxSize/2+1).toList\n                if (changeLeft == changeRight)\
    \ {\n                    newArr = middlePart.reverse\n                    smallestChange\
    \ = changeLeft\n                } else {\n                    newArr = middlePart.reverse\n\
    \                    smallestChange = changeRight\n                }\n       \
    \     } else {\n                newArr = arr\n            }\n        }\n     \
    \   return smallestChange\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E050] Type Error: /tmp/tmp36gtl3z4.scala:25:29 -----------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m            \e[33mval\e[0m \e[36mchangeLeft\e[0m = smallestChange(leftPart)\n\
    \e[31m\e[31m   |\e[0m                             ^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                        \e[33mvariable\e[0m \e[35msmallestChange\e[0m\
    \ does not take parameters\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E050] Type Error:\
    \ /tmp/tmp36gtl3z4.scala:26:30 -----------------------------\e[0m\e[0m\n\e[31m26\
    \ |\e[0m            \e[33mval\e[0m \e[36mchangeRight\e[0m = smallestChange(rightPart)\n\
    \e[31m\e[31m   |\e[0m                              ^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                        \e[33mvariable\e[0m \e[35msmallestChange\e[0m\
    \ does not take parameters\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        arr.foldLeft(0l){ (a,b) => if (b == a || b < a) b else a\
    \ }\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpnwmh0mo7.scala:18)\n\tat Problem.main(tmpnwmh0mo7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010556
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        // Step 1: Find maximum and minimum value\n        var minValue\
    \ = arr(0)\n        var maxValue = arr(0)\n        for (i <- 1 to arr.length)\
    \ {\n            if (arr(i) < minValue)\n                minValue = arr(i)\n \
    \           if (arr(i) > maxValue)\n                maxValue = arr(i)\n      \
    \  }\n\n        // Step 2: Create empty map\n        val palindromicMap = new\
    \ collection.mutable.LinkedHashMap[Long, Long]()\n\n        // Step 3: Put min\
    \ and max in the map and make them equal\n        palindromicMap.put(minValue,\
    \ maxValue)\n        palindromicMap.put(maxValue, minValue)\n\n        // Step\
    \ 4: Iterate over the list and remove elements from map and map values\n     \
    \   // to remove duplicates\n        for (i <- 0 until arr.length) {\n       \
    \     var key = arr(i)\n            var value = palindromicMap.get(key)\n\n  \
    \          // Step 5: Remove from map\n            if (value != null) {\n    \
    \            palindromicMap.remove(value)\n            }\n\n            // Step\
    \ 6: Remove from map values\n            if (value != null) {\n              \
    \  palindromicMap.put(value, key)\n            }\n        }\n\n        // Step\
    \ 7: Get length of palindromicMap\n        var length : Long = palindromicMap.length\n\
    \n        // Step 8: Check if length is odd\n        if (length % 2 != 0)\n  \
    \          length -= 1\n\n        // Step 9: Return length\n        length\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpboeyu060.scala:40:38\
    \ --------------------\e[0m\e[0m\n\e[31m40 |\e[0m                palindromicMap.remove(value)\n\
    \e[31m\e[31m   |\e[0m                                      ^^^^^\e[0m\n\e[31m\
    \   |\e[0m                                      Found:    (value : Option[Long])\n\
    \e[31m   |\e[0m                                      Required: Long\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpboeyu060.scala:45:35 --------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m                palindromicMap.put(value, key)\n\e[31m\e\
    [31m   |\e[0m                                   ^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                                 Found:    (value : Option[Long])\n\e[31m   |\e\
    [0m                                   Required: Long\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpboeyu060.scala:50:43 ------------------------\e\
    [0m\e[0m\n\e[31m50 |\e[0m        \e[33mvar\e[0m \e[36mlength\e[0m : \e[35mLong\e\
    [0m = palindromicMap.length\n\e[31m\e[31m   |\e[0m                           \
    \ ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue length is not a member of scala.collection.mutable.LinkedHashMap[Long,\
    \ Long]\n3 errors found\n"
  stdout: ''
  timestamp: 1660010557
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        var palindromic = arr.filter(_ % 2 == 0).filter(_ % 2 ==\
    \ 1).filter(_ % 2 != 0).reverse\n        val reversed = palindromic.reverse\n\
    \        val smallestChange = reversed.indexWhere(x => x == palindromic(0))\n\
    \        val difference = reversed.length - smallestChange\n        if (difference\
    \ == 0) 0\n        else smallestChange\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp030ydr_u.scala:23)\n\tat Problem.main(tmp030ydr_u.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010558
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr2 = arr.toArray\n        val len = arr.length\n \
    \       val count = new scala.collection.mutable.HashMap[Long, Int]()\n      \
    \  var change = 0\n        var count = 0\n        var minChange = 0\n        var\
    \ index = len - 1 // to find last index of any element of arr\n        while (index\
    \ >= 0) {\n            if (count.contains(arr2[index])) {\n                val\
    \ value = count.get(arr2[index])\n                val newCount = value + 1\n \
    \               if (newCount > minChange) {\n                    minChange = newCount\n\
    \                    change = value\n                }\n            } else {\n\
    \                change.value = change.value.toInt + 1\n                count\
    \ += change\n                change = 0\n                minChange = count.min\n\
    \            }\n            index -= 1\n        }\n        minChange\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpd6qp03ik.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mvar\e[0m \e[36mcount\e[0m = \e[31m0\e[0m\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mcount is already\
    \ defined as \e[33mvalue\e[0m \e[35mcount\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpd6qp03ik.scala:23:36\
    \ ------------------------\e[0m\e[0m\n\e[31m23 |\e[0m            \e[33mif\e[0m\
    \ (count.contains(arr2[\e[35mindex\e[0m])) {\n\e[31m\e[31m   |\e[0m          \
    \                          ^^^^^\e[0m\n\e[31m   |\e[0m                       \
    \             Not found: type index\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpd6qp03ik.scala:24:43 ------------------------\e[0m\e[0m\n\e[31m24 |\e\
    [0m                \e[33mval\e[0m \e[36mvalue\e[0m = count.get(arr2[\e[35mindex\e\
    [0m])\n\e[31m\e[31m   |\e[0m                                           ^^^^^\e\
    [0m\n\e[31m   |\e[0m                                           Not found: type\
    \ index\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpd6qp03ik.scala:25:37\
    \ ------------------------\e[0m\e[0m\n\e[31m25 |\e[0m                \e[33mval\e\
    [0m \e[36mnewCount\e[0m = value + \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        \
    \                       ^^^^^^^\e[0m\n\e[31m   |\e[0mvalue + is not a member of\
    \ Option[Int], but could be made available as an extension method.\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mOne of the following imports might make progress towards fixing\
    \ the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpd6qp03ik.scala:28:29 --------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m                    change = value\n\e[31m\e[31m "
  stdout: ''
  timestamp: 1660010559
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val list = arr.sortBy(-_).toList\n        val n = list.length\n\
    \        val result = new mutable.HashMap[Int, Long]\n        var change = 0\n\
    \        for(i <- 0 until n)\n            if (list(i) == list(n-1-i) || list(i)\
    \ == list(n-2-i) || list(i) == list(n-3-i) || list(i) == list(n-i-i)) {\n    \
    \            result += ((i) -> change)\n                change += 1\n        \
    \    }\n        if (list.length == n)\n            result\n        else\n    \
    \        smallestChange(list.toList)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpguwun7k5.scala:17:25 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m mutable.HashMap[\e[35mInt\e[0m, \e[35mLong\e[0m]\n\e[31m\e[31m   |\e[0m  \
    \                       ^^^^^^^\e[0m\n\e[31m   |\e[0m                        \
    \ Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010554
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        var min_change = 0\n        var min_length = arr.size\n\n\
    \        for (i <- arr.indices) {\n            var temp = arr(i)\n           \
    \ var temp2 = arr(i + 1)\n            if (temp < temp2) {\n                temp\
    \ = arr(i + 1)\n            }\n            if (temp < temp2) {\n             \
    \   temp = arr(i)\n            }\n            if (temp < temp2) {\n          \
    \      temp = arr(i + 1)\n            }\n            if (temp < temp2) {\n   \
    \             temp = arr(i)\n            }\n            if (temp < temp2) {\n\
    \                temp = arr(i)\n            }\n            if (temp < temp2) {\n\
    \                temp = arr(i + 1)\n            }\n            if (temp < temp2)\
    \ {\n                temp = arr(i)\n            }\n            if (temp < temp2)\
    \ {\n                temp = arr(i + 1)\n            }\n            if (temp <\
    \ temp2) {\n                temp = arr(i)\n            }\n            if (temp\
    \ < temp2) {\n                temp = arr(i + 1)\n            }\n            if\
    \ (temp < temp2) {\n                temp = arr(i)\n            }\n           \
    \ if (temp < temp2) {\n                temp = arr(i + 1)\n            }\n    \
    \        if (temp < temp2) {\n                temp = arr(i)\n            }\n \
    \           if (temp < temp2) {\n                temp = arr(i + 1)\n         \
    \   }\n            if (temp < temp2) {\n                temp = arr(i)\n      \
    \      }\n            if (temp < temp2) {\n                temp = arr(i + 1)\n\
    \            }\n            if (temp < temp2) {\n                temp = arr(i)\n\
    \            }\n            if (temp < temp2) {\n                temp = arr(i\
    \ + 1)\n            }\n            if (temp < temp2) {\n                temp =\
    \ arr(i)\n            }\n            if (temp < temp2) {\n                temp\
    \ = arr(i + 1)\n            }\n            if (temp < temp2) {\n             \
    \   temp = arr(i)\n            }\n            if (temp < temp2) {\n          \
    \      temp = arr(i + 1)\n            }\n            if (temp < temp2) {\n   \
    \             temp = arr(i)\n            }\n            if (temp < temp2) {\n\
    \                temp = arr(i + 1)\n            }\n            if (temp < temp2)\
    \ {\n                temp = arr(i)\n            }\n            if (temp < temp2)\
    \ {\n                temp = arr(i + 1)\n            }\n            if (temp <\
    \ temp2) {\n                temp = arr(i)\n            }\n            if (temp\
    \ < temp2) {\n                temp = arr(i + 1)\n            }\n            if\
    \ (temp < temp2) {\n                temp = arr(i)\n            }\n           \
    \ if (temp < temp2) {\n                temp = arr(i + 1)\n            }\n    \
    \        if (temp < temp2) {\n                temp = arr(i)\n            }\n \
    \           if (temp < temp2) {\n                temp = arr(i + 1)\n         \
    \   }\n            if (temp < temp2) {\n                temp = arr(i)\n      \
    \      }\n            if (temp < temp2) {\n                temp = arr(i + 1)\n\
    \            }\n            if (temp < temp2) {\n                temp = arr(i)\n\
    \            }\n            if (temp < temp2) {\n                temp = arr(i\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp_gqwpgj0.scala:128:4 ---------------------------\e\
    [0m\e[0m\n\e[31m128 |\e[0m    }\n\e[31m\e[31m    |\e[0m    ^\e[0m\n\e[31m    |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp_gqwpgj0.scala:141:0\
    \ ---------------------------\e[0m\e[0m\n\e[31m141 |\e[0m\n\e[31m\e[31m    |\e\
    [0m^\e[0m\n\e[31m    |\e[0m'}' expected, but eof found\n\e[33m\e[33m-- Warning:\
    \ /tmp/tmp_gqwpgj0.scala:129:4 ---------------------------------------\e[0m\e\
    [0m\n\e[33m129 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e[35mArray\e\
    [0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m    |\e[0m    ^\e[0m\n\e[33m    |\e[0m\
    \    Line is indented too far to the left, or a `}` is missing\n1 warning found\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660010556
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val m = arr.min\n        val n = arr.length\n        val\
    \ r = new Array[Long](m)\n        val diffs = new Array[Int](n)\n        val start\
    \ = new Array[Int](m - 1)\n        val end = new Array[Int](1)\n        val maxLength\
    \ = (m / 2).toInt\n        var i = 0\n        var j = 0\n        while(i < n &&\
    \ j < m){\n            diffs(i) = arr(j) - arr(i)\n            i += 1\n      \
    \      j += 1\n        }\n        var max = 0\n        while(i < n){\n       \
    \     if(diffs(i) == 0){\n                i += 1\n            }else{\n       \
    \         if(diffs(i) > 0){\n                    while(j < m && diffs(i) - arr(j)\
    \ == 0){\n                        j += 1\n                    }\n            \
    \        if(j < m){\n                        while(j < m && diffs(i) - arr(j)\
    \ < 0){\n                            j += 1\n                        }\n     \
    \                   if(j >= m){\n                            while(j < m && diffs(i)\
    \ < 0){\n                                j += 1\n                            }\n\
    \                            if(j >= m){\n                                while(j\
    \ < m && diffs(i) != 0){\n                                    j += 1\n       \
    \                         }\n                                if(j >= m){\n   \
    \                                 val temp = diffs(i)\n                      \
    \              val temp2 = arr(j)\n                                    val temp3\
    \ = diffs(i) - arr(j)\n                                    if(temp2 == temp3){\n\
    \                                        val temp = diffs(i)\n               \
    \                         val temp2 = arr(j)\n                               \
    \         val temp3 = diffs(i) - arr(j)\n                                    \
    \    val temp4 = diffs(j) - diffs(i)\n                                       \
    \ if(temp2 == temp3){\n                                            val temp =\
    \ diffs(i)\n                                            val temp2 = arr(j)\n \
    \                                           val temp3 = diffs(i) - arr(j)\n  \
    \                                          val temp4 = diffs(j) - diffs(i)\n \
    \                                           val temp5 = arr(j) - arr(i)\n    \
    \                                        if(temp2 == temp3){\n               \
    \                                 val temp = diffs(i)\n                      \
    \                          val temp2 = arr(j)\n                              \
    \                  val temp3 = diffs(i) - arr(j)\n                           \
    \                     val temp4 = diffs(j) - diffs(i)\n                      \
    \                          val temp5 = arr(j) - arr(i)\n                     \
    \                           if(temp2 == temp3){\n                            \
    \                        val temp = diffs(i)\n                               \
    \                     val temp2 = arr(j)\n                                   \
    \                 val temp3 = diffs(i) - arr(j)\n                            \
    \                        val temp4 = diffs(j) - diffs(i)\n                   \
    \                                 val temp5 = arr(j) - arr(i)\n              \
    \                                      val temp6 = arr(i) - arr(j)\n         \
    \                                           if(temp2 == temp3){\n            \
    \                                            val temp = diff\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmplkrdk6u6.scala:93:0 ----------------------------\e\
    [0m\e[0m\n\e[31m93 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmplkrdk6u6.scala:17:32\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mr\e\
    [0m = \e[33mnew\e[0m \e[35mArray\e[0m[\e[35mLong\e[0m](m)\n\e[31m\e[31m   |\e\
    [0m                                ^\e[0m\n\e[31m   |\e[0m                   \
    \             Found:    (m : Long)\n\e[31m   |\e[0m                          \
    \      Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmplkrdk6u6.scala:19:35\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mstart\e\
    [0m = \e[33mnew\e[0m \e[35mArray\e[0m[\e[35mInt\e[0m](m - \e[31m1\e[0m)\n\e[31m\e\
    [31m   |\e[0m                                   ^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                                 Found:    Long\n\e[31m   |\e[0m            \
    \                       Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmplkrdk6u6.scala:25:23 --------------------\e[0m\e\
    [0m\n\e[31m25 |\e[0m            diffs(i) = arr(j) - arr(i)\n\e[31m\e[31m   |\e\
    [0m                       ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m              \
    \         Found:    Long\n\e[31m   |\e[0m                       Required: Int\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmplkrdk6u6.scala:79:67\
    \ ------------------------\e[0m\e[0m\n\e[31m79 |\e[0m                        \
    \                                \e[33mval\e[0m \e[36mtemp\e[0m = diff\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \   ^^^^\e[0m\n\e[31m   |\e[0m                                               \
    \          Not found: diff\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[33m\e[33m-- Warning: /tmp/tmplkrdk6u6.scala:81:4\
    \ ----"
  stdout: ''
  timestamp: 1660010560
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val changed = mutable.ListBuffer[Long]()\n        val reversed\
    \ = arr.map(x => reverse(x))\n        for (i <- 0 until arr.length) {\n      \
    \      if (i == arr.length - 1) {\n                if (arr(i) == arr(0)) {\n \
    \                   changed.add(i)\n                }\n            } else if (arr(i)\
    \ == arr(i + 1)) {\n                val k = reversed.indexOf(arr(i))\n       \
    \         changed.add(k)\n            }\n        }\n        changed.min\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp62vjjlyw.scala:15:22 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mchanged\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp62vjjlyw.scala:16:36 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mreversed\e[0m = arr.map(\e\
    [36mx\e[0m => reverse(x))\n\e[31m\e[31m   |\e[0m                             \
    \       ^^^^^^^\e[0m\n\e[31m   |\e[0m                                    Not found:\
    \ reverse\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010557
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        var pal = false\n        var count = 0\n        for( i <-\
    \ arr.indices.reverse ) {\n            if( arr(i) == arr(i+1) ) {\n          \
    \      pal = true\n                count = i\n            }\n        }\n     \
    \   if( !pal ) {\n            count = 0\n        }\n        \n        return count\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 8\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.smallestChange$$anonfun$1(tmp3pwh25ly.scala:18)\n\tat scala.runtime.java8.JFunction1$mcVI$sp.apply(JFunction1$mcVI$sp.scala:18)\n\
    \tat scala.collection.immutable.Range.foreach(Range.scala:190)\n\tat Problem$.smallestChange(tmp3pwh25ly.scala:22)\n\
    \tat Problem$.main(tmp3pwh25ly.scala:30)\n\tat Problem.main(tmp3pwh25ly.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010560
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        var i = 0\n        val maxValue = arr.foldLeft(arr.head)((m,\
    \ x) => if (x < m) x else m)\n        var min = maxValue\n        var minI = 0\n\
    \        var minJ = 0\n        var isPalindrome = true\n        while (i < arr.length)\
    \ {\n            min = maxValue\n            minI = minJ = 0\n            var\
    \ tmp = arr(i)\n            while (tmp != 0) {\n                tmp = tmp / 10\n\
    \                val digit = tmp.toInt\n                val index = digit * 10\
    \ + minI\n                if (index >= arr.length) break\n                if (arr(index)\
    \ != digit) {\n                    minJ = index\n                    break\n \
    \               }\n                minI += 1\n                min = Math.min(min,\
    \ digit + arr(minJ))\n            }\n            isPalindrome = minI == minJ\n\
    \            val change = if (isPalindrome) minI-1 else arr.length - minI\n  \
    \          if (change > arr.length) break\n            i += 1\n        }\n   \
    \     min\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpf28fzgxo.scala:23:24\
    \ --------------------\e[0m\e[0m\n\e[31m23 |\e[0m            minI = minJ = \e\
    [31m0\e[0m\n\e[31m\e[31m   |\e[0m                   ^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                   Found:    Unit\n\e[31m   |\e[0m                   Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpf28fzgxo.scala:29:41\
    \ ------------------------\e[0m\e[0m\n\e[31m29 |\e[0m                \e[33mif\e\
    [0m (index >= arr.length) break\n\e[31m\e[31m   |\e[0m                       \
    \                  ^^^^^\e[0m\n\e[31m   |\e[0m                               \
    \          Not found: break\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpf28fzgxo.scala:32:20 ------------------------\e[0m\e[0m\n\e[31m32 |\e\
    [0m                    break\n\e[31m\e[31m   |\e[0m                    ^^^^^\e\
    [0m\n\e[31m   |\e[0m                    Not found: break\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpf28fzgxo.scala:39:37 ------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m            \e[33mif\e[0m (change > arr.length) break\n\
    \e[31m\e[31m   |\e[0m                                     ^^^^^\e[0m\n\e[31m \
    \  |\e[0m                                     Not found: break\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1660010559
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arrCopy = arr.toBuffer\n        arrCopy.reverse()\n\
    \        val result = 0\n        var index = 0\n        while (index < arrCopy.size)\n\
    \        {\n            val change = arrCopy(index - 1).toLong - arrCopy(index).toLong\n\
    \            if (change <= 0)\n            {\n                result = result\
    \ + 1\n            }\n            else\n            {\n                result\
    \ = result\n            }\n            index = index + 1\n        }\n        return\
    \ result\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpnow44lkl.scala:16:23 -----------------------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        arrCopy.reverse()\n\e[31m\e[31m   |\e[0m    \
    \    ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmissing argument for parameter i of\
    \ \e[33mmethod\e[0m \e[35mapply\e[0m in \e[33mtrait\e[0m \e[35mSeqOps\e[0m: (i:\
    \ Int): Long\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmpnow44lkl.scala:24:23 -----------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m                result = result + \e[31m1\e[0m\n\e[31m\e\
    [31m   |\e[0m                ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m       \
    \         Reassignment to val result\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E052]\
    \ Type Error: /tmp/tmpnow44lkl.scala:28:23 -----------------------------\e[0m\e\
    [0m\n\e[31m28 |\e[0m                result = result\n\e[31m\e[31m   |\e[0m   \
    \             ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                Reassignment\
    \ to val result\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010557
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.sort\n        val n = arr.length\n       \
    \ val min = n - 1\n\n        // for case when arr is Palindromic\n        if (n\
    \ == 0 || arr(n-1) == arr(0))\n            0\n        else\n            1 + smallestChange(arr.take(min).reverse)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpzx223xyr.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sort\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660010556
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val len = arr.length\n        val maxLen = math.pow(2, len.toDouble)\n\
    \        val map = mutable.HashMap.empty[Long, Long]\n        var counter = arr(0)\n\
    \        var lenCounter = 1\n        for (i <- 1 until len) {\n            val\
    \ a = counter\n            val b = arr(i)\n            val c = math.pow(b, a)\n\
    \            val lenCounter = math.max(lenCounter, c.toInt)\n            counter\
    \ += a\n            map.put(i, c)\n        }\n\n        val lenMax = math.pow(2,\
    \ lenCounter)\n        val minNum = lenMax - lenMax * map.getOrElse(lenCounter,\
    \ 0L).toInt\n        val minNumPalin = map.getOrElse(lenCounter, 0L).toInt * 2\n\
    \        val maxNumPalin = map.getOrElse(lenCounter, 0L).toInt * 2 + 1\n     \
    \   if (minNum >= minNumPalin && maxNumPalin <= maxLen && lenCounter <= maxLen)\
    \ {\n            return lenCounter\n        } else {\n            0l\n       \
    \ }\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpiao1ocd8.scala:17:18 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mmap\e[0m = mutable.HashMap.empty[\e\
    [35mLong\e[0m, \e[35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                  ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                  Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660010558
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        if(arr.length == 0) 0\n        else if(arr.head.toString.equals(\"\
    -1\")) 0\n        else arr.head + smallestChange(arr.tail)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpky5mryvy.scala:20)\n\tat Problem.main(tmpky5mryvy.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010560
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val r = arr.size + 1\n        var m = 0\n        var i =\
    \ 0\n        var j = 0\n        for(i <- 0 until arr.size) {\n            for(j\
    \ <- 0 until arr.size) {\n                if (i == j) continue\n             \
    \   if (arr(i) > arr(j)) continue\n                if (arr(i) < arr(j)) continue\n\
    \                if (arr(i) == arr(j)) {\n                    if (i > j) m +=\
    \ 1\n                    if (i == arr.size) m += arr.size - j\n              \
    \      if (j == arr.size) m += arr.size - i\n                }\n            }\n\
    \        }\n        val m = arr.size - r\n        if (m < 0) -1\n        else\
    \ m\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpett07_fl.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mm\e[0m = arr.size - r\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mm is already\
    \ defined as \e[33mvariable\e[0m \e[35mm\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpett07_fl.scala:21:28 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m                \e[33mif\e[0m (i == j) continue\n\e[31m\e\
    [31m   |\e[0m                            ^^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \                      Not found: continue\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpett07_fl.scala:22:37 ------------------------\e[0m\e\
    [0m\n\e[31m22 |\e[0m                \e[33mif\e[0m (arr(i) > arr(j)) continue\n\
    \e[31m\e[31m   |\e[0m                                     ^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                                     Not found: continue\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpett07_fl.scala:23:37 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m                \e[33mif\e[0m (arr(i) < arr(j)) continue\n\
    \e[31m\e[31m   |\e[0m                                     ^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                                     Not found: continue\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1660010558
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val nr = arr.length\n        if (nr == 0)\n            return\
    \ 0\n        val l = arr.head\n        val n = nr - 1\n        val s = n / 2\n\
    \        var minChange = 0\n        while (l <= r) {\n            val m = s *\
    \ (s - 1)\n            val j = m + m + 2 * m\n            if (arr(j) == arr(j\
    \ + 1) && arr(j) == l) {\n                minChange = j\n            }\n     \
    \       s -= 1\n            r += 1\n        }\n        minChange\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpxkc5eyn1.scala:22:20 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mwhile\e[0m (l <= r) {\n\e[31m\e[31m   |\e\
    [0m                    ^\e[0m\n\e[31m   |\e[0m                    Not found: r\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpxkc5eyn1.scala:28:14\
    \ ------------------------\e[0m\e[0m\n\e[31m28 |\e[0m            s -= \e[31m1\e\
    [0m\n\e[31m\e[31m   |\e[0m            ^^^^\e[0m\n\e[31m   |\e[0m            value\
    \ -= is not a member of Int - did you mean s.!=?\n\e[31m\e[31m-- [E006] Not Found\
    \ Error: /tmp/tmpxkc5eyn1.scala:29:12 ------------------------\e[0m\e[0m\n\e[31m29\
    \ |\e[0m            r += \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m            ^\e[0m\n\
    \e[31m   |\e[0m            Not found: r\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010560
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        // first find out whether there is more than one element\
    \ in the list to change\n        val changed = arr.filter(x => x != arr.last).length\
    \ != arr.length\n        // If there is only one element in the list, then there\
    \ is no need to change the elements\n        if (!changed) 0\n        // If there\
    \ are more than one element in the list, we need to change one element to another\
    \ element\n        else arr.take(arr.length - 1).foldLeft(arr.last)(_ + 1) + (arr.last\
    \ * arr.take(arr.length - 1).reverse.foldLeft(arr.last)(_ + 1))\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E086] Syntax Error: /tmp/tmp62d4lxta.scala:20:57 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33melse\e[0m arr.take(arr.length - \e[31m1\e\
    [0m).foldLeft(arr.last)(_ + \e[31m1\e[0m) + (arr.last * arr.take(arr.length -\
    \ \e[31m1\e[0m).reverse.foldLeft(arr.last)(_ + \e[31m1\e[0m))\n\e[31m\e[31m  \
    \ |\e[0m                                                         ^^^^^\e[0m\n\e\
    [31m   |\e[0m                                 Wrong number of parameters, expected:\
    \ 2\n\e[31m\e[31m-- [E086] Syntax Error: /tmp/tmp62d4lxta.scala:20:130 --------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33melse\e[0m arr.take(arr.length - \e[31m1\e\
    [0m).foldLeft(arr.last)(_ + \e[31m1\e[0m) + (arr.last * arr.take(arr.length -\
    \ \e[31m1\e[0m).reverse.foldLeft(arr.last)(_ + \e[31m1\e[0m))\n\e[31m\e[31m  \
    \ |\e[0m                                                                     \
    \                                                             ^^^^^\e[0m\n\e[31m\
    \   |\e[0m                                 Wrong number of parameters, expected:\
    \ 2\n2 errors found\n"
  stdout: ''
  timestamp: 1660010558
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        arr.sortBy(_.toLong).reverse.foldLeft(0) {\n           \
    \ case (acc,item) => {\n                // Change one item to any other item and\
    \ keep track of how many times we changed\n                // If we ever reach\
    \ the length of the list without changing any item then stop\n               \
    \ val curr = acc.toLong\n                acc += if (item == arr[acc.length-1])\
    \ 0 else 1\n                acc\n            }\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpw9nw8y53.scala:20:23 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m                acc += \e[33mif\e[0m (item == arr[acc.length-\e\
    [31m1\e[0m]) \e[31m0\e[0m \e[33melse\e[0m \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m\
    \                       ^^\e[0m\n\e[31m   |\e[0m                       expression\
    \ expected but \e[31mif\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpw9nw8y53.scala:20:20 ------------------------\e[0m\e[0m\n\e[31m20 |\e\
    [0m                acc += \e[33mif\e[0m (item == arr[acc.length-\e[31m1\e[0m])\
    \ \e[31m0\e[0m \e[33melse\e[0m \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m           \
    \     ^^^^^^\e[0m\n\e[31m   |\e[0m                value += is not a member of\
    \ Int - did you mean acc.!=?\n2 errors found\n"
  stdout: ''
  timestamp: 1660010562
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val pList = new mutable.ListBuffer[Long]()\n        val\
    \ pList = arr.map(elem => (elem + arr(arr.lastIndexOf(elem))).toLong)\n      \
    \  val palindromicList = arr.take(arr.lastIndexOf(arr(arr.lastIndexOf(arr(0))).toLong))\n\
    \        pList.takeWhile(elem => palindromicList.exists(palindrome(elem)))\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpx0wj8ou2.scala:16:12 ---------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mpList\e[0m = arr.map(\e\
    [36melem\e[0m => (elem + arr(arr.lastIndexOf(elem))).toLong)\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mpList is already defined as \e[33mvalue\e[0m \e[35mpList\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E006] Not\
    \ Found Error: /tmp/tmpx0wj8ou2.scala:15:24 ------------------------\e[0m\e[0m\n\
    \e[31m15 |\e[0m        \e[33mval\e[0m \e[36mpList\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                        ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                        Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010559
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr2 = arr.dropRight(1)\n        val arr1 = arr.dropLeft(1)\n\
    \        val ans = arr.head\n        if (arr2.length < arr1.length) {\n      \
    \      ans = arr2.head\n        }\n        val arr3 = arr2.zipWithIndex\n    \
    \    val p1 = arr3.takeWhile(_._2 > arr.head).map(_._1).sum\n        val p2 =\
    \ arr3.takeWhile(_._2 < arr.head).map(_._1).sum\n        if (p1 < p2) {\n    \
    \        ans\n        } else {\n            ans - p1\n        }\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmphjjdwgz8.scala:16:23 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36marr1\e[0m = arr.dropLeft(\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m                   ^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   value dropLeft is not a member of List[Long]\n\e\
    [31m\e[31m-- [E052] Type Error: /tmp/tmphjjdwgz8.scala:19:16 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m            ans = arr2.head\n\e[31m\e[31m   |\e[0m  \
    \          ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            Reassignment to val\
    \ ans\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010563
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        var maxCount = 0\n        for(i <- 0 until arr.length) {\n\
    \            var count = 1\n            for(j <- 0 until i) {\n              \
    \  if(arr(i-j) == arr(i-j+1)) {\n                    count += 1\n            \
    \    }\n            }\n            maxCount = max(maxCount,count)\n        }\n\
    \        maxCount\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 8\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.smallestChange$$anonfun$1$$anonfun$1(tmpwk9mf8z5.scala:19)\n\tat\
    \ scala.runtime.java8.JFunction1$mcVI$sp.apply(JFunction1$mcVI$sp.scala:18)\n\t\
    at scala.collection.immutable.Range.foreach(Range.scala:190)\n\tat Problem$.smallestChange$$anonfun$1(tmpwk9mf8z5.scala:22)\n\
    \tat scala.runtime.java8.JFunction1$mcVI$sp.apply(JFunction1$mcVI$sp.scala:18)\n\
    \tat scala.collection.immutable.Range.foreach(Range.scala:190)\n\tat Problem$.smallestChange(tmpwk9mf8z5.scala:24)\n\
    \tat Problem$.main(tmpwk9mf8z5.scala:28)\n\tat Problem.main(tmpwk9mf8z5.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tool"
  stdout: ''
  timestamp: 1660010566
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        var stack = immutable.Stack.empty[Long]\n        var min\
    \ = Long.MaxValue\n        var index = 0\n        var startIndex = 0\n       \
    \ while(index < arr.length) {\n            val n = arr(index)\n            val\
    \ start = index\n            val end = (index + 1) % arr.length\n            val\
    \ currentIndex = start\n            while(currentIndex < end && index < arr.length)\
    \ {\n                stack.push(arr(currentIndex))\n                currentIndex\
    \ = (currentIndex + 1) % arr.length\n            }\n            stack.reverse()\n\
    \            index = end\n            while(index < arr.length) {\n          \
    \      if(stack.isEmpty) {\n                    min += 1\n                } else\
    \ {\n                    val top = stack.pop()\n                    if(top !=\
    \ n) {\n                        min += 1\n                        break\n    \
    \                }\n                }\n                index += 1\n          \
    \  }\n        }\n        return min\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpvuy47blg.scala:15:20 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mvar\e[0m \e[36mstack\e[0m = immutable.Stack.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                    ^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                    Not found: immutable\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E052] Type Error: /tmp/tmpvuy47blg.scala:26:29 -----------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m                currentIndex = (currentIndex + \e[31m1\e\
    [0m) % arr.length\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                Reassignment to val currentIndex\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpvuy47blg.scala:37:24 ------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m                        break\n\e[31m\e[31m   |\e[0m\
    \                        ^^^^^\e[0m\n\e[31m   |\e[0m                        Not\
    \ found: break\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010562
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val list: mutable.Buffer[Long] = mutable.Buffer.empty\n\
    \        var index = 0\n        var ans = 0\n\n        while (index < arr.length)\
    \ {\n            val element = arr(index)\n            list.+=element\n      \
    \      index += 1\n\n            while (index < arr.length) {\n              \
    \  if (element == arr(index)) {\n                    index += 1\n            \
    \    } else {\n                    val left = list.last\n                    val\
    \ right = arr(index)\n                    if (left != right) {\n             \
    \           ans += 1\n                        list.pop\n                    }\n\
    \                    index += 1\n                }\n            }\n        }\n\
    \        ans\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpbqujknt9.scala:15:18 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mlist\e[0m: mutable.Buffer[\e\
    [35mLong\e[0m] = mutable.Buffer.empty\n\e[31m\e[31m   |\e[0m                 \
    \ ^^^^^^^\e[0m\n\e[31m   |\e[0m                  Not found: mutable\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpbqujknt9.scala:15:41 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mlist\e[0m: mutable.Buffer[\e\
    [35mLong\e[0m] = mutable.Buffer.empty\n\e[31m\e[31m   |\e[0m                 \
    \                        ^^^^^^^\e[0m\n\e[31m   |\e[0m                       \
    \                  Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010563
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        if(arr.isEmpty) 0\n        else {\n            val ms =\
    \ arr.map(x => x*x)\n            val len = ms.length\n            var i = 0\n\
    \            val m1 = ms\n            val m2 = ms.reverse\n\n            while(i\
    \ < len) {\n                if(ms(i) != m2(i)) {\n                    val next\
    \ = m1(i + 1)\n                    m1(i) = m2(i) = next\n                    i\
    \ += 2\n                } else {\n                    i += 1\n               \
    \ }\n            }\n\n            if(m1(len) != m2(len)) {\n                val\
    \ next = m2(len - 1) + 1\n                m1(len) = m2(len) = next\n         \
    \   }\n\n            m1(0) = m2(0) = 1\n            m1.map(x => x*x).sum\n   \
    \     }\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmps_eapzz_.scala:26:20 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m                    m1(i) = m2(i) = next\n\e[31m\e[31m\
    \   |\e[0m                    ^^\e[0m\n\e[31m   |\e[0m   value update is not a\
    \ member of List[Long] - did you mean m1.updated?\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmps_eapzz_.scala:26:28 ------------------------\e[0m\e[0m\n\e[31m26\
    \ |\e[0m                    m1(i) = m2(i) = next\n\e[31m\e[31m   |\e[0m      \
    \                      ^^\e[0m\n\e[31m   |\e[0m   value update is not a member\
    \ of List[Long] - did you mean m2.updated?\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmps_eapzz_.scala:35:16 ------------------------\e[0m\e[0m\n\e[31m35 |\e\
    [0m                m1(len) = m2(len) = next\n\e[31m\e[31m   |\e[0m           \
    \     ^^\e[0m\n\e[31m   |\e[0m   value update is not a member of List[Long] -\
    \ did you mean m1.updated?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmps_eapzz_.scala:35:26\
    \ ------------------------\e[0m\e[0m\n\e[31m35 |\e[0m                m1(len) =\
    \ m2(len) = next\n\e[31m\e[31m   |\e[0m                          ^^\e[0m\n\e[31m\
    \   |\e[0m   value update is not a member of List[Long] - did you mean m2.updated?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmps_eapzz_.scala:38:12 ------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m            m1(\e[31m0\e[0m) = m2(\e[31m0\e[0m) = \e\
    [31m1\e[0m\n\e[31m\e[31m   |\e[0m            ^^\e[0m\n\e[31m   |\e[0m   value\
    \ update is not a member of List[Long] - did you mean m1.updated?\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmps_eapzz_.scala:38:20 ------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m            m1(\e[31m0\e[0m) = m2(\e[31m0\e[0m) = \e\
    [31m1\e[0m\n\e[31m\e[31m   |\e[0m                    ^^\e[0m\n\e[31m   |\e[0m\
    \   value update is not a member of List[Long] - did you mean m2.updated?\n6 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010568
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.size\n        if(n == 0) 0\n        else if\
    \ n % 2 == 0 {\n            val mid = n / 2\n            smallestChange(arr.take(mid)).change(mid,\
    \ mid, arr)\n        } else {\n            val mid = n / 2\n            smallestChange(arr.take(mid)).change(mid,\
    \ mid+1, arr)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp8yq9b75d.scala:20:10 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        } \e[33melse\e[0m {\n\e[31m\e[31m   |\e[0m  \
    \        ^^^^\e[0m\n\e[31m   |\e[0m          'then' expected, but 'else' found\n\
    \e[31m\e[31m-- [E050] Type Error: /tmp/tmp8yq9b75d.scala:17:25 -----------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m n % \e[31m2\e[0m\
    \ == \e[31m0\e[0m {\n\e[31m\e[31m   |\e[0m                         ^\e[0m\n\e\
    [31m   |\e[0m                         expression does not take parameters\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp8yq9b75d.scala:19:42\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m            smallestChange(arr.take(mid)).change(mid,\
    \ mid, arr)\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m            value change is not a member of Long\n\e[33m\e\
    [33m-- [E129] Potential Issue Warning: /tmp/tmp8yq9b75d.scala:24:4 -----------------\e\
    [0m\e[0m\n\e[33m23 |\e[0m        }\n\e[33m24 |\e[0m    }\n\e[33m\e[33m   |\e[0m\
    \         ^\e[0m\n\e[33m   |\e[0mA pure expression does nothing in statement position;\
    \ you may be omitting necessary parentheses\n\e[33m   |\e[0m\n\e[33m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 warning found\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1660010566
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val newArray = arr.toBuffer.toArray.sortWith(compare)\n\
    \        var change = 0\n        val m = newArray.length\n        var i = 0\n\
    \        var j = 0\n        var index = 0\n        while (i<m) {\n           \
    \ if (newArray(i) == newArray(m-1))\n                change = change + 1\n   \
    \         i = i + 1\n        }\n        if (change == 0) {\n            return\
    \ 0\n        } else {\n            change = change-1\n            while (j < change)\
    \ {\n                index = j\n                j = (j+1)%m\n            }\n \
    \           return newArray(index)\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmperpj6cu8.scala:15:53 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mnewArray\e[0m = arr.toBuffer.toArray.sortWith(compare)\n\
    \e[31m\e[31m   |\e[0m                                                     ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                                     Not found:\
    \ compare\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010564
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        def rec(curr : Long, min : Long, len : Int) : Long = {\n\
    \            if( len == 0)\n                min\n            else if(arr[curr].toLong\
    \ < arr[min].toLong)\n                rec(curr+1, min, len-1)\n            else\
    \ if( arr[curr].toLong == arr[min].toLong && min != curr)\n                rec(curr+1,\
    \ curr, len-1)\n            else\n                rec(curr+1, min, len-1)\n  \
    \      }\n        rec(0, -1, arr.size)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpoo8x8m6v.scala:18:24 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m            \e[33melse\e[0m \e[33mif\e[0m(arr[curr].toLong\
    \ < arr[min].toLong)\n\e[31m\e[31m   |\e[0m                        ^^^^\e[0m\n\
    \e[31m   |\e[0m                        Not found: type curr\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpoo8x8m6v.scala:20:25 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m            \e[33melse\e[0m \e[33mif\e[0m( arr[curr].toLong\
    \ == arr[min].toLong && min != curr)\n\e[31m\e[31m   |\e[0m                  \
    \       ^^^^\e[0m\n\e[31m   |\e[0m                         Not found: type curr\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010564
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        def isPalindromic(palin : Long, element : Long) : Boolean\
    \ = {\n            val rev_palin = element.toString.reverse //To reverse palindrome\
    \ string.\n            rev_palin.toCharArray.takeWhile(c => c != palin).forall{c\
    \ => c != element}\n        }\n        val length = arr.length\n        var countChanges\
    \ = 0\n        var maxCount = -1L\n        val changeArray = arr.foldLeft((List[Long](0l.toLong),\
    \ List[Long](0l.toLong))) {\n            case ((count, changes), element) =>\n\
    \                val isPalin = element.toString.reverse == element.toString\n\
    \                if(count < maxCount && isPalin) count + 1\n                else\
    \ if(count > maxCount && !isPalin) count\n                else (count, changes\
    \ + 1L)\n        }._1\n        val changeList = changeArray._1.reverse\n     \
    \   var maxChange = -1L\n        changeList.foreach { c =>\n            val isPalin\
    \ = isPalindromic(c, changeArray._2)\n            if(isPalin && maxChange < c)\
    \ maxChange = c\n        }\n        if(maxChange < length) countChanges = maxChange\n\
    \        countChanges\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpx12cec1q.scala:25:25 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m                \e[33mif\e[0m(count < maxCount && isPalin)\
    \ count + \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\
    \e[31m   |\e[0mvalue < is not a member of List[Long], but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m  import math.Ordered.orderingToOrdered\n\e[31m   |\e[0m  import\
    \ math.Ordering.Implicits.infixOrderingOps\n\e[31m   |\e[0m\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpx12cec1q.scala:25:54 ------------------------\e[0m\e\
    [0m\n\e[31m25 |\e[0m                \e[33mif\e[0m(count < maxCount && isPalin)\
    \ count + \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m                                \
    \                ^^^^^^^\e[0m\n\e[31m   |\e[0mvalue + is not a member of List[Long],\
    \ but could be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mOne of the following imports might make progress towards fixing the\
    \ problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpx12cec1q.scala:26:30 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m                \e[33melse\e[0m \e[33mif\e[0m(count >\
    \ maxCount && !isPalin) count\n\e[31m\e[31m   |\e[0m                        ^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue > is not a member of List[Long], but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m  import math.Ordered.orderingToOrdered\n\e[31m   |\e[0m  import\
    \ math.Ordering.Implicits.infixOrderingOps\n\e[31m   |\e[0m\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpx12cec1q.scala:26:54 --------------------\e[0m\e\
    [0m\n\e[31m26 |\e[0m                \e[33melse\e[0m \e[33mif\e[0m(count > maxCount"
  stdout: ''
  timestamp: 1660010570
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val palindromicArray = arr.toList\n        val maxPalindromicIndex\
    \ = palindromicArray.indexOf(palindromicArray.last) + palindromicArray.size +\
    \ 1\n        val maxPalindromic = palindromicArray.take(maxPalindromicIndex).toArray\n\
    \        val sumPalindromic = palindromicArray.filter(_ => palindromicArray.indexOf(_)\
    \ == palindromicArray.lastIndexOf(_)).sum\n        maxPalindromicIndex - sumPalindromic\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E081] Type Error: /tmp/tmpwu5zese0.scala:18:83 -----------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36msumPalindromic\e[0m = palindromicArray.filter(_\
    \ => palindromicArray.indexOf(_) == palindromicArray.lastIndexOf(_)).sum\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \                   ^\e[0m\n\e[31m   |\e[0mMissing parameter type\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mI could not infer the type of the parameter _$2 of expanded\
    \ function:\n\e[31m   |\e[0m(_$2, _$3) => palindromicArray.indexOf(_$2) == palindromicArray.lastIndexOf(_$3).\n\
    \e[31m\e[31m-- [E081] Type Error: /tmp/tmpwu5zese0.scala:18:118 ----------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36msumPalindromic\e[0m = palindromicArray.filter(_\
    \ => palindromicArray.indexOf(_) == palindromicArray.lastIndexOf(_)).sum\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \                                                      ^\e[0m\n\e[31m   |\e[0mMissing\
    \ parameter type\n\e[31m   |\e[0m\n\e[31m   |\e[0mI could not infer the type of\
    \ the parameter _$3 of expanded function:\n\e[31m   |\e[0m(_$2, _$3) => palindromicArray.indexOf(_$2)\
    \ == palindromicArray.lastIndexOf(_$3).\n2 errors found\n"
  stdout: ''
  timestamp: 1660010565
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val minVal = arr.head\n        val maxVal = arr.last\n \
    \       val minMax = maxVal - minVal\n        val revArr = reverse(arr)\n    \
    \    var sum = 0\n        var count = 0\n        for (x <- arr) {\n          \
    \  if (sum + x == revArr.sum) {\n                count += 1\n            }\n \
    \           sum = sum + x\n        }\n        (count * minMax).min(minVal)\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpv5r0eaxa.scala:18:21 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mrevArr\e[0m = reverse(arr)\n\
    \e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \               Not found: reverse\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpv5r0eaxa.scala:25:18 --------------------\e[0m\e[0m\n\e[31m25\
    \ |\e[0m            sum = sum + x\n\e[31m\e[31m   |\e[0m                  ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                  Found:    Long\n\e[31m   |\e[0m        \
    \          Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010568
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length\n        val resultSet = new mutable.TreeSet[Long]\n\
    \        if (arr.isEmpty || arr.length <= 1) {\n            return 0\n       \
    \ }\n        val pivot = arr(arr.length / 2)\n        var i = arr.length - 1\n\
    \        var j = arr.length - 1\n        while (i >= 0 && j >= 0) {\n        \
    \    val left = arr(i - 1)\n            val right = arr(j)\n            if (left\
    \ == pivot) {\n                val temp = arr(i)\n                arr(i) = right\n\
    \                arr(j)= temp\n                i -= 1\n                j -= 1\n\
    \                resultSet += j\n            } else {\n                j --\n\
    \            }\n        }\n        resultSet.min\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpsh_11iwo.scala:34:20 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m                j --\n\e[31m\e[31m   |\e[0m         \
    \           ^\e[0m\n\e[31m   |\e[0m                    expression expected but\
    \ \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpsh_11iwo.scala:16:28\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mresultSet\e[0m = \e[33mnew\e[0m mutable.TreeSet[\e[35mLong\e[0m]\n\e[31m\e\
    [31m   |\e[0m                            ^^^^^^^\e[0m\n\e[31m   |\e[0m       \
    \                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpsh_11iwo.scala:28:16 ------------------------\e[0m\e\
    [0m\n\e[31m28 |\e[0m                arr(i) = right\n\e[31m\e[31m   |\e[0m    \
    \            ^^^\e[0m\n\e[31m   |\e[0m  value update is not a member of List[Long]\
    \ - did you mean arr.updated?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpsh_11iwo.scala:29:16\
    \ ------------------------\e[0m\e[0m\n\e[31m29 |\e[0m                arr(j)= temp\n\
    \e[31m\e[31m   |\e[0m                ^^^\e[0m\n\e[31m   |\e[0m  value update is\
    \ not a member of List[Long] - did you mean arr.updated?\n4 errors found\n"
  stdout: ''
  timestamp: 1660010569
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        def go(i : Int, l : List[Long]) : Long = i match {\n   \
    \         case 0 => l(0)\n            case 1 => l(0)\n            case 2 => l(0)\n\
    \            case i => l(i) min l(i - 1)\n        }\n        val len = arr.size\n\
    \        val maxLen = len - 1 // to handle odd numbered list\n        (len + 1)\
    \ max 0 //to handle even\n        val start = 0\n        val end = len - 1\n \
    \       var changes = 0\n        while(start < maxLen) {\n            val middle\
    \ = start + (end - start) / 2\n            val middleVal = go(middle, arr)\n \
    \           if (middleVal == middle) {\n                changes += 1\n       \
    \     }\n            end = middle\n            start = middle\n        }\n   \
    \     if (changes == 1) changes += 1\n        changes\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmpmo952ct8.scala:33:16 -----------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m            end = middle\n\e[31m\e[31m   |\e[0m     \
    \       ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            Reassignment to val end\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmpmo952ct8.scala:34:18 -----------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m            start = middle\n\e[31m\e[31m   |\e[0m   \
    \         ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            Reassignment to val\
    \ start\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010566
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        var len = arr.length\n        val count = new scala.collection.mutable.HashMap[Long,\
    \ Long]()\n        var cur :Long = 0\n        var flag = false\n        var index\
    \ = 0\n        while (index < len) {\n            if (count.contains(arr(index)))\
    \ {\n                val curr = count(arr(index))\n                if (curr >\
    \ cur) {\n                    cur = curr\n                    flag = true\n  \
    \              }\n            } else {\n                val curr = 1\n       \
    \         count.put(arr(index), curr)\n            }\n            index = index\
    \ + 1\n        }\n        if (flag == false)\n            return 1\n        else\n\
    \            return cur\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpfauj49q3.scala:39)\n\tat Problem.main(tmpfauj49q3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010571
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val m = arr.takeRight(arr.length-1)\n        var changes\
    \ = 0\n        var i = 0\n        while(i < m.length) {\n            if(m(m(i))\
    \ == m(m.length-i-1) ) {\n                changes += 1;\n                i +=1\n\
    \            } else {\n                i +=1\n            }\n        }\n     \
    \   changes + 1\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpb8spl9zp.scala:19:18\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            \e[33mif\e[0m(m(m(i))\
    \ == m(m.length-i-\e[31m1\e[0m) ) {\n\e[31m\e[31m   |\e[0m                 ^^^^\e\
    [0m\n\e[31m   |\e[0m                 Found:    Long\n\e[31m   |\e[0m         \
    \        Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010569
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.size\n        val minChanges = arr match {\n\
    \            case Nil => 0\n            case head :: tail => {\n             \
    \   val change = smallestChange(tail)\n                val nextMinChange = if\
    \ (head % 2 == 0) n / 2 - change else -change // If the head is even, subtract\
    \ two changes from the next head, otherwise add two\n                smallestChange(tail.take(nextMinChange)\
    \ ++ tail.drop(nextMinChange))\n            }\n        }\n        minChanges\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpegit8arc.scala:21:41\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m                smallestChange(tail.take(nextMinChange)\
    \ ++ tail.drop(nextMinChange))\n\e[31m\e[31m   |\e[0m                        \
    \                 ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                        \
    \                Found:    (nextMinChange : Long)\n\e[31m   |\e[0m           \
    \                             Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpegit8arc.scala:21:69 --------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m                smallestChange(tail.take(nextMinChange)\
    \ ++ tail.drop(nextMinChange))\n\e[31m\e[31m   |\e[0m                        \
    \                                             ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                                        Found:    (nextMinChange : Long)\n\e\
    [31m   |\e[0m                                        Required: Int\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660010570
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        // Create a stack\n        val stack = mutable.Stack[Long]()\n\
    \        arr.foreach{x => stack push x}\n        while(stack.nonEmpty) {\n   \
    \         // Pop and compare the current element with the top of the stack\n \
    \           val cur = stack.pop()\n            val top = stack.last\n        \
    \    if(top == cur){\n                // If the current element is equal to the\
    \ top of the stack, remove it\n                stack.pop()\n            }\n  \
    \          else{\n                // If it's greater than the top of the stack,\
    \ add it to the stack\n                if(top < cur){\n                    stack\
    \ push cur\n                }\n                // If it's less than the top of\
    \ the stack, remove it from the stack\n                else{\n               \
    \     stack.pop()\n                }\n            }\n        }\n        // Now\
    \ check if the stack has any elements, and return their number\n        if(stack.nonEmpty){\n\
    \            stack.toList.length\n        }\n        else{\n            0\n  \
    \      }\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp71dduudi.scala:16:20 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010566
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        var i = arr.length\n        var min = arr(0).toLong\n  \
    \      var j = arr.length - 1\n        var k = arr.length - 1\n        var temp\
    \ = 0\n\n        while(i >= 0 && j >= 0){\n            if(arr(i) != arr(k)){\n\
    \                temp = arr(i).toLong - arr(k).toLong\n                if(temp\
    \ < min){\n                    min = temp\n                }\n            }\n\
    \            i = i - 1\n            k = k - 1\n        }\n        min\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpnhxn8rt0.scala:23:23\
    \ --------------------\e[0m\e[0m\n\e[31m23 |\e[0m                temp = arr(i).toLong\
    \ - arr(k).toLong\n\e[31m\e[31m   |\e[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                       Found:    Long\n\e[31m   |\e[0m   \
    \                    Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010570
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val listSize = arr.length\n        val reverseList = new\
    \ mutable.ArrayList[Long]()\n        var i = listSize - 1\n        while(i >=\
    \ 0) {\n            reverseList += arr(i)\n            i -= 1\n        }\n   \
    \     var sum = 0\n        val minChange = new mutable.Queue[Long]()\n       \
    \ var startIndex = 0\n        var endIndex = listSize\n        if(listSize % 2\
    \ == 0) {\n            startIndex = (listSize - 1) / 2\n            endIndex =\
    \ listSize / 2\n        } else {\n            startIndex = (listSize - 1) / 2\n\
    \            endIndex = (listSize + 1) / 2\n        }\n\n        var startElement\
    \ = reverseList(startIndex)\n        var lastElement = reverseList(endIndex)\n\
    \        var lastElementChange = 0\n        val maxLength = math.min(endIndex\
    \ - startIndex, listSize)\n        var currentLength = listSize\n        while(currentLength\
    \ > 0) {\n            val maxElement = reverseList(currentLength - 1)\n      \
    \      if(maxElement == startElement) {\n                if(currentLength == listSize)\
    \ {\n                    minChange += lastElement\n                    lastElement\
    \ = 0l\n                    currentLength = listSize + 1\n                } else\
    \ {\n                    minChange += maxElement\n                    lastElementChange\
    \ = currentLength\n                    currentLength -= 1\n                }\n\
    \            } else {\n                val nextElement = reverseList(currentLength\
    \ + 1)\n                if(nextElement == lastElement) {\n                   \
    \ minChange += nextElement\n                    lastElementChange = currentLength\n\
    \                    currentLength -= 1\n                } else {\n          \
    \          minChange += maxElement\n                    lastElementChange = currentLength\n\
    \                    currentLength -= 1\n                }\n            }\n  \
    \      }\n        if(reverseList.size() < listSize) {\n            val lastElement\
    \ = reverseList(listSize)\n            if(lastElement == startElement) {\n   \
    \             minChange += lastElement\n                lastElementChange = listSize\n\
    \            } else {\n                minChange += lastElement\n            \
    \    lastElementChange = listSize\n            }\n        }\n        while(!minChange.isEmpty)\
    \ {\n            sum += minChange.dequeue\n        }\n        sum\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpdz2ciuz9.scala:16:30 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mreverseList\e[0m = \e[33mnew\e\
    [0m mutable.ArrayList[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m              \
    \                ^^^^^^^\e[0m\n\e[31m   |\e[0m                              Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpdz2ciuz9.scala:23:28\
    \ ------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e\
    [36mminChange\e[0m = \e[33mnew\e[0m mutable.Queue[\e[35mLong\e[0m]()\n\e[31m\e\
    [31m   |\e[0m                            ^^^^^^^\e[0m\n\e[31m   |\e[0m       \
    \                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010569
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length\n        val arrSize = arr.size\n   \
    \     val min = arrSize / 2\n        val min = arrSize / 2\n        for (i<-0\
    \ to arr.length-1){\n            val current = arr(i)\n            if (i % 2 ==\
    \ 0){\n                if (current < min)\n                    min = current\n\
    \            } else {\n                if (current > min)\n                  \
    \  min = current\n            }\n        }\n        arr.size - min\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp1o6wuvve.scala:18:12 ---------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = arrSize / \e\
    [31m2\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0mmin is already defined as \e[33mvalue\e[0m \e[35mmin\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp1o6wuvve.scala:23:26\
    \ --------------------\e[0m\e[0m\n\e[31m23 |\e[0m                    min = current\n\
    \e[31m\e[31m   |\e[0m                          ^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \                         Found:    (current : Long)\n\e[31m   |\e[0m        \
    \                  Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp1o6wuvve.scala:26:26 --------------------\e[0m\e[0m\n\e[31m26\
    \ |\e[0m                    min = current\n\e[31m\e[31m   |\e[0m             \
    \             ^^^^^^^\e[0m\n\e[31m   |\e[0m                          Found:  \
    \  (current : Long)\n\e[31m   |\e[0m                          Required: Int\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010571
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.size\n        if (n <= 1)\n            return\
    \ 0\n        val mid = (n - 1) / 2\n        // Reverse the subarray starting at\
    \ index mid to index mid - 1\n        val (rev1, rev2) = arr.splitAt(mid)\n  \
    \      // Do the same for the subarray starting from mid to n - 1\n        val\
    \ (r1, r2) = rev2.splitAt(n - mid)\n        // Now add up the difference between\
    \ the first half of the reversed subarray\n        // and the first half of the\
    \ reversed subarray + the first half of the original subarray.\n        // This\
    \ will be the minimum number of elements needed to reverse the subarray.\n   \
    \     //\n        // For the first half of the reversed subarray, reverse the\
    \ entire list\n        // and add the first half of the original list to it. \n\
    \        // For the first half of the original subarray,\n        // reverse the\
    \ subarray and add the first half of the reversed subarray to it.\n        //\
    \ The difference between the two halves of the reversed subarray will \n     \
    \   // be the minimum number of elements needed to reverse the original subarray.\n\
    \        // Repeat this procedure for each half of the original array.\n     \
    \   //\n        // The answer will be the minimum number of elements needed to\
    \ reverse the\n        // original subarray.\n        // For a more detailed explanation\
    \ see Section 5.2 of \"Intro to Algorithms\" by CLRS or section 5.3 of \"Intro\
    \ to Algorithms\" by CLRS in \"Algorithms for Programmers Volume 2\" by Bentley.\n\
    \        //\n        // Time Complexity: O(n)\n        val m = r1.size\n     \
    \   val r = r1.size + r2.size + arr.size\n        (if (r < m)\n            r\n\
    \        else\n            m) \n    }\n    def main(args: Array[String]) = {\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpjzceyfkn.scala:48)\n\tat Problem.main(tmpjzceyfkn.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010573
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        var arr = arr.toList\n        var minChanges = arr.length\n\
    \        val maxDiff = arr.tail.diff(arr).toInt\n        val minDiff = arr.head.diff(arr).toInt\n\
    \        minDiff = if (minDiff < 0) -minDiff else minDiff\n        val maxDiffInt\
    \ = maxDiff.toInt\n        minChanges = if (minChanges < 0) -minChanges else minChanges\n\
    \        while (arr.head != arr.tail) {\n            var currentMinDiff = arr.head.diff(arr).toInt\n\
    \            var currentMinChanges = arr.head.diff(arr).toInt\n            currentMinDiff\
    \ = if (currentMinDiff < 0) -currentMinDiff else currentMinDiff\n            currentMinChanges\
    \ = if (currentMinChanges < 0) -currentMinChanges else currentMinChanges\n   \
    \         minDiff = minDiff.min(currentMinDiff)\n            minChanges = minChanges.min(currentMinChanges)\n\
    \            arr = arr.tail\n        }\n        arr.length\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpg_fx1poh.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mvar\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvariable\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E052] Type Error: /tmp/tmpg_fx1poh.scala:19:16 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        minDiff = \e[33mif\e[0m (minDiff < \e[31m0\e\
    [0m) -minDiff \e[33melse\e[0m minDiff\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Reassignment to val minDiff\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E052] Type Error: /tmp/tmpg_fx1poh.scala:27:20 -----------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m            minDiff = minDiff.min(currentMinDiff)\n\e\
    [31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m            Reassignment to val minDiff\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010568
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        var minChange = arr.length\n        for (i <- 0 until arr.length\
    \ / 2) {\n            var current = 0\n            var start = 0\n           \
    \ var end = arr.length - 1\n            while (start < end) {\n              \
    \  if (current == arr[start].get) current += 1\n                else if (current\
    \ == arr[end].get) current -= 1\n                else {\n                    if\
    \ (current > 0) start++\n                    else end--\n                }\n \
    \           }\n            if (current < minChange) minChange = current\n    \
    \    }\n        minChange\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp6s32d2sc.scala:24:44 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m                    \e[33mif\e[0m (current > \e[31m0\e\
    [0m) start++\n\e[31m\e[31m   |\e[0m                                          \
    \  ^\e[0m\n\e[31m   |\e[0m                                      expression expected\
    \ but \e[31melse\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp6s32d2sc.scala:21:35 ------------------------\e[0m\e[0m\n\e[31m21 |\e\
    [0m                \e[33mif\e[0m (current == arr[\e[35mstart\e[0m].get) current\
    \ += \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m                                   ^^^^^\e\
    [0m\n\e[31m   |\e[0m                                   Not found: type start\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp6s32d2sc.scala:22:40\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m                \e[33melse\e\
    [0m \e[33mif\e[0m (current == arr[end].get) current -= \e[31m1\e[0m\n\e[31m\e\
    [31m   |\e[0m                                        ^^^\e[0m\n\e[31m   |\e[0m\
    \                                        Not found: type end\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1660010571
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        def smallestChangeHelper(arr: List[Long], arrReverse: List[Long]):\
    \ Long = {\n            if(arr.isEmpty)\n                return 0\n          \
    \  val newArrReverse = arrReverse.head\n            var largest = arr.head\n \
    \           for(i <- 1 until arr.length)\n                if(arr(i) == largest)\n\
    \                    largest += arrReverse(i)\n            val minChange = smallest\
    \ + largest\n            if(smallest > largest)\n                smallestChangeHelper(arr.tail,\
    \ newArrReverse)\n            else\n                smallestChangeHelper(newArrReverse,\
    \ arr)\n        }\n\n        smallestChangeHelper(arr, arr.reverse)\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpzc5xfrfw.scala:23:28 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            \e[33mval\e[0m \e[36mminChange\e[0m = smallest\
    \ + largest\n\e[31m\e[31m   |\e[0m                            ^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                            Not found: smallest\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpzc5xfrfw.scala:24:15 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m            \e[33mif\e[0m(smallest > largest)\n\e[31m\e\
    [31m   |\e[0m               ^^^^^^^^\e[0m\n\e[31m   |\e[0m               Not found:\
    \ smallest\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpzc5xfrfw.scala:25:47\
    \ --------------------\e[0m\e[0m\n\e[31m25 |\e[0m                smallestChangeHelper(arr.tail,\
    \ newArrReverse)\n\e[31m\e[31m   |\e[0m                                      \
    \         ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                                \
    \        Found:    (newArrReverse : Long)\n\e[31m   |\e[0m                   \
    \                     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpzc5xfrfw.scala:27:37 --------------------\e[0m\e\
    [0m\n\e[31m27 |\e[0m                smallestChangeHelper(newArrReverse, arr)\n\
    \e[31m\e[31m   |\e[0m                                     ^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                     Found:    (newArrReverse :\
    \ Long)\n\e[31m   |\e[0m                                     Required: List[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660010574
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        var sum = 0l\n        var count = 1\n        var index =\
    \ 0\n        var flag = false\n        var temp = arr.head\n\n        while(index\
    \ < arr.length){\n            if(arr(index) < temp){\n                temp = arr(index)\n\
    \            }\n            index = index + 1\n        }\n\n        for(i = 0;\
    \ i < arr.length; i++){\n            if(arr(i) == temp){\n                sum\
    \ = sum + 1l\n            }\n        }\n\n        while(index < arr.length){\n\
    \            if(arr(index) > temp){\n                temp = arr(index)\n     \
    \       }\n            index = index + 1\n        }\n\n        for(i = 0; i <\
    \ arr.length; i++){\n            if(arr(i) == temp){\n                sum = sum\
    \ + 1l\n            }\n        }\n\n        for(i = 0; i < arr.length; i++){\n\
    \            if(arr(i) != temp){\n                count = count + 1\n        \
    \        flag = true\n            }\n        }\n\n        if(flag){\n        \
    \    return 0l\n        }\n        return sum + count\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpw_mrzdh8.scala:28:14 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mfor\e[0m(i = \e[31m0\e[0m; i < arr.length;\
    \ i++){\n\e[31m\e[31m   |\e[0m              ^\e[0m\n\e[31m   |\e[0m          \
    \    ')' expected, but '=' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpw_mrzdh8.scala:28:33\
    \ ---------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mfor\e[0m(i\
    \ = \e[31m0\e[0m; i < arr.length; i++){\n\e[31m\e[31m   |\e[0m               \
    \                  ^\e[0m\n\e[31m   |\e[0m                                 '<-'\
    \ expected, but ';' found\n\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpw_mrzdh8.scala:28:38\
    \ ---------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mfor\e[0m(i\
    \ = \e[31m0\e[0m; i < arr.length; i++){\n\e[31m\e[31m   |\e[0m               \
    \                       ^\e[0m\n\e[31m   |\e[0m                              \
    \        pattern expected\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tmpw_mrzdh8.scala:41:14 ---------------------------\e[0m\e[0m\n\e[31m41\
    \ |\e[0m        \e[33mfor\e[0m(i = \e[31m0\e[0m; i < arr.length; i++){\n\e[31m\e\
    [31m   |\e[0m              ^\e[0m\n\e[31m   |\e[0m              ')' expected,\
    \ but '=' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpw_mrzdh8.scala:41:33\
    \ ---------------------------\e[0m\e[0m\n\e[31m41 |\e[0m        \e[33mfor\e[0m(i\
    \ = \e[31m0\e[0m; i < arr.length; i++){\n\e[31m\e[31m   |\e[0m               \
    \                  ^\e[0m\n\e[31m   |\e[0m                                 '<-'\
    \ expected, but ';' found\n\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpw_mrzdh8.scala:41:38\
    \ ---------------------------\e[0m\e[0m\n\e[31m41 |\e[0m        \e[33mfor\e[0m(i\
    \ = \e[31m0\e[0m; i < arr.length; i++){\n\e[31m\e[31m   |\e[0m               \
    \                       ^\e[0m\n\e[31m   |\e[0m                              \
    \        pattern expected\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tmpw_mrzdh8.scala:47:14 ---------------------------\e[0m\e[0m\n\e[31m47\
    \ |\e[0m        \e[33mfor\e[0m(i ="
  stdout: ''
  timestamp: 1660010577
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val m = arr.max\n        val l = arr.min\n        val diff\
    \ = m - l - 1\n        if(diff <= 0) {\n            return 0\n        }\n    \
    \    else if(diff < 0) {\n            val n = arr.length\n            val dl =\
    \ l - n - 1\n            if(dl <= 0) {\n                return 0\n           \
    \ }\n            else if(dl < 0) {\n                return -1\n            }\n\
    \        }\n        val p = scala.util.Sorting.quickSort(arr.toList).reverse\n\
    \        val s = (p + p).min\n        return Math.abs(s)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmp0wvjb1ds.scala:31:35 -----------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mp\e[0m = scala.util.Sorting.quickSort(arr.toList).reverse\n\
    \e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e[35mquickSort\e\
    [0m in \e[33mobject\e[0m \e[35mSorting\e[0m with types\n\e[31m   |\e[0m [K](a:\
    \ Array[K])(\e[33mimplicit \e[0mevidence$1: Ordering[K]): Unit\n\e[31m   |\e[0m\
    \ (a: Array[Float]): Unit\n\e[31m   |\e[0m (a: Array[Int]): Unit\n\e[31m   |\e\
    [0m (a: Array[Double]): Unit\n\e[31m   |\e[0mmatch arguments ((arr.toList : =>\
    \ List[Long]))\n1 error found\n"
  stdout: ''
  timestamp: 1660010572
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        var change = 0\n        for (i <- 0 until arr.length) {\n\
    \            val prev = arr.head\n            val next = arr.last\n          \
    \  arr.head = next\n            arr.last = prev\n            change = Math.min(change,\
    \ arr.length - 1)\n        }\n        change\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmpz6i89w8a.scala:19:21 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m            arr.head = next\n\e[31m\e[31m   |\e[0m  \
    \          ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            Reassignment to val\
    \ head\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmpz6i89w8a.scala:20:21\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m            arr.last\
    \ = prev\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m            Reassignment to val last\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010573
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val len = arr.size\n        var cur = 0\n        var min\
    \ = Integer.MIN_VALUE\n        var min = len\n        var left = 0\n        var\
    \ right = (len - 1)\n\n        while ( left < right ) {\n            val mid =\
    \ math.floor((left + right) / 2)\n            val leftElem = arr(mid)\n      \
    \      val rightElem = arr(len - mid - 1)\n            if (leftElem == rightElem)\
    \ {\n                cur = cur + 1\n                min = Math.min(min, cur)\n\
    \                left = mid + 1\n                right = (len - mid - 1)\n   \
    \         } else if (leftElem < rightElem) {\n                min = Math.min(min,\
    \ cur)\n                left = mid + 1\n            } else {\n               \
    \ right = mid\n            }\n        }\n        min\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmptkg32j0u.scala:18:12 ---------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mvar\e[0m \e[36mmin\e[0m = len\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmin is already defined\
    \ as \e[33mvariable\e[0m \e[35mmin\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmptkg32j0u.scala:24:31 --------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m            \e[33mval\e[0m \e[36mleftElem\e[0m = arr(mid)\n\
    \e[31m\e[31m   |\e[0m                               ^^^\e[0m\n\e[31m   |\e[0m\
    \                               Found:    (mid : Double)\n\e[31m   |\e[0m    \
    \                           Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmptkg32j0u.scala:25:32 --------------------\e[0m\e\
    [0m\n\e[31m25 |\e[0m            \e[33mval\e[0m \e[36mrightElem\e[0m = arr(len\
    \ - mid - \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m                               \
    \ ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                                Found:  \
    \  Double\n\e[31m   |\e[0m                                Required: Int\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmptkg32j0u.scala:29:23 --------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m                left = mid + \e[31m1\e[0m\n\e[31m\e[31m\
    \   |\e[0m                       ^^^^^^^\e[0m\n\e[31m   |\e[0m               \
    \        Found:    Double\n\e[31m   |\e[0m                       Required: Int\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmptkg32j0u.scala:30:25\
    \ --------------------\e[0m\e[0m\n\e[31m30 |\e[0m                right = (len\
    \ - mid - \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m                         ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                         Found:    Double\n\e[31m   |\e[0m\
    \                         Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ exp"
  stdout: ''
  timestamp: 1660010578
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        if (arr.length == 1) return 0\n        val mn = arr.min\n\
    \        var changeCount = 0\n        // O(n)\n        for (i <- arr.indices if\
    \ arr(i) != mn) changeCount++\n        changeCount\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpqpljalxq.scala:19:58 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mfor\e[0m (i <- arr.indices \e[33mif\e[0m\
    \ arr(i) != mn) changeCount++\n\e[31m\e[31m   |\e[0m                         \
    \                      ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                   \
    \                      value ++ is not a member of Int\n1 error found\n"
  stdout: ''
  timestamp: 1660010577
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        var result = arr.head\n        var temp = arr\n        for\
    \ (i<-arr.length to 1 by -1){\n            var temp = arr\n            temp.foreach{\
    \ x=> if(x.toLong<i) temp = temp::(x::temp)}\n            var changed = temp\n\
    \            if(temp.isEmpty || changed == temp.reverse){\n                temp\
    \ = temp.reverse\n                changed = temp\n            }\n            result\
    \ = result + Math.max(temp.length - changed.size, 0)\n        }\n        result\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpkvwaug7p.scala:19:52\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            temp.foreach{ \e\
    [36mx\e[0m=> \e[33mif\e[0m(x.toLong<i) temp = temp::(x::temp)}\n\e[31m\e[31m \
    \  |\e[0m                                                    ^^^^\e[0m\n\e[31m\
    \   |\e[0m                                           Found:    (temp : List[Long])\n\
    \e[31m   |\e[0m                                           Required: Long\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010578
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        var change = 0\n        var temp = 0\n        arr.sortWith((x,y)\
    \ => x.toLong <=> y.toLong)\n        arr.foreach { x =>\n            temp = arr.reverse.find(y=>\
    \ y.toLong == x)\n            if(temp.isDefined && temp.toLong != x) {\n     \
    \           change++\n            }\n        }\n        change\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp664onkmh.scala:21:24 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m                change++\n\e[31m\e[31m   |\e[0m     \
    \                   ^\e[0m\n\e[31m   |\e[0m                        expression\
    \ expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmp664onkmh.scala:17:39 ------------------------\e[0m\e[0m\n\e[31m17 |\e\
    [0m        arr.sortWith((\e[36mx\e[0m,\e[36my\e[0m) => x.toLong <=> y.toLong)\n\
    \e[31m\e[31m   |\e[0m                              ^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0m               value <=> is not a member of Long - did you mean Long.<=?\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp664onkmh.scala:19:35 --------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m            temp = arr.reverse.find(\e[36my\e[0m=> y.toLong\
    \ == x)\n\e[31m\e[31m   |\e[0m                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                   Found:    Option[Long]\n\e[31m   |\e[0m\
    \                   Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmp664onkmh.scala:20:20 ------------------------\e[0m\e[0m\n\e[31m20 |\e\
    [0m            \e[33mif\e[0m(temp.isDefined && temp.toLong != x) {\n\e[31m\e[31m\
    \   |\e[0m               ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m               value\
    \ isDefined is not a member of Int\n4 errors found\n"
  stdout: ''
  timestamp: 1660010579
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val counts = arr.groupBy(x => x%2==0).mapValues(_.length).filter(_._2\
    \ == arr.length).toSeq\n        counts.length match {\n            case 0 => 0\n\
    \            case 1 => arr(0)\n            case _ => {\n                val reversed\
    \ = arr.foldLeft(List[Long]())((acc, x) => if(acc == List[Long]()) List(x) ::\
    \ acc else acc ::: List(x))\n                val maxCount = reversed.foldLeft(0l)((acc,\
    \ x) => if (acc == 0 || x > reversed(acc)) x else acc)\n                val newCount\
    \ = reversed.foldLeft(1l)((acc, x) => if (acc == 0 || x > reversed(acc)) x + 1\
    \ else acc)\n                maxCount - newCount\n            }\n        }\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4d7zxog6.scala:20:98\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m                \e[33mval\e[0m\
    \ \e[36mreversed\e[0m = arr.foldLeft(List[\e[35mLong\e[0m]())((\e[36macc\e[0m,\
    \ \e[36mx\e[0m) => \e[33mif\e[0m(acc == List[\e[35mLong\e[0m]()) List(x) :: acc\
    \ \e[33melse\e[0m acc ::: List(x))\n\e[31m\e[31m   |\e[0m                    \
    \                                                                          ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                                    Found:\
    \    \e[1m\e[31mList\e[0m\e[1m\e[31m[\e[0mLong\e[1m\e[31m]\e[0m\n\e[31m   |\e\
    [0m                                                    Required: Long\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4d7zxog6.scala:21:94 --------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m                \e[33mval\e[0m \e[36mmaxCount\e[0m =\
    \ reversed.foldLeft(\e[31m0l\e[0m)((\e[36macc\e[0m, \e[36mx\e[0m) => \e[33mif\e\
    [0m (acc == \e[31m0\e[0m || x > reversed(acc)) x \e[33melse\e[0m acc)\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \                              ^^^\e[0m\n\e[31m   |\e[0m                     \
    \                             Found:    (acc : Long)\n\e[31m   |\e[0m        \
    \                                          Required: Int\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4d7zxog6.scala:22:94 --------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m                \e[33mval\e[0m \e[36mnewCount\e[0m =\
    \ reversed.foldLeft(\e[31m1l\e[0m)((\e[36macc\e[0m, \e[36mx\e[0m) => \e[33mif\e\
    [0m (acc == \e[31m0\e[0m || x > reversed(acc)) x + \e[31m1\e[0m \e[33melse\e[0m\
    \ acc)\n\e[31m\e[31m   |\e[0m                                                \
    \                                              ^^^\e[0m\n\e[31m   |\e[0m     \
    \                                             Found:    (acc : Long)\n\e[31m \
    \  |\e[0m                                                  Required: Int\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available "
  stdout: ''
  timestamp: 1660010578
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        // Write your code here\n        var min = arr.length\n\
    \        var count = 0\n        for(i<- arr.length-1 to 0 by -1){\n          \
    \  count += 1\n            if(arr.toList.map(_+1).equals(arr.toList.map(_-1))){\n\
    \                min = count\n            }\n        }\n        min\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5nw37r8_.scala:27)\n\tat Problem.main(tmp5nw37r8_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010581
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val len = arr.length\n        if(len == 1) 0\n        else\
    \ if(len == 2) 1\n        else {\n            val arr1 = arr.takeRight(len/2)\n\
    \            val arr2 = arr.drop(len/2)\n            val p1 = smallestChange(arr1)\n\
    \            val p2 = smallestChange(arr2)\n            if(p1 < p2) p1 else p2\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp8a8qc1w1.scala:27)\n\tat Problem.main(tmp8a8qc1w1.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010580
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        if(arr.isEmpty) 0\n        else if(arr.head.toString ==\
    \ arr.tail.head.toString) arr.size\n        else if(arr.head.toLong == arr.tail.head.toLong)\
    \ arr.size\n        else smallestChange(arr.tail).min(arr.head.toLong)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.util.NoSuchElementException: head of empty list\n\tat scala.collection.immutable.Nil$.head(List.scala:662)\n\
    \tat scala.collection.immutable.Nil$.head(List.scala:661)\n\tat Problem$.smallestChange(tmpg92k5wtu.scala:16)\n\
    \tat Problem$.smallestChange(tmpg92k5wtu.scala:18)\n\tat Problem$.smallestChange(tmpg92k5wtu.scala:18)\n\
    \tat Problem$.smallestChange(tmpg92k5wtu.scala:18)\n\tat Problem$.smallestChange(tmpg92k5wtu.scala:18)\n\
    \tat Problem$.smallestChange(tmpg92k5wtu.scala:18)\n\tat Problem$.smallestChange(tmpg92k5wtu.scala:18)\n\
    \tat Problem$.smallestChange(tmpg92k5wtu.scala:18)\n\tat Problem$.main(tmpg92k5wtu.scala:21)\n\
    \tat Problem.main(tmpg92k5wtu.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010580
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        if (arr.isEmpty) {\n            return 0\n        }\n\n\
    \        val result = arr.foldLeft(arr.size - 1){\n            (count, cur) =>\
    \ count\n        }\n\n        val reversed = arr.reverse\n        val isPalindrome\
    \ = reversed == arr\n        if (reversed.size < arr.size && !isPalindrome) {\n\
    \            return 0\n        }\n\n        val changes = arr.size - 1\n     \
    \   (result - changes, changes)\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpun335_x0.scala:30:8\
    \ ---------------------\e[0m\e[0m\n\e[31m30 |\e[0m        (result - changes, changes)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \        Found:    (Int, Int)\n\e[31m   |\e[0m        Required: Long\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010579
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val m = arr.foldLeft(arr.head) { (i, x) => if (x.compareTo(i)\
    \ < 0) x else i }\n        val n = arr.foldRight(arr.head) { (i, x) => if (x.compareTo(i)\
    \ < 0) x else i }\n        val sum = arr.foldLeft(arr.head + 1) { (i, x) => if\
    \ (x.compareTo(i) < 0) x else i }\n        val len = len - 1 // -1 because the\
    \ first element in the list has already been changed to match it\n        val\
    \ diff = (m * n - sum) / len\n        diff + arr.size\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpsw8lqouv.scala:18:18 ---------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mlen\e[0m = len - \e[31m1\e\
    [0m \e[34m// -1 because the first element in the list has already been changed\
    \ to match it\e[0m\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e\
    [0m                  Recursive \e[33mvalue\e[0m \e[35mlen\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010578
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        def f(n : Long, list : List[Long]) : List[Long] = list match\
    \ {\n            case x :: xs if (x != n) => x :: f(n, xs)\n            case x\
    \ :: xs => x :: xs\n            case Nil => Nil\n        }\n        val n = arr(arr.length-1)\n\
    \        if (arr.length == 1) n\n        else {\n            val left = f(arr(0),\
    \ arr :: Nil)\n            val right = f(n - arr(arr.length-1), arr.reverse)\n\
    \            arr.length - left.length + right.length\n        }\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmph385jzlg.scala:23:33\
    \ --------------------\e[0m\e[0m\n\e[31m23 |\e[0m            \e[33mval\e[0m \e\
    [36mleft\e[0m = f(arr(\e[31m0\e[0m), arr :: Nil)\n\e[31m\e[31m   |\e[0m      \
    \                           ^^^\e[0m\n\e[31m   |\e[0m                        \
    \         Found:    (arr : List[Long])\n\e[31m   |\e[0m                      \
    \           Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010580
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val len = arr.length\n        var count = 1\n        val\
    \ m = new mutable.HashMap[Long, Long]()\n        for (i <- 1 to len) {\n     \
    \       if (m.contains(arr(i))) {\n                count = count + 1\n       \
    \     } else {\n                m.put(arr(i), count)\n                count =\
    \ count + 1\n            }\n        }\n\n        var minCount = count\n      \
    \  var minChange = 0\n        for (i <- 1 to len) {\n            val currentCount\
    \ = m.get(arr(i))\n            if (currentCount > minCount) {\n              \
    \  minCount = currentCount\n                minChange = arr(i)\n            }\n\
    \        }\n        minChange\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpso9e_gym.scala:17:20 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mm\e[0m = \e[33mnew\e[0m\
    \ mutable.HashMap[\e[35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpso9e_gym.scala:33:31\
    \ --------------------\e[0m\e[0m\n\e[31m33 |\e[0m                minChange = arr(i)\n\
    \e[31m\e[31m   |\e[0m                            ^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                            Found:    Long\n\e[31m   |\e[0m                 \
    \           Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010580
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        // Solution using dynamic programming\n        // Using\
    \ a mutable matrix to store the current min number of elements that can be changed\
    \ to make the list palindromic\n        val m = arr.length\n        val n = arr.head\n\
    \        val p = new Array[List[Long]](m)\n        var i = 1\n        var j =\
    \ 0\n        while (i <= m-1) {\n            if (i == j) {\n                //\
    \ For the first element in the array\n                p(i) = n\n             \
    \   i += 1\n            }\n            else if (arr[i - 1] != arr[j]) {\n    \
    \            // If the element at i doesn't match the element at j\n         \
    \       // then we need to change one element\n                p(i) = min(arr(i),\
    \ arr(j))\n                i += 1\n            }\n            else {\n       \
    \         // If the element at i matches the element at j then\n             \
    \   // we need to change two elements\n                p(i) = min(arr(i), arr(j))\n\
    \                j += 1\n            }\n        }\n        p(0)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp1mgtbeb_.scala:25:23\
    \ --------------------\e[0m\e[0m\n\e[31m25 |\e[0m                p(i) = n\n\e\
    [31m\e[31m   |\e[0m                       ^\e[0m\n\e[31m   |\e[0m            \
    \           Found:    (n : Long)\n\e[31m   |\e[0m                       Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp1mgtbeb_.scala:28:27\
    \ ------------------------\e[0m\e[0m\n\e[31m28 |\e[0m            \e[33melse\e\
    [0m \e[33mif\e[0m (arr[i - \e[31m1\e[0m] != arr[j]) {\n\e[31m\e[31m   |\e[0m \
    \                          ^\e[0m\n\e[31m   |\e[0m                           Not\
    \ found: type -\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp1mgtbeb_.scala:31:26\
    \ --------------------\e[0m\e[0m\n\e[31m31 |\e[0m                p(i) = min(arr(i),\
    \ arr(j))\n\e[31m\e[31m   |\e[0m                       ^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                       Found:    Long\n\e[31m   |\e[0m        \
    \               Required: \e[1m\e[32mList\e[0m\e[1m\e[32m[\e[0mLong\e[1m\e[32m]\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp1mgtbeb_.scala:37:26\
    \ --------------------\e[0m\e[0m\n\e[31m37 |\e[0m                p(i) = min(arr(i),\
    \ arr(j))\n\e[31m\e[31m   |\e[0m                       ^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                       Found:    Long\n\e[31m   |\e[0m        \
    \               Required: \e[1m\e[32mList\e[0m\e[1m\e[32m[\e[0mLong\e[1m\e[32m]\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp1mgtbeb_.scala:41:9\
    \ ---------------------\e[0m\e[0m\n\e[31m41 |\e[0m        p(\e[31m0\e[0m)\n\e\
    [31m\e[31m   |\e[0m        ^^^^\e[0m\n\e[31m   |\e[0m        Found:    \e[1m\e\
    [31mList\e[0m\e[1m\e[31m[\e[0mLong\e[1m\e[31m]\e[0m\n\e[31m   |\e[0m        Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explai"
  stdout: ''
  timestamp: 1660010582
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.sortWith(_ < _)\n        var counter = 0\n\
    \        var j = 0\n        var i = 0\n        while(j < arr.length){\n      \
    \      while(j >= 0 && arr(i) == arr(i+1)){\n                j -= 1\n        \
    \        i += 1\n            }\n            if(j >= 0){\n                counter\
    \ += j\n                j = 0\n            }\n        }\n        counter\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpy20r5nas.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortWith(_\
    \ < _)\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m       \
    \           Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010580
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.size\n        val m = 2 * arr.size\n       \
    \ val p = m / 2\n\n        val l = new Array[Long](m)\n\n        for (i <- 0 until\
    \ p)\n            l(i) = arr(i)\n\n        for ((i <- 0 until m)) {\n        \
    \    val j = i + 1\n            val k = j - 1\n            if (l(i) != arr(k))\n\
    \                l(i) = arr(k)\n        }\n\n        val sumOf2 = 0\n        for\
    \ (i <- 0 until p) {\n            sumOf2 = sumOf2 + l(i) * l(i)\n        }\n\n\
    \        val sumOf1 = n - sumOf2\n        return sumOf1\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp6yc_47kl.scala:24:16 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mfor\e[0m ((i <- \e[31m0\e[0m until m))\
    \ {\n\e[31m\e[31m   |\e[0m                ^^\e[0m\n\e[31m   |\e[0m           \
    \     ')' expected, but '<-' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp6yc_47kl.scala:24:31\
    \ ---------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mfor\e[0m\
    \ ((i <- \e[31m0\e[0m until m)) {\n\e[31m\e[31m   |\e[0m                     \
    \          ^\e[0m\n\e[31m   |\e[0m                               '<-' expected,\
    \ but '{' found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp6yc_47kl.scala:29:9\
    \ -------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        }\n\e[31m\e[31m\
    \   |\e[0m         ^\e[0m\n\e[31m   |\e[0mvalue foreach is not a member of Null,\
    \ but could be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mOne of the following imports might fix the problem:\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m  import Option.option2Iterable\n\e[31m   |\e[0m  import collection.LazyZip2.lazyZip2ToIterable\n\
    \e[31m   |\e[0m  import collection.LazyZip3.lazyZip3ToIterable\n\e[31m   |\e[0m\
    \  import collection.LazyZip4.lazyZip4ToIterable\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.list\
    \ asScalaBuffer\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.properties\
    \ AsScalaMap\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.enumeration\
    \ AsScalaIterator\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.iterator\
    \ asScala\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.map\
    \ AsScalaConcurrentMap\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.set\
    \ asScala\n\e[31m   |\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m sumOf2 = \e\
    [31m0\e[0m\n3 errors found\n"
  stdout: ''
  timestamp: 1660010583
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n       //Sort descending order and reverse the array \n       //and\
    \ remove duplicate items from the reversed array\n       arr.sortWith(_>_).reverse.toSet.toList.distinct\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpqv3ko534.scala:17:46\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m       arr.sortWith(_>_).reverse.toSet.toList.distinct\n\
    \e[31m\e[31m   |\e[0m       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m       Found:    \e[1m\e[31mList\e[0m\e[1m\e[31m[\e[0mLong\e\
    [1m\e[31m]\e[0m\n\e[31m   |\e[0m       Required: Long\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660010582
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        arr.foldLeft(0)(_+arr.reverse match { case a :: b => smallestChange(b\
    \ diff a) })\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E086] Syntax Error: /tmp/tmpeakev051.scala:15:24 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        arr.foldLeft(\e[31m0\e[0m)(_+arr.reverse \e[33mmatch\e\
    [0m { \e[33mcase\e[0m a :: b => smallestChange(b diff a) })\n\e[31m\e[31m   |\e\
    [0m                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                        Wrong number of parameters, expected:\
    \ 2\n1 error found\n"
  stdout: ''
  timestamp: 1660010579
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val l = arr.size\n        val l = arr.min\n        val l\
    \ = arr.max\n        val l = (l / 2).toInt\n        val l = arr.min\n        val\
    \ l = arr.max\n        val l = (l / 2).toInt\n        val l = arr.min\n      \
    \  val l = arr.max\n        val l = arr.size\n        val l = arr.min\n      \
    \  val l = arr.max\n        val l = arr.min\n        val l = arr.max\n       \
    \ val l = arr.min\n        val l = arr.max\n        val l = arr.min\n        val\
    \ l = arr.max\n        val l = arr.min\n        val l = arr.max\n        val l\
    \ = arr.min\n        val l = arr.max\n        val l = arr.min\n        val l =\
    \ arr.max\n        val l = arr.min\n        val l = arr.max\n        val l = arr.min\n\
    \        val l = arr.max\n        val l = arr.min\n        val l = arr.max\n \
    \       val l = arr.min\n        val l = arr.max\n        val l = arr.min\n  \
    \      val l = arr.max\n        val l = arr.min\n        val l = arr.max\n   \
    \     val l = arr.min\n        val l = arr.max\n        val l = arr.min\n    \
    \    val l = arr.max\n        val l = arr.min\n        val l = arr.max\n     \
    \   val l = arr.min\n        val l = arr.max\n        val l = arr.min\n      \
    \  val l = arr.max\n        val l = arr.min\n        val l = arr.max\n       \
    \ val l = arr.min\n        val l = arr.max\n        val l = arr.min\n        val\
    \ l = arr.max\n        val l = arr.min\n        val l = arr.max\n        val l\
    \ = arr.min\n        val l = arr.max\n        val l = arr.min\n        val l =\
    \ arr.max\n        val l = arr.min\n        val l = arr.max\n        val l = arr.min\n\
    \        val l = arr.max\n        val l = arr.min\n        val l = arr.max\n \
    \       val l = arr.min\n        val l = arr.max\n        val l = arr.min\n  \
    \      val l = arr.max\n        val l = arr.min\n        val l = arr.max\n   \
    \     val l = arr.min\n        val l = arr.max\n        val l = arr.min\n    \
    \    val l = arr.max\n        val l = arr.min\n        val l = arr.max\n     \
    \   val l = arr.min\n        val l = arr.max\n        val l = arr.min\n      \
    \  val l = arr.max\n        val l = arr.min\n        val l = arr.max\n       \
    \ val l = arr.min\n        val l = arr.max\n\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7vix5b4p.scala:16:12 ---------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36ml\e[0m = arr.min\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0ml is already defined\
    \ as \e[33mvalue\e[0m \e[35ml\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7vix5b4p.scala:17:12 ---------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36ml\e[0m = arr.max\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0ml is already defined\
    \ as \e[33mvalue\e[0m \e[35ml\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7vix5b4p.scala:18:12 ---------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36ml\e[0m = (l / \e[31m2\e\
    [0m).toInt\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0ml is already defined as \e[33mvalue\e[0m \e[35ml\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7vix5b4p.scala:19:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m\
    \ \e[36ml\e[0m = arr.min\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0ml is already defined as \e[33mvalue\e[0m \e[35ml\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7vix5b4p.scala:20:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m\
    \ \e[36ml\e[0m = arr.max\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0ml is already defined as \e[33mvalue\e[0m \e[35ml\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7vix5b4p.scala:21:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e["
  stdout: ''
  timestamp: 1660010583
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        // Write your code here.\n        val maxLen = arr.length\n\
    \        val stack = mutable.Stack[Long]()\n        val visited = mutable.HashSet[Long]()\n\
    \        val changed = mutable.HashSet[Long]()\n        for (i<- 0 until maxLen){\n\
    \            if (visited(i)){\n                stack.pop()\n                visited(i)\n\
    \            }\n            else if (stack.isEmpty || arr(i) != stack.pop()){\n\
    \                stack.push(arr(i))\n                visited.add(arr(i))\n   \
    \             changed.add(arr(i))\n            }\n        }\n        if (!stack.isEmpty)\
    \ changed(stack.pop())\n        if (stack.isEmpty) changed(0)\n        changed.size\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpw4_axwhh.scala:17:20 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpw4_axwhh.scala:18:22 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mvisited\e[0m = mutable.HashSet[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpw4_axwhh.scala:19:22 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mchanged\e[0m = mutable.HashSet[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010582
- exit_code: -1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val len = arr.length\n        var left = 0\n        var\
    \ right = 0\n\n        while(left < len) {\n            right = len - left\n \
    \           if(right > 1) {\n                val mid = left + (right >> 1)\n \
    \               if(arr.tail.tail.tail.forall(a => a == arr.tail.last) &&  arr.tail.forall(a\
    \ => a == arr.last)) {\n                    left += right\n                  \
    \  right = mid\n                    if(left > len) {\n                       \
    \ left = 0\n                    }\n                } else {\n                \
    \    right = mid - 1\n                }\n            } else {\n              \
    \  if(arr.tail.forall(a => a == arr.last)) {\n                    left += 1;\n\
    \                }\n            }\n        }\n        if(left > 0) {\n       \
    \     left\n        } else {\n            0\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1660010589
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        var ans = ListBuffer.empty[Long]\n        arr.foreach {\
    \ x =>\n            val reverse = arr.reverse\n            val len = arr.size\n\
    \            var max = 0\n            var i = 0\n            for (i<len/2 ; i\
    \ <len-i; i++ ) {\n                if (x>reverse(i)) {\n                    max\
    \ = i\n                    break;\n                }\n            }\n        \
    \    ans += (arr(max).toLong)\n        }\n        ans.min\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpuhubj3id.scala:21:25 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m            \e[33mfor\e[0m (i<len/\e[31m2\e[0m ; i <len-i;\
    \ i++ ) {\n\e[31m\e[31m   |\e[0m                         ^\e[0m\n\e[31m   |\e\
    [0m                         ')' expected, but ';' found\n\e[31m\e[31m-- [E040]\
    \ Syntax Error: /tmp/tmpuhubj3id.scala:21:29 ---------------------------\e[0m\e\
    [0m\n\e[31m21 |\e[0m            \e[33mfor\e[0m (i<len/\e[31m2\e[0m ; i <len-i;\
    \ i++ ) {\n\e[31m\e[31m   |\e[0m                             ^\e[0m\n\e[31m  \
    \ |\e[0m                             '<-' expected, but $XMLSTART$< found\n\e\
    [31m\e[31m-- [E032] Syntax Error: /tmp/tmpuhubj3id.scala:21:41 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m            \e[33mfor\e[0m (i<len/\e[31m2\e[0m ; i <len-i;\
    \ i++ ) {\n\e[31m\e[31m   |\e[0m                                         ^\e[0m\n\
    \e[31m   |\e[0m                                         pattern expected\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1660010582
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        // write your code here\n        val arr = arr.reverse\n\
    \        if(arr.isEmpty) {\n            return 0\n        }\n        var count\
    \ = 0\n        val arr = arr.map(x => (x % 2) == 0)\n        var i = 0\n     \
    \   while(i < arr.length) {\n            if(arr(i) == arr(i)) {\n            \
    \    count = count+1\n                i = i + 1\n            } else {\n      \
    \          i = i + 1\n            }\n        }\n        return count\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpebkdhlth.scala:21:12 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.map(\e[36mx\e\
    [0m => (x % \e[31m2\e[0m) == \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0marr is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmpebkdhlth.scala:16:18 ---------------------------\e[0m\e[0m\n\e[31m16\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.reverse\n\e[31m\e[31m   |\e\
    [0m                  ^\e[0m\n\e[31m   |\e[0m                  Recursive \e[33mvalue\e\
    [0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010582
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        // Convert to a mutable list, then sort it and reverse it\n\
    \        val arr2 = arr.toList.sortBy(x => x).reverse\n\n        // Keep a record\
    \ of the last and current value\n        val last = 0\n        val current = 0\n\
    \        var currentIndex = 0\n        var palindromicIndex = 0\n\n        //\
    \ The smallest change is 0 for the whole list\n        val smallestChange = 0l\n\
    \n        // Go through each element in the list\n        for (i <- 0 until arr2.length)\
    \ {\n            // If this element is the same as the previous element\n    \
    \        if (arr2(i) == last) {\n                current += 1\n              \
    \  // Update the smallestChange if this is the smallest change\n             \
    \   if (current == smallestChange) {\n                    palindromicIndex = i\n\
    \                }\n            } else {\n                // Update last, current\
    \ and smallestChange values\n                last = arr2(i)\n                current\
    \ = 1\n                smallestChange = current\n            }\n            //\
    \ Update the current index\n            currentIndex += 1\n        }\n\n     \
    \   // If we have no change in the smallest change\n        if (currentIndex ==\
    \ 0) {\n            smallestChange = 0\n        } else {\n            smallestChange\
    \ = smallestChange - 1\n        }\n\n        // Return the smallest change\n \
    \       palindromicIndex\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp5bjr8_32.scala:31:24 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m                current += \e[31m1\e[0m\n\e[31m\e[31m\
    \   |\e[0m                ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m              value\
    \ += is not a member of Int - did you mean current.!=?\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmp5bjr8_32.scala:38:27 --------------------\e[0m\e\
    [0m\n\e[31m38 |\e[0m                last = arr2(i)\n\e[31m\e[31m   |\e[0m    \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                       Found:\
    \    Long\n\e[31m   |\e[0m                       Required: Int\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E052] Type Error: /tmp/tmp5bjr8_32.scala:39:24 -----------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m                current = \e[31m1\e[0m\n\e[31m\e[31m\
    \   |\e[0m                ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                Reassignment\
    \ to val current\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmp5bjr8_32.scala:40:31\
    \ -----------------------------\e[0m\e[0m\n\e[31m40 |\e[0m                smallestChange\
    \ = current\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                Reassignment to val smallestChange\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E052] Type Error: /tmp/tmp5bjr8_32.scala:48:27 -----------------------------\e\
    [0m\e[0m\n\e[31m48 |\e[0m            smallestChange = \e[31m0\e[0m\n\e[31m\e[31m\
    \   |\e[0m            ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            Reassignment\
    \ to val smallestChange\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmp5bjr8_32.scala:50:27\
    \ -----------------------------\e[0m\e[0m\n\e[31m50 |\e[0m            smallestChange\
    \ = smallestChange - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m            Reassignment to val smallestChange\n\e[31m   |\e\
    [0m\n"
  stdout: ''
  timestamp: 1660010586
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        var len = arr.length\n        var mid = 0\n        var cur\
    \ = 0\n        var flag = 0\n\n        while (cur < len) {\n            while\
    \ (cur < len && flag == 1) {\n                mid = cur\n                cur +=\
    \ 1\n                if (arr[mid] == arr[cur]) flag = 0\n                else\
    \ flag = 1\n            }\n\n            if (cur < len) cur += 1\n           \
    \ else return mid\n        }\n        return 0\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmps_dgoqjh.scala:24:24 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m                \e[33mif\e[0m (arr[\e[35mmid\e[0m] ==\
    \ arr[\e[35mcur\e[0m]) flag = \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m            \
    \            ^^^\e[0m\n\e[31m   |\e[0m                        Not found: type\
    \ mid\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010584
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        var stack = new Stack[Long]()\n        var low = 0\n   \
    \     var high = arr.length - 1\n        while (low < high) {\n            if\
    \ (arr[low] == arr[high]) {\n                low += 1\n                high -=\
    \ 1\n            } else if (arr[low] > arr[high]) {\n                stack.push(arr[low])\n\
    \                low += 1\n            } else {\n                stack.push(arr[high])\n\
    \                high -= 1\n            }\n        }\n        val len = arr.length\n\
    \        var counter = 0\n        while (stack.size > 0)\n            counter\
    \ += 1\n        return counter\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmppvcas1fg.scala:19:20 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m            \e[33mif\e[0m (arr[\e[35mlow\e[0m] == arr[\e\
    [35mhigh\e[0m]) {\n\e[31m\e[31m   |\e[0m                    ^^^\e[0m\n\e[31m \
    \  |\e[0m                    Not found: type low\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmppvcas1fg.scala:22:27 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m            } \e[33melse\e[0m \e[33mif\e[0m (arr[low]\
    \ > arr[high]) {\n\e[31m\e[31m   |\e[0m                           ^^^\e[0m\n\e\
    [31m   |\e[0m                           Not found: type low\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmppvcas1fg.scala:23:31 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m                stack.push(arr[\e[35mlow\e[0m])\n\e[31m\e\
    [31m   |\e[0m                               ^^^\e[0m\n\e[31m   |\e[0m        \
    \                       Not found: type low\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmppvcas1fg.scala:26:31 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m                stack.push(arr[\e[35mhigh\e[0m])\n\e\
    [31m\e[31m   |\e[0m                               ^^^^\e[0m\n\e[31m   |\e[0m \
    \                              Not found: type high\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n4 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010584
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arrToAns  = arr.toList.toArray.sortBy(_._2).reverse.zipWithIndex\n\
    \        val ansIndex = arrToAns.toList.head._2\n        val index    = arrToAns.toList.last._2\n\
    \        val minCount = (ansIndex - index) / 2\n\n        var count = 0\n    \
    \    for(i <- 0 until arr.length){\n            val newIndex = arr.length - count\
    \ - 1 - (i + 1)\n            val newCount = arr.length - count - 1 - i\n     \
    \       if(newIndex < 0){\n                newIndex = newIndex + newCount\n  \
    \          }\n            if(newIndex > arr.length){\n                newIndex\
    \ = newIndex - newCount\n            }\n            if(newIndex < 0){\n      \
    \          newIndex = newIndex + newCount\n            }\n            if(newIndex\
    \ > arr.length){\n                newIndex = newIndex - newCount\n           \
    \ }\n\n            if((arr(i).toLong - arr[newIndex].toLong) < (arr(i).toLong\
    \ - arr[newIndex].toLong)){\n                count = count + 1\n            }\n\
    \        }\n        arr.length.toLong - count * 2\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpl8pb4nsi.scala:15:52 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marrToAns\e[0m  = arr.toList.toArray.sortBy(_._2).reverse.zipWithIndex\n\
    \e[31m\e[31m   |\e[0m                                                  ^^^^\e\
    [0m\n\e[31m   |\e[0m                                        value _2 is not a\
    \ member of Long\n\e[31m\e[31m-- Error: /tmp/tmpl8pb4nsi.scala:15:55 -----------------------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marrToAns\e[0m  = arr.toList.toArray.sortBy(_._2).reverse.zipWithIndex\n\
    \e[31m\e[31m   |\e[0m                                                       ^\e\
    [0m\n\e[31m   |\e[0mambiguous given instances: both \e[33mobject\e[0m \e[35mChar\e\
    [0m in \e[33mobject\e[0m \e[35mOrdering\e[0m and \e[33mobject\e[0m \e[35mShort\e\
    [0m in \e[33mobject\e[0m \e[35mOrdering\e[0m match type Ordering[B] of parameter\
    \ ord of \e[33mmethod\e[0m \e[35msortBy\e[0m in \e[33mclass\e[0m \e[35mArrayOps\e\
    [0m\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmpl8pb4nsi.scala:25:25 -----------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m                newIndex = newIndex + newCount\n\e[31m\e\
    [31m   |\e[0m                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                Reassignment to val newIndex\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E052] Type Error: /tmp/tmpl8pb4nsi.scala:28:25 -----------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m                newIndex = newIndex - newCount\n\e[31m\e\
    [31m   |\e[0m                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                Reassignment to val newIndex\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E052] Type Error: /tmp/tmpl8pb4nsi.scala:31:25 -----------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m                newIndex = newIndex + newCount\n\e[31m\e\
    [31m   |\e[0m                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                Reassignment to val newIndex\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when c"
  stdout: ''
  timestamp: 1660010586
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val map = mutable.LinkedHashMap[Long, Long]()\n        val\
    \ arr = arr.toList\n        for( i <- arr.indices.reverse; e <- arr(i)) map +=\
    \ (e -> arr(i))\n        // Now map holds the palindromic array\n        // Now\
    \ traverse this map and find the minimum number of changes:\n        map.toSeq.sortBy(_._1).reverse.headOption.map\
    \ { case (key, value) =>\n            if (value == arr.last) 0 else {\n      \
    \          val index = value - 1\n                val min = index\n          \
    \      var prevMin = index - 1\n                for (e <- arr.indices) {\n   \
    \                 if (e - prevMin == index)\n                        min++\n \
    \                   else if (e - prevMin > index)\n                        break\n\
    \                    prevMin = e\n                }\n                min\n   \
    \         }\n        }.getOrElse(0)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp14ys_kw0.scala:27:29 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m                        min++\n\e[31m\e[31m   |\e[0m\
    \                             ^\e[0m\n\e[31m   |\e[0m                        \
    \     expression expected but \e[31munindent\e[0m found\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp14ys_kw0.scala:15:18 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mmap\e[0m = mutable.LinkedHashMap[\e\
    [35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                  ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                  Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E045] Cyclic Error: /tmp/tmp14ys_kw0.scala:16:18 ---------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010584
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length\n        val d = n / 2\n        val m\
    \ = n / 2\n        var x = arr[m - 1]\n        var y = arr[m]\n\n        var changes\
    \ = 0\n        while(m > 0 && d > 0 && x > y ){\n            x = y\n         \
    \   y = arr[m-1]\n            arr(m-1) = arr[m]\n            arr(m) = x\n    \
    \        m -= 1\n            d -= 1\n            changes +=1\n        }\n\n  \
    \      if(changes > 0){\n            return changes - 1\n        }\n        return\
    \ 0\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp4jhjyn4x.scala:18:22 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mvar\e[0m \e[36mx\e[0m = arr[\e[35mm\e[0m\
    \ \e[35m-\e[0m \e[31m1\e[0m]\n\e[31m\e[31m   |\e[0m                      ^\e[0m\n\
    \e[31m   |\e[0m                      Not found: type -\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp4jhjyn4x.scala:19:20 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mvar\e[0m \e[36my\e[0m = arr[\e[35mm\e[0m]\n\
    \e[31m\e[31m   |\e[0m                    ^\e[0m\n\e[31m   |\e[0m             \
    \       Not found: type m\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp4jhjyn4x.scala:24:21 ------------------------\e[0m\e[0m\n\e[31m24 |\e\
    [0m            y = arr[\e[35mm-\e[31m1\e[0m]\n\e[31m\e[31m   |\e[0m          \
    \           ^\e[0m\n\e[31m   |\e[0m                     Not found: type -\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp4jhjyn4x.scala:25:12\
    \ ------------------------\e[0m\e[0m\n\e[31m25 |\e[0m            arr(m-\e[31m1\e\
    [0m) = arr[\e[35mm\e[0m]\n\e[31m\e[31m   |\e[0m            ^^^\e[0m\n\e[31m  \
    \ |\e[0m  value update is not a member of List[Long] - did you mean arr.updated?\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp4jhjyn4x.scala:25:27 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m            arr(m-\e[31m1\e[0m) = arr[\e[35mm\e[0m]\n\
    \e[31m\e[31m   |\e[0m                           ^\e[0m\n\e[31m   |\e[0m      \
    \                     Not found: type m\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp4jhjyn4x.scala:26:12 ------------------------\e[0m\e\
    [0m\n\e[31m26 |\e[0m            arr(m) = x\n\e[31m\e[31m   |\e[0m            ^^^\e\
    [0m\n\e[31m   |\e[0m  value update is not a member of List[Long] - did you mean\
    \ arr.updated?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp4jhjyn4x.scala:27:14\
    \ ------------------------\e[0m\e["
  stdout: ''
  timestamp: 1660010586
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        // Create hash map to store all elements with their index\n\
    \        // And then iterate to create list of elements that needs to be changed\n\
    \        var hashMap : mutable.HashMap[Long, Int] = mutable.HashMap[Long, Int]()\n\
    \        for (i <- 0 until arr.length) {\n            if (i % 2 == 0) {\n    \
    \            hashMap.update(arr(i), hashMap.getOrElse(arr(i), 0) + 1)\n      \
    \      } else {\n                hashMap.update(arr(i), hashMap.getOrElse(arr(i),\
    \ 0) - 1)\n            }\n        }\n        \n        // Compare all elements\
    \ with hashMap\n        // If hashMap has more than half elements that need to\
    \ be changed, return half of them\n        // If hashMap has less than half elements\
    \ that need to be changed, return half of them\n        // If hashMap has exactly\
    \ the same elements that need to be changed, return 0\n        var result : Long\
    \ = 0\n        for (i <- hashMap) {\n            if (hashMap(i) > arr.length /\
    \ 2) {\n                result = hashMap(i)\n            } else if (hashMap(i)\
    \ < arr.length / 2) {\n                result = hashMap(i)\n            }\n  \
    \      }\n        return result\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpub6vp1b6.scala:17:22 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mvar\e[0m \e[36mhashMap\e[0m : mutable.HashMap[\e\
    [35mLong\e[0m, \e[35mInt\e[0m] = mutable.HashMap[\e[35mLong\e[0m, \e[35mInt\e\
    [0m]()\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpub6vp1b6.scala:17:51 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mvar\e[0m \e[36mhashMap\e[0m : mutable.HashMap[\e\
    [35mLong\e[0m, \e[35mInt\e[0m] = mutable.HashMap[\e[35mLong\e[0m, \e[35mInt\e\
    [0m]()\n\e[31m\e[31m   |\e[0m                                                \
    \   ^^^^^^^\e[0m\n\e[31m   |\e[0m                                            \
    \       Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010585
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        var min = Integer.MAX_VALUE\n        var min = arr(0)\n\
    \        var minIndex = -1\n        for(i <- arr.indices) {\n            if(arr(i)\
    \ == arr(arr.length - 1 - i)) {\n                val temp = arr(arr.length - i\
    \ - 1)\n                arr(arr.length - i - 1) = arr(i)\n                arr(i)\
    \ = temp\n                min = Math.min(arr(i), min)\n                if(min\
    \ != Integer.MAX_VALUE && minIndex == -1) {\n                    minIndex = i\n\
    \                }\n            }\n        }\n        min\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpxint9kwl.scala:16:12 ---------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mvar\e[0m \e[36mmin\e[0m = arr(\e[31m0\e\
    [0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmin is\
    \ already defined as \e[33mvariable\e[0m \e[35mmin\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpxint9kwl.scala:21:16\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m                arr(arr.length\
    \ - i - \e[31m1\e[0m) = arr(i)\n\e[31m\e[31m   |\e[0m                ^^^\e[0m\n\
    \e[31m   |\e[0m  value update is not a member of List[Long] - did you mean arr.updated?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpxint9kwl.scala:22:16 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m                arr(i) = temp\n\e[31m\e[31m   |\e[0m\
    \                ^^^\e[0m\n\e[31m   |\e[0m  value update is not a member of List[Long]\
    \ - did you mean arr.updated?\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxint9kwl.scala:23:34\
    \ --------------------\e[0m\e[0m\n\e[31m23 |\e[0m                min = Math.min(arr(i),\
    \ min)\n\e[31m\e[31m   |\e[0m                               ^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                               Found:    Long\n\e[31m   |\e[0m     \
    \                          Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660010587
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n      var len = arr.size\n      if(len == 1) return arr(0)\n   \
    \   if(len == 0) return 0l\n      var maxP = 0l\n      var numChanges = 0\n  \
    \    while(len > 0) {\n        len -= 1\n        if(arr(len) > arr(len - 1)) maxP\
    \ += 1\n        if(arr(len) < arr(len - 1)) numChanges += 1\n      }\n      if(numChanges\
    \ == 0) {\n        if(maxP < 2) maxP = 0\n        else maxP = 2\n      }\n   \
    \   else maxP = maxP / 2\n      if(maxP < 1) maxP = 0\n      else maxP = 1\n \
    \     return maxP\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: -1\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:115)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.smallestChange(tmpwoy6buo3.scala:22)\n\tat Problem$.main(tmpwoy6buo3.scala:35)\n\
    \tat Problem.main(tmpwoy6buo3.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010587
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.reverse\n        var minChange = 0L\n    \
    \    var left = 0\n        var right = 0\n        for (i <- arr.indices) {\n \
    \           val next = arr(i)\n            if (next < arr[left]) {\n         \
    \       left = i\n            }\n            if (next > arr[right]) {\n      \
    \          right = i\n            }\n        }\n        if (right - left + 1 >\
    \ minChange) {\n            minChange = right - left + 1\n        }\n        left\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp4h32eemd.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.reverse\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660010586
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val m = arr.length\n        val n = arr.head\n        val\
    \ set = Set[Long]().toSet\n        var min = math.min(m, n)\n        for(i <-\
    \ m until n-1) {\n            if(arr(i) == arr(i + 1)) {\n                if(arr(i)\
    \ != 0) {\n                    min += 1\n                    arr(i) = -1\n   \
    \             }\n            } else {\n                val b = set(arr(i))\n \
    \               if(arr(i) != 0 && b != -1) {\n                    min += 1\n \
    \                   arr(i) = b\n                }\n                val c = set(arr(i\
    \ + 1))\n                if(arr(i) != 0 && c != -1) {\n                    min\
    \ += 1\n                    arr(i + 1) = c\n                }\n            }\n\
    \        }\n        min\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpscg165kg.scala:19:25\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mfor\e[0m(i <- m\
    \ until n-\e[31m1\e[0m) {\n\e[31m\e[31m   |\e[0m                         ^^^\e\
    [0m\n\e[31m   |\e[0m                         Found:    Long\n\e[31m   |\e[0m \
    \                        Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpscg165kg.scala:23:20 ------------------------\e[0m\e\
    [0m\n\e[31m23 |\e[0m                    arr(i) = -\e[31m1\e[0m\n\e[31m\e[31m \
    \  |\e[0m                    ^^^\e[0m\n\e[31m   |\e[0m  value update is not a\
    \ member of List[Long] - did you mean arr.updated?\n\e[31m\e[31m-- Error: /tmp/tmpscg165kg.scala:27:34\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m27 |\e[0m       \
    \         \e[33mif\e[0m(arr(i) != \e[31m0\e[0m && b != -\e[31m1\e[0m) {\n\e[31m\e\
    [31m   |\e[0m                                  ^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \       Values of types Boolean and Int cannot be compared with == or !=\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpscg165kg.scala:29:20 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m                    arr(i) = b\n\e[31m\e[31m   |\e[0m\
    \                    ^^^\e[0m\n\e[31m   |\e[0m  value update is not a member of\
    \ List[Long] - did you mean arr.updated?\n\e[31m\e[31m-- Error: /tmp/tmpscg165kg.scala:32:34\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m32 |\e[0m       \
    \         \e[33mif\e[0m(arr(i) != \e[31m0\e[0m && c != -\e[31m1\e[0m) {\n\e[31m\e\
    [31m   |\e[0m                                  ^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \       Values of types Boolean and Int cannot be compared with == or !=\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpscg165kg.scala:34:20 ------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m                    arr(i + \e[31m1\e[0m) = c\n\e[31m\e\
    [31m   |\e[0m                    ^^^\e[0m\n\e[31m   |\e[0m  value update is not\
    \ a member of List[Long] - did you mean arr.updated?\n6 errors found\n"
  stdout: ''
  timestamp: 1660010587
