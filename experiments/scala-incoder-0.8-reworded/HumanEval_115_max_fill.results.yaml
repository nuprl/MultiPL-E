language: scala
name: HumanEval_115_max_fill
results:
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        var sum = 0\n        var i = grid.length\n        while\
    \ (i > 0) {\n            sum += grid.apply(i-1).map(x => if (x == 0) capacity\
    \ else 0l).toList.foldLeft(0l) { (sum, e) => sum + e }\n            i -= 1\n \
    \       }\n        sum\n    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp1erj9w5j.scala:29:16 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m            sum += grid.apply(i-\e[31m1\e[0m).map(\e\
    [36mx\e[0m => \e[33mif\e[0m (x == \e[31m0\e[0m) capacity \e[33melse\e[0m \e[31m0l\e\
    [0m).toList.foldLeft(\e[31m0l\e[0m) { (\e[36msum\e[0m, \e[36me\e[0m) => sum +\
    \ e }\n\e[31m\e[31m   |\e[0m            ^^^^^^\e[0m\n\e[31m   |\e[0m         \
    \   value += is not a member of Int - did you mean Int.!=?\n1 error found\n"
  stdout: ''
  timestamp: 1659979257
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        def maxFillUtil(grid : List[List[Long]], bucket: List[Long],\
    \ maxLength : Int, minLength : Int) : Int = {\n            val l = grid.length\n\
    \            if(l <= minLength || l >= maxLength)\n                return 1\n\
    \            val row = grid(l)\n            if(row(0) == bucket(0))\n        \
    \        maxFillUtil(grid, bucket, maxLength, l+1)\n            else\n       \
    \         if(bucket(0) == bucket(l-1))\n                    maxFillUtil(grid,\
    \ bucket, l+1, minLength)\n                else\n                    if(bucket(0)\
    \ == bucket(l-1)-1)\n                        maxFillUtil(grid, bucket, l+1, minLength)\n\
    \                    else\n                        if(bucket(l-1) == bucket(l-1))\n\
    \                            maxFillUtil(grid, bucket, l+1, minLength)\n     \
    \                   else\n                            if(bucket(l-1) == bucket(l-1)-1)\n\
    \                                maxFillUtil(grid, bucket, l+1, minLength)\n \
    \                           else\n                                maxFillUtil(grid,\
    \ bucket, minLength, l+1)\n        }\n        val res = new mutable.ArrayBuffer(0l)\n\
    \        var maxLength = 0l\n        for(l <- 1 to grid.length)\n            if(maxLength\
    \ < l)\n                maxLength = l\n        for(l <- 1 to maxLength)\n    \
    \        res += maxFillUtil(grid, new mutable.ArrayBuffer(0l), l, l)\n       \
    \ res.sum\n    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp8j4gt6at.scala:48:22 ------------------------\e\
    [0m\e[0m\n\e[31m48 |\e[0m        \e[33mval\e[0m \e[36mres\e[0m = \e[33mnew\e[0m\
    \ mutable.ArrayBuffer(\e[31m0l\e[0m)\n\e[31m\e[31m   |\e[0m                  \
    \    ^^^^^^^\e[0m\n\e[31m   |\e[0m                      Not found: mutable\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp8j4gt6at.scala:53:22\
    \ --------------------\e[0m\e[0m\n\e[31m53 |\e[0m        \e[33mfor\e[0m(l <- \e\
    [31m1\e[0m to maxLength)\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                      Found:    (maxLength : Long)\n\e[31m\
    \   |\e[0m                      Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659979258
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        var result : Long = 0\n        var i : Long = 0\n      \
    \  var j : Long = 0\n        while(i < grid.length){\n            var nextWellHasBeenFilled\
    \ : Boolean = false\n            while(j < grid(i).length){\n                if(grid[i][j]\
    \ != 0 && capacity >= grid[i][j]){\n                    grid[i][j] = 0\n     \
    \               nextWellHasBeenFilled = true\n                    capacity -=\
    \ grid[i][j]\n                }\n                j++\n            }\n        \
    \    if(!nextWellHasBeenFilled){\n                result++\n            }\n  \
    \          i++\n        }\n        return result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 1l.toLong,\
    \ 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong, 0l.toLong), List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (1l)) == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp6j0ys3to.scala:33:31 -----------------------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m                    grid[\e[35mi\e[0m][\e[35mj\e[0m]\
    \ = \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m                               ^\e[0m\n\
    \e[31m   |\e[0m                               end of statement expected but '='\
    \ found\n\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp6j0ys3to.scala:37:19 ---------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m                j++\n\e[31m\e[31m   |\e[0m          \
    \         ^\e[0m\n\e[31m   |\e[0m                   expression expected but \e\
    [31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp6j0ys3to.scala:40:24\
    \ ---------------------------\e[0m\e[0m\n\e[31m40 |\e[0m                result++\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E018] Syntax Error: /tmp/tmp6j0ys3to.scala:42:15 ---------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m            i++\n\e[31m\e[31m   |\e[0m              \
    \ ^\e[0m\n\e[31m   |\e[0m               expression expected but \e[31m'}'\e[0m\
    \ found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp6j0ys3to.scala:31:27\
    \ --------------------\e[0m\e[0m\n\e[31m31 |\e[0m            \e[33mwhile\e[0m(j\
    \ < grid(i).length){\n\e[31m\e[31m   |\e[0m                           ^\e[0m\n\
    \e[31m   |\e[0m                           Found:    (i : Long)\n\e[31m   |\e[0m\
    \                           Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmp6j0ys3to.scala:32:27 ------------------------\e[0m\e\
    [0m\n\e[31m32 |\e[0m                \e[33mif\e[0m(grid[\e[35mi\e[0m][\e[35mj\e\
    [0m] != \e[31m0\e[0m && capacity >= grid[\e[35mi\e[0m][\e[35mj\e[0m]){\n\e[31m\e\
    [31m   |\e[0m                           ^\e[0m\n\e[31m   |\e[0m           "
  stdout: ''
  timestamp: 1659979259
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val result = mutable.ListBuffer(0)\n        for(i <- 0 until\
    \ grid.length){\n            for(j <- 0 until grid(i).length){\n             \
    \   result.add(grid(i)(j).map(i => i => if (i == 1) capacity/grid[0].length else\
    \ 0).sum)\n            }\n        }\n        result.foldLeft(0)(_ + _)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpn_y4nv23.scala:26:21 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer(\e\
    [31m0\e[0m)\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979253
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val bucket = mutable.ArrayBuffer(capacity)\n        val\
    \ emptyCount = mutable.ArrayBuffer(capacity)\n        for (row <- grid.toStream)\
    \ {\n            for (column <- row.toStream) {\n                bucket.update(column,\
    \ 1)\n                if (column < capacity) {\n                    emptyCount.update(column,\
    \ 0l)\n                }\n            }\n        }\n\n        val answer = mutable.ArrayBuffer.empty[Long]\n\
    \        for (i <- 1 to capacity) {\n            val count = (emptyCount(i) -\
    \ bucket(i)).toLong\n            if (count < answer.size) {\n                answer\
    \ = answer :+ count\n            }\n        }\n        answer.last\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpgu_8d8ca.scala:26:21 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mbucket\e[0m = mutable.ArrayBuffer(capacity)\n\
    \e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \               Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpgu_8d8ca.scala:27:25 ------------------------\e[0m\e[0m\n\e[31m27 |\e\
    [0m        \e[33mval\e[0m \e[36memptyCount\e[0m = mutable.ArrayBuffer(capacity)\n\
    \e[31m\e[31m   |\e[0m                         ^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                       Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpgu_8d8ca.scala:37:21 ------------------------\e[0m\e\
    [0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e[36manswer\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpgu_8d8ca.scala:38:23 --------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m        \e[33mfor\e[0m (i <- \e[31m1\e[0m to capacity)\
    \ {\n\e[31m\e[31m   |\e[0m                       ^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                       Found:    (capacity : Long)\n\e[31m   |\e[0m         \
    \              Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E052] Type Error:\
    \ /tmp/tmpgu_8d8ca.scala:41:23 -----------------------------\e[0m\e[0m\n\e[31m41\
    \ |\e[0m                answer = answer :+ count\n\e[31m\e[31m   |\e[0m      \
    \          ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                Reassignment\
    \ to val answer\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n5 errors found\n"
  stdout: ''
  timestamp: 1659979257
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val minCell = grid.head\n        var minCellId = 1\n   \
    \     var fills = 0\n        var gridId = 0\n        var currentCell = minCell\n\
    \        while (minCell != List.empty) {\n            val curCellId = currentCell.head\n\
    \            val currCapacity = currentCell.tail.last\n            currentCell\
    \ = currentCell.tail\n            if (currCapacity < capacity) {\n           \
    \     val prevCell = grid.take(gridId).last\n                var prevCellId =\
    \ 1\n                if (prevCell.head == 0) {\n                    val newCell\
    \ = grid.map(_.filter(!_.isInstanceOf[List[Long]])).toList.drop(1)\n         \
    \           if (newCell.head == 0) newCell = List((1l))\n                    val\
    \ newCapacity = newCell.last.tail.last\n                    if (newCapacity <\
    \ currCapacity) {\n                        newCell.init(_ + currCapacity - newCapacity)\n\
    \                        val newCellId = newCell.head.head\n                 \
    \       val newCell2Id = newCellId + 1\n                        var newCellId\
    \ = 1\n                        while (newCellId <= newCell2Id) {\n           \
    \                 var newCellId2 = newCellId + 1\n                           \
    \ var newCellId2 = 1\n                            while (newCellId2 <= newCell2Id)\
    \ {\n                                if (newCell2Id <= 10) {\n               \
    \                     if (newCellId < newCell2Id) {\n                        \
    \                val newCellId = newCellId + 1\n                             \
    \           val newCellId2 = newCellId2 + 1\n                                \
    \    } else {\n                                        break\n               \
    \                     }\n                                } else {\n          \
    \                          val newCellId = newCellId + 1\n                   \
    \                 val newCellId2 = newCellId2 + 1\n                          \
    \      }\n                            }\n                            if (newCellId\
    \ <= newCell2Id) {\n                                val newCell = newCell.toList\n\
    \                                val newCellId = newCell.head.head\n         \
    \                       val newCell2Id = newCellId + 1\n                     \
    \           var newCellId = 1\n                                while (newCellId\
    \ <= newCell2Id) {\n                                    var newCellId2 = newCellId\
    \ + 1\n                                    var newCellId2 = 1\n              \
    \                      while (newCellId2 <= newCell2Id) {\n                  \
    \                      if (newCell2Id <= 10) {\n                             \
    \               if (newCellId < newCell2Id) {\n                              \
    \                  val newCellId = newCellId + 1\n                           \
    \                     val newCellId2 = newCellId2 + 1\n                      \
    \                      } else {\n                                            \
    \    break\n                                            }\n                  \
    \                      } else {\n                                            val\
    \ newCellId = newCellId + 1\n                                            val newCellId2\
    \ = newCellId2 + 1\n                                        }\n              \
    \                      }\n                                    if (newCellId <=\
    \ new\n    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpz4zxakmb.scala:85:4 ----------------------------\e\
    [0m\e[0m\n\e[31m85 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tmpz4zxakmb.scala:95:0 ----------------------------\e[0m\e[0m\n\e[31m95\
    \ |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\
    \e[31m\e[31m-- Error: /tmp/tmpz4zxakmb.scala:40:24 -----------------------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m                    \e[33mif\e[0m (newCell.head == \e\
    [31m0\e[0m) newCell = List((\e[31m1l\e[0m))\n\e[31m\e[31m   |\e[0m           \
    \             ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m     Values of types List[Long]\
    \ and Int cannot be compared with == or !=\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpz4zxakmb.scala:40:59 --------------------\e[0m\e[0m\n\e[31m40\
    \ |\e[0m                    \e[33mif\e[0m (newCell.head == \e[31m0\e[0m) newCell\
    \ = List((\e[31m1l\e[0m))\n\e[31m\e[31m   |\e[0m                             \
    \                              ^^\e[0m\n\e[31m   |\e[0m                      \
    \                             Found:    (\e[31m1L\e[0m : Long)\n\e[31m   |\e[0m\
    \                                                   Required: List[Long]\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpz4zxakmb.scala:46:28 ---------------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m                        \e[33mvar\e[0m \e[36mnewCellId\e\
    [0m = \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m                        ^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mnewCellId is already defined as \e[33mvalue\e[0m \e[35mnewCellId\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E081] Type\
    \ Error: /tmp/tmpz4zxakmb.scala:43:37 -----------------------------\e[0m\e[0m\n\
    \e[31m43 |\e[0m                        newCell.init(_ + currCapacity - newCapacity)\n\
    \e[31m\e[31m   |\e[0m                                     ^\e[0m\n\e[31m   |\e\
    [0m   Missing parameter type\n\e[31m   |\e[0m\n\e[31m   |\e[0m   I could "
  stdout: ''
  timestamp: 1659979259
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        // write your code here\n        val buckets = grid.map(\
    \ row => Array.ofDim[Long](row.length) )\n        var maxCount = 0\n        buckets.foreach(\
    \ row => {\n            row.foreach{ bucket => maxCount = bucket.max{bucket =>\
    \ bucket * capacity} }\n        })\n        maxCount\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E081] Type Error: /tmp/tmpvkz_xjfm.scala:30:57 -----------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m            row.foreach{ \e[36mbucket\e[0m => maxCount\
    \ = bucket.max{\e[36mbucket\e[0m => bucket * capacity} }\n\e[31m\e[31m   |\e[0m\
    \                                                         ^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Missing parameter type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m                     I could not infer the type of the parameter bucket.\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659979254
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        var count = 0\n        var currentCapacity = 0\n\n     \
    \   for(row <- grid){\n            if(row(0)==0 && row(1)==0){\n             \
    \   currentCapacity = capacity\n            } else {\n                currentCapacity\
    \ = capacity - row(0)\n            }\n            for(i <- 1 to row.length-1){\n\
    \                for(j <- 1 to row.length-1){\n                    if(j == i){\n\
    \                        if(row(i) == 1){\n                            if(currentCapacity\
    \ > capacity){\n                                currentCapacity = capacity\n \
    \                           }\n                        }\n                   \
    \ } else {\n                        if(row(i) == 0 && row(i-1) == 0 && row(i+1)\
    \ == 0 && row(j) == 1){\n                            if(currentCapacity > capacity){\n\
    \                                currentCapacity = capacity\n                \
    \            }\n                        }\n                    }\n           \
    \     }\n                count += 1\n                currentCapacity += 1\n  \
    \          }\n        }\n\n        count = 0\n        for(row <- grid){\n    \
    \        for(i <- 1 to row.length-1){\n                for(j <- 1 to row.length-1){\n\
    \                    if(j == i){\n                        if(row(i) == 1){\n \
    \                           if(currentCapacity > capacity){\n                \
    \                currentCapacity = capacity\n                            }\n \
    \                       }\n                    } else {\n                    \
    \    if(row(i) == 0 && row(i-1) == 0 && row(i+1) == 0 && row(j) == 1){\n     \
    \                       if(currentCapacity > capacity){\n                    \
    \            currentCapacity = capacity\n                            }\n     \
    \                   }\n                    }\n                }\n            \
    \    count += 1\n                currentCapacity += 1\n            }\n       \
    \ }\n\n        return count\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 1l.toLong,\
    \ 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong, 0l.toLong), List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (1l)) == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4yromp74.scala:31:34\
    \ --------------------\e[0m\e[0m\n\e[31m31 |\e[0m                currentCapacity\
    \ = capacity\n\e[31m\e[31m   |\e[0m                                  ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Found:    (capacity : Long)\n\
    \e[31m   |\e[0m                                  Required: Int\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4yromp74.scala:33:34 --------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m                currentCapacity = capacity - row(\e[31m0\e\
    [0m)\n\e[31m\e[31m   |\e[0m                                  ^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Found:    Long\n\e[31m \
    \  |\e[0m                                  Required: Int\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4yromp74.scala:40:50 --------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m                                currentCapacity = capacity\n\
    \e[31m\e[31m   |\e[0m                                                  ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                             Found:    (capacity\
    \ : Long)\n\e[31m   |\e[0m                                             Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4yromp74.scala:46:50\
    \ --------------------\e[0m\e[0m\n\e[31m46 |\e[0m                            \
    \    currentCapacity = capacity\n\e[31m\e[31m   |\e[0m                       \
    \                           ^^^^^^^^\e[0m\n\e[31m   |\e[0m                   \
    \                          Found:    (capacity : Long)\n\e[31m   |\e[0m      \
    \                                       Required: Int\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmp4yromp74.scala:63:50 --------------------\e\
    [0m\e[0m\n\e[31m63 |\e[0m                                curren"
  stdout: ''
  timestamp: 1659979260
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val n = grid.length\n        val m = grid(0).length\n  \
    \      val c = new Array[Long](m)\n        \n        val w = mutable.ArrayBuffer.fill(m,\
    \ 0l)(0l)\n        val c = new Array[Long](m)\n        val d = new Array[Long](m)\n\
    \n        val p = new scala.collection.mutable.HashMap[Long, Int]()\n        for\
    \ (i <- 0 until m) {\n            p(grid(i)(0)) += 1\n        }\n\n        val\
    \ q = mutable.HashMap.empty[Long, Long]\n        for (i <- 0 until m) {\n    \
    \        for (j <- 0 until n) {\n                c(j) += p(grid(i)(j))\n     \
    \       }\n\n            val r = 0\n            val max = scala.math.max(scala.math.max(c(0),\
    \ c(m-1)), c(m-1)) + c(0) - capacity\n            while (max > 0) {\n        \
    \        if (max < d)(r) = max\n                max -= 1\n            }\n\n  \
    \          q(grid(i)(0)) = r\n        }\n\n        q.size\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp6j27w52u.scala:48:32 -----------------------------------------\e\
    [0m\e[0m\n\e[31m48 |\e[0m                \e[33mif\e[0m (max < d)(r) = max\n\e\
    [31m\e[31m   |\e[0m                                ^\e[0m\n\e[31m   |\e[0m   \
    \                             end of statement expected but '=' found\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp6j27w52u.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mc\e[0m = \e[33mnew\e[0m\
    \ \e[35mArray\e[0m[\e[35mLong\e[0m](m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mc is already defined as \e[33mvalue\e[0m \e[35mc\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp6j27w52u.scala:30:16 ------------------------\e[0m\e[0m\n\e[31m30 |\e\
    [0m        \e[33mval\e[0m \e[36mw\e[0m = mutable.ArrayBuffer.fill(m, \e[31m0l\e\
    [0m)(\e[31m0l\e[0m)\n\e[31m\e[31m   |\e[0m                ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp6j27w52u.scala:39:16 ------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m \e[36mq\e[0m = mutable.HashMap.empty[\e\
    [35mLong\e[0m, \e[35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E134] Type Error: /tmp/tmp6j27w52u.scala:48:24 -----------------------------\e\
    [0m\e[0m\n\e[31m48 |\e[0m                \e[33mif\e[0m (max < d)(r) = max\n\e\
    [31m\e[31m   |\e[0m                    ^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35m<\e[0m in \e[33mclass\e[0m\
    \ \e[35mLong\e[0m with types\n\e[31m   |\e[0m (x: Double): Boolean\n\e[31m   |\e\
    [0m (x: Float): Boolean\n\e[31m   |\e[0m (x: Long): Boolean\n\e[31m   |\e[0m (x:\
    \ Int): Boolean\n\e[31m   |\e[0m (x: Char): Boolean\n\e[31m   |\e[0m (x: Short):\
    \ Boolean\n\e[31m   |\e[0m (x: Byte): B"
  stdout: ''
  timestamp: 1659979257
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val result = 0\n        if (grid.length == 1) {\n      \
    \      return 1\n        }\n        val maxHeight = grid[0].length\n        var\
    \ maxRow = 0\n        var minHeight = grid.length\n        val buckets = grid.map(_.map(_.toLong))\n\
    \        val maxVolume = buckets.map(_.sum).max\n        val volumes = buckets.map(_.foldLeft(0l)\
    \ { (acc, val) => acc + val })\n        if (maxVolume > capacity) {\n        \
    \    return maxHeight + 1\n        }\n        var minRow = grid.length - 1\n \
    \       while (buckets.exists(_.length == 0)) {\n            minRow = minRow +\
    \ 1\n            buckets = grid.map(_.map(_.toLong))\n            maxVolume =\
    \ buckets.map(_.sum).max\n            if (maxVolume > capacity) {\n          \
    \      maxHeight = minRow + 1\n                break\n            }\n        \
    \    minHeight = minRow + 1\n        }\n        var row = 1\n        while (row\
    \ <= minHeight) {\n            var col = 1\n            var sum = 0\n        \
    \    var maxCount = 0\n            while (col <= maxHeight) {\n              \
    \  sum += buckets(row)(col)\n                if (sum > capacity) {\n         \
    \           maxCount = 1\n                    break\n                }\n     \
    \           maxCount = 0\n                col += 1\n            }\n          \
    \  if (maxCount > 0) {\n                val oldRow = row\n                val\
    \ oldCol = col\n                row += 1\n                col += 1\n         \
    \       if (row == minHeight) {\n                    minRow = oldRow\n       \
    \             minHeight = oldCol + 1\n                }\n            }\n     \
    \       if (row == minHeight) {\n                break\n            }\n      \
    \  }\n        if (row == minHeight) {\n            return 1\n        }\n     \
    \   result\n    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmptwa8tafm.scala:35:57 ---------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e[36mvolumes\e[0m = buckets.map(_.foldLeft(\e\
    [31m0l\e[0m) { (\e[36macc\e[0m, \e[33mval\e[0m) => acc + \e[33mval\e[0m })\n\e\
    [31m\e[31m   |\e[0m                                                         ^^^\e\
    [0m\n\e[31m   |\e[0m                                       expression expected\
    \ but \e[31mval\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmptwa8tafm.scala:35:71 ---------------------------\e[0m\e[0m\n\e[31m35\
    \ |\e[0m        \e[33mval\e[0m \e[36mvolumes\e[0m = buckets.map(_.foldLeft(\e\
    [31m0l\e[0m) { (\e[36macc\e[0m, \e[33mval\e[0m) => acc + \e[33mval\e[0m })\n\e\
    [31m\e[31m   |\e[0m                                                          \
    \             ^^^\e[0m\n\e[31m   |\e[0m                                      \
    \ expression expected but \e[31mval\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ Error: /tmp/tmptwa8tafm.scala:30:28 -----------------------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mmaxHeight\e[0m = grid[\e\
    [31m0\e[0m].length\n\e[31m\e[31m   |\e[0m                        ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m        \e[33mmethod\e[0m \e[35mapply\e[0m in \e[33mtrait\e[0m\
    \ \e[35mLinearSeqOps\e[0m does not take type parameters\n\e[31m\e[31m-- [E052]\
    \ Type Error: /tmp/tmptwa8tafm.scala:42:20 -----------------------------\e[0m\e\
    [0m\n\e[31m42 |\e[0m            buckets = grid.map(_.map(_.toLong))\n\e[31m\e\
    [31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m            Reassignment to val buckets\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E052]\
    \ Type Error: /tmp/tmptwa8tafm.scala:43:22 -----------------------------\e[0m\e\
    [0m\n\e[31m43 |\e[0m            maxVolume = buckets.map(_.sum).max\n\e[31m\e[31m\
    \   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \            Reassignment to val maxVolume\n\e[31m "
  stdout: ''
  timestamp: 1659979259
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val rowSize = grid.head.length\n        val columnSize =\
    \ grid.last.length\n        val maxBucket = capacity/rowSize\n        var totalBucket\
    \ = 0\n        var totalWater = 1\n        var row = 0\n        var column = 0\n\
    \        while (row < rowSize && column < columnSize) {\n            val bucket\
    \ = grid((row)(column))\n            totalBucket += bucket\n            totalWater\
    \ -= bucket\n            row = (row + 1) % rowSize\n            column = (column\
    \ + 1) % columnSize\n        }\n        var result = 0\n        if (totalBucket\
    \ > 0) {\n            result = Math.pow(maxBucket,columnSize-totalBucket) * Math.pow(maxBucket,rowSize-totalBucket-totalWater)\n\
    \        }\n        result\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 1l.toLong,\
    \ 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong, 0l.toLong), List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (1l)) == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E050] Type Error: /tmp/tmp5lckjtrw.scala:34:31 -----------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m            \e[33mval\e[0m \e[36mbucket\e[0m = grid((row)(column))\n\
    \e[31m\e[31m   |\e[0m                               ^^^\e[0m\n\e[31m   |\e[0m\
    \                               \e[33mvariable\e[0m \e[35mrow\e[0m does not take\
    \ parameters\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp5lckjtrw.scala:35:24\
    \ ------------------------\e[0m\e[0m\n\e[31m35 |\e[0m            totalBucket +=\
    \ bucket\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \            value += is not a member of Int - did you mean Int.!=?\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp5lckjtrw.scala:36:23 ------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m            totalWater -= bucket\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value -= is not\
    \ a member of Int - did you mean Int.!=?\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp5lckjtrw.scala:42:21 --------------------\e[0m\e[0m\n\e[31m42\
    \ |\e[0m            result = Math.pow(maxBucket,columnSize-totalBucket) * Math.pow(maxBucket,rowSize-totalBucket-totalWater)\n\
    \e[31m\e[31m   |\e[0m                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                     Found:    Double\n\e[31m   |\e[0m   \
    \                  Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659979259
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        // Write your code here\n        var max = 0\n        var\
    \ counter = 1\n        var maxSoFar = 0\n        \n        for (row <- grid){\n\
    \            var curr = 0\n            var currSum = 0\n            for (i <-\
    \ 0 until row.length){\n                currSum = currSum + row(i)\n         \
    \       if(currSum > capacity){\n                    curr = 1\n              \
    \      currSum = 0\n                }\n            }\n            if(curr > max){\n\
    \                max = curr\n            }\n            if(curr > maxSoFar){\n\
    \                maxSoFar = curr\n            }\n            counter = counter\
    \ + 1\n        }\n        if(max == maxSoFar){\n            counter\n        }else{\n\
    \            counter - maxSoFar\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 1l.toLong,\
    \ 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong, 0l.toLong), List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (1l)) == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpwq7ar4de.scala:35:26\
    \ --------------------\e[0m\e[0m\n\e[31m35 |\e[0m                currSum = currSum\
    \ + row(i)\n\e[31m\e[31m   |\e[0m                          ^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                          Found:    Long\n\e[31m   |\e[0m\
    \                          Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979257
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        var count = 0\n        var i = grid.length\n        var\
    \ j = 0\n        var k = grid.headOption.map(_.length)\n        while(i < 2l)\
    \ {\n            while(j < 2l) {\n                while(k != 0l && j < k.get &&\
    \ j < 2l) {\n                    if(grid(i)(j) == 1l) {\n                    \
    \    k -= 1\n                    } else if(grid(i)(j) == 0l) {\n             \
    \           count += 1\n                        k += 1\n                    }\n\
    \                    j += 1\n                }\n                j = 0\n      \
    \      }\n            i = 0\n        }\n        count\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp3i9wx683.scala:32:22 -----------------------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m                \e[33mwhile\e[0m(k != \e[31m0l\e[0m &&\
    \ j < k.get && j < \e[31m2l\e[0m) {\n\e[31m\e[31m   |\e[0m                   \
    \   ^^^^^^^\e[0m\n\e[31m   |\e[0m   Values of types Option[Int] and Long cannot\
    \ be compared with == or !=\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp3i9wx683.scala:34:26\
    \ ------------------------\e[0m\e[0m\n\e[31m34 |\e[0m                        k\
    \ -= \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m                        ^^^^\e[0m\n\e\
    [31m   |\e[0m  value -= is not a member of Option[Int] - did you mean Option[Int].!=?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp3i9wx683.scala:37:26 ------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m                        k += \e[31m1\e[0m\n\e[31m\e[31m\
    \   |\e[0m                        ^^^^\e[0m\n\e[31m   |\e[0m  value += is not\
    \ a member of Option[Int] - did you mean Option[Int].!=?\n3 errors found\n"
  stdout: ''
  timestamp: 1659979259
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = grid.map(_.toSet)\n        val maxCount =\
    \ buckets.reduce((a, b) => if (a.max > b.max) a else b).max\n        (maxCount\
    \ + 1) * capacity - (maxCount + 1)\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 1l.toLong,\
    \ 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong, 0l.toLong), List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (1l)) == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpt3cy7pks.scala:31)\n\tat Problem.main(tmpt3cy7pks.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979260
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val m = grid.length\n        val n = grid(0).length\n  \
    \      val maxBucket = m / n\n        var maxCount = 0\n        val m1 = grid.length\
    \ - 1\n        val n1 = grid[0].length - 1 \n        var i = 0\n        while\
    \ (i <= m1) {\n            var j = 0\n            while (j <= n1) {\n        \
    \        val bucket = (grid(i)(j) * capacity).toLong\n                if (bucket\
    \ > maxBucket) {\n                    maxBucket = bucket\n                   \
    \ maxCount = j.toLong\n                }\n                j += 1\n           \
    \ }\n            i += 1\n        }\n        maxCount\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmppr9i4qzh.scala:31:21 -----------------------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mn1\e[0m = grid[\e[31m0\e\
    [0m].length - \e[31m1\e[0m \n\e[31m\e[31m   |\e[0m                 ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m        \e[33mmethod\e[0m \e[35mapply\e[0m in \e[33mtrait\e[0m\
    \ \e[35mLinearSeqOps\e[0m does not take type parameters\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmppr9i4qzh.scala:38:32 --------------------\e[0m\e\
    [0m\n\e[31m38 |\e[0m                    maxBucket = bucket\n\e[31m\e[31m   |\e\
    [0m                                ^^^^^^\e[0m\n\e[31m   |\e[0m              \
    \                  Found:    (bucket : Long)\n\e[31m   |\e[0m                \
    \                Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmppr9i4qzh.scala:39:33 --------------------\e[0m\e[0m\n\e[31m39\
    \ |\e[0m                    maxCount = j.toLong\n\e[31m\e[31m   |\e[0m       \
    \                        ^^^^^^^^\e[0m\n\e[31m   |\e[0m                      \
    \         Found:    Long\n\e[31m   |\e[0m                               Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659979259
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        var result : Long = 0\n        val buckets = mutable.HashMap[Long,\
    \ Long]()\n        grid.foreach(row => {\n            row.foreach(item => {\n\
    \                buckets += ((item % capacity).asInstanceOf[Long], (item / capacity).asInstanceOf[Long])\n\
    \            })\n        })\n        var i : Long = 0\n        while(i < buckets.size)\
    \ {\n            val capacityLeft = buckets(i)(0) - buckets(i)(1)\n          \
    \  if(capacityLeft <= 0) result += 1\n            buckets(i)(0) = buckets(i)(1)\
    \ - capacityLeft\n            i += 1\n        }\n        result\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp9kdxrs8g.scala:27:22 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mbuckets\e[0m = mutable.HashMap[\e\
    [35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                     \
    \ ^^^^^^^\e[0m\n\e[31m   |\e[0m                      Not found: mutable\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659979255
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        require (grid.length == grid[0].length)\n        require\
    \ (1 <= grid[0].length && grid[0].length <= 10^2)\n        require (1 <= grid[0][1]\
    \ && grid[0][1] <= 10^2)\n        require (grid.length == grid.reduce((x, y) =>\
    \ x.size <=> y.size))\n        require (capacity <= 10L)\n        var count =\
    \ 0\n        var i = 0\n        var j = 0\n        var l = 0\n        var maxL\
    \ = 0\n        var tmp = 0\n        while (i < grid.length) {\n            val\
    \ l = grid.apply(i).max\n            if (l > maxL) {\n                count =\
    \ 0\n                maxL = l\n            }\n            while (j < grid.apply(i).length)\
    \ {\n                if (grid(i)(j) == 1) {\n                    tmp = grid.apply(i).max\
    \ - l\n                    if (tmp <= capacity)\n                        count\
    \ += (tmp <= 0)\n                }\n                j += 1\n            }\n  \
    \          i += 1\n        }\n        count\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 1l.toLong,\
    \ 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong, 0l.toLong), List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (1l)) == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpsatxnsou.scala:26:36 -----------------------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        require (grid.length == grid[\e[31m0\e[0m].length)\n\
    \e[31m\e[31m   |\e[0m                                ^^^^^^^\e[0m\n\e[31m   |\e\
    [0m        \e[33mmethod\e[0m \e[35mapply\e[0m in \e[33mtrait\e[0m \e[35mLinearSeqOps\e\
    [0m does not take type parameters\n\e[31m\e[31m-- Error: /tmp/tmpsatxnsou.scala:27:26\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m27 |\e[0m       \
    \ require (\e[31m1\e[0m <= grid[\e[31m0\e[0m].length && grid[\e[31m0\e[0m].length\
    \ <= \e[31m10\e[0m^\e[31m2\e[0m)\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        \e[33mmethod\e[0m \e[35mapply\e[0m in \e[33mtrait\e\
    [0m \e[35mLinearSeqOps\e[0m does not take type parameters\n\e[31m\e[31m-- Error:\
    \ /tmp/tmpsatxnsou.scala:28:26 -----------------------------------------\e[0m\e\
    [0m\n\e[31m28 |\e[0m        require (\e[31m1\e[0m <= grid[\e[31m0\e[0m][\e[31m1\e\
    [0m] && grid[\e[31m0\e[0m][\e[31m1\e[0m] <= \e[31m10\e[0m^\e[31m2\e[0m)\n\e[31m\e\
    [31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m   |\e[0m        \e[33mmethod\e\
    [0m \e[35mapply\e[0m in \e[33mtrait\e[0m \e[35mLinearSeqOps\e[0m does not take\
    \ type parameters\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpsatxnsou.scala:29:61\
    \ ------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        require (grid.length\
    \ == grid.reduce((\e[36mx\e[0m, \e[36my\e[0m) => x.size <=> y.size))\n\e[31m\e\
    [31m   |\e[0m                                                      ^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                 value <=> is not a member of Int - did you\
    \ mean Int.<=?\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpsatxnsou.scala:41:23\
    \ --------------------\e[0m\e[0m\n\e[31m41 |\e[0m                maxL = l\n\e\
    [31m\e[31m   |\e[0m                       ^\e[0m\n\e[31m   |\e[0m            \
    \           Found:    (l : Long)\n\e[31m   |\e[0m                       Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpsatxnsou.scala:45:26\
    \ --------------------\e[0m\e[0m\n\e[31m45 |\e[0m                    tmp = g"
  stdout: ''
  timestamp: 1659979260
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        var cnt = 0\n        val res = mutable.ArrayBuffer.empty[List[Long]]\n\
    \        grid.foreach(row => {\n            val leftWells = mutable.ArrayBuffer.empty[List[Long]]\n\
    \            val rightWells = mutable.ArrayBuffer.empty[List[Long]]\n        \
    \    row.foreach(w => {\n                if (w == 1l) {\n                    leftWells\
    \ += w\n                } else {\n                    rightWells += w\n      \
    \          }\n            })\n            val rightBucket = rightWells.toList.sum\n\
    \            val leftBucket = leftWells.toList.sum\n            val leftToUse\
    \ = leftBucket - capacity\n            val rightToUse = rightBucket - capacity\n\
    \            val toUse = (rightToUse + leftToUse) / 2 // we must take at least\
    \ half the left bucket\n            if (toUse >= 0l) { // we need toUse\n    \
    \            cnt += 1\n                res += row :: leftWells\n             \
    \   res += row :: rightWells\n            }\n        })\n        cnt\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpziexp1p_.scala:27:18 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mres\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mList\e[0m[\e[35mLong\e[0m]]\n\e[31m\e[31m   |\e[0m                  ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                  Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpziexp1p_.scala:29:28 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m            \e[33mval\e[0m \e[36mleftWells\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mList\e[0m[\e[35mLong\e[0m]]\n\e[31m\e[31m   |\e[0m                       \
    \     ^^^^^^^\e[0m\n\e[31m   |\e[0m                            Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpziexp1p_.scala:30:29\
    \ ------------------------\e[0m\e[0m\n\e[31m30 |\e[0m            \e[33mval\e[0m\
    \ \e[36mrightWells\e[0m = mutable.ArrayBuffer.empty[\e[35mList\e[0m[\e[35mLong\e\
    [0m]]\n\e[31m\e[31m   |\e[0m                             ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                             Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659979253
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val m = grid.zipWithIndex.toList.sortWith(_._1 > _._1).lastOption.map(x\
    \ => (x._2 - 1) * x._1 + x._2)\n        require(m != 0, \"grid must have at least\
    \ 1 row\")\n        require(m.length == grid.length, \"grid must have same number\
    \ of rows\")\n        require(m(0) == 1, \"all rows should have capacity 1\")\n\
    \        require(m.last < capacity, \"capacity should less than all rows\")\n\n\
    \        var buckets = m.tail\n        var n = m.length\n        var fills = 0\n\
    \n        while (n > 1) {\n            buckets = buckets.tail\n            fills\
    \ += 1\n            n -= 1\n        }\n        fills\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpo77nj_cn.scala:26:55 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mm\e[0m = grid.zipWithIndex.toList.sortWith(_._1\
    \ > _._1).lastOption.map(\e[36mx\e[0m => (x._2 - \e[31m1\e[0m) * x._1 + x._2)\n\
    \e[31m\e[31m   |\e[0m                                                  ^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue > is not a member of List[Long], but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m  import math.Ordered.orderingToOrdered\n\e[31m   |\e[0m  import\
    \ math.Ordering.Implicits.infixOrderingOps\n\e[31m   |\e[0m\n\e[31m\e[31m-- [E134]\
    \ Type Error: /tmp/tmpo77nj_cn.scala:26:94 -----------------------------\e[0m\e\
    [0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mm\e[0m = grid.zipWithIndex.toList.sortWith(_._1\
    \ > _._1).lastOption.map(\e[36mx\e[0m => (x._2 - \e[31m1\e[0m) * x._1 + x._2)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                           ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m None of the overloaded\
    \ alternatives of \e[33mmethod\e[0m \e[35m*\e[0m in \e[33mclass\e[0m \e[35mInt\e\
    [0m with types\n\e[31m   |\e[0m  (x: Double): Double\n\e[31m   |\e[0m  (x: Float):\
    \ Float\n\e[31m   |\e[0m  (x: Long): Long\n\e[31m   |\e[0m  (x: Int): Int\n\e\
    [31m   |\e[0m  (x: Char): Int\n\e[31m   |\e[0m  (x: Short): Int\n\e[31m   |\e\
    [0m  (x: Byte): Int\n\e[31m   |\e[0m match arguments ((x._1 : => List[Long]))\n\
    \e[31m\e[31m-- Error: /tmp/tmpo77nj_cn.scala:27:16 -----------------------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        require(m != \e[31m0\e[0m, \e[31m\"grid must\
    \ have at least 1 row\"\e[0m)\n\e[31m\e[31m   |\e[0m                ^^^^^^\e[0m\n\
    \e[31m   |\e[0mValues of types Option[Nothing] and Int cannot be compared with\
    \ == or !=\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpo77nj_cn.scala:28:18\
    \ ------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        require(m.length\
    \ == grid.length, \e[31m\"grid must have same number of rows\"\e[0m)\n\e[31m\e\
    [31m   |\e[0m                ^^^^^^^^\e[0m\n\e[31m   |\e[0m           "
  stdout: ''
  timestamp: 1659979261
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val m = grid.head\n        val n = m.length\n        val\
    \ bucketSize = math.min(math.max(1L, (m.toLong.maxVal - m.toLong.minVal) / n),\
    \ capacity)\n        val buckets = mutable.ArrayBuffer.fill(m, 0)\n        for(x\
    \ <- 1 to n) {\n            buckets(x - 1) = (bucketSize - buckets(x - 1)).toLong\n\
    \        }\n        val x = 0\n        while(buckets.head < bucketSize) {\n  \
    \          val y = x\n            while(buckets(y) > 0) {\n                buckets(y--)\
    \ = buckets(y) + 1\n            }\n            x += 1\n        }\n        x\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp26_heuc_.scala:37:27 ---------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m                buckets(y--) = buckets(y) + \e[31m1\e\
    [0m\n\e[31m\e[31m   |\e[0m                           ^\e[0m\n\e[31m   |\e[0m \
    \                          expression expected but \e[31m')'\e[0m found\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp26_heuc_.scala:28:50 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mbucketSize\e[0m = math.min(math.max(\e\
    [31m1L\e[0m, (m.toLong.maxVal - m.toLong.minVal) / n), capacity)\n\e[31m\e[31m\
    \   |\e[0m                                                ^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mvalue toLong is not a member of List[Long], but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e\
    [0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import\
    \ math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmp26_heuc_.scala:29:22 ------------------------\e[0m\e\
    [0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mbuckets\e[0m = mutable.ArrayBuffer.fill(m,\
    \ \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp26_heuc_.scala:39:14 ------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m            x += \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m\
    \            ^^^^\e[0m\n\e[31m   |\e[0m            value += is not a member of\
    \ Int - did you mean x.!=?\n4 errors found\n"
  stdout: ''
  timestamp: 1659979260
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        var max = 0\n        val rowSize = grid.head._2.size\n \
    \       val columnSize = grid.head._1.size\n\n        for ((i, j) <- grid.indices)\
    \ {\n            val current = grid((i, j)) - capacity - 1\n            if (current\
    \ > max) {\n                max = current\n            }\n        }\n        max\
    \ / rowSize * columnSize\n    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp16p9hxev.scala:27:32 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mrowSize\e[0m = grid.head._2.size\n\
    \e[31m\e[31m   |\e[0m                      ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                      value _2 is not a member of List[Long]\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmp16p9hxev.scala:28:35 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mcolumnSize\e[0m = grid.head._1.size\n\
    \e[31m\e[31m   |\e[0m                         ^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                         value _1 is not a member of List[Long]\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmp16p9hxev.scala:31:31 --------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m            \e[33mval\e[0m \e[36mcurrent\e[0m = grid((i,\
    \ j)) - capacity - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m                       \
    \        ^^^^^^\e[0m\n\e[31m   |\e[0m                               Found:   \
    \ (Any, Any)\n\e[31m   |\e[0m                               Required: Int\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659979259
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        if (grid.length == 0)\n            return 0\n        val\
    \ cols = grid.head._2.size\n        val rows = grid.length\n        val m = math.min(cols,\
    \ rows)\n        val r = math.min(cols, rows)\n        val n = math.min(rows,\
    \ cols)\n        val r = math.min(r, m)\n        val c = math.min(rows, cols)\n\
    \        val c = math.min(c, m)\n        var sum = 0\n        var filling = 0\n\
    \        val newGrid = grid.map(_.map(_ + 0l))\n        val maxCapacity = n *\
    \ capacity.toInt\n        while (maxCapacity > newGrid.head._2.sum && filling\
    \ < r * c * n) {\n            if (newGrid.head._2.sum < newGrid.head._1.sum) {\n\
    \                newGrid.head._2.map(_.sum - newGrid.head._2.sum)\n          \
    \  }\n            if (newGrid.head._1.sum < newGrid.head._2.sum) {\n         \
    \       newGrid.head._1.map(_.sum - newGrid.head._1.sum)\n            }\n    \
    \        if (newGrid.head._1.sum < newGrid.head._2.sum && newGrid.head._1.sum\
    \ < newGrid.head._2.sum) {\n                newGrid.head._1.map(_.sum - newGrid.head._2.sum)\n\
    \            }\n            newGrid.head._1.map(_.sum - newGrid.head._2.sum)\n\
    \            newGrid.head._2.map(_.sum - newGrid.head._1.sum)\n            filling\
    \ += 1\n        }\n        sum\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 1l.toLong,\
    \ 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong, 0l.toLong), List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (1l)) == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpb5k_18ty.scala:33:12 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = math.min(r, m)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mr is\
    \ already defined as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpb5k_18ty.scala:35:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m\
    \ \e[36mc\e[0m = math.min(c, m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mc is already defined as \e[33mvalue\e[0m \e[35mc\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpb5k_18ty.scala:28:29 ------------------------\e[0m\e[0m\n\e[31m28 |\e\
    [0m        \e[33mval\e[0m \e[36mcols\e[0m = grid.head._2.size\n\e[31m\e[31m  \
    \ |\e[0m                   ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                \
    \   value _2 is not a member of List[Long]\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpb5k_18ty.scala:41:29 ------------------------\e[0m\e[0m\n\e[31m41 |\e\
    [0m            \e[33mif\e[0m (newGrid.head._2.sum < newGrid.head._1.sum) {\n\e\
    [31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \           value _2 is not a member of List[Long]\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmpb5k_18ty.scala:42:29 ------------------------\e[0m\e[0m\n\
    \e[31m42 |\e[0m                newGrid.head._2.map(_.sum - newGrid.head._2.sum)\n\
    \e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m   \
    \             value _2 is not a member of List[Long]\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmpb5k_18ty.scala:44:29 ------------------------\e[0m\e[0m\n\
    \e[31m44 |\e[0m            \e[33mif\e[0m (newGrid.head._1.sum < newGrid.head._2.sum)\
    \ {\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                value _1 is not a member of List[Long]\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpb5k_18ty.scala"
  stdout: ''
  timestamp: 1659979261
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        var total = 0L\n        for ( i <- 0 until grid.length )\
    \ {\n            for ( j <- 1 until grid[0].length ) {\n                if ( grid(i).contains(j)\
    \ ) { \n                    var count = 0L\n                    for ( k <- 0 until\
    \ capacity ) {\n                        count += grid(i).take(k).contains(j) ?\
    \ 1L : 0L\n                    }\n                    total += count * grid[0].length\n\
    \                    break\n                }\n            }\n        }\n    \
    \    total\n    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmparuxof4o.scala:28:35 -----------------------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m            \e[33mfor\e[0m ( j <- \e[31m1\e[0m until\
    \ grid[\e[31m0\e[0m].length ) {\n\e[31m\e[31m   |\e[0m                       \
    \        ^^^^^^^\e[0m\n\e[31m   |\e[0m        \e[33mmethod\e[0m \e[35mapply\e\
    [0m in \e[33mtrait\e[0m \e[35mLinearSeqOps\e[0m does not take type parameters\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmparuxof4o.scala:31:39 --------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m                    \e[33mfor\e[0m ( k <- \e[31m0\e[0m\
    \ until capacity ) {\n\e[31m\e[31m   |\e[0m                                  \
    \     ^^^^^^^^\e[0m\n\e[31m   |\e[0m                                       Found:\
    \    (capacity : Long)\n\e[31m   |\e[0m                                      \
    \ Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmparuxof4o.scala:32:30\
    \ ------------------------\e[0m\e[0m\n\e[31m32 |\e[0m                        count\
    \ += grid(i).take(k).contains(j) ? \e[31m1L\e[0m : \e[31m0L\e[0m\n\e[31m\e[31m\
    \   |\e[0m                        ^^^^^^^^\e[0m\n\e[31m   |\e[0m             \
    \   value += is not a member of Long - did you mean Long.!=?\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmparuxof4o.scala:32:61 ------------------------\e[0m\e\
    [0m\n\e[31m32 |\e[0m                        count += grid(i).take(k).contains(j)\
    \ ? \e[31m1L\e[0m : \e[31m0L\e[0m\n\e[31m\e[31m   |\e[0m                     \
    \            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m             \
    \                    value ? is not a member of Boolean\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmparuxof4o.scala:34:26 ------------------------\e[0m\e\
    [0m\n\e[31m34 |\e[0m                    total += count * grid[\e[31m0\e[0m].length\n\
    \e[31m\e[31m   |\e[0m                    ^^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \          value += is not a member of Long - did you mean Long.!=?\n\e[31m\e\
    [31m-- Error: /tmp/tmparuxof4o.scala:34:41 -----------------------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m                    total += count * grid[\e[31m0\e[0m].lengt"
  stdout: ''
  timestamp: 1659979259
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        def recurse(row : List[Long], bucket : mutable.Set[Long],\
    \ count : Long, minFill : Long) : Long = {\n            if (bucket.size == capacity)\
    \ {\n                count += 1\n            }\n            minFill = recurse(row\
    \ :+ 0l, bucket, count, minFill)\n            minFill = recurse(row :+ 1l, bucket,\
    \ count, minFill)\n            minFill = recurse(row :+ 0l, bucket, count, minFill)\n\
    \            minFill = recurse(row :+ 0l, bucket, count, minFill)\n          \
    \  minFill = recurse(row :+ 0l, bucket, count, minFill)\n            minFill =\
    \ recurse(row :+ 1l, bucket, count, minFill)\n            minFill = recurse(row\
    \ :+ 1l, bucket, count, minFill)\n            minFill = recurse(row :+ 1l, bucket,\
    \ count, minFill)\n            minFill = recurse(row :+ 0l, bucket, count, minFill)\n\
    \            minFill = recurse(row :+ 1l, bucket, count, minFill)\n          \
    \  minFill = recurse(row :+ 1l, bucket, count, minFill)\n            minFill =\
    \ recurse(row :+ 0l, bucket, count, minFill)\n            minFill = recurse(row\
    \ :+ 0l, bucket, count, minFill)\n            minFill = recurse(row :+ 0l, bucket,\
    \ count, minFill)\n            minFill = recurse(row :+ 1l, bucket, count, minFill)\n\
    \            minFill = recurse(row :+ 1l, bucket, count, minFill)\n          \
    \  minFill = recurse(row :+ 0l, bucket, count, minFill)\n            minFill =\
    \ recurse(row :+ 1l, bucket, count, minFill)\n            minFill = recurse(row\
    \ :+ 0l, bucket, count, minFill)\n            minFill = recurse(row :+ 0l, bucket,\
    \ count, minFill)\n            minFill = recurse(row :+ 0l, bucket, count, minFill)\n\
    \            minFill = recurse(row :+ 1l, bucket, count, minFill)\n          \
    \  minFill = recurse(row :+ 1l, bucket, count, minFill)\n            minFill =\
    \ recurse(row :+ 0l, bucket, count, minFill)\n            minFill = recurse(row\
    \ :+ 1l, bucket, count, minFill)\n            minFill = recurse(row :+ 1l, bucket,\
    \ count, minFill)\n            minFill = recurse(row :+ 0l, bucket, count, minFill)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpr67tyv4k.scala:67:0 ----------------------------\e\
    [0m\e[0m\n\e[31m67 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpr67tyv4k.scala:26:47\
    \ ------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mdef\e[0m \e\
    [36mrecurse\e[0m(\e[36mrow\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mbucket\e\
    [0m : mutable.Set[\e[35mLong\e[0m], \e[36mcount\e[0m : \e[35mLong\e[0m, \e[36mminFill\e\
    [0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e[0m          \
    \                                     ^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \                                     Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpr67tyv4k.scala:28:22 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m                count += \e[31m1\e[0m\n\e[31m\e[31m \
    \  |\e[0m                ^^^^^^^^\e[0m\n\e[31m   |\e[0m               value +=\
    \ is not a member of Long - did you mean count.!=?\n\e[31m\e[31m-- [E052] Type\
    \ Error: /tmp/tmpr67tyv4k.scala:30:20 -----------------------------\e[0m\e[0m\n\
    \e[31m30 |\e[0m            minFill = recurse(row :+ \e[31m0l\e[0m, bucket, count,\
    \ minFill)\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m            Reassignment to val minFill\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E052] Type Error: /tmp/tmpr67tyv4k.scala:31:20 -----------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m            minFill = recurse(row :+ \e[31m1l\e[0m, bucket,\
    \ count, minFill)\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m            Reassignment to val minFill\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E052] Type Error: /tmp/tmpr67tyv4k.scala:32:20 -----------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m            minFill = recurse(row :+ \e[31m0l\e[0m, bucket,\
    \ count, minFill)\n\e[31"
  stdout: ''
  timestamp: 1659979271
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val rowCount = grid.length\n        val colCount = grid(0).length\n\
    \        if(rowCount > 0 && colCount > 0) {\n            if(rowCount == 1 || colCount\
    \ == 1)\n                1\n            else\n                rowCount.product(colCount).foldLeft(0l.toLong){(res,\
    \ elem) =>\n                    if(grid(elem).sum() <= capacity)\n           \
    \             res + 1\n                    else\n                        res\n\
    \                }\n        }\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 1l.toLong,\
    \ 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong, 0l.toLong), List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (1l)) == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp3_ntmz5d.scala:32:25 ------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m                rowCount.product(colCount).foldLeft(\e\
    [31m0l\e[0m.toLong){(\e[36mres\e[0m, \e[36melem\e[0m) =>\n\e[31m\e[31m   |\e[0m\
    \                ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                value product\
    \ is not a member of Int\n\e[33m\e[33m-- [E129] Potential Issue Warning: /tmp/tmp3_ntmz5d.scala:30:16\
    \ ----------------\e[0m\e[0m\n\e[33m30 |\e[0m                \e[31m1\e[0m\n\e\
    [33m\e[33m   |\e[0m                ^\e[0m\n\e[33m   |\e[0mA pure expression does\
    \ nothing in statement position; you may be omitting necessary parentheses\n\e\
    [33m   |\e[0m\n\e[33m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 warning found\n1 error found\n"
  stdout: ''
  timestamp: 1659979268
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val m = new mutable.PriorityQueue[(Long, List[List[Long]]),\
    \ mutable.PriorityQueue[(Long, List[List[Long]]), mutable.PriorityQueue[Long]]\
    \ // Use priority queue instead of max heap because it can handle duplicate keys\n\
    \        m.update(0, grid -> (0, grid -> List()))\n        val cnt = 1\n     \
    \   while (!m.isEmpty) {\n            val cur = m.dequeue()\n            val size\
    \ = cur._1\n            val curGrid = cur._2\n            val m = cur._3\n   \
    \         val capacity = curGrid.head\n            val x = curGrid.last\n\n  \
    \          x foreach {\n                case 0 => (curGrid, curGrid) foreach {\n\
    \                    case (row, _) => row.map(_ => 0)\n                }\n   \
    \             case 1 => (curGrid, curGrid) foreach {\n                    case\
    \ (row, _) => row.map(_ => 1)\n                }\n                case _ =>\n\
    \                }\n            x foreach {\n                case 0 => (curGrid,\
    \ curGrid) foreach {\n                    case (row, _) => row.map(_ => 0)\n \
    \               }\n                case 1 => (curGrid, curGrid) foreach {\n  \
    \                  case (row, _) => row.map(_ => 1)\n                }\n     \
    \           case _ =>\n                }\n            x foreach {\n          \
    \      case 0 => (curGrid, curGrid) foreach {\n                    case (row,\
    \ _) => row.map(_ => 0)\n                }\n                case 1 => (curGrid,\
    \ curGrid) foreach {\n                    case (row, _) => row.map(_ => 1)\n \
    \               }\n                case _ =>\n                }\n            x\
    \ foreach {\n                case 0 => (curGrid, curGrid) foreach {\n        \
    \            case (row, _) => row.map(_ => 0)\n                }\n           \
    \     case 1 => (curGrid, curGrid) foreach {\n                    case (row, _)\
    \ => row.map(_ => 1)\n                }\n                case _ =>\n         \
    \       }\n            x foreach {\n                case 0 => (curGrid, curGrid)\
    \ foreach {\n                    case (row, _) => row.map(_ => 0)\n          \
    \      }\n                case 1 => (curGrid, curGrid) foreach {\n           \
    \         case (row, _) => row.map(_ => 1)\n                }\n              \
    \  case _ =>\n                }\n            x foreach {\n                case\
    \ 0 => (curGrid, curGrid) foreach {\n                    case (row, _) => row.map(_\
    \ => 0)\n                }\n                case 1 => (curGrid, curGrid) foreach\
    \ {\n                    case (row, _) => row.map(_ => 1)\n                }\n\
    \                case _ \n    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpm_4fgmed.scala:27:9 ----------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        m.update(\e[31m0\e[0m, grid -> (\e[31m0\e[0m,\
    \ grid -> List()))\n\e[31m\e[31m   |\e[0m         ^\e[0m\n\e[31m   |\e[0m    \
    \     an identifier expected, but '.' found\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpm_4fgmed.scala:26:20 ------------------------\e[0m\e[0m\n\e[31m26 |\e\
    [0m        \e[33mval\e[0m \e[36mm\e[0m = \e[33mnew\e[0m mutable.PriorityQueue[(\e\
    [35mLong\e[0m, \e[35mList\e[0m[\e[35mList\e[0m[\e[35mLong\e[0m]]), mutable.PriorityQueue[(\e\
    [35mLong\e[0m, \e[35mList\e[0m[\e[35mList\e[0m[\e[35mLong\e[0m]]), mutable.PriorityQueue[\e\
    [35mLong\e[0m]] \e[34m// Use priority queue instead of max heap because it can\
    \ handle duplicate keys\e[0m\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpm_4fgmed.scala:99:1 ---------------------\e\
    [0m\e[0m\n\e[31m99 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e[0m\n\e[31m   |\e[0m Found:\
    \    Unit\n\e[31m   |\e[0m Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659979268
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        var maxWellCapacity = 0\n        var curMaxWellCapacity\
    \ = 0\n        var curWellsToLow = 0\n        var curWellsToFill = 0\n       \
    \ var totalWellsToFill = 0\n        var currentLevel = 1\n        var curWell\
    \ = 0\n        for (rowIndex <- 0 until grid.length) {\n            curMaxWellCapacity\
    \ = grid[rowIndex].foldLeft(0) { (maxValue, item) =>\n                if (maxValue\
    \ > item) maxValue\n                else item\n            }\n            if (curMaxWellCapacity\
    \ > capacity) {\n                curMaxWellCapacity = capacity\n            }\n\
    \            while (currentLevel <= curMaxWellCapacity / capacity ) {\n      \
    \          curWellsToLow = (curMaxWellCapacity * currentLevel).toLong\n      \
    \          curWellsToFill += curWellsToLow\n                totalWellsToFill +=\
    \ curWellsToLow\n                currentLevel += 1\n            }\n          \
    \  while (curWellsToFill > 0) {\n                grid[rowIndex].tail.headOption\
    \ match {\n                case Some(curWell) => curWell -= 1\n              \
    \  case None => curWellsToFill -= 1\n                }\n                curWellsToFill\
    \ -= 1\n            }\n        }\n        totalWellsToFill\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpcqbx3hm7.scala:34:38 ------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m            curMaxWellCapacity = grid[\e[35mrowIndex\e\
    [0m].foldLeft(\e[31m0\e[0m) { (\e[36mmaxValue\e[0m, \e[36mitem\e[0m) =>\n\e[31m\e\
    [31m   |\e[0m                                      ^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                                      Not found: type rowIndex\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpcqbx3hm7.scala:39:37 --------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m                curMaxWellCapacity = capacity\n\e[31m\e\
    [31m   |\e[0m                                     ^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                                     Found:    (capacity : Long)\n\e[31m  \
    \ |\e[0m                                     Required: Int\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpcqbx3hm7.scala:42:68 --------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m                curWellsToLow = (curMaxWellCapacity *\
    \ currentLevel).toLong\n\e[31m\e[31m   |\e[0m                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                Found:    Long\n\e[31m   |\e\
    [0m                                Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpcqbx3hm7.scala:48:21 ------------------------\e\
    [0m\e[0m\n\e[31m48 |\e[0m                grid[\e[35mrowIndex\e[0m].tail.headOption\
    \ \e[33mmatch\e[0m {\n\e[31m\e[31m   |\e[0m                     ^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                     Not found: type rowIndex\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1659979270
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val max = 0\n        val res = 0\n        for (a <- grid)\
    \ {\n            val temp = (a(0).asInstanceOf[Long], a(1).asInstanceOf[Long],\
    \ a(2).asInstanceOf[Long])\n            val temp2 = temp._2 - temp._1\n      \
    \      val temp3 = temp._3 - temp._1\n            val temp4 = temp._3 - temp._2\n\
    \            val temp5 = temp._4 - temp._1\n            val temp6 = temp._4 -\
    \ temp._2\n            if (temp3 > temp) {\n                if (temp4 > temp)\
    \ {\n                    if (temp6 > temp) {\n                        if (temp5\
    \ > temp) {\n                            if (temp2 > temp) {\n               \
    \                 max = temp5\n                                res = 1\n     \
    \                       }\n                        }\n                    }\n\
    \                }\n            }\n        }\n        if (res == 0) res\n    \
    \    else max\n    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpg9zhmr65.scala:33:29 ------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m            \e[33mval\e[0m \e[36mtemp5\e[0m = temp._4\
    \ - temp._1\n\e[31m\e[31m   |\e[0m                        ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m  value _4 is not a member of (Long, Long, Long) - did you mean temp._1?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpg9zhmr65.scala:34:29 ------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m            \e[33mval\e[0m \e[36mtemp6\e[0m = temp._4\
    \ - temp._2\n\e[31m\e[31m   |\e[0m                        ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m  value _4 is not a member of (Long, Long, Long) - did you mean temp._1?\n\
    \e[31m\e[31m-- [E134] Type Error: /tmp/tmpg9zhmr65.scala:35:22 -----------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m            \e[33mif\e[0m (temp3 > temp) {\n\e[31m\e\
    [31m   |\e[0m                ^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded\
    \ alternatives of \e[33mmethod\e[0m \e[35m>\e[0m in \e[33mclass\e[0m \e[35mLong\e\
    [0m with types\n\e[31m   |\e[0m (x: Double): Boolean\n\e[31m   |\e[0m (x: Float):\
    \ Boolean\n\e[31m   |\e[0m (x: Long): Boolean\n\e[31m   |\e[0m (x: Int): Boolean\n\
    \e[31m   |\e[0m (x: Char): Boolean\n\e[31m   |\e[0m (x: Short): Boolean\n\e[31m\
    \   |\e[0m (x: Byte): Boolean\n\e[31m   |\e[0mmatch arguments ((temp : (Long,\
    \ Long, Long)))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpg9zhmr65.scala:36:26\
    \ -----------------------------\e[0m\e[0m\n\e[31m36 |\e[0m                \e[33mif\e\
    [0m (temp4 > temp) {\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e[35m>\e\
    [0m in \e[33mclass\e[0m \e[35mLong\e[0m with types\n\e[31m   |\e[0m (x: Double):\
    \ Boolean\n\e[31m   |\e[0m (x: Float): Boolean\n\e[31m   |\e[0m (x: Long): Boolean\n\
    \e[31m   |\e[0m (x: Int): Boolean\n\e[31m   |\e[0m (x: Char): Boolean\n\e[31m\
    \   |\e[0m (x: Short): Boolean\n\e[31m   |\e[0m (x: Byte): Boolean\n\e[31m   |\e\
    [0mmatch arguments ((temp : (Long, Long, Long)))\n\e[31m\e[31m-- [E134] Type Error:\
    \ /tmp/tmpg9zhmr65.scala:39:38 -----------------------------\e[0m\e[0m\n\e[31m39\
    \ |\e[0m                            \e[33mif\e[0m (temp2 > temp) {\n\e[31m\e[31m\
    \   |\e[0m "
  stdout: ''
  timestamp: 1659979272
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val rows = grid.length // number of rows\n        val columns\
    \ = grid(0).length // number of columns\n        val maxBuckets = rows * columns\
    \ // maximum number of buckets\n        val bucketCapacity = capacity / rows\n\
    \        var sum = 0 \n        for (row <- 0 until rows; row < rows ; row++) {\n\
    \            for (column <- 0 until columns; column < columns; column++) {\n \
    \               // use bucket\n                if (grid[row][column] == 1)\n \
    \               {\n                    val bucket = bucket getOrElse { new Long(0);\
    \ } \n                    // use bucket\n                    bucket.update(capacity\
    \ - bucket.asInstanceOf[Long], 1l)\n                    sum = sum + bucket\n \
    \               }\n            }\n        }\n        if (sum < bucketCapacity)\n\
    \            sum\n        else\n            maxBuckets - sum\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp_6y8ya5o.scala:31:45 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mfor\e[0m (row <- \e[31m0\e[0m until rows;\
    \ row < rows ; row++) {\n\e[31m\e[31m   |\e[0m                               \
    \              ^\e[0m\n\e[31m   |\e[0m                                       \
    \     '<-' expected, but ';' found\n\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmp_6y8ya5o.scala:31:52\
    \ ---------------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mfor\e[0m\
    \ (row <- \e[31m0\e[0m until rows; row < rows ; row++) {\n\e[31m\e[31m   |\e[0m\
    \                                                    ^\e[0m\n\e[31m   |\e[0m \
    \                                                   pattern expected\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp_6y8ya5o.scala:32:60 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m            \e[33mfor\e[0m (column <- \e[31m0\e[0m until\
    \ columns; column < columns; column++) {\n\e[31m\e[31m   |\e[0m              \
    \                                              ^\e[0m\n\e[31m   |\e[0m       \
    \                                     '<-' expected, but ';' found\n\e[31m\e[31m--\
    \ [E032] Syntax Error: /tmp/tmp_6y8ya5o.scala:32:70 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m            \e[33mfor\e[0m (column <- \e[31m0\e[0m until\
    \ columns; column < columns; column++) {\n\e[31m\e[31m   |\e[0m              \
    \                                                        ^\e[0m\n\e[31m   |\e\
    [0m                                                        pattern expected\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659979268
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        def maxFillIterate(frontier : Set[Long], grid : List[List[Long]],\
    \ capacity : Long, result : Long) : Long = {\n            result match {\n   \
    \             case 0 => 0\n                case 1 => 0\n                case _\
    \ => {\n                    val index = frontier.head\n                    val\
    \ r = frontier.tail\n\n                    if (index == grid.length) maxFillIterate(r,\
    \ grid, capacity, 0)\n                    else if (capacity == 0) maxFillIterate(r,\
    \ grid, capacity, 1)\n                    else {\n                        val\
    \ next = grid[index].head\n                        maxFillIterate(r, grid, capacity\
    \ - next, result + 1)\n                    }\n                }\n            }\n\
    \        }\n\n        val empty = Set(1l, 0l)\n        val front = Set(1l, 0l)\n\
    \        var max = 0l\n        var count = 0\n        for (row <- grid) {\n  \
    \          count += 1\n            var cur = 0l\n            for (cell <- row)\
    \ {\n                if (cell.toLong == 0) {\n                    cur += 1l\n\
    \                }\n            }\n            if (cur > max) {\n            \
    \    max = cur\n                front = empty\n            }\n            if (cur\
    \ > max) {\n                max = cur\n                front = empty\n       \
    \     }\n        }\n        maxFillIterate(front, grid, capacity, count)\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp0o59_rok.scala:37:40 ------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m                        \e[33mval\e[0m \e[36mnext\e[0m\
    \ = grid[\e[35mindex\e[0m].head\n\e[31m\e[31m   |\e[0m                       \
    \                 ^^^^^\e[0m\n\e[31m   |\e[0m                                \
    \        Not found: type index\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E052] Type Error:\
    \ /tmp/tmp0o59_rok.scala:58:22 -----------------------------\e[0m\e[0m\n\e[31m58\
    \ |\e[0m                front = empty\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                Reassignment to val front\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E052] Type Error: /tmp/tmp0o59_rok.scala:62:22 -----------------------------\e\
    [0m\e[0m\n\e[31m62 |\e[0m                front = empty\n\e[31m\e[31m   |\e[0m\
    \                ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                Reassignment\
    \ to val front\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659979268
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        var count : Long = 0\n        for (x <- 0 until grid.length)\
    \ {\n            val minGrid: mutable.Map[Long, Long] = mutable.Map[Long, Long]()\n\
    \            val buckets = mutable.Map[Long, Long]()\n            for (y <- 0\
    \ until grid[x].length) {\n                buckets += ((x, y), capacity)\n   \
    \             minGrid += ((x, y), grid[x][y].toLong)\n            }\n        \
    \    minGrid.forKeyValue { (x, y) =>\n                if (buckets.contains((x,\
    \ y))) {\n                    if (minGrid.contains((x, y))) {\n              \
    \          minGrid((x, y)) -= buckets((x, y))\n                        buckets\
    \ -= ((x, y))\n                        count += 1\n                    }\n   \
    \                 else {\n                        minGrid((x, y)) -= grid[x][y]\n\
    \                    }\n                }\n            }\n        }\n        count\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpkfjaxx2r.scala:28:25 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m            \e[33mval\e[0m \e[36mminGrid\e[0m: mutable.Map[\e\
    [35mLong\e[0m, \e[35mLong\e[0m] = mutable.Map[\e[35mLong\e[0m, \e[35mLong\e[0m]()\n\
    \e[31m\e[31m   |\e[0m                         ^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                       Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpkfjaxx2r.scala:28:51 ------------------------\e[0m\e\
    [0m\n\e[31m28 |\e[0m            \e[33mval\e[0m \e[36mminGrid\e[0m: mutable.Map[\e\
    [35mLong\e[0m, \e[35mLong\e[0m] = mutable.Map[\e[35mLong\e[0m, \e[35mLong\e[0m]()\n\
    \e[31m\e[31m   |\e[0m                                                   ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                                   Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpkfjaxx2r.scala:29:26\
    \ ------------------------\e[0m\e[0m\n\e[31m29 |\e[0m            \e[33mval\e[0m\
    \ \e[36mbuckets\e[0m = mutable.Map[\e[35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e\
    [31m   |\e[0m                          ^^^^^^^\e[0m\n\e[31m   |\e[0m         \
    \                 Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpkfjaxx2r.scala:30:35 ------------------------\e[0m\e\
    [0m\n\e[31m30 |\e[0m            \e[33mfor\e[0m (y <- \e[31m0\e[0m until grid[\e\
    [35mx\e[0m].length) {\n\e[31m\e[31m   |\e[0m                                 \
    \  ^\e[0m\n\e[31m   |\e[0m                                   Not found: type x\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659979268
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        var max = 0\n        var res = 0\n        val rs = mutable.Queue[Int](0)\n\
    \        grid.foreach{row =>\n            row.foreach{c =>\n                if(c\
    \ == 0)\n                    rs.push(grid.get(rs.size))\n                else\n\
    \                    rs.pop()\n            }\n        }\n        while(!rs.isEmpty)\
    \ {\n            val r = rs.pop\n            val w = grid[r]\n            val\
    \ l = grid[r.max(0) - 1]\n            max = math.max(max, l - w)\n           \
    \ res += 1\n        }\n        if(max >= capacity)\n            max\n        else\n\
    \            0\n    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpkox3rg42.scala:40:30 ---------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m            \e[33mval\e[0m \e[36ml\e[0m = grid[r.max(\e\
    [31m0\e[0m) - \e[31m1\e[0m]\n\e[31m\e[31m   |\e[0m                           \
    \   ^\e[0m\n\e[31m   |\e[0m                              ']' expected, but '('\
    \ found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpkox3rg42.scala:28:17 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mrs\e[0m = mutable.Queue[\e\
    [35mInt\e[0m](\e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m                 ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                 Not found: mutable\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpkox3rg42.scala:39:25 ------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m            \e[33mval\e[0m \e[36mw\e[0m = grid[\e[35mr\e\
    [0m]\n\e[31m\e[31m   |\e[0m                         ^\e[0m\n\e[31m   |\e[0m  \
    \                       Not found: type r\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659979267
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        var size : Int = grid.length\n        var fill : Long =\
    \ 1\n        var i : Int = 0\n        while (i < size) {\n            var j :\
    \ Int = i + 1\n            while (j < size) {\n                if (grid[i][j]\
    \ == 1l) {\n                    fill += capacity\n                } else {\n \
    \                   fill -= 1\n                }\n                j+=1\n     \
    \       }\n            i+=1\n        }\n        fill\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpl5pxzclj.scala:32:28 ------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m                \e[33mif\e[0m (grid[\e[35mi\e[0m][\e\
    [35mj\e[0m] == \e[31m1l\e[0m) {\n\e[31m\e[31m   |\e[0m                       \
    \     ^\e[0m\n\e[31m   |\e[0m                            Not found: type j\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpl5pxzclj.scala:32:25\
    \ ------------------------\e[0m\e[0m\n\e[31m32 |\e[0m                \e[33mif\e\
    [0m (grid[\e[35mi\e[0m][\e[35mj\e[0m] == \e[31m1l\e[0m) {\n\e[31m\e[31m   |\e\
    [0m                         ^\e[0m\n\e[31m   |\e[0m                         Not\
    \ found: type i\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659979269
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val rem = grid.map(_.zipWithIndex).\n            filter(x\
    \ => x._2.length == grid.length).\n            map(x => (x._2.last, x._2)).toMap\n\
    \n        val empty = grid.map(_.zipWithIndex).filter(x => x._2.length == 1).map(x\
    \ => (x._2.last, x._2)).toMap\n\n        val newMap = rem.foldLeft(empty)( (m,x)\
    \ => {\n            val last = m.getOrElse(x._1, 0l)\n            val m = m.updated(x._1,\
    \ last + x._2)\n            m\n        })\n        newMap.getOrElse(capacity,0l)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmplk9z_coe.scala:27:26 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m            filter(\e[36mx\e[0m => x._2.length == grid.length).\n\
    \e[31m\e[31m   |\e[0m                        ^^^^\e[0m\n\e[31m   |\e[0m      \
    \                  value _2 is not a member of List[(Long, Int)]\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmplk9z_coe.scala:28:24 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m            map(\e[36mx\e[0m => (x._2.last, x._2)).toMap\n\
    \e[31m\e[31m   |\e[0m                      ^^^^\e[0m\n\e[31m   |\e[0m        \
    \              value _2 is not a member of List[(Long, Int)]\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmplk9z_coe.scala:28:35 ------------------------\e[0m\e\
    [0m\n\e[31m28 |\e[0m            map(\e[36mx\e[0m => (x._2.last, x._2)).toMap\n\
    \e[31m\e[31m   |\e[0m                                 ^^^^\e[0m\n\e[31m   |\e\
    [0m                           value _2 is not a member of List[(Long, Int)]\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmplk9z_coe.scala:30:59 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mempty\e[0m = grid.map(_.zipWithIndex).filter(\e\
    [36mx\e[0m => x._2.length == \e[31m1\e[0m).map(\e[36mx\e[0m => (x._2.last, x._2)).toMap\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \ ^^^^\e[0m\n\e[31m   |\e[0m                           value _2 is not a member\
    \ of List[(Long, Int)]\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmplk9z_coe.scala:30:87\
    \ ------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e\
    [36mempty\e[0m = grid.map(_.zipWithIndex).filter(\e[36mx\e[0m => x._2.length ==\
    \ \e[31m1\e[0m).map(\e[36mx\e[0m => (x._2.last, x._2)).toMap\n\e[31m\e[31m   |\e\
    [0m                                                                          \
    \           ^^^^\e[0m\n\e[31m   |\e[0m                           value _2 is not\
    \ a member of List[(Long, Int)]\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmplk9z_coe.scala:30:98\
    \ ------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e\
    [36mempty\e[0m = grid.map(_.zipWithIndex).filter(\e[36mx\e[0m => x._2.length ==\
    \ \e[31m1\e[0m).map(\e[3"
  stdout: ''
  timestamp: 1659979274
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val m = grid.length\n        val n = grid[0].length\n  \
    \      val bucket = mutable.ArrayBuffer(capacity)\n        val result = mutable.ArrayBuffer.fill(m)\n\
    \        grid(0).foreach { n =>\n            bucket.clear()\n            grid(0).foreach\
    \ { i =>\n                bucket.add(grid(i)(n))\n            }\n            while\
    \ (!bucket.isEmpty) {\n                val k = bucket.head\n                bucket.clear()\n\
    \                grid(0).foreach { i =>\n                    if (grid(i)(n) <=\
    \ k) {\n                        bucket.add(grid(i)(n))\n                    }\n\
    \                }\n                if (bucket.size > 0) {\n                 \
    \   result.add(-1)\n                } else {\n                    result.add(0)\n\
    \                }\n            }\n        }\n        result(0)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpzbkitcsj.scala:27:20 -----------------------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = grid[\e[31m0\e\
    [0m].length\n\e[31m\e[31m   |\e[0m                ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \        \e[33mmethod\e[0m \e[35mapply\e[0m in \e[33mtrait\e[0m \e[35mLinearSeqOps\e\
    [0m does not take type parameters\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpzbkitcsj.scala:28:21\
    \ ------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e\
    [36mbucket\e[0m = mutable.ArrayBuffer(capacity)\n\e[31m\e[31m   |\e[0m       \
    \              ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpzbkitcsj.scala:29:21\
    \ ------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = mutable.ArrayBuffer.fill(m)\n\e[31m\e[31m   |\e[0m         \
    \            ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpzbkitcsj.scala:39:29\
    \ --------------------\e[0m\e[0m\n\e[31m39 |\e[0m                    \e[33mif\e\
    [0m (grid(i)(n) <= k) {\n\e[31m\e[31m   |\e[0m                             ^\e\
    [0m\n\e[31m   |\e[0m                             Found:    (i : Long)\n\e[31m\
    \   |\e[0m                             Required: Int\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpzbkitcsj.scala:39:32 --------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m                    \e[33mif\e[0m (grid(i)(n) <= k) {\n\
    \e[31m\e[31m   |\e[0m                                ^\e[0m\n\e[31m   |\e[0m \
    \                               Found:    (n : Long)\n\e[31m   |\e[0m        \
    \                        Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n5 errors found\n"
  stdout: ''
  timestamp: 1659979273
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        var n = 1\n        val result = new mutable.HashMap[Long,\
    \ Int]()\n        for (row <- grid) {\n            val bucketCapacity = row.last\n\
    \            var bucketSum = 0\n            var bucketCount = 0\n            for\
    \ (col <- row) {\n                if (col == 0) bucketCount += 1\n           \
    \     if (col == 1) bucketSum += bucketCapacity\n                if (bucketCount\
    \ == capacity) bucketCapacity -= 1\n            }\n            result(bucketCount)\
    \ += n\n            n *= bucketCapacity\n        }\n        result(1l) += n\n\
    \        result(2l) += n\n        result(3l) += n\n        result(4l) += n\n \
    \       result(5l) += n\n        result(0l) += n\n        result\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp3k5pfdrh.scala:27:25 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m mutable.HashMap[\e[35mLong\e[0m, \e[35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m\
    \                         ^^^^^^^\e[0m\n\e[31m   |\e[0m                      \
    \   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp3k5pfdrh.scala:34:40\
    \ ------------------------\e[0m\e[0m\n\e[31m34 |\e[0m                \e[33mif\e\
    [0m (col == \e[31m1\e[0m) bucketSum += bucketCapacity\n\e[31m\e[31m   |\e[0m \
    \                             ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m             \
    \     value += is not a member of Int - did you mean Int.!=?\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp3k5pfdrh.scala:35:60 ------------------------\e[0m\e\
    [0m\n\e[31m35 |\e[0m                \e[33mif\e[0m (bucketCount == capacity) bucketCapacity\
    \ -= \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m                                     \
    \        ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m      value -= is not a member\
    \ of Long - did you mean bucketCapacity.!=?\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmp3k5pfdrh.scala:38:14 ------------------------\e[0m\e[0m\n\e[31m38 |\e\
    [0m            n *= bucketCapacity\n\e[31m\e[31m   |\e[0m            ^^^^\e[0m\n\
    \e[31m   |\e[0m            value *= is not a member of Int - did you mean Int.!=?\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1659979273
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        var result : Long = 0\n        var newGrid : List[List[Long]]\
    \ = grid.clone\n        val nwell = grid.map(_.length).reduce(_ + _)\n       \
    \ val nrow = grid.length\n        val ncol = grid(0).length\n        val nbucket\
    \ = ceil(nwell / ncol).toInt\n        for ( i <- 0 until nrow) {\n           \
    \ for ( j <- 0 until ncol) {\n                if (grid[i][j] == 1) {\n       \
    \             var bucket = floor((j * ncol + i) / nbucket).toInt\n           \
    \         if (bucket <= capacity) {\n                        val x = ((j * ncol\
    \ + i) % nbucket) + 1\n                        val y = ((j * ncol + i) / nbucket)\
    \ + 1\n                        newGrid(x) = y.toLong\n                    }\n\
    \                }\n            }\n        }\n        for (i <- 0 until nwell)\
    \ {\n            if (newGrid(i) <= capacity) {\n                result += newGrid(i).toLong\n\
    \            }\n        }\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 1l.toLong,\
    \ 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong, 0l.toLong), List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (1l)) == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpk4p24byu.scala:27:46 -----------------------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mvar\e[0m \e[36mnewGrid\e[0m : \e[35mList\e\
    [0m[\e[35mList\e[0m[\e[35mLong\e[0m]] = grid.clone\n\e[31m\e[31m   |\e[0m    \
    \                                     ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\e[33mmethod\e\
    [0m \e[35mclone\e[0m in \e[33mclass\e[0m \e[35mObject\e[0m cannot be accessed\
    \ as a member of (grid : List[List[Long]]) from module class Problem$.\n\e[31m\
    \   |\e[0m Access to protected \e[33mmethod\e[0m \e[35mclone\e[0m not permitted\
    \ because prefix type List[List[Long]]\n\e[31m   |\e[0m does not conform to \e\
    [33mobject\e[0m \e[35mProblem\e[0m where the access takes place\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpk4p24byu.scala:34:28 ------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m                \e[33mif\e[0m (grid[\e[35mi\e[0m][\e\
    [35mj\e[0m] == \e[31m1\e[0m) {\n\e[31m\e[31m   |\e[0m                        \
    \    ^\e[0m\n\e[31m   |\e[0m                            Not found: type j\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpk4p24byu.scala:34:25\
    \ ------------------------\e[0m\e[0m\n\e[31m34 |\e[0m                \e[33mif\e\
    [0m (grid[\e[35mi\e[0m][\e[35mj\e[0m] == \e[31m1\e[0m) {\n\e[31m\e[31m   |\e[0m\
    \                         ^\e[0m\n\e[31m   |\e[0m                         Not\
    \ found: type i\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpk4p24byu.scala:39:24\
    \ ------------------------\e[0m\e[0m\n\e[31m39 |\e[0m                        newGrid(x)\
    \ = y.toLong\n\e[31m\e[31m   |\e[0m                        ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mvalue update is not a member of List[List[Long]] - did you mean List[List[Long]].updated?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpk4p24byu.scala:45:27 ------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m            \e[33mif\e[0m (newGrid(i) <= capacity) {\n\
    \e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ <= is not a member of List[Long], but could be made available as an exte"
  stdout: ''
  timestamp: 1659979274
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        def findEmptyRow(i : Long, max : Long) : List[Long] = {\n\
    \            val max = i\n            val list = List[Long]()\n            while\
    \ (i < grid.length) {\n                if (grid[max](0) != 0) {\n            \
    \        list :+= max\n                    max -= 1\n                } else {\n\
    \                    max = 0\n                    i += 1\n                }\n\
    \            }\n            list\n        }\n        def findEmptyColumn(j : Long,\
    \ max : Long) : List[Long] = {\n            val max = j\n            val list\
    \ = List[Long]()\n            while (j < grid.length) {\n                if (grid[j](0)\
    \ != 0) {\n                    list :+= max\n                    max -= 1\n  \
    \              } else {\n                    max = 0\n                    j +=\
    \ 1\n                }\n            }\n            list\n        }\n        var\
    \ count = 0\n        val r = findEmptyRow(0, grid.length-1)\n        val c = findEmptyColumn(0,\
    \ grid.length-1)\n        var minCap = capacity\n        var maxCap = capacity\n\
    \        var i = 0\n        var j = 0\n        while (r.contains(0) == true &&\
    \ c.contains(0) == true) {\n            i += 1\n            j += 1\n         \
    \   minCap = max(minCap, grid[r.head](1).toLong)\n            maxCap = max(maxCap,\
    \ grid[c.head](1).toLong)\n            if (grid[r.head](1).toLong <= grid[c.head](1).toLong)\
    \ {\n                r.remove(0)\n                c.remove(0) \n             \
    \   count += grid[r.head](1).toLong\n            }\n        }\n        minCap\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp2p4fncci.scala:30:25 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m                \e[33mif\e[0m (grid[\e[35mmax\e[0m](\e\
    [31m0\e[0m) != \e[31m0\e[0m) {\n\e[31m\e[31m   |\e[0m                        \
    \ ^^^\e[0m\n\e[31m   |\e[0m                         Not found: type max\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp2p4fncci.scala:31:25 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m                    list :+= max\n\e[31m\e[31m   |\e\
    [0m                    ^^^^^^^^\e[0m\n\e[31m   |\e[0m         value :+= is not\
    \ a member of List[Long] - did you mean list.:+?\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmp2p4fncci.scala:32:24 ------------------------\e[0m\e[0m\n\e[31m32\
    \ |\e[0m                    max -= \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m       \
    \             ^^^^^^\e[0m\n\e[31m   |\e[0m                 value -= is not a member\
    \ of Long - did you mean max.!=?\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmp2p4fncci.scala:34:24\
    \ -----------------------------\e[0m\e[0m\n\e[31m34 |\e[0m                   \
    \ max = \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Reassignment to val max\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmp2p4fncci.scala:35:22 ------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m                    i += \e[31m1\e[0m\n\e[31m\e[31m \
    \  |\e[0m                    ^^^^\e[0m\n\e[31m   |\e[0m                   value\
    \ += is not a member of Long - did you mean i.!=?\n\e[31m\e[31m-- [E006] Not Found\
    \ Error: /tmp/tmp2p4fncci.scala:44:25 ------------------------\e[0m\e[0m\n\e[31m44\
    \ |\e[0m                \e[33mif\e[0m (grid[\e[35mj\e[0m](\e[31m0\e[0m) != \e\
    [31m0\e[0m) {\n\e[31m\e[31m   |\e[0m                         ^\e[0m\n\e[31m  \
    \ |\e[0m                         Not found: type j\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp2p4fncci.scala:45:25 ------------------------"
  stdout: ''
  timestamp: 1659979277
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        var count = 0;\n        var bucket = new Array[Long](10)\n\
    \        for (well <- grid) {\n            var l = well.length\n            if\
    \ (l == 0) {\n                bucket.clear\n                count += 1\n     \
    \           continue\n            }\n            var max = 0\n            for\
    \ (j <- 0 until l) {\n                if (well[j] != 0l) {\n                 \
    \   max += 1\n                }\n            }\n            if (max > bucket(l))\
    \ {\n                bucket(l) = max\n            }\n        }\n        count\
    \ += (bucket.length - 1)\n        for (i <- 0 until bucket.length) {\n       \
    \     count -= bucket(bucket.length - i - 1)\n        }\n        count\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpl2wkzahd.scala:31:23 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m                bucket.clear\n\e[31m\e[31m   |\e[0m \
    \               ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue clear is not a member\
    \ of Array[Long] - did you mean Array[Long].clone?\n\e[31m\e[31m-- [E006] Not\
    \ Found Error: /tmp/tmpl2wkzahd.scala:33:16 ------------------------\e[0m\e[0m\n\
    \e[31m33 |\e[0m                continue\n\e[31m\e[31m   |\e[0m               \
    \ ^^^^^^^^\e[0m\n\e[31m   |\e[0m                Not found: continue\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpl2wkzahd.scala:37:25 ------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m                \e[33mif\e[0m (well[\e[35mj\e[0m] !=\
    \ \e[31m0l\e[0m) {\n\e[31m\e[31m   |\e[0m                         ^\e[0m\n\e[31m\
    \   |\e[0m                         Not found: type j\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpl2wkzahd.scala:47:18 ------------------------\e\
    [0m\e[0m\n\e[31m47 |\e[0m            count -= bucket(bucket.length - i - \e[31m1\e\
    [0m)\n\e[31m\e[31m   |\e[0m            ^^^^^^^^\e[0m\n\e[31m   |\e[0m        \
    \    value -= is not a member of Int - did you mean Int.!=?\n4 errors found\n"
  stdout: ''
  timestamp: 1659979274
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val grid = grid.toSet\n        val colLen = grid(0).length\n\
    \        val rowLen = grid(0).zipWithIndex.map(_._2).max\n        \n        val\
    \ res = mutable.HashSet[(Long, Long)]()\n        var count = 0\n        \n   \
    \     for (i <- 0 until colLen) {\n            val left  = 0\n            val\
    \ right = 10\n            \n            while (left < right) {\n             \
    \   val m = (left + right) / 2\n                \n                // move upward\n\
    \                val row = grid(0).zipWithIndex.find { case (k, v) => v >= m }._2\n\
    \                val col = row(i)\n                \n                // move right\n\
    \                val row = grid(0).zipWithIndex.find { case (k, v) => v < m }._2\n\
    \                val col = row(i)\n                \n                val v = grid(0).zipWithIndex.find\
    \ { case (k, v) => v == m }._1\n                val w = v\n                \n\
    \                if (!res.contains((v,w))) count += 1\n                \n    \
    \            val nx = grid.toSeq.filter(_.contains(v))\n                if (nx.exists(_.size\
    \ == 2)) break\n                \n                val ny = grid.toSeq.filter(_.contains(w))\n\
    \                if (ny.exists(_.size == 2)) break\n                \n       \
    \         if (w >= colLen) right = m - 1\n                else if (w <= colLen\
    \ + rowLen) left = m + 1\n                else break\n            }\n        }\n\
    \        \n        val res = res.toSeq.map(_.swap).map(_._2)\n        res.length\
    \ * count\n    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp19xiooce.scala:65:12 ---------------------------\e\
    [0m\e[0m\n\e[31m65 |\e[0m        \e[33mval\e[0m \e[36mres\e[0m = res.toSeq.map(_.swap).map(_._2)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mres is already defined as \e[33mvalue\e[0m \e[35mres\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmp19xiooce.scala:26:19 ---------------------------\e[0m\e[0m\n\e[31m26\
    \ |\e[0m        \e[33mval\e[0m \e[36mgrid\e[0m = grid.toSet\n\e[31m\e[31m   |\e\
    [0m                   ^\e[0m\n\e[31m   |\e[0m                   Recursive \e[33mvalue\e\
    [0m \e[35mgrid\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp19xiooce.scala:30:18 ------------------------\e[0m\e[0m\n\e[31m30 |\e\
    [0m        \e[33mval\e[0m \e[36mres\e[0m = mutable.HashSet[(\e[35mLong\e[0m, \e\
    [35mLong\e[0m)]()\n\e[31m\e[31m   |\e[0m                  ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                  Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp19xiooce.scala:54:44 ------------------------\e\
    [0m\e[0m\n\e[31m54 |\e[0m                \e[33mif\e[0m (nx.exists(_.size == \e\
    [31m2\e[0m)) break\n\e[31m\e[31m   |\e[0m                                    \
    \        ^^^^^\e[0m\n\e[31m   |\e[0m                                         \
    \   Not found: break\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp19xiooce.scala:57:44\
    \ ------------------------\e[0m\e[0m\n\e[31m57 |\e[0m                \e[33mif\e\
    [0m (ny.exists(_.size == \e[31m2\e[0m)) break\n\e[31m\e[31m   |\e[0m         \
    \                                   ^^^^^\e[0m\n\e[31m   |\e[0m              \
    \                              Not found: break\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E052] Type E"
  stdout: ''
  timestamp: 1659979269
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        var max = 0\n        val m = grid.length\n        val n\
    \ = grid(0).length\n        for(i <- 0 until m){\n            var left = 0\n \
    \           for(j <- 1 until n){\n                if(i == 0 && j == 0){\n    \
    \                left += grid(i)(j)\n                } else if (grid(i)(j) >=\
    \ capacity){\n                    left += capacity\n                } else {\n\
    \                    left += grid(i)(j)\n                }\n            }\n  \
    \          if(left > max){\n                max = left\n            }\n      \
    \  }\n        return max\n    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpu8cbt5wc.scala:33:25 ------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m                    left += grid(i)(j)\n\e[31m\e[31m\
    \   |\e[0m                    ^^^^^^^\e[0m\n\e[31m   |\e[0m                  value\
    \ += is not a member of Int - did you mean Int.!=?\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmpu8cbt5wc.scala:35:25 ------------------------\e[0m\e[0m\n\
    \e[31m35 |\e[0m                    left += capacity\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                  value += is not\
    \ a member of Int - did you mean Int.!=?\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpu8cbt5wc.scala:37:25 ------------------------\e[0m\e[0m\n\e[31m37 |\e\
    [0m                    left += grid(i)(j)\n\e[31m\e[31m   |\e[0m             \
    \       ^^^^^^^\e[0m\n\e[31m   |\e[0m                  value += is not a member\
    \ of Int - did you mean Int.!=?\n3 errors found\n"
  stdout: ''
  timestamp: 1659979275
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val gridSize = grid.size\n        val wells = gridSize(0).toLong\
    \ + gridSize(1).toLong\n        val buckets = wells * capacity / 10\n\n      \
    \  def fillRow(row: List[Long], bucket : Long, fill : Long): Unit = {\n      \
    \      row match {\n                case Nil => ()\n                case x ::\
    \ xs =>\n                    val y = x.toLong\n                    fillRow(xs,\
    \ bucket - y, fill + y)\n            }\n        }\n\n        val empty = mutable.Queue[Long]()\n\
    \        val fill = mutable.Queue[Long]()\n\n        val result = mutable.ListBuffer.empty[Long]\n\
    \n        // put wells into the queue\n        empty.enqueue(wells)\n        fill.enqueue(wells)\n\
    \n        while !empty.isEmpty\n            if (!fill.isEmpty) {\n           \
    \     val nextWells = empty.dequeue()\n                val nextBuckets = fill.dequeue()\n\
    \n                fillRow(row, nextBuckets, nextWells)\n\n                result.addAll(fill.toList)\n\
    \            }\n\n            // put empty wells into the queue\n            empty.enqueue(nextWells)\n\
    \            fill.enqueue(nextBuckets)\n\n        scala.math.min(result.length)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpv64ieaok.scala:49:12 ---------------------------\e\
    [0m\e[0m\n\e[31m49 |\e[0m            \e[33mif\e[0m (!fill.isEmpty) {\n\e[31m\e\
    [31m   |\e[0m            ^^\e[0m\n\e[31m   |\e[0m            'do' expected, but\
    \ 'if' found\n\e[31m\e[31m-- [E050] Type Error: /tmp/tmpv64ieaok.scala:27:20 -----------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mwells\e[0m = gridSize(\e\
    [31m0\e[0m).toLong + gridSize(\e[31m1\e[0m).toLong\n\e[31m\e[31m   |\e[0m    \
    \                ^^^^^^^^\e[0m\n\e[31m   |\e[0m                    \e[33mvalue\e\
    [0m \e[35mgridSize\e[0m does not take parameters\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpv64ieaok.scala:39:20 ------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m \e[36mempty\e[0m = mutable.Queue[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpv64ieaok.scala:40:19 ------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m        \e[33mval\e[0m \e[36mfill\e[0m = mutable.Queue[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpv64ieaok.scala:42:21 ------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[33m\e[33m--\
    \ Warning: /tmp/tmpv64ieaok.scala:60:12 ---------------------------------------\e\
    [0m\e[0m\n\e[33m60 |\e[0m            fill.enqueue(nextBuckets)\n\e[33m\e[33m \
    \  |\e[0m            ^\e[0m\n\e[33m   |\e[0m   Incompatible combinations of tabs\
    \ and sp"
  stdout: ''
  timestamp: 1659979270
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = grid (1) // get a column of buckets\n    \
    \    val totalWells = grid.length // get a row of buckets\n        val maxCapacity\
    \ = buckets.lastOption.get (0) + capacity // get the maximum capacity from the\
    \ last column\n        val numFilled = mutable.ListBuffer[Long]() // initialize\
    \ an ListBuffer to collect the number of fills\n\n        // iterate the rows\
    \ of the grid\n        for (i <- 1 to totalWells) {\n            val currentCapacity\
    \ = buckets(i)\n            // if the current bucket is full, add an item to the\
    \ ListBuffer to be returned\n            if (currentCapacity >= maxCapacity) {\n\
    \                numFilled += currentCapacity - maxCapacity\n                maxCapacity\
    \ = buckets(i)\n            }\n            // otherwise, add the current row to\
    \ the ListBuffer and fill the bucket \n            else {\n                numFilled\
    \ += 1\n                maxCapacity -= currentCapacity\n            }\n      \
    \  }\n\n        // return the sum of all items in the ListBuffer\n        numFilled.sum\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E050] Type Error: /tmp/tmpa3imp51n.scala:28:45 -----------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mmaxCapacity\e[0m = buckets.lastOption.get\
    \ (\e[31m0\e[0m) + capacity \e[34m// get the maximum capacity from the last column\e\
    [0m\n\e[31m\e[31m   |\e[0m                          ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                     \e[33mmethod\e[0m \e[35mget\e[0m in \e[33mclass\e\
    [0m \e[35mOption\e[0m does not take parameters\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpa3imp51n.scala:29:24 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mnumFilled\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]() \e[34m// initialize an ListBuffer to collect the number of fills\e\
    [0m\n\e[31m\e[31m   |\e[0m                        ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                        Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E052] Type Error: /tmp/tmpa3imp51n.scala:37:28 -----------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m                maxCapacity = buckets(i)\n\e[31m\e[31m\
    \   |\e[0m                ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \           Reassignment to val maxCapacity\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659979270
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        require(grid.length == 1 || grid.length == 2 || grid.length\
    \ == grid.head.length, \"invalid grid length\")\n        require(grid\n      \
    \      .head\n            .length == 1\n            && grid\n            .head\n\
    \            .head\n            .toLong == 1\n            && grid\n          \
    \  .head\n            .last\n            .toLong == 1\n            && grid.tail\n\
    \            .head\n            .toLong == 1\n            && grid\n          \
    \  .tail\n            .last\n            .toLong == 1, \"invalid grid data\")\n\
    \        require(capacity <= 10, \"invalid capacity\")\n        val size = grid.head\n\
    \        val ret = if (grid\n            .head\n            .toLong == 1\n   \
    \         && grid\n            .last\n            .toLong == 1\n            &&\
    \ grid\n            .tail\n            .toLong == 1\n            && grid\n   \
    \         .tail\n            .last\n            .toLong == 1)\n            0\n\
    \        else\n            grid\n            .head\n            .toLong == 1\n\
    \            && grid\n            .last\n            .toLong == 1\n          \
    \  && grid\n            .tail\n            .toLong == 1\n            && grid\n\
    \            .tail\n            .last\n            .toLong == 1)\n           \
    \ 0\n        for (i <- 0 until size) {\n            val row = grid\n         \
    \       (i + 1)\n                .toLong == 1\n                && grid\n     \
    \           (i + 1)\n                .last\n                .toLong == 1\n   \
    \             && grid\n                (i + 1)\n                .tail\n      \
    \          .toLong == 1\n                && grid\n                (i + 1)\n  \
    \              .tail\n                .last\n                .toLong == 1\n  \
    \          val ret = ret + (if (i > 0) {\n                val nextRow = grid\n\
    \                    (i + 1)\n                    .toLong == 1\n             \
    \       && grid\n                    (i + 1)\n                    .last\n    \
    \                .toLong == 1\n                    && grid\n                 \
    \   (i + 1)\n                    .tail\n                    .toLong == 1\n   \
    \                 && grid\n                    (i + 1)\n                    .tail\n\
    \                    .last\n                    .toLong == 1\n               \
    \ nextRow && nextRow.head.toLong == row.head.toLong && nextRow.tail.toLong ==\
    \ row.tail.toLong\n                else false)\n            } else false)\n  \
    \      }\n        ret\n    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpvew7kfe0.scala:74:24 ---------------------------\e\
    [0m\e[0m\n\e[31m74 |\e[0m            .toLong == \e[31m1\e[0m)\n\e[31m\e[31m  \
    \ |\e[0m                        ^\e[0m\n\e[31m   |\e[0m                      \
    \  '}' expected, but ')' found\n\e[31m\e[31m-- Error: /tmp/tmpvew7kfe0.scala:111:16\
    \ ----------------------------------------\e[0m\e[0m\n\e[31m111 |\e[0m       \
    \         \e[33melse\e[0m \e[31mfalse\e[0m)\n\e[31m\e[31m    |\e[0m          \
    \      ^^^^\e[0m\n\e[31m    |\e[0m                end of statement expected but\
    \ 'else' found\n\e[31m\e[31m-- Error: /tmp/tmpvew7kfe0.scala:112:14 ----------------------------------------\e\
    [0m\e[0m\n\e[31m112 |\e[0m            } \e[33melse\e[0m \e[31mfalse\e[0m)\n\e\
    [31m\e[31m    |\e[0m              ^^^^\e[0m\n\e[31m    |\e[0m              end\
    \ of statement expected but 'else' found\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpvew7kfe0.scala:40:13 ------------------------\e[0m\e[0m\n\e[31m38 |\e\
    [0m            && grid.tail\n\e[31m39 |\e[0m            .head\n\e[31m40 |\e[0m\
    \            .toLong == \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m               ^\e\
    [0m\n\e[31m   |\e[0mvalue toLong is not a member of List[Long], but could be made\
    \ available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the\
    \ following imports might make progress towards fixing the problem:\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpvew7kfe0.scala:44:13 ------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m            && grid\n\e[31m42 |\e[0m            .tail\n\
    \e[31m43 |\e[0m            .last\n\e[31m44 |\e[0m            .toLong == \e[31m1\e\
    [0m, \e[31m\"invalid grid data\"\e[0m)\n\e[31m\e[31m   |\e[0m               ^\e\
    [0m\n\e[31m   |\e[0mvalue toLong is not a member of List[Long], but could be made\
    \ available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the\
    \ following imports might make progress towards fixing the problem:\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m  imp"
  stdout: ''
  timestamp: 1659979276
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        var numWells : Long = 0\n        var fillNum = 0\n\n   \
    \     for(x<-grid) {\n            for(y<-x) {\n                if(y(1) > capacity)\
    \ fillNum += 1\n            }\n            numWells += x.length\n        }\n\n\
    \        if(fillNum > 0) {\n            (fillNum - 1) * capacity\n        } else\
    \ {\n            0\n        }\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 1l.toLong,\
    \ 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong, 0l.toLong), List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (1l)) == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E050] Type Error: /tmp/tmpve8ypb8u.scala:31:19 -----------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m                \e[33mif\e[0m(y(\e[31m1\e[0m) > capacity)\
    \ fillNum += \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m                   ^\e[0m\n\e\
    [31m   |\e[0m                   \e[33mparameter\e[0m \e[35my\e[0m does not take\
    \ parameters\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979271
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        var count = 0\n        val maxSize = grid.foldLeft(0l)((max,\
    \ row) => math.max(max, row.size))\n        var row = 0\n        while (row <\
    \ grid.length) {\n            var column = 0\n            while (column < grid[row].length)\
    \ {\n                var size = 0\n                while ( grid[row][column] !=\
    \ 0l) {\n                    size += 1\n                    column += 1\n    \
    \                if (size > maxSize || size < capacity * row) {\n            \
    \            count += 1\n                        size = 0\n                  \
    \  }\n                }\n                column += 1\n                row += 1\n\
    \            }\n            row += 1\n        }\n        count * maxSize / grid.size\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpe2w59gm6.scala:31:33 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m            \e[33mwhile\e[0m (column < grid[\e[35mrow\e\
    [0m].length) {\n\e[31m\e[31m   |\e[0m                                 ^^^\e[0m\n\
    \e[31m   |\e[0m                                 Not found: type row\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpe2w59gm6.scala:33:34 ------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m                \e[33mwhile\e[0m ( grid[\e[35mrow\e[0m][\e\
    [35mcolumn\e[0m] != \e[31m0l\e[0m) {\n\e[31m\e[31m   |\e[0m                  \
    \                ^^^^^^\e[0m\n\e[31m   |\e[0m                                \
    \  Not found: type column\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpe2w59gm6.scala:33:29 ------------------------\e[0m\e[0m\n\e[31m33 |\e\
    [0m                \e[33mwhile\e[0m ( grid[\e[35mrow\e[0m][\e[35mcolumn\e[0m]\
    \ != \e[31m0l\e[0m) {\n\e[31m\e[31m   |\e[0m                             ^^^\e\
    [0m\n\e[31m   |\e[0m                             Not found: type row\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1659979272
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val m = grid.length\n        val n = grid(0).length\n  \
    \      def maxFillHelper(i : Int, j : Int) : Long = {\n            if(i == m &&\
    \ j == n) return 1\n            if(i == m || j == n) return 0\n            val\
    \ ret = if (grids(i-1, j) == 1) maxFillHelper(i-1, j-1) else maxFillHelper(i,\
    \ j-1)\n            val ret = if (grids(i, j-1) == 1) maxFillHelper(i-1, j) else\
    \ maxFillHelper(i, j)\n            val ret = if (grids(i-1, j-1) == 1) maxFillHelper(i-1,\
    \ j) else maxFillHelper(i, j)\n            val ret = if (grids(i-1, j) == 1) maxFillHelper(i,\
    \ j-1) else maxFillHelper(i, j)\n            val ret = if (grids(i, j+1) == 1)\
    \ maxFillHelper(i, j) else maxFillHelper(i, j)\n            val ret = if (grids(i+1,\
    \ j+1) == 1) maxFillHelper(i+1, j+1) else maxFillHelper(i+1, j+1)\n          \
    \  val ret = if (grids(i-1, j+1) == 1) maxFillHelper(i, j+1) else maxFillHelper(i,\
    \ j+1)\n            val ret = if (grids(i+1, j) == 1) maxFillHelper(i+1, j) else\
    \ maxFillHelper(i+1, j)\n            val ret = if (grids(i+1, j+1) == 1) maxFillHelper(i+1,\
    \ j+1) else maxFillHelper(i+1, j+1)\n            return ret * capacity / grids(i,\
    \ j)*2\n        }\n        maxFillHelper(0, 0)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 1l.toLong,\
    \ 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong, 0l.toLong), List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (1l)) == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp_ir_594v.scala:32:16 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m            \e[33mval\e[0m \e[36mret\e[0m = \e[33mif\e\
    [0m (grids(i, j-\e[31m1\e[0m) == \e[31m1\e[0m) maxFillHelper(i-\e[31m1\e[0m, j)\
    \ \e[33melse\e[0m maxFillHelper(i, j)\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mret is already defined as \e[33mvalue\e[0m \e[35mret\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp_ir_594v.scala:33:16 ---------------------------\e[0m\e[0m\n\e[31m33\
    \ |\e[0m            \e[33mval\e[0m \e[36mret\e[0m = \e[33mif\e[0m (grids(i-\e\
    [31m1\e[0m, j-\e[31m1\e[0m) == \e[31m1\e[0m) maxFillHelper(i-\e[31m1\e[0m, j)\
    \ \e[33melse\e[0m maxFillHelper(i, j)\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mret is already defined as \e[33mvalue\e[0m \e[35mret\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp_ir_594v.scala:34:16 ---------------------------\e[0m\e[0m\n\e[31m34\
    \ |\e[0m            \e[33mval\e[0m \e[36mret\e[0m = \e[33mif\e[0m (grids(i-\e\
    [31m1\e[0m, j) == \e[31m1\e[0m) maxFillHelper(i, j-\e[31m1\e[0m) \e[33melse\e\
    [0m maxFillHelper(i, j)\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mret is already defined as \e[33mvalue\e[0m \e[35mret\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp_ir_594v.scala:35:16 ---------------------------\e[0m\e[0m\n\e[31m35\
    \ |\e[0m            \e[33mval\e[0m \e[36mret\e[0m = \e[33mif\e[0m (grids(i, j+\e\
    [31m1\e[0m) == \e[31m1\e[0m) maxFillHelper(i, j) \e[33melse\e[0m maxFillHelper(i,\
    \ j)\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1659979277
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        var bucket : mutable.Map[Long, Int] = mutable.Map()\n  \
    \      for (i <- 0 until grid.length) {\n            val l = grids(i).head\n \
    \           bucket(l) += 1\n        }\n        var fill = 0\n        var changes\
    \ = 0\n        for (i <- 0 until grid.length) {\n            val l = grids(i).head\n\
    \            val c = bucket(l)\n            if (c > 0) {\n                fill\
    \ += 1\n            }\n            while (fill > 0) {\n                if (bucket(l)\
    \ <= capacity) {\n                    fill -= 1\n                } else {\n  \
    \                  bucket(l) -= 1\n                }\n                changes\
    \ += 1\n            }\n        }\n        changes\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 1l.toLong,\
    \ 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong, 0l.toLong), List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (1l)) == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpakgfjxmo.scala:26:21 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mvar\e[0m \e[36mbucket\e[0m : mutable.Map[\e\
    [35mLong\e[0m, \e[35mInt\e[0m] = mutable.Map()\n\e[31m\e[31m   |\e[0m        \
    \             ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpakgfjxmo.scala:26:46\
    \ ------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mvar\e[0m \e\
    [36mbucket\e[0m : mutable.Map[\e[35mLong\e[0m, \e[35mInt\e[0m] = mutable.Map()\n\
    \e[31m\e[31m   |\e[0m                                              ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                              Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpakgfjxmo.scala:28:20\
    \ ------------------------\e[0m\e[0m\n\e[31m28 |\e[0m            \e[33mval\e[0m\
    \ \e[36ml\e[0m = grids(i).head\n\e[31m\e[31m   |\e[0m                    ^^^^^\e\
    [0m\n\e[31m   |\e[0m                    Not found: grids\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpakgfjxmo.scala:34:20 ------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m            \e[33mval\e[0m \e[36ml\e[0m = grids(i).head\n\
    \e[31m\e[31m   |\e[0m                    ^^^^^\e[0m\n\e[31m   |\e[0m         \
    \           Not found: grids\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659979278
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val m = grid.map(_.size).max\n        val n = grid.map(_.head.length).max\n\
    \        val arr = new Array[Long](n)\n        arr(0) = capacity\n        var\
    \ maxFill = 0\n        for( i <- 1 until m ) {\n            for( j <- 1 until\
    \ n ) {\n                if( arr(j) < 0 ) arr(j) = -capacity + 1\n           \
    \     if( arr(j) > 0 ) {\n                    var total = 0\n                \
    \    var count = 0\n                    for( k <- 0 until arr(j) ) {\n       \
    \                 if( grid(i-k)(i-j) == 1 ) count += 1\n                     \
    \   total += arr(j) - k\n                    }\n                    if( total\
    \ > arr(j) ) {\n                        arr(j) = total\n                     \
    \   if( total > maxFill ) maxFill = total\n                    }\n           \
    \     }\n            }\n        }\n        maxFill\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpoi7s1zkw.scala:27:32 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = grid.map(_.head.length).max\n\
    \e[31m\e[31m   |\e[0m                         ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                         value length is not a member of Long\n\e[31m\e[31m--\
    \ Error: /tmp/tmpoi7s1zkw.scala:27:43 -----------------------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = grid.map(_.head.length).max\n\
    \e[31m\e[31m   |\e[0m                                           ^\e[0m\n\e[31m\
    \   |\e[0mambiguous given instances: both \e[33mobject\e[0m \e[35mChar\e[0m in\
    \ \e[33mobject\e[0m \e[35mOrdering\e[0m and \e[33mobject\e[0m \e[35mBigInt\e[0m\
    \ in \e[33mobject\e[0m \e[35mOrdering\e[0m match type Ordering[B] of parameter\
    \ ord of \e[33mmethod\e[0m \e[35mmax\e[0m in \e[33mtrait\e[0m \e[35mIterableOnceOps\e\
    [0m\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpoi7s1zkw.scala:37:41 --------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m                    \e[33mfor\e[0m( k <- \e[31m0\e[0m\
    \ until arr(j) ) {\n\e[31m\e[31m   |\e[0m                                    \
    \  ^^^^^^\e[0m\n\e[31m   |\e[0m                                      Found:  \
    \  Long\n\e[31m   |\e[0m                                      Required: Int\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpoi7s1zkw.scala:39:30\
    \ ------------------------\e[0m\e[0m\n\e[31m39 |\e[0m                        total\
    \ += arr(j) - k\n\e[31m\e[31m   |\e[0m                        ^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                  value += is not a member of Int - did you mean\
    \ Int.!=?\n4 errors found\n"
  stdout: ''
  timestamp: 1659979284
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        var ans = 1\n        val maxBucket = capacity.toLong / grid.head.length.toLong\n\
    \        var currentBucket = 0\n        \n        for (row <- 0 until grid.length)\
    \ {\n            var currentRow = grid[row]\n            val maxBuckets = maxBucket\
    \ / currentRow.size\n            val currentBuckets = currentBucket + maxBuckets\n\
    \            \n            for (c <- 0 until currentRow.size) {\n            \
    \    if (currentRow(c) == 0) {\n                    currentBucket += currentBuckets\n\
    \                    currentBuckets -= maxBuckets\n                }\n       \
    \         else {\n                    currentBucket += currentBuckets\n      \
    \              currentBuckets -= maxBuckets\n                }\n            }\n\
    \            \n            ans = Math.max(ans, currentBucket)\n        }\n   \
    \     ans\n    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpeytdj9fs.scala:31:34 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m            \e[33mvar\e[0m \e[36mcurrentRow\e[0m = grid[\e\
    [35mrow\e[0m]\n\e[31m\e[31m   |\e[0m                                  ^^^\e[0m\n\
    \e[31m   |\e[0m                                  Not found: type row\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659979278
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        def recurse(grid: List[List[Long]], capacity : Long, cur:\
    \ Long) : Long = {\n            // base case\n            if (grid.length == 1)\
    \ {\n                if (cur.sum < capacity) {\n                    cur.sum <-\
    \ capacity\n                }\n                return cur\n            }\n   \
    \         val index = cur.toInt\n            val r = grid(index)(index).toLong\n\
    \            if (r.toLong == 1) {\n                val next = recurse(grid, capacity\
    \ - r, cur + r).toLong\n                next.sum <- next.sum + capacity\n    \
    \            return next\n            } else if (r.toLong == 0) {\n          \
    \      val next = recurse(grid, capacity, cur + r).toLong\n                next.sum\
    \ <- next.sum + capacity\n                return next\n            }\n       \
    \ }\n        val result = recurse(grid, capacity, 0l)\n        if (result.sum\
    \ == capacity) {\n            result.sum\n        } else {\n            -1\n \
    \       }\n    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp5bol01vg.scala:30:28 -----------------------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m                    cur.sum <- capacity\n\e[31m\e[31m\
    \   |\e[0m                            ^^\e[0m\n\e[31m   |\e[0m               \
    \             end of statement expected but '<-' found\n\e[31m\e[31m-- Error:\
    \ /tmp/tmp5bol01vg.scala:38:25 -----------------------------------------\e[0m\e\
    [0m\n\e[31m38 |\e[0m                next.sum <- next.sum + capacity\n\e[31m\e\
    [31m   |\e[0m                         ^^\e[0m\n\e[31m   |\e[0m               \
    \          end of statement expected but '<-' found\n\e[31m\e[31m-- Error: /tmp/tmp5bol01vg.scala:42:25\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m42 |\e[0m       \
    \         next.sum <- next.sum + capacity\n\e[31m\e[31m   |\e[0m             \
    \            ^^\e[0m\n\e[31m   |\e[0m                         end of statement\
    \ expected but '<-' found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp5bol01vg.scala:29:24\
    \ ------------------------\e[0m\e[0m\n\e[31m29 |\e[0m                \e[33mif\e\
    [0m (cur.sum < capacity) {\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                    value sum is not a member of Long\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmp5bol01vg.scala:30:24 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m                    cur.sum <- capacity\n\e[31m\e[31m\
    \   |\e[0m                    ^^^^^^^\e[0m\n\e[31m   |\e[0m                  \
    \  value sum is not a member of Long\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp5bol01vg.scala:38:21\
    \ ------------------------\e[0m\e[0m\n\e[31m38 |\e[0m                next.sum\
    \ <- next.sum + capacity\n\e[31m\e[31m   |\e[0m                ^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                value sum is not a member of Long\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmp5bol01vg.scala:42:21 ------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m                next.sum <- next.sum + capacity\n\e[31m\e\
    [31m   |\e[0m                ^^^^^^^^\e[0m\n\e[31m   |\e[0m                value\
    \ sum is not a member of Long\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp5bol01vg.scala:47:19\
    \ ------------------------\e[0m"
  stdout: ''
  timestamp: 1659979285
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val rowsLength = grid.length\n        val colsLength = grid(0).length\n\
    \        if (rowsLength == colsLength) {\n            0\n        }\n        if\
    \ (rowsLength > colsLength) {\n            0\n        }\n        else {\n    \
    \        val maxBuckets = rowsLength * colsLength\n            val maxBucketsCapacity\
    \ = capacity\n            val rowToRemove = 0\n            val colToRemove = 0\n\
    \            val currentMaxBuckets = maxBuckets\n            val currentCapacity\
    \ = maxBucketsCapacity\n            val grid = grid.toList\n            val buckets\
    \ = mutable.Set[Long]().toList.iterator\n            var sum = 0\n           \
    \ while (currentMaxBuckets != 0) {\n                if (currentCapacity == 0)\
    \ {\n                    buckets = buckets.filter(_.toLong < 0)\n            \
    \    }\n                if (buckets.size == 0) {\n                    currentCapacity\
    \ += 1\n                }\n                else {\n                    val maxBucketsBefore\
    \ = buckets.filter(_.toLong > 0).toList.length\n                    if (currentCapacity\
    \ - maxBucketsBefore == 0) {\n                        currentCapacity += 1\n \
    \                   }\n                }\n                buckets = buckets.filter(_.toLong\
    \ <= 0).toList.iterator\n                sum += maxBuckets\n                currentMaxBuckets\
    \ -= 1\n            }\n            maxBuckets\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpz70g_70o.scala:41:23 ---------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m            \e[33mval\e[0m \e[36mgrid\e[0m = grid.toList\n\
    \e[31m\e[31m   |\e[0m                       ^\e[0m\n\e[31m   |\e[0m          \
    \             Recursive \e[33mvalue\e[0m \e[35mgrid\e[0m needs type\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpz70g_70o.scala:42:26 ------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m            \e[33mval\e[0m \e[36mbuckets\e[0m = mutable.Set[\e\
    [35mLong\e[0m]().toList.iterator\n\e[31m\e[31m   |\e[0m                      \
    \    ^^^^^^^\e[0m\n\e[31m   |\e[0m                          Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmpz70g_70o.scala:46:28 -----------------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m                    buckets = buckets.filter(_.toLong\
    \ < \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                    Reassignment to val buckets\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpz70g_70o.scala:49:36 ------------------------\e\
    [0m\e[0m\n\e[31m49 |\e[0m                    currentCapacity += \e[31m1\e[0m\n\
    \e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m     value += is not a member of Long - did you mean currentCapacity.!=?\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpz70g_70o.scala:54:40 ------------------------\e\
    [0m\e[0m\n\e[31m54 |\e[0m                        currentCapacity += \e[31m1\e\
    [0m\n\e[31m\e[31m   |\e[0m                        ^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m     value += is not a member of Long - did you mean currentCapacity.!=?\n\
    \e[31m\e[31m-- [E052] Type Error: /tmp/tmpz70g_70o.scala:57:24 -----------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m                buckets = buckets.filter(_.toLong <=\
    \ \e[31m0\e[0m).toList.iterator\n\e[31m\e[31m   |\e[0m            "
  stdout: ''
  timestamp: 1659979283
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val m = grid.length\n        val n = grid(0).length\n  \
    \      val bucket = mutable.ListBuffer[Long](capacity)\n        val result = mutable.ListBuffer[Long]()\n\
    \        var i : Int = 0\n        var j : Int = 0\n        var left : Int = 0\n\
    \        var right : Int = 0\n        while (i < m && j < n) {\n            if\
    \ (grid(i)(j).toLong == 1) {\n                bucket.clear()\n               \
    \ bucket.addAll(grid(i)(j - 1).toLong to grid(i)(j + n).toLong)\n            \
    \    for (k <- bucket) {\n                    left += k\n                }\n \
    \               for (k <- bucket.tail) {\n                    right += k\n   \
    \             }\n                result += left - right\n                i +=\
    \ 1\n                j += 1\n            } else {\n                i += 1\n  \
    \              j += 1\n            }\n        }\n        bucket.clear()\n    \
    \    bucket.addAll(grid(i)(j).toLong to grid(i)(j + n).toLong)\n        for (k\
    \ <- bucket) {\n            left += k\n        }\n        for (k <- bucket.tail)\
    \ {\n            right += k\n        }\n        result -= left + right\n     \
    \   result match {\n            case x if x <= 0 => 0\n            case _ => result.sum\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp2cnq3yly.scala:28:21 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mbucket\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m](capacity)\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmp2cnq3yly.scala:29:21 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659979281
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        def maxFillInternal(grid : List[List[Long]], capacity :\
    \ Long) : List[List[Long]] = {\n            def fillBucket(bucket : Long, grid\
    \ : List[List[Long]]): List[List[Long]] = bucket match {\n                case\
    \ 0 => grid // empty bucket\n                case 1 => grid.drop(1) // fill bucket\
    \ with one unit of water\n                case _ => fillBucket(bucket.drop(1),\
    \ grid.drop(1))\n            }\n            grid.map(_.toList).reduce(fillBucket(_,\
    \ capacity))\n        }\n        val answer = maxFillInternal(grid, capacity)\n\
    \        answer.foldLeft(0l){ (sum, current) => sum + current.map(_.toLong).sum\
    \ }\n    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpv7jb9k33.scala:30:44 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m                \e[33mcase\e[0m _ => fillBucket(bucket.drop(\e\
    [31m1\e[0m), grid.drop(\e[31m1\e[0m))\n\e[31m\e[31m   |\e[0m                 \
    \                    ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                       \
    \              value drop is not a member of Long\n\e[31m\e[31m-- [E086] Syntax\
    \ Error: /tmp/tmpv7jb9k33.scala:32:38 ---------------------------\e[0m\e[0m\n\e\
    [31m32 |\e[0m            grid.map(_.toList).reduce(fillBucket(_, capacity))\n\e\
    [31m\e[31m   |\e[0m                                      ^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                 Wrong number of parameters,\
    \ expected: 2\n2 errors found\n"
  stdout: ''
  timestamp: 1659979284
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val map = new mutable.HashMap[List[Long], Long]()\n    \
    \    val result = mutable.ListBuffer.empty[Long]\n        val bucket = mutable.ListBuffer.empty[Long]\n\
    \        grid.foreach(row => bucket.append(0l))\n        grid.foreach(row => map.put(row,\
    \ 0l))\n        grid.foreach(row => bucket.append(0l))\n        grid.foreach(row\
    \ => bucket.foreach(cell => map(cell) = bucket.sum))\n        map.foreach { case\
    \ (row, cell) => bucket.foreach(cell => if (bucket.sum == 0) bucket.push(cell\
    \ + capacity) else if (bucket.sum == cell) bucket.push(cell - capacity))}\n  \
    \      bucket.foreach(cell => if (bucket.sum == cell) bucket.push(cell - capacity))\n\
    \        var i = 1\n        while (i < bucket.sum) {\n            if (bucket.sum\
    \ - i < bucket.sum) bucket.take(bucket.sum - i).foreach(x => map(x.toLong) = bucket.sum)\n\
    \            else bucket.foreach(x => map(x.toLong) = bucket.sum - i)\n      \
    \      i += 1\n        }\n        result = bucket.sum\n        result\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp_nyy6qwx.scala:26:22 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mmap\e[0m = \e[33mnew\e[0m\
    \ mutable.HashMap[\e[35mList\e[0m[\e[35mLong\e[0m], \e[35mLong\e[0m]()\n\e[31m\e\
    [31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m   |\e[0m             \
    \         Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp_nyy6qwx.scala:27:21 ------------------------\e[0m\e[0m\n\e[31m27 |\e\
    [0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer.empty[\e[35mLong\e\
    [0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmp_nyy6qwx.scala:28:21 ------------------------\e[0m\e\
    [0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mbucket\e[0m = mutable.ListBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E052] Type Error: /tmp/tmp_nyy6qwx.scala:41:15 -----------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m        result = bucket.sum\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Reassignment to val result\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659979281
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        var counter = mutable.Map[List[Long], Int]().withDefaultValue(0)\n\
    \        for(i <- 0 until grid.length) {\n            for(j <- 0 until grid[0].length)\n\
    \                if(grid[i][j] == 0) {\n                    val cur = counter.get(grid[i])\n\
    \                    if(cur != 0) counter(grid[i]) = cur + 1\n               \
    \ }\n        }\n        for(i <- 0 until grid.length) {\n            val cur =\
    \ counter(grid[i])\n            if(cur > 0) counter(grid[i]) = cur - 1\n     \
    \   }\n        if(counter.forall(_ > 0l)) {\n            val res = counter.maxBy(_._1)._1.toLong\n\
    \            if(res > capacity) -1\n            else res\n        } else 0l\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp08rs4_tt.scala:26:22 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mvar\e[0m \e[36mcounter\e[0m = mutable.Map[\e\
    [35mList\e[0m[\e[35mLong\e[0m], \e[35mInt\e[0m]().withDefaultValue(\e[31m0\e[0m)\n\
    \e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                 Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- Error:\
    \ /tmp/tmp08rs4_tt.scala:28:33 -----------------------------------------\e[0m\e\
    [0m\n\e[31m28 |\e[0m            \e[33mfor\e[0m(j <- \e[31m0\e[0m until grid[\e\
    [31m0\e[0m].length)\n\e[31m\e[31m   |\e[0m                             ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        \e[33mmethod\e[0m \e[35mapply\e[0m in \e[33mtrait\e\
    [0m \e[35mLinearSeqOps\e[0m does not take type parameters\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmp08rs4_tt.scala:29:27 ------------------------\e[0m\e\
    [0m\n\e[31m29 |\e[0m                \e[33mif\e[0m(grid[\e[35mi\e[0m][\e[35mj\e\
    [0m] == \e[31m0\e[0m) {\n\e[31m\e[31m   |\e[0m                           ^\e[0m\n\
    \e[31m   |\e[0m                           Not found: type j\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmp08rs4_tt.scala:29:24 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m                \e[33mif\e[0m(grid[\e[35mi\e[0m][\e[35mj\e\
    [0m] == \e[31m0\e[0m) {\n\e[31m\e[31m   |\e[0m                        ^\e[0m\n\
    \e[31m   |\e[0m                        Not found: type i\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n4 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659979281
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val x = grid(0).length\n        val y = grid(0).zipWithIndex.filter(_._1\
    \ == 0).map(_._2).max\n        val maxx = grid(0).zipWithIndex.filter(_._1 ==\
    \ 1).map(_._2).max\n        val maxy = grid(0).zipWithIndex.filter(_._1 == 2).map(_._2).max\n\
    \        val xx = if (maxx == 0) x else maxx - x\n        val yy = if (maxy ==\
    \ 0) y else maxy - y\n        if (Math.min(xx, yy, yy) == xx) yy else xx - yy\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpmn14nwqt.scala:32:17 -----------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mif\e[0m (Math.min(xx, yy, yy) == xx) yy\
    \ \e[33melse\e[0m xx - yy\n\e[31m\e[31m   |\e[0m            ^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e\
    [0m in \e[33mobject\e[0m \e[35mMath\e[0m with types\n\e[31m   |\e[0m (x$0: Double,\
    \ x$1: Double): Double\n\e[31m   |\e[0m (x$0: Float, x$1: Float): Float\n\e[31m\
    \   |\e[0m (x$0: Long, x$1: Long): Long\n\e[31m   |\e[0m (x$0: Int, x$1: Int):\
    \ Int\n\e[31m   |\e[0mmatch arguments ((xx : Int), (yy : Int), (yy : Int))\n1\
    \ error found\n"
  stdout: ''
  timestamp: 1659979283
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        var sum = 0\n        var minCapacity = 0\n        for (row\
    \ <- grid) {\n            val rowCapacities = row.map(_.toLong)\n            minCapacity\
    \ = math.min(minCapacity, rowCapacities.max)\n            sum += rowCapacities.sum\n\
    \        }\n        if (sum > capacity) sum else sum - minCapacity\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmph6gkwl8h.scala:30:48\
    \ --------------------\e[0m\e[0m\n\e[31m30 |\e[0m            minCapacity = math.min(minCapacity,\
    \ rowCapacities.max)\n\e[31m\e[31m   |\e[0m                                  \
    \              ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                       \
    \                         Found:    Long\n\e[31m   |\e[0m                    \
    \                            Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmph6gkwl8h.scala:31:16 ------------------------\e[0m\e\
    [0m\n\e[31m31 |\e[0m            sum += rowCapacities.sum\n\e[31m\e[31m   |\e[0m\
    \            ^^^^^^\e[0m\n\e[31m   |\e[0m            value += is not a member\
    \ of Int - did you mean Int.!=?\n2 errors found\n"
  stdout: ''
  timestamp: 1659979286
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        var max = 0\n        var fill = 0\n        var index = 0\n\
    \        for (row <- grid){\n            max = Math.max(max, row.length)\n   \
    \     }\n        for (row <- grid){\n            fill = row.foldLeft(0l) { (max,\
    \ cur) => {\n                val x = if (cur == 0) capacity else max - 1\n   \
    \             val y = if (cur == 0) capacity else cur - 1\n                if\
    \ (x <= y) return cur\n                if (cur == 0) return max\n            \
    \    return max\n            }}\n            index += 1\n        }\n        max\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp8jeym4vs.scala:33:36\
    \ --------------------\e[0m\e[0m\n\e[31m33 |\e[0m            fill = row.foldLeft(\e\
    [31m0l\e[0m) { (\e[36mmax\e[0m, \e[36mcur\e[0m) => {\n\e[31m\e[31m   |\e[0m  \
    \                 ^\e[0m\n\e[31m   |\e[0m                   Found:    Long\n\e\
    [31m   |\e[0m                   Required: Int\n\e[31m34 |\e[0m               \
    \ \e[33mval\e[0m \e[36mx\e[0m = \e[33mif\e[0m (cur == \e[31m0\e[0m) capacity \e\
    [33melse\e[0m max - \e[31m1\e[0m\n\e[31m35 |\e[0m                \e[33mval\e[0m\
    \ \e[36my\e[0m = \e[33mif\e[0m (cur == \e[31m0\e[0m) capacity \e[33melse\e[0m\
    \ cur - \e[31m1\e[0m\n\e[31m36 |\e[0m                \e[33mif\e[0m (x <= y) \e\
    [33mreturn\e[0m cur\n\e[31m37 |\e[0m                \e[33mif\e[0m (cur == \e[31m0\e\
    [0m) \e[33mreturn\e[0m max\n\e[31m38 |\e[0m                \e[33mreturn\e[0m max\n\
    \e[31m39 |\e[0m            }}\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979286
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        def dfs(grid : List[List[Long]], currentRow : Int, currentCol\
    \ : Int, currentWell : Int) : Unit = {\n            val currentBucket = grid[currentRow](currentCol)\n\
    \            if(currentWell == 0 && currentBucket < capacity)\n              \
    \  currentBucket += 1\n            else if(currentWell == 1 && currentBucket >\
    \ 0)\n                currentBucket -= 1\n            else if(currentWell == 0\
    \ && currentBucket == 0)\n                dfs(grid, currentRow + 1, currentCol,\
    \ currentWell + 1)\n            else if(currentWell == 1 && currentBucket == 1)\n\
    \                dfs(grid, currentRow + 1, currentCol, currentWell - 1)\n    \
    \    }\n        val maxRow = 0\n        val maxCol = 0\n        val maxWell =\
    \ 0\n        for(row <- grid.indices) {\n            for(col <- grid(0).indices)\
    \ {\n                val currentBucket = grid[row](col)\n                if(currentWell\
    \ == 0 && currentBucket < capacity)\n                    currentBucket += 1\n\
    \                else if(currentWell == 1 && currentBucket > 0)\n            \
    \        currentBucket -= 1\n                else if(currentWell == 0 && currentBucket\
    \ == 0)\n                    dfs(grid, row, col, 1)\n                else if(currentWell\
    \ == 1 && currentBucket == 1)\n                    dfs(grid, row, col, -1)\n \
    \               if(currentWell > maxWell)\n                    maxWell = currentWell\n\
    \                if(currentCol > maxCol)\n                    maxCol = currentCol\n\
    \                if(row > maxRow)\n                    maxRow = row\n        \
    \    }\n        }\n        (maxRow - maxCol) + maxWell\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpk4yzp5h1.scala:27:37 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m            \e[33mval\e[0m \e[36mcurrentBucket\e[0m =\
    \ grid[\e[35mcurrentRow\e[0m](currentCol)\n\e[31m\e[31m   |\e[0m             \
    \                        ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                    \
    \                 Not found: type currentRow\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpk4yzp5h1.scala:42:41 ------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m                \e[33mval\e[0m \e[36mcurrentBucket\e\
    [0m = grid[\e[35mrow\e[0m](col)\n\e[31m\e[31m   |\e[0m                       \
    \                  ^^^\e[0m\n\e[31m   |\e[0m                                 \
    \        Not found: type row\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpk4yzp5h1.scala:43:19 ------------------------\e[0m\e[0m\n\e[31m43 |\e\
    [0m                \e[33mif\e[0m(currentWell == \e[31m0\e[0m && currentBucket\
    \ < capacity)\n\e[31m\e[31m   |\e[0m                   ^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: currentWell\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpk4yzp5h1.scala:45:24 ------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m                \e[33melse\e[0m \e[33mif\e[0m(currentWell\
    \ == \e[31m1\e[0m && currentBucket > \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m    \
    \                    ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                       \
    \ Not found: currentWell\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpk4yzp5h1.scala:47:24 ------------------------\e[0m\e[0m\n\e[31m47 |\e\
    [0m                \e[33melse\e[0m \e[33mif\e[0m(currentWell == \e[31m0\e[0m &&\
    \ currentBucket == \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m                      \
    \  ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                        Not found: currentWell\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available"
  stdout: ''
  timestamp: 1659979283
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        require(grid.length == grid[0].shape.length && grid[0].length\
    \ == grid[1].length,\n            \"grid: ${grid.length}, grid[0].length: ${grid[0].shape.length},\
    \ grid[1].length: ${grid[1].length}\")\n        val newGrid = grid.map(_.map(_.toLong))\n\
    \        val rowSize = grid[0].shape.length\n        val colSize = grid[0].length\n\
    \        var currentMax = capacity\n        var maxCount = 0\n        for ((r,\
    \ c) <- grid.zipWithIndex) {\n            val rIdx = r / rowSize\n           \
    \ val cIdx = c / colSize\n            val rValue = newGrid((rIdx))\n         \
    \   val cValue = newGrid((cIdx))\n            currentMax = rValue.map(cValue).max\n\
    \            maxCount = if (currentMax > capacity) maxCount + 1 else maxCount\n\
    \        }\n        require(maxCount <= rowSize * colSize, \"maxCount: ${maxCount}\"\
    )\n        currentMax\n    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpvjvmaseu.scala:26:35 -----------------------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        require(grid.length == grid[\e[31m0\e[0m].shape.length\
    \ && grid[\e[31m0\e[0m].length == grid[\e[31m1\e[0m].length,\n\e[31m\e[31m   |\e\
    [0m                               ^^^^^^^\e[0m\n\e[31m   |\e[0m        \e[33mmethod\e\
    [0m \e[35mapply\e[0m in \e[33mtrait\e[0m \e[35mLinearSeqOps\e[0m does not take\
    \ type parameters\n\e[31m\e[31m-- Error: /tmp/tmpvjvmaseu.scala:29:26 -----------------------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mrowSize\e[0m = grid[\e[31m0\e\
    [0m].shape.length\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m        \e[33mmethod\e[0m \e[35mapply\e[0m in \e[33mtrait\e[0m \e\
    [35mLinearSeqOps\e[0m does not take type parameters\n\e[31m\e[31m-- Error: /tmp/tmpvjvmaseu.scala:30:26\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m30 |\e[0m       \
    \ \e[33mval\e[0m \e[36mcolSize\e[0m = grid[\e[31m0\e[0m].length\n\e[31m\e[31m\
    \   |\e[0m                      ^^^^^^^\e[0m\n\e[31m   |\e[0m        \e[33mmethod\e\
    [0m \e[35mapply\e[0m in \e[33mtrait\e[0m \e[35mLinearSeqOps\e[0m does not take\
    \ type parameters\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpvjvmaseu.scala:34:25\
    \ ------------------------\e[0m\e[0m\n\e[31m34 |\e[0m            \e[33mval\e[0m\
    \ \e[36mrIdx\e[0m = r / rowSize\n\e[31m\e[31m   |\e[0m                       ^^^\e\
    [0m\n\e[31m   |\e[0mvalue / is not a member of List[Long], but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e\
    [0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpvjvmaseu.scala:38:36 --------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m            currentMax = rValue.map(cValue).max\n\e[31m\e\
    [31m   |\e[0m                                    ^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                                    Found:    (cValue : List[Long])\n\e[31m \
    \  |\e[0m                                "
  stdout: ''
  timestamp: 1659979289
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        require(grid.length == grid(0).length)\n        require(grid(0).length\
    \ == 1)\n        val max = 0\n        val index = 0\n        for (row <- 0 until\
    \ grid.length) {\n            if (grid[row].isEmpty) {\n                for (col\
    \ <- 0 until grid[row].length) {\n                    val value = grid((row *\
    \ grid[0].length) + col)\n                    val oldCount = max\n           \
    \         if (value == 0) {\n                        val newCount = Math.max(0,\
    \ maxCount.get(index) + 1)\n                        if (newCount > oldCount) {\n\
    \                            max = newCount\n                        }\n     \
    \               }\n                    else max = Math.max(max, newCount)\n  \
    \                  maxCount.update(index, max)\n                    index += 1\n\
    \                }\n            }\n        }\n        return max\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpwryso641.scala:31:21 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m            \e[33mif\e[0m (grid[\e[35mrow\e[0m].isEmpty)\
    \ {\n\e[31m\e[31m   |\e[0m                     ^^^\e[0m\n\e[31m   |\e[0m     \
    \                Not found: type row\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpwryso641.scala:32:41 ------------------------\e[0m\e\
    [0m\n\e[31m32 |\e[0m                \e[33mfor\e[0m (col <- \e[31m0\e[0m until\
    \ grid[\e[35mrow\e[0m].length) {\n\e[31m\e[31m   |\e[0m                      \
    \                   ^^^\e[0m\n\e[31m   |\e[0m                                \
    \         Not found: type row\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- Error: /tmp/tmpwryso641.scala:33:48\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m33 |\e[0m       \
    \             \e[33mval\e[0m \e[36mvalue\e[0m = grid((row * grid[\e[31m0\e[0m].length)\
    \ + col)\n\e[31m\e[31m   |\e[0m                                            ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        \e[33mmethod\e[0m \e[35mapply\e[0m in \e[33mtrait\e\
    [0m \e[35mLinearSeqOps\e[0m does not take type parameters\n\e[31m\e[31m-- Error:\
    \ /tmp/tmpwryso641.scala:35:24 -----------------------------------------\e[0m\e\
    [0m\n\e[31m35 |\e[0m                    \e[33mif\e[0m (value == \e[31m0\e[0m)\
    \ {\n\e[31m\e[31m   |\e[0m                        ^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m     Values of types List[Long] and Int cannot be compared with == or !=\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpwryso641.scala:36:51 ------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m                        \e[33mval\e[0m \e[36mnewCount\e\
    [0m = Math.max(\e[31m0\e[0m, maxCount.get(index) + \e[31m1\e[0m)\n\e[31m\e[31m\
    \   |\e[0m                                                   ^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                                                   Not found: maxCount\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmpwryso641.scala:38:32 ----------------"
  stdout: ''
  timestamp: 1659979288
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = mutable.PriorityQueue[mutable.PriorityQueue[Long]](\n\
    \            new mutable.PriorityQueue[Long](capacity, new scala.math.Ordering[Long]\
    \ {\n                override def compare(x: Long, y: Long): Int = x - y\n   \
    \         })\n        )\n        val bucketIndexes = mutable.PriorityQueue[Long](-1L,\
    \ new scala.math.Ordering[Long] {\n            override def compare(x: Long, y:\
    \ Long): Int = x - y\n        })\n        val bucketCapacity = mutable.PriorityQueue[Long](capacity,\
    \ new scala.math.Ordering[Long] {\n            override def compare(x: Long, y:\
    \ Long): Int = x - y\n        })\n        val bucketIndexesList = mutable.PriorityQueue[List[Long]](List(-1L),\
    \ new scala.math.Ordering[Long] {\n            override def compare(x: Long, y:\
    \ Long): Int = x - y\n        })\n        for (row <- grid) {\n            val\
    \ index = row.zipWithIndex.map(_._1).max\n            buckets.add(new mutable.PriorityQueue[Long](row.length,\
    \ new scala.math.Ordering[Long] {\n                override def compare(x: Long,\
    \ y: Long): Int = x - y\n            }))\n            bucketIndexes.enqueue(index)\n\
    \            bucketCapacity.enqueue(row.length)\n        }\n        val bucketCount\
    \ = 0\n        val bucketCapacityCount = 0\n        while (!buckets.isEmpty) {\n\
    \            bucketCount += 1\n            val index = bucketIndexes.dequeue()\n\
    \            bucketCapacityCount += bucketCapacity.dequeue()\n            val\
    \ bucket = buckets.dequeue()\n            var bucketIndex = -1\n            var\
    \ bucketCapacity = -1\n            while (bucket != null) {\n                bucketIndex\
    \ = index\n                bucketCapacity = bucketCapacityCount\n            \
    \    bucket = bucket.dequeue()\n            }\n            val capacityToAdd =\
    \ bucketCapacity - bucketCapacityCount\n            val capacityToRemove = bucketCapacityCount\
    \ - bucketCapacity\n            buckets.enqueue(\n                new mutable.PriorityQueue[Long](\n\
    \                    bucket.enqueue(\n                        bucket.dequeue()\
    \ + capacityToAdd\n                    )\n                )\n            )\n \
    \           bucketIndexes.enqueue(bucketIndex)\n            bucketCapacityCount\
    \ += capacityToRemove\n        }\n        bucketCount\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpn73tt7si.scala:26:44 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mbuckets\e[0m = mutable.PriorityQueue[mutable.PriorityQueue[\e\
    [35mLong\e[0m]](\n\e[31m\e[31m   |\e[0m                                      \
    \      ^^^^^^^\e[0m\n\e[31m   |\e[0m                                         \
    \   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpn73tt7si.scala:26:22\
    \ ------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e\
    [36mbuckets\e[0m = mutable.PriorityQueue[mutable.PriorityQueue[\e[35mLong\e[0m]](\n\
    \e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                 Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpn73tt7si.scala:27:16 ------------------------\e[0m\e\
    [0m\n\e[31m27 |\e[0m            \e[33mnew\e[0m mutable.PriorityQueue[\e[35mLong\e\
    [0m](capacity, \e[33mnew\e[0m scala.math.Ordering[\e[35mLong\e[0m] {\n\e[31m\e\
    [31m   |\e[0m                ^^^^^^^\e[0m\n\e[31m   |\e[0m                Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpn73tt7si.scala:31:28\
    \ ------------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e\
    [36mbucketIndexes\e[0m = mutable.PriorityQueue[\e[35mLong\e[0m](-\e[31m1L\e[0m,\
    \ \e[33mnew\e[0m scala.math.Ordering[\e[35mLong\e[0m] {\n\e[31m\e[31m   |\e[0m\
    \                            ^^^^^^^\e[0m\n\e[31m   |\e[0m                   \
    \         Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpn73tt7si.scala:32:58 --------------------\e[0m\e[0m\n\e[31m32\
    \ |\e[0m            \e[33moverride\e[0m \e[33mdef\e[0m compare(x: Long, y: Long):\
    \ Int = x - y\n\e[31m\e[31m   |\e[0m                                         \
    \                 ^^^^^\e[0m\n\e[31m   |\e[0m                "
  stdout: ''
  timestamp: 1659979290
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val map = collection.mutable.Map[Long, List[Long]]()\n \
    \       for (row <- grid)\n        {\n            val key = row(1).asInstanceOf[Long]\n\
    \            val list = map.get(key).orElse(List()) \n            list :+= 0\n\
    \            map += key -> list\n        }\n        var i = 0\n        while (i\
    \ < grid.length)\n        {\n            val buckets = map.get(capacity).map(_.asInstanceOf[Long]).toArray\n\
    \            if (buckets.length > 0)\n            {\n                val index\
    \ = buckets.indexOf(0)\n                if (index > -1)\n                {\n \
    \                   map.get(capacity).remove(index)\n                    i +=\
    \ index\n                }\n                else\n                    i += 1\n\
    \            }\n            else\n                i += 1\n        }\n        i\
    \ + 1\n    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp6vmaj8gx.scala:30:47\
    \ --------------------\e[0m\e[0m\n\e[31m30 |\e[0m            \e[33mval\e[0m \e\
    [36mlist\e[0m = map.get(key).orElse(List()) \n\e[31m\e[31m   |\e[0m          \
    \                                 ^^^^^^\e[0m\n\e[31m   |\e[0m               \
    \                            Found:    List[Nothing]\n\e[31m   |\e[0m        \
    \                                   Required: Option[List[Long]]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp6vmaj8gx.scala:31:17 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m            list :+= \e[31m0\e[0m\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^^\e[0m\n\e[31m   |\e[0m            value :+= is not a member\
    \ of Option[List[Long]]\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp6vmaj8gx.scala:32:26\
    \ --------------------\e[0m\e[0m\n\e[31m32 |\e[0m            map += key -> list\n\
    \e[31m\e[31m   |\e[0m                          ^^^^\e[0m\n\e[31m   |\e[0m    \
    \                      Found:    \e[1m\e[31m(\e[0m\e[1m\e[31mlist\e[0m\e[1m\e\
    [31m \e[0m\e[1m\e[31m:\e[0m\e[1m\e[31m \e[0m\e[1m\e[31mOption\e[0m\e[1m\e[31m[\e\
    [0mList[Long\e[1m\e[31m]\e[0m]\e[1m\e[31m)\e[0m\n\e[31m   |\e[0m             \
    \             Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmp6vmaj8gx.scala:43:38 ------------------------\e[0m\e[0m\n\e[31m43 |\e\
    [0m                    map.get(capacity).remove(index)\n\e[31m\e[31m   |\e[0m\
    \                    ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \          value remove is not a member of Option[List[Long]]\n4 errors found\n"
  stdout: ''
  timestamp: 1659979290
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val n = grid.length\n        val m = grid(0).length\n  \
    \      val map = mutable.HashMap[(List[Long], List[Long]), Int]()\n        for\
    \ (i <- 0 until m) {\n            for (j <- 0 until n) {\n                if (grid(i)(j)\
    \ == 1) {\n                    val bucket = map.getOrElse((List(grid(i)(j).toLong,\
    \ grid(i)(j + 1).toLong, grid(i)(j + 2).toLong), capacity), capacity)\n      \
    \              map.put((List(grid(i)(j).toLong, grid(i)(j + 1).toLong, grid(i)(j\
    \ + 2).toLong), bucket)\n                }\n            }\n        }\n       \
    \ for (pair <- map.keys) {\n            map((pair._1, pair._2))\n        }\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpe2w0qptf.scala:34:16 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m                }\n\e[31m\e[31m   |\e[0m            \
    \    ^\e[0m\n\e[31m   |\e[0m                ')' expected, but '}' found\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpe2w0qptf.scala:28:18 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mmap\e[0m = mutable.HashMap[(\e\
    [35mList\e[0m[\e[35mLong\e[0m], \e[35mList\e[0m[\e[35mLong\e[0m]), \e[35mInt\e\
    [0m]()\n\e[31m\e[31m   |\e[0m                  ^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \                 Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659979285
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        require(grid.length == grid.head.size,\n               \"\
    grid.length must be the same as grid.head.size\")\n        require(grid\n    \
    \             .map(_.size)\n                 .sum == 1,\n               \"all\
    \ cells in each row must occupy the same well\")\n        require(grid\n     \
    \            .map(_.size)\n                 .sum == grid\n                 .map(_.size)\n\
    \                 .sum,\n               \"all cells in each column must occupy\
    \ the same well\")\n        require(capacity > 0, \"capacity must be positive\"\
    )\n        require(grid\n                 .map(_.length)\n                 .sum\
    \ == grid\n                 .map(_.length)\n                 .sum,\n         \
    \      \"all cells in each well must occupy the same space\")\n        require(grid\n\
    \                 .zipWithIndex\n                 .map(_.toList)\n           \
    \      .map(l => l.length == grid\n                                  .zipWithIndex\n\
    \                                  .filter(!_.toList.contains(l.head))\n     \
    \                             .map(_.head)\n                                 \
    \ .contains(l.last))\n                 .forall(!_),\n               \"all cells\
    \ in each well must occupy the same space\")\n        require(grid\n         \
    \        .zipWithIndex\n                 .map(_.toList)\n                 .map(l\
    \ => l.length == grid\n                                  .zipWithIndex\n     \
    \                             .filter(!_.toList.contains(l.head))\n          \
    \                        .map(_.last)\n                                  .contains(l.head))\n\
    \                 .forall(!_),\n               \"all cells in each well must occupy\
    \ the same space\")\n        val buckets = grid\n            .zipWithIndex\n \
    \           .map(_.toList)\n            .map(l => l.length == grid\n         \
    \                     .zipWithIndex\n                              .filter(!_.toList.contains(l.head))\n\
    \                              .map(_.head)\n                              .contains(l.last))\n\
    \            .flatMap(!_)\n            .map(bucket => 0l to bucket)\n        \
    \    .toList\n            .sorted\n        val usedBuckets = mutable.ListBuffer.empty[Int]\n\
    \        val result = mutable.ListBuffer.empty[Int]\n        for (i <- 1 to buckets.size\
    \ - 1) {\n            val r = i + buckets(i) - buckets(i - 1)\n            if\
    \ (r > 0) {\n                val leftBucket = buckets(i)\n                val\
    \ leftBuckets = buckets.drop(i)\n                val rightBuckets = buckets.take(r)\n\
    \                val leftKey = buckets(i) - leftBucket\n                val rightKey\
    \ = leftBucket - buckets(r)\n                if (leftBucket + r == buckets.last)\
    \ {\n                    val newKey = leftBucket + r\n                    \n \
    \   }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpuapkc82_.scala:100:0 ---------------------------\e\
    [0m\e[0m\n\e[31m100 |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m'}'\
    \ expected, but eof found\n\e[31m\e[31m-- Error: /tmp/tmpuapkc82_.scala:48:27\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m48 |\e[0m       \
    \          .map(l => l.length == grid\n\e[31m\e[31m   |\e[0m                 \
    \          ^\e[0m\n\e[31m   |\e[0m        Values of types Int and Boolean cannot\
    \ be compared with == or !=\n\e[31m49 |\e[0m                                 \
    \ .zipWithIndex\n\e[31m50 |\e[0m                                  .filter(!_.toList.contains(l.head))\n\
    \e[31m51 |\e[0m                                  .map(_.head)\n\e[31m52 |\e[0m\
    \                                  .contains(l.last))\n\e[31m\e[31m-- Error: /tmp/tmpuapkc82_.scala:58:27\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m58 |\e[0m       \
    \          .map(l => l.length == grid\n\e[31m\e[31m   |\e[0m                 \
    \          ^\e[0m\n\e[31m   |\e[0m        Values of types Int and Boolean cannot\
    \ be compared with == or !=\n\e[31m59 |\e[0m                                 \
    \ .zipWithIndex\n\e[31m60 |\e[0m                                  .filter(!_.toList.contains(l.head))\n\
    \e[31m61 |\e[0m                                  .map(_.last)\n\e[31m62 |\e[0m\
    \                                  .contains(l.head))\n\e[31m\e[31m-- Error: /tmp/tmpuapkc82_.scala:68:22\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m68 |\e[0m       \
    \     .map(l => l.length == grid\n\e[31m\e[31m   |\e[0m                      ^\e\
    [0m\n\e[31m   |\e[0m        Values of types Int and Boolean cannot be compared\
    \ with == or !=\n\e[31m69 |\e[0m                              .zipWithIndex\n\e\
    [31m70 |\e[0m                              .filter(!_.toList.contains(l.head))\n\
    \e[31m71 |\e[0m                              .map(_.head)\n\e[31m72 |\e[0m   \
    \                           .contains(l.last))\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpuapkc82_.scala:73:21 --------------------\e[0m\e[0m\n\e[31m73\
    \ |\e[0m            .flatMap(!_)\n\e[31m\e[31m   |\e[0m                     ^^\e\
    [0m\n\e[31m   |\e[0m        "
  stdout: ''
  timestamp: 1659979294
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        var currentCapacity : Long = 0\n        var isEmpty : Boolean\
    \ = true\n        var numOfEmpty : Int = 0\n        var buckets : List[List[Long]]\
    \ = List()\n        var bucketIndex = 0\n        grid.foreach(r => {\n       \
    \     if (r.isEmpty) isEmpty = true\n            buckets = r :: buckets\n    \
    \    })\n        if (isEmpty) bucketIndex += buckets.size * 1\n        while(!isEmpty\
    \ && bucketIndex < buckets.size * capacity) {\n            isEmpty =  buckets(0).isEmpty\n\
    \            if (isEmpty) {\n                buckets(0) = buckets(0).take(capacity)\n\
    \                currentCapacity += 1\n            }\n            buckets(0) =\
    \ buckets(0).drop(capacity)\n            bucketIndex += 1\n            numOfEmpty\
    \ += 1\n            buckets(0) = buckets(0).take(capacity)\n            bucketIndex\
    \ += 1\n        }\n        currentCapacity -= 1\n        numOfEmpty -= 1\n   \
    \     bucketIndex -= 1\n        currentCapacity -= 1\n        numOfEmpty -= 1\n\
    \        bucketIndex -= 1\n        numOfEmpty -= buckets.size * 1\n        currentCapacity\
    \ -= 1\n        numOfEmpty -= 1\n        bucketIndex -= 1\n        numOfEmpty\
    \ -= buckets.size * 1\n        currentCapacity -= 1\n        numOfEmpty -= 1\n\
    \        bucketIndex -= 1\n        numOfEmpty -= buckets.size * 1\n        currentCapacity\
    \ -= 1\n        numOfEmpty -= 1\n        bucketIndex -= 1\n        numOfEmpty\
    \ -= buckets.size * 1\n        currentCapacity -= 1\n        numOfEmpty -= 1\n\
    \        bucketIndex -= 1\n        numOfEmpty -= buckets.size * 1\n        currentCapacity\
    \ -= 1\n        numOfEmpty -= 1\n        bucketIndex -= 1\n        numOfEmpty\
    \ -= buckets.size * 1\n        currentCapacity -= 1\n        numOfEmpty -= 1\n\
    \        bucketIndex -= 1\n        numOfEmpty -= buckets.size * 1\n        currentCapacity\
    \ -= 1\n        numOfEmpty -= 1\n        bucketIndex -= 1\n        numOfEmpty\
    \ -= buckets.size * 1\n        currentCapacity -= 1\n        numOfEmpty -= 1\n\
    \        bucketIndex -= 1\n        numOfEmpty -= buckets.size * 1\n        currentCapacity\
    \ -= 1\n        numOfEmpty -= 1\n        bucketIndex -= 1\n        numOfEmpty\
    \ -= buckets.size * 1\n        currentCapacity -= 1\n        numOfEmpty -= 1\n\
    \        bucketIndex -= 1\n        numOfEmpty -= buckets.size * 1\n        currentCapacity\
    \ -= 1\n        numOfEmpty -= 1\n        bucketIndex -= 1\n        numOfEmpty\
    \ -= buckets.size * 1\n        currentCapacity -= 1\n        numOfEmpty -= 1\n\
    \        bucketIndex -= 1\n        numOfEmpty -= buckets.size * 1\n        currentCapacity\
    \ -= 1\n        numOfEmpty -= 1\n        bucketIndex -= 1\n        numOfEmpty\
    \ -= buckets.\n    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpwlp9xm44.scala:107:4 ---------------------------\e\
    [0m\e[0m\n\e[31m107 |\e[0m    }\n\e[31m\e[31m    |\e[0m    ^\e[0m\n\e[31m    |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmpwlp9xm44.scala:39:16 ------------------------\e[0m\e[0m\n\e[31m39\
    \ |\e[0m                buckets(\e[31m0\e[0m) = buckets(\e[31m0\e[0m).take(capacity)\n\
    \e[31m\e[31m   |\e[0m                ^^^^^^^\e[0m\n\e[31m   |\e[0mvalue update\
    \ is not a member of List[List[Long]] - did you mean List[List[Long]].updated?\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpwlp9xm44.scala:39:45 --------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m                buckets(\e[31m0\e[0m) = buckets(\e[31m0\e\
    [0m).take(capacity)\n\e[31m\e[31m   |\e[0m                                   \
    \          ^^^^^^^^\e[0m\n\e[31m   |\e[0m                                    \
    \         Found:    (capacity : Long)\n\e[31m   |\e[0m                       \
    \                      Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpwlp9xm44.scala:42:12 ------------------------\e[0m\e\
    [0m\n\e[31m42 |\e[0m            buckets(\e[31m0\e[0m) = buckets(\e[31m0\e[0m).drop(capacity)\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^\e[0m\n\e[31m   |\e[0mvalue update is\
    \ not a member of List[List[Long]] - did you mean List[List[Long]].updated?\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpwlp9xm44.scala:42:41 --------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m            buckets(\e[31m0\e[0m) = buckets(\e[31m0\e\
    [0m).drop(capacity)\n\e[31m\e[31m   |\e[0m                                   \
    \      ^^^^^^^^\e[0m\n\e[31m   |\e[0m                                        \
    \ Found:    (capacity : Long)\n\e[31m   |\e[0m                               \
    \          Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpwlp9xm44.scala:45:12 ------------------------\e[0m\e[0m\n\e[31m45 |\e\
    [0m            buckets(\e[31m0\e[0m) = buckets(\e[31m0\e[0m).take(capacity)\n\e\
    [31m"
  stdout: ''
  timestamp: 1659979292
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        def dfs(grid : List[List[Long]], i : Int, j : Int, visited\
    \ : Set[Int], visitedCount : Int) : Long = {\n            if(visited.contains(i)\
    \ && visited.contains(j)) {\n                return visitedCount\n           \
    \ }\n            if(grid[i][j] == 0) {\n                visited.add(i)\n     \
    \           visited.add(j)\n                visitedCount += 1\n              \
    \  return dfs(grid, i + 1, j, visited, visitedCount)\n            }\n        \
    \    if((grid[i][j] == 1) && (i != grid.length - 1 && j != grid[i].length - 1))\
    \ {\n                visited.add(i)\n                visited.add(j)\n        \
    \        visitedCount += 1\n                return dfs(grid, i + 1, j, visited,\
    \ visitedCount)\n            }\n            visitedCount += 0\n            return\
    \ visitedCount\n        }\n        var visited = new mutable.HashSet[Int]()\n\
    \        visited.add(0)\n        visited.add(grid.length - 1)\n        return\
    \ dfs(grid, 0, 0, visited, 0)\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 1l.toLong,\
    \ 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong, 0l.toLong), List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (1l)) == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpjcmrxge5.scala:30:23 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m            \e[33mif\e[0m(grid[\e[35mi\e[0m][\e[35mj\e\
    [0m] == \e[31m0\e[0m) {\n\e[31m\e[31m   |\e[0m                       ^\e[0m\n\e\
    [31m   |\e[0m                       Not found: type j\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpjcmrxge5.scala:30:20 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m            \e[33mif\e[0m(grid[\e[35mi\e[0m][\e[35mj\e\
    [0m] == \e[31m0\e[0m) {\n\e[31m\e[31m   |\e[0m                    ^\e[0m\n\e[31m\
    \   |\e[0m                    Not found: type i\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpjcmrxge5.scala:33:29 ------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m                visitedCount += \e[31m1\e[0m\n\e[31m\e\
    [31m   |\e[0m                ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m         value\
    \ += is not a member of Int - did you mean visitedCount.!=?\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpjcmrxge5.scala:36:24 ------------------------\e[0m\e\
    [0m\n\e[31m36 |\e[0m            \e[33mif\e[0m((grid[\e[35mi\e[0m][\e[35mj\e[0m]\
    \ == \e[31m1\e[0m) && (i != grid.length - \e[31m1\e[0m && j != grid[\e[35mi\e\
    [0m].length - \e[31m1\e[0m)) {\n\e[31m\e[31m   |\e[0m                        ^\e\
    [0m\n\e[31m   |\e[0m                        Not found: type j\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpjcmrxge5.scala:36:21 ------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m            \e[33mif\e[0m((grid[\e[35mi\e[0m][\e[35mj\e\
    [0m] == \e[31m1\e[0m) && (i != grid.length - \e[31m1\e[0m && j != grid[\e[35mi\e\
    [0m].length - \e[31m1\e[0m)) {\n\e[31m\e[31m   |\e[0m                     ^\e\
    [0m\n\e[31m   |\e[0m                     Not found: type i\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpjcmrxge5.scala:39:29 ------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m "
  stdout: ''
  timestamp: 1659979291
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val result = 0\n        var i = 0\n        var j = 0\n \
    \       var k = 0\n        var n = 0\n        while (i < grid.length && j < grid[i].length)\
    \ {\n            result += math.max(grid(i)(j) - capacity, grid[j](i)) - capacity\n\
    \            k = i\n            while (k >= 0 && j >= 0) {\n                n\
    \ += grid[k](i)\n                grid[k-1] = grid[k-1].drop(i+1)\n           \
    \     j--\n                k--\n            }\n            i = k + 1\n       \
    \     j = n\n            n = 0\n        }\n        result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp5xhcw4lc.scala:36:26 -----------------------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m                grid[\e[35mk-\e[31m1\e[0m] = grid[k-\e\
    [31m1\e[0m].drop(i+\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m                      \
    \    ^\e[0m\n\e[31m   |\e[0m                          end of statement expected\
    \ but '=' found\n\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp5xhcw4lc.scala:38:19\
    \ ---------------------------\e[0m\e[0m\n\e[31m38 |\e[0m                k--\n\e\
    [31m\e[31m   |\e[0m                   ^\e[0m\n\e[31m   |\e[0m                \
    \   expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp5xhcw4lc.scala:31:43 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mwhile\e[0m (i < grid.length && j < grid[\e\
    [35mi\e[0m].length) {\n\e[31m\e[31m   |\e[0m                                 \
    \          ^\e[0m\n\e[31m   |\e[0m                                           Not\
    \ found: type i\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp5xhcw4lc.scala:32:19\
    \ ------------------------\e[0m\e[0m\n\e[31m32 |\e[0m            result += math.max(grid(i)(j)\
    \ - capacity, grid[\e[35mj\e[0m](i)) - capacity\n\e[31m\e[31m   |\e[0m       \
    \     ^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value += is not a member of Int\
    \ - did you mean result.!=?\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp5xhcw4lc.scala:32:59\
    \ ------------------------\e[0m\e[0m\n\e[31m32 |\e[0m            result += math.max(grid(i)(j)\
    \ - capacity, grid[\e[35mj\e[0m](i)) - capacity\n\e[31m\e[31m   |\e[0m       \
    \                                                    ^\e[0m\n\e[31m   |\e[0m \
    \                                                      Not found: type j\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp5xhcw4lc.scala:35:18 ------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m                n += grid[\e[35mk\e[0m](i)\n\e[31m\e\
    [31m   |\e[0m                ^^^^\e[0"
  stdout: ''
  timestamp: 1659979291
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val count = new mutable.HashMap[List[Long], Long]()\n  \
    \      val result = new mutable.HashMap[List[Long], Long]()\n        grid.foreach(row\
    \ => {\n            row.foreach(bucket => {\n                if (count.contains(bucket))\
    \ {\n                    count(bucket) = count(bucket) + 1 \n                }\
    \ else {\n                    count.put(bucket, 1)\n                }\n      \
    \      })\n        })\n        count.foreach(bucket => {\n            if (count(bucket)\
    \ > 1) {\n                val index = bucket.min\n                val value =\
    \ count(bucket)\n                if (value > 0) {\n                    if (result.contains(bucket))\
    \ {\n                        result(bucket) = result(bucket) + value\n       \
    \             } else {\n                        result(bucket) = value\n     \
    \               }\n                }\n            }\n        })\n        val total\
    \ = count(count.keys.max)\n        result.foreach(bucket => {\n            if\
    \ (count(bucket) > 1) {\n                val value = count(bucket)\n         \
    \       if (value > 0) {\n                    count(bucket) = count(bucket) -\
    \ 1 \n                }\n            }\n        })\n        result.values.sum\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp6_npjk6u.scala:26:24 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mcount\e[0m = \e[33mnew\e\
    [0m mutable.HashMap[\e[35mList\e[0m[\e[35mLong\e[0m], \e[35mLong\e[0m]()\n\e[31m\e\
    [31m   |\e[0m                        ^^^^^^^\e[0m\n\e[31m   |\e[0m           \
    \             Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp6_npjk6u.scala:27:25 ------------------------\e[0m\e[0m\n\e[31m27 |\e\
    [0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e[0m mutable.HashMap[\e\
    [35mList\e[0m[\e[35mLong\e[0m], \e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m    \
    \                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                         Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659979288
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = mutable.HashMap[Long, Int]()\n        val\
    \ result = 0\n        for (r <- 0 until grid.length) {\n            val rowMax\
    \ = grid(r)\n            for (c <- 0 until rowMax.length) {\n                if\
    \ (!rowMax.contains(0l) && !rowMax.contains(1l)) {\n                    val bucketId\
    \ = rowMax.foldLeft(0l)((x, y) => x | y)\n                    if (buckets.contains(bucketId))\
    \ {\n                        val oldValue = buckets(bucketId)\n              \
    \          buckets(bucketId) = oldValue + 1\n                        if (oldValue\
    \ > capacity) {\n                            result = math.max(result, buckets(bucketId))\n\
    \                        }\n                    }\n                }\n       \
    \     }\n        }\n        result\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 1l.toLong,\
    \ 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong, 0l.toLong), List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (1l)) == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp_50e0gkf.scala:26:22 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mbuckets\e[0m = mutable.HashMap[\e\
    [35mLong\e[0m, \e[35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E052] Type Error: /tmp/tmp_50e0gkf.scala:37:35 -----------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m                            result = math.max(result,\
    \ buckets(bucketId))\n\e[31m\e[31m   |\e[0m                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                            Reassignment to val result\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659979290
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        if (grid == null || grid.isEmpty) 0\n        val numWells\
    \ = grid.head.size\n        val bucketSize = capacity / numWells\n        val\
    \ totalCapacity = capacity\n        val buckets = mutable.ArrayBuffer[mutable.ArrayBuffer[Long]]()\n\
    \        for (i <- 1 to numWells)\n            for (j <- 1 to numWells)\n    \
    \            if (j < i)\n                    buckets += mutable.ArrayBuffer[Long]()\n\
    \        // The bucket is full\n        if (buckets.isEmpty || totalCapacity <\
    \ buckets.last.last)\n            return 0\n        val numBuckets = buckets.last.length\n\
    \        val minBucketCapacity = totalCapacity / numBuckets\n        // The bucket\
    \ cannot exceed the total capacity\n        if (buckets.last.last > totalCapacity)\n\
    \            return 0\n        // The bucket is empty and there exists an empty\
    \ bucket\n        if (buckets.last.isEmpty && buckets.last.last == 0l)\n     \
    \       return 0\n        // The buckets are empty\n        if (buckets.last.last\
    \ == 0l)\n            return 1\n        val fillBucket = buckets.last.last\n \
    \       val bucketCapacity = buckets.last.last\n        val bucketsLeft = numBuckets\
    \ - fillBucket\n        // The bucket is empty and there exists an empty bucket\n\
    \        if (buckets.last.isEmpty && buckets.last.last == 0l)\n            return\
    \ 0\n        // The buckets are full\n        if (bucketsLeft == 0)\n        \
    \    return 0\n        // The bucket is full\n        if (bucketCapacity == minBucketCapacity)\n\
    \            return maxFill(grid.tail, bucketCapacity)\n        // The bucket\
    \ is empty and there exists an non-empty bucket\n        if (bucketCapacity ==\
    \ totalCapacity && buckets.last.isEmpty && buckets.last.last != 0l)\n        \
    \    return maxFill(grid.tail, bucketCapacity)\n        // The bucket is empty\
    \ and there exists an non-empty bucket\n        if (bucketCapacity == totalCapacity)\n\
    \            return 1 + maxFill(grid.tail, bucketCapacity)\n        // The bucket\
    \ is full\n        if (bucketCapacity < minBucketCapacity)\n            return\
    \ 0\n        // The bucket is empty and there exists an non-empty bucket\n   \
    \     if (bucketCapacity == minBucketCapacity)\n            return 1 + maxFill(grid.tail,\
    \ bucketCapacity)\n        // The bucket is empty and there exists an non-empty\
    \ bucket\n        if (bucketCapacity < totalCapacity)\n            return 1 +\
    \ maxFill(grid.tail, bucketCapacity)\n        // The bucket is full\n        return\
    \ 0\n    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpuu2fvpcw.scala:30:42 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mbuckets\e[0m = mutable.ArrayBuffer[mutable.ArrayBuffer[\e\
    [35mLong\e[0m]]()\n\e[31m\e[31m   |\e[0m                                     \
    \     ^^^^^^^\e[0m\n\e[31m   |\e[0m                                          Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpuu2fvpcw.scala:30:22\
    \ ------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e\
    [36mbuckets\e[0m = mutable.ArrayBuffer[mutable.ArrayBuffer[\e[35mLong\e[0m]]()\n\
    \e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                 Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[33m\e[33m-- [E129]\
    \ Potential Issue Warning: /tmp/tmpuu2fvpcw.scala:26:42 ----------------\e[0m\e\
    [0m\n\e[33m26 |\e[0m        \e[33mif\e[0m (grid == \e[31mnull\e[0m || grid.isEmpty)\
    \ \e[31m0\e[0m\n\e[33m\e[33m   |\e[0m                                        \
    \  ^\e[0m\n\e[33m   |\e[0mA pure expression does nothing in statement position;\
    \ you may be omitting necessary parentheses\n\e[33m   |\e[0m\n\e[33m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 warning found\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659979290
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val rowCount = grid.length\n        val colCount = grid(0).length\n\
    \        \n        val max = 0l\n        var temp : Long = 0l\n        var i :\
    \ Int = 0\n        var j : Int = 0\n        \n        for(i <- 0 until rowCount){\n\
    \            for(j <- 0 until colCount){\n                temp = grid[i][j].toLong\n\
    \                while(grid[i][j] == 1l){\n                    if(temp < capacity){\n\
    \                        temp += 1l\n                    } else {\n          \
    \              temp -= 1l\n                    }\n                    \n     \
    \               if(temp > max){\n                        max = temp\n        \
    \            }\n                    \n                    if(temp == 0){\n   \
    \                     temp = 1l\n                    }\n                }\n  \
    \          }\n        }\n        \n        max\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 1l.toLong,\
    \ 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong, 0l.toLong), List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (1l)) == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp7lp5hzkp.scala:36:31 ------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m                temp = grid[\e[35mi\e[0m][\e[35mj\e[0m].toLong\n\
    \e[31m\e[31m   |\e[0m                               ^\e[0m\n\e[31m   |\e[0m  \
    \                             Not found: type j\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp7lp5hzkp.scala:36:28 ------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m                temp = grid[\e[35mi\e[0m][\e[35mj\e[0m].toLong\n\
    \e[31m\e[31m   |\e[0m                            ^\e[0m\n\e[31m   |\e[0m     \
    \                       Not found: type i\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmp7lp5hzkp.scala:37:30 ------------------------\e[0m\e\
    [0m\n\e[31m37 |\e[0m                \e[33mwhile\e[0m(grid[\e[35mi\e[0m][\e[35mj\e\
    [0m] == \e[31m1l\e[0m){\n\e[31m\e[31m   |\e[0m                              ^\e\
    [0m\n\e[31m   |\e[0m                              Not found: type j\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp7lp5hzkp.scala:37:27 ------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m                \e[33mwhile\e[0m(grid[\e[35mi\e[0m][\e\
    [35mj\e[0m] == \e[31m1l\e[0m){\n\e[31m\e[31m   |\e[0m                        \
    \   ^\e[0m\n\e[31m   |\e[0m                           Not found: type i\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E052] Type Error: /tmp/tmp7lp5hzkp.scala:45:28 -----------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m                        max = temp\n\e[31m\e[31m   |\e\
    [0m                        ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                  \
    \      Reassignment to val max\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n5 errors found\n"
  stdout: ''
  timestamp: 1659979292
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        // Your code here\n        val map = mutable.HashMap[Long,\
    \ Long]()\n        for( row <- 0 until grid.length)\n        {\n            for(\
    \ column <- 0 until grid[0].length)\n            {\n                map.put(row,\
    \ column)\n            }\n        }\n\n        var i = 0\n        var j = 0\n\
    \        var count = 0\n        while(i < grid.length && j < grid[0].length)\n\
    \        {\n            count = map.get(grid(i)(j))\n            if(count == 0)\n\
    \            {\n                i +=1\n                map.put(grid(i)(j), capacity)\n\
    \                j += 1\n                map.put(grid(i)(j), capacity)\n     \
    \       }\n            else if(count < capacity)\n            {\n            \
    \    i += 1\n            }\n            else\n            {\n                j\
    \ += 1 \n            }\n        }\n        count\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 1l.toLong,\
    \ 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong, 0l.toLong), List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (1l)) == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpcihwjm_w.scala:27:18 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mmap\e[0m = mutable.HashMap[\e\
    [35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                  ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                  Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- Error: /tmp/tmpcihwjm_w.scala:30:39 -----------------------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m            \e[33mfor\e[0m( column <- \e[31m0\e[0m until\
    \ grid[\e[31m0\e[0m].length)\n\e[31m\e[31m   |\e[0m                          \
    \         ^^^^^^^\e[0m\n\e[31m   |\e[0m        \e[33mmethod\e[0m \e[35mapply\e\
    [0m in \e[33mtrait\e[0m \e[35mLinearSeqOps\e[0m does not take type parameters\n\
    \e[31m\e[31m-- Error: /tmp/tmpcihwjm_w.scala:39:41 -----------------------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m        \e[33mwhile\e[0m(i < grid.length && j < grid[\e\
    [31m0\e[0m].length)\n\e[31m\e[31m   |\e[0m                                   \
    \  ^^^^^^^\e[0m\n\e[31m   |\e[0m        \e[33mmethod\e[0m \e[35mapply\e[0m in\
    \ \e[33mtrait\e[0m \e[35mLinearSeqOps\e[0m does not take type parameters\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659979293
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        var buckets = mutable.ArrayBuffer.empty[Int]\n        for\
    \ (row <- 0 until grid.length) {\n            buckets += 0 until capacity.toInt\n\
    \        }\n        \n        for (bucket <- buckets) {\n            var wells\
    \ = 0\n            var water = 0\n            var current = 0\n            while\
    \ (current < grid.length && water < capacity) {\n                val row = current.toInt\n\
    \                val col = current.toInt\n                val value = grid[current]\n\
    \                val value = if (value == 0l) 0l else 1l\n                if (value\
    \ != 0l && buckets(bucket + value) == buckets(bucket + 1))\n                 \
    \   wells += 1\n                water += 1\n                current += 1\n   \
    \         }\n            if (water > capacity)\n                return wells *\
    \ 2\n        }\n        return 0l\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 1l.toLong,\
    \ 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong, 0l.toLong), List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (1l)) == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp3knpxk01.scala:26:22 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mvar\e[0m \e[36mbuckets\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mInt\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659979292
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        // Write your code here\n        var total = 0\n       \
    \ val map = scala.collection.mutable.HashMap.empty[Long, Long]\n        grid.foreach{\n\
    \            row => {\n                row.foreach{\n                    v =>\
    \ {\n                        map  += v\n                    }\n              \
    \  }\n            }\n        }\n        map.foreach(\n            v => {\n   \
    \             if (v <= capacity) {\n                    total += 1\n         \
    \       }\n            }\n        )\n        return total\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpdza8g91p.scala:33:32\
    \ --------------------\e[0m\e[0m\n\e[31m33 |\e[0m                        map \
    \ += v\n\e[31m\e[31m   |\e[0m                                ^\e[0m\n\e[31m  \
    \ |\e[0m                                Found:    (\e[1m\e[31mv\e[0m\e[1m\e[31m\
    \ \e[0m\e[1m\e[31m:\e[0m Long)\n\e[31m   |\e[0m                              \
    \  Required: (\e[1m\e[32mLong\e[0m\e[1m\e[32m,\e[0m Long)\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpdza8g91p.scala:40:22 ------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m                \e[33mif\e[0m (v <= capacity) {\n\e[31m\e\
    [31m   |\e[0m                    ^^^^\e[0m\n\e[31m   |\e[0mvalue <= is not a member\
    \ of (Long, Long), but could be made available as an extension method.\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mOne of the following imports might fix the problem:\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Ordered.orderingToOrdered\n\e[31m\
    \   |\e[0m  import math.Ordering.Implicits.infixOrderingOps\n\e[31m   |\e[0m\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659979299
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val m = grid.length\n        val n = grid(0).length\n  \
    \      val buckets = Array.ofDim[Long](m, n)\n        for ((i, j) <- 0 until m)\
    \ {\n            for (k <- 0 until n) {\n                buckets(i, j) = if (grid(i)(k)\
    \ == 0) capacity else 0\n            }\n        }\n        return maxFillHelper(buckets,\
    \ m, n)\n    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpar0469ki.scala:31:41\
    \ --------------------\e[0m\e[0m\n\e[31m31 |\e[0m                buckets(i, j)\
    \ = \e[33mif\e[0m (grid(i)(k) == \e[31m0\e[0m) capacity \e[33melse\e[0m \e[31m0\e\
    [0m\n\e[31m\e[31m   |\e[0m                                         ^\e[0m\n\e\
    [31m   |\e[0m                                         Found:    (i : Any)\n\e\
    [31m   |\e[0m                                         Required: Int\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpar0469ki.scala:31:24 --------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m                buckets(i, j) = \e[33mif\e[0m (grid(i)(k)\
    \ == \e[31m0\e[0m) capacity \e[33melse\e[0m \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m\
    \                        ^\e[0m\n\e[31m   |\e[0m                        Found:\
    \    (i : Any)\n\e[31m   |\e[0m                        Required: Int\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpar0469ki.scala:31:27 --------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m                buckets(i, j) = \e[33mif\e[0m (grid(i)(k)\
    \ == \e[31m0\e[0m) capacity \e[33melse\e[0m \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m\
    \                           ^\e[0m\n\e[31m   |\e[0m                          \
    \ Found:    (j : Any)\n\e[31m   |\e[0m                           Required: Array[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpar0469ki.scala:34:15\
    \ ------------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mreturn\e[0m\
    \ maxFillHelper(buckets, m, n)\n\e[31m\e[31m   |\e[0m               ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m               Not found: maxFillHelper\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1659979298
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val height  = grid.length\n        val width   = grid(0).get.length\n\
    \        val minVal  = math.min(width, height)\n        var count = 0\n      \
    \  var index = 0\n        while(index<height) {\n            var index2 = 0\n\
    \            while(index2<width) {\n                val value = grid((index+minVal-1)/minVal,(index2+minVal-1)/minVal)\n\
    \                if(value == 1l) {\n                    count+=1;\n          \
    \      }\n                index2+=1\n            }\n            index+=1\n   \
    \     }\n        math.max(1,Math.ceil(Math.sqrt(count*capacity/width*height/minVal)).toInt)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp33eqe1vu.scala:27:30 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mwidth\e[0m   = grid(\e[31m0\e\
    [0m).get.length\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m  value get is not a member of List[Long] - did you mean List[Long].seq?\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp33eqe1vu.scala:34:33 --------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m                \e[33mval\e[0m \e[36mvalue\e[0m = grid((index+minVal-\e\
    [31m1\e[0m)/minVal,(index2+minVal-\e[31m1\e[0m)/minVal)\n\e[31m\e[31m   |\e[0m\
    \                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                 Found:    (Nothing, Nothing)\n\
    \e[31m   |\e[0m                                 Required: Int\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- Error: /tmp/tmp33eqe1vu.scala:35:19 -----------------------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m                \e[33mif\e[0m(value == \e[31m1l\e[0m)\
    \ {\n\e[31m\e[31m   |\e[0m                   ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \    Values of types List[Long] and Long cannot be compared with == or !=\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659979299
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        // write your code here\n        val totalSize = grid.reduce(_\
    \ + _)\n        if (totalSize == 0l)\n            return 0\n        val size =\
    \ totalSize / capacity\n        val bucket = mutable.ArrayBuffer(capacity).view.take(size)\n\
    \        val empty = mutable.ArrayBuffer(capacity).view.take(size)\n        val\
    \ countMap = mutable.HashMap[List[Long], Long]()\n        grid.foreach { row =>\n\
    \            row.foreach { bucket => bucket.foreach { empty => empty.foreach {\
    \ _ <- 0 } }\n            empty.clear()\n            bucket.foreach { bucket =>\
    \ empty.add(bucket) }\n        }\n        val maxCount = countMap.max { case (_,\
    \ count) => count }\n        countMap.values.toList.max\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpk47glpzd.scala:35:80 -----------------------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m            row.foreach { \e[36mbucket\e[0m => bucket.foreach\
    \ { \e[36mempty\e[0m => empty.foreach { _ <- \e[31m0\e[0m } }\n\e[31m\e[31m  \
    \ |\e[0m                                                                     \
    \           ^^\e[0m\n\e[31m   |\e[0m                                end of statement\
    \ expected but '<-' found\n\e[31m\e[31m-- [E017] Syntax Error: /tmp/tmpk47glpzd.scala:35:78\
    \ ---------------------------\e[0m\e[0m\n\e[31m35 |\e[0m            row.foreach\
    \ { \e[36mbucket\e[0m => bucket.foreach { \e[36mempty\e[0m => empty.foreach {\
    \ _ <- \e[31m0\e[0m } }\n\e[31m\e[31m   |\e[0m                               \
    \                                               ^\e[0m\n\e[31m   |\e[0m      \
    \                 Unbound placeholder parameter; incorrect use of _\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpk47glpzd.scala:51:0 ----------------------------\e\
    [0m\e[0m\n\e[31m51 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpk47glpzd.scala:27:38\
    \ ------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e\
    [36mtotalSize\e[0m = grid.reduce(_ + _)\n\e[31m\e[31m   |\e[0m               \
    \                     ^^^\e[0m\n\e[31m   |\e[0mvalue + is not a member of List[Long],\
    \ but could be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mOne of the following imports might make progress towards fixing the\
    \ problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- Error: /tmp/tmpk47glpzd.scala:28:12 -----------------------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mif\e[0m (totalSize == \e[31m0l\e[0m)\n\e\
    [31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    Values\
    \ of types List[Long] and Long cannot be compared with"
  stdout: ''
  timestamp: 1659979302
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val m = grid.map(_.length).max\n        val n = grid.map(_.last).max\n\
    \        // find first non-zero cell\n        val i = grid (0 until m) (0 until\
    \ n).find(_.nonEmpty)\n        // use recursion to fill all cells, return the\
    \ count\n        val count = maxFillUtil(grid, i, m, n, capacity)\n        //\
    \ the return value can be replaced with 'count'\n        count\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpp7rjwav3.scala:29:22\
    \ --------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mi\e\
    [0m = grid (\e[31m0\e[0m until m) (\e[31m0\e[0m until n).find(_.nonEmpty)\n\e\
    [31m\e[31m   |\e[0m                      ^^^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                 Found:    Range\n\e[31m   |\e[0m                      Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpp7rjwav3.scala:29:42\
    \ --------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mi\e\
    [0m = grid (\e[31m0\e[0m until m) (\e[31m0\e[0m until n).find(_.nonEmpty)\n\e\
    [31m\e[31m   |\e[0m                                          ^\e[0m\n\e[31m  \
    \ |\e[0m                                          Found:    (n : Long)\n\e[31m\
    \   |\e[0m                                          Required: Int\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpp7rjwav3.scala:31:20 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mcount\e[0m = maxFillUtil(grid,\
    \ i, m, n, capacity)\n\e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                    Not found: maxFillUtil\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659979300
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        if (grid.length == 1) {\n            grid(0).map(_.toInt).sum\n\
    \        } else {\n            var result : Long = 0\n            var fillRow\
    \ : List[List[Long]] = grid.head\n            var fillCol : List[Long] = grid.head\n\
    \n            for (x <- grid.length) {\n                for (y <- x.toInt) {\n\
    \                    var currentCol : List[Long] = fillCol.tail\n            \
    \        var currentRow : List[Long] = fillRow.tail\n\n                    var\
    \ currentMax: Long = currentCol.foldLeft(0l) { (max: Long, current: Long) => max\
    \ max max }\n                    var currentIndex: Long = currentRow.foldLeft(0l)\
    \ { (max: Long, current: Long) => max max max }\n\n                    var current:\
    \ Long = currentCol.foldLeft(0l) { (max: Long, current: Long) => max max max }\n\
    \                    if (current == capacity) {\n                        currentMax\
    \ = currentMax.toLong - currentIndex.toLong\n                        result =\
    \ result + currentMax\n                    }\n                }\n            \
    \    fillRow = fillRow.tail\n                fillCol = fillCol.tail\n        \
    \    }\n            result\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 1l.toLong,\
    \ 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong, 0l.toLong), List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (1l)) == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp7iqzs5ac.scala:30:50\
    \ --------------------\e[0m\e[0m\n\e[31m30 |\e[0m            \e[33mvar\e[0m \e\
    [36mfillRow\e[0m : \e[35mList\e[0m[\e[35mList\e[0m[\e[35mLong\e[0m]] = grid.head\n\
    \e[31m\e[31m   |\e[0m                                             ^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                             Found:    List[Long]\n\
    \e[31m   |\e[0m                                             Required: List[\e\
    [1m\e[32mList\e[0m\e[1m\e[32m[\e[0mLong\e[1m\e[32m]\e[0m]\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmp7iqzs5ac.scala:33:22 ------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m            \e[33mfor\e[0m (x <- grid.length) {\n\e[31m\e\
    [31m   |\e[0m                      ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m         \
    \             value foreach is not a member of Int\n2 errors found\n"
  stdout: ''
  timestamp: 1659979299
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        require(grid.length == grid.head.size)\n        var n =\
    \ 0\n        var max = 0\n        val rowCount = grid.head.size\n        var index\
    \ = 0\n        while(index < rowCount) {\n            require(rowCount > index)\n\
    \            require(index > 0)\n            require(index != rowCount)\n    \
    \        val row = grid(index)\n            val colCount = row.size\n        \
    \    var colIndex = 0\n            while(colIndex < colCount) {\n            \
    \    require(colCount > colIndex)\n                require(colIndex > 0)\n   \
    \             require(colIndex != colCount)\n                val col = rows(index)\n\
    \                val value = grid(index)(colIndex)\n                if(value !=\
    \ 0) {\n                    require(index > 0)\n                    require(colCount\
    \ > colIndex)\n                    require(colIndex > 0)\n                   \
    \ require(colIndex != colCount)\n                    var maxValue = 0l\n     \
    \               var colMaxValue = 0l\n                    val maxCol = grid(index\
    \ - 1)\n                    val maxRow = grid(index + 1)\n                   \
    \ val colMin = grid(index - 1)(colIndex)\n                    val colMax = grid(index\
    \ + 1)(colIndex)\n                    val minCol = grid(index - 1)(colCount)\n\
    \                    val minRow = grid(index + 1)(colCount)\n                \
    \    val colRange = colMax - colMin + 1\n                    var rowRange = 0l\n\
    \                    val maxColValue = max(maxCol)\n                    val minColValue\
    \ = min(minCol)\n                    val maxRowValue = max(maxRow)\n         \
    \           val minRowValue = min(minRow)\n                    val minColRange\
    \ = minColValue - minColValue + 1\n                    val maxColValue = max(maxCol)\n\
    \                    val minColValue = min(minCol)\n                    val maxRowValue\
    \ = max(maxRow)\n                    val minRowValue = min(minRow)\n         \
    \           val minRowRange = minRowValue - minRowValue + 1\n                \
    \    val colValue = col(colIndex)\n                    val rowValue = row(colIndex)\n\
    \                    val colMaxValue = max(colMax)\n                    val rowMaxValue\
    \ = max(rowMax)\n                    val colMinValue = min(colMin)\n         \
    \           val rowMinValue = min(rowMin)\n                    val colRangeValue\
    \ = colRangeValue + 1\n                    val rowRangeValue = rowRangeValue +\
    \ 1\n                    maxValue = math.max(maxValue, value)\n              \
    \      colMaxValue = math.max(colMaxValue, colValue)\n                    rowMaxValue\
    \ = math.max(rowMaxValue, rowValue)\n                    colMinValue = math.min(colMinValue,\
    \ colValue)\n                    rowMinValue = math.min(rowMinValue, rowValue)\n\
    \n    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp9xj21546.scala:93:0 ----------------------------\e\
    [0m\e[0m\n\e[31m93 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp9xj21546.scala:42:26\
    \ ------------------------\e[0m\e[0m\n\e[31m42 |\e[0m                \e[33mval\e\
    [0m \e[36mcol\e[0m = rows(index)\n\e[31m\e[31m   |\e[0m                      \
    \    ^^^^\e[0m\n\e[31m   |\e[0m                          Not found: rows\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp9xj21546.scala:64:24 ---------------------------\e\
    [0m\e[0m\n\e[31m64 |\e[0m                    \e[33mval\e[0m \e[36mmaxColValue\e\
    [0m = max(maxCol)\n\e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxColValue is already defined as \e[33mvalue\e[0m \e[35mmaxColValue\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp9xj21546.scala:65:24 ---------------------------\e[0m\e[0m\n\e\
    [31m65 |\e[0m                    \e[33mval\e[0m \e[36mminColValue\e[0m = min(minCol)\n\
    \e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mminColValue is already defined as \e[33mvalue\e[0m \e[35mminColValue\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp9xj21546.scala:66:24 ---------------------------\e[0m\e[0m\n\e\
    [31m66 |\e[0m                    \e[33mval\e[0m \e[36mmaxRowValue\e[0m = max(maxRow)\n\
    \e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mmaxRowValue is already defined as \e[33mvalue\e[0m \e[35mmaxRowValue\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp9xj21546.scala:67:24 ---------------------------\e[0m\e[0m\n\e\
    [31m67 |\e[0m                    \e[33mval\e[0m \e["
  stdout: ''
  timestamp: 1659979296
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        var totalWells = grid.head\n\n        totalWells match {\n\
    \            case head :: tail => maxFill(tail, capacity)\n            case _\
    \ => 0\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpvj4ylx6p.scala:29:41\
    \ --------------------\e[0m\e[0m\n\e[31m29 |\e[0m            \e[33mcase\e[0m head\
    \ :: tail => maxFill(tail, capacity)\n\e[31m\e[31m   |\e[0m                  \
    \                       ^^^^\e[0m\n\e[31m   |\e[0m                           \
    \              Found:    \e[1m\e[31m(\e[0m\e[1m\e[31mtail\e[0m\e[1m\e[31m \e[0m\e\
    [1m\e[31m:\e[0m\e[1m\e[31m \e[0mList[Long]\e[1m\e[31m)\e[0m\n\e[31m   |\e[0m \
    \                                        Required: \e[1m\e[32mList\e[0m\e[1m\e\
    [32m[\e[0mList[Long]\e[1m\e[32m]\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979300
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        if (grid.length < 1 || grid.head.length < 1 || grid.head.headOption.isEmpty\
    \ || grid.tail.length < 1 || grid.tail.tailOption.isEmpty) {\n            return\
    \ 0\n        }\n        // val buckets = grid.map(_.toLong)\n        // val result\
    \ = buckets.count(_ == 0) // count the non zero buckets\n        val buckets =\
    \ grid.map(_.toLong).toSet\n        val result = (buckets.count(_ == 0) - (buckets.count(_\
    \ == 0) - capacity)).toLong\n        // println(buckets.count(_ == 0) - (buckets.count(_\
    \ == 0) - capacity))\n        return result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 1l.toLong,\
    \ 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong, 0l.toLong), List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (1l)) == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp9pagpus5.scala:26:121 -----------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mif\e[0m (grid.length < \e[31m1\e[0m ||\
    \ grid.head.length < \e[31m1\e[0m || grid.head.headOption.isEmpty || grid.tail.length\
    \ < \e[31m1\e[0m || grid.tail.tailOption.isEmpty) {\n\e[31m\e[31m   |\e[0m   \
    \                                                                            \
    \                                ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ tailOption is not a member of List[List[Long] @uncheckedVariance] - did you\
    \ mean List[List[Long] @uncheckedVariance].lastOption?\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp9pagpus5.scala:31:33 ------------------------\e[0m\e\
    [0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mbuckets\e[0m = grid.map(_.toLong).toSet\n\
    \e[31m\e[31m   |\e[0m                               ^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mvalue toLong is not a member of List[Long], but could be made available as\
    \ an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports\
    \ might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e[0m  import\
    \ math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import math.Numeric.Implicits.infixNumericOps\n\
    \e[31m   |\e[0m\n2 errors found\n"
  stdout: ''
  timestamp: 1659979303
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val totalBuckets = grid.length\n        if (totalBuckets\
    \ == 0) {\n            return 0\n        }\n        var buckets = List[Long]()\n\
    \        for (i <- 0 until totalBuckets) {\n            buckets += grid(i)(0).toLong\n\
    \        }\n        var numBuckets = 0\n        var currentBucket = 0\n      \
    \  var currentBucketCapacity = 0\n        while (buckets.nonEmpty) {\n       \
    \     if (currentBucketCapacity >= capacity) {\n                numBuckets +=\
    \ 1\n                currentBucketCapacity -= capacity\n                currentBucket\
    \ += 1\n            }\n            val availableCapacity = currentBucketCapacity\
    \ - grid(currentBucket)(1).toLong\n            buckets = buckets.dropWhile(bucket\
    \ => bucket <= availableCapacity)\n            currentBucketCapacity -= grid(currentBucket)(1).toLong\n\
    \        }\n        return numBuckets\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 1l.toLong,\
    \ 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong, 0l.toLong), List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (1l)) == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpx4yfrb1a.scala:32:20 ------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m            buckets += grid(i)(\e[31m0\e[0m).toLong\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    value +=\
    \ is not a member of List[Long] - did you mean List[Long].!=?\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpx4yfrb1a.scala:40:38 ------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m                currentBucketCapacity -= capacity\n\e\
    [31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                value -= is not a member of Int - did you mean Int.!=?\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpx4yfrb1a.scala:45:34 ------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m            currentBucketCapacity -= grid(currentBucket)(\e\
    [31m1\e[0m).toLong\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m            value -= is not a member of Int - did you mean\
    \ Int.!=?\n3 errors found\n"
  stdout: ''
  timestamp: 1659979304
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val rowSum = grid.sum\n        val maxVal = Math.min(rowSum,\
    \ capacity)\n        val counter = collection.mutable.HashMap.empty[Long, Int]\n\
    \        for (row <- grid.indices) {\n            for (column <- grid) {\n   \
    \             if (rowSum - row.toLong >= maxVal) {\n                    maxVal\
    \ -= row.toLong\n                    counter.put(row.toLong, counter.getOrElse(row.toLong,\
    \ 0) + 1l)\n                }\n            }\n        }\n        val res = counter.filter{\
    \ case (count, value) => (value - count) > 0 }\n        return res.map(_._1).sum\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmplb5ch32_.scala:26:29 -----------------------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mrowSum\e[0m = grid.sum\n\
    \e[31m\e[31m   |\e[0m                             ^\e[0m\n\e[31m   |\e[0m    \
    \        No implicit Ordering defined for B\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \            where:    B is a type variable with constraint >: List[Long]\n\e\
    [31m   |\e[0m            .\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmplb5ch32_.scala:33:44\
    \ --------------------\e[0m\e[0m\n\e[31m33 |\e[0m                    counter.put(row.toLong,\
    \ counter.getOrElse(row.toLong, \e[31m0\e[0m) + \e[31m1l\e[0m)\n\e[31m\e[31m \
    \  |\e[0m                                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                            Found:    Long\n\
    \e[31m   |\e[0m                                            Required: Int\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659979306
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val rows        = grid.length\n        val cols        =\
    \ grid[0].length\n        val maxBuckets = math.max(rows,cols)\n        val buckets\
    \     = scala.collection.mutable.ArrayBuffer.fill[Long](maxBuckets)\n        val\
    \ rowsLow     = scala.collection.mutable.ArrayBuffer.empty[Long]\n        val\
    \ colsLow     = scala.collection.mutable.ArrayBuffer.empty[Long]\n        for\
    \ ((i,j) <- 1 to maxBuckets) {\n            if (buckets(i)==0l.toLong && buckets(j)==0l.toLong\
    \ && grid[i][j].toLong==1l.toLong && i<rows && j<cols) {\n                buckets(i)\
    \ = grid[i][j].toLong\n                buckets(j) = 0l.toLong\n            }\n\
    \        }\n        for (i <- 1 to maxBuckets) {\n            if (buckets(i).toLong==1l.toLong)\
    \ {\n                rowsLow += buckets(i).toLong\n                colsLow +=\
    \ buckets(i).toLong\n            }\n        }\n        rowsLow.length\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpqo88uigf.scala:27:30 -----------------------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mcols\e[0m        = grid[\e\
    [31m0\e[0m].length\n\e[31m\e[31m   |\e[0m                          ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m        \e[33mmethod\e[0m \e[35mapply\e[0m in \e[33mtrait\e[0m\
    \ \e[35mLinearSeqOps\e[0m does not take type parameters\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpqo88uigf.scala:33:24 --------------------\e[0m\e\
    [0m\n\e[31m33 |\e[0m            \e[33mif\e[0m (buckets(i)==\e[31m0l\e[0m.toLong\
    \ && buckets(j)==\e[31m0l\e[0m.toLong && grid[\e[35mi\e[0m][\e[35mj\e[0m].toLong==\e\
    [31m1l\e[0m.toLong && i<rows && j<cols) {\n\e[31m\e[31m   |\e[0m             \
    \           ^\e[0m\n\e[31m   |\e[0m                        Found:    (i : Any)\n\
    \e[31m   |\e[0m                        Required: Long\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpqo88uigf.scala:33:49 --------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m            \e[33mif\e[0m (buckets(i)==\e[31m0l\e[0m.toLong\
    \ && buckets(j)==\e[31m0l\e[0m.toLong && grid[\e[35mi\e[0m][\e[35mj\e[0m].toLong==\e\
    [31m1l\e[0m.toLong && i<rows && j<cols) {\n\e[31m\e[31m   |\e[0m             \
    \                                    ^\e[0m\n\e[31m   |\e[0m                 \
    \                                Found:    (j : Any)\n\e[31m   |\e[0m        \
    \                                         Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpqo88uigf.scala:33:74 ------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m            \e[33mif\e[0m (buckets(i)==\e[31m0l\e[0m.toLong\
    \ && buckets(j)==\e[31m0l\e[0m.toLong && grid[\e[35mi\e[0m][\e[35mj\e[0m].toLong==\e\
    [31m1l\e[0m.toLong && i<rows && j<cols) {\n\e[31m\e[31m   |\e[0m             \
    \                                                             ^\e[0m\n\e[31m \
    \  |\e[0m                                                       Not found: type\
    \ j\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e"
  stdout: ''
  timestamp: 1659979308
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        var count = 0\n        var min = Long.MaxValue\n       \
    \ val res = mutable.ArrayBuffer(0)\n        var max = 0\n        for (r <- 0 until\
    \ grid.length){\n            for (c <- 0 until grid[r].length){\n            \
    \    if(max < grid[r][c]){\n                    max = grid[r][c]\n           \
    \     }\n            }\n            if(max < min){\n                min = max\n\
    \            }\n            res += grid[r]\n        }\n        for(i <- 0 until\
    \ res.length){\n            if(res(i) < min)\n                count += 1\n   \
    \     }\n        count\n    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpw9v5gn3x.scala:28:18 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mres\e[0m = mutable.ArrayBuffer(\e\
    [31m0\e[0m)\n\e[31m\e[31m   |\e[0m                  ^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                  Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpw9v5gn3x.scala:31:35 ------------------------\e[0m\e\
    [0m\n\e[31m31 |\e[0m            \e[33mfor\e[0m (c <- \e[31m0\e[0m until grid[\e\
    [35mr\e[0m].length){\n\e[31m\e[31m   |\e[0m                                  \
    \ ^\e[0m\n\e[31m   |\e[0m                                   Not found: type r\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpw9v5gn3x.scala:32:33\
    \ ------------------------\e[0m\e[0m\n\e[31m32 |\e[0m                \e[33mif\e\
    [0m(max < grid[\e[35mr\e[0m][\e[35mc\e[0m]){\n\e[31m\e[31m   |\e[0m          \
    \                       ^\e[0m\n\e[31m   |\e[0m                              \
    \   Not found: type c\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpw9v5gn3x.scala:32:30\
    \ ------------------------\e[0m\e[0m\n\e[31m32 |\e[0m                \e[33mif\e\
    [0m(max < grid[\e[35mr\e[0m][\e[35mc\e[0m]){\n\e[31m\e[31m   |\e[0m          \
    \                    ^\e[0m\n\e[31m   |\e[0m                              Not\
    \ found: type r\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpw9v5gn3x.scala:33:34\
    \ ------------------------\e[0m\e[0m\n\e[31m33 |\e[0m                    max =\
    \ grid[\e[35mr\e[0m][\e[35mc\e[0m]\n\e[31m\e[31m   |\e[0m                    \
    \              ^\e[0m\n\e[31m   |\e[0m                                  Not found:\
    \ type c\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpw9v5gn3x.scala:33:31\
    \ ------------------------\e[0m\e[0m\n\e[31m33 |\e[0m                    max =\
    \ g"
  stdout: ''
  timestamp: 1659979301
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val maxBuckets = grid.toList.flatMap(_.toList).groupBy(_\
    \ % capacity)\n        val sumOfBuckets = grid.toList.flatMap(_.toList).sum\n\
    \        val maxBucketsCap = maxBuckets.map(_._2.length).max\n        val buckets\
    \ = (1 to maxBucketsCap).map(x => 0L).toList ++ maxBuckets.map(_._2.map(y => y).sum).toList\n\
    \        val bucketsCap = buckets.max\n        val numBucketsRem = bucketsCap\
    \ - capacity\n        if(numBucketsRem > 0){\n            maxFill(grid.map(_.removeAll(0))\
    \ ++ grid.map(_.removeAll(0)) ++ buckets.map(_.remove(0)), capacity)\n       \
    \ }else{\n            maxBucketsCap - numBucketsRem \n        }\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpokad0fl4.scala:33:31 ------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m            maxFill(grid.map(_.removeAll(\e[31m0\e[0m))\
    \ ++ grid.map(_.removeAll(\e[31m0\e[0m)) ++ buckets.map(_.remove(\e[31m0\e[0m)),\
    \ capacity)\n\e[31m\e[31m   |\e[0m                             ^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                           value removeAll is not a member of List[Long]\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpokad0fl4.scala:33:59 ------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m            maxFill(grid.map(_.removeAll(\e[31m0\e[0m))\
    \ ++ grid.map(_.removeAll(\e[31m0\e[0m)) ++ buckets.map(_.remove(\e[31m0\e[0m)),\
    \ capacity)\n\e[31m\e[31m   |\e[0m                                           \
    \              ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue removeAll is not a member\
    \ of List[Long], but could be made available as an extension method.\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0mOne of the following imports might fix the problem:\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.seq\
    \ AsJavaList\n\e[31m   |\e[0m  import collection.convert.ImplicitConversionsToJava.seq\
    \ AsJavaList\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.collection\
    \ asJava\n\e[31m   |\e[0m  import collection.convert.ImplicitConversionsToJava.collection\
    \ asJava\n\e[31m   |\e[0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpokad0fl4.scala:33:90\
    \ ------------------------\e[0m\e[0m\n\e[31m33 |\e[0m            maxFill(grid.map(_.removeAll(\e\
    [31m0\e[0m)) ++ grid.map(_.removeAll(\e[31m0\e[0m)) ++ buckets.map(_.remove(\e\
    [31m0\e[0m)), capacity)\n\e[31m\e[31m   |\e[0m                               \
    \                                                         ^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                                    value remove is not a member of\
    \ Long\n3 errors found\n"
  stdout: ''
  timestamp: 1659979305
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        // write your code here\n        grid.foldLeft(0l)((max,\
    \ currentRow) => {\n            if(max == 0) (max += currentRow.foldLeft(0l){(max,\
    \ currentCol) =>\n                if((currentCol % 2) == 0) max += currentCol\n\
    \                else max - currentCol\n            }, 0)\n            else (max\
    \ -= currentRow.foldLeft(0l){(max, currentCol) =>\n                if((currentCol\
    \ % 2) == 0) max += currentCol\n                else max - currentCol\n      \
    \      }, 0)\n        })\n    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpfc4jmy48.scala:28:30 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m            \e[33mif\e[0m(max == \e[31m0\e[0m) (max +=\
    \ currentRow.foldLeft(\e[31m0l\e[0m){(\e[36mmax\e[0m, \e[36mcurrentCol\e[0m) =>\n\
    \e[31m\e[31m   |\e[0m                          ^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \               value += is not a member of Long - did you mean max.!=?\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpfc4jmy48.scala:29:46 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m                \e[33mif\e[0m((currentCol % \e[31m2\e\
    [0m) == \e[31m0\e[0m) max += currentCol\n\e[31m\e[31m   |\e[0m               \
    \                           ^^^^^^\e[0m\n\e[31m   |\e[0m                 value\
    \ += is not a member of Long - did you mean max.!=?\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmpfc4jmy48.scala:32:22 ------------------------\e[0m\e[0m\n\
    \e[31m32 |\e[0m            \e[33melse\e[0m (max -= currentRow.foldLeft(\e[31m0l\e\
    [0m){(max, currentCol) =>\n\e[31m\e[31m   |\e[0m                  ^^^^^^\e[0m\n\
    \e[31m   |\e[0m                 value -= is not a member of Long - did you mean\
    \ max.!=?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpfc4jmy48.scala:33:46\
    \ ------------------------\e[0m\e[0m\n\e[31m33 |\e[0m                \e[33mif\e\
    [0m((currentCol % \e[31m2\e[0m) == \e[31m0\e[0m) max += currentCol\n\e[31m\e[31m\
    \   |\e[0m                                          ^^^^^^\e[0m\n\e[31m   |\e\
    [0m                 value += is not a member of Long - did you mean max.!=?\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1659979306
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val rowMax = grid.head.map(x => x.toLong)\n        val colMax\
    \ = grid.last.map(x => x.toLong)\n        val gridSize = grid.length\n       \
    \ val colSum = grid.map(_.toLong).sum\n        val rowSum = grid.map(_.toLong).sum\n\
    \        val currentCapacity = colSum * (rowSum / gridSize) * (colSum / rowSum)\n\
    \        var count = 0\n        var j = 0\n        for (i <- 0 to (gridSize -\
    \ 1)) {\n            while (j < colSum) {\n                if (gridSize(i) - capacity\
    \ <= j) {\n                    count += 1\n                    j = 0\n       \
    \         }\n                j += 1\n            }\n        }\n        count\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp8bj9zr8s.scala:29:32 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mcolSum\e[0m = grid.map(_.toLong).sum\n\
    \e[31m\e[31m   |\e[0m                              ^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mvalue toLong is not a member of List[Long], but could be made available as\
    \ an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports\
    \ might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e[0m  import\
    \ math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import math.Numeric.Implicits.infixNumericOps\n\
    \e[31m   |\e[0m\n\e[31m\e[31m-- Error: /tmp/tmp8bj9zr8s.scala:29:43 -----------------------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mcolSum\e[0m = grid.map(_.toLong).sum\n\
    \e[31m\e[31m   |\e[0m                                           ^\e[0m\n\e[31m\
    \   |\e[0mambiguous given instances: both \e[33mobject\e[0m \e[35mBigDecimalIsFractional\e\
    [0m in \e[33mobject\e[0m \e[35mNumeric\e[0m and \e[33mobject\e[0m \e[35mFloatIsFractional\e\
    [0m in \e[33mobject\e[0m \e[35mNumeric\e[0m match type Numeric[B] of parameter\
    \ num of \e[33mmethod\e[0m \e[35msum\e[0m in \e[33mtrait\e[0m \e[35mIterableOnceOps\e\
    [0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp8bj9zr8s.scala:30:32 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mrowSum\e[0m = grid.map(_.toLong).sum\n\
    \e[31m\e[31m   |\e[0m                              ^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mvalue toLong is not a member of List[Long], but could be made available as\
    \ an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports\
    \ might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e[0m  import\
    \ math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import math.Numeric.Implicits.infixNumericOps\n\
    \e[31m   |\e[0m\n\e[31m\e[31m-- Error: /tmp/tmp8bj9zr8s.scala:30:43 -----------------------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mrowSum\e[0"
  stdout: ''
  timestamp: 1659979308
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        var counter = Long.MaxValue\n        for (i <- 1 to grid.length-1)\
    \ {\n            for (j <- 1 to grid[i].length-1) {\n                counter +=\
    \ 1\n                if (grid(i-1,j-1)+capacity<=grid[i][j]) {\n             \
    \       grid(i-1,j-1) = grid[i][j]\n                    counter = maxFill((grid,capacity),counter)\n\
    \                }\n            }\n        }\n        counter\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp6zy1q33d.scala:28:32 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m            \e[33mfor\e[0m (j <- \e[31m1\e[0m to grid[\e\
    [35mi\e[0m].length-\e[31m1\e[0m) {\n\e[31m\e[31m   |\e[0m                    \
    \            ^\e[0m\n\e[31m   |\e[0m                                Not found:\
    \ type i\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp6zy1q33d.scala:30:25\
    \ --------------------\e[0m\e[0m\n\e[31m30 |\e[0m                \e[33mif\e[0m\
    \ (grid(i-\e[31m1\e[0m,j-\e[31m1\e[0m)+capacity<=grid[\e[35mi\e[0m][\e[35mj\e\
    [0m]) {\n\e[31m\e[31m   |\e[0m                         ^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                         Found:    (Int, Int)\n\e[31m   |\e[0m       \
    \                  Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmp6zy1q33d.scala:31:20 ------------------------\e[0m\e[0m\n\e[31m31 |\e\
    [0m                    grid(i-\e[31m1\e[0m,j-\e[31m1\e[0m) = grid[\e[35mi\e[0m][\e\
    [35mj\e[0m]\n\e[31m\e[31m   |\e[0m                    ^^^^\e[0m\n\e[31m   |\e\
    [0mvalue update is not a member of List[List[Long]] - did you mean grid.updated?\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp6zy1q33d.scala:31:44 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m                    grid(i-\e[31m1\e[0m,j-\e[31m1\e[0m)\
    \ = grid[\e[35mi\e[0m][\e[35mj\e[0m]\n\e[31m\e[31m   |\e[0m                  \
    \                          ^\e[0m\n\e[31m   |\e[0m                           \
    \                 Not found: type j\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp6zy1q33d.scala:31:41 ------------------------\e[0m\e[0m\n\e[31m31 |\e\
    [0m                    grid(i-\e[31m1\e[0m,j-\e[31m1\e[0m) = grid[\e[35mi\e[0m][\e\
    [35mj\e[0m]\n\e[31m\e[31m   |\e[0m                                         ^\e\
    [0m\n\e[31m   |\e[0m                                         Not found: type i\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain"
  stdout: ''
  timestamp: 1659979308
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        require(grid.length == grid(0).length)\n        var max\
    \ = 0\n        var i = 0\n        var j = 0\n        while (i < grid.length) {\n\
    \            while (j < grid[0].length && grid(i)(j) < capacity) j++\n       \
    \     while (j < grid[0].length && grid(i)(j) == capacity) j++\n            if\
    \ (j == grid[0].length) j = 0\n            max = Math.max(max, j)\n          \
    \  i += 1\n        }\n        max\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 1l.toLong,\
    \ 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong, 0l.toLong), List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (1l)) == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmply4gbfv2.scala:31:67 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m            \e[33mwhile\e[0m (j < grid[\e[31m0\e[0m].length\
    \ && grid(i)(j) < capacity) j++\n\e[31m\e[31m   |\e[0m                       \
    \                                            ^\e[0m\n\e[31m   |\e[0m         \
    \                            expression expected but \e[31mwhile\e[0m found\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- Error: /tmp/tmply4gbfv2.scala:31:27 -----------------------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m            \e[33mwhile\e[0m (j < grid[\e[31m0\e[0m].length\
    \ && grid(i)(j) < capacity) j++\n\e[31m\e[31m   |\e[0m                       ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        \e[33mmethod\e[0m \e[35mapply\e[0m in \e[33mtrait\e\
    [0m \e[35mLinearSeqOps\e[0m does not take type parameters\n\e[31m\e[31m-- Error:\
    \ /tmp/tmply4gbfv2.scala:33:25 -----------------------------------------\e[0m\e\
    [0m\n\e[31m33 |\e[0m            \e[33mif\e[0m (j == grid[\e[31m0\e[0m].length)\
    \ j = \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m        \e[33mmethod\e[0m \e[35mapply\e[0m in \e[33mtrait\e[0m \e\
    [35mLinearSeqOps\e[0m does not take type parameters\n3 errors found\n"
  stdout: ''
  timestamp: 1659979302
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val n = grid.length\n        val m = grid.head.size\n  \
    \      val x = new mutable.HashMap[Long, Int]()\n        var cur = 0\n       \
    \ for (i <- 0 until n) {\n            for (j <- 0 until m) {\n               \
    \ if (grid(i)(j) != 0) {\n                    val k = capacity.toInt - (grid(i)(j)\
    \ * capacity)\n                    if (k > 0) {\n                        val v\
    \ = x(grid(i)(j))\n                        if (v < k) {\n                    \
    \        x(grid(i)(j)) = k\n                            cur = cur + k\n      \
    \                  }\n                    }\n                }\n            }\n\
    \        }\n        cur\n    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp43t4ov9u.scala:28:20 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mx\e[0m = \e[33mnew\e[0m\
    \ mutable.HashMap[\e[35mLong\e[0m, \e[35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                  ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp43t4ov9u.scala:38:34\
    \ --------------------\e[0m\e[0m\n\e[31m38 |\e[0m                            cur\
    \ = cur + k\n\e[31m\e[31m   |\e[0m                                  ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Found:    Long\n\e[31m \
    \  |\e[0m                                  Required: Int\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659979306
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val height = (grid map _.length).toSet\n        val width\
    \ = (grid map _.last).toSet\n        val grid = (grid map (_.toList).toList)\n\
    \        if (grid.length == 1) 0\n        else if (width.size < height) width.size\
    \ * capacity\n        else if (height.size < width) height.size * capacity\n \
    \       else (height.size + width.size) * (capacity/2)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E081] Type Error: /tmp/tmpi9k6r_zx.scala:26:31 -----------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mheight\e[0m = (grid map\
    \ _.length).toSet\n\e[31m\e[31m   |\e[0m                               ^\e[0m\n\
    \e[31m   |\e[0m   Missing parameter type\n\e[31m   |\e[0m\n\e[31m   |\e[0m   I\
    \ could not infer the type of the parameter _$1 of expanded function:\n\e[31m\
    \   |\e[0m   _$1 => grid map _$1.length.\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmpi9k6r_zx.scala:28:20 ---------------------------\e[0m\e[0m\n\e[31m28\
    \ |\e[0m        \e[33mval\e[0m \e[36mgrid\e[0m = (grid map (_.toList).toList)\n\
    \e[31m\e[31m   |\e[0m                    ^\e[0m\n\e[31m   |\e[0m             \
    \       Recursive \e[33mvalue\e[0m \e[35mgrid\e[0m needs type\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E081] Type Error: /tmp/tmpi9k6r_zx.scala:27:30 -----------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mwidth\e[0m = (grid map _.last).toSet\n\
    \e[31m\e[31m   |\e[0m                              ^\e[0m\n\e[31m   |\e[0m   Missing\
    \ parameter type\n\e[31m   |\e[0m\n\e[31m   |\e[0m   I could not infer the type\
    \ of the parameter _$2 of expanded function:\n\e[31m   |\e[0m   _$2 => grid map\
    \ _$2.last.\n3 errors found\n"
  stdout: ''
  timestamp: 1659979302
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        var max = 0\n        var current = 0\n        var currentMax\
    \ = 0\n        var currentMin = 0\n        var bucket = mutable.BitSet(capacity)\n\
    \        for (row <- grid.indices) {\n            val temp = grid[row]\n     \
    \       var next = 0\n            var j = 0\n            var k = 0\n         \
    \   var count = 0\n            var prev = 0\n            while (j < temp.length)\
    \ {\n                if (temp(j) == 1) {\n                    bucket.set(temp)\n\
    \                    count = count + 1\n                    if (count == 1) next\
    \ = temp(j)\n                    if (prev == 0) prev = temp(j)\n             \
    \       if (prev != 0) {\n                        current = k\n              \
    \          currentMin = k\n                        currentMax = k\n          \
    \              bucket.clear(prev)\n                        bucket.clear(next)\n\
    \                        count = 0\n                    }\n                  \
    \  prev = temp(j)\n                    next = temp(j)\n                    k =\
    \ k + 1\n                }\n                j = (j + 1) % temp.length\n      \
    \      }\n            current = k\n            currentMin = k\n            currentMax\
    \ = k\n            bucket.clear(prev)\n            bucket.clear(next)\n      \
    \      bucket.clear(current)\n        }\n        for (bucket <- bucket.iterator)\
    \ {\n            current = bucket.nextClearBit(0)\n            if (current > currentMax)\
    \ {\n                max = currentMax\n            }\n            else if (current\
    \ < currentMin) {\n                max = currentMin\n            }\n         \
    \   else {\n                max = current\n            }\n        }\n        return\
    \ max\n    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmu4a3v1p.scala:30:21 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mvar\e[0m \e[36mbucket\e[0m = mutable.BitSet(capacity)\n\
    \e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \               Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpmu4a3v1p.scala:32:28 ------------------------\e[0m\e[0m\n\e[31m32 |\e\
    [0m            \e[33mval\e[0m \e[36mtemp\e[0m = grid[\e[35mrow\e[0m]\n\e[31m\e\
    [31m   |\e[0m                            ^^^\e[0m\n\e[31m   |\e[0m           \
    \                 Not found: type row\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659979303
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = mutable.Map[Long, Long]()\n        var total\
    \ = 0\n        var count = 0\n        for (r <- 1 to grid.length) {\n        \
    \    for (c <- 1 to grid(r).length) {\n                if (c != grid(r).length)\
    \ {\n                    buckets += ((grid(r).length, c) -> grid[r](c))\n    \
    \            }\n            }\n            total += grid(r).sum\n            count\
    \ += 1\n        }\n        var index = 0\n        var max = 0\n        for (bucket\
    \ <- buckets) {\n            if ((bucket._1 -> bucket._2) < (max -> grid[(bucket._2).floor.toLong]).sum)\
    \ {\n                max = bucket._1 -> bucket._2\n                index = bucket._1\n\
    \            }\n        }\n        total += max\n        count -= 1\n        count\
    \ += index\n        total += count\n        return total\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp9ef_bf_2.scala:41:67 ---------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m            \e[33mif\e[0m ((bucket._1 -> bucket._2) <\
    \ (max -> grid[(bucket._2).floor.toLong]).sum) {\n\e[31m\e[31m   |\e[0m      \
    \                                                             ^\e[0m\n\e[31m \
    \  |\e[0m                                             ']' expected, but '.' found\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp9ef_bf_2.scala:26:22 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mbuckets\e[0m = mutable.Map[\e\
    [35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                     \
    \ ^^^^^^^\e[0m\n\e[31m   |\e[0m                      Not found: mutable\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp9ef_bf_2.scala:35:18 ------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m            total += grid(r).sum\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^^\e[0m\n\e[31m   |\e[0m            value += is not a member\
    \ of Int - did you mean Int.!=?\n3 errors found\n"
  stdout: ''
  timestamp: 1659979308
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val maxCol = grid.map(_.length).max\n        val maxRow\
    \ = grid.maxBy(_.length).getOrElse(0 :: Nil).length\n        val map = mutable.Map[Int,\
    \ (Int, Int)]().withDefaultValue((maxRow, maxCol))\n        for (row <- 0 until\
    \ maxRow; col <- 0 until maxCol)\n            map += (row -> col) -> (row,col)\n\
    \        \n        val totalFills = 0 until map.length\n        \n        while(map.length\
    \ > 0) {\n            val (row, col) = map.head\n            totalFills += 1\n\
    \            map.remove(col).foreach(m => map -= (col._1 -> m))\n        }\n \
    \       \n        totalFills * capacity\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 1l.toLong,\
    \ 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong, 0l.toLong), List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (1l)) == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpyt1qhs1m.scala:27:42 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mmaxRow\e[0m = grid.maxBy(_.length).getOrElse(\e\
    [31m0\e[0m :: Nil).length\n\e[31m\e[31m   |\e[0m                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                     value getOrElse is not a member of List[Long]\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpyt1qhs1m.scala:28:18 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mmap\e[0m = mutable.Map[\e\
    [35mInt\e[0m, (\e[35mInt\e[0m, \e[35mInt\e[0m)]().withDefaultValue((maxRow, maxCol))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^\e[0m\n\e[31m   |\e[0m         \
    \         Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmpyt1qhs1m.scala:35:17 ---------------------------\e[0m\e[0m\n\e[31m35\
    \ |\e[0m            \e[33mval\e[0m (row, col) = map.head\n\e[31m\e[31m   |\e[0m\
    \                 ^\e[0m\n\e[31m   |\e[0m                 Recursive \e[33mvalue\e\
    [0m \e[35m$1$\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmpyt1qhs1m.scala:35:22 ---------------------------\e[0m\e[0m\n\e[31m35\
    \ |\e[0m            \e[33mval\e[0m (row, col) = map.head\n\e[31m\e[31m   |\e[0m\
    \                      ^\e[0m\n\e[31m   |\e[0m                      Recursive\
    \ \e[33mvalue\e[0m \e[35m$1$\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpyt1qhs1m.scala:36:23 ------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m            totalFills += \e[31m1\e[0m\n\e[31m\e[31m\
    \   |\e[0m            ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m         value += is\
    \ not a member of Range - did you mean totalFills.!=?\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmpyt1qhs1m.scala:40:19 ------------------------\e[0m\e[0m\n\
    \e[31m40 |\e[0m        totalFills * capacity\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue * is not a member of Range, "
  stdout: ''
  timestamp: 1659979312
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = grid.map{case List(a,b,c,d) => (a.toLong,b.toLong,c.toLong,d.toLong)}\n\
    \        val map = buckets.toMap\n        val fillableBuckets = map.filter(_._2.toLong\
    \ - _._2.toLong < capacity).toList\n        fillableBuckets.map(_._1.toLong).sum\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpbtbvj623.scala:27:31 -----------------------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mmap\e[0m = buckets.toMap\n\
    \e[31m\e[31m   |\e[0m                               ^\e[0m\n\e[31m   |\e[0m  \
    \                 Cannot prove that (Long, Long, Long, Long) <:< (K, V)\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m                   where:    K is a type variable\n\
    \e[31m   |\e[0m                             V is a type variable\n\e[31m   |\e\
    [0m                   .\n1 error found\n"
  stdout: ''
  timestamp: 1659979311
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val result = mutable.Map[Long, List[List[Long]]]()\n\n \
    \       // fill each row with empty buckets\n        for(i <- 0 until grid.length)\n\
    \            for(j <- 0 until grid[i].length)\n                if((grid(i,j) %\
    \ 2) == 0)\n                    result(grid(i,j)) = List(List(grid(i,j))) :: result(grid(i,j))\n\
    \                else\n                    result(grid(i,j)) = List(List(grid(i,j)))\
    \ :: result(grid(i,j))\n\n        // fill each bucket with water\n        val\
    \ buckets = mutable.Map[Long, Long]()\n        for(i <- 0 until capacity.toInt)\n\
    \            buckets(i) = 0\n\n        for(i <- 0 until grid.length)\n       \
    \     for(j <- 0 until grid[i].length)\n                if((grid(i,j) % 2) ==\
    \ 0)\n                    buckets(result(grid(i,j))(1)) = grid(i,j)\n        \
    \        else\n                    buckets(result(grid(i,j))(2)) = grid(i,j)\n\
    \n        val current = 0L\n        val count = 0L\n        while(current <= capacity.toInt)\
    \ {\n            val next = buckets(current).toInt\n            buckets(current)\
    \ = current + 1\n            current++\n            if(buckets(current) < capacity.toInt)\
    \ {\n                if(buckets(next) == 0)\n                    count += 1\n\
    \                buckets(current) = next + 1\n            }\n            buckets(current)\
    \ = 0L\n        }\n        count\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 1l.toLong,\
    \ 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong, 0l.toLong), List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (1l)) == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpflvsu1l_.scala:53:21 ---------------------------\e\
    [0m\e[0m\n\e[31m53 |\e[0m            current++\n\e[31m\e[31m   |\e[0m        \
    \             ^\e[0m\n\e[31m   |\e[0m                     expression expected\
    \ but \e[31mif\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpflvsu1l_.scala:26:21 ------------------------\e[0m\e[0m\n\e[31m26 |\e\
    [0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.Map[\e[35mLong\e[0m, \e\
    [35mList\e[0m[\e[35mList\e[0m[\e[35mLong\e[0m]]]()\n\e[31m\e[31m   |\e[0m    \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpflvsu1l_.scala:30:34\
    \ ------------------------\e[0m\e[0m\n\e[31m30 |\e[0m            \e[33mfor\e[0m(j\
    \ <- \e[31m0\e[0m until grid[\e[35mi\e[0m].length)\n\e[31m\e[31m   |\e[0m    \
    \                              ^\e[0m\n\e[31m   |\e[0m                       \
    \           Not found: type i\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpflvsu1l_.scala:31:25 --------------------\e[0m\e[0m\n\e[31m31\
    \ |\e[0m                \e[33mif\e[0m((grid(i,j) % \e[31m2\e[0m) == \e[31m0\e\
    [0m)\n\e[31m\e[31m   |\e[0m                         ^^^\e[0m\n\e[31m   |\e[0m\
    \                         Found:    (Int, Int)\n\e[31m   |\e[0m              \
    \           Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpflvsu1l_.scala:37:22 ------------------------\e[0m\e[0m\n\e[31m37 |\e\
    [0m        \e[33mval\e[0m \e[36mbuckets\e[0m = mutable.Map[\e[35mLong\e[0m, \e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpflvsu1l_.scala:42:34 -------"
  stdout: ''
  timestamp: 1659979314
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        require(grid.length == grid[0].length)\n        require(grid.length\
    \ == grid[1].length)\n        require(grid.length == grid[2].length)\n       \
    \ require(capacity >= 1)\n        require(grid.length >= 3)\n\n        val numWells\
    \ = grid[0].length\n        val bucketCapacities = grid\n            .map(_.map(_.toLong))\n\
    \            .map(_.toArray.toList)\n            .map(_.toList)\n            .map(_.toList)\n\
    \            .map(_.toList)\n            .map(_.toList)\n            .map(_.toList)\n\
    \            .map(_.toList)\n            .map(_.toList)\n            .map(_.toList)\n\
    \            .map(_.toList)\n            .map(_.toList)\n            .map(_.toList)\n\
    \            .map(_.toList)\n            .map(_.toList)\n            .map(_.toList)\n\
    \            .map(_.toList)\n            .map(_.toList)\n            .map(_.toList)\n\
    \            .map(_.toList)\n            .map(_.toList)\n            .map(_.toList)\n\
    \            .map(_.toList)\n            .map(_.toList)\n            .map(_.toList)\n\
    \            .map(_.toList)\n            .map(_.toList)\n            .map(_.toList)\n\
    \            .map(_.toList)\n            .map(_.toList)\n            .map(_.toList)\n\
    \            .map(_.toList)\n            .map(_.toList)\n            .map(_.toList)\n\
    \            .map(_.toList)\n            .map(_.toList)\n            .map(_.toList)\n\
    \            .map(_.toList)\n            .map(_.toList)\n            .map(_.toList)\n\
    \            .map(_.toList)\n            .map(_.toList)\n            .map(_.toList)\n\
    \            .map(_.toList)\n            .map(_.toList)\n            .map(_.toList)\n\
    \            .map(_.toList)\n            .map(_.toList)\n            .map(_.toList)\n\
    \            .map(_.toList)\n            .map(_.toList)\n            .map(_.toList)\n\
    \            .map(_.toList)\n            .map(_.toList)\n            .map(_.toList)\n\
    \            .map(_.toList)\n            .map(_.toList)\n            .map(_.toList)\n\
    \            .map(_.toList)\n            .map(_.toList)\n            .map(_.toList)\n\
    \            .map(_.toList)\n            .map(_.toList)\n            .map(_.toList)\n\
    \            .map(_.toList)\n            .map(_.toList)\n            .map(_.toList)\n\
    \            .map(_.toList)\n            .map(_.toList)\n            .map(_.toList)\n\
    \            .map(_.toList)\n            .map(_.toList)\n            .map(_.toList)\n\
    \            .map(_.to\n    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp79ti1s7n.scala:108:4 ---------------------------\e\
    [0m\e[0m\n\e[31m108 |\e[0m    }\n\e[31m\e[31m    |\e[0m    ^\e[0m\n\e[31m    |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- Error: /tmp/tmp79ti1s7n.scala:26:35\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m26 |\e[0m       \
    \ require(grid.length == grid[\e[31m0\e[0m].length)\n\e[31m\e[31m   |\e[0m   \
    \                            ^^^^^^^\e[0m\n\e[31m   |\e[0m        \e[33mmethod\e\
    [0m \e[35mapply\e[0m in \e[33mtrait\e[0m \e[35mLinearSeqOps\e[0m does not take\
    \ type parameters\n\e[31m\e[31m-- Error: /tmp/tmp79ti1s7n.scala:27:35 -----------------------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        require(grid.length == grid[\e[31m1\e[0m].length)\n\
    \e[31m\e[31m   |\e[0m                               ^^^^^^^\e[0m\n\e[31m   |\e\
    [0m        \e[33mmethod\e[0m \e[35mapply\e[0m in \e[33mtrait\e[0m \e[35mLinearSeqOps\e\
    [0m does not take type parameters\n\e[31m\e[31m-- Error: /tmp/tmp79ti1s7n.scala:28:35\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m28 |\e[0m       \
    \ require(grid.length == grid[\e[31m2\e[0m].length)\n\e[31m\e[31m   |\e[0m   \
    \                            ^^^^^^^\e[0m\n\e[31m   |\e[0m        \e[33mmethod\e\
    [0m \e[35mapply\e[0m in \e[33mtrait\e[0m \e[35mLinearSeqOps\e[0m does not take\
    \ type parameters\n\e[31m\e[31m-- Error: /tmp/tmp79ti1s7n.scala:32:27 -----------------------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mnumWells\e[0m = grid[\e\
    [31m0\e[0m].length\n\e[31m\e[31m   |\e[0m                       ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m        \e[33mmethod\e[0m \e[35mapply\e[0m in \e[33mtrait\e[0m\
    \ \e[35mLinearSeqOps\e[0m does not take type parameters\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmp79ti1s7n.scala:108:5 --------------------\e[0m\e\
    [0m\n\e[31m108 |\e[0m    }\n\e[31m\e[31m    |\e[0m     ^\e[0m\n\e[31m    |\e[0m\
    \     Found:    Unit\n\e[31m    |\e[0m     Required: Long\n\e[31m    |\e[0m\n\e\
    [31m    |\e[0m longer explanation available when compiling with `-explain`\n6\
    \ errors found\n"
  stdout: ''
  timestamp: 1659979315
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val m = new mutable.HashMap[Long, Long]()\n        for (i\
    \ <- 0 until grid.length) {\n            for (j <- 0 until grid[0].length) {\n\
    \                if (grid[i][j] > 0) {\n                    m.putIfAbsent(j +\
    \ 1, 0L)\n                    m(j + 1) = m(j + 1) + capacity\n               \
    \ }\n            }\n        }\n        val result = m.toSeq.map(x => x._2 - x._1).max\n\
    \        if (result == 0l) {\n            0\n        } else {\n            result\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpslyh5fnq.scala:26:20 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mm\e[0m = \e[33mnew\e[0m\
    \ mutable.HashMap[\e[35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- Error: /tmp/tmpslyh5fnq.scala:28:34\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m28 |\e[0m       \
    \     \e[33mfor\e[0m (j <- \e[31m0\e[0m until grid[\e[31m0\e[0m].length) {\n\e\
    [31m\e[31m   |\e[0m                              ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \        \e[33mmethod\e[0m \e[35mapply\e[0m in \e[33mtrait\e[0m \e[35mLinearSeqOps\e\
    [0m does not take type parameters\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpslyh5fnq.scala:29:28\
    \ ------------------------\e[0m\e[0m\n\e[31m29 |\e[0m                \e[33mif\e\
    [0m (grid[\e[35mi\e[0m][\e[35mj\e[0m] > \e[31m0\e[0m) {\n\e[31m\e[31m   |\e[0m\
    \                            ^\e[0m\n\e[31m   |\e[0m                         \
    \   Not found: type j\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpslyh5fnq.scala:29:25\
    \ ------------------------\e[0m\e[0m\n\e[31m29 |\e[0m                \e[33mif\e\
    [0m (grid[\e[35mi\e[0m][\e[35mj\e[0m] > \e[31m0\e[0m) {\n\e[31m\e[31m   |\e[0m\
    \                         ^\e[0m\n\e[31m   |\e[0m                         Not\
    \ found: type i\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659979310
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val rowMax = grid.foldLeft((1l, 0l)) { case ((maxRow, maxCol),\
    \ row) =>\n            if (row[maxCol] == 1l) {\n                (maxRow + row[maxCol].toLong,\
    \ maxCol)\n            } else {\n                (maxRow, maxCol)\n          \
    \  }\n        }\n        (maxRow - capacity, rowMax._1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpd4iwx5ma.scala:27:20 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m            \e[33mif\e[0m (row[\e[35mmaxCol\e[0m] ==\
    \ \e[31m1l\e[0m) {\n\e[31m\e[31m   |\e[0m                    ^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                    Not found: type maxCol\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpd4iwx5ma.scala:28:30 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m                (maxRow + row[\e[35mmaxCol\e[0m].toLong,\
    \ maxCol)\n\e[31m\e[31m   |\e[0m                              ^^^^^^\e[0m\n\e\
    [31m   |\e[0m                              Not found: type maxCol\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpd4iwx5ma.scala:33:9 -------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        (maxRow - capacity, rowMax._1)\n\e[31m\e[31m\
    \   |\e[0m         ^^^^^^\e[0m\n\e[31m   |\e[0m         Not found: maxRow\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659979311
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        if (grid.isEmpty) 0\n        else if (grid.head.length !=\
    \ 1) 0\n        else {\n            val row = grid.head\n            val left\
    \ = maxFill(row.tail, 1)\n            val right = maxFill(row.init, capacity)\n\
    \            val fill = left.toLong + right.toLong\n            if (fill > capacity)\
    \ maxFill(grid, capacity)\n            else maxFill(row.init :+ row.tail.head,\
    \ fill)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpe0cgd6gd.scala:30:35\
    \ --------------------\e[0m\e[0m\n\e[31m30 |\e[0m            \e[33mval\e[0m \e\
    [36mleft\e[0m = maxFill(row.tail, \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m       \
    \                        ^^^^^^^^\e[0m\n\e[31m   |\e[0m                      \
    \         Found:    List[Long @uncheckedVariance]\n\e[31m   |\e[0m           \
    \                    Required: List[List[Long]]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpe0cgd6gd.scala:31:36 --------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m            \e[33mval\e[0m \e[36mright\e[0m = maxFill(row.init,\
    \ capacity)\n\e[31m\e[31m   |\e[0m                                ^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                Found:    List[Long @uncheckedVariance]\n\
    \e[31m   |\e[0m                                Required: List[List[Long]]\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpe0cgd6gd.scala:34:25\
    \ --------------------\e[0m\e[0m\n\e[31m34 |\e[0m            \e[33melse\e[0m maxFill(row.init\
    \ :+ row.tail.head, fill)\n\e[31m\e[31m   |\e[0m                         ^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                         Found:    List[Long]\n\e[31m   |\e\
    [0m                         Required: List[\e[1m\e[32mList\e[0m\e[1m\e[32m[\e\
    [0mLong\e[1m\e[32m]\e[0m]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659979315
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val m = grid.map(_.length)\n        val n = grid.map(_.head.length)\n\
    \        var ret = 0\n        for (i <- 0 to m.get(0).max if m.get(i) > 0) {\n\
    \            if (m(i) > 0) {\n                ret += m(i) * n(i)\n           \
    \ }\n        }\n        for (i <- 0 to m.get(m.length - 1).max if m.get(i) > 0)\
    \ {\n            if (m(i) > 0) {\n                ret += m(i) * n(i)\n       \
    \     }\n        }\n        for (i <- 0 to m.get(m.length - 1).max if m.get(i)\
    \ > 0) {\n            if (m(i) > 0) {\n                ret += m(i) * n(i)\n  \
    \          }\n        }\n        for (i <- 0 to m.get(m.length - 1).max if m.get(i)\
    \ > 0) {\n            if (m(i) > 0) {\n                ret += m(i) * n(i)\n  \
    \          }\n        }\n        for (i <- 0 to m.get(m.length - 1).max if m.get(i)\
    \ > 0) {\n            if (m(i) > 0) {\n                ret += m(i) * n(i)\n  \
    \          }\n        }\n        for (i <- 0 to m.get(m.length - 1).max if m.get(i)\
    \ > 0) {\n            if (m(i) > 0) {\n                ret += m(i) * n(i)\n  \
    \          }\n        }\n        return ret\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 1l.toLong,\
    \ 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong, 0l.toLong), List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (1l)) == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp8jmto6xv.scala:27:32 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = grid.map(_.head.length)\n\
    \e[31m\e[31m   |\e[0m                         ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                         value length is not a member of Long\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmp8jmto6xv.scala:29:25 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mfor\e[0m (i <- \e[31m0\e[0m to m.get(\e\
    [31m0\e[0m).max \e[33mif\e[0m m.get(i) > \e[31m0\e[0m) {\n\e[31m\e[31m   |\e[0m\
    \                       ^^^^^\e[0m\n\e[31m   |\e[0mvalue get is not a member of\
    \ List[Int], but could be made available as an extension method.\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mOne of the following imports might fix the problem:\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.seq\
    \ AsJavaList\n\e[31m   |\e[0m  import collection.convert.ImplicitConversionsToJava.seq\
    \ AsJavaList\n\e[31m   |\e[0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp8jmto6xv.scala:29:41\
    \ ------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mfor\e[0m (i\
    \ <- \e[31m0\e[0m to m.get(\e[31m0\e[0m).max \e[33mif\e[0m m.get(i) > \e[31m0\e\
    [0m) {\n\e[31m\e[31m   |\e[0m                                       ^^^^^\e[0m\n\
    \e[31m   |\e[0mvalue get is not a member of List[Int], but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.seq\
    \ AsJavaList\n\e[31m   |\e[0m  import collection.convert.ImplicitConversionsToJava.seq\
    \ AsJavaList\n\e[31m   |\e[0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp8jmto6xv.scala:31:20\
    \ ------------------------\e[0m\e[0m\n\e[31m31 |\e[0m                ret += m(i)\
    \ * n(i)\n\e[31m\e[31m   |\e[0m                ^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \              value += is not a member of Int - did you mean Int.!=?\n\e[31m\e\
    [31m-- [E051] Reference Error: /tmp/tmp8jmto6xv.scala:31:28 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m                ret += m(i) * n(i)\n\e[31m\e[31m   |\e\
    [0m                   "
  stdout: ''
  timestamp: 1659979321
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        // Write your code here.\n        val minVal = math.min(grid.map(_.length).max,\n\
    \                             grid.map(_(1).length).max)\n        val maxVal =\
    \ math.min(grid.map(_.length).max,\n                             grid.map(_(1).length).max)\n\
    \        val delta = (capacity / minVal)\n        var count = 0\n        for(i\
    \ <- 0 to maxVal-minVal) {\n            val l1 = i / delta\n            val l2\
    \ = i % delta\n            val min = l1 * delta + l2\n            val max = l1\
    \ * delta + delta + l2\n            if (grid((min+minVal).toInt, (max+maxVal).toInt).length\
    \ < capacity) count = count+1\n        }\n        count\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp4q5t7p1p.scala:28:43 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m                             grid.map(_(\e[31m1\e[0m).length).max)\n\
    \e[31m\e[31m   |\e[0m                                      ^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                                    value length is not a member\
    \ of Long\n\e[31m\e[31m-- Error: /tmp/tmp4q5t7p1p.scala:28:54 -----------------------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m                             grid.map(_(\e[31m1\e[0m).length).max)\n\
    \e[31m\e[31m   |\e[0m                                                      ^\e\
    [0m\n\e[31m   |\e[0mambiguous given instances: both \e[33mobject\e[0m \e[35mInt\e\
    [0m in \e[33mobject\e[0m \e[35mOrdering\e[0m and \e[33mobject\e[0m \e[35mChar\e\
    [0m in \e[33mobject\e[0m \e[35mOrdering\e[0m match type Ordering[B] of parameter\
    \ ord of \e[33mmethod\e[0m \e[35mmax\e[0m in \e[33mtrait\e[0m \e[35mIterableOnceOps\e\
    [0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp4q5t7p1p.scala:30:43 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m                             grid.map(_(\e[31m1\e[0m).length).max)\n\
    \e[31m\e[31m   |\e[0m                                      ^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                                    value length is not a member\
    \ of Long\n\e[31m\e[31m-- Error: /tmp/tmp4q5t7p1p.scala:30:54 -----------------------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m                             grid.map(_(\e[31m1\e[0m).length).max)\n\
    \e[31m\e[31m   |\e[0m                                                      ^\e\
    [0m\n\e[31m   |\e[0mambiguous given instances: both \e[33mobject\e[0m \e[35mInt\e\
    [0m in \e[33mobject\e[0m \e[35mOrdering\e[0m and \e[33mobject\e[0m \e[35mChar\e\
    [0m in \e[33mobject\e[0m \e[35mOrdering\e[0m match type Ordering[B] of parameter\
    \ ord of \e[33mmethod\e[0m \e[35mmax\e[0m in \e[33mtrait\e[0m \e[35mIterableOnceOps\e\
    [0m\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4q5t7p1p.scala:38:21 --------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m            \e[33mif\e[0m (grid((min+minVal).toInt, (max+maxVal).toInt).length\
    \ < capacity) count = count+\e[31m1\e[0m\n\e[31m\e[31m   |\e[0m              \
    \       ^^^^^^^^^"
  stdout: ''
  timestamp: 1659979317
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        var i : Int = 0\n        var j : Int = 0\n        var min\
    \ : Long = Long.MaxValue\n        var max : Long = 0\n        var result : Long\
    \ = 0\n        while (i <= grid.length && j <= grid[0].length && j < grid[0].length\
    \ + 1) {\n            if (grid[i][j] == 1l) {\n                if (capacity >\
    \ max) {\n                    max = capacity\n                }\n            \
    \    min = min + grid[i][j]\n            } else if (grid[i][j] == 0l) {\n    \
    \            if (capacity < min) {\n                    min = capacity\n     \
    \           }\n                max = max + grid[i][j]\n            }\n       \
    \     j += i\n            i += 1\n        }\n        result = max\n        capacity\
    \ = min\n        while (capacity < max) {\n            capacity = capacity / 2\n\
    \        }\n        return result * capacity\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 1l.toLong,\
    \ 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong, 0l.toLong), List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (1l)) == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpb3iu04fh.scala:31:44 -----------------------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mwhile\e[0m (i <= grid.length && j <= grid[\e\
    [31m0\e[0m].length && j < grid[\e[31m0\e[0m].length + \e[31m1\e[0m) {\n\e[31m\e\
    [31m   |\e[0m                                        ^^^^^^^\e[0m\n\e[31m   |\e\
    [0m        \e[33mmethod\e[0m \e[35mapply\e[0m in \e[33mtrait\e[0m \e[35mLinearSeqOps\e\
    [0m does not take type parameters\n\e[31m\e[31m-- Error: /tmp/tmpb3iu04fh.scala:31:66\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m31 |\e[0m       \
    \ \e[33mwhile\e[0m (i <= grid.length && j <= grid[\e[31m0\e[0m].length && j <\
    \ grid[\e[31m0\e[0m].length + \e[31m1\e[0m) {\n\e[31m\e[31m   |\e[0m         \
    \                                                     ^^^^^^^\e[0m\n\e[31m   |\e\
    [0m        \e[33mmethod\e[0m \e[35mapply\e[0m in \e[33mtrait\e[0m \e[35mLinearSeqOps\e\
    [0m does not take type parameters\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpb3iu04fh.scala:32:24\
    \ ------------------------\e[0m\e[0m\n\e[31m32 |\e[0m            \e[33mif\e[0m\
    \ (grid[\e[35mi\e[0m][\e[35mj\e[0m] == \e[31m1l\e[0m) {\n\e[31m\e[31m   |\e[0m\
    \                        ^\e[0m\n\e[31m   |\e[0m                        Not found:\
    \ type j\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpb3iu04fh.scala:32:21\
    \ ------------------------\e[0m\e[0m\n\e[31m32 |\e[0m            \e[33mif\e[0m\
    \ (grid[\e[35mi\e[0m][\e[35mj\e[0m] == \e[31m1l\e[0m) {\n\e[31m\e[31m   |\e[0m\
    \                     ^\e[0m\n\e[31m   |\e[0m                     Not found: type\
    \ i\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpb3iu04fh.scala:36:36\
    \ ------------------------\e[0m\e[0m\n\e[31m36 |\e[0m                min = min\
    \ + grid[\e[35mi\e[0m][\e[35mj\e[0m]\n\e[31m\e[31m   |\e[0m                  \
    \                  ^\e[0m\n\e[31m   |\e[0m                                   \
    \ Not found: type j\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpb3iu0"
  stdout: ''
  timestamp: 1659979313
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val n = grid.length\n        val m = grid[0].length\n  \
    \      val dp = new Array[Long](m)\n        // initialize all values in dp to\
    \ -1\n        for (i <- 0 until m) {\n            dp(i) = -1\n        }\n    \
    \    // fill all cells that have a 1\n        for (i <- 0 until n) {\n       \
    \     val minIndex = math.min(i, m - 1)\n            val maxIndex = math.max(i,\
    \ m - 1)\n            for (j <- minIndex to maxIndex) {\n                if (grid(i)(j)\
    \ != 0) {\n                    dp(i) = math.max(dp(i), dp(i + 1) + grid(i)(j))\n\
    \                }\n            }\n        }\n        // return the max value\
    \ from the dp matrix\n        dp.max\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 1l.toLong,\
    \ 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong, 0l.toLong), List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (1l)) == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpnb69eu7s.scala:27:20 -----------------------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mm\e[0m = grid[\e[31m0\e\
    [0m].length\n\e[31m\e[31m   |\e[0m                ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \        \e[33mmethod\e[0m \e[35mapply\e[0m in \e[33mtrait\e[0m \e[35mLinearSeqOps\e\
    [0m does not take type parameters\n1 error found\n"
  stdout: ''
  timestamp: 1659979314
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        // Write your code here.\n        var res = 0\n        var\
    \ i = grid.length -1\n        var j = grid(0).length -1\n        while (i >= 0)\
    \ {\n            while (j >= 0) {\n                if (grid(i)(j) == 1) {\n  \
    \                  res += 1\n                    i -= 1\n                    j\
    \ -= 1\n                } else {\n                    j -= 1\n               \
    \ }\n            }\n            i -= 1\n        }\n        while (i >= 0) {\n\
    \            while (j >= 0) {\n                if (grid(i)(j) == 0) {\n      \
    \              res += 1\n                    i -= 1\n                    j -=\
    \ 1\n                } else {\n                    j -= 1\n                }\n\
    \            }\n            i -= 1\n        }\n        res\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpsgi34wqz.scala:57)\n\tat Problem.main(tmpsgi34wqz.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979319
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val grid = mutable.ArrayBuffer(grid)\n        grid.map(_.map(x\
    \ => x match {\n            case 0 => -1\n            case 1 => 0\n          \
    \  case -1 => 1\n        }))\n\n        val rows = grid.map(_.size)\n        val\
    \ columns = grid.head.length\n        val capacity = capacity\n\n        val grid\
    \ = mutable.ArrayBuffer(grid)\n        val allBuckets = mutable.ArrayBuffer(capacity\
    \ - 1, capacity - 1, capacity - 1, capacity - 1)\n\n        grid.map { row =>\n\
    \            val bucket = row(0)\n            val newRow = grid.map(row => 0 ::\
    \ row.drop(1): _*)\n\n            allBuckets.map(bucket => (bucket, newRow))\n\
    \        }.flatten.toSeq.sortBy(_._1).reverse map { case (bucket, newRow) =>\n\
    \            val size = newRow.map(x => 0 :: x).sum\n            size match {\n\
    \                case 0 => bucket\n                case _ =>\n               \
    \     if (newRow.map(x => 0 :: x).sum < 0) bucket - 1 else bucket\n          \
    \  }\n        }.foldLeft(0)((acc, curr) => if (curr >= capacity) acc + 1 else\
    \ acc)\n\n    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E031] Syntax Error: /tmp/tmprfv6agx4.scala:42:59 ---------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m            \e[33mval\e[0m \e[36mnewRow\e[0m = grid.map(\e\
    [36mrow\e[0m => \e[31m0\e[0m :: row.drop(\e[31m1\e[0m): \e[35m_*\e[0m)\n\e[31m\e\
    [31m   |\e[0m                                                           ^\e[0m\n\
    \e[31m   |\e[0m                                    * can be used only for last\
    \ argument\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmprfv6agx4.scala:37:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m\
    \ \e[36mgrid\e[0m = mutable.ArrayBuffer(grid)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mgrid is already defined as \e[33mvalue\e[0m \e[35mgrid\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmprfv6agx4.scala:26:19 ------------------------\e[0m\e[0m\n\e[31m26 |\e\
    [0m        \e[33mval\e[0m \e[36mgrid\e[0m = mutable.ArrayBuffer(grid)\n\e[31m\e\
    [31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                \
    \   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmprfv6agx4.scala:35:23\
    \ ---------------------------\e[0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m\
    \ \e[36mcapacity\e[0m = capacity\n\e[31m\e[31m   |\e[0m                      \
    \ ^\e[0m\n\e[31m   |\e[0m                       Recursive \e[33mvalue\e[0m \e\
    [35mcapacity\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmprfv6agx4.scala:38:25 ------------------------\e[0m\e[0m\n\e[31m38 |\e\
    [0m        \e[33mval\e[0m \e[36mallBuckets\e[0m = mutable.ArrayBuffer(capacity\
    \ - \e[31m1\e[0m, capacity - \e[31m1\e[0m, capacity - \e[31m1\e[0m, capacity -\
    \ \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m                         ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                         Not found: mutable\n\e[31"
  stdout: ''
  timestamp: 1659979312
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        var count : Long = 0\n        var buckets : List[List[Long]]\
    \ = Nil\n        var i : Int = 0\n        while (i < grid.length) {\n        \
    \    if (grid(i)(0) > 0) {\n                buckets = buckets :+ grid(i)(0)\n\
    \                count += grid(i)(0)\n                i += 1\n            } else\
    \ {\n                if (grid(i)(0) == 1) {\n                    buckets = buckets\
    \ :+ grid(i)(1)\n                    count += grid(i)(1)\n                   \
    \ i += 1\n                }\n                buckets = buckets :+ capacity\n \
    \               count += capacity\n                i += 1\n            }\n   \
    \     }\n        count\n    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp2vifol4_.scala:31:44\
    \ --------------------\e[0m\e[0m\n\e[31m31 |\e[0m                buckets = buckets\
    \ :+ grid(i)(\e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m                            \
    \         ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                                   \
    \  Found:    Long\n\e[31m   |\e[0m                                     Required:\
    \ \e[1m\e[32mList\e[0m\e[1m\e[32m[\e[0mLong\e[1m\e[32m]\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp2vifol4_.scala:36:48 --------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m                    buckets = buckets :+ grid(i)(\e[31m1\e\
    [0m)\n\e[31m\e[31m   |\e[0m                                         ^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                         Found:    Long\n\e\
    [31m   |\e[0m                                         Required: \e[1m\e[32mList\e\
    [0m\e[1m\e[32m[\e[0mLong\e[1m\e[32m]\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmp2vifol4_.scala:40:37 --------------------\e[0m\e\
    [0m\n\e[31m40 |\e[0m                buckets = buckets :+ capacity\n\e[31m\e[31m\
    \   |\e[0m                                     ^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                                     Found:    (capacity : Long)\n\e[31m   |\e\
    [0m                                     Required: List[Long]\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1659979318
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val rows     = grid.length\n        val columns  = grid(0).toLong\n\
    \n        var count : Long = 0\n        var bucket = capacity\n        for (i\
    \ <- 0 until rows) {\n            val water  = grids(i)\n            val bucket\
    \ = math.max(0, bucket - water)\n            count += math.min(bucket, 1L)\n \
    \       }\n        count\n    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpiso4kprj.scala:27:31 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mcolumns\e[0m  = grid(\e\
    [31m0\e[0m).toLong\n\e[31m\e[31m   |\e[0m                       ^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue toLong is not a member of List[Long], but could be made\
    \ available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the\
    \ following imports might make progress towards fixing the problem:\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpiso4kprj.scala:32:25 ------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m            \e[33mval\e[0m \e[36mwater\e[0m  = grids(i)\n\
    \e[31m\e[31m   |\e[0m                         ^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                     Not found: grids\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659979321
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        grid.map(_.toSet).foldLeft(0l){ (maxValue, nextValue) =>\n\
    \            val buckets = nextValue.toSet\n            if (buckets.size < maxValue)\
    \ maxValue else buckets.min\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 1l.toLong,\
    \ 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong, 0l.toLong), List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (1l)) == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmplkga575o.scala:32)\n\tat Problem.main(tmplkga575o.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979322
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        var ans = -1\n        var i = grid.length\n        var j\
    \ = grid(0).length\n        var bucket = new Array[Long](j)\n        var cnt =\
    \ 0\n        var lower = 1\n        var higher = 1\n        var minBucket = 0\n\
    \        var maxBucket = 0\n\n        while (i-- > 0 && j-- > 0) {\n         \
    \   bucket(j) = 0\n            if (grid(i)(j) == 0) {\n                lower =\
    \ bucket.takeWhile(x => x < 0).last\n                higher = bucket.takeWhile(x\
    \ => x > 0).last\n                minBucket = math.min(minBucket, lower, higher)\n\
    \                maxBucket = math.max(maxBucket, lower, higher)\n            \
    \    cnt += math.min(lower, higher)\n                if (cnt < capacity) {\n \
    \                   bucket(j) = 1\n                }\n            }\n        }\n\
    \        ans = minBucket + math.min(1, minBucket + maxBucket)\n        return\
    \ ans\n    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpiz2qvzc5.scala:36:21 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mwhile\e[0m (i-- > \e[31m0\e[0m && j-- >\
    \ \e[31m0\e[0m) {\n\e[31m\e[31m   |\e[0m                     ^\e[0m\n\e[31m  \
    \ |\e[0m                     ')' expected, but integer literal found\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpiz2qvzc5.scala:36:16 ------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mwhile\e[0m (i-- > \e[31m0\e[0m && j-- >\
    \ \e[31m0\e[0m) {\n\e[31m\e[31m   |\e[0m               ^^^\e[0m\n\e[31m   |\e\
    [0m               value -- is not a member of Int\n\e[31m\e[31m-- [E006] Not Found\
    \ Error: /tmp/tmpiz2qvzc5.scala:36:19 ------------------------\e[0m\e[0m\n\e[31m36\
    \ |\e[0m        \e[33mwhile\e[0m (i-- > \e[31m0\e[0m && j-- > \e[31m0\e[0m) {\n\
    \e[31m\e[31m   |\e[0m                   ^\e[0m\n\e[31m   |\e[0m              \
    \     Not found: >\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpiz2qvzc5.scala:39:53\
    \ --------------------\e[0m\e[0m\n\e[31m39 |\e[0m                lower = bucket.takeWhile(\e\
    [36mx\e[0m => x < \e[31m0\e[0m).last\n\e[31m\e[31m   |\e[0m                  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m               \
    \         Found:    Long\n\e[31m   |\e[0m                        Required: Int\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpiz2qvzc5.scala:40:54\
    \ --------------------\e[0m\e[0m\n\e[31m40 |\e[0m                higher = bucket.takeWhile(\e\
    [36mx\e[0m => x > \e[31m0\e[0m).last\n\e[31m\e[31m   |\e[0m                  \
    \       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m              \
    \           Found:    Long\n\e[31m   |\e[0m                         Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpiz2qvzc5.scala:41:33\
    \ -----------------------------\e[0m\e[0m\n\e[31m41 |\e[0m                minBucket\
    \ = math.min(minBucket, lower, higher)\n\e[31m\e[31m   |\e[0m         "
  stdout: ''
  timestamp: 1659979322
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        def dfs(grid : List[List[Long]], idx : Long, bucket : Long)\
    \ : List[List[Long]] = {\n            if (grid == Nil) Nil\n            else if\
    \ (grid == Nil :&& bucket < capacity) List(List(bucket))\n            else if\
    \ (!grid.isEmpty) {\n                val nextGrid = grid.tail\n              \
    \  val nextBucket = bucket - grid((idx-1).toInt)((idx-1).toInt).toLong\n     \
    \           val nextCanBeEmpty : Boolean = nextGrid.isEmpty && nextBucket < capacity\n\
    \                if (nextCanBeEmpty) dfs(nextGrid, idx+1, nextBucket)\n      \
    \          else {\n                    val nextBuckets = dfs(nextGrid, idx+1,\
    \ nextBucket)\n                    if (nextBuckets == Nil || nextBuckets.head\
    \ < nextBucket) {\n                        nextBuckets :+ List(bucket)\n     \
    \               } else {\n                        nextBuckets\n              \
    \      }\n                }\n            } else Nil\n        }\n        dfs(grid,\
    \ 0, capacity).headOption.getOrElse(0)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 1l.toLong,\
    \ 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong, 0l.toLong), List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (1l)) == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpo_2w_wb8.scala:28:33 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m            \e[33melse\e[0m \e[33mif\e[0m (grid == Nil\
    \ :&& bucket < capacity) List(List(bucket))\n\e[31m\e[31m   |\e[0m           \
    \                  ^^^^^^^\e[0m\n\e[31m   |\e[0mvalue :&& is not a member of object\
    \ scala.collection.immutable.Nil - did you mean Nil.:++?\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpo_2w_wb8.scala:36:63 ------------------------\e[0m\e\
    [0m\n\e[31m36 |\e[0m                    \e[33mif\e[0m (nextBuckets == Nil || nextBuckets.head\
    \ < nextBucket) {\n\e[31m\e[31m   |\e[0m                                     \
    \         ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue < is not a member of List[Long],\
    \ but could be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mOne of the following imports might make progress towards fixing the\
    \ problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Ordered.orderingToOrdered\n\
    \e[31m   |\e[0m  import math.Ordering.Implicits.infixOrderingOps\n\e[31m   |\e\
    [0m\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpo_2w_wb8.scala:44:51 --------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m        dfs(grid, \e[31m0\e[0m, capacity).headOption.getOrElse(\e\
    [31m0\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Matchable\n\e[31m   |\e[0m        Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659979322
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val n = grid.length\n        if (n == 0) 0\n        else\
    \ if (n == 1) 1\n        else if (n == 2 && grid[0][1] > 0) 1\n        else if\
    \ (n == 3) 0\n        else {\n            val buckets = mutable.ArrayBuffer(capacity)\n\
    \            val grid2 = grid.map(_.reverse).map{ case List(a,b,c) => (a,b,c)\
    \ }\n            for ((a,b,c) <- grid2) buckets += 0\n\n            val fillBuckets\
    \ = mutable.ArrayBuffer(grid2.length-1)\n            val bucketsCopy = buckets.toList\n\
    \            val grid3 = (grid2 +++ grid2).toList\n            val res = grid3.map{\
    \ case List(a,b,c) => (a,b,c) }\n            val fillBucketsRes = fillBuckets.toList\n\
    \            val bucketsCopyRes = bucketsCopy.toList\n\n            while (true)\
    \ {\n                if (fillBuckets(0) == 0) return res.length\n            \
    \    val a = fillBuckets(0)\n                val b = fillBuckets(1)\n        \
    \        val c = fillBuckets(2)\n                if (a > 0) fillBuckets(0) = bucketsCopy(bucketsCopy.indexOf(a)\
    \ - 1)\n                if (b > 0) fillBuckets(1) = bucketsCopy(bucketsCopy.indexOf(b)\
    \ - 1)\n                if (c > 0) fillBuckets(2) = bucketsCopy(bucketsCopy.indexOf(c)\
    \ - 1)\n\n                val b = res(fillBuckets(0))\n                val c =\
    \ res(fillBuckets(1))\n                val a = res(fillBuckets(2))\n         \
    \       if (a > 0 && a < n && a.head == 1) fillBuckets(0) = fillBucketsRes(fillBucketsRes.indexOf(a)\
    \ - 1)\n                if (b > 0 && b < n && b.head == 1) fillBuckets(1) = fillBucketsRes(fillBucketsRes.indexOf(b)\
    \ - 1)\n                if (c > 0 && c < n && c.head == 1) fillBuckets(2) = fillBucketsRes(fillBucketsRes.indexOf(c)\
    \ - 1)\n            }\n        }\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 1l.toLong,\
    \ 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong, 0l.toLong), List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (1l)) == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpeaou1nt0.scala:29:31 -----------------------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (n == \e[31m2\e\
    [0m && grid[\e[31m0\e[0m][\e[31m1\e[0m] > \e[31m0\e[0m) \e[31m1\e[0m\n\e[31m\e\
    [31m   |\e[0m                           ^^^^^^^\e[0m\n\e[31m   |\e[0m        \e\
    [33mmethod\e[0m \e[35mapply\e[0m in \e[33mtrait\e[0m \e[35mLinearSeqOps\e[0m does\
    \ not take type parameters\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpeaou1nt0.scala:32:26\
    \ ------------------------\e[0m\e[0m\n\e[31m32 |\e[0m            \e[33mval\e[0m\
    \ \e[36mbuckets\e[0m = mutable.ArrayBuffer(capacity)\n\e[31m\e[31m   |\e[0m  \
    \                        ^^^^^^^\e[0m\n\e[31m   |\e[0m                       \
    \   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpeaou1nt0.scala:36:30\
    \ ------------------------\e[0m\e[0m\n\e[31m36 |\e[0m            \e[33mval\e[0m\
    \ \e[36mfillBuckets\e[0m = mutable.ArrayBuffer(grid2.length-\e[31m1\e[0m)\n\e\
    [31m\e[31m   |\e[0m                              ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                              Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpeaou1nt0.scala:38:31 ------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m            \e[33mval\e[0m \e[36mgrid3\e[0m = (grid2\
    \ +++ grid2).toList\n\e[31m\e[31m   |\e[0m                         ^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue +++ is not a member of List[(Long, Long, Long)] - did\
    \ you mean grid2.++?\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpeaou1nt0.scala:52:20\
    \ ---------------------------\e[0m\e[0m\n\e[31m52 |\e[0m                \e[33mval\e\
    [0m \e[36mb\e[0m = res(fillBuckets(\e[31m0\e[0m))\n\e[31m\e[31m   |\e[0m     \
    \           ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mb is already defined\
    \ as \e[33mvalue\e[0m \e[35mb\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpeaou1nt0.scala:53:20 -------------------------"
  stdout: ''
  timestamp: 1659979321
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        var bucket : Long = 1l\n        var max = 0l\n        var\
    \ fill = 0l\n        for (row <- grid) {\n            var count : Long = 0\n \
    \           var fill = 0\n            for (col <- row) {\n                if (col.toLong\
    \ == bucket) {\n                    fill += 1\n                    count += fill\n\
    \                    if (count > max) {\n                        max = count\n\
    \                    }\n                }\n                else {\n          \
    \          count += 0l\n                }\n            }\n            bucket +=\
    \ 1\n            fill += 0l\n            if (fill > max) {\n                max\
    \ = fill\n            }\n        }\n        return max\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpj4svnfgx.scala:45:17 ------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m            fill += \e[31m0l\e[0m\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^\e[0m\n\e[31m   |\e[0m            value += is not a member\
    \ of Int - did you mean Int.!=?\n1 error found\n"
  stdout: ''
  timestamp: 1659979321
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = grid.map(x => new Array[Long](capacity))\n\
    \        for(i <- 0 until buckets.length-1) {\n            for(j <- 0 until buckets(i).length)\
    \ {\n                buckets(i)(j) = buckets(i)(j) + 1\n            }\n      \
    \  }\n        var i = buckets.length - 1\n        var j = 0\n        val count\
    \ = buckets.foldLeft(0l) { (i, j) =>\n            var newI = i\n            var\
    \ newJ = j\n            var maxCount = 0\n            while (newI > 0) {\n   \
    \             if (buckets(newI)(newJ) <= buckets(newI-1)(newJ)) {\n          \
    \          newI = newI - 1\n                } else {\n                    if (buckets(newI)(newJ)\
    \ > maxCount) {\n                        maxCount = buckets(newI)(newJ)\n    \
    \                }\n                    newI = newI - 1\n                }\n \
    \           }\n            while (newJ > 0) {\n                if (buckets(i)(newJ)\
    \ <= buckets(i)(newJ-1)) {\n                    newJ = newJ - 1\n            \
    \    } else {\n                    if (buckets(i)(newJ) > maxCount) {\n      \
    \                  maxCount = buckets(i)(newJ)\n                    }\n      \
    \              newJ = newJ - 1\n                }\n            }\n           \
    \ count = maxCount\n            count + newI + newJ\n        }\n        count\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpykinqt_r.scala:26:52\
    \ --------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mbuckets\e\
    [0m = grid.map(\e[36mx\e[0m => \e[33mnew\e[0m \e[35mArray\e[0m[\e[35mLong\e[0m](capacity))\n\
    \e[31m\e[31m   |\e[0m                                                    ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                             Found:    (capacity\
    \ : Long)\n\e[31m   |\e[0m                                             Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpykinqt_r.scala:39:28\
    \ --------------------\e[0m\e[0m\n\e[31m39 |\e[0m                \e[33mif\e[0m\
    \ (buckets(newI)(newJ) <= buckets(newI-\e[31m1\e[0m)(newJ)) {\n\e[31m\e[31m  \
    \ |\e[0m                            ^^^^\e[0m\n\e[31m   |\e[0m               \
    \             Found:    (newI : Long)\n\e[31m   |\e[0m                       \
    \     Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpykinqt_r.scala:39:34\
    \ --------------------\e[0m\e[0m\n\e[31m39 |\e[0m                \e[33mif\e[0m\
    \ (buckets(newI)(newJ) <= buckets(newI-\e[31m1\e[0m)(newJ)) {\n\e[31m\e[31m  \
    \ |\e[0m                                  ^^^^\e[0m\n\e[31m   |\e[0m         \
    \                         Found:    (newJ : Array[Long])\n\e[31m   |\e[0m    \
    \                              Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpykinqt_r.scala:39:51 --------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m                \e[33mif\e[0m (buckets(newI)(newJ) <=\
    \ buckets(newI-\e[31m1\e[0m)(newJ)) {\n\e[31m\e[31m   |\e[0m                 \
    \                                  ^^^^^^\e[0m\n\e[31m   |\e[0m              \
    \                                     Found:    Long\n\e[31m   |\e[0m        \
    \                                           Required: Int\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] "
  stdout: ''
  timestamp: 1659979328
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val numRows = grid.length\n        val numColumns = grid(0).length\n\
    \        val numWells = numRows * numColumns\n        val numBuckets = numWells\
    \ * (capacity / 10)\n        val numBucketsCap = numBuckets\n        val buckets\
    \ = (0 to numBucketsCap).map(i => Array.fill(numColumns)(0l).toList)\n       \
    \ val wells = (0 to numWells).map(i => Array.fill(numRows)(0l).toList)\n     \
    \   for (i <- 0 until numRows) {\n            for (j <- 0 until numColumns) {\n\
    \                if (grid(i)(j) != 0l) {\n                    buckets(grid(i)(j).toLong\
    \ * capacity / 10).updated(j, 0)\n                }\n            }\n        }\n\
    \        var numWellsFilled = 0\n        for (i <- 0 until numRows) {\n      \
    \      for (j <- 0 until numColumns) {\n                if (buckets(i)(j) != 0l)\
    \ {\n                    numWellsFilled = numWellsFilled + 1\n               \
    \     wells(i)(j) = wells(i)(j) + buckets(i)(j).last\n                    buckets(i)(j)\
    \ = 0l\n                }\n            }\n        }\n        buckets.reverse.foldLeft(0l)\
    \ {\n            (sum, i) =>\n            sum + i\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpdobiwhr6.scala:31:28\
    \ --------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mbuckets\e\
    [0m = (\e[31m0\e[0m to numBucketsCap).map(\e[36mi\e[0m => Array.fill(numColumns)(\e\
    [31m0l\e[0m).toList)\n\e[31m\e[31m   |\e[0m                            ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                            Found:    (numBucketsCap : Long)\n\
    \e[31m   |\e[0m                            Required: Int\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpdobiwhr6.scala:36:28 --------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m                    buckets(grid(i)(j).toLong * capacity\
    \ / \e[31m10\e[0m).updated(j, \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m           \
    \                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                        Found:    Long\n\e[31m   |\e[0m                     \
    \       Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpdobiwhr6.scala:45:20\
    \ ------------------------\e[0m\e[0m\n\e[31m45 |\e[0m                    wells(i)(j)\
    \ = wells(i)(j) + buckets(i)(j).last\n\e[31m\e[31m   |\e[0m                  \
    \  ^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue update is not a member of List[Long] -\
    \ did you mean List[Long].updated?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpdobiwhr6.scala:45:62\
    \ ------------------------\e[0m\e[0m\n\e[31m45 |\e[0m                    wells(i)(j)\
    \ = wells(i)(j) + buckets(i)(j).last\n\e[31m\e[31m   |\e[0m                  \
    \                              ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \                                value last is not a member of Long\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpdobiwhr6.scala:46:20 ------------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m                    buckets(i)(j) = \e[31m0l\e[0m\n\e\
    [31m\e[31m   |\e[0m                    ^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue update\
    \ is not a member of List[Long] - did you mean List[Long].updated?\n\e[31m\e[31m--\
    \ [E134] Type Error: /tmp/tmpdobiwhr6.scala"
  stdout: ''
  timestamp: 1659979326
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val bucket = mutable.TreeMap[Int, Long]()\n        val result\
    \ = mutable.HashMap[Int, Int]()\n        var cnt = 0\n        var col = 0\n  \
    \      for (row <- 0 until grid.length) {\n            var rowSum = 0\n      \
    \      var found = 0\n            val r = grid[row]\n            while (col <\
    \ r.length) {\n                rowSum += r.get(col)\n                found +=\
    \ r.get(col) == 1 // count how many 1 we found \n                col += 1\n  \
    \          }\n            if (rowSum > 0) {\n                cnt += found\n  \
    \              val k = found.toDouble\n                if (bucket.size < k) {\n\
    \                    bucket.size += k\n                    result((cnt / bucket.size).toInt)\
    \ += ((cnt % bucket.size).toInt * bucket.size / k).toInt\n                }\n\
    \            }\n            col += 1\n        }\n        result.map {\n      \
    \      case (k, cnt) => k -> cnt.toDouble\n        }.maxBy(_._1).get._2\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpb9h4guat.scala:26:21 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mbucket\e[0m = mutable.TreeMap[\e\
    [35mInt\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpb9h4guat.scala:27:21 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.HashMap[\e\
    [35mInt\e[0m, \e[35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpb9h4guat.scala:33:25 ------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m            \e[33mval\e[0m \e[36mr\e[0m = grid[\e[35mrow\e\
    [0m]\n\e[31m\e[31m   |\e[0m                         ^^^\e[0m\n\e[31m   |\e[0m\
    \                         Not found: type row\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659979320
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val res : List[List[Long]] = ListBuffer.empty[List[Long]]\n\
    \        for ( r <- 0 to grid.length - 1 ) {\n            for ( c <- 0 to grid[r].length\
    \ - 1 ) {\n                val b : List[Long] = grid[r](c).asInstanceOf[List[Long]]\n\
    \                if( b.contains(0) || b.contains(capacity) ){\n              \
    \      if( b.contains(0) ){\n                        res(r).append(capacity)\n\
    \                        res(r).append(0)\n                    } else {\n    \
    \                    res(r).append(0)\n                        res(r).append(capacity)\n\
    \                    }\n                } else {\n                    res(r).append(0)\n\
    \                    res(r).append(0)\n                }\n            }\n    \
    \    }\n        scala.util.Sorting.quickSort(res(_))\n        res(0).last\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp2zjm6c9h.scala:26:53\
    \ --------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mres\e\
    [0m : \e[35mList\e[0m[\e[35mList\e[0m[\e[35mLong\e[0m]] = ListBuffer.empty[\e\
    [35mList\e[0m[\e[35mLong\e[0m]]\n\e[31m\e[31m   |\e[0m                       \
    \              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            \
    \   Found:    scala.collection.mutable.ListBuffer[List[Long]]\n\e[31m   |\e[0m\
    \               Required: List[List[Long]]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmp2zjm6c9h.scala:28:33 ------------------------\e[0m\e\
    [0m\n\e[31m28 |\e[0m            \e[33mfor\e[0m ( c <- \e[31m0\e[0m to grid[\e\
    [35mr\e[0m].length - \e[31m1\e[0m ) {\n\e[31m\e[31m   |\e[0m                 \
    \                ^\e[0m\n\e[31m   |\e[0m                                 Not found:\
    \ type r\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp2zjm6c9h.scala:29:42\
    \ ------------------------\e[0m\e[0m\n\e[31m29 |\e[0m                \e[33mval\e\
    [0m \e[36mb\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m] = grid[\e[35mr\e[0m](c).asInstanceOf[\e\
    [35mList\e[0m[\e[35mLong\e[0m]]\n\e[31m\e[31m   |\e[0m                       \
    \                   ^\e[0m\n\e[31m   |\e[0m                                  \
    \        Not found: type r\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmp2zjm6c9h.scala:32:31 ------------------------\e[0m\e[0m\n\e[31m32 |\e\
    [0m                        res(r).append(capacity)\n\e[31m\e[31m   |\e[0m    \
    \                    ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue append is not a\
    \ member of List[Long] - did you mean List[Long].appended?\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp2zjm6c9h.scala:33:31 ------------------------\e[0m\e\
    [0m\n\e[31m33 |\e[0m                        res(r).append(\e[31m0\e[0m)\n\e[31m\e\
    [31m   |\e[0m                        ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ append is not a member of List[Long] - did you mean Li"
  stdout: ''
  timestamp: 1659979329
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val wells = grid.map{ case List(x: Long, y: Long, w: Long)\
    \ => x -> y -> w }.toMap\n        val buckets = mutable.Map[Long, mutable.Set[Long]]()\n\
    \        for (well in wells) {\n            buckets.get(well._1).fold(Set[Long]())\
    \ { case (bucket, list) => bucket += well._2 }\n        }\n        buckets.values.reduce(_\
    \ + _).map(_.toLong).max\n    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpotn_q2_h.scala:28:28 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mfor\e[0m (well in wells) {\n\e[31m\e[31m\
    \   |\e[0m                            ^\e[0m\n\e[31m   |\e[0m                \
    \            '<-' expected, but '{' found\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tmpotn_q2_h.scala:31:36 ---------------------------\e[0m\e[0m\n\e[31m31\
    \ |\e[0m        buckets.values.reduce(_ + _).map(_.toLong).max\n\e[31m\e[31m \
    \  |\e[0m                                    ^\e[0m\n\e[31m   |\e[0m         \
    \                           '<-' expected, but '.' found\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpotn_q2_h.scala:27:40 ------------------------\e[0m\e\
    [0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mbuckets\e[0m = mutable.Map[\e\
    [35mLong\e[0m, mutable.Set[\e[35mLong\e[0m]]()\n\e[31m\e[31m   |\e[0m        \
    \                                ^^^^^^^\e[0m\n\e[31m   |\e[0m               \
    \                         Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpotn_q2_h.scala:27:22 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mbuckets\e[0m = mutable.Map[\e\
    [35mLong\e[0m, mutable.Set[\e[35mLong\e[0m]]()\n\e[31m\e[31m   |\e[0m        \
    \              ^^^^^^^\e[0m\n\e[31m   |\e[0m                      Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpotn_q2_h.scala:30:9\
    \ -------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        }\n\e[31m\e[31m\
    \   |\e[0m         ^\e[0m\n\e[31m   |\e[0mvalue withFilter is not a member of\
    \ Null, but could be made available as an extension method.\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mOne of the following imports might fix the problem:\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m  import Option.option2Iterable\n\e[31m   |\e[0m  import collection.LazyZip2.lazyZip2ToIterable\n\
    \e[31m   |\e[0m  import collection.LazyZip3.lazyZip3ToIterable\n\e[31m   |\e[0m\
    \  import collection.LazyZip4.lazyZip4ToIterable\n\e[31m   |\e[0m  import collection.convert.Impl"
  stdout: ''
  timestamp: 1659979328
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        // sort grid by its y coordinate\n        val sortedGrid\
    \ : List[(Int, List[Long])] = grid.sortBy(_._1)\n        // fill each row with\
    \ capacity (sort by y coordinate again)\n        val sortedGridFilled : List[(Int,\
    \ List[Long])] = sortedGrid.foldLeft(List.empty[(Int, List[Long])]) {\n      \
    \      case(res, currRow) =>\n                if (currRow._1 == sortedGrid.last._1)\
    \ res.reverse.map(_ => (currRow._1, currRow._2))\n                else res.reverse.map(_\
    \ => (currRow._1, currRow._2 :+ sortedGridFilled.last._2.last.last + capacity))\n\
    \        }\n        // remove all rows with capacity in it\n        val sortedGridFilledWithoutCapacity\
    \ : List[(Int, List[Long])] = sortedGridFilled\n            .filter(_._2.last\
    \ != capacity)\n        // count how many times you have to lower it (by taking\
    \ previous row's cell)\n        val counting : List[(Int, List[Long])] = sortedGridFilledWithoutCapacity.foldLeft(List.empty[(Int,\
    \ List[Long])]) {\n            case(res, currRow) =>\n                if (currRow._1\
    \ == res.last._1) res.reverse.map(_ => (currRow._1, currRow._2))\n           \
    \     else res.reverse.map(_ => (currRow._1, currRow._2 :+ counting.last._2.last.last\
    \ + 1))\n        }\n        \n        sortedGridFilledWithoutCapacity.last._2\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpjsuw3vow.scala:27:65 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36msortedGrid\e[0m : \e[35mList\e\
    [0m[(\e[35mInt\e[0m, \e[35mList\e[0m[\e[35mLong\e[0m])] = grid.sortBy(_._1)\n\e\
    [31m\e[31m   |\e[0m                                                          \
    \     ^^^^\e[0m\n\e[31m   |\e[0m                                  value _1 is\
    \ not a member of List[Long]\n\e[31m\e[31m-- Error: /tmp/tmpjsuw3vow.scala:27:68\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m27 |\e[0m       \
    \ \e[33mval\e[0m \e[36msortedGrid\e[0m : \e[35mList\e[0m[(\e[35mInt\e[0m, \e[35mList\e\
    [0m[\e[35mLong\e[0m])] = grid.sortBy(_._1)\n\e[31m\e[31m   |\e[0m            \
    \                                                        ^\e[0m\n\e[31m   |\e\
    [0mambiguous given instances: both \e[33mobject\e[0m \e[35mInt\e[0m in \e[33mobject\e\
    [0m \e[35mOrdering\e[0m and \e[33mobject\e[0m \e[35mDeprecatedDoubleOrdering\e\
    [0m in \e[33mobject\e[0m \e[35mOrdering\e[0m match type Ordering[B] of parameter\
    \ ord of \e[33mmethod\e[0m \e[35msortBy\e[0m in \e[33mtrait\e[0m \e[35mSeqOps\e\
    [0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpjsuw3vow.scala:32:99 ------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m                \e[33melse\e[0m res.reverse.map(_ =>\
    \ (currRow._1, currRow._2 :+ sortedGridFilled.last._2.last.last + capacity))\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m       \
    \                               value last is not a member of Long\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpjsuw3vow.scala:41:91 ------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m                \e[33melse\e[0m res.reverse.map(_ =>\
    \ (currRow._1, currRow._2 :+ counting.last._2.last.last + \e[31m1\e[0m))\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \     ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                       \
    \               value last is not a member of Long\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmpjsuw3vow.scala:44:45 --------------------\e[0m\e[0m\n\
    \e[31m44 |\e[0m "
  stdout: ''
  timestamp: 1659979329
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val max = new mutable.HashMap[Long,Long]()\n        val\
    \ m = new mutable.HashMap[Long,Long]()\n        val temp = new mutable.HashMap[Long,Long]()\n\
    \        for (row in grid) {\n            for (bucket <- row) {\n            \
    \    max += (bucket -> (bucket.toLong * capacity))\n                if (bucket\
    \ > 0) m.put(bucket, 1l)\n            }\n        }\n        max.foreach(bucket\
    \ => temp.put(bucket._1, bucket._2.toLong))\n        val min = (1 to capacity).reduce(temp(_),\
    \ (_, num) => if (num > _) num else _)\n        val ret = 0\n        while (m.size\
    \ > 0) {\n            val nextM = new mutable.HashMap[Long,Long]()\n         \
    \   val nextM2 = new mutable.HashMap[Long,Long]()\n            val nextMax = new\
    \ mutable.HashMap[Long,Long]()\n            for (bucket <- m.keys) {\n       \
    \         val num = m.get(bucket)\n                if (num < min) nextM.put(bucket,\
    \ num + capacity)\n                else nextM.put(bucket, num - capacity)\n  \
    \              val num2 = max.get(bucket)\n                if (num2 > 0) {\n \
    \                   val num3 = nextMax.get(bucket)\n                    if (num3\
    \ > 0) {\n                        if (num3 > num2) nextM2.put(bucket, num3 + capacity)\n\
    \                        else nextM2.put(bucket, num3 - capacity)\n          \
    \          }\n                    else {\n                        if (num2 > num3)\
    \ nextM2.put(bucket, num2 + capacity)\n                        else nextM2.put(bucket,\
    \ num2 - capacity)\n                    }\n                }\n            }\n\
    \            m = nextM\n            max = nextMax\n        }\n        return min\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpbm6rjuww.scala:29:26 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mfor\e[0m (row in grid) {\n\e[31m\e[31m\
    \   |\e[0m                          ^\e[0m\n\e[31m   |\e[0m                  \
    \        '<-' expected, but '{' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpbm6rjuww.scala:35:27\
    \ ---------------------------\e[0m\e[0m\n\e[31m35 |\e[0m        max.foreach(\e\
    [36mbucket\e[0m => temp.put(bucket._1, bucket._2.toLong))\n\e[31m\e[31m   |\e\
    [0m                           ^^\e[0m\n\e[31m   |\e[0m                       \
    \    ')' expected, but '=>' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpbm6rjuww.scala:36:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmin\e[0m = (\e[31m1\e[0m to capacity).reduce(temp(_), (_, \e[36mnum\e\
    [0m) => \e[33mif\e[0m (num > _) num \e[33melse\e[0m _)\n\e[31m\e[31m   |\e[0m^^^\e\
    [0m\n\e[31m   |\e[0m'<-' expected, but 'end of statement' found\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpbm6rjuww.scala:26:22 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = \e[33mnew\e[0m\
    \ mutable.HashMap[\e[35mLong\e[0m,\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                    ^^^^^^^\e[0m\n\e[31m   |\e[0m                      Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpbm6rjuww.scala:27:20\
    \ ------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e\
    [36mm\e[0m = \e[33mnew\e[0m mutable.HashMap[\e[35mLong\e[0m,\e[35mLong\e[0m]()\n\
    \e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e[31m   |\e[0m       \
    \             Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpbm6rjuww.scala:28:23 ------------------------\e[0m\e[0m\n\e[31m28 |\e\
    [0m        \e[33mval\e[0m \e[36mtemp\e[0m = \e[33mnew\e[0m mutable.HashMap[\e\
    [35mLong\e[0m,\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                      \
    \ ^^^^^^^\e[0m\n\e[31m   |\e[0m                       Not found: mutable\n\e[31m\
    \   |\e[0m\n\e[31m"
  stdout: ''
  timestamp: 1659979329
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val w = grid.head\n        val rw = w.map(_ - w.sum).map(w\
    \ => if (w < 0) -1 else 1)\n        val wl = w.sum\n        val c = capacity\n\
    \        val rc = rw.sum\n        val c = Math.min(c, wl)\n        val rc = Math.min(rc,\
    \ wl)\n        if (wl == 0) 0\n        else if (c == 0) 1\n        else {\n  \
    \          val r = Math.ceil(c * rc / wl)\n            val r = Math.min(r, wl\
    \ - rw)\n            val m = r * w\n            var count = 1\n            val\
    \ m = Math.ceil(count * w / wl)\n            if (r < rw) maxFill(grid.tail, r\
    \ + rw)\n            else {\n                val rc = Math.ceil(r * m / wl)\n\
    \                val rc = Math.min(rc, wl - rw)\n                val m = Math.ceil(r\
    \ * w / wl)\n                var count = 0\n                while (count * w <\
    \ wl) count += 1\n                if (count == 1) 0\n                else {\n\
    \                    val m = Math.ceil(count * w / wl)\n                    maxFill(grid.tail,\
    \ m + 1l)\n                }\n            }\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpjd6uctmd.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mc\e[0m = Math.min(c, wl)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mc is\
    \ already defined as \e[33mvalue\e[0m \e[35mc\e[0m\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpjd6uctmd.scala:32:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m\
    \ \e[36mrc\e[0m = Math.min(rc, wl)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mrc is already defined as \e[33mvalue\e[0m \e[35mrc\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpjd6uctmd.scala:37:16 ---------------------------\e[0m\e[0m\n\e[31m37\
    \ |\e[0m            \e[33mval\e[0m \e[36mr\e[0m = Math.min(r, wl - rw)\n\e[31m\e\
    [31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mr is\
    \ already defined as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpjd6uctmd.scala:40:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m40 |\e[0m            \e[33mval\e\
    [0m \e[36mm\e[0m = Math.ceil(count * w / wl)\n\e[31m\e[31m   |\e[0m          \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mm is already defined\
    \ as \e[33mvalue\e[0m \e[35mm\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E134] Type Error: /tmp/tmpjd6uctmd.scala:38:22 -----------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m            \e[33mval\e[0m \e[36mm\e[0m = r * w\n\e[31m\e\
    [31m   |\e[0m                    ^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded\
    \ alternatives of \e[33mmethod\e[0m \e[35m*\e[0m in \e[33mclass\e[0m \e[35mDouble\e\
    [0m with types\n\e[31m   |\e[0m (x: Double): Double\n\e[31m   |\e[0m (x: Float):\
    \ Double\n\e[31m   |\e[0m ("
  stdout: ''
  timestamp: 1659979328
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val n = grid.length\n        var result : Long = 0\n   \
    \     var currentMax = capacity\n        for( i <- 0 until n ) {\n           \
    \ var currentCount : Long = 0\n            for( j <- 0 until currentMax ) {\n\
    \                if( (grid[i][j] == 0l) && (j+1 < currentMax) ){\n           \
    \         currentCount += 1\n                    currentMax -= 1\n           \
    \     }\n            }\n            result = math.max(result, currentCount)\n\
    \        }\n        result\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 1l.toLong,\
    \ 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong, 0l.toLong), List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (1l)) == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpjkcd6r4b.scala:31:30\
    \ --------------------\e[0m\e[0m\n\e[31m31 |\e[0m            \e[33mfor\e[0m( j\
    \ <- \e[31m0\e[0m until currentMax ) {\n\e[31m\e[31m   |\e[0m                \
    \              ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                              Found:\
    \    (currentMax : Long)\n\e[31m   |\e[0m                              Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpjkcd6r4b.scala:32:29\
    \ ------------------------\e[0m\e[0m\n\e[31m32 |\e[0m                \e[33mif\e\
    [0m( (grid[\e[35mi\e[0m][\e[35mj\e[0m] == \e[31m0l\e[0m) && (j+\e[31m1\e[0m <\
    \ currentMax) ){\n\e[31m\e[31m   |\e[0m                             ^\e[0m\n\e\
    [31m   |\e[0m                             Not found: type j\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpjkcd6r4b.scala:32:26 ------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m                \e[33mif\e[0m( (grid[\e[35mi\e[0m][\e\
    [35mj\e[0m] == \e[31m0l\e[0m) && (j+\e[31m1\e[0m < currentMax) ){\n\e[31m\e[31m\
    \   |\e[0m                          ^\e[0m\n\e[31m   |\e[0m                  \
    \        Not found: type i\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659979328
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val w = getW(grid)\n        val i = findEmpty(w, capacity)\n\
    \        if(i != -1) return 0\n        val ret: Long = 0\n        if(grid.get(i).size\
    \ == 1) return grid.get(i).get(0).toLong\n        val bucket = grid.get(i).filter(\
    \ x=> x != 0 )\n        var count = 0\n        while(bucket.nonEmpty) {\n    \
    \        val bucketSize: Long = bucket.size\n            while(bucketSize > 0)\
    \ {\n                val nextBucketSize = bucketSize - bucket.last\n         \
    \       bucket.last = 0\n                bucketSize = nextBucketSize\n       \
    \         count += getW(grid)\n                i += 1\n            }\n       \
    \     bucket.last = 0\n            count += getW(grid)\n            i += 1\n \
    \       }\n        ret\n    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpos9fkku9.scala:26:16 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mw\e[0m = getW(grid)\n\e\
    [31m\e[31m   |\e[0m                ^^^^\e[0m\n\e[31m   |\e[0m                Not\
    \ found: getW\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpos9fkku9.scala:27:16\
    \ ------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e\
    [36mi\e[0m = findEmpty(w, capacity)\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                Not found: findEmpty\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpos9fkku9.scala:30:16 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mif\e[0m(grid.get(i).size == \e[31m1\e[0m)\
    \ \e[33mreturn\e[0m grid.get(i).get(\e[31m0\e[0m).toLong\n\e[31m\e[31m   |\e[0m\
    \           ^^^^^^^^\e[0m\n\e[31m   |\e[0m  value get is not a member of List[List[Long]]\
    \ - did you mean grid.seq?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpos9fkku9.scala:30:46\
    \ ------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mif\e[0m(grid.get(i).size\
    \ == \e[31m1\e[0m) \e[33mreturn\e[0m grid.get(i).get(\e[31m0\e[0m).toLong\n\e\
    [31m\e[31m   |\e[0m                                         ^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mvalue get is not a member of List[List[Long]], but could be made\
    \ available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the\
    \ following imports might fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m \
    \ import collection.convert.ImplicitConversions.seq AsJavaList\n\e[31m   |\e[0m\
    \  import collection.convert.ImplicitConversionsToJava.seq AsJavaList\n\e[31m\
    \   |\e[0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpos9fkku9.scala:31:26\
    \ ------------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e\
    [36mbucket\e[0m = grid.get(i).filter( \e[36mx\e[0m=> x != \e[31m0\e[0m )\n\e[31m\e\
    [31m   |\e[0m                     ^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue get is not\
    \ a member of List[List[Long]], but could be made available as an exten"
  stdout: ''
  timestamp: 1659979330
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val maxCapacity = grid.map(_.length).max\n        require(maxCapacity\
    \ >= capacity)\n        var counter : Long = 0\n\n        grid.map(_.map(x =>\
    \ x match {\n            case 0 => 0\n            case 1 => 1\n        }).foreach{\
    \ row =>\n            var j = 0\n            while(j < row.length && row[j] !=\
    \ 0) {\n                val currentCapacity = j\n                val newCapacity\
    \ = currentCapacity - capacity\n                if(newCapacity < 0) {\n      \
    \              newCapacity = 0\n                }\n                row.setLength(j,\
    \ newCapacity)\n                j++\n            }\n        })\n        counter\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpjhytdho6.scala:42:19 ---------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m                j++\n\e[31m\e[31m   |\e[0m          \
    \         ^\e[0m\n\e[31m   |\e[0m                   expression expected but \e\
    [31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpjhytdho6.scala:35:26\
    \ ------------------------\e[0m\e[0m\n\e[31m35 |\e[0m            \e[33mwhile\e\
    [0m(j < row.length && row[\e[35mj\e[0m] != \e[31m0\e[0m) {\n\e[31m\e[31m   |\e\
    [0m                      ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                    \
    \  value length is not a member of Int\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmpjhytdho6.scala:39:32\
    \ -----------------------------\e[0m\e[0m\n\e[31m39 |\e[0m                   \
    \ newCapacity = \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                    Reassignment to val newCapacity\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpjhytdho6.scala:41:20 ------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m                row.setLength(j, newCapacity)\n\e[31m\e\
    [31m   |\e[0m                ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m             \
    \   value setLength is not a member of Int\n4 errors found\n"
  stdout: ''
  timestamp: 1659979329
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val map = new mutable.HashMap[Long, List[Long]]().withDefaultValue(List())\n\
    \        for(i <- 1 to (grid.length + 1).asInstanceOf[Long])\n        for( j <-\
    \ 1 until (grid[i-1].length + 1).asInstanceOf[Long]){\n            map.getOrElse(grid(i)(j),\
    \ List.empty).append(capacity)\n        }\n        val res = mutable.ArrayBuffer.empty[Long]\n\
    \        for(key <- map.keys){\n            val v = map.get(key)\n           \
    \ val x = v(0)\n            val y = v(1)\n            res += v.length\n      \
    \      for(i <- 1 to (grid.length + 1).asInstanceOf[Long])\n            for( j\
    \ <- 1 until (grid[i-1].length + 1).asInstanceOf[Long]){\n                if((x+i)<=grid.length\
    \ || (y+j)<=grid[0].length && grid(x+i)(y+j) == 0 && v.length > (capacity * 2)){\n\
    \                    res += 1\n                    map((x+i)(y+j) - 1).remove(0)\n\
    \                }\n            }\n        }\n        res\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpxivieszb.scala:26:22 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mmap\e[0m = \e[33mnew\e[0m\
    \ mutable.HashMap[\e[35mLong\e[0m, \e[35mList\e[0m[\e[35mLong\e[0m]]().withDefaultValue(List())\n\
    \e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                 Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpxivieszb.scala:27:52 --------------------\e[0m\e\
    [0m\n\e[31m27 |\e[0m        \e[33mfor\e[0m(i <- \e[31m1\e[0m to (grid.length +\
    \ \e[31m1\e[0m).asInstanceOf[\e[35mLong\e[0m])\n\e[31m\e[31m   |\e[0m        \
    \              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                  Found:    Long\n\e[31m   |\e[0m                      Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpxivieszb.scala:28:33\
    \ ------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mfor\e[0m( j\
    \ <- \e[31m1\e[0m until (grid[\e[35mi-\e[31m1\e[0m].length + \e[31m1\e[0m).asInstanceOf[\e\
    [35mLong\e[0m]){\n\e[31m\e[31m   |\e[0m                                 ^\e[0m\n\
    \e[31m   |\e[0m                                 Not found: type -\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpxivieszb.scala:31:18 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mres\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                  ^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                  Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659979329
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        // Use mutable to count number of times\n        var count\
    \ : mutable.Map[Long, Int] = mutable.Map[Long, Int]()\n        // We need two\
    \ nested loop to complete the algorithm\n        for ((i, j) <- grid.zipWithIndex)\
    \ {\n            // If all well has already been filled, we can skip them\n  \
    \          if (grid[i][j] == 0l) {\n                count = count + (i.toLong\
    \ -> 0l)\n                continue\n            }\n            // We need two\
    \ loops to fill well of size 1 first\n            for ((k) <- 1 to grid[i][j])\
    \ {\n                count = count + (i.toLong -> k.toLong)\n            }\n \
    \           // Then we need to check if there are any well of size greater than\
    \ 1\n            // If so, we can use other technique to find out how many we\
    \ can fill from bucket\n            // For instance, we need to use two loop to\
    \ check how many we can fill from bucket\n            // We first check how many\
    \ we can fill from bucket of size 1\n            for ((k) <- 1 to grid[i][j])\
    \ {\n                // If it is already filled, we skip it\n                if\
    \ (grid[i][j] == 0l) {\n                    count = count + (i.toLong -> k.toLong)\n\
    \                    continue\n                }\n                // Otherwise,\
    \ we can fill from bucket of size 2\n                // We need to check how many\
    \ we can fill from bucket of size 2\n                for (l <- 1 to grid[i][j])\
    \ {\n                    // If it is already filled, we skip it\n            \
    \        if (grid[i][j] == 0l) {\n                        count = count + (i.toLong\
    \ -> k.toLong)\n                        continue\n                    }\n    \
    \                // Otherwise, we can fill from bucket of size 3\n           \
    \         // We need to check how many we can fill from bucket of size 3\n   \
    \                 for (m <- 1 to grid[i][j]) {\n                        // If\
    \ it is already filled, we skip it\n                        if (grid[i][j] ==\
    \ 0l) {\n                            count = count + (i.toLong -> k.toLong)\n\
    \                            continue\n                        }\n           \
    \             // Otherwise, we can fill from bucket of size 4\n              \
    \          // We need to check how many we can fill from bucket of size 4\n  \
    \                      for ((n) <- 1 to grid[i][j]) {\n                      \
    \      // If it is already filled, we skip it\n                            if\
    \ (grid[i][j] == 0l) {\n                                count = count + (i.toLong\
    \ -> k.toLong)\n                                continue\n                   \
    \         }\n                            // Otherwise, we can fill from bucket\
    \ of size 5\n                            // We need to check how many we can fill\
    \ from bucket of size 5\n                            for (o <- 1 to grid[i][j])\
    \ {\n                                // If it is already filled, we skip it\n\
    \                                if (grid[i][j] == 0l) {\n                   \
    \                 count = count + (i.toLong -> k.toLong)\n                   \
    \                 continue\n                                }\n              \
    \                  // Otherwise, we can fill from bucket of size 6\n         \
    \                       // We need to \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 1l.toLong,\
    \ 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong, 0l.toLong), List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (1l)) == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpd_krs6a9.scala:93:0 ----------------------------\e\
    [0m\e[0m\n\e[31m93 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpd_krs6a9.scala:27:20\
    \ ------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mvar\e[0m \e\
    [36mcount\e[0m : mutable.Map[\e[35mLong\e[0m, \e[35mInt\e[0m] = mutable.Map[\e\
    [35mLong\e[0m, \e[35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpd_krs6a9.scala:27:45 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mvar\e[0m \e[36mcount\e[0m : mutable.Map[\e\
    [35mLong\e[0m, \e[35mInt\e[0m] = mutable.Map[\e[35mLong\e[0m, \e[35mInt\e[0m]()\n\
    \e[31m\e[31m   |\e[0m                                             ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                             Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpd_krs6a9.scala:31:24\
    \ ------------------------\e[0m\e[0m\n\e[31m31 |\e[0m            \e[33mif\e[0m\
    \ (grid[\e[35mi\e[0m][\e[35mj\e[0m] == \e[31m0l\e[0m) {\n\e[31m\e[31m   |\e[0m\
    \                        ^\e[0m\n\e[31m   |\e[0m                        Not found:\
    \ type j\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpd_krs6a9.scala:31:21\
    \ ------------------------\e[0m\e[0m\n\e[31m31 |\e[0m            \e[33mif\e[0m\
    \ (grid[\e[35mi\e[0m][\e[35mj\e[0m] == \e[31m0l\e[0m) {\n\e[31m\e[31m   |\e[0m\
    \                     ^\e[0m\n\e[31m   |\e[0m                     Not found: type\
    \ i\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpd_krs6a9.scala:33:16\
    \ ------------------------\e[0m\e[0m\n\e[31m33 |\e[0m                continue\n\
    \e[31m\e[31m   |\e[0m                ^^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \      Not found: "
  stdout: ''
  timestamp: 1659979327
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        var ret : Long = 0\n        val rowNum : Long = grid.length\n\
    \        val colNum : Long = grid(0).length\n        val bucketCapacity : Long\
    \ = capacity\n        val bucketNum : Int = ((bucketCapacity - 1) / rowNum).toInt\n\
    \        val bucket = mutable.ArrayBuffer.fill(rowNum)(0l)\n        // bucket\
    \ index start from 0 -> number of buckets = 9\n        for (i <- 0 until rowNum)\
    \ {\n            for (j <- 0 until colNum) {\n                val bucket : Int\
    \ = ((bucketCapacity - 1) / rowNum).toInt\n                if (bucket(numToList(i,\
    \ j)) <= 0) {\n                    ret += 1\n                    bucket(numToList(i,\
    \ j)) = bucket(bucketNum - 1)\n                } else {\n                    bucket(numToList(i,\
    \ j)) = bucket(numToList(i, j))\n                }\n            }\n        }\n\
    \        ret\n    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpwn648w0r.scala:31:21 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mbucket\e[0m = mutable.ArrayBuffer.fill(rowNum)(\e\
    [31m0l\e[0m)\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m \
    \  |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpwn648w0r.scala:33:26 --------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mfor\e[0m (i <- \e[31m0\e[0m until rowNum)\
    \ {\n\e[31m\e[31m   |\e[0m                          ^^^^^^\e[0m\n\e[31m   |\e\
    [0m                          Found:    (rowNum : Long)\n\e[31m   |\e[0m      \
    \                    Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpwn648w0r.scala:34:30 --------------------\e[0m\e[0m\n\e[31m34\
    \ |\e[0m            \e[33mfor\e[0m (j <- \e[31m0\e[0m until colNum) {\n\e[31m\e\
    [31m   |\e[0m                              ^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \                        Found:    (colNum : Long)\n\e[31m   |\e[0m          \
    \                    Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E050] Type Error:\
    \ /tmp/tmpwn648w0r.scala:36:20 -----------------------------\e[0m\e[0m\n\e[31m36\
    \ |\e[0m                \e[33mif\e[0m (bucket(numToList(i, j)) <= \e[31m0\e[0m)\
    \ {\n\e[31m\e[31m   |\e[0m                    ^^^^^^\e[0m\n\e[31m   |\e[0m   \
    \                 \e[33mvalue\e[0m \e[35mbucket\e[0m does not take parameters\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpwn648w0r.scala:36:27\
    \ ------------------------\e[0m\e[0m\n\e[31m36 |\e[0m                \e[33mif\e\
    [0m (bucket(numToList(i, j)) <= \e[31m0\e[0m) {\n\e[31m\e[31m   |\e[0m       \
    \                    ^^^^^^^^^\e[0m\n\e[31m   |\e[0m                         \
    \  Not found: numToList\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-"
  stdout: ''
  timestamp: 1659979334
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val m = grid.size\n        val n = grid.head.get.length\n\
    \        val b = capacity\n\n        def dfs(i : Int, j : Int, b : Long) : Int\
    \ = {\n            if (i == m && j == n) return b\n            if (i == m) return\
    \ 0\n            if (j == n) return 0\n            if (grid[i][j] == 0) return\
    \ 0\n            val res = dfs(i + 1, j, (b + grid[i][j])%b) + dfs(i, j + 1, b)\n\
    \            grid[i][j] = res > b ? res - b : 0\n            res\n        }\n\n\
    \        var cnt = 0\n        var i : Int = 0\n        var j : Int = 0\n     \
    \   while (i < m && j < n) {\n            val cnt = dfs(i, j, b)\n           \
    \ if (cnt == 0) i += 1\n            if (cnt == 0) j += 1\n        }\n        cnt\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpb20puvvw.scala:36:23 -----------------------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m            grid[\e[35mi\e[0m][\e[35mj\e[0m] = res >\
    \ b ? res - b : \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m                       ^\e\
    [0m\n\e[31m   |\e[0m                       end of statement expected but '=' found\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpb20puvvw.scala:27:26 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = grid.head.get.length\n\
    \e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  value\
    \ get is not a member of List[Long] - did you mean List[Long].seq?\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpb20puvvw.scala:31:41 --------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m            \e[33mif\e[0m (i == m && j == n) \e[33mreturn\e\
    [0m b\n\e[31m\e[31m   |\e[0m                                         ^\e[0m\n\e\
    [31m   |\e[0m                                         Found:    (b : Long)\n\e\
    [31m   |\e[0m                                         Required: Int\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpb20puvvw.scala:34:24 ------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m            \e[33mif\e[0m (grid[\e[35mi\e[0m][\e[35mj\e\
    [0m] == \e[31m0\e[0m) \e[33mreturn\e[0m \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m  \
    \                      ^\e[0m\n\e[31m   |\e[0m                        Not found:\
    \ type j\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpb20puvvw.scala:34:21\
    \ ------------------------\e[0m\e[0m\n\e[31m34 |\e[0m            \e[33mif\e[0m\
    \ (grid[\e[35mi\e[0m][\e[35mj\e[0m] == \e[31m0\e[0m) \e[33mreturn\e[0m \e[31m0\e\
    [0m\n\e[31m\e[31m   |\e[0m                     ^\e[0m\n\e[31m   |\e[0m       \
    \              Not found: type i\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpb20puvvw.scala:35:49 ------------------------\e[0m\e[0m\n\e[31m35 |\e\
    [0m            \e[33mval\e[0m \e[36mres\e[0m = dfs(i + \e[31m1\e[0m, j"
  stdout: ''
  timestamp: 1659979333
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val maxCount = 1\n        val newGrid = grid.foldLeft[List[List[Long]]](List[List[Long]]())\
    \ { \n            (x, y) => {\n                val newX = x\n                val\
    \ newY = y\n                if(x.size == 0 || y.size == 0) newX :+ 0\n       \
    \         else if(x.size == 1 && y.size == 1) newX :+ 1\n                else\
    \ newX :+ 0\n            }\n        }.reverse\n        val newCap = capacity\n\
    \        newGrid.foldLeft[List[List[Long]]](List[List[Long]]()) { \n         \
    \   (x, y) => {\n                val newX = x\n                val newY = y\n\
    \                if(newX(0) == 0 && newY(0) == 0) newX :+ 0\n                else\
    \ if(newX(0) == 1 && newY(0) == 0) newX :+ 1\n                else newX :+ 0\n\
    \            }\n        }.reverse.foldLeft[List[List[Long]]](List[List[Long]]())\
    \ { \n            (x, y) => {\n                val newX = x\n                val\
    \ newY = y\n                if(newX(0) == 0 && newY(0) == 1) newX :+ 0\n     \
    \           else if(newX(0) == 1 && newY(0) == 1) newX :+ 1\n                else\
    \ newX :+ 0\n            }\n        }.reverse.foldLeft[List[List[Long]]](List[List[Long]]())\
    \ { \n            (x, y) => {\n                val newX = x\n                val\
    \ newY = y\n                if(newX(0) == 0 && newY(1) == 0) newX :+ 0\n     \
    \           else if(newX(0) == 1 && newY(1) == 0) newX :+ 1\n                else\
    \ newX :+ 0\n            }\n        }.reverse.foldLeft[List[List[Long]]](List[List[Long]]())\
    \ { \n            (x, y) => {\n                val newX = x\n                val\
    \ newY = y\n                if(newX(0) == 0 && newY(1) == 1) newX :+ 0\n     \
    \           else if(newX(0) == 1 && newY(1) == 1) newX :+ 1\n                else\
    \ newX :+ 0\n            }\n        }.reverse.foldLeft[List[List[Long]]](List[List[Long]]())\
    \ { \n            (x, y) => {\n                val newX = x\n                val\
    \ newY = y\n                if(newX(0) == 0 && newY(0) == 1 && newY(1) == 1) newX\
    \ :+ 1\n                else newX :+ 0\n            }\n        }.reverse.foldLeft[List[List[Long]]](List[List[Long]]())\
    \ { \n            (x, y) => {\n                val newX = x\n                val\
    \ newY = y\n                if(newX(1) == 0 && newY(0) == 1) new\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp3dh_7g1o.scala:81:4 ----------------------------\e\
    [0m\e[0m\n\e[31m81 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tmp3dh_7g1o.scala:91:0 ----------------------------\e[0m\e[0m\n\e[31m91\
    \ |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp3dh_7g1o.scala:31:55 --------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m                \e[33mif\e[0m(x.size == \e[31m0\e[0m\
    \ || y.size == \e[31m0\e[0m) newX :+ \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m     \
    \                                                  ^\e[0m\n\e[31m   |\e[0m   \
    \                                                 Found:    (\e[31m0\e[0m : Int)\n\
    \e[31m   |\e[0m                                                    Required: List[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp3dh_7g1o.scala:32:60\
    \ --------------------\e[0m\e[0m\n\e[31m32 |\e[0m                \e[33melse\e\
    [0m \e[33mif\e[0m(x.size == \e[31m1\e[0m && y.size == \e[31m1\e[0m) newX :+ \e\
    [31m1\e[0m\n\e[31m\e[31m   |\e[0m                                            \
    \                ^\e[0m\n\e[31m   |\e[0m                                     \
    \               Found:    (\e[31m1\e[0m : Int)\n\e[31m   |\e[0m              \
    \                                      Required: List[Long]\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp3dh_7g1o.scala:33:29 --------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m                \e[33melse\e[0m newX :+ \e[31m0\e[0m\n\
    \e[31m\e[31m   |\e[0m                             ^\e[0m\n\e[31m   |\e[0m    \
    \                         Found:    (\e[31m0\e[0m : Int)\n\e[31m   |\e[0m    \
    \                         Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ Error: /tmp/tmp3dh_7g1o.scala:41:19 -----------------------------------------\e\
    [0m\e[0m\n\e[31m41 |\e["
  stdout: ''
  timestamp: 1659979341
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = grid.zipWithIndex.map { case (w, i) => Bucket\
    \ (w, i.toLong) }\n        // create a list of bucket capacities\n        val\
    \ capacities = buckets.map { b => b.capacity }\n        // iterate over the grid\
    \ columns\n        for (col <- 0 until grid.length) {\n            // calculate\
    \ the bucket index this column belongs to\n            val bucketIndex = col.toLong\
    \ / capacity\n            // iterate over the grid rows\n            for (row\
    \ <- 0 until grid.length) {\n                // if the current row belongs to\
    \ the current column then\n                if (row == col) {\n               \
    \     // add an extra capacity if the grid at that row and column is empty\n \
    \                   if (buckets.get(bucketIndex).isEmpty) buckets.get(bucketIndex).capacity\
    \ += 1\n                    // otherwise do nothing\n                    else\
    \ {\n                        buckets.get(bucketIndex).capacity -= 1\n        \
    \                buckets.get(bucketIndex).minCapacity -= 1\n                 \
    \   }\n                }\n                // if the current row does not belong\
    \ to the current column then\n                else {\n                    // add\
    \ the extracapacity if the grid at that row and column is empty\n            \
    \        if (buckets.get(bucketIndex).isEmpty) buckets.get(bucketIndex).capacity\
    \ += 1\n                    // otherwise do nothing\n                    else\
    \ {\n                        buckets.get(bucketIndex).capacity -= 1\n        \
    \                buckets.get(bucketIndex).minCapacity -= 1\n                 \
    \   }\n                }\n            }\n            // iterate over the buckets\
    \ starting at the current column\n            for (bucket <- buckets.drop(bucketIndex))\
    \ {\n                // if the bucket is empty then add a new row to the current\
    \ column\n                if (bucket.isEmpty) bucket.capacity += 1\n         \
    \       // otherwise do nothing\n                else {\n                    bucket.capacity\
    \ -= 1\n                    bucket.minCapacity -= 1\n                }\n     \
    \       }\n        }\n        buckets.foldLeft(1l)((a, b) => if (a == b) a else\
    \ a + b)\n    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpo81on32t.scala:26:61 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mbuckets\e[0m = grid.zipWithIndex.map\
    \ { \e[33mcase\e[0m (w, i) => Bucket (w, i.toLong) }\n\e[31m\e[31m   |\e[0m  \
    \                                                           ^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                                                       Not found: Bucket\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpo81on32t.scala:28:46\
    \ ------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e\
    [36mcapacities\e[0m = buckets.map { \e[36mb\e[0m => b.capacity }\n\e[31m\e[31m\
    \   |\e[0m                                            ^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                               value capacity is not a member of Nothing\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpo81on32t.scala:38:32 ------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m                    \e[33mif\e[0m (buckets.get(bucketIndex).isEmpty)\
    \ buckets.get(bucketIndex).capacity += \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m   \
    \                     ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue get is not a member\
    \ of List[Nothing], but could be made available as an extension method.\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mOne of the following imports might fix the problem:\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.seq\
    \ AsJavaList\n\e[31m   |\e[0m  import collection.convert.ImplicitConversionsToJava.seq\
    \ AsJavaList\n\e[31m   |\e[0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpo81on32t.scala:38:66\
    \ ------------------------\e[0m\e[0m\n\e[31m38 |\e[0m                    \e[33mif\e\
    [0m (buckets.get(bucketIndex).isEmpty) buckets.get(bucketIndex).capacity += \e\
    [31m1\e[0m\n\e[31m\e[31m   |\e[0m                                            \
    \              ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue get is not a member of List[Nothing],\
    \ but could be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mOne of the following imports might fix the problem:\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m  import "
  stdout: ''
  timestamp: 1659979342
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        grid.zipWithIndex.map { case (row, index) =>\n         \
    \   val buckets = row.span(x => x == 1).toList\n            val newCapacity =\
    \ capacity - buckets.map(_.length).sum\n            val newRow = if (buckets.isEmpty)\
    \ row else row.drop(buckets.head.length)\n            val newGrid = if (buckets.isEmpty)\
    \ grid else grid.map { case (row, index) =>\n                if (index == buckets.head)\
    \ newRow.concat(buckets.tail)\n                else row\n            }\n     \
    \       newGrid.zipWithIndex.map { case (newRow, index) =>\n                if\
    \ (index == buckets.head) newRow.toLong else 0\n            }.sum\n        }.max\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpbbj824wu.scala:35:20 -----------------------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m                \e[33mif\e[0m (index == buckets.head)\
    \ newRow.toLong \e[33melse\e[0m \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m          \
    \          ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mValues of types Int and\
    \ List[Long] | (List[Long] | Nothing) cannot be compared with == or !=\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpbbj824wu.scala:35:50 ------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m                \e[33mif\e[0m (index == buckets.head)\
    \ newRow.toLong \e[33melse\e[0m \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m          \
    \                                 ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue toLong\
    \ is not a member of Any, but could be made available as an extension method.\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might make progress\
    \ towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659979337
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        // write your code here\n        var count : Long = 0\n\
    \        var maxCount : Long = 0\n        for(r <- 0 until grid.length){\n   \
    \         for(c <- 0 until grid[0].length){\n                var bucket : Long\
    \ = grid(r).get(c)\n                var count : Long = 0\n                while(bucket\
    \ != 0 && capacity > 0){\n                    count += bucket\n              \
    \      bucket -= 1\n                    capacity -= 1\n                }\n   \
    \             count += capacity\n                if(count > maxCount){\n     \
    \               maxCount = count\n                }\n            }\n        }\n\
    \        return maxCount\n    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpvlfmnori.scala:30:33 -----------------------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m            \e[33mfor\e[0m(c <- \e[31m0\e[0m until grid[\e\
    [31m0\e[0m].length){\n\e[31m\e[31m   |\e[0m                             ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        \e[33mmethod\e[0m \e[35mapply\e[0m in \e[33mtrait\e\
    [0m \e[35mLinearSeqOps\e[0m does not take type parameters\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpvlfmnori.scala:31:44 ------------------------\e[0m\e\
    [0m\n\e[31m31 |\e[0m                \e[33mvar\e[0m \e[36mbucket\e[0m : \e[35mLong\e\
    [0m = grid(r).get(c)\n\e[31m\e[31m   |\e[0m                                  \
    \  ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  value get is not a member of List[Long]\
    \ - did you mean List[Long].seq?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpvlfmnori.scala:36:29\
    \ ------------------------\e[0m\e[0m\n\e[31m36 |\e[0m                    capacity\
    \ -= \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m            value -= is not a member of Long - did you mean capacity.!=?\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1659979338
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        var rowSize = grid.map(_.size).max\n        var maxRow =\
    \ grid(0).size\n        var maxCol = grid.maxBy(_.size).size\n        \n     \
    \   if(maxCol != rowSize) {\n            return -1l\n        }\n        \n   \
    \     var count = 0\n        var row = 0\n        while(row < maxRow) {\n    \
    \        val currentRow = grid(row)\n            val maxCol = currentRow.size\n\
    \            val nextRow = row + 1\n            \n            while(nextRow <\
    \ maxRow) {\n                if(currentRow(nextRow) == 1l) {\n               \
    \     if(nextRow < maxRow) {\n                        currentRow(nextRow) = 0l\n\
    \                        nextRow = nextRow + 1\n                        count\
    \ = count + 1\n                    } else {\n                        currentRow(nextRow)\
    \ = 1l\n                        count = count + 1\n                        nextRow\
    \ = nextRow + 1\n                    }\n                } else {\n           \
    \         if(nextRow < maxRow) {\n                        currentRow(nextRow)\
    \ = 1l\n                        nextRow = nextRow + 1\n                      \
    \  count = count + 1\n                    } else {\n                        currentRow(nextRow)\
    \ = 0l\n                        nextRow = nextRow + 1\n                      \
    \  count = count + 1\n                    }\n                }\n            }\n\
    \            \n            row = nextRow\n        }\n        \n        return\
    \ count\n    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmphqp82ub3.scala:44:24 ------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m                        currentRow(nextRow) = \e[31m0l\e\
    [0m\n\e[31m\e[31m   |\e[0m                        ^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mvalue update is not a member of List[Long] - did you mean currentRow.updated?\n\
    \e[31m\e[31m-- [E052] Type Error: /tmp/tmphqp82ub3.scala:45:32 -----------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m                        nextRow = nextRow + \e[31m1\e\
    [0m\n\e[31m\e[31m   |\e[0m                        ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                        Reassignment to val nextRow\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmphqp82ub3.scala:48:24 ------------------------\e\
    [0m\e[0m\n\e[31m48 |\e[0m                        currentRow(nextRow) = \e[31m1l\e\
    [0m\n\e[31m\e[31m   |\e[0m                        ^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mvalue update is not a member of List[Long] - did you mean currentRow.updated?\n\
    \e[31m\e[31m-- [E052] Type Error: /tmp/tmphqp82ub3.scala:50:32 -----------------------------\e\
    [0m\e[0m\n\e[31m50 |\e[0m                        nextRow = nextRow + \e[31m1\e\
    [0m\n\e[31m\e[31m   |\e[0m                        ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                        Reassignment to val nextRow\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmphqp82ub3.scala:54:24 ------------------------\e\
    [0m\e[0m\n\e[31m54 |\e[0m                        currentRow(nextRow) = \e[31m1l\e\
    [0m\n\e[31m\e[31m   |\e[0m                        ^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mvalue update is not a member of List[Long] - did you mean currentRow.updated?\n\
    \e[31m\e[31m-- [E052] Type Error: /tmp/tmphqp82ub3.scala:55:32 -----------------------------\e\
    [0m\e[0m\n\e[31m55 |\e[0m                        nextRow = nextRow + \e[31m1\e\
    [0m\n\e[31m\e[31m   |\e[0m                        ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                        Reassignment to val nextRow\n\e[31m   |\e\
    [0m\n\e[31"
  stdout: ''
  timestamp: 1659979338
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n      assert(grid.length == grid\n        .map(_.length)\n     \
    \   .reduce((a, b) => a + b)\n        .toLong)\n      assert(grid.head.length\
    \ == 1)\n      assert(capacity <= grid.head(0).toLong)\n\n      val buckets =\
    \ new mutable.HashMap[Long, Long]\n      val bucketsWithoutLast = grid.tail\n\
    \        .map(row => row.map(_.toLong)).flatten\n        .distinct\n        .groupBy(x\
    \ => x)\n        .filter(_._2 > capacity)\n        .mapValues(x => x.size)\n \
    \     bucketsWithoutLast.foreach {\n        case (bucket, value) => buckets.put(bucket,\
    \ value)\n      }\n      buckets.maxBy(_._2)._1\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 1l.toLong,\
    \ 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong, 0l.toLong), List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (1l)) == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpjp3mqyc7.scala:33:24 ------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m      \e[33mval\e[0m \e[36mbuckets\e[0m = \e[33mnew\e\
    [0m mutable.HashMap[\e[35mLong\e[0m, \e[35mLong\e[0m]\n\e[31m\e[31m   |\e[0m \
    \                       ^^^^^^^\e[0m\n\e[31m   |\e[0m                        Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpjp3mqyc7.scala:38:21\
    \ ------------------------\e[0m\e[0m\n\e[31m38 |\e[0m        .filter(_._2 > capacity)\n\
    \e[31m\e[31m   |\e[0m                ^^^^^^\e[0m\n\e[31m   |\e[0mvalue > is not\
    \ a member of List[Long], but could be made available as an extension method.\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might make progress\
    \ towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Ordered.orderingToOrdered\n\
    \e[31m   |\e[0m  import math.Ordering.Implicits.infixOrderingOps\n\e[31m   |\e\
    [0m\n2 errors found\n"
  stdout: ''
  timestamp: 1659979340
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n      val b = new mutable.HashMap[Long, List[Long]]()\n      var\
    \ count = 0\n      grid.foreach{ x =>\n        x.foreach{ y =>\n          if (b.contains(y))\n\
    \            b.getOrElse(y, Nil).foreach{ x =>\n              if (x >= capacity)\
    \ {\n                count += 1 // count the amount of times we need to lower\
    \ the buckets\n                val newCapacity = b.getOrElse(y, Nil).filterNot(_\
    \ >= capacity).min\n                b.put(y, newCapacity.map{x => x + 1}.toList)\n\
    \              } else {\n                b.put(y, b.getOrElse(y, Nil).map{x =>\
    \ x + 1}.toList)\n              }\n            }\n          else\n           \
    \ b += y -> List(1L)\n        }\n      }\n      count\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpu_m5abp9.scala:26:18 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m      \e[33mval\e[0m \e[36mb\e[0m = \e[33mnew\e[0m mutable.HashMap[\e\
    [35mLong\e[0m, \e[35mList\e[0m[\e[35mLong\e[0m]]()\n\e[31m\e[31m   |\e[0m    \
    \              ^^^^^^^\e[0m\n\e[31m   |\e[0m                  Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979332
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val rows = grid.length\n        val cols = grid[0].length\n\
    \n        var i = 0\n        var j = 0\n        var max = 0\n\n        var counter\
    \ = Int().asInstanceOf[Int]\n\n        while (i < rows) {\n            var sum\
    \ = 0\n\n            while (j < cols) {\n                sum += grid(i)(j)\n \
    \               j++\n            }\n\n            if (sum >= capacity) {\n   \
    \             counter += 1\n            }\n            max = Math.max(max, counter)\n\
    \            i += 1\n            j = 0\n        }\n\n        max + 1\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpv1t4tyvz.scala:40:19 ---------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m                j++\n\e[31m\e[31m   |\e[0m          \
    \         ^\e[0m\n\e[31m   |\e[0m                   expression expected but \e\
    [31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- Error: /tmp/tmpv1t4tyvz.scala:27:23\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m27 |\e[0m       \
    \ \e[33mval\e[0m \e[36mcols\e[0m = grid[\e[31m0\e[0m].length\n\e[31m\e[31m   |\e\
    [0m                   ^^^^^^^\e[0m\n\e[31m   |\e[0m        \e[33mmethod\e[0m \e\
    [35mapply\e[0m in \e[33mtrait\e[0m \e[35mLinearSeqOps\e[0m does not take type\
    \ parameters\n\e[31m\e[31m-- [E050] Type Error: /tmp/tmpv1t4tyvz.scala:33:22 -----------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mvar\e[0m \e[36mcounter\e[0m = Int().asInstanceOf[\e\
    [35mInt\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^\e[0m\n\e[31m   |\e\
    [0m                    \e[33mobject\e[0m \e[35mInt\e[0m in \e[33mpackage\e[0m\
    \ \e[35mscala\e[0m does not take parameters\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpv1t4tyvz.scala:39:20 ------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m                sum += grid(i)(j)\n\e[31m\e[31m   |\e\
    [0m                ^^^^^^\e[0m\n\e[31m   |\e[0m                value += is not\
    \ a member of Int - did you mean Int.!=?\n4 errors found\n"
  stdout: ''
  timestamp: 1659979338
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        // 1. First we define the bucket to be the row and column\
    \ of the grid that has the maximum value when transformed\n        var maxRow\
    \ : Int = grid.length-1\n        var maxCol : Int = grid(0).length-1\n       \
    \ var maxVal = grid(0).getOrElse(0l)\n        for(r <- 0 until grid.length-1)\
    \ {\n            for(c<- 0 until grid(0).length-1) {\n                var curVal\
    \ = grid(r).getOrElse(0l)\n                if(curVal > maxVal) {\n           \
    \         maxVal = curVal\n                    maxRow = r\n                  \
    \  maxCol = c\n                }\n            }\n        }\n        // 2. We need\
    \ to empty each bucket so that it can refill its capacity\n        // 3.1. The\
    \ bucket has all the water we can extract from it. We will use this bucket to\
    \ help us empty the wells\n        val bucket = grid(maxRow).dropRight(maxCol).toList.take(maxCol).reverse.takeRight(grid((maxRow-1).toInt).length).reverse\n\
    \        // 3.2 We will use another bucket to help us empty the wells when the\
    \ wells are full\n        val bucket2 = grid(maxRow-1).dropRight(maxCol).toList.take(maxCol).reverse.takeRight(grid((maxRow-1).toInt).length).reverse\n\
    \        // 4. Now we can fill the buckets\n        for(i <- 0 until bucket.length)\
    \ {\n            val bucketElement = bucket(i)\n            for(j <- 0 until bucketElement.length)\n\
    \                bucket(bucketElement(j))(i) = 0\n        }\n        // 5. Finally\
    \ we can calculate the result\n        var result : Long = bucket.length\n   \
    \     for(r <- 0 until grid.length-1) {\n            for(c <- 0 until grid((maxRow-1).toInt).length-1)\
    \ {\n                var curVal = grid(r).getOrElse(0l)\n                var newVal\
    \ : Long = 0\n                if(curVal != 0l) {\n                    newVal =\
    \ (curVal * (capacity-1)).floor\n                    result += newVal - (curVal\
    \ * (capacity-1)).floor\n                }\n            }\n        }\n       \
    \ result\n    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmptpavqzma.scala:29:29 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mvar\e[0m \e[36mmaxVal\e[0m = grid(\e[31m0\e\
    [0m).getOrElse(\e[31m0l\e[0m)\n\e[31m\e[31m   |\e[0m                     ^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                     value getOrElse is not a member of List[Long]\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmptpavqzma.scala:32:37 ------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m                \e[33mvar\e[0m \e[36mcurVal\e[0m = grid(r).getOrElse(\e\
    [31m0l\e[0m)\n\e[31m\e[31m   |\e[0m                             ^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                           value getOrElse is not a member\
    \ of List[Long]\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmptpavqzma.scala:48:43\
    \ ------------------------\e[0m\e[0m\n\e[31m48 |\e[0m            \e[33mfor\e[0m(j\
    \ <- \e[31m0\e[0m until bucketElement.length)\n\e[31m\e[31m   |\e[0m         \
    \                    ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m              \
    \               value length is not a member of Long\n\e[31m\e[31m-- [E050] Type\
    \ Error: /tmp/tmptpavqzma.scala:49:23 -----------------------------\e[0m\e[0m\n\
    \e[31m49 |\e[0m                bucket(bucketElement(j))(i) = \e[31m0\e[0m\n\e\
    [31m\e[31m   |\e[0m                       ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                       \e[33mvalue\e[0m \e[35mbucketElement\e[0m does not take\
    \ parameters\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmptpavqzma.scala:55:37\
    \ ------------------------\e[0m\e[0m\n\e[31m55 |\e[0m                \e[33mvar\e\
    [0m \e[36mcurVal\e[0m = grid(r).getOrElse(\e[31m0l\e[0m)\n\e[31m\e[31m   |\e[0m\
    \                             ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        \
    \                   value getOrElse is not a member of List[Long]\n5 errors found\n"
  stdout: ''
  timestamp: 1659979340
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val rec : PartialFunction[List[List[Long]], Int] = { case\
    \ head :: tail => tail.size; case head :: tail => tail.size + maxFill(tail, capacity);\
    \ }\n        val total = rec(grid)\n        val minRec = rec\n        val maxRec\
    \ = rec\n        val minRec2 = rec\n        val maxRec2 = rec\n        for(i <-\
    \ 1 to grid.length; j <- 1 to grid[0].length) total = (total + minRec(grid).orElse(0)\
    \ + maxRec(grid).orElse(0)) if (total < capacity) minRec = total else maxRec =\
    \ total\n        for(i <- 1 to grid.length; j <- 1 to grid[0].length) total =\
    \ (total + minRec2(grid).orElse(0) + maxRec2(grid).orElse(0)) if (total < capacity)\
    \ minRec2 = total else maxRec2 = total\n        (maxRec - minRec) max maxRec -\
    \ minRec + (maxRec2 - minRec2) max maxRec2 - minRec2\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp8zx5iekr.scala:32:127 ----------------------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mfor\e[0m(i <- \e[31m1\e[0m to grid.length;\
    \ j <- \e[31m1\e[0m to grid[\e[31m0\e[0m].length) total = (total + minRec(grid).orElse(\e\
    [31m0\e[0m) + maxRec(grid).orElse(\e[31m0\e[0m)) \e[33mif\e[0m (total < capacity)\
    \ minRec = total \e[33melse\e[0m maxRec = total\n\e[31m\e[31m   |\e[0m       \
    \                                                                            \
    \                                            ^^\e[0m\n\e[31m   |\e[0m        \
    \                        end of statement expected but 'if' found\n\e[31m\e[31m--\
    \ Error: /tmp/tmp8zx5iekr.scala:33:129 ----------------------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mfor\e[0m(i <- \e[31m1\e[0m to grid.length;\
    \ j <- \e[31m1\e[0m to grid[\e[31m0\e[0m].length) total = (total + minRec2(grid).orElse(\e\
    [31m0\e[0m) + maxRec2(grid).orElse(\e[31m0\e[0m)) \e[33mif\e[0m (total < capacity)\
    \ minRec2 = total \e[33melse\e[0m maxRec2 = total\n\e[31m\e[31m   |\e[0m     \
    \                                                                            \
    \                                                ^^\e[0m\n\e[31m   |\e[0m    \
    \                            end of statement expected but 'if' found\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmp8zx5iekr.scala:26:114 -------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mrec\e[0m : \e[35mPartialFunction\e\
    [0m[\e[35mList\e[0m[\e[35mList\e[0m[\e[35mLong\e[0m]], \e[35mInt\e[0m] = { \e\
    [33mcase\e[0m head :: tail => tail.size; \e[33mcase\e[0m head :: tail => tail.size\
    \ + maxFill(tail, capacity); }\n\e[31m\e[31m   |\e[0m                        \
    \                                                                            \
    \              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                                                     Found:    Long\n\e[31m \
    \  |\e[0m                                                          Required: Int\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- Error: /tmp/tmp8zx5iekr.scala:32:49 ----"
  stdout: ''
  timestamp: 1659979345
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val rows = grid.length\n        val cols = grid(0).length\n\
    \        var currentCap = capacity\n\n        // find all buckets\n        def\
    \ findBuckets(row: Int, col: Int): List[List[Long]] = grid\n            .take(rows)\n\
    \            .drop(1)\n            .take(cols)\n            .drop(1)\n       \
    \     .flatMap(_.map((_)))\n\n        // find empty buckets\n        def findEmptyBuckets(row:\
    \ Int, col: Int): List[List[Long]] = findBuckets(row, col)\n            .filter(x\
    \ => x == 0l)\n            .takeWhile(_ != 0l)\n            .dropWhile(_ != 0l)\n\
    \n        // find new empty buckets\n        def findNewBuckets(row: Int, col:\
    \ Int, currentCap: Long): List[List[Long]] = findEmptyBuckets(row, col)\n    \
    \        .map(x => if(x % currentCap == 0) 0l else currentCap * x / (x + 1l))\n\
    \            .takeWhile(_ <= currentCap)\n            .dropWhile(_ >= currentCap)\n\
    \n        // new cap per bucket\n        def newCap(currentCap: Long): Long =\
    \ currentCap / 2\n\n        // new bucket\n        def newBucket(row: Int, col:\
    \ Int, currentCap: Long): List[List[Long]] =\n            findNewBuckets(row,\
    \ col, currentCap).map(x => (x+1l).toLong)\n\n        // fill empty buckets\n\
    \        def fillEmptyBuckets(row: Int, col: Int, currentCap: Long): List[List[Long]]\
    \ = findNewBuckets(row, col, currentCap)\n            .flatMap(x => List(newBucket(row,\
    \ col, currentCap), newBucket(row, col + 1, currentCap)))\n            .filter(_._1\
    \ != 0l)\n\n        // fill all buckets\n        def fillAllBuckets(row: Int,\
    \ col: Int, currentCap: Long): List[List[Long]] = findNewBuckets(row, col, currentCap)\n\
    \            .flatMap(x => List(newBucket(row, col, currentCap), newBucket(row,\
    \ col + 1, currentCap)))\n            .filter(_._1 != 0l)\n\n        // fill all\
    \ buckets\n        def fillAllBuckets2(row: Int, col: Int, currentCap: Long):\
    \ List[List[Long]] = findNewBuckets(row, col, currentCap)\n            .flatMap(x\
    \ => List(newBucket(row, col, currentCap), newBucket(row, col + 1, currentCap)))\n\
    \            .filter(_._1 != 0l)\n\n        val result = (findEmptyBuckets(0,0)\n\
    \            .foldLeft((currentCap, fillAllBuckets2(0,0, currentCap))){\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpwxcl3ijj.scala:75:4 ----------------------------\e\
    [0m\e[0m\n\e[31m75 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[31m\e[31m   |\e[0m    ^^^\e[0m\n\e\
    [31m   |\e[0m    ')' expected, but 'def' found\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tmpwxcl3ijj.scala:84:0 ----------------------------\e[0m\e[0m\n\e[31m84\
    \ |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\
    \e[31m\e[31m-- [E086] Syntax Error: /tmp/tmpwxcl3ijj.scala:36:21 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m            .flatMap(_.map((_)))\n\e[31m\e[31m   |\e\
    [0m                     ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                     Wrong\
    \ number of parameters, expected: 1\n\e[31m\e[31m-- Error: /tmp/tmpwxcl3ijj.scala:40:25\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m40 |\e[0m       \
    \     .filter(x => x == \e[31m0l\e[0m)\n\e[31m\e[31m   |\e[0m                \
    \         ^^^^^^^\e[0m\n\e[31m   |\e[0m    Values of types List[Long] and Long\
    \ cannot be compared with == or !=\n\e[31m\e[31m-- Error: /tmp/tmpwxcl3ijj.scala:41:23\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m41 |\e[0m       \
    \     .takeWhile(_ != \e[31m0l\e[0m)\n\e[31m\e[31m   |\e[0m                  \
    \     ^^^^^^^\e[0m\n\e[31m   |\e[0m    Values of types List[Long] and Long cannot\
    \ be compared with == or !=\n\e[31m\e[31m-- Error: /tmp/tmpwxcl3ijj.scala:42:23\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m42 |\e[0m       \
    \     .dropWhile(_ != \e[31m0l\e[0m)\n\e[31m\e[31m   |\e[0m                  \
    \     ^^^^^^^\e[0m\n\e[31m   |\e[0m    Values of types List[Long] and Long cannot\
    \ be compared with == or !=\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpwxcl3ijj.scala:46:27\
    \ ------------------------\e[0m\e[0m\n\e[31m46 |\e[0m            .map(x => \e\
    [33mif\e[0m(x % currentCap == \e[31m0\e[0m) \e[31m0l\e[0m \e[33melse\e[0m currentCap\
    \ * x / (x + \e[31m1l\e[0m))\n\e[31m\e[31m   |\e[0m                         ^^^\e\
    [0m\n\e[31m   |\e[0mvalue % is not a member of List[Long], but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mThe following import\
    \ migh"
  stdout: ''
  timestamp: 1659979345
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        var totalWater : Long = 0\n        var water: Int = 0\n\n\
    \        val totalRow = grid.length\n        val totalCol = grid[0].length\n\n\
    \        if(totalRow == 0 || totalCol == 0){\n            return 0\n        }\n\
    \n        for(row <- 1 to totalRow){\n            for(col <- 1 to totalCol){\n\
    \                val row = grid[row - 1]\n                val col = grid[col -\
    \ 1]\n                val totalColWithinWell = row.length + col.length\n     \
    \           val bucket = math.max(math.min(bucketCapacity.toLong, totalColWithinWell\
    \ / 2), 1).toInt\n                if(bucket == 0){\n                    water\
    \ += 1\n                }\n                totalWater += bucket\n            }\n\
    \        }\n\n        totalWater -= water\n        totalWater += math.max(math.min(bucketCapacity.toLong,\
    \ totalRow * totalCol), 1).toInt\n        totalWater -= capacity\n\n        totalWater\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpvevfe655.scala:30:27 -----------------------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mtotalCol\e[0m = grid[\e\
    [31m0\e[0m].length\n\e[31m\e[31m   |\e[0m                       ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m        \e[33mmethod\e[0m \e[35mapply\e[0m in \e[33mtrait\e[0m\
    \ \e[35mLinearSeqOps\e[0m does not take type parameters\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpvevfe655.scala:38:35 ------------------------\e[0m\e\
    [0m\n\e[31m38 |\e[0m                \e[33mval\e[0m \e[36mrow\e[0m = grid[\e[35mrow\e\
    [0m \e[35m-\e[0m \e[31m1\e[0m]\n\e[31m\e[31m   |\e[0m                        \
    \           ^\e[0m\n\e[31m   |\e[0m                                   Not found:\
    \ type -\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpvevfe655.scala:39:35\
    \ ------------------------\e[0m\e[0m\n\e[31m39 |\e[0m                \e[33mval\e\
    [0m \e[36mcol\e[0m = grid[\e[35mcol\e[0m \e[35m-\e[0m \e[31m1\e[0m]\n\e[31m\e\
    [31m   |\e[0m                                   ^\e[0m\n\e[31m   |\e[0m      \
    \                             Not found: type -\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpvevfe655.scala:41:47 ------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m                \e[33mval\e[0m \e[36mbucket\e[0m = math.max(math.min(bucketCapacity.toLong,\
    \ totalColWithinWell / \e[31m2\e[0m), \e[31m1\e[0m).toInt\n\e[31m\e[31m   |\e\
    [0m                                               ^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                                               Not found: bucketCapacity\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpvevfe655.scala:50:19\
    \ ------------------------\e[0m\e[0m\n\e[31m50 |\e[0m        totalWater += math.max(math.min(bucketCapacity.toLong,\
    \ totalRow * totalCol), \e[31m1\e[0m).toInt\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        value += is not a member of Long - did you mean Long.!=?\n\
    \e[31m\e[31m-- [E006] Not Found"
  stdout: ''
  timestamp: 1659979342
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val nBuckets = grid.head.length\n        val bucketCap =\
    \ math.pow(10, nBuckets.toInt)\n        val buckets = new Array[List[Long]](nBuckets)\n\
    \        for (i  <- 0 until (grid.length-1)) buckets(i) = grid(i).take(bucketCap)\n\
    \        val newCapacity = capacity - bucketCap\n        var index = 0\n     \
    \   val nextGrids = new Array[List[Long]](nBuckets)\n        for (i  <- 0 until\
    \ (grid.length-1)) {\n            val bucket = buckets(i)\n            if (bucket\
    \ > capacity) index++\n            else {\n                val bucketIndex = buckets.indexWhere(x\
    \ => x >= bucket)\n                newCapacity -= 1\n                nextGrids(bucketIndex)\
    \ = grid(i)\n                buckets(i) = bucket\n            }\n        }\n \
    \       val maxIndex = index\n        val nextGridArray = nextGrids.toList\n \
    \       var max = 0\n        var count = 0\n        for (i  <- 0 until (nextGridArray.length-1))\
    \ {\n            val nextGridIndex = nextGridArray(i).length\n            val\
    \ gridIndex = grid.length\n            if (nextGridIndex > gridIndex) count++\n\
    \            else {\n                if (nextGridIndex > maxIndex) max = nextGridIndex\n\
    \                nextGridArray(i) = grid(i).take(nextGridIndex)\n            }\n\
    \        }\n        if (count > max) max\n        else maxFillNoRep(grid, capacity,\
    \ nextGridArray.toList(0), nextGridArray.toList(1))\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp0tob9c79.scala:35:42 ---------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m            \e[33mif\e[0m (bucket > capacity) index++\n\
    \e[31m\e[31m   |\e[0m                                          ^\e[0m\n\e[31m\
    \   |\e[0m                                      expression expected but \e[31melse\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp0tob9c79.scala:50:50\
    \ ---------------------------\e[0m\e[0m\n\e[31m50 |\e[0m            \e[33mif\e\
    [0m (nextGridIndex > gridIndex) count++\n\e[31m\e[31m   |\e[0m               \
    \                                   ^\e[0m\n\e[31m   |\e[0m                  \
    \                    expression expected but \e[31melse\e[0m found\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp0tob9c79.scala:29:70 --------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mfor\e[0m (i  <- \e[31m0\e[0m until (grid.length-\e\
    [31m1\e[0m)) buckets(i) = grid(i).take(bucketCap)\n\e[31m\e[31m   |\e[0m     \
    \                                                                 ^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                          Found:    (bucketCap\
    \ : Double)\n\e[31m   |\e[0m                                          Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp0tob9c79.scala:35:23\
    \ ------------------------\e[0m\e[0m\n\e[31m35 |\e[0m            \e[33mif\e[0m\
    \ (bucket > capacity) index++\n\e[31m\e[31m   |\e[0m                ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue > is not a member of List[Long], but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m  import math.Ordered.orderingToOrdered\n\e[31m   |\e[0m  import\
    \ math.Ordering.Implicits.infixOrderingOps\n\e[31m   |\e[0m\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmp0tob9c79.scala:57:13 ------------"
  stdout: ''
  timestamp: 1659979345
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val grid2d = grid.map(_.map(_.toLong))\n        val minCapacity\
    \ = math.min(grid2d.map(_.length).max,grid2d.map(_.zipWithIndex.map(_.length).max).max)\n\
    \        if (minCapacity > capacity) 0 else minCapacity - capacity\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp9wv96dy9.scala:27:92 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mminCapacity\e[0m = math.min(grid2d.map(_.length).max,grid2d.map(_.zipWithIndex.map(_.length).max).max)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                  ^^^^^^^^\e[0m\n\e[31m   |\e[0m          value\
    \ length is not a member of (Long @uncheckedVariance, Int)\n\e[31m\e[31m-- Error:\
    \ /tmp/tmp9wv96dy9.scala:27:103 ----------------------------------------\e[0m\e\
    [0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mminCapacity\e[0m = math.min(grid2d.map(_.length).max,grid2d.map(_.zipWithIndex.map(_.length).max).max)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                               ^\e[0m\n\e[31m   |\e[0mambiguous\
    \ given instances: both \e[33mobject\e[0m \e[35mDeprecatedFloatOrdering\e[0m in\
    \ \e[33mobject\e[0m \e[35mOrdering\e[0m and \e[33mobject\e[0m \e[35mInt\e[0m in\
    \ \e[33mobject\e[0m \e[35mOrdering\e[0m match type Ordering[B] of parameter ord\
    \ of \e[33mmethod\e[0m \e[35mmax\e[0m in \e[33mtrait\e[0m \e[35mIterableOnceOps\e\
    [0m\n\e[31m\e[31m-- Error: /tmp/tmp9wv96dy9.scala:27:108 ----------------------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mminCapacity\e[0m = math.min(grid2d.map(_.length).max,grid2d.map(_.zipWithIndex.map(_.length).max).max)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                                    ^\e[0m\n\e[31m   |\e[0mambiguous\
    \ given instances: both \e[33mobject\e[0m \e[35mDeprecatedFloatOrdering\e[0m in\
    \ \e[33mobject\e[0m \e[35mOrdering\e[0m and \e[33mobject\e[0m \e[35mInt\e[0m in\
    \ \e[33mobject\e[0m \e[35mOrdering\e[0m match type Ordering[B] of parameter ord\
    \ of \e[33mmethod\e[0m \e[35mmax\e[0m in \e[33mtrait\e[0m \e[35mIterableOnceOps\e\
    [0m\n3 errors found\n"
  stdout: ''
  timestamp: 1659979342
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = grid.map(_.toList)\n        var need = capacity\n\
    \        buckets.foreach(_.foreach(need = math.min(need, _)))\n        need\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E081] Type Error: /tmp/tmp7qrtpoyv.scala:28:56 -----------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        buckets.foreach(_.foreach(need = math.min(need,\
    \ _)))\n\e[31m\e[31m   |\e[0m                                                \
    \        ^\e[0m\n\e[31m   |\e[0m   Missing parameter type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m   I could not infer the type of the parameter _$3 of expanded function:\n\
    \e[31m   |\e[0m   _$3 => math.min(need, _$3).\n1 error found\n"
  stdout: ''
  timestamp: 1659979340
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = mutable.Map[Long, Long]()\n        var max\
    \ = 0\n        var maxCount = 0\n        grid.foreach { case (l: List[Long]) =>\n\
    \            l.foreach { case (b: Long) =>\n                buckets += (b -> buckets.getOrElse(b,\
    \ 0L) + 1)\n            }\n        }\n        buckets.foreach { case (b: Long,\
    \ count: Long) =>\n            if(max < count) max = count\n        }\n      \
    \  if(max > capacity) max -= 1\n        if(max > 0) maxCount += max\n        maxCount\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp1_4lc64z.scala:26:22 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mbuckets\e[0m = mutable.Map[\e\
    [35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                     \
    \ ^^^^^^^\e[0m\n\e[31m   |\e[0m                      Not found: mutable\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659979340
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        // O(n^2)\n        val map = grid.zipWithIndex.filter{ case\
    \ (w, i) => w == 0 }.map{case (w, i) => (i, w)}.toMap\n        // O(n^2)\n   \
    \     val bucket = grid.zipWithIndex.filter{ case (w, i) => w == 1 }.map{case\
    \ (w, i) => (i, w)}.toMap\n        // O(n^2)\n        val bucket2 = grid.zipWithIndex.filter{\
    \ case (w, i) => w == 0 }.map{case (w, i) => (i, w)}.toMap\n        // O(n^2)\n\
    \        val bucket3 = grid.zipWithIndex.filter{ case (w, i) => w == 1 }.map{case\
    \ (w, i) => (i, w)}.toMap\n        // O(n)\n        val map = map + (bucket +\
    \ bucket2 + bucket3)\n        // O(n^2)\n        val max = map.filter{ case (k,v)\
    \ => v > capacity }.maxBy(_._1)._2\n        // O(1)\n        map\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp18ith3h4.scala:35:12 ---------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e[36mmap\e[0m = map + (bucket\
    \ + bucket2 + bucket3)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmap is already defined as \e[33mvalue\e[0m \e[35mmap\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- Error: /tmp/tmp18ith3h4.scala:27:59\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m27 |\e[0m       \
    \ \e[33mval\e[0m \e[36mmap\e[0m = grid.zipWithIndex.filter{ \e[33mcase\e[0m (w,\
    \ i) => w == \e[31m0\e[0m }.map{\e[33mcase\e[0m (w, i) => (i, w)}.toMap\n\e[31m\e\
    [31m   |\e[0m                                                           ^^^^^^\e\
    [0m\n\e[31m   |\e[0m     Values of types List[Long] and Int cannot be compared\
    \ with == or !=\n\e[31m\e[31m-- Error: /tmp/tmp18ith3h4.scala:29:62 -----------------------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mbucket\e[0m = grid.zipWithIndex.filter{\
    \ \e[33mcase\e[0m (w, i) => w == \e[31m1\e[0m }.map{\e[33mcase\e[0m (w, i) =>\
    \ (i, w)}.toMap\n\e[31m\e[31m   |\e[0m                                       \
    \                       ^^^^^^\e[0m\n\e[31m   |\e[0m     Values of types List[Long]\
    \ and Int cannot be compared with == or !=\n\e[31m\e[31m-- Error: /tmp/tmp18ith3h4.scala:31:63\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m31 |\e[0m       \
    \ \e[33mval\e[0m \e[36mbucket2\e[0m = grid.zipWithIndex.filter{ \e[33mcase\e[0m\
    \ (w, i) => w == \e[31m0\e[0m }.map{\e[33mcase\e[0m (w, i) => (i, w)}.toMap\n\e\
    [31m\e[31m   |\e[0m                                                          \
    \     ^^^^^^\e[0m\n\e[31m   |\e[0m     Values of types List[Long] and Int cannot\
    \ be compared with == or !=\n\e[31m\e[31m-- Error: /tmp/tmp18ith3h4.scala:33:63\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m33 |\e[0m       \
    \ \e[33mval\e[0m \e[36mbucket3\e[0m = grid.zipWithIndex.filter{ \e[33mcase\e[0m\
    \ (w, i) => w == \e[31m1\e[0m }.map{\e[33mcase\e[0m (w, i) => (i, w)}.toMap\n\e\
    [31m\e[31m   |\e[0m               "
  stdout: ''
  timestamp: 1659979346
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val n = grid.length\n        val m = grid.head.length\n\
    \        val maxFill = 0\n        var lastRow = 0\n        var lastCol = 0\n \
    \       var count = 0\n        val nextCol = lastCol + 1\n        while(count\
    \ < capacity) {\n            val maxCol = if (nextCol == m) n else nextCol\n \
    \           val maxRow = if (lastRow == n) n else lastRow\n            val newRow\
    \ = grid.apply(maxRow)\n            val newCol = grid.apply(maxCol)\n        \
    \    val bucket = newCol.indexOf(1l)\n            val newVal = newRow.apply(bucket)\n\
    \            val value = newVal.toLong\n            val diff = value - capacity\n\
    \            if (diff > 0)\n                count += diff\n            val nextVal\
    \ = newRow.apply(bucket + 1)\n            nextVal.toLong - capacity\n        }\n\
    \        count\n    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpiha_kuri.scala:43:22 ------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m                count += diff\n\e[31m\e[31m   |\e[0m\
    \                ^^^^^^^^\e[0m\n\e[31m   |\e[0m                value += is not\
    \ a member of Int - did you mean Int.!=?\n1 error found\n"
  stdout: ''
  timestamp: 1659979344
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val nWell = grid.length\n        val nColumn = grid.head.length\n\
    \        val grid = mutable.ArrayBuffer.empty[List[Long]](nWell)\n        var\
    \ max = 0\n        var min = 0\n        for (i <- 0 until nWell)\n           \
    \ grid += 0 :: Nil\n\n        for (i <- 0 until nWell) {\n            grid +=\
    \ grid(i)\n            if (grid(i).length == nColumn) {\n                for (j\
    \ <- 0 until nColumn) {\n                    if (grid[i].exists(_ == j))\n   \
    \                     max += 1\n                    else\n                   \
    \     min += 1\n                }\n            }\n        }\n\n        if (min\
    \ < max) max\n        else\n            min * capacity\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmplphhdhhq.scala:28:19 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mgrid\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mList\e[0m[\e[35mLong\e[0m]](nWell)\n\e[31m\e[31m   |\e[0m                \
    \   ^^^^^^^\e[0m\n\e[31m   |\e[0m                   Not found: mutable\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmplphhdhhq.scala:28:57 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mgrid\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mList\e[0m[\e[35mLong\e[0m]](nWell)\n\e[31m\e[31m   |\e[0m                \
    \                                         ^\e[0m\n\e[31m   |\e[0m            \
    \                            Recursive \e[33mvalue\e[0m \e[35mnWell\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmplphhdhhq.scala:38:29\
    \ ------------------------\e[0m\e[0m\n\e[31m38 |\e[0m                    \e[33mif\e\
    [0m (grid[\e[35mi\e[0m].exists(_ == j))\n\e[31m\e[31m   |\e[0m               \
    \              ^\e[0m\n\e[31m   |\e[0m                             Not found:\
    \ type i\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659979341
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val wells = mutable.Map[Long,List[Long]]()\n        for\
    \ ((row,rows) <- grid) {\n            val buckets = mutable.ListBuffer.empty[Long]\n\
    \            for (i <- 0 until rows.length)\n                if (row(i) == 1)\
    \ buckets += 1\n            wells += (row.toLong -> buckets)\n        }\n    \
    \    var i = 0\n        while (i<capacity) {\n            val buckets = wells(i)\n\
    \            i += 1\n            if (buckets.isEmpty) i-1\n            else buckets.min\
    \ - 1\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpott9j00c.scala:26:20 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mwells\e[0m = mutable.Map[\e\
    [35mLong\e[0m,\e[35mList\e[0m[\e[35mLong\e[0m]]()\n\e[31m\e[31m   |\e[0m     \
    \               ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpott9j00c.scala:28:26\
    \ ------------------------\e[0m\e[0m\n\e[31m28 |\e[0m            \e[33mval\e[0m\
    \ \e[36mbuckets\e[0m = mutable.ListBuffer.empty[\e[35mLong\e[0m]\n\e[31m\e[31m\
    \   |\e[0m                          ^^^^^^^\e[0m\n\e[31m   |\e[0m            \
    \              Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpott9j00c.scala:29:35 ------------------------\e[0m\e[0m\n\e[31m29 |\e\
    [0m            \e[33mfor\e[0m (i <- \e[31m0\e[0m until rows.length)\n\e[31m\e\
    [31m   |\e[0m                              ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \                             value length is not a member of Any\n\e[31m\e[31m--\
    \ [E050] Type Error: /tmp/tmpott9j00c.scala:30:20 -----------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m                \e[33mif\e[0m (row(i) == \e[31m1\e[0m)\
    \ buckets += \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m                    ^^^\e[0m\n\
    \e[31m   |\e[0m                    \e[33mvalue\e[0m \e[35mrow\e[0m does not take\
    \ parameters\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpott9j00c.scala:34:8\
    \ ---------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mwhile\e[0m (i<capacity)\
    \ {\n\e[31m\e[31m   |\e[0m        ^\e[0m\n\e[31m   |\e[0m        Found:    Unit\n\
    \e[31m   |\e[0m        Required: Long\n\e[31m35 |\e[0m            \e[33mval\e\
    [0m \e[36mbuckets\e[0m = wells(i)\n\e[31m36 |\e[0m            i += \e[31m1\e[0m\n\
    \e[31m37 |\e[0m            \e[33mif\e[0m (buckets.isEmpty) i-\e[31m1\e[0m\n\e\
    [31m38 |\e[0m            \e[33melse\e[0m buckets.min - \e[31m1\e[0m\n\e[31m39\
    \ |\e[0m        }\n\e[31m   |\e[0m\n\e"
  stdout: ''
  timestamp: 1659979346
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n      val buckets = grid.map(_.toSet).map(_.size)\n      val maxBuckets\
    \ = buckets.max\n      (0 until maxBuckets).toSeq.foldLeft(0)((acc, _) => acc\
    \ + (buckets.takeWhile(_ == _).sum - buckets.dropWhile(_ == _).sum))\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E086] Syntax Error: /tmp/tmpw76v_r6j.scala:28:82 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m      (\e[31m0\e[0m until maxBuckets).toSeq.foldLeft(\e\
    [31m0\e[0m)((\e[36macc\e[0m, _) => acc + (buckets.takeWhile(_ == _).sum - buckets.dropWhile(_\
    \ == _).sum))\n\e[31m\e[31m   |\e[0m                                         \
    \                                         ^^^^^^\e[0m\n\e[31m   |\e[0m       \
    \                          Wrong number of parameters, expected: 1\n\e[31m\e[31m--\
    \ [E086] Syntax Error: /tmp/tmpw76v_r6j.scala:28:114 --------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m      (\e[31m0\e[0m until maxBuckets).toSeq.foldLeft(\e\
    [31m0\e[0m)((\e[36macc\e[0m, _) => acc + (buckets.takeWhile(_ == _).sum - buckets.dropWhile(_\
    \ == _).sum))\n\e[31m\e[31m   |\e[0m                                         \
    \                                                                         ^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                 Wrong number of parameters,\
    \ expected: 1\n2 errors found\n"
  stdout: ''
  timestamp: 1659979345
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val numRows = grid.length\n        val numCols = grid.head.length\n\
    \        val fill = (0 until numCols).filter(x => x % 2 != 0).foldLeft(1l)((x,\
    \ y) => x * y)\n        val grid = grid.map(x => x.map(y => (y, 0))).map(_.toList)\n\
    \        val numFill = grid.map(x => x.map(y => y % 2 == 0).sum).foldLeft(0l)((x,\
    \ y) => x + y)\n        val result = numFill / numRows * capacity - fill\n   \
    \     result\n    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpib45j_ek.scala:29:19 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mgrid\e[0m = grid.map(\e\
    [36mx\e[0m => x.map(\e[36my\e[0m => (y, \e[31m0\e[0m))).map(_.toList)\n\e[31m\e\
    [31m   |\e[0m                   ^\e[0m\n\e[31m   |\e[0m                   Recursive\
    \ \e[33mvalue\e[0m \e[35mgrid\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979345
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        // fill a rectangle from each well with water, if \n   \
    \     // the water cannot fill the well, \n        // lower the capacity of the\
    \ well\n        // if the water can fill the well, \n        // increase the capacity\
    \ of the well\n        // we use a priority queue to ensure that the max is determined\n\
    \        // by priority \n        val p = PriorityQueue[((Int, Long), Boolean)]\n\
    \        val result = mutable.ListBuffer.empty[Long]\n        for (i <- 0 until\
    \ grid.length) {\n            for (j <- 0 until grid(0).length) {\n          \
    \      if (grid(i)(j) ==  0) {\n                    // fill a rectangle from each\
    \ well with water, if \n                    // the water cannot fill the well,\
    \ \n                    // lower the capacity of the well\n                  \
    \  // if the water can fill the well, \n                    // increase the capacity\
    \ of the well\n                    p.enqueue(((i,j), false))\n               \
    \ } else {\n                    // the water can fill the well, \n           \
    \         // increase the capacity of the well\n                    p.enqueue(((i,j),\
    \ true))\n                }\n            }\n        }\n        // dequeue all\
    \ items that can fill the well\n        while(!p.isEmpty) {\n            val item\
    \ = p.dequeue\n            if (item._2) {\n                result += (item._1._1\
    \ * item._1._2)\n            }\n        }\n        // return result\n        result.max\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp6f79zrzp.scala:34:21 ------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmp6f79zrzp.scala:43:22 ------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m                    p.enqueue(((i,j), \e[31mfalse\e[0m))\n\
    \e[31m\e[31m   |\e[0m                    ^^^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \   value enqueue is not a member of Seq[((Int, Long), Boolean)] => \n\e[31m \
    \  |\e[0m          scala.collection.mutable.PriorityQueue[((Int, Long), Boolean)]\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp6f79zrzp.scala:47:22 ------------------------\e\
    [0m\e[0m\n\e[31m47 |\e[0m                    p.enqueue(((i,j), \e[31mtrue\e[0m))\n\
    \e[31m\e[31m   |\e[0m                    ^^^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \   value enqueue is not a member of Seq[((Int, Long), Boolean)] => \n\e[31m \
    \  |\e[0m          scala.collection.mutable.PriorityQueue[((Int, Long), Boolean)]\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp6f79zrzp.scala:52:17 ------------------------\e\
    [0m\e[0m\n\e[31m52 |\e[0m        \e[33mwhile\e[0m(!p.isEmpty) {\n\e[31m\e[31m\
    \   |\e[0m               ^^^^^^^^^\e[0m\n\e[31m   |\e[0m        value isEmpty\
    \ is not a member of Seq[((Int, Long), Boolean)] => \n\e[31m   |\e[0m        \
    \  scala.collection.mutable.PriorityQueue[((Int, Long), Boolean)]\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmp6f79zrzp.scala:53:25 ------------------------\e\
    [0m\e[0m\n\e[31m53 |\e[0m            \e[33mval\e[0m \e[36mitem\e[0m = p.dequeue\n\
    \e[31m\e[31m   |\e[0m                       ^^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \      value dequeue is not a member of Seq[((Int, Long), Boolean)] => \n\e[31m\
    \   |\e[0m          scala.collection.mutable.PriorityQueue[((Int, Long), Boolean)]\n\
    5 errors found\n"
  stdout: ''
  timestamp: 1659979351
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val emptyWells = mutable.Map[Long, Long]()\n        grid.foreach\
    \ { row =>\n            row.foreach { j =>\n                emptyWells(j) match\
    \ {\n                    case Some(well) => {\n                        val emptyCount\
    \ = emptyWells(j)\n                        emptyWells(j) = 0\n               \
    \         val remain = well - capacity\n                        if(remain <= emptyCount)\
    \ {\n                            emptyWells += (j -> remain)\n               \
    \         }\n                    }\n                    case None => \n      \
    \          }\n            }\n        }\n        emptyWells.valuesIterator.foldLeft((1l,\
    \ 0l))((acc, next) => if(acc._1 < next._1) (acc._1, next._1) else next)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp278i4f5s.scala:26:25 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36memptyWells\e[0m = mutable.Map[\e\
    [35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                     \
    \    ^^^^^^^\e[0m\n\e[31m   |\e[0m                         Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp278i4f5s.scala:33:37\
    \ ------------------------\e[0m\e[0m\n\e[31m33 |\e[0m                        \e\
    [33mval\e[0m \e[36mremain\e[0m = well - capacity\n\e[31m\e[31m   |\e[0m      \
    \                               ^^^^\e[0m\n\e[31m   |\e[0m                   \
    \                  Not found: well\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659979346
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        def getTotalArea(grid : List[List[Long]]): Long = {\n  \
    \          val totalArea = 0L\n            for(i <- 0 until grid.length) {\n \
    \               for(j <- 0 until grid[i].length) {\n                    totalArea\
    \ += grid[i][j].toLong\n                }\n            }\n            totalArea\n\
    \        }\n\n        def getBucketCapacity(bucketCapacity : Long, grid : List[List[Long]]):\
    \ Long = {\n            val bucketCapacity = bucketCapacity.toInt\n          \
    \  val totalArea = getTotalArea(grid)\n            bucketCapacity * (totalArea\
    \ / grid().length).toInt\n        }\n\n        def getTotalWaterInBucket(bucket\
    \ : List[Long], grid : List[List[Long]]): Long = {\n            var totalWater\
    \ = 0L\n            for(i <- 0 until bucket.length) {\n                totalWater\
    \ += bucket[i].toLong * grid()(i)(j)\n            }\n            totalWater\n\
    \        }\n\n        val totalBucket = grid.length zip grid().map(_.length).max\n\
    \        val bucketCapacity = capacity / totalBucket\n\n        var totalWaterInBucket\
    \ = 0L\n        var bucketsNeedToBeRemoved = new Array[Long](totalBucket)\n  \
    \      for(i <- 0 until totalBucket) {\n            totalWaterInBucket = getTotalWaterInBucket(grid(i),\
    \ grid)\n            val needToBeRemoved = totalWaterInBucket - bucketCapacity\n\
    \            if(needToBeRemoved > 0) {\n                bucketsNeedToBeRemoved(i)\
    \ = needToBeRemoved\n            }\n        }\n\n        var maxWater = 0L\n \
    \       for(i <- 0 until bucketsNeedToBeRemoved.length) {\n            maxWater\
    \ = Math.max(maxWater, bucketsNeedToBeRemoved(i) + getBucketCapacity(bucketCapacity,\
    \ grid))\n        }\n        maxWater\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 1l.toLong,\
    \ 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong, 0l.toLong), List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (1l)) == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpkzi_l33p.scala:29:38 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m                \e[33mfor\e[0m(j <- \e[31m0\e[0m until\
    \ grid[\e[35mi\e[0m].length) {\n\e[31m\e[31m   |\e[0m                        \
    \              ^\e[0m\n\e[31m   |\e[0m                                      Not\
    \ found: type i\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpkzi_l33p.scala:30:30\
    \ ------------------------\e[0m\e[0m\n\e[31m30 |\e[0m                    totalArea\
    \ += grid[\e[35mi\e[0m][\e[35mj\e[0m].toLong\n\e[31m\e[31m   |\e[0m          \
    \          ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m           value += is not a member\
    \ of Long - did you mean totalArea.!=?\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpkzi_l33p.scala:30:41 ------------------------\e[0m\e[0m\n\e[31m30 |\e\
    [0m                    totalArea += grid[\e[35mi\e[0m][\e[35mj\e[0m].toLong\n\e\
    [31m\e[31m   |\e[0m                                         ^\e[0m\n\e[31m   |\e\
    [0m                                         Not found: type j\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpkzi_l33p.scala:30:38 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m                    totalArea += grid[\e[35mi\e[0m][\e\
    [35mj\e[0m].toLong\n\e[31m\e[31m   |\e[0m                                    \
    \  ^\e[0m\n\e[31m   |\e[0m                                      Not found: type\
    \ i\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpkzi_l33p.scala:37:33\
    \ ---------------------------\e[0m\e[0m\n\e[31m37 |\e[0m            \e[33mval\e\
    [0m \e[36mbucketCapacity\e[0m = bucketCapacity.toInt\n\e[31m\e[31m   |\e[0m  \
    \                               ^\e[0m\n\e[31m   |\e[0m                      \
    \         Recursive \e[33mvalue\e[0m \e[35mbucketCapacity\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpkzi_l33p.scala:45:27\
    \ ------------"
  stdout: ''
  timestamp: 1659979353
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        def recurse(w : List[Long], b : List[Long], c : Long) :\
    \ Long = {\n            if (w.length == 0) return c\n            if (b.length\
    \ == 0) return recurse(w, b, c+w(w.head))\n            if (w(w.head) == 0) return\
    \ recurse(w, b, c+recurse(w, b, c))\n            return recurse(w, b, c+recurse(w,\
    \ b, c+w(w.head)))\n        }\n        val n = grid.length\n        val m = grid(0).length\n\
    \        val b = mutable.ArrayBuffer(capacity)\n        for (i <- 0 until n) b\
    \ += 0\n        recurse(grid, b, 0)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 1l.toLong,\
    \ 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong, 0l.toLong), List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (1l)) == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpbw5jdgps.scala:28:58\
    \ --------------------\e[0m\e[0m\n\e[31m28 |\e[0m            \e[33mif\e[0m (b.length\
    \ == \e[31m0\e[0m) \e[33mreturn\e[0m recurse(w, b, c+w(w.head))\n\e[31m\e[31m\
    \   |\e[0m                                                        ^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                                        Found:\
    \    Long\n\e[31m   |\e[0m                                                   \
    \     Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpbw5jdgps.scala:29:20\
    \ --------------------\e[0m\e[0m\n\e[31m29 |\e[0m            \e[33mif\e[0m (w(w.head)\
    \ == \e[31m0\e[0m) \e[33mreturn\e[0m recurse(w, b, c+recurse(w, b, c))\n\e[31m\e\
    [31m   |\e[0m                  ^^^^^^\e[0m\n\e[31m   |\e[0m                  Found:\
    \    Long\n\e[31m   |\e[0m                  Required: Int\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpbw5jdgps.scala:30:55 --------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m            \e[33mreturn\e[0m recurse(w, b, c+recurse(w,\
    \ b, c+w(w.head)))\n\e[31m\e[31m   |\e[0m                                    \
    \                 ^^^^^^\e[0m\n\e[31m   |\e[0m                               \
    \                      Found:    Long\n\e[31m   |\e[0m                       \
    \                              Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpbw5jdgps.scala:34:16 ------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36mb\e[0m = mutable.ArrayBuffer(capacity)\n\
    \e[31m\e[31m   |\e[0m                ^^^^^^^\e[0m\n\e[31m   |\e[0m           \
    \     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpbw5jdgps.scala:36:16 --------------------\e[0m\e[0m\n\e[31m36\
    \ |\e[0m        recurse(grid, b, \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m        \
    \        ^^^^\e[0m\n\e"
  stdout: ''
  timestamp: 1659979355
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val rows = grid.length\n        val columns = grid(0).length\n\
    \        val empty = rows.toLong * columns.toLong\n        val toBeEmpty = capacity\
    \ - empty\n        val filler = (0 until rows).map(i => 0 until columns).map(j\
    \ => (0l).asInstanceOf[List[Long]])\n        val list = List[List[Long]](List(grid))\n\
    \        val toBeEmpty = capacity - empty\n        val toBeFilled = (0 until rows).map(i\
    \ => 0 until columns).map(j => (0l).asInstanceOf[List[Long]])\n        toBeEmpty\
    \ match {\n            case i if i >= list.size => 0\n            case i if (list(i).length\
    \ == 0) => 0\n            case i =>\n                val filler = (0 until i).map(j\
    \ => 0 until columns).map(k => (0l).asInstanceOf[List[Long]])\n              \
    \  val list = List[List[Long]](list.toBuffer)\n                val toBeEmpty =\
    \ capacity - empty\n                val toBeFilled = (0 until i).map(j => 0 until\
    \ columns).map(k => (0l).asInstanceOf[List[Long]])\n                toBeEmpty\
    \ match {\n                    case i if i >= list.size => 0\n               \
    \     case i if (list(i).length == 0) => 0\n                    case i =>\n  \
    \                      val filler = (0 until i).map(j => 0 until columns).map(k\
    \ => (0l).asInstanceOf[List[Long]])\n                        val list = List[List[Long]](list.toBuffer)\n\
    \                        val toBeEmpty = capacity - empty\n                  \
    \      val toBeFilled = (0 until i).map(j => 0 until columns).map(k => (0l).asInstanceOf[List[Long]])\n\
    \                        toBeEmpty match {\n                            case i\
    \ if i >= list.size => 0\n                            case i if (list(i).length\
    \ == 0) => 0\n                            case i =>\n                        \
    \        val filler = (0 until i).map(j => 0 until columns).map(k => (0l).asInstanceOf[List[Long]])\n\
    \                                val list = List[List[Long]](list.toBuffer)\n\
    \                                val toBeEmpty = capacity - empty\n          \
    \                      val toBeFilled = (0 until i).map(j => 0 until columns).map(k\
    \ => (0l).asInstanceOf[List[Long]])\n                                toBeEmpty\
    \ match {\n                                    case i if i >= list.size => 0\n\
    \                                    case i if (list(i).length == 0) => 0\n  \
    \                                  case i =>\n                               \
    \         \n    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpfoi7okxt.scala:73:0 ----------------------------\e\
    [0m\e[0m\n\e[31m73 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpfoi7okxt.scala:32:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m\
    \ \e[36mtoBeEmpty\e[0m = capacity - empty\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mtoBeEmpty is already defined as \e[33mvalue\e[0m \e[35mtoBeEmpty\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmpfoi7okxt.scala:31:41 --------------------\e[0m\e[0m\n\
    \e[31m31 |\e[0m        \e[33mval\e[0m \e[36mlist\e[0m = List[\e[35mList\e[0m[\e\
    [35mLong\e[0m]](List(grid))\n\e[31m\e[31m   |\e[0m                           \
    \              ^^^^\e[0m\n\e[31m   |\e[0m                                    \
    \ Found:    (grid : List[List[Long]])\n\e[31m   |\e[0m                       \
    \              Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpfoi7okxt.scala:36:28 --------------------\e[0m\e[0m\n\e[31m36\
    \ |\e[0m            \e[33mcase\e[0m i \e[33mif\e[0m (list(i).length == \e[31m0\e\
    [0m) => \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m                            ^\e[0m\n\
    \e[31m   |\e[0m                            Found:    (i : Long)\n\e[31m   |\e\
    [0m                            Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpfoi7okxt.scala:38:38 --------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m                \e[33mval\e[0m \e[36mfiller\e[0m = (\e\
    [31m0\e[0m until i).map(\e[36mj\e[0m => \e[31m0\e[0m until columns).map(\e[36mk\e\
    [0m => (\e[31m0l\e[0m).asInstanceOf[\e[35mList\e[0m[\e[35mLong\e[0m]])\n\e[31m\e\
    [31m   |\e[0m                                      ^\e[0m\n\e[31m   |\e[0m   \
    \                                   Found:    (i : Long)\n\e[31m   |\e[0m    \
    \                               "
  stdout: ''
  timestamp: 1659979358
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val bucket = mutable.ArrayBuffer(capacity).scanLeft(0l)(_\
    \ + _)\n        \n        for(row <- 0 until grid.size) {\n            val row1\
    \ = row.copy\n            val row2 = row.copy\n            for(col <- 0 until\
    \ grid(0).size) {\n                val currentCount = bucket(col - 1 )\n     \
    \           val newCount = row1(col - 1).plus(row2(col - 1).minus(currentCount))\n\
    \                bucket(col - 1 ) = newCount\n            }\n        }\n     \
    \   \n        bucket.sum\n    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp_8m91tnp.scala:26:21 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mbucket\e[0m = mutable.ArrayBuffer(capacity).scanLeft(\e\
    [31m0l\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp_8m91tnp.scala:29:27 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m            \e[33mval\e[0m \e[36mrow1\e[0m = row.copy\n\
    \e[31m\e[31m   |\e[0m                       ^^^^^^^^\e[0m\n\e[31m   |\e[0m   \
    \                    value copy is not a member of Int\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp_8m91tnp.scala:30:27 ------------------------\e[0m\e\
    [0m\n\e[31m30 |\e[0m            \e[33mval\e[0m \e[36mrow2\e[0m = row.copy\n\e\
    [31m\e[31m   |\e[0m                       ^^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                  value copy is not a member of Int\n3 errors found\n"
  stdout: ''
  timestamp: 1659979355
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val size = grid.size\n        if (size == 0) 0 else (grid.map(_(1)).sum\
    \ - grid(0).sum) * capacity / grid(0).sum\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 1l.toLong,\
    \ 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong, 0l.toLong), List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (1l)) == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpsm1zwvyu.scala:30)\n\tat Problem.main(tmpsm1zwvyu.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979358
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val totalCapacity : Long = grid.map(_.size).sum\n\n    \
    \    var totalWater : Long = 0\n\n        // create buckets\n        var buckets\
    \ : List[Long] = List.fill(grid.size)(0L)\n        grid.foreach{ row =>\n    \
    \        val currentCapacity = row.size\n            val currentWater = 1L\n \
    \           val currentBucket = buckets(row.index.toInt)\n            val newCapacity\
    \ = currentCapacity + currentWater\n            buckets(row.index.toInt) = if\
    \ (currentCapacity < newCapacity) currentCapacity else newCapacity\n        }\n\
    \n        // fill buckets\n        var fillCount : Long = 0\n        while(totalWater\
    \ < totalCapacity) {\n            // check buckets left\n            var checkCount\
    \ : Long = 0\n            while(buckets.map(_.toInt).sum > 0) {\n            \
    \    val currentBucket = buckets.map(_.toInt).sum - 1\n                val currentCapacity\
    \ = buckets(currentBucket)\n                val currentWater = grid\n        \
    \        currentWater.foreach{ case (k, v) => if (k == currentBucket) v -= 1 }\n\
    \                checkCount += 1\n                buckets(currentBucket) = currentCapacity\n\
    \            }\n\n            // fill bucket\n            if (checkCount == 0)\
    \ {\n                totalWater += buckets.last\n                buckets = buckets.dropRight(1)\n\
    \            }\n            else {\n                fillCount += 1\n         \
    \       totalWater += buckets(buckets.size - 1)\n                buckets = buckets.tail\n\
    \            }\n        }\n\n        return fillCount\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp8auj7zyb.scala:35:44 ------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m            \e[33mval\e[0m \e[36mcurrentBucket\e[0m =\
    \ buckets(row.index.toInt)\n\e[31m\e[31m   |\e[0m                            \
    \            ^^^^^^^^^\e[0m\n\e[31m   |\e[0m   value index is not a member of\
    \ List[Long] - did you mean row.indexOf?\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmp8auj7zyb.scala:37:12 ------------------------\e[0m\e[0m\n\e[31m37 |\e\
    [0m            buckets(row.index.toInt) = \e[33mif\e[0m (currentCapacity < newCapacity)\
    \ currentCapacity \e[33melse\e[0m newCapacity\n\e[31m\e[31m   |\e[0m         \
    \   ^^^^^^^\e[0m\n\e[31m   |\e[0mvalue update is not a member of List[Long] -\
    \ did you mean List[Long].updated?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp8auj7zyb.scala:37:24\
    \ ------------------------\e[0m\e[0m\n\e[31m37 |\e[0m            buckets(row.index.toInt)\
    \ = \e[33mif\e[0m (currentCapacity < newCapacity) currentCapacity \e[33melse\e\
    [0m newCapacity\n\e[31m\e[31m   |\e[0m                    ^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m   value index is not a member of List[Long] - did you mean row.indexOf?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp8auj7zyb.scala:49:79 ------------------------\e\
    [0m\e[0m\n\e[31m49 |\e[0m                currentWater.foreach{ \e[33mcase\e[0m\
    \ (k, v) => \e[33mif\e[0m (k == currentBucket) v -= \e[31m1\e[0m }\n\e[31m\e[31m\
    \   |\e[0m                                                                   \
    \          ^^^^\e[0m\n\e[31m   |\e[0m                    value -= is not a member\
    \ of Any - did you mean v.!=?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp8auj7zyb.scala:51:16\
    \ ------------------------\e[0m\e[0m\n\e[31m51 |\e[0m                buckets(currentBucket)\
    \ = currentCapacity\n\e[31m\e[31m   |\e[0m                ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mvalue update is not a member of List[Long] - did you mean List[Long].updated?\n\
    5 errors found\n"
  stdout: ''
  timestamp: 1659979357
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        // init\n        val m = grid.length\n        val n = grid.head._2.length\n\
    \        val w = immutable.ArrayBuffer.empty[Long](n)\n        val r = immutable.ArrayBuffer.empty[Long](n)\n\
    \        val f = immutable.ArrayBuffer.empty[Long](n)\n        val l = immutable.ArrayBuffer.empty[Long](n)\n\
    \        val b = immutable.ArrayBuffer.empty[Long](n)\n        var flag = false\n\
    \        val bucket = immutable.ArrayBuffer.empty[Long](n)\n        for (i <-\
    \ 0 until m){\n            for (j <- 0 until n){\n                if (grid(i)(j)\
    \ == 1) {\n                    flag =  true\n                    bucket(j) = capacity\n\
    \                } else {\n                    flag =  false\n               \
    \ }\n                if (flag == true) {\n                    r.update(j, 0)\n\
    \                }\n                l.update(j, 1)\n                f.update(j,\
    \ 0)\n                b.update(j, 1)\n            }\n        }\n        val x\
    \ = r.reduceLeft( (a, b) => a + b )\n        val y = b.reduceLeft( (a, b) => a\
    \ + b )\n        val z = immutable.ArrayBuffer.empty[Long](n)\n        for (j\
    \ <- 0 until n){\n            if (x==1 && y==0) {\n                z(j) = z(j)+1\n\
    \            } else if (x==1 && y==1) {\n                z(j) = z(j)+1\n     \
    \       } else if (x==1 && y==-1) {\n                z(j) = z(j)+1\n         \
    \   } else if (x==-1 && y==1) {\n                z(j) = z(j)+1\n            }\
    \ else if (x==-1 && y==-1) {\n                z(j) = z(j)+1\n            } else\
    \ if (x==1 && y==-2) {\n                z(j) = z(j)+1\n            } else if (x==-1\
    \ && y==-2) {\n                z(j) = z(j)+1\n            }\n        }\n     \
    \   val z = z.reduceLeft( (a, b) => a + b )\n        return (z-bucket.sum)\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpatfu6kt2.scala:72:12 ---------------------------\e\
    [0m\e[0m\n\e[31m72 |\e[0m        \e[33mval\e[0m \e[36mz\e[0m = z.reduceLeft( (\e\
    [36ma\e[0m, \e[36mb\e[0m) => a + b )\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mz is already defined as \e[33mvalue\e[0m \e[35mz\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpatfu6kt2.scala:28:26 ------------------------\e[0m\e[0m\n\e[31m28 |\e\
    [0m        \e[33mval\e[0m \e[36mn\e[0m = grid.head._2.length\n\e[31m\e[31m   |\e\
    [0m                ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                value _2\
    \ is not a member of List[Long]\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpatfu6kt2.scala:29:16\
    \ ------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e\
    [36mw\e[0m = immutable.ArrayBuffer.empty[\e[35mLong\e[0m](n)\n\e[31m\e[31m   |\e\
    [0m                ^^^^^^^^^\e[0m\n\e[31m   |\e[0m                Not found: immutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpatfu6kt2.scala:30:16\
    \ ------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e\
    [36mr\e[0m = immutable.ArrayBuffer.empty[\e[35mLong\e[0m](n)\n\e[31m\e[31m   |\e\
    [0m                ^^^^^^^^^\e[0m\n\e[31m   |\e[0m                Not found: immutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpatfu6kt2.scala:31:16\
    \ ------------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e\
    [36mf\e[0m = immutable.ArrayBuffer.empty[\e[35mLong\e[0m](n)\n\e[31m\e[31m   |\e\
    [0m                ^^^^^^^^^\e[0m\n\e[31m   |\e[0m                Not found: immutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpatfu6kt2.scala:32:16\
    \ ------------------------\e[0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e\
    [36ml\e[0m = immutable.ArrayBuffer.empty[\e[35mLon"
  stdout: ''
  timestamp: 1659979355
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val rows = new collection.mutable.ListBuffer[Long]()\n \
    \       var max = 0l\n        grid.foreach{ row => \n            if(row(0) > 0)\
    \ max += 1\n            rows ++= row\n        }\n        grid.foreach{ row =>\
    \ \n            if(row(0) > 0) max -= 1\n        }\n        val index = Collections.binarySearch(rows,\
    \ capacity)\n        if(index < 0) index else max -= index\n        max\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpqtibogcc.scala:35:20 ------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e[36mindex\e[0m = Collections.binarySearch(rows,\
    \ capacity)\n\e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                    Not found: Collections\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659979352
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        var curBuck = 0\n        var maxBuck = 0\n        var count\
    \ = 0\n        var prev = 0\n        for(i <- 1 to grid.length) {\n          \
    \  for(j <- 1 to grid(i).length) {\n                count +=1\n              \
    \  if(prev != grid[i][j]) {\n                    curBuck += 1\n              \
    \      if(curBuck > capacity) {\n                        maxBuck = count\n   \
    \                     curBuck = 0\n                    }\n                   \
    \ count = 0\n                }\n                prev = grid[i][j]\n          \
    \  }\n        }\n        maxBuck\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 1l.toLong,\
    \ 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong, 0l.toLong), List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (1l)) == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpi15pqo08.scala:33:35 ------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m                \e[33mif\e[0m(prev != grid[\e[35mi\e\
    [0m][\e[35mj\e[0m]) {\n\e[31m\e[31m   |\e[0m                                 \
    \  ^\e[0m\n\e[31m   |\e[0m                                   Not found: type j\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpi15pqo08.scala:33:32\
    \ ------------------------\e[0m\e[0m\n\e[31m33 |\e[0m                \e[33mif\e\
    [0m(prev != grid[\e[35mi\e[0m][\e[35mj\e[0m]) {\n\e[31m\e[31m   |\e[0m       \
    \                         ^\e[0m\n\e[31m   |\e[0m                            \
    \    Not found: type i\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpi15pqo08.scala:41:31\
    \ ------------------------\e[0m\e[0m\n\e[31m41 |\e[0m                prev = grid[\e\
    [35mi\e[0m][\e[35mj\e[0m]\n\e[31m\e[31m   |\e[0m                             \
    \  ^\e[0m\n\e[31m   |\e[0m                               Not found: type j\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpi15pqo08.scala:41:28\
    \ ------------------------\e[0m\e[0m\n\e[31m41 |\e[0m                prev = grid[\e\
    [35mi\e[0m][\e[35mj\e[0m]\n\e[31m\e[31m   |\e[0m                            ^\e\
    [0m\n\e[31m   |\e[0m                            Not found: type i\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1659979353
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        if (grid.isEmpty)\n            return 0\n        var max\
    \ : Long = 0\n        for (row <- grid) {\n            if (row.length > 1) {\n\
    \                var n = 0\n                for (j <- 1 to row.length - 1)\n \
    \                   n += if (row[j] % 2 == 1) capacity else -capacity\n      \
    \          if (n > max)\n                    max = n\n            }\n        }\n\
    \        max \n    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp9pbuzae0.scala:33:25 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m                    n += \e[33mif\e[0m (row[j] % \e[31m2\e\
    [0m == \e[31m1\e[0m) capacity \e[33melse\e[0m -capacity\n\e[31m\e[31m   |\e[0m\
    \                         ^^\e[0m\n\e[31m   |\e[0m                         expression\
    \ expected but \e[31mif\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmp9pbuzae0.scala:33:22 ------------------------\e[0m\e[0m\n\e[31m33 |\e\
    [0m                    n += \e[33mif\e[0m (row[j] % \e[31m2\e[0m == \e[31m1\e\
    [0m) capacity \e[33melse\e[0m -capacity\n\e[31m\e[31m   |\e[0m               \
    \     ^^^^\e[0m\n\e[31m   |\e[0m                  value += is not a member of\
    \ Int - did you mean Int.!=?\n2 errors found\n"
  stdout: ''
  timestamp: 1659979355
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        if(grid.isEmpty) {\n            return 0\n        }\n  \
    \      // find max capacity of bucket\n        val maxCapacity = grid.max((a,\
    \ b) => b.last - a.last).last\n        // count number of filling needed\n   \
    \     var count = 0\n        for(row <- grid.zipWithIndex; bucket <- row.last){\n\
    \            if(bucket.last > maxCapacity) {\n                count += maxCapacity\
    \ - bucket.last\n            }\n        }\n        return count\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp2l28uvvf.scala:30:45\
    \ --------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mmaxCapacity\e\
    [0m = grid.max((\e[36ma\e[0m, \e[36mb\e[0m) => b.last - a.last).last\n\e[31m\e\
    [31m   |\e[0m                                             ^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                             Found:    Long\n\e\
    [31m   |\e[0m                                             Required: Int\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp2l28uvvf.scala:33:48 ------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mfor\e[0m(row <- grid.zipWithIndex; bucket\
    \ <- row.last){\n\e[31m\e[31m   |\e[0m                                       \
    \         ^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue foreach is not a member of Tuple.Last[(List[Long]\
    \ @uncheckedVariance, Int)]\n2 errors found\n"
  stdout: ''
  timestamp: 1659979359
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        if(grid.isEmpty)\n            return 0\n        var cnt\
    \ : Long = 0\n        for(r <- 1 to grid.length-1) {\n            if(capacity\
    \ < 0)\n                break\n            cnt += grid(r-1).sum\n            grid[r-1]\
    \ = grid[r-1].filter(_ != 1)\n            grid[r-1].foreach{ x =>\n          \
    \      val d = grid(r-1).lastIndex - r-1\n                if(d < 0)\n        \
    \            break\n                grid[r-1].remove(x)\n                grid[r-1].last\
    \ = x\n                grid[r-1].foreach{ x =>\n                    if(x <= 0)\n\
    \                        break\n                    grid[r-1].insert(x, 0)\n \
    \               }\n            }\n            grid[r-1].foreach{ x =>\n      \
    \          if(x <= 0)\n                    break\n                grid[r-1].remove(x)\n\
    \                grid[r-1].last = x\n                grid[r-1].foreach{ x =>\n\
    \                    if(x <= 0)\n                        break\n             \
    \       grid[r-1].insert(x, 0)\n                }\n            }\n        }\n\
    \        cnt\n    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmps1b5o9_w.scala:33:22 -----------------------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m            grid[\e[35mr-\e[31m1\e[0m] = grid[r-\e[31m1\e\
    [0m].filter(_ != \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m                      ^\e\
    [0m\n\e[31m   |\e[0m                      end of statement expected but '=' found\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmps1b5o9_w.scala:31:16 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m                break\n\e[31m\e[31m   |\e[0m        \
    \        ^^^^^\e[0m\n\e[31m   |\e[0m                Not found: break\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmps1b5o9_w.scala:33:18 ------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m            grid[\e[35mr-\e[31m1\e[0m] = grid[r-\e[31m1\e\
    [0m].filter(_ != \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\
    \e[31m   |\e[0m                  Not found: type -\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmps1b5o9_w.scala:34:18 ------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m            grid[\e[35mr-\e[31m1\e[0m].foreach{ \e[36mx\e\
    [0m =>\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m       \
    \           Not found: type -\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmps1b5o9_w.scala:46:18 ------------------------\e[0m\e[0m\n\e[31m46 |\e\
    [0m            grid[\e[35mr-\e[31m1\e[0m].foreach{ \e[36mx\e[0m =>\n\e[31m\e[31m\
    \   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                  Not found:\
    \ type -\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n5 errors found\n"
  stdout: ''
  timestamp: 1659979353
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val rows = grid.length\n        val cols = grid(0).get.length\n\
    \        val numWells = rows * (cols - 1)\n        val numBuckets = capacity /\
    \ cols \n        val res = new mutable.HashMap[Long, Long]\n        val numRes\
    \ = new mutable.HashMap[Long, Long]\n        val startTime = System.currentTimeMillis()\n\
    \        val numRes = cols * rows * numBuckets // 1 million records\n        val\
    \ res = numRes.toArray.zipWithIndex.toList.sortBy(-_._2).take(numBuckets)\n  \
    \      val startTime1 = System.currentTimeMillis()\n        val numRes = numBuckets\
    \ * numWells // 10 million\n        val res1 = numRes.toArray.zipWithIndex.toList.sortBy(-_._2).take(numWells)\n\
    \        val startTime2 = System.currentTimeMillis()\n        val numRes = numWells\
    \ * numBuckets // 100 million\n        val res2 = numRes.toArray.zipWithIndex.toList.sortBy(-_._2).take(numBuckets)\n\
    \        val startTime3 = System.currentTimeMillis()\n        val numRes = numBuckets\
    \ * numWells // 1 million\n        val res3 = numRes.toArray.zipWithIndex.toList.sortBy(-_._2).take(numWells)\n\
    \        val startTime4 = System.currentTimeMillis()\n        val numRes = numBuckets\
    \ * numWells // 1 million\n        val res4 = numRes.toArray.zipWithIndex.toList.sortBy(-_._2).take(numWells)\n\
    \        val startTime5 = System.currentTimeMillis()\n        val numRes = numBuckets\
    \ * numWells // 1 million\n        val res5 = numRes.toArray.zipWithIndex.toList.sortBy(-_._2).take(numWells)\n\
    \        val startTime6 = System.currentTimeMillis()\n        val numRes = numBuckets\
    \ * numWells // 1 million\n        val res6 = numRes.toArray.zipWithIndex.toList.sortBy(-_._2).take(numWells)\n\
    \        val startTime7 = System.currentTimeMillis()\n        val numRes = numBuckets\
    \ * numWells // 1 million\n        val res7 = numRes.toArray.zipWithIndex.toList.sortBy(-_._2).take(numWells)\n\
    \        val startTime8 = System.currentTimeMillis()\n        val numRes = numBuckets\
    \ * numWells // 1 million\n        val res8 = numRes.toArray.zipWithIndex.toList.sortBy(-_._2).take(num\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp29n_3ecu.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp29n_3ecu.scala:33:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36mnumRes\e[0m = cols * rows * numBuckets \e[34m// 1 million records\e[0m\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mnumRes is already defined as \e[33mvalue\e[0m \e[35mnumRes\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp29n_3ecu.scala:34:12 ---------------------------\e[0m\e[0m\n\e[31m34\
    \ |\e[0m        \e[33mval\e[0m \e[36mres\e[0m = numRes.toArray.zipWithIndex.toList.sortBy(-_._2).take(numBuckets)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mres is already defined as \e[33mvalue\e[0m \e[35mres\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp29n_3ecu.scala:36:12 ---------------------------\e[0m\e[0m\n\e[31m36\
    \ |\e[0m        \e[33mval\e[0m \e[36mnumRes\e[0m = numBuckets * numWells \e[34m//\
    \ 10 million\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mnumRes is already defined as \e[33mvalue\e[0m \e[35mnumRes\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp29n_3ecu.scala:39:12 ---------------------------\e[0m\e[0m\n\e\
    [31m39 |\e[0m        \e[33mval\e[0m \e[36mnumRes\e[0m = numWells * numBuckets\
    \ \e[34m// 100 million\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mnumRes is already defined as \e[33mvalue\e[0m \e[35mnumRes\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of top"
  stdout: ''
  timestamp: 1659979359
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val N = grid.length\n        val M = grid(0).length\n  \
    \      val fill = mutable.HashMap[Long, Int]()\n        for (i <- 0 until N) {\n\
    \            for (j <- 0 until M) {\n                if (grid[i][j].toLong ==\
    \ 0) {\n                    val bucket = capacity / M\n                    if\
    \ (fill.getOrElse(bucket, 0l).isDefined) {\n                        fill.put(bucket,\
    \ fill.get(bucket)+1)\n                        grid[i][j] = 1l\n             \
    \       }\n                }\n            }\n        }\n        fill.map(_._2).reduce((x,y)=>x+y).toLong\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpblz_rh4g.scala:35:35 -----------------------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m                        grid[\e[35mi\e[0m][\e[35mj\e\
    [0m] = \e[31m1l\e[0m\n\e[31m\e[31m   |\e[0m                                  \
    \ ^\e[0m\n\e[31m   |\e[0m                                 end of statement expected\
    \ but '=' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpblz_rh4g.scala:28:19\
    \ ------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e\
    [36mfill\e[0m = mutable.HashMap[\e[35mLong\e[0m, \e[35mInt\e[0m]()\n\e[31m\e[31m\
    \   |\e[0m                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                   Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpblz_rh4g.scala:31:28\
    \ ------------------------\e[0m\e[0m\n\e[31m31 |\e[0m                \e[33mif\e\
    [0m (grid[\e[35mi\e[0m][\e[35mj\e[0m].toLong == \e[31m0\e[0m) {\n\e[31m\e[31m\
    \   |\e[0m                            ^\e[0m\n\e[31m   |\e[0m                \
    \            Not found: type j\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpblz_rh4g.scala:31:25 ------------------------\e[0m\e[0m\n\e[31m31 |\e\
    [0m                \e[33mif\e[0m (grid[\e[35mi\e[0m][\e[35mj\e[0m].toLong == \e\
    [31m0\e[0m) {\n\e[31m\e[31m   |\e[0m                         ^\e[0m\n\e[31m  \
    \ |\e[0m                         Not found: type i\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpblz_rh4g.scala:35:32 ------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m                        grid[\e[35mi\e[0m][\e[35mj\e\
    [0m] = \e[31m1l\e[0m\n\e[31m\e[31m   |\e[0m                                ^\e\
    [0m\n\e[31m   |\e[0m                                Not found: type j\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpblz_rh4g.scala:35:29 ------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m                        grid[\e[35mi\e[0m][\e[35mj\e\
    [0m] = \e[31m1l"
  stdout: ''
  timestamp: 1659979355
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val numRows = grid.length\n        val numColumns = grid(0).length\n\
    \        var maxCap = capacity\n        val rem = numRows * numColumns - capacity\n\
    \        val rem = rem / numRows\n        val ret = rem.toLong\n\n        val\
    \ res = mutable.ArrayBuffer.empty[Long]\n        // find the max number of rows\
    \ you can empty using max capacity with row index\n        val maxRows = (rem:\
    \ Long) match {\n            case \"1\" => numRows - 1\n            case x =>\
    \ x\n        }\n        \n        val minRows = (maxRows * numColumns) / (numRows\
    \ - 1)\n        val minRows = minRows.toLong\n\n        ret += minRows\n     \
    \   ret += maxRows\n        \n        val res1 = (maxRows / numColumns).toLong\n\
    \        if (res1 > 0) {\n            ret += res1\n        }\n        res ++=\
    \ res1\n        res\n    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp5q6p6z4t.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mrem\e[0m = rem / numRows\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mrem\
    \ is already defined as \e[33mvalue\e[0m \e[35mrem\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp5q6p6z4t.scala:41:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m41 |\e[0m        \e[33mval\e[0m\
    \ \e[36mminRows\e[0m = minRows.toLong\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mminRows is already defined as \e[33mvalue\e[0m \e[35mminRows\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E006] Not\
    \ Found Error: /tmp/tmp5q6p6z4t.scala:33:18 ------------------------\e[0m\e[0m\n\
    \e[31m33 |\e[0m        \e[33mval\e[0m \e[36mres\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                  ^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                  Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ Error: /tmp/tmp5q6p6z4t.scala:36:17 -----------------------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m            \e[33mcase\e[0m \e[31m\"1\"\e[0m => numRows\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m                 ^^^\e[0m\n\e[31m   |\e\
    [0m        Values of types String and Long cannot be compared with == or !=\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmp5q6p6z4t.scala:40:31 ------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m        \e[33mval\e[0m \e[36mminRows\e[0m = (maxRows\
    \ * numColumns) / (numRows - \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m            \
    \           ^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue * is not a member of AnyVal,\
    \ but could be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mOne of the following imports might make progress towards fixing the\
    \ problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |"
  stdout: ''
  timestamp: 1659979361
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        var count = Long.MaxValue\n        grid.foreach{ row =>\n\
    \            if(row.length == 1) count = count + 1\n        }\n        if(count\
    \ == 0) return 0\n        var maxCount = 0\n        var newGrid = grid.map{ row\
    \ => row.map{ value =>\n            if((value & 1) == 1) return 0\n          \
    \  else return capacity\n        } }\n        while(newGrid.forall{ row =>\n \
    \           row.foreach{ value =>\n                if((value & 1) == 0) newGrid.foreach{\
    \ row =>\n                    row.foreach{ value =>\n                        if((value\
    \ & 1) == 0) newGrid -= 1\n                        else newGrid += capacity\n\
    \                    }\n                }\n            }\n        })\n       \
    \ newGrid.foreach{ row =>\n            count = count - row.length\n          \
    \  count = count - row.last\n            if((count & 1) == 1) return count - 1\n\
    \            if((count & 1) == 0) return count + 1\n        }\n        return\
    \ 0\n    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpb3qlpvee.scala:38:26 ------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m                \e[33mif\e[0m((value & \e[31m1\e[0m)\
    \ == \e[31m0\e[0m) newGrid.foreach{ \e[36mrow\e[0m =>\n\e[31m\e[31m   |\e[0m \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0mvalue & is not a member of Nothing,\
    \ but could be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mOne of the following imports might fix the problem:\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m  import Byte.byte2int\n\e[31m   |\e[0m  import Byte.byte2long\n\
    \e[31m   |\e[0m  import Byte.byte2short\n\e[31m   |\e[0m  import Char.char2int\n\
    \e[31m   |\e[0m  import Char.char2long\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.set\
    \ asScala\n\e[31m   |\e[0m  import collection.convert.ImplicitConversionsToScala.set\
    \ asScala\n\e[31m   |\e[0m  import math.BigInt.javaBigInteger2bigInt\n\e[31m \
    \  |\e[0m  import Short.short2int\n\e[31m   |\e[0m  import Short.short2long\n\e\
    [31m   |\e[0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpb3qlpvee.scala:40:34\
    \ ------------------------\e[0m\e[0m\n\e[31m40 |\e[0m                        \e\
    [33mif\e[0m((value & \e[31m1\e[0m) == \e[31m0\e[0m) newGrid -= \e[31m1\e[0m\n\e\
    [31m\e[31m   |\e[0m                            ^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ & is not a member of Nothing, but could be made available as an extension method.\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might fix the problem:\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m  import Byte.byte2int\n\e[31m   |\e[0m  import\
    \ Byte.byte2long\n\e[31m   |\e[0m  import Byte.byte2short\n\e[31m   |\e[0m  import\
    \ Char.char2int\n\e[31m   |\e[0m  import Char.char2long\n\e[31m   |\e[0m  import\
    \ collection.convert.ImplicitConversions.set asScala\n\e[31m   |\e[0m  import\
    \ collection.convert.ImplicitConversionsToScala.set asScala\n\e[31m   |\e[0m \
    \ import math.BigInt.javaBigInteger2bigInt\n\e[31m   |\e[0m  import Short.short2int\n\
    \e[31m   |\e[0m  import Short.short2long\n\e[31m   |\e[0m\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpb3qlpvee.scala:40:53 ------------------------\e[0m\e\
    [0m\n\e[31m40 |\e[0m                        \e[33mif\e[0m((value & \e[31m1\e[0m) "
  stdout: ''
  timestamp: 1659979362
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        // write your code here\n        var max = 0\n        var\
    \ n = 0\n        val m = grid.length\n        val n = grid(0).length\n       \
    \ for(i <- 0 until m){\n            for(j <- 0 until n){\n                if(grid(i)(j)\
    \ ==0){\n                    grid(i)(j) = 1\n                    grid(i)(j) =\
    \ capacity\n                    val x = i - 1\n                    val y = j -\
    \ 1\n                    val capacity = capacity\n                    val minCapacity\
    \ = 0\n                    val maxCapacity = capacity * 10\n                 \
    \   while(x >=0){\n                        while(y >=0){\n                   \
    \         if(grid(x).length == minCapacity){\n                               \
    \ grids(x).remove(y)\n                                grids(x).remove(y)\n   \
    \                             break\n                            }\n         \
    \                   y -= 1\n                        }\n                      \
    \  x -= 1\n                        minCapacity = minCapacity * 10\n          \
    \          }\n                    while(y >=0){\n                        while(x\
    \ >=0){\n                            if(grid(x).length == maxCapacity){\n    \
    \                            grids(x).remove(y)\n                            \
    \    grids(x).remove(y)\n                                break\n             \
    \               }\n                            x -= 1\n                      \
    \  }\n                        y -= 1\n                        maxCapacity = maxCapacity\
    \ * 10\n                    }\n                    grids(x).add(x)\n         \
    \           grids(x).add(y)\n                    while(x >=0){\n             \
    \           while(y >=0){\n                            if(grid(x).length == minCapacity){\n\
    \                                grids(x).remove(y)\n                        \
    \        grids(x).remove(y)\n                                break\n         \
    \                   }\n                            y -= 1\n                  \
    \      }\n                        x -= 1\n                        minCapacity\
    \ = minCapacity * 10\n                    }\n                    while(y >=0){\n\
    \                        while(x >=0){\n                            if(grid(x).length\
    \ == maxCapacity){\n                                grids(x).remove(y)\n     \
    \                           grids(x).remove(y)\n                             \
    \   break\n                            }\n                            x -= 1\n\
    \                        }\n                        y -= 1\n                 \
    \       maxCapacity = maxCapacity * 10\n                    }\n              \
    \      grids(x).add(x)\n                    grids(x).add(y)\n                }\n\
    \            }\n        }\n        for(i <- 0 until m){\n            for(j <-\
    \ 0 until n){\n                if(grid(i)(j) ==1){\n                    val x\
    \ = i - 1\n                    val y = j - 1\n                    val capacity\
    \ = capacity\n                    val minCapacity = 0\n                    val\
    \ maxCapacity = capacity * 10\n                    while(x >=0){\n           \
    \             while(y >=0){\n                            if(grid(x).length ==\
    \ minCapacity){\n                                grids(x).remove(y)\n        \
    \                        grids(x).remove(y)\n                                break\n\
    \                            }\n                            y -= 1\n         \
    \               }\n                        x -= 1\n                        min\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp1gekathv.scala:125:0 ---------------------------\e\
    [0m\e[0m\n\e[31m125 |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m'}'\
    \ expected, but eof found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp1gekathv.scala:30:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m\
    \ \e[36mn\e[0m = grid(\e[31m0\e[0m).length\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mn is already defined as \e[33mvariable\e[0m \e[35mn\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmp1gekathv.scala:34:20 ------------------------\e[0m\e[0m\n\e[31m34 |\e\
    [0m                    grid(i)(j) = \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m      \
    \              ^^^^^^^\e[0m\n\e[31m   |\e[0mvalue update is not a member of List[Long]\
    \ - did you mean List[Long].updated?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp1gekathv.scala:35:20\
    \ ------------------------\e[0m\e[0m\n\e[31m35 |\e[0m                    grid(i)(j)\
    \ = capacity\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0mvalue update is not a member of List[Long] - did you mean List[Long].updated?\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp1gekathv.scala:44:32 ------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m                                grids(x).remove(y)\n\e\
    [31m\e[31m   |\e[0m                                ^^^^^\e[0m\n\e[31m   |\e[0m\
    \                                Not found: grids\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp1gekathv.scala:45:32 ------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m                                grids(x).remove(y)\n\e\
    [31m\e[31m   |\e[0m                                ^^^^^\e[0m\n\e[31m   |\e[0m\
    \                                Not found: grids\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp1gekathv.scala:46:32 ------------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m          "
  stdout: ''
  timestamp: 1659979363
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        // write your code here\n        var count = 0\n       \
    \ val rowLength = grid.map(_.size).max\n        val rowCapacity = grid.map(_.map(_.toInt)).max\n\
    \        if (rowLength != rowCapacity) {\n            count = 0\n        }\n \
    \       else {\n            count = rowLength - rowCapacity\n        }\n     \
    \   val maxWidth = grid.map(_.size).max\n        val maxHeight = grid.map(_.size).max\n\
    \        if (maxWidth == 0 || maxHeight == 0) {\n            return count\n  \
    \      }\n        else {\n            val maxCapacity = grid.map(_.map(_.toInt)).max\n\
    \            if (maxCapacity != capacity) {\n                return count\n  \
    \          }\n            else {\n                val minWidth = grid.map(_.size).min\n\
    \                val minHeight = grid.map(_.size).min\n                val minCapacity\
    \ = grid.map(_.map(_.toInt)).min\n                val maxCapacity = grid.map(_.map(_.toInt)).max\n\
    \                count += minWidth * (minHeight - minCapacity)\n             \
    \   count += minWidth * (maxCapacity - capacity)\n                count += maxWidth\
    \ * (minCapacity - capacity)\n                count += maxWidth * (maxCapacity\
    \ - capacity)\n                count += minHeight * (maxCapacity - capacity)\n\
    \                return count\n            }\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpa1a8s2k4.scala:30:12 -----------------------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mif\e[0m (rowLength != rowCapacity) {\n\e\
    [31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \      Values of types Int and List[Int] cannot be compared with == or !=\n\e\
    [31m\e[31m-- [E134] Type Error: /tmp/tmpa1a8s2k4.scala:34:30 -----------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m            count = rowLength - rowCapacity\n\e[31m\e\
    [31m   |\e[0m                    ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m None of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35m-\e[0m in \e[33mclass\e[0m\
    \ \e[35mInt\e[0m with types\n\e[31m   |\e[0m  (x: Double): Double\n\e[31m   |\e\
    [0m  (x: Float): Float\n\e[31m   |\e[0m  (x: Long): Long\n\e[31m   |\e[0m  (x:\
    \ Int): Int\n\e[31m   |\e[0m  (x: Char): Int\n\e[31m   |\e[0m  (x: Short): Int\n\
    \e[31m   |\e[0m  (x: Byte): Int\n\e[31m   |\e[0m match arguments ((rowCapacity\
    \ : List[Int]))\n\e[31m\e[31m-- Error: /tmp/tmpa1a8s2k4.scala:43:16 -----------------------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m            \e[33mif\e[0m (maxCapacity != capacity) {\n\
    \e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m     Values of types List[Int] and Long cannot be compared with == or !=\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpa1a8s2k4.scala:51:22 ------------------------\e\
    [0m\e[0m\n\e[31m51 |\e[0m                count += minWidth * (minHeight - minCapacity)\n\
    \e[31m\e[31m   |\e[0m                ^^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \      value += is not a member of Int - did you mean Int.!=?\n\e[31m\e[31m--\
    \ [E134] Type Error: /tmp/tmpa1a8s2k4.scala:51:47 -----------------------------\e\
    [0m\e[0m\n\e[31m51 |\e[0m                count += minWidth * (minHeight - minCapacity)\n\
    \e[31m\e[31m   |\e[0m                                     ^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m None of the overloaded alternatives of \e[33mmethod\e[0m \e[35m-\e\
    [0m in \e[33mclass\e[0m \e[35mInt\e[0m with types\n\e[31m   |\e[0m  (x: Double):\
    \ Double\n\e[31m   |\e[0m  (x: Float): Float\n\e[31m   |\e[0m  (x: Long): Long\n\
    \e[31m   |\e[0m  (x: Int): Int\n\e[31m   |\e[0m  (x: Ch"
  stdout: ''
  timestamp: 1659979365
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val maxCount = 1\n        val gridSize = grid.size\n   \
    \     val map = new mutable.HashMap[Long, List[Long]]()\n        for (row <- 0\
    \ until gridSize) {\n            val currentCount = map.get(grid(row)(0)).length\n\
    \            map.put(grid(row)(0), grid(row)(0))::grid(row)(1)::List(grid(row)(2))\n\
    \            if (currentCount > maxCount) {\n                maxCount = currentCount\n\
    \            }\n        }\n        if (maxCount > capacity) {\n            maxCount\n\
    \        } else {\n            (maxCount - capacity) * map(capacity)(0)\n    \
    \    }\n    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpdyi1yr8o.scala:28:22 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mmap\e[0m = \e[33mnew\e[0m\
    \ mutable.HashMap[\e[35mLong\e[0m, \e[35mList\e[0m[\e[35mLong\e[0m]]()\n\e[31m\e\
    [31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m   |\e[0m             \
    \         Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E052] Type Error:\
    \ /tmp/tmpdyi1yr8o.scala:33:25 -----------------------------\e[0m\e[0m\n\e[31m33\
    \ |\e[0m                maxCount = currentCount\n\e[31m\e[31m   |\e[0m       \
    \         ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                Reassignment\
    \ to val maxCount\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659979356
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = (1 to grid.length).map { i =>\n          \
    \  mutable.HashMap[Long, Long](1 -> 0)\n        }\n        grid.map { row =>\n\
    \            if (row.length == 1) buckets(row(0)) -= 1\n            else buckets(row(0))\
    \ -= 1\n            buckets(row(0)) += 1\n        }\n        buckets.maxBy(_._1)._1\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmplzm0y3ry.scala:27:12 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m            mutable.HashMap[\e[35mLong\e[0m, \e[35mLong\e\
    [0m](\e[31m1\e[0m -> \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m            ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m            Not found: mutable\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmplzm0y3ry.scala:30:44 --------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m            \e[33mif\e[0m (row.length == \e[31m1\e[0m)\
    \ buckets(row(\e[31m0\e[0m)) -= \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m          \
    \                               ^^^^^^\e[0m\n\e[31m   |\e[0m                 \
    \                        Found:    Long\n\e[31m   |\e[0m                     \
    \                    Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmplzm0y3ry.scala:31:28 --------------------\e[0m\e[0m\n\e[31m31\
    \ |\e[0m            \e[33melse\e[0m buckets(row(\e[31m0\e[0m)) -= \e[31m1\e[0m\n\
    \e[31m\e[31m   |\e[0m                         ^^^^^^\e[0m\n\e[31m   |\e[0m   \
    \                      Found:    Long\n\e[31m   |\e[0m                       \
    \  Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmplzm0y3ry.scala:32:23\
    \ --------------------\e[0m\e[0m\n\e[31m32 |\e[0m            buckets(row(\e[31m0\e\
    [0m)) += \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m                    ^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Found:    Long\n\e[31m   |\e[0m             \
    \       Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmplzm0y3ry.scala:34:24\
    \ ------------------------\e[0m\e[0m\n\e[31m34 |\e[0m        buckets.maxBy(_._1)._1\n\
    \e[31m\e[31m   |\e[0m                      ^^^^\e[0m\n\e[31m   |\e[0mvalue _1\
    \ is not a member of Nothing, but could be made available as an extension method.\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mThe following import might fix the proble"
  stdout: ''
  timestamp: 1659979363
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        // Your code here\n        var nwell = 0\n        var nbucket\
    \ = 0\n        var nlow = 0\n        var nold = 0\n        var nfill = 0\n   \
    \     for (row <- grid) {\n            nwell = row.length\n            for (col\
    \ <- row) {\n                if (col == 1 || col == 0) {\n                   \
    \ nlow = nwell\n                    nold = nwell\n                } else {\n \
    \                   nlow = nold\n                    nold = nwell\n          \
    \      }\n                if (capacity-nold < nlow) {\n                    nlow\
    \ = nlow - 1\n                    nbucket = nbucket - 1\n                    nfill\
    \ = nfill + 1\n                }\n            }\n        }\n        if (nbucket\
    \ < nfill)\n            return nfill\n        else\n            return nbucket\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp2uh_odqu.scala:55)\n\tat Problem.main(tmp2uh_odqu.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979363
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val rows = grid.length\n        val cols = grid(0).length\n\
    \        val buckets = Array.ofDim[Long](cols)\n        (0 until cols).foreach(i\
    \ => {\n            buckets(i) = 0\n        })\n        val helper = mutable.ArrayBuffer.empty[(List[List[Long]],\
    \ List[Long])]\n        val stack = mutable.Stack.empty[(List[List[Long]], List[Long])]\n\
    \        helper.append((grid, 0l))\n        helper.append((stack.toList, 0l))\n\
    \        while(!helper.isEmpty) {\n            val pair = helper.pop()\n     \
    \       val buckets = pair._1.toList\n            val value = pair._2\n      \
    \      val newBuckets = mutable.ArrayBuffer.empty[Long]\n            val newValue\
    \ = value\n            buckets.zipWithIndex.foreach(i => {\n                if(i._1\
    \ == 1) {\n                    newBuckets += (i._2 + 1)\n                } else\
    \ {\n                    newBuckets += i._2\n                }\n            })\n\
    \            buckets.foreach(i => {\n                if((i + 1) > newBuckets.length)\
    \ {\n                    newBuckets += (i - (newBuckets.length))\n           \
    \     }\n            })\n            newBuckets.foreach(i => {\n             \
    \   if((i - 1) < 0) {\n                    newBuckets += i\n                }\n\
    \            })\n            newValue -= newBuckets.length\n            buckets.foreach(i\
    \ => {\n                if((i + 1) > newBuckets.length) {\n                  \
    \  newBuckets += (i - (newBuckets.length))\n                }\n            })\n\
    \            newBuckets.foreach(i => {\n                if((i - 1) < 0) {\n  \
    \                  newBuckets += i\n                }\n            })\n      \
    \      stack.push((pair._1, newValue))\n            val newGrid = mutable.ArrayBuffer.empty[List[Long]]\n\
    \            (0 until rows).foreach(j => {\n                newGrid += mutable.ArrayBuffer.empty[Long]\n\
    \                (0 until cols).foreach(k => {\n                    newGrid(k)\
    \ += if (buckets(k) == 0) 0 else buckets(k)\n                })\n            })\n\
    \            helper.append((newGrid, newValue))\n        }\n        stack.toList.map(p\
    \ => p._2).max\n    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpg74kztwc.scala:75:34 ---------------------------\e\
    [0m\e[0m\n\e[31m75 |\e[0m                    newGrid(k) += \e[33mif\e[0m (buckets(k)\
    \ == \e[31m0\e[0m) \e[31m0\e[0m \e[33melse\e[0m buckets(k)\n\e[31m\e[31m   |\e\
    [0m                                  ^^\e[0m\n\e[31m   |\e[0m                \
    \                  expression expected but \e[31mif\e[0m found\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpg74kztwc.scala:32:21 ------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mhelper\e[0m = mutable.ArrayBuffer.empty[(\e\
    [35mList\e[0m[\e[35mList\e[0m[\e[35mLong\e[0m]], \e[35mList\e[0m[\e[35mLong\e\
    [0m])]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpg74kztwc.scala:33:20 ------------------------\e[0m\e\
    [0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack.empty[(\e\
    [35mList\e[0m[\e[35mList\e[0m[\e[35mLong\e[0m]], \e[35mList\e[0m[\e[35mLong\e\
    [0m])]\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpg74kztwc.scala:40:29 ------------------------\e[0m\e\
    [0m\n\e[31m40 |\e[0m            \e[33mval\e[0m \e[36mnewBuckets\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                             ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                             Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpg74kztwc.scala:71:26 ------------------------\e\
    [0m\e[0m\n\e[31m71 |\e[0m            \e[33mval\e[0m \e[36mnewGrid\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mList\e[0m[\e[35mLong\e[0m]]\n\e[31m\e[31m   |\e[0m                       \
    \   ^^^^^^^\e[0m\n\e[31m   |\e[0m                   "
  stdout: ''
  timestamp: 1659979359
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        var count = 0\n        var max = 0\n        for (row <-\
    \ grid) {\n            for (bucket <- row) {\n                if ((bucket > max)\
    \ || (count == 0)) {\n                    max = bucket\n                    count\
    \ = 0\n                }\n                if (bucket == max) {\n             \
    \       count += 1\n                }\n            }\n        }\n        return\
    \ max\n    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpkosc4aex.scala:31:26\
    \ --------------------\e[0m\e[0m\n\e[31m31 |\e[0m                    max = bucket\n\
    \e[31m\e[31m   |\e[0m                          ^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                        Found:    (bucket : Long)\n\e[31m   |\e[0m          \
    \                Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979366
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        def minBucket(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n            def countInRow(grid : List[List[Long]], row: List[Long],\
    \ capacity : Long) : Int = {\n                var count = 0\n                for\
    \ (i <- 0 to grid.length - 1) {\n                    if (grid[i] == row) {\n \
    \                       count += 1\n                    }\n                }\n\
    \                if (count == capacity) {\n                    count -= 1\n  \
    \              }\n                count\n            }\n            var minCount\
    \ = sys.maxInt\n            var minRow = List[Long]()\n            for (i <- 0\
    \ to grid.length - 1) {\n                if (minCount > countInRow(grid, grid[i],\
    \ capacity)) {\n                    minRow = grid\n                    minCount\
    \ = countInRow(grid, grid[i], capacity)\n                }\n            }\n  \
    \          minCount\n        }\n\n        def countInRow(grid : List[List[Long]],\
    \ row: List[Long], capacity : Long) : Int = {\n            var count = 0\n   \
    \         for (i <- 0 to grid.length - 1) {\n                if (grid[i] == row)\
    \ {\n                    count += 1\n                }\n            }\n      \
    \      if (count == capacity) {\n                count -= 1\n            }\n \
    \           count\n        }\n        val n = grid.length\n        val m = grid[0].length\n\
    \        var maxCount = sys.maxInt\n        var maxRow = List[Long]()\n      \
    \  var curCount = sys.maxInt\n        for (i<- 0 to n - 1) {\n            if (maxCount\
    \ < countInRow(grid, grid[i], capacity)) {\n                maxRow = grid\n  \
    \              maxCount = countInRow(grid, grid[i], capacity)\n            }\n\
    \        }\n        for (i<- 0 to m - 1) {\n            if (maxCount < countInRow(grid,\
    \ List(grid[0](i)), capacity)) {\n                maxRow = grid\n            \
    \    maxCount = countInRow(grid, List(grid[0](i)), capacity)\n            }\n\
    \        }\n        (maxCount, maxRow)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 1l.toLong,\
    \ 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong, 0l.toLong), List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (1l)) == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp0342tr2z.scala:30:29 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m                    \e[33mif\e[0m (grid[\e[35mi\e[0m]\
    \ == row) {\n\e[31m\e[31m   |\e[0m                             ^\e[0m\n\e[31m\
    \   |\e[0m                             Not found: type i\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmp0342tr2z.scala:39:31 ------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m            \e[33mvar\e[0m \e[36mminCount\e[0m = sys.maxInt\n\
    \e[31m\e[31m   |\e[0m                           ^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                           value maxInt is not a member of sys\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmp0342tr2z.scala:43:29 --------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m                    minRow = grid\n\e[31m\e[31m   |\e\
    [0m                             ^^^^\e[0m\n\e[31m   |\e[0m                   \
    \          Found:    \e[1m\e[31m(\e[0m\e[1m\e[31mgrid\e[0m\e[1m\e[31m \e[0m\e\
    [1m\e[31m:\e[0m\e[1m\e[31m \e[0mList[\e[1m\e[31mList\e[0m\e[1m\e[31m[\e[0mLong\e\
    [1m\e[31m]\e[0m]\e[1m\e[31m)\e[0m\n\e[31m   |\e[0m                           \
    \  Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp0342tr2z.scala:44:53\
    \ ------------------------\e[0m\e[0m\n\e[31m44 |\e[0m                    minCount\
    \ = countInRow(grid, grid[\e[35mi\e[0m], capacity)\n\e[31m\e[31m   |\e[0m    \
    \                                                 ^\e[0m\n\e[31m   |\e[0m    \
    \                                                 Not found: type i\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp0342tr2z.scala:53:25 ------------------------\e\
    [0m\e[0m\n\e[31m53 |\e[0m                \e[33mif\e[0m (grid[\e[35mi\e[0m] ==\
    \ row) {\n\e[31m\e[31m   |\e[0m                         ^\e[0m\n\e[31m   |\e[0m\
    \                         Not found: type i\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ Error: /tmp/"
  stdout: ''
  timestamp: 1659979369
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        // write your code here\n        val rowCount = grid.length\n\
    \        val colCount = grid.head._2.length\n        val bucketCount = rowCount\
    \ * colCount\n        val buckets = mutable.Buffer.empty[List[Long]](bucketCount)\n\
    \n        for (i <- 0 until rowCount) {\n            val row = grid(i)\n     \
    \       for (j <- 0 until colCount) {\n                val well = row.toLong\n\
    \                val bucket = well.toLong\n                if (bucket < capacity)\
    \ {\n                    buckets += List(bucket)\n                }\n        \
    \    }\n        }\n\n        var sum = 0\n        for (bucket <- buckets) {\n\
    \            val well = bucket.toLong\n            if (well > capacity) {\n  \
    \              sum += 1\n            }\n        }\n\n        return sum\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpwe2cbcsj.scala:28:33 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mcolCount\e[0m = grid.head._2.length\n\
    \e[31m\e[31m   |\e[0m                       ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                       value _2 is not a member of List[Long]\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpwe2cbcsj.scala:30:22 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mbuckets\e[0m = mutable.Buffer.empty[\e\
    [35mList\e[0m[\e[35mLong\e[0m]](bucketCount)\n\e[31m\e[31m   |\e[0m          \
    \            ^^^^^^^\e[0m\n\e[31m   |\e[0m                      Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpwe2cbcsj.scala:35:31\
    \ ------------------------\e[0m\e[0m\n\e[31m35 |\e[0m                \e[33mval\e\
    [0m \e[36mwell\e[0m = row.toLong\n\e[31m\e[31m   |\e[0m                      \
    \     ^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue toLong is not a member of List[Long],\
    \ but could be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mOne of the following imports might make progress towards fixing the\
    \ problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659979369
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val rowMax = grid.map(_.length).max\n        val colMax\
    \ = grid.map(_.head.length).max\n        if (rowMax == 0 || colMax == 0)\n   \
    \         return 0\n        val rowMin = grid.map(_.length).min\n        val colMin\
    \ = grid.map(_.head.length).min\n        var count = 0\n        for (row <- 1\
    \ to rowMax) {\n            for (col <- 1 to colMax) {\n                val cells\
    \ = grid.filter{ case (l,r) =>\n                    val maxRow = row max r\n \
    \                   val minRow = row min r\n                    val maxCol = col\
    \ max l\n                    val minCol = col min l\n                    r > l\
    \ && l > 0 && r < colMax && l < colMin && r >= minRow && l >= minCol\n       \
    \         }\n                val bucketSize = (cells.length - 1).toLong\n    \
    \            if (bucketSize < capacity)\n                    count += 1\n    \
    \            else\n                    count += capacity - bucketSize\n      \
    \      }\n        }\n        count\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 1l.toLong,\
    \ 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong, 0l.toLong), List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (1l)) == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpg6vf48_3.scala:27:37 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mcolMax\e[0m = grid.map(_.head.length).max\n\
    \e[31m\e[31m   |\e[0m                              ^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                              value length is not a member of Long\n\
    \e[31m\e[31m-- Error: /tmp/tmpg6vf48_3.scala:27:48 -----------------------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mcolMax\e[0m = grid.map(_.head.length).max\n\
    \e[31m\e[31m   |\e[0m                                                ^\e[0m\n\e\
    [31m   |\e[0mambiguous given instances: both \e[33mobject\e[0m \e[35mBigDecimal\e\
    [0m in \e[33mobject\e[0m \e[35mOrdering\e[0m and \e[33mobject\e[0m \e[35mInt\e\
    [0m in \e[33mobject\e[0m \e[35mOrdering\e[0m match type Ordering[B] of parameter\
    \ ord of \e[33mmethod\e[0m \e[35mmax\e[0m in \e[33mtrait\e[0m \e[35mIterableOnceOps\e\
    [0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpg6vf48_3.scala:31:37 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mcolMin\e[0m = grid.map(_.head.length).min\n\
    \e[31m\e[31m   |\e[0m                              ^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                              value length is not a member of Long\n\
    \e[31m\e[31m-- Error: /tmp/tmpg6vf48_3.scala:31:48 -----------------------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mcolMin\e[0m = grid.map(_.head.length).min\n\
    \e[31m\e[31m   |\e[0m                                                ^\e[0m\n\e\
    [31m   |\e[0mambiguous given instances: both \e[33mobject\e[0m \e[35mBigDecimal\e\
    [0m in \e[33mobject\e[0m \e[35mOrdering\e[0m and \e[33mobject\e[0m \e[35mInt\e\
    [0m in \e[33mobject\e[0m \e[35mOrdering\e[0m match type Ordering[B] of parameter\
    \ ord of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mtrait\e[0m \e[35mIterableOnceOps\e\
    [0m\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpg6vf48_3.scala:36:41 --------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m                    \e[33mval\e[0m \e[36mmaxRow\e[0m\
    \ = row max r\n\e[31m\e[31m   |\e[0m                                         ^\e\
    [0m\n\e[31m   |\e[0m                                       "
  stdout: ''
  timestamp: 1659979372
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val result = new mutable.ListBuffer[Int]\n        var total\
    \ = 0\n        \n        for (h <- 0 until grid.length) {\n            total +=\
    \ grid(h).sum\n        }\n        \n        val maxCap = total / capacity\n  \
    \      val minCap = total / grid.length\n        val maxBucket = (maxCap - minCap)\
    \ * capacity + minCap\n        val bucketCount = 1\n        \n        while (bucketCount\
    \ < maxBucket) {\n            for (h <- 0 until grid.length) {\n             \
    \   val cur = grid[h].sum\n                if (cur <= minCap) {\n            \
    \        val l = grid[h]\n                    l.clear()\n                    val\
    \ r = grid[h]\n                    r.clear()\n                    val newBucket\
    \ = (maxCap - minCap) * capacity + minCap\n                    \n            \
    \        if (newBucket > bucketCount) {\n                        result += bucketCount\n\
    \                        bucketCount += newBucket\n                    }\n   \
    \             }\n            }\n            \n            maxBucket = (maxCap\
    \ - minCap) * capacity + minCap\n            bucketCount += 1\n        }\n   \
    \     \n        result match {\n            case x if x > 0 => x.toLong\n    \
    \        case x if x == 0 => -1\n            case x if x < 0 => 0\n        }\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp3vjyl9jw.scala:26:25 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m mutable.ListBuffer[\e[35mInt\e[0m]\n\e[31m\e[31m   |\e[0m                \
    \         ^^^^^^^\e[0m\n\e[31m   |\e[0m                         Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp3vjyl9jw.scala:30:18\
    \ ------------------------\e[0m\e[0m\n\e[31m30 |\e[0m            total += grid(h).sum\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^\e[0m\n\e[31m   |\e[0m            value\
    \ += is not a member of Int - did you mean Int.!=?\n\e[31m\e[31m-- [E006] Not\
    \ Found Error: /tmp/tmp3vjyl9jw.scala:40:31 ------------------------\e[0m\e[0m\n\
    \e[31m40 |\e[0m                \e[33mval\e[0m \e[36mcur\e[0m = grid[\e[35mh\e\
    [0m].sum\n\e[31m\e[31m   |\e[0m                               ^\e[0m\n\e[31m \
    \  |\e[0m                               Not found: type h\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmp3vjyl9jw.scala:42:33 ------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m                    \e[33mval\e[0m \e[36ml\e[0m = grid[\e\
    [35mh\e[0m]\n\e[31m\e[31m   |\e[0m                                 ^\e[0m\n\e\
    [31m   |\e[0m                                 Not found: type h\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp3vjyl9jw.scala:44:33 ------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m                    \e[33mval\e[0m \e[36mr\e[0m = grid[\e\
    [35mh\e[0m]\n\e[31m\e[31m   |\e[0m                                 ^\e[0m\n\e\
    [31m   |\e[0m                                 Not found: type h\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp3vjyl9jw.scala:50:36 ------------------------\e\
    [0m\e[0m\n\e[31m50 |\e[0m                        bucketCount += newBucket\n\e\
    [31m\e[31m   |\e[0m                        ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e["
  stdout: ''
  timestamp: 1659979369
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        require(grid.length == 1)\n        require(grid.head.size\
    \ == 2)\n        require(grid.head._1 == 1 && grid.head._2 == 1)\n        require(0\
    \ <= capacity && capacity <= 10)\n        require(grid.head._3 > 0)\n        var\
    \ currentCount : Long = 0\n        var maxCount : Long = 1\n        var emptyCount\
    \ : Long = 0\n        var emptyCells = grid(0)\n        emptyCells ++= grid(0)\n\
    \        emptyCells ++= grid(0)\n        var i = 0\n        var j = 0\n      \
    \  var maxCount : Long = 1\n        var emptyCount : Long = 0\n        while (i\
    \ < grid.length) {\n            while (j < grid[0].length) {\n               \
    \ emptyCells = grid(i)(j)\n                if (emptyCells == 0l) {\n         \
    \           currentCount += 1\n                    emptyCount += 1\n         \
    \           emptyCells ++= grid(i)(j)\n                    maxCount += 1 // For\
    \ this row, not every column needs to be filled\n                }\n         \
    \       if (currentCount >= capacity) {\n                    emptyCount += maxCount\
    \ // This is because we need to leave a row even if some columns fill up\n   \
    \                 maxCount = 1\n                    currentCount = 0\n       \
    \         }\n                j++\n            }\n            maxCount += 1\n \
    \           currentCount = 0\n            i++\n            emptyCount += 1\n \
    \       }\n        if (emptyCount > 0) maxCount += emptyCount // We need to leave\
    \ one row if some columns fill up\n        return maxCount\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmprabyot8a.scala:55:19 ---------------------------\e\
    [0m\e[0m\n\e[31m55 |\e[0m                j++\n\e[31m\e[31m   |\e[0m          \
    \         ^\e[0m\n\e[31m   |\e[0m                   expression expected but \e\
    [31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmprabyot8a.scala:39:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m39 |\e[0m        \e[33mvar\e[0m\
    \ \e[36mmaxCount\e[0m : \e[35mLong\e[0m = \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmaxCount is already defined\
    \ as \e[33mvariable\e[0m \e[35mmaxCount\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmprabyot8a.scala:40:12 ---------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m        \e[33mvar\e[0m \e[36memptyCount\e[0m : \e[35mLong\e\
    [0m = \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0memptyCount is already defined as \e[33mvariable\e[0m \e[35memptyCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmprabyot8a.scala:28:26 ------------------------\e[0m\e[0m\n\
    \e[31m28 |\e[0m        require(grid.head._1 == \e[31m1\e[0m && grid.head._2 ==\
    \ \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                value _1 is not a member of List[Long]\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmprabyot8a.scala:30:26 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        require(grid.head._3 > \e[31m0\e[0m)\n\e[31m\e\
    [31m   |\e[0m                ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m              \
    \  value _3 is not a member of List[Long]\n\e[31m\e[31m-- Error: /tmp/tmprabyot8a.scala:42:27\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m42 |\e[0m       \
    \     \e[33mwhile\e[0m (j < grid[\e[31m0\e[0m].length) {\n\e[31m\e[31m   |\e[0m\
    \                       ^^^^^^^\e[0m\n\e[31m   |\e[0m        \e[33mmethod\e[0"
  stdout: ''
  timestamp: 1659979371
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        if (grid.length == 1) return 0\n        if (grid.length\
    \ == 0) return 0\n        if (grid == List.empty) return 0\n        val m = grid.head\n\
    \        val n = grid.last\n        val maxCount = m.zipWithIndex.foldLeft((0l,\
    \ 0l))((c, (m, i)) => {\n            if (c._2 > 0) c._2 else c._2 = 1\n      \
    \      if (c._1 > capacity) c._1 else c._1 = capacity\n            (c, i)\n  \
    \      })\n        return maxCount._1 + 1\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 1l.toLong,\
    \ 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong, 0l.toLong), List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (1l)) == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp_e5c9sco.scala:31:61 -----------------------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mmaxCount\e[0m = m.zipWithIndex.foldLeft((\e\
    [31m0l\e[0m, \e[31m0l\e[0m))((\e[36mc\e[0m, (m, i)) => {\n\e[31m\e[31m   |\e[0m\
    \                                                             ^^^^^^\e[0m\n\e\
    [31m   |\e[0m                                            not a legal formal parameter\n\
    \e[31m\e[31m-- [E052] Type Error: /tmp/tmp_e5c9sco.scala:32:41 -----------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m            \e[33mif\e[0m (c._2 > \e[31m0\e[0m) c._2\
    \ \e[33melse\e[0m c._2 = \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m                 \
    \                   ^^^^^^^^\e[0m\n\e[31m   |\e[0m                           \
    \         Reassignment to val _2\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E052] Type Error:\
    \ /tmp/tmp_e5c9sco.scala:33:48 -----------------------------\e[0m\e[0m\n\e[31m33\
    \ |\e[0m            \e[33mif\e[0m (c._1 > capacity) c._1 \e[33melse\e[0m c._1\
    \ = capacity\n\e[31m\e[31m   |\e[0m                                          \
    \ ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                                      \
    \     Reassignment to val _1\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp_e5c9sco.scala:34:16 ------------------------\e[0m\e[0m\n\e[31m34 |\e\
    [0m            (c, i)\n\e[31m\e[31m   |\e[0m                ^\e[0m\n\e[31m   |\e\
    [0m                Not found: i\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp_e5c9sco.scala:34:13 --------------------\e[0m\e[0m\n\e[31m34\
    \ |\e[0m            (c, i)\n\e[31m\e[31m   |\e[0m             ^\e[0m\n\e[31m \
    \  |\e[0m             Found:    (c : (Long, Long))\n\e[31m   |\e[0m          \
    \   Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n5 errors found\n"
  stdout: ''
  timestamp: 1659979369
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        grid.headOption.map {\n            case List() => 0\n  \
    \          case _ => 1\n        }.getOrElse(1)\n\n        val m = grid.length\n\
    \        val n = grid(0).length\n        var i : Int = 0\n        var j : Int\
    \ = 0\n        var max = 0\n\n        while (i < m && j < n) {\n            if\
    \ (grid[i][j] < capacity) {\n                val c = grid[i][j]\n            \
    \    grid[i][j] = 0\n                max = 0\n                val count = maxFill(\
    \ grid (i, j + 1) , capacity) - c\n                grid[i][j] = c\n          \
    \      max = math.max(max, count)\n                i = i + 1\n            }\n\
    \            else if (grid[i][j] == 0) {\n                i = i + 1\n        \
    \    }\n            else {\n                j = j + 1\n            }\n       \
    \ }\n        max\n    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmphb01_w1j.scala:40:27 -----------------------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m                grid[\e[35mi\e[0m][\e[35mj\e[0m] = \e\
    [31m0\e[0m\n\e[31m\e[31m   |\e[0m                           ^\e[0m\n\e[31m   |\e\
    [0m                           end of statement expected but '=' found\n\e[31m\e\
    [31m-- Error: /tmp/tmphb01_w1j.scala:43:27 -----------------------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m                grid[\e[35mi\e[0m][\e[35mj\e[0m] = c\n\
    \e[31m\e[31m   |\e[0m                           ^\e[0m\n\e[31m   |\e[0m      \
    \                     end of statement expected but '=' found\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmphb01_w1j.scala:38:24 ------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m            \e[33mif\e[0m (grid[\e[35mi\e[0m][\e[35mj\e\
    [0m] < capacity) {\n\e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m\
    \   |\e[0m                        Not found: type j\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmphb01_w1j.scala:38:21 ------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m            \e[33mif\e[0m (grid[\e[35mi\e[0m][\e[35mj\e\
    [0m] < capacity) {\n\e[31m\e[31m   |\e[0m                     ^\e[0m\n\e[31m \
    \  |\e[0m                     Not found: type i\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmphb01_w1j.scala:39:32 ------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m                \e[33mval\e[0m \e[36mc\e[0m = grid[\e\
    [35mi\e[0m][\e[35mj\e[0m]\n\e[31m\e[31m   |\e[0m                             \
    \   ^\e[0m\n\e[31m   |\e[0m                                Not found: type j\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmphb01_w1j.scala:39:29\
    \ ------------------------\e[0m\e[0m\n\e[31m39 |\e[0m                \e[33mval\e\
    [0m \e[36mc\e[0m = grid[\e[35mi\e[0m][\e[35mj\e[0m]\n\e[31m\e[31m   |\e[0m   \
    \                          ^\e[0m\n\e[31m   |\e[0m                           \
    \  Not found: type i\n\e[31m   |\e[0m\n\e[31m   |\e[0m longe"
  stdout: ''
  timestamp: 1659979370
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        var count = 1\n        var min = 0\n        var max = grid.length\
    \ - 1\n        while(max >= min) {\n            while(min <= max && grid(max)(1)\
    \ == 0) {\n                max = max - 1\n            }\n            while(min\
    \ <= max && grid(min)(1) == 0) {\n                min = min + 1\n            }\n\
    \            if(grid(max)(0) > 0) {\n                count = count + capacity(grid(max)(0))\
    \ * Math.max(0, grid(max)(1) - grid(min)(1))\n                min = min + 1\n\
    \            }\n            else {\n                count = count + capacity(grid(max)(0))\
    \ * Math.max(0, grid(min)(1) - grid(max)(1))\n                max = max - 1\n\
    \            }\n        }\n        count\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 1l.toLong,\
    \ 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong, 0l.toLong), List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (1l)) == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E050] Type Error: /tmp/tmp7k_y0z70.scala:37:32 -----------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m                count = count + capacity(grid(max)(\e\
    [31m0\e[0m)) * Math.max(\e[31m0\e[0m, grid(max)(\e[31m1\e[0m) - grid(min)(\e[31m1\e\
    [0m))\n\e[31m\e[31m   |\e[0m                                ^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                             \e[33mparameter\e[0m \e[35mcapacity\e\
    [0m does not take parameters\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E050] Type Error:\
    \ /tmp/tmp7k_y0z70.scala:41:32 -----------------------------\e[0m\e[0m\n\e[31m41\
    \ |\e[0m                count = count + capacity(grid(max)(\e[31m0\e[0m)) * Math.max(\e\
    [31m0\e[0m, grid(min)(\e[31m1\e[0m) - grid(max)(\e[31m1\e[0m))\n\e[31m\e[31m \
    \  |\e[0m                                ^^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \                       \e[33mparameter\e[0m \e[35mcapacity\e[0m does not take\
    \ parameters\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659979367
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = grid.getOrElse(List[Long](0l.toLong), List[Long](0l.toLong))\n\
    \        val bucketMap = mutable.Map[Long, Long]()\n        var bucketNbr = 0\n\
    \        for (b <- buckets) {\n            if (bucketMap.get(b) == null) {\n \
    \               bucketMap(b) = bucketNbr\n                bucketNbr += 1\n   \
    \         }\n        }\n\n        var fillNbr = 1\n        var maxNbr = 0\n  \
    \      var grid2 = new Array[List[Long]](grid.length)\n        for (i <- 0 until\
    \ grid.length) {\n            var rowNbr = 0\n            var isFilled = false\n\
    \            var row = grid.get(i)\n            for (j <- 0 until row.length)\
    \ {\n                if (rowNbr == bucketMap.get(row.get(j))) {\n            \
    \        if (j + 1 <  row.length) {\n                        rowNbr += 1\n   \
    \                     if (rowNbr == capacity) {\n                            isFilled\
    \ = true\n                        }\n                    }\n                }\n\
    \            }\n            if (isFilled) {\n                grid2(i) = row\n\
    \                fillNbr += 1\n            } else {\n                grid2(i)\
    \ = List(rowNbr)\n                maxNbr += 1\n            }\n        }\n\n  \
    \      maxNbr\n    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp_q0lw3us.scala:26:27 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mbuckets\e[0m = grid.getOrElse(List[\e\
    [35mLong\e[0m](\e[31m0l\e[0m.toLong), List[\e[35mLong\e[0m](\e[31m0l\e[0m.toLong))\n\
    \e[31m\e[31m   |\e[0m                      ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                     value getOrElse is not a member of List[List[Long]]\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmp_q0lw3us.scala:27:24 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mbucketMap\e[0m = mutable.Map[\e\
    [35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                     \
    \   ^^^^^^^\e[0m\n\e[31m   |\e[0m                        Not found: mutable\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp_q0lw3us.scala:42:27\
    \ ------------------------\e[0m\e[0m\n\e[31m42 |\e[0m            \e[33mvar\e[0m\
    \ \e[36mrow\e[0m = grid.get(i)\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue get is not a member of List[List[Long]], but could be\
    \ made available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne\
    \ of the following imports might fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m  import collection.convert.ImplicitConversions.seq AsJavaList\n\e[31m   |\e\
    [0m  import collection.convert.ImplicitConversionsToJava.seq AsJavaList\n\e[31m\
    \   |\e[0m\n3 errors found\n"
  stdout: ''
  timestamp: 1659979372
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = mutable.ArrayBuffer(capacity)\n        val\
    \ wells = mutable.ArrayBuffer.empty[List[Long]]\n        for (row <- grid) {\n\
    \            val row = row.toList.sortBy(_.toLong)\n            val bucket = row(0)\n\
    \            wells ++= row\n            buckets += bucket\n        }\n       \
    \ val emptyWells = buckets.toSet.diffSet(Set(1l.toLong))\n        val res = (wells.length\
    \ - emptyWells).longValue()\n        if (res > capacity) res else capacity\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpdk5fxrsc.scala:26:22 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mbuckets\e[0m = mutable.ArrayBuffer(capacity)\n\
    \e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                 Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpdk5fxrsc.scala:27:20 ------------------------\e[0m\e\
    [0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mwells\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mList\e[0m[\e[35mLong\e[0m]]\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659979368
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val maxCount = 1\n        val emptyCount = 0\n        val\
    \ result = grid.map(row => {\n            if (row.head == 0)\n               \
    \ maxCount += 1\n            else\n                emptyCount += 1\n         \
    \   row\n        }).sum + 1\n        while (emptyCount > 0) {\n            val\
    \ newEmptyCount = grid.map(row => {\n                if (row.head == 0)\n    \
    \                maxCount += 1\n                else\n                    emptyCount\
    \ -= 1\n                row\n            }).sum + 1\n            if (newEmptyCount\
    \ - emptyCount >= 1)\n                break\n            else {\n            \
    \    emptyCount = newEmptyCount\n                maxCount = grid.map(row => {\n\
    \                    if (row.head == 0)\n                        maxCount += 1\n\
    \                    else\n                        emptyCount -= 1\n         \
    \           row\n                }).sum + 1\n            }\n        }\n      \
    \  result\n    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpa73rav17.scala:30:25 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m                maxCount += \e[31m1\e[0m\n\e[31m\e[31m\
    \   |\e[0m                ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m             value\
    \ += is not a member of Int - did you mean maxCount.!=?\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpa73rav17.scala:32:27 ------------------------\e[0m\e\
    [0m\n\e[31m32 |\e[0m                emptyCount += \e[31m1\e[0m\n\e[31m\e[31m \
    \  |\e[0m                ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m           value +=\
    \ is not a member of Int - did you mean emptyCount.!=?\n\e[31m\e[31m-- Error:\
    \ /tmp/tmpa73rav17.scala:34:14 -----------------------------------------\e[0m\e\
    [0m\n\e[31m34 |\e[0m        }).sum + \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m     \
    \         ^\e[0m\n\e[31m   |\e[0m            No implicit Ordering defined for\
    \ B\n\e[31m   |\e[0m\n\e[31m   |\e[0m            where:    B is a type variable\
    \ with constraint >: List[Long]\n\e[31m   |\e[0m            .\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpa73rav17.scala:38:29 ------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m                    maxCount += \e[31m1\e[0m\n\e[31m\e\
    [31m   |\e[0m                    ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m           \
    \  value += is not a member of Int - did you mean maxCount.!=?\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpa73rav17.scala:40:31 ------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m                    emptyCount -= \e[31m1\e[0m\n\e[31m\e\
    [31m   |\e[0m                    ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m         \
    \  value -= is not a member of Int - did you mean emptyCount.!=?\n\e[31m\e[31m--\
    \ Error: /tmp/tmpa73rav17.scala:42:18 -----------------------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m            }).sum + \e[31m1\e[0m\n\e[31m\e[31m   |\e\
    [0m                  ^\e[0m\n\e[31m   |\e[0m            No implicit Ordering defined\
    \ for B\n\e[31m   |\e[0m\n\e[31m   |\e[0m            where:    B is a type variable\
    \ with constraint >: List[Long]\n\e[31m   |\e[0m            .\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpa73rav17.scala:44:16 ------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m                break\n\e[31"
  stdout: ''
  timestamp: 1659979373
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        // Your code here\n        val m = grid.head.size\n    \
    \    var total = 0\n        grid.foreach(row => \n            row.foreach(value\
    \ => \n                total += if(value == 1l) capacity else 0\n            ))\n\
    \        val max1 = total.toInt / m\n        val max2 = ((total % m) * m) - max1\n\
    \        math.max(max1, max2)\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 1l.toLong,\
    \ 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong, 0l.toLong), List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (1l)) == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp3b9z0x6b.scala:31:25 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m                total += \e[33mif\e[0m(value == \e[31m1l\e\
    [0m) capacity \e[33melse\e[0m \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m            \
    \             ^^\e[0m\n\e[31m   |\e[0m                         expression expected\
    \ but \e[31mif\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmp3b9z0x6b.scala:31:22 ------------------------\e[0m\e[0m\n\e[31m31 |\e\
    [0m                total += \e[33mif\e[0m(value == \e[31m1l\e[0m) capacity \e\
    [33melse\e[0m \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m                ^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                value += is not a member of Int - did you mean\
    \ Int.!=?\n2 errors found\n"
  stdout: ''
  timestamp: 1659979372
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        // write your code here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 1l.toLong,\
    \ 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong, 0l.toLong), List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (1l)) == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp2a2zz7ke.scala:25:67\
    \ --------------------\e[0m\e[0m\n\e[31m25 |\e[0m    \e[33mdef\e[0m \e[36mmaxFill\e\
    [0m(\e[36mgrid\e[0m : \e[35mList\e[0m[\e[35mList\e[0m[\e[35mLong\e[0m]], \e[36mcapacity\e\
    [0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e[0m          \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                          Found:    Unit\n\e\
    [31m   |\e[0m                                                          Required:\
    \ Long\n\e[31m26 |\e[0m        \e[34m// write your code here\e[0m\n\e[31m27 |\e\
    [0m    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979372
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val row = grid(0).toList\n        val buckets = row.map(_.toLong)\n\
    \        var max = 0\n        for (i <- 1 to grid.length-1) {\n            for\
    \ (j <- 1 to row(i).length-1) {\n                val newBucket = buckets(j)\n\
    \                val newCapacity = capacity\n                val newBucketCap\
    \ = newCapacity - newBucket\n                val newRow = row(i).filterNot(newBucket).map(_\
    \ + newBucketCap).toList\n                val newGrid = grid :+ newRow\n     \
    \           if (newBucketCap > max) {\n                    max = newBucketCap\n\
    \                }\n            }\n        }\n        max\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpkzr0aoid.scala:30:34 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m            \e[33mfor\e[0m (j <- \e[31m1\e[0m to row(i).length-\e\
    [31m1\e[0m) {\n\e[31m\e[31m   |\e[0m                           ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                           value length is not a member of\
    \ Long\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpkzr0aoid.scala:34:36 ------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m                \e[33mval\e[0m \e[36mnewRow\e[0m = row(i).filterNot(newBucket).map(_\
    \ + newBucketCap).toList\n\e[31m\e[31m   |\e[0m                             ^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                             value filterNot is not a member\
    \ of Long\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpkzr0aoid.scala:37:26\
    \ --------------------\e[0m\e[0m\n\e[31m37 |\e[0m                    max = newBucketCap\n\
    \e[31m\e[31m   |\e[0m                          ^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                          Found:    (newBucketCap : Long)\n\e[31m   |\e[0m\
    \                          Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659979374
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = grid.map(_.toArray).\n            zipWithIndex.\n\
    \            map(x => mutable.HashMap(x -> x._2)).\n            foldLeft(mutable.HashMap.empty[Long,\
    \ Int]()) {\n            case (m, (bucket, index)) => m.updated(index, m.getOrElse(index,\
    \ 0) + bucket)\n        }\n        buckets.foldLeft(0)(x => math.max(x, x.getOrElse(1,\
    \ 0)))\n    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmprowuxd7r.scala:28:21 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m            map(\e[36mx\e[0m => mutable.HashMap(x ->\
    \ x._2)).\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmprowuxd7r.scala:29:21 ------------------------\e[0m\e\
    [0m\n\e[31m29 |\e[0m            foldLeft(mutable.HashMap.empty[\e[35mLong\e[0m,\
    \ \e[35mInt\e[0m]()) {\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmprowuxd7r.scala:30:43 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m            \e[33mcase\e[0m (m, (bucket, index)) => m.updated(index,\
    \ m.getOrElse(index, \e[31m0\e[0m) + bucket)\n\e[31m\e[31m   |\e[0m          \
    \                               ^^^^^^^^^\e[0m\n\e[31m   |\e[0m              \
    \                      value updated is not a member of Any\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmprowuxd7r.scala:30:60 ------------------------\e[0m\e\
    [0m\n\e[31m30 |\e[0m            \e[33mcase\e[0m (m, (bucket, index)) => m.updated(index,\
    \ m.getOrElse(index, \e[31m0\e[0m) + bucket)\n\e[31m\e[31m   |\e[0m          \
    \                                                ^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                                  value getOrElse is not a member of Any\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmprowuxd7r.scala:32:16 ------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        buckets.foldLeft(\e[31m0\e[0m)(\e[36mx\e[0m =>\
    \ math.max(x, x.getOrElse(\e[31m1\e[0m, \e[31m0\e[0m)))\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        value foldLeft is not a\
    \ member of Any\n5 errors found\n"
  stdout: ''
  timestamp: 1659979374
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val map = new mutable.HashMap[Long, List[Long]]\n      \
    \  grid.foreach { row =>\n            row.foreach { column =>\n              \
    \  map.get(column) match {\n                    case Some(list) => list ::= row\n\
    \                    case None => map += (column -> row)\n                }\n\
    \            }\n        }\n        var count = 0\n        map foreach { case (column,\
    \ rows) =>\n            val min = rows.min\n            val max = rows.max\n \
    \           if (max - min < capacity / rows.size) {\n                count +=\
    \ 1\n                if (map.contains(min)) map.remove(min) match {\n        \
    \            case Some(list) => list ::= column\n                    case None\
    \ => map += (column -> column)\n                }\n            }\n        }\n\
    \        count\n    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpwedaleqk.scala:26:22 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mmap\e[0m = \e[33mnew\e[0m\
    \ mutable.HashMap[\e[35mLong\e[0m, \e[35mList\e[0m[\e[35mLong\e[0m]]\n\e[31m\e\
    [31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m   |\e[0m             \
    \         Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpwedaleqk.scala:30:39 ------------------------\e[0m\e[0m\n\e[31m30 |\e\
    [0m                    \e[33mcase\e[0m Some(list) => list ::= row\n\e[31m\e[31m\
    \   |\e[0m                                       ^^^^\e[0m\n\e[31m   |\e[0m  \
    \                                     Not found: list\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659979370
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val m = grid.length\n        val n = grid(0).length\n  \
    \      val buckets = Vector.tabulate(n)((i, _) => capacity)\n        (m > 0 &&\
    \ n < 10L*10L && grid.forall(_.forall(_ == 0)) ||\n           m == 0l && n ==\
    \ 0l && grid.forall(_.forall(_ == 0)) ||\n           m == 0 && n == 0l && grid.forall(_.forall(_\
    \ == 0)))\n            ? 0\n            : findMax(grid, buckets)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpmbb4scw8.scala:33:21 -----------------------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m            : findMax(grid, buckets)\n\e[31m\e[31m  \
    \ |\e[0m                     ^\e[0m\n\e[31m   |\e[0m                     end of\
    \ statement expected but '(' found\n\e[31m\e[31m-- [E086] Syntax Error: /tmp/tmpmbb4scw8.scala:28:48\
    \ ---------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbuckets\e[0m = Vector.tabulate(n)((\e[36mi\e[0m, _) => capacity)\n\e[31m\e\
    [31m   |\e[0m                                         ^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                 Wrong number of parameters, expected:\
    \ 1\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpmbb4scw8.scala:32:12 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        (m > \e[31m0\e[0m && n < \e[31m10L\e[0m*\e[31m10L\e\
    [0m && grid.forall(_.forall(_ == \e[31m0\e[0m)) ||\n\e[31m30 |\e[0m          \
    \ m == \e[31m0l\e[0m && n == \e[31m0l\e[0m && grid.forall(_.forall(_ == \e[31m0\e\
    [0m)) ||\n\e[31m31 |\e[0m           m == \e[31m0\e[0m && n == \e[31m0l\e[0m &&\
    \ grid.forall(_.forall(_ == \e[31m0\e[0m)))\n\e[31m32 |\e[0m            ? \e[31m0\e\
    [0m\n\e[31m\e[31m   |\e[0m        ^\e[0m\n\e[31m   |\e[0m        value ? is not\
    \ a member of Boolean.\n\e[31m   |\e[0m        Note that `?` is treated as an\
    \ infix operator in Scala 3.\n\e[31m   |\e[0m        If you do not want that,\
    \ insert a `;` or empty line in front\n\e[31m   |\e[0m        or drop any spaces\
    \ behind the operator.\n3 errors found\n"
  stdout: ''
  timestamp: 1659979372
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val bucketSize = capacity\n        val grid = mutable.ArrayBuffer.empty[List[Long]]\n\
    \        for (i <- 0 until grid.length){\n            grid += i :: Nil\n     \
    \   }\n        val result = mutable.ArrayBuffer.empty[Long]\n        var next\
    \ = 1\n        for (i <- 0 until grid.length - 1){\n            for (j <- 0 until\
    \ grid[i].length - 1){\n                val nextBuckets = next / bucketSize\n\
    \                next += 1\n                val buckets = grid.map(_.map(i =>\
    \ if (i == j) 1l else 0l))\n                val bucket = buckets(i)\n        \
    \        val nextValue = bucket * nextBuckets\n                for (k <- 0 until\
    \ bucketSize - 1){\n                    if (!(nextValue + k + 1 < bucketSize)){\n\
    \                        nextValue += k + 1\n                    }\n         \
    \       }\n                val value = nextValue + bucket * nextBuckets\n    \
    \            result += value\n            }\n        }\n        result.toList.length\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpyt2zyaf6.scala:27:19 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mgrid\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mList\e[0m[\e[35mLong\e[0m]]\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpyt2zyaf6.scala:31:21 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpyt2zyaf6.scala:34:35 ------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m            \e[33mfor\e[0m (j <- \e[31m0\e[0m until grid[\e\
    [35mi\e[0m].length - \e[31m1\e[0m){\n\e[31m\e[31m   |\e[0m                   \
    \                ^\e[0m\n\e[31m   |\e[0m                                   Not\
    \ found: type i\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpyt2zyaf6.scala:40:34\
    \ --------------------\e[0m\e[0m\n\e[31m40 |\e[0m                \e[33mfor\e[0m\
    \ (k <- \e[31m0\e[0m until bucketSize - \e[31m1\e[0m){\n\e[31m\e[31m   |\e[0m\
    \                                  ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \                            Found:    Long\n\e[31m   |\e[0m                 \
    \                 Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659979375
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val m = grid.length\n        val n = grid(0).length\n  \
    \      var max = 0\n        grid(0).foreach(x => { \n            if (x == 1) \n\
    \                max += 1\n        })\n        (1 to m).map(x => (0 to n).map(y\
    \ => grid(x).map(z => if (z == 0) capacity else z).sum).sum).reduce((x, y) =>\
    \ if (x > y) x else y)\n    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 3\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.maxFill$$anonfun$2$$anonfun$1(tmp_p5853b7.scala:33)\n\tat scala.runtime.java8.JFunction1$mcJI$sp.apply(JFunction1$mcJI$sp.scala:17)\n\
    \tat scala.collection.immutable.Range.map(Range.scala:59)\n\tat Problem$.maxFill$$anonfun$2(tmp_p5853b7.scala:33)\n\
    \tat scala.runtime.java8.JFunction1$mcJI$sp.apply(JFunction1$mcJI$sp.scala:17)\n\
    \tat scala.collection.immutable.Range.map(Range.scala:59)\n\tat Problem$.maxFill(tmp_p5853b7.scala:33)\n\
    \tat Problem$.main(tmp_p5853b7.scala:36)\n\tat Problem.main(tmp_p5853b7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGe"
  stdout: ''
  timestamp: 1659979375
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        // write your code here\n        val newGrid = grid.map\
    \ { row =>\n            val r = mutable.ArrayBuffer.empty[Long]\n            row.foreach(x\
    \ => r.synchronized += x)\n            r\n        }.toList\n\n        val maxLength\
    \ = mutable.ArrayBuffer.empty[Long]\n        var counter = 0\n\n        while(newGrid.isEmpty)\
    \ {\n            val max = newGrid.map(x => x.sum).max\n            if(max ==\
    \ capacity) counter += 1\n            if(max > capacity) {\n                val\
    \ r = newGrid.map(x => x.sum).dropWhile(x => x == capacity)\n                maxLength\
    \ += r.min\n                newGrid = r.toList\n            } else {\n       \
    \         maxLength += max\n                newGrid = newGrid.dropWhile(x => x\
    \ == max).toList\n            }\n        }\n\n        maxLength.max\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpr_6tk329.scala:28:20 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m            \e[33mval\e[0m \e[36mr\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpr_6tk329.scala:33:24 ------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mmaxLength\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                        ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                        Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpr_6tk329.scala:37:41 ------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m            \e[33mval\e[0m \e[36mmax\e[0m = newGrid.map(\e\
    [36mx\e[0m => x.sum).max\n\e[31m\e[31m   |\e[0m                              \
    \         ^^^^^\e[0m\n\e[31m   |\e[0mvalue sum is not a member of Nothing, but\
    \ could be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mOne of the following imports might fix the problem:\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m  import Option.option2Iterable\n\e[31m   |\e[0m  import collection.LazyZip2.lazyZip2ToIterable\n\
    \e[31m   |\e[0m  import collection.LazyZip3.lazyZip3ToIterable\n\e[31m   |\e[0m\
    \  import collection.LazyZip4.lazyZip4ToIterable\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.list\
    \ asScalaBuffer\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.properties\
    \ AsScalaMap\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.enumeration\
    \ AsScalaIterator\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.iterator\
    \ asScala\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.map\
    \ AsScalaConcurrentMap\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.set\
    \ asScala\n\e[31m   |\e[0m\n\e[31m\e[31m-- Error: /tmp/tmpr_6tk329.scala:37:49\
    \ -----------------------------------------\e"
  stdout: ''
  timestamp: 1659979375
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = mutable.HashSet[Long](capacity)\n        grid\
    \ foreach {\n            case x if x.forall(x => buckets add x) =>\n         \
    \       buckets = buckets.filterNot(x => x == 0)\n        }\n        buckets.foldLeft(0l)((a,\
    \ b) => if (b > a) b - a else a)\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 1l.toLong,\
    \ 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong, 0l.toLong), List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (1l)) == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpdgbd6b97.scala:26:22 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mbuckets\e[0m = mutable.HashSet[\e\
    [35mLong\e[0m](capacity)\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E052] Type Error: /tmp/tmpdgbd6b97.scala:29:24 -----------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m                buckets = buckets.filterNot(\e[36mx\e\
    [0m => x == \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                Reassignment to val buckets\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659979373
