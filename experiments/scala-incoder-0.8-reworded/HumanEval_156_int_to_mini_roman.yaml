name: HumanEval_156_int_to_mini_roman
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Given a positive integer, obtain its roman numeral equivalent as a string,\n\
  \    // and return it in lowercase.\n    // Restrictions: 1 <= num <= 1000\n   \
  \ // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n    // >>> intToMiniRoman((152l))\n\
  \    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n    // (\"cdxxvi\")\n   \
  \ def intToMiniRoman(number : Long) : String = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
  xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
  ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
  d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
  iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
  xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
  dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
  cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n}\n"
completions: ["        var ret = \"\"\n        var i = 0\n        var j = 0\n    \
    \    var n = 0\n\n        while (i <= number.toInt) {\n            j = number.toInt\
    \ - i\n\n            n = number\n            while (j > (n%10)) {\n          \
    \      n /= 10\n                j /= 10\n            }\n            n += j\n\n\
    \            while (n > 1000) {\n                ret += \"M\"\n              \
    \  n /= 100\n            }\n            while (n > 900) {\n                ret\
    \ += \"CM\"\n                n /= 100\n            }\n            while (n > 400)\
    \ {\n                ret += \"D\"\n                n /= 100\n            }\n \
    \           while (n > 100) {\n                ret += \"CD\"\n               \
    \ n /= 100\n            }\n            while (n > 90) {\n                ret +=\
    \ \"C\"\n                n /= 100\n            }\n            while (n > 40) {\n\
    \                ret += \"XC\"\n                n /= 100\n            }\n    \
    \        while (n > 10) {\n                ret += \"L\"\n                n /=\
    \ 100\n            }\n            while (n > 5) {\n                ret += \"XL\"\
    \n                n /= 100\n            }\n            while (n > 1) {\n     \
    \           ret += \"X\"\n                n /= 100\n            }\n          \
    \  while (n > 1) {\n                ret += \"I\"\n                n /= 100\n \
    \           }\n\n            ret += n\n            ret += \"\"\n            i\
    \ += 1\n        }\n        return ret", "        val roms = new mutable.HashMap[Int,\
    \ String]()\n        val ones = \"I V X L C D M S \"\n        val tens = \"X L\
    \ C D M \"\n        val hundreds = \"C D M \"\n        val thousands = \"M S \"\
    \n        for (i <- 1L to 1000) {\n            val n = number / (i.toDouble)\n\
    \            roms += (i.toLong -> if(n > 0) tens.dropRight(1) else ones.dropRight(1))\n\
    \            number -= i * i.toDouble\n        }\n        for (i <- 1L to 1000)\
    \ {\n            val n = number / (i.toDouble)\n            roms += (i.toLong\
    \ -> if(n > 0) hundreds.dropRight(1) else thousands.dropRight(1))\n          \
    \  number -= i * i.toDouble\n        }\n        val res = roms map {case (num,\
    \ rom) => (num toString + rom) } reduce (_.concat)\n        if(res.equals(\"\"\
    )) \"\" else res.toLower", "        var numeral = \"\"\n        for(i <- 1 to\
    \ number) {\n            numeral += miniRoman(number)\n        }\n        numeral.toLowerCase()",
  "        val roman = romanMap(number)(0)\n        var result : String = \"\"\n \
    \       for(i <- 0 until roman.length){\n            if(roman(i) == 1) result\
    \ = result + roman(i)\n            else if(roman(i) == 2) result = result + \"\
    i\"\n            else if(roman(i) == 3) result = result + \"ii\"\n           \
    \ else if(roman(i) == 4) result = result + \"iii\"\n            else if(roman(i)\
    \ == 5) result = result + \"iv\"\n            else if(roman(i) == 6) result =\
    \ result + \"v\"\n            else if(roman(i) == 7) result = result + \"vi\"\n\
    \            else if(roman(i) == 8) result = result + \"vii\"\n            else\
    \ if(roman(i) == 9) result = result + \"viii\"\n            else if(roman(i) ==\
    \ 10) result = result + \"ix\"\n            else if(roman(i) == 11) result = result\
    \ + \"x\"\n            else if(roman(i) == 12) result = result + \"xi\"\n    \
    \        else if(roman(i) == 13) result = result + \"xii\"\n            else if(roman(i)\
    \ == 14) result = result + \"xiii\"\n            else result = result + \"xiii\"\
    \n        }\n        return result", "        val roman = \"MCMXCIV\"\n      \
    \  val romanNums = roman.map(_.toInt)\n        var miniRoman = \"-1\"\n      \
    \  for((r,n) <- romanNums zip number if n < 0){\n            miniRoman = r + miniRoman\n\
    \        }\n        for((r,n) <- romanNums zip number if n >= 0){\n          \
    \  miniRoman = n + miniRoman\n        }\n        return miniRoman.substring(1,\
    \ miniRoman.length)", "        val romanMap = new mutable.HashMap[Long, String]()\n\
    \        romanMap (1000) =\"M\"\n        romanMap (900) =\"CM\"\n        romanMap\
    \ (500) =\"D\"\n        romanMap (400) =\"CD\"\n        romanMap (100) =\"C\"\n\
    \        romanMap (90) =\"XC\"\n        romanMap (50) =\"L\"\n        romanMap\
    \ (40) =\"XL\"\n        romanMap (10) =\"X\"\n        romanMap (9) =\"IX\"\n \
    \       romanMap (5) =\"V\"\n        romanMap (4) =\"IV\"\n        romanMap (1)\
    \ =\"I\"\n        val number = number%100\n        var roman = \"\"\n        while(number\
    \ != 0){\n            val digit = number%10;\n            roman += romanMap(digit)\n\
    \            number /= 10;\n        }\n        roman.lowercase", "        val\
    \ r = new scala.collection.mutable.StringBuilder()\n        var n = (number /\
    \ 1000l).toInt\n        var m = number % 1000l\n        var num = 0l\n       \
    \ var isNeg = (number < 0l)\n        var i = 1l\n        while(m > 1000) {\n \
    \           m = m / 1000l\n            num += 1l\n        }\n        while(n >\
    \ 1) {\n            if(n % 10 == 0) {\n                m.toString.toCharArray.foreach(\
    \ c => r += c.toString.toUpperCase)\n                r += m.toString.toUpperCase\n\
    \                m = m / 10l\n                num -= 1\n            } else if(n\
    \ % 10 == 1) {\n                r += m.toString.toUpperCase\n                m\
    \ = m / 10l\n                num -= 1\n            } else {\n                r\
    \ += m.toString.toUpperCase\n                m = m / 10l\n                num\
    \ -= 1\n            }\n            n -= 1\n        }\n        if(isNeg) r += \"\
    -\"\n        r += num.toString\n        r.toString.toLowerCase", "        def\
    \ miniRoman(x : int, maxium : int) : String = {\n            val result = \"\"\
    \n            val a = scala.math.pow( 10, x )\n            val b = scala.math.pow(\
    \ 10, maxium )\n            for( i <- 1 to maxium ) {\n                if( i %\
    \ 2 != 0 ) {\n                    result += scala.math.floor( x % b ) / b\n  \
    \              }\n                x /= a\n            }\n            return result\n\
    \        }\n        return miniRoman(number, 1000)", "        val roman: Set[Char]\
    \ = Set( 'I', 'IV', 'V', 'IX', 'XL', 'XC' );\n        val digits: Set[Int] = Set(1,\
    \ 5, 10, 50, 100, 500, 1000, 5000);\n        val numerals: Map[Int, String] =\
    \ Map(\n            1 -> \"I\",\n            5 -> \"V\",\n            10 -> \"\
    X\",\n            50 -> \"L\",\n            100 -> \"C\",\n            500 ->\
    \ \"D\",\n            1000 -> \"M\",\n            5000 -> \"C\"\n        );\n\
    \        val result = roman.map( x => digits.contains( x.toInt ) match {\n   \
    \         case true => numerals(x.toInt)\n            case false => x.toString\n\
    \        }).mkString\n        result.toLowerCase", "        var roman = scala.collection.mutable.StringBuilder()\n\
    \        var i = 3\n        while(i > 0 && number > 0){\n            roman +=\
    \ intToMiniRoman(number % i)\n            i /= 100\n            number /= 100\n\
    \        }\n        roman.toString()", "        //  Represent number as string\
    \ array of (numeral, value)\n        val numberStringArray = (1l..number).map(i\
    \ => s\"${i}${i}\").toArray\n        // Calculate string array of (denominator,\
    \ numerators)\n        val numeratorsStringArray = (1l..number).map(i => s\"${i}\"\
    ).toArray\n        val sum : Int = numeratorsStringArray.map(_.length).sum\n \
    \       val numeratorsStringBuilder = Stream.concat(Stream.from(0)(numeratorsStringArray),\
    \ numeratorsStringArray.tail).map(_ + \"\").toArray\n        val denominatorsStringBuilder\
    \ = Stream.from(0)(numeratorsStringArray.map(_.length).toArray).map(_ + \"\").toArray\n\
    \        val numeratorsStringBuilderToArray = Stream.from(numeratorsStringBuilder)(_.toArray).toArray\n\
    \        val denominatorsStringBuilderToArray = Stream.from(denominatorsStringBuilder)(_.toArray).toArray\n\
    \        val numeratorsStringBuilderToArrayLength = numeratorsStringBuilderToArray.length\n\
    \        val denominatorsStringBuilderToArrayLength = denominatorsStringBuilderToArray.length\n\
    \        val numberStringBuilderLength = numberStringArray.length\n        //\
    \ Calculate numerators and denominators from string arrays\n        var numerators\
    \ : Array[String] = null\n        var denominators : Array[String] = null\n  \
    \      numerators = numeratorsStringBuilderToArray.slice(0, numeratorsStringBuilderToArrayLength).map(x\
    \ => x.padTo(sum, \"0\") + x)\n        denominators = denominatorsStringBuilderToArray.slice(0,\
    \ denominatorsStringBuilderToArrayLength).map(x => x.padTo(sum, \"0\") + x)\n\
    \        val numeratorsLength = numerators.length\n        val denominatorsLength\
    \ = denominators.length\n        // Remove leading zeros from numerators and denominators\n\
    \        var numeratorsLength = numeratorsLength\n        var denominatorsLength\
    \ = denominatorsLength\n        while (numeratorsLength > 0 && numerators(numeratorsLength\
    \ - 1) == \"\") numeratorsLength = numeratorsLength - 1\n        while (denominatorsLength\
    \ > 0 && denominators(denominatorsLength - 1) == \"\") denominatorsLength = denominatorsLength\
    \ - 1\n        val minLength = min(numeratorsLength, denominatorsLength)\n   \
    \     val newNumerators = numerators.slice(0, minLength)\n        val newDenominators\
    \ = denominators.slice(0, minLength)\n        // Determine new denominators and\
    \ numerators from new denominators\n        var newDenominatorsLength = newDenominators.length\n\
    \        var newNumeratorsLength = newNumerators.length", "        val num = number.toInt\n\
    \        // the length of roman numeral string\n        val romanLength = 1\n\
    \        val romanString = new Array[Char](romanLength)\n        val romanStringMutable\
    \ = mutable.ArrayBuffer(romanString)\n        val romanValues = mutable.ArrayBuffer(\n\
    \            (100, \"M\"),\n            (90, \"CM\"),\n            (50, \"D\"\
    ),\n            (40, \"CD\"),\n            (10, \"C\"),\n            (9, \"XC\"\
    ),\n            (5, \"L\"),\n            (4, \"XL\"),\n            (1, \"X\")\n\
    \            )\n        val romanValueIndex = romanValues.length - 1\n\n     \
    \   val divisor = num / romanValueIndex\n        romanStringMutable(0) = if (divisor\
    \ > 0) romanValues(romanValueIndex - divisor)\n            else \"M\"\n      \
    \  num %= romanValueIndex\n\n        val remainder = num % romanValueIndex\n \
    \       romanStringMutable(1) = if (remainder > 0) romanValues(remainder)\n  \
    \          else \"M\"\n        romanString.mkString", "        val romans = Map(\n\
    \            1 -> \"I\",\n            5 -> \"V\",\n            10 -> \"X\",\n\
    \            50 -> \"L\",\n            100 -> \"C\",\n            500 -> \"D\"\
    ,\n            1000 -> \"M\"\n        )\n        val roman = romans.values.drop(romans.indexOf(romans.max)).last\n\
    \        val numString = number.toString.toInt\n        val romanNum = romans(numString).take(roman.length)\n\
    \        val result = roman.zip(romanNum).map(x => x._1 + x._2).mkString(\"\"\
    )\n        result", "        // Convert the number to String and collect results\
    \ in a list\n        val numberString = number.toString\n        val result =\
    \ numberString.dropRightWhile(_ <= '1').dropWhile(_ <= '0').takeWhile(_ != '0')\n\
    \        // Convert the list to a string, return it in lowercase\n        return\
    \ result.mkString.toLowerCase", "        val roman : ListBuffer[Char] = new ListBuffer[Char]()\n\
    \        // We first convert the number to a string\n        var numberString\
    \ = number.toString\n        var index = 0\n        while(index < numberString.length)\
    \ {\n            val c = numberString(index)\n            if (c == '0') {\n  \
    \              roman.append('I')\n            } else if (c == '1') {\n       \
    \         roman.append('V')\n            } else if (c == '5') {\n            \
    \    roman.append('X')\n            } else if (c == '9') {\n                roman.append('IX')\n\
    \            } else {\n                roman.append(c)\n            }\n      \
    \      index += 1\n        }\n        val miniRoman = roman.mkString\n       \
    \ miniRoman.toLowerCase", "        val romans = mutable.Map.empty[Long, String]\n\
    \n        while(number > 0) {\n            romans(number) = romans.getOrElse(number,\
    \ \"\")\n            number = number / 100\n\n        }\n        romans.map {\
    \ case (k, v) => k + \"M\" + v }", "        val romanArray = Array(\"\", \"M\"\
    , \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"\
    IV\", \"I\")\n        val romanToIntArray = romanArray.zip(romanArray).map(c =>\
    \ (c.getInt(0), c.getInt(1))).toArray\n        val integer = BigInt(number)\n\
    \        val numeral = romanToIntArray.map(i => integer.getAndRemainder(BigInt(i._2))).toList.reverse.foldLeft(\"\
    \")(_ + _ + _)\n        numeral.toLowerCase + numeral(1)", "        val roman\
    \ = List(\"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"\
    IX\", \"X\", \"XI\", \"XII\", \"XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\", \"\
    XVIII\", \"XIX\", \"XX\", \"XXI\", \"XXII\", \"XXIII\", \"XXIV\", \"XXV\", \"\
    XXVI\", \"XXVII\", \"XXVIII\", \"XXIX\", \"XXX\", \"XXI\", \"XXII\", \"XXIII\"\
    , \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\", \"XXVIII\", \"XXIX\", \"XXX\")\n   \
    \     val romanNum = List(\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\"\
    , \"DCC\", \"DCCC\", \"CM\", \"M\", \"MM\", \"MMM\")\n        val string = \"\"\
    \n        if (number > 999) {\n            throw new IllegalArgumentException(\"\
    number must be less than or equal to 999\")\n        } else {\n            number\
    \ match {\n                case i if i <= 100 => string += roman(number/100) +\
    \ \"V\"\n                case i if i <= 500 => string += roman(number/1000) +\
    \ \"IX\"\n                case i if i <= 1000 => string += roman(number/100) +\
    \ \"X\"\n                case _ => throw new IllegalArgumentException(\"number\
    \ must be between 1 and 999\")\n            }\n        }\n        return string.toLowerCase",
  "        val result = new StringBuilder\n        val numerals = Array(\"\", \"c\"\
    , \"d\", \"l\", \"x\", \"c\", \"l\")\n        val letters = Array(\"\", \"i\"\
    , \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\")\n        var index\
    \ = 0\n        var current = number % 1000\n        while(current > 0) {\n   \
    \         if(current > 999) {\n                index += 3\n                current\
    \ = current / 1000\n            } else {\n                index += 2\n       \
    \         current = current / 100\n            }\n            result.append(letters(index))\
    \ // append this letter\n            result.append(numerals(current)) // append\
    \ this numeral\n        }\n        return result.toString()", "        val romanArray\
    \ = new Array[String](11)\n        romanArray(0) =\"M\";romanArray(1) =\"C\";romanArray(2)\
    \ =\"L\";romanArray(3) =\"X\";romanArray(4) =\"V\";romanArray(5) =\"I\";romanArray(6)\
    \ =\"D\";romanArray(7) =\"M\";romanArray(8) =\"C\";romanArray(9) =\"L\";romanArray(10)\
    \ =\"X\";\n        val index = number / 1000\n        val romanIndex = number\
    \ % 1000\n        romanArray(romanIndex)", "        val roman = mutable.ListBuffer.empty[String]\n\
    \        var i = 0\n        while (i < number) {\n            var val = number\n\
    \            while (val > 0) {\n                val remainder = val % 10\n   \
    \             roman.append(remainder)\n                val val /= 10\n       \
    \     }\n            i += 1\n        }\n        return roman.toString.toLowerCase",
  "        def miniRoman(n : Long) : String = {\n            if(n >= 1000000000l)\
    \ miniRoman(n / 1000000000l) + 'M'\n            else if(n >= 1000000l) miniRoman(n\
    \ / 1000000l) + 'CM'\n            else if(n >= 1000l) miniRoman(n / 1000l) + 'CD'\n\
    \            else if(n >= 100l) miniRoman(n / 100l) + 'XC'\n            else if(n\
    \ >= 10l) miniRoman(n / 10l) + 'L'\n            else miniRoman(n % 10) + 'X'\n\
    \        }\n        val arr = mutable.ArrayBuffer.empty[(Int, String)]\n     \
    \   var i = number\n        while(i >= 1) {\n            arr += ((i / 10, miniRoman(i\
    \ % 10)))\n            i /= 10\n        }\n        arr.toSeq.reverse.map(x =>\
    \ x._2).mkString.toLowerCase", "        if (number < 1 || number > 1000l) throw\
    \ new RuntimeException(\"number out of range\")\n        var romanNumber = \"\
    I\"\n        var previousValue = 0\n        while (number > 0) {\n           \
    \ var currentValue = number % 100l\n            var currentSymbol = romanNumber.charAt(romanNumber.length\
    \ - 1)\n            var currentPreviousValue = previousValue % 10l\n         \
    \   previousValue = currentValue\n            romanNumber += currentSymbol\n \
    \           number -= currentValue\n            var nextValue = currentValue *\
    \ 100l\n            var nextSymbol = romanNumber.charAt(romanNumber.length - 1)\n\
    \            var nextPreviousValue = previousValue * 10l\n            previousValue\
    \ = nextValue\n            romanNumber += nextSymbol\n            number -= nextValue\n\
    \        }\n        return romanNumber", "        val roman = number.toRoman\n\
    \        val chars = roman.split('')\n        val index = chars.indexOf(\"i\"\
    );\n        val newChars = chars.filterNot(_ == \"i\")\n        val numString\
    \ = \"\" + chars(0).toInt + chars(1).toInt + chars(2).toInt + chars(3).toInt +\n\
    \            chars(4).toInt + chars(5).toInt + chars(6).toInt + chars(7).toInt\
    \ + chars(8).toInt + chars(9).toInt;\n        val newNum = numString + chars(index)\n\
    \        newChars.mkString(\"\") + newNum.toLower", "      var currentChar = scala.util.Try(number.toString).getOrElse(\"\
    I\")\n      var numOfChars = 0\n      var roman = \"\"\n      var lastChar = \"\
    \"\n      while(currentChar.length >= 1){\n        lastChar = currentChar\n  \
    \      if(currentChar >= 1000000000000l)\n          currentChar = scala.util.Try(currentChar.toString.dropRight(9)).getOrElse(\"\
    \")\n        roman = roman.dropRight(1)\n        roman = roman + lastChar\n  \
    \      numOfChars = numOfChars + 1\n      }\n      while(numOfChars > 0){\n  \
    \      roman = roman + currentChar\n        currentChar = scala.util.Try(currentChar.toString.dropRight(1)).getOrElse(\"\
    \")\n        numOfChars = numOfChars - 1\n      }\n      roman = roman.dropRight(1)\n\
    \      return roman", "        val romans = Map(1000 -> \"M\", 900  -> \"CM\"\
    , 500  -> \"D\", 400  -> \"CD\", 100  -> \"C\", 90   -> \"XC\", 50   -> \"L\"\
    , 40   -> \"XL\", 10   -> \"X\", 9    -> \"IX\", 5    -> \"V\", 4    -> \"IV\"\
    , 1    -> \"I\")\n        val n = number\n        val roman = \"\"\n        var\
    \ remainder = n\n        while (n > 0) {\n            roman += romans(n % 100l)\n\
    \            n /= 100l\n        }\n        remainder = remainder % 10\n      \
    \  romans += (remainder, \"X\")\n        (romans.reverse mkString \"\")", "  \
    \      var numerals = scala.collection.mutable.ListBuffer.empty[String]\n    \
    \    var i = 0\n        var isDigit = true\n        var isUpper = false\n    \
    \    var isOdd = false\n        while(number != 0) {\n            val x = number\
    \ % 10\n            if(x != 0) {\n                numerals += if (isUpper) x.toString()\
    \ else x.toString.toLowerCase()\n                number /= 10\n            }\n\
    \            else {\n                numerals += if (isUpper) x.toString() else\
    \ x.toString.toLowerCase()\n                if(isOdd) {\n                    numerals\
    \ += \"i\"\n                }\n                else {\n                    numerals\
    \ += \"c\"\n                }\n                isDigit = false\n             \
    \   isUpper = false\n                isOdd = true\n                number /= 10\n\
    \            }\n        }\n        numerals.reverse.mkString", '        // TODO:
    fill in the code here', "        if (number == 0 || number == 1) {\n         \
    \   return \"i\"\n        }\n        if (number == 12) {\n            return \"\
    xix\"\n        }\n        if (number < 1000 || number > 9999) {\n            throw\
    \ new IllegalArgumentException(\"Invalid number \" + number)\n        }\n    \
    \    var sum : Int = 0\n        val str = new StringBuilder\n        for (i <-\
    \ 1 until number) {\n            if (number % i == 0) {\n                sum +=\
    \ i\n                str.append(intToMiniRoman(i))\n            }\n        }\n\
    \        if (sum < number) {\n            str.append(\"vi\")\n        } else {\n\
    \            str.append(\"ix\")\n        }\n        str.result()", "        val\
    \ digits = scala.math.pow(_ , number)\n        val firstDigits = scala.math.pow(10.0,\
    \ number)\n        val result = (scala.math.round(firstDigits) to scala.math.round(digits)).\n\
    \            map{f => if(f == 0) \"0\"\n            else scala.math.pow(f, number).asInstanceOf[Int].toString}.\n\
    \            mkString(\"\")\n        result.toLower", "        val ones   = Set(\"\
    i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\")\n    \
    \    val tens   = Set(\"x\", \"xx\", \"xxx\")\n        val hundreds = Set(\"c\"\
    , \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\")\n       \
    \ val thous = Set(\"t\")\n        val thousands = Set(\"m\", \"mm\", \"mmm\",\
    \ \"mxxx\")\n        val millions = Set(\"mmm\", \"mmmm\", \"xxxm\")\n       \
    \ val billions = Set(\"bbbb\", \"bab\", \"bba\")\n        val trillions = Set(\"\
    bbbbb\", \"bbaa\", \"babb\", \"babba\", \"bbaab\", \"bbbab\")\n        val quadrillions\
    \ = Set(\"bbaaab\", \"bbaabb\", \"babbab\", \"babbabb\", \"babbabba\", \"babbabbab\"\
    )\n        val quintillions = Set(\"bbbbbab\", \"babbabbb\", \"babbabbab\", \"\
    babbabbabb\", \"babbabbabba\", \"babbabbabbab\")\n        val sextillions = Set(\"\
    bbbbbabab\", \"babbabbabb\", \"babbabbabbab\", \"babbabbabbabb\", \"babbabbabbabba\"\
    , \"babbabbabbabbab\")\n        val septillions = Set(\"bbbbbbbabb\", \"babbbbabba\"\
    , \"babbbbabbabbab\", \"babbbbabbabbabb\", \"babbbbabbabbaba\", \"babbbbabbabbabb\"\
    )\n        val octillions = Set(\"bbbbbbbabab\", \"babbbbabbabb\", \"babbbbabbabbab\"\
    , \"babbbbabbabbabb\", \"babbbbabbabbaba\", \"babbbbabbabbabb\")\n        val\
    \ nonillions = Set(\"bbbbbbb\", \"babbbb\", \"babbbba\", \"babbbbab\", \"babbbbabb\"\
    , \"babbbbabba\", \"babbbbabbabbab\")\n        val decillions = Set(\"bbbbbbbb\"\
    , \"bbbbbab\", \"bbbbbabb\", \"bbbbbabba\", \"bbbbbabbab\", \"bbbbbabbab\", \"\
    bbbbbabbabb\", \"bbbbbbbbbb\")\n        val undecillions = Set(\"bbbbbbbbbb\"\
    , \"bbbbbbbbbbb\", \"bbbbbbbbbbba\", \"bbbbbbbbbbbb\", \"bbbbbbbbbbbbb\", \"bbbbbbbbbbbbba\"\
    , \"bbbbbbbbbbbbbab\")\n        val unoctillions = Set(\"bbbbbbbbbbab\", \"bbbbbbbbbbbab\"\
    , \"bbbbbbbbbbbabb\", \"bbbbbbbbbbbabba\", \"bbbbbbbbbbbabbab\", \"bbbbbbbbbbbabbabb\"\
    , \"bbbbbbbb", "        val arr = Array(1l, 5l, 10l, 50l, 100l, 500l, 1000l)\n\
    \        val miniRoman = arr(number).toString.dropRight(1)\n        miniRoman",
  "        var result = \"\"\n        var base = 1000l\n        while (number > base)\
    \ {\n            number -= base\n            result = result + \"M\"\n       \
    \     base = 1000l\n        }\n        base = 1000l\n        var digits = mutable.ArrayBuffer.empty[Long]\n\
    \        var num = 0L\n        while (number > 0) {\n            digits = digits\
    \ :+ num % base\n            num = num / base\n            base = 1000l\n    \
    \    }\n        for (number <- digits) {\n            result = result + romanNumerals.get(number).toString.toLowerCase\n\
    \        }\n        return result", "        // Write your code here\n       \
    \ var numStr = \"\"\n        var i = 0\n        var last = 0\n        var numCount\
    \ = 0\n        while(number > 0) {\n            numCount += number % 10\n    \
    \        number = number / 10\n            i += 1\n            num = number %\
    \ 10\n            if(last == 0) {\n                numStr += num\n           \
    \ }\n            else if(last != 1) {\n                numStr += numStr(num)\n\
    \            }\n            else if(numCount == 0) {\n                last = 1\n\
    \                numStr += numStr(num)\n            }\n            else if(numCount\
    \ == 1) {\n                last = num\n                numStr += numStr(num)\n\
    \            }\n            else if(numCount == 2) {\n                last = 1\n\
    \                numStr += numStr(num)\n            }\n            else {\n  \
    \              numStr += numStr(num)\n            }\n        }\n        if(numCount\
    \ == 0 && numStr.length < 4) {\n            while(numStr.length < 4) {\n     \
    \           numStr += \"0\"\n            }\n        }\n        else if(numCount\
    \ == 1 && numStr.length < 3) {\n            while(numStr.length < 3) {\n     \
    \           numStr += \"0\"\n            }\n        }\n        if(numStr.length\
    \ == 1) {\n            numStr += numStr(num)\n        }\n        else if(numStr.length\
    \ != 0) {\n            while(numStr.length > 0) {\n                numStr += \"\
    0\"\n            }\n        }\n        return numStr", "        var result: String\
    \ = \"\"\n        val romans = List(\n            \"I\",\"II\",\"III\",\"IV\"\
    ,\"V\",\"VI\",\"VII\",\"VIII\",\"IX\",\n            \"X\",\"XX\",\"XXX\",\"XL\"\
    ,\"L\",\"LX\",\"LXX\",\"LXXX\",\"XC\",\n            \"C\",\"CC\",\"CCC\",\"CD\"\
    ,\"D\",\"DC\",\"DCC\",\"DCCC\",\"CM\",\n            \"M\"\n        )\n       \
    \ var numberString = number.toString\n        var numDigits = numberString.length\n\
    \        var currentNumber = 1\n        var currentResult = \"\"\n        var\
    \ romanIndex: Int = romans.indexOf(\"M\")\n        while (currentNumber <= numDigits)\
    \ {\n            if (numDigits > 9) {\n                romanIndex = romans.indexOf(\"\
    M\")\n            }\n            val temp = currentNumber % 10\n            val\
    \ nextTemp = currentNumber / 10\n            currentResult = romans(romanIndex)\
    \ + romans(romanIndex + 1) + romans(romanIndex + 2) + romans(romanIndex + 3)\n\
    \            if (currentResult != romans(romanIndex) && currentResult != romans(romanIndex\
    \ + 1) && currentResult != romans(romanIndex + 2) && currentResult != romans(romanIndex\
    \ + 3)) {\n                currentResult = romans(romanIndex + 1) + romans(romanIndex\
    \ + 2) + romans(romanIndex + 3)\n            }\n            if (temp != 0) {\n\
    \                currentResult += \"M\"\n                currentNumber += 1\n\
    \            }\n            if (nextTemp != 0) {\n                currentResult\
    \ += \"M\"\n                currentNumber += nextTemp\n            }\n       \
    \     numDigits -= 1\n        }\n        result = currentResult\n        return\
    \ result.toLowerCase()", "        val romList = mutable.ListBuffer(\"\")\n   \
    \     for (i <- 0 until number) {\n            romList += \"M\"\n        }\n \
    \       for (i <- number until 1000) {\n            romList += \"CM\"\n      \
    \      romList += getRomanNumberForNumber(i)\n        }\n        val reversed\
    \ = romList.reverse\n        val result = reversed.mkString(\"\")\n        result.substring(1,\
    \ result.length).toLowerCase", "        if(number < 1 || number > 1000) {\n  \
    \          throw new java.lang.NumberFormatException(\"Invalid roman-number \"\
    +number);\n        }\n        if(number == 1)\n            return \"I\";\n   \
    \     val roman = scala.collection.mutable.ListBuffer[String]()\n        val baseMap:\
    \ Map[Int, Int] = Map(1 -> \"I\", 5 -> \"V\", 10 -> \"X\", 50 -> \"L\", 100 ->\
    \ \"C\", 500 -> \"D\", 1000 -> \"M\");\n        val digitMap: Map[Int, Int] =\
    \ Map(1 -> 1, 5 -> 5, 10 -> 10, 50 -> 50, 100 -> 100, 500 -> 500, 1000 -> 1000);\n\
    \        while(number > 0) {\n            if(number % 1000 == 0) {\n         \
    \       roman.append(baseMap(number % 100));\n                number /= 1000;\n\
    \                continue;\n            }\n            val remainder = number\
    \ % 10;\n            number /= 10;\n            roman.append(baseMap(remainder));\n\
    \        }\n        roman.toList.sortWith(_.compareTo(\"I\") > 0).mkString(\"\
    _\")", "        if(number < 1000)\n        {\n            val roman: String =\
    \ intToMiniRomanHelper(number)\n            roman.toLowerCase\n        }\n   \
    \     else\n        {\n            val roman: String = intToMiniRomanHelper(number%1000)\n\
    \            roman.toLowerCase\n        }", "        var roman = new collection.mutable.MutableList[String]()\n\
    \        var currentNumber = number\n        while (currentNumber != 0) {\n  \
    \          roman += currentNumber % 10 + roman[roman.length-1]\n            currentNumber\
    \ = currentNumber / 10\n        }\n        return roman.reverse.mkString", " \
    \       var roman = scala.collection.mutable.MutableList[String]()\n        val\
    \ romanNum = number\n        while(romanNum > 0){\n            if(romanNum % 1000\
    \ < 10)roman.append(\"M\")\n            if(romanNum % 1000 <= 10 && romanNum %\
    \ 1000 > 10)roman.append(\"CM\")\n            if(romanNum % 1000 < 10 && romanNum\
    \ % 1000 > 9)roman.append(\"D\")\n            if(romanNum % 1000 <= 10 && romanNum\
    \ % 1000 > 8)roman.append(\"CD\")\n            if(romanNum % 1000 <= 10 && romanNum\
    \ % 1000 > 7)roman.append(\"C\")\n            if(romanNum % 1000 <= 10 && romanNum\
    \ % 1000 > 6)roman.append(\"XC\")\n            if(romanNum % 1000 <= 10 && romanNum\
    \ % 1000 > 5)roman.append(\"L\")\n            if(romanNum % 1000 <= 10 && romanNum\
    \ % 1000 > 4)roman.append(\"XL\")\n            if(romanNum % 1000 <= 10 && romanNum\
    \ % 1000 > 3)roman.append(\"X\")\n            if(romanNum % 1000 <= 10 && romanNum\
    \ % 1000 > 2)roman.append(\"IX\")\n            if(romanNum % 1000 <= 10 && romanNum\
    \ % 1000 > 1)roman.append(\"V\")\n            if(romanNum % 1000 > 0)roman.append(\"\
    IV\")\n            romanNum = romanNum / 1000\n        }\n        roman.reverse.mkString.toLowerCase",
  "        val romans = List(\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"\
    X\",\"IX\",\"V\",\"IV\",\"I\")\n        val index = 0\n        val numerals =\
    \ scala.collection.mutable.ListBuffer.empty[String]\n        while {\n       \
    \     number >= roman => numerals.clear()\n            number >= roman && index\
    \ < romans.length => numerals.append (romans(index))\n            number >= roman\
    \ && index >= romans.length + 1 => numerals.append (romans(romans.length + 1))\n\
    \            number >= roman && index <= romans.length - 1 => numerals.append\
    \ (romans(index))\n            number < roman => numerals.clear()\n          \
    \  number < roman && index < romans.length => numerals.append (romans(index))\n\
    \            number < roman && index >= romans.length + 1 => numerals.append (romans(romans.length\
    \ + 1))\n            number < roman && index <= romans.length - 1 => numerals.append\
    \ (romans(index))\n        }\n        numerals.toList.sortWith(_.compareTo(_)\
    \ < 0).map(_.toString).toLowerCase ", "        // Use a mutable array to store\
    \ each digit of the roman numeral.\n        // Initialize each digit to its correct\
    \ index in the array.\n        // TODO: Consider using a different data structure\
    \ to store each digit in the array.\n        // The array is too small to store\
    \ the longest possible roman numeral, so we need a different one.\n        var\
    \ romanNumeral = new mutable.Array[String](100)\n        var position : Int =\
    \ -1\n\n        // Iterate through the digits.\n        while(number != 0) {\n\
    \            // Set the position of the current digit to its correct index in\
    \ the array.\n            position = number % 10\n\n            // Add the digit\
    \ to the array.\n            romanNumeral += romanDigits(position)\n\n       \
    \     // Divide number by 10 to get its last digit.\n            number /= 10\n\
    \        }\n\n        // Return romanNumeral as a string.\n        romanNumeral.mkString.toLowerCase",
  "        val roman = number.toString.toList\n        val index = roman.indexOf(0)\n\
    \        roman.init\n        while(index != -1) {\n            if(roman(index)\
    \ >= 60 && roman(index) <= 90)\n                roman(index) = roman(index) -\
    \ 55\n            else if(roman(index) >= 90 && roman(index) <= 100)\n       \
    \         roman(index) = roman(index) - 45\n            else if(roman(index) >=\
    \ 100)\n                roman(index) = roman(index) - 40\n            index =\
    \ roman.indexOf(0)\n        }\n        roman.mkString.toLowerCase", "        var\
    \ roman = \"\"\n        var result = 0\n        number match {\n            case\
    \ n if (n > 0) => {\n                val nums = n.toString.toInt\n           \
    \     val numsString = nums.map(n => n.toString).mkString(\"\")\n            \
    \    val rem = nums.last\n                result += rem * Math.pow(10, nums.size\
    \ - 1)\n                while (result >= 1000) {\n                    roman =\
    \ (result / 1000).toString.toInt.toString + roman\n                    result\
    \ %= 1000\n                }\n                result += numsString\n         \
    \       roman = roman.substring(0, roman.length - 1)\n            }\n        \
    \    case _ => {\n                roman = \"\"\n                result = 0\n \
    \           }\n        }\n        result.toString", "        if (number < 1 ||\
    \ number > 1000) {\n            throw new RuntimeException(\"Illegal argument:\
    \ \" + number)\n        }\n        val romans = scala.collection.mutable.ArrayBuffer.empty[String]\n\
    \        for (i <- 1 until number) {\n            val value = number % i\n   \
    \         val roman = if (value >= 10)\n                romans append \"M\"\n\
    \            else romans append if (value < 10)\n                \"C\"\n     \
    \       else value else \"D\"\n            romans append roman\n            number\
    \ /= i\n        }\n        romans.toSeq.toString.toLowerCase", "        val roman\
    \ = mutable.Set(\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"\
    X\", \"IX\", \"V\", \"IV\", \"I\")\n        val factors = scala.math.pow(2, number.toInt).toInt\n\
    \        var sum = 0\n        for (i <- 1 to factors) {\n            sum += roman.iterator.filter(roman.contains((i\
    \ / i.toDouble).toInt)).last\n        }\n        sum.toString", "        val result\
    \ = number match {\n            case 1 => s\"x\"\n            case 2 => s\"l\"\
    \n            case 3 => s\"c\"\n            case 4 => s\"xl\"\n            case\
    \ 5 => s\"xc\"\n            case 6 => s\"xxl\"\n            case 7 => s\"xxxl\"\
    \n            case 9 => s\"xlc\"\n            case 10 => s\"xc\"\n           \
    \ case 12 => s\"lx\"\n            case 14 => s\"lxx\"\n            case 16 =>\
    \ s\"lxxx\"\n            case 21 => s\"xc\"\n            case 22 => s\"x\"\n \
    \           case 23 => s\"xl\"\n            case 24 => s\"l\"\n            case\
    \ 25 => s\"c\"\n            case 26 => s\"xxl\"\n            case 27 => s\"xxxl\"\
    \n            case 28 => s\"xlc\"\n            case 30 => s\"xc\"\n          \
    \  case 31 => s\"x\"\n            case 32 => s\"lx\"\n            case 33 => s\"\
    lxx\"\n            case 34 => s\"lxxx\"\n            case 35 => s\"xc\"\n    \
    \        case 36 => s\"x\"\n            case 37 => s\"xl\"\n            case 38\
    \ => s\"l\"\n            case 39 => s\"c\"\n            case 40 => s\"xxl\"\n\
    \            case 41 => s\"xxxl\"\n            case 42 => s\"xlc\"\n         \
    \   case 50 => s\"xc\"\n            case 51 => s\"x\"\n            case 52 =>\
    \ s\"lx\"\n            case 53 => s\"lxx\"\n            case 54 => s\"lxxx\"\n\
    \            case 55 => s\"xc\"\n            case 56 => s\"x\"\n            case\
    \ 57 => s\"xl\"\n            case 58 => s\"l\"\n            case 59 => s\"c\"\n\
    \            case 60 => s\"xxl\"\n            case 61 => s\"xxxl\"\n         \
    \   case 62 => s\"xlc\"\n            case 70 => s\"xc\"\n            case 71 =>\
    \ s\"x\"\n            case 72 => s\"lx\"\n            case 73 => s\"lxx\"\n  \
    \          case 74 => s\"lxxx\"\n            case 75 => s\"xc\"\n            case\
    \ 76 => s\"x\"\n            case 77 => s\"xl\"\n            case 78 => s\"l\"\n\
    \            case 79 => s\"c\"\n            case 80 => s\"xxl\"\n            case\
    \ 81 => s\"xxxl\"\n            case 82 => s\"xlc\"\n            case 90 => s\"\
    xc\"\n            case 91 => s\"x\"\n            case 92 => s\"lx\"\n        \
    \    case 93 => ", "        val romans = Map( 1  -> \"I\",\n                 \
    \        5  -> \"V\",\n                         10 -> \"X\",\n               \
    \          50 -> \"L\",\n                         100 -> \"C\",\n            \
    \             500 -> \"D\",\n                         1000 -> \"M\")\n       \
    \ val numerals = romans.collect { case (roman, numeral) => numeral.charAt(0) ->\
    \ roman }\n        val romanString = \"\"\n        val remainder = number % 1000;\n\
    \        (1 to 10).foreach { number =>\n            romanString += if (number\
    \ in numerals) numerals(number) else \"\"\n        }\n        romanString += (if\
    \ (remainder >= 5000) romans(remainder) else \"\")\n        romanString.toLower",
  "        val romans = scala.collection.mutable.ListBuffer[String]()\n        var\
    \ i = number\n        while (i >= 1000) {\n            romans += ((i / 1000).map(i\
    \ => String.valueOf(i)).mkString(\"\"))\n            i -= 1000\n        }\n  \
    \      romans += ((i).map(i => String.valueOf(i)).mkString(\"\"))\n        romans.reverse.mkString(\"\
    \")", "        if(number < 1l) throw new IllegalArgumentException(\"Number too\
    \ small: \" + number)\n        val nums = List(\"M\",\"CM\",\"D\",\"CD\",\"C\"\
    ,\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\")\n        var roman = \"\"\
    \n        var lastDigit = 0\n        while(number > 0l) {\n            roman +=\
    \ nums(lastDigit)\n            if(number % 10 == 0) lastDigit += 1\n         \
    \   number /= 10\n        }\n        roman", "        val numberString = number.toString.toString.trim\n\
    \        val roman = scala.collection.mutable.Map[Int, String]()\n        for\
    \ (number <- numberString.split(\"\"))\n            if (number.length == 1)\n\
    \                roman += number -> \"m\" // m\n            else if (number.length\
    \ == 2 && number >= 10)\n                roman += number -> \"c\" // c\n     \
    \       else if (number.length == 3 && number >= 100)\n                roman +=\
    \ number -> \"d\" // d\n            else if (number.length == 3 && number >= 10)\n\
    \                roman += number -> \"x\" // x\n            else if (number.length\
    \ == 4 && number >= 1000)\n                roman += number -> \"l\" // l\n   \
    \         else if (number.length == 5 && number >= 10000)\n                roman\
    \ += number -> \"c\" // c\n            else if (number.length == 6 && number >=\
    \ 100000)\n                roman += number -> \"d\" // d\n            else if\
    \ (number.length == 7 && number >= 1000000)\n                roman += number ->\
    \ \"x\" // x\n            else if (number.length == 8 && number >= 10000000)\n\
    \                roman += number -> \"l\" // l\n            else if (number.length\
    \ == 9 && number >= 1000000000)\n                roman += number -> \"c\" // c\n\
    \            else\n                roman += number -> \"i\" // i\n        val\
    \ min = roman.toList.minBy(_._1)._1\n        val max = roman.toList.maxBy(_._1)._1\n\
    \        roman.toList\n            .filter(number => (number >= min && number\
    \ <= max))\n            .map(x => x._1 + x._2)\n            .mkString(\"\", \"\
    m\", \"c\", \"d\", \"x\", \"l\", \"c\", \"d\")", "        val roman = mutable.Buffer.empty[String]\n\
    \        for(i <- 1 to number){\n            roman.append(romans(i-1) + romans(i%10));\n\
    \        }\n        roman.toString().toLowerCase()", "        if (number <= 1000)\
    \ roman(number);\n        else intToMiniRoman(number/100) + roman(number%100);",
  "        val numStr = (number % 10L).map(\"M\" -> 10, \"D\" -> 5, \"C\" -> 1, \"\
    L\" -> 0, \"X\" -> 10, \"V\" -> 5, \"I\" -> 1).getOrElse(\"\")\n        val result:\
    \ List[String] = for (n <- numStr) yield \"M\" + n.tail\n        (result.map(_.toLowerCase\
    \ + _).mkString(\"\")).capitalize", "        val romanNum = number.toString.map(_.toInt).sorted\n\
    \        val miniRomanNum = mutable.Buffer.empty[String]\n        var count =\
    \ 0\n        for (x <- romanNum) {\n            if (x == 1) {\n              \
    \  miniRomanNum += romanNum(count)\n                count += 1\n            }\
    \ else {\n                miniRomanNum += romanNum(count) + romanNum(count+1).toLowerCase\n\
    \                count += 1\n            }\n        }\n        miniRomanNum.toList.toString.toLowerCase",
  "        val roman = mutable.LinkedHashMap[(Long, Int), (Long, String)]()\n    \
    \    roman.put(1l, roman(number))\n        roman.put(5l, roman(number))\n    \
    \    roman.put(10l, roman(number))\n        roman.put(50l, roman(number))\n  \
    \      roman.put(100l, roman(number))\n        roman.put(500l, roman(number))\n\
    \        roman.put(1000l, roman(number))\n        return roman(number)", "   \
    \     var roman = \"\"\n        var romanDigitCount = 0\n        var base = 0\n\
    \        val firstDigit = number / 100\n        val secondDigit = number % 100\n\
    \        val firstRomanDigits = List(\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\"\
    , \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\")\n        val secondRomanDigits\
    \ = List(\"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"\
    X\", \"XI\", \"XII\")\n        while (romanDigitCount < firstDigit.toInt) {\n\
    \            roman = romanDigits + roman\n            romanDigitCount += 1\n \
    \       }\n        roman = romanDigits + roman\n        romanDigitCount += 1\n\
    \        while (romanDigitCount < secondDigit.toInt) {\n            roman = romanDigits\
    \ + roman\n            romanDigitCount += 1\n        }\n        roman = firstRomanDigits\
    \ + roman\n        romanDigitCount += 2\n        while (romanDigitCount < secondRomanDigits.size)\n\
    \            roman = romanDigits + roman\n            romanDigitCount += 1\n \
    \       base = 100\n        while (romanDigitCount > 0)\n            roman = romanDigits\
    \ + roman\n            romanDigitCount -= 1\n        roman = roman.reverse\n \
    \       if (roman.startsWith(\"M\"))\n            roman = roman.drop(1)\n    \
    \    if (roman.startsWith(\"CM\"))\n            roman = roman.drop(2)\n      \
    \  if (roman.startsWith(\"D\"))\n            roman = roman.drop(2)\n        if\
    \ (roman.startsWith(\"CD\"))\n            roman = roman.drop(3)\n        if (roman.startsWith(\"\
    C\"))\n            roman = roman.drop(3)\n        if (roman.startsWith(\"X\"))\n\
    \            roman = roman.drop(3)\n        if (roman.startsWith(\"XL\"))\n  \
    \          roman = roman.drop(4)\n        if (roman.startsWith(\"L\"))\n     \
    \       roman = roman.drop(4)\n        if (roman.startsWith(\"V\"))\n        \
    \    roman = roman.drop(4)\n        if (roman.startsWith(\"IV\"))\n          \
    \  roman = roman.drop(5)\n        if (roman.startsWith(\"I\"))\n            roman\
    \ = roman.drop(5)\n        if (roman.startsWith(\"I", "        if (number < 1)\
    \ throw new IllegalArgumentException(\"number must be positive\")\n        if\
    \ (number > 1000) throw new IllegalArgumentException(\"number must be <= 1000\"\
    )\n        val miniRoman = mutable.StringBuilder()\n        // The \"i\" suffix\
    \ is used for \"i\".\n        val suffix = \"i\"\n        val romanBase = Array(\
    \ \"M\", \"MM\", \"MMM\",\n                                \"D\", \"DD\", \"DDD\"\
    ,\n                                \"C\", \"CC\", \"CCC\",\n                 \
    \               \"X\", \"XX\", \"XXX\",\n                                \"L\"\
    , \"LL\", \"LLL\",\n                                \"XL\", \"XXL\", \"XXXL\"\
    ,\n                                \"V\", \"VV\", \"VVV\",\n                 \
    \               \"I\", \"II\", \"III\",\n                                \"XC\"\
    , \"XCC\", \"XCCC\",\n                                \"CM\", \"CMC\", \"CMCC\"\
    ,\n                                \"IV\", \"IV\", \"IV\",\n                 \
    \               \"III\", \"III\", \"IIII\",\n                                \"\
    LV\", \"LV\", \"L\",\n                                \"VI\", \"VII\", \"VIII\"\
    ,\n                                \"XII\", \"XIII\", \"XIIII\",\n           \
    \                     \"LX\", \"LXX\", \"LXXX\",\n                           \
    \     \"CX\", \"CXX\", \"CXXX\",\n                                \"CL\", \"CLL\"\
    , \"CLXX\",\n                                \"CLX\", \"CLXX\", \"CLXXX\",\n \
    \                               \"CLE\", \"CLE\", \"CLED\",\n                \
    \                \"CXL\", \"CXLI\", \"CXLII\",\n                             \
    \   \"CLX\", \"CLX\", \"CLXX\",\n                                \"CLXX\", \"\
    CLXX\", \"CLXXX\",\n                                \"CLCX\", \"CLCX\", \"CLCXX\"\
    ,\n                                \"CLXC\", \"CLXCX\", \"CLXCXX\",\n        \
    \                        \"CLXXC\", \"CLXXCX\", \"CLXXCXX\",\n               \
    \                 \"CLXXXC\", \"CLXXXCX\", \"CLXXXCXX\",\n                   \
    \             \"CMC\", \"CMCC\", \"CMCCC\",\n                                \"\
    I\", \"II\", \"III\",\n                                \"III\", \"IIII\", \"IIIII\"\
    ,\n                                \"IV\", \"IV\", \"IV\",\n                 \
    \               \"V\", \"VI\", \"VII\",\n                                \"VII\"\
    , \"VIII\", \"VIIII\",\n                                \"VIII\", \"VIIII\", \"\
    VIIIII\",\n                                \"VIIII\", \"VIIIII\", \"VIIIIII\"\
    ,\n                                \"VIIIII\", \"VIIIIII\", \"VIIIIIII\",\n  \
    \                              \"VIIIIII\", \"VIIIIIII\", \"VIIIIIIII\",\n   \
    \                             \"VIIIIIII\", \"VIIIIIIII\", \"VIIIIIIIII\",\n \
    \                               \"", "        var roman = \"\"\n        for (i:\
    \ Long <- 1 to number) {\n            roman += intToRoman(i)\n        }\n    \
    \    roman.toLowerCase()", "        val roman = scala.collection.mutable.ListBuffer.empty[String]\n\
    \        roman.append(scala.math.pow(10, (number - 1).toInt).toString)\n     \
    \   var i = number - 1\n        while(i > 0){\n            roman.append(roman.last,\
    \ roman.last.length)\n            roman.insert(roman.size - 1, \"M\")\n      \
    \      i -= 1\n        }\n        return roman.mkString", "        val result\
    \ = new mutable.ListBuffer[Char]()\n        var nums = number.toCharArray\n  \
    \      for (i in 0 until nums.length) {\n            val num: Int = nums(i).toInt\n\
    \            val mod = num % 10\n            if (mod <= 3) {\n               \
    \ nums(i) = 'I'\n            } else if (mod == 4) {\n                nums(i) =\
    \ 'V'\n            } else if (mod == 5) {\n                nums(i) = 'X'\n   \
    \         } else {\n                nums(i) = nums(i).toChar\n            }\n\
    \            result += nums(i)\n        }\n        result.toString", "       \
    \ var result = \"m\"\n        // Many ways to solve this problem. Some less elegant,\
    \ some less efficient.\n        // Here are two:\n        for (d <- 1 to number)\
    \ {\n            result += (if (number >= 1000000000L && number <= 1000000L) (\"\
    M\") else \"\")\n            result += (if (number >= 10000L && number < 100000L)\
    \ (\"CM\") else \"\")\n            result += (if (number >= 100L && number < 10L)\
    \ (\"D\") else \"\")\n            result += (if (number >= 10L && number < 100L)\
    \ (\"CD\") else \"\")\n            result += (if (number >= 10L && number < 100L)\
    \ (\"C\") else \"\")\n            result += (if (number >= 10L && number < 100L)\
    \ (\"X\") else \"\")\n            result += (if (number >= 100L && number < 1000L)\
    \ (\"L\") else \"\")\n            result += (if (number >= 1000L && number < 10000L)\
    \ (\"XC\") else \"\")\n            result += (if (number >= 10000L && number <\
    \ 100000L) (\"LX\") else \"\")\n            result += (if (number >= 100000L &&\
    \ number < 1000000L) (\"LXX\") else \"\")\n            result += (if (number >=\
    \ 1000000L && number < 1000000000L) (\"LXXX\") else \"\")\n        }\n       \
    \ return result", "        val romanArray = Array(\"\", \"m\", \"cm\", \"d\",\
    \ \"cd\", \"c\", \"xc\", \"xl\", \"l\", \"ix\", \"iv\", \"x\", \"ix\", \"v\",\
    \ \"iv\")\n        val romanArray2 = Array(\"\", \"d\", \"cd\", \"c\", \"xc\"\
    , \"l\", \"ix\", \"v\", \"iv\")\n        val romanArray3 = Array(\"\", \"l\",\
    \ \"ix\", \"v\", \"iv\")\n        val romanArray4 = Array(\"\")\n        val romanArray5\
    \ = Array(\"\")\n        val romanArray6 = Array(\"\")\n\n        def toRoman(num:\
    \ Long): String = {\n            if (num >= 1000) return romanArray6(roundDown(num\
    \ / (1000 * 1000))) + romanArray5(roundDown(num / (1000 * 100 * 10)))\n      \
    \      if (num >= 900) return romanArray5(roundDown(num / (1000 * 100 * 10)))\
    \ + romanArray4(roundDown(num / (1000 * 100)))\n            if (num >= 500) return\
    \ romanArray4(roundDown(num / (1000 * 100))) + romanArray3(roundDown(num / (1000\
    \ * 10 * 10)))\n            if (num >= 400) return romanArray3(roundDown(num /\
    \ (1000 * 10 * 10))) + romanArray2(roundDown(num / (1000 * 10)))\n           \
    \ if (num >= 100) return romanArray2(roundDown(num / (1000 * 10))) + romanArray1(roundDown(num\
    \ / (1000)))\n            if (num >= 90) return romanArray1(roundDown(num / (1000)))\
    \ + romanArray1(roundDown(num / (1000 * 10)))\n            if (num >= 50) return\
    \ romanArray1(roundDown(num / (1000 * 10))) + romanArray1(roundDown(num / (1000\
    \ * 100 * 10)))\n            if (num >= 40) return romanArray1(roundDown(num /\
    \ (1000 * 100 * 10))) + romanArray1(roundDown(num / (1000 * 100)))\n         \
    \   if (num >= 10) return romanArray1(roundDown(num / (1000 * 100))) + romanArray1(roundDown(num\
    \ / (1000 * 10 * 10)))\n            if (num >= 9) return romanArray1(roundDown(num\
    \ / (1000 * 10 * 10))) + romanArray1(roundDown(num / (1000 * 10)))\n         \
    \   if (num >= 5) return romanArray1(roundDown(num / (1000 * 10))) + romanArray1(roundDown(num\
    \ / (1000 * 100 * 10)))\n            if (num >= 4) return romanArray1(roundDown(num\
    \ / (1000 * 100 * 10))) + romanArray1(roundDown", "        val roman = List[String]()\n\
    \        roman.push(\"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"\
    viii\", \"ix\")\n        roman.push(\"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"\
    lx\")\n        roman.push(\"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\"\
    , \"dccc\", \"cm\")\n        roman.push(\"m\", \"mm\", \"mmm\")\n        roman.foreach(x\
    \ => {\n            val romanNum = number / 1000 * 1000\n            val newNum\
    \ = number % 1000\n            val newRomanNum = romanNum.asInstanceOf[Int]\n\
    \            val numOfDigits = newNum.toString.length\n            val romanDigit\
    \ = roman(newRomanNum)\n            val newDigit = romanDigit + (if (numOfDigits\
    \ > romanDigit.length) 0 else \"\")\n            roman.insert(newRomanNum, newDigit)\n\
    \        })\n        roman.reverse.mkString(\"\")", "        val romanList = mutable.ListBuffer[String]()\n\
    \        for(i <- 0 until number) romanList += i.toString.toLowerCase(Locale.ROOT).romanNumeral\n\
    \        romanList.mkString(\"\")", "      val roman = collection.mutable.ListBuffer[String]()\n\
    \      for (i <- 1 to number) {\n        roman += intToMiniRoman(i)\n      }\n\
    \      roman.mkString", "        // The largest integer you can represent as a\
    \ Roman numeral is 999.\n        // When you're done with the program, don't forget\
    \ to print the final\n        // result!\n        if (number > 999) throw new\
    \ RuntimeException(\"Cannot represent number \" + number + \" as a Roman numeral\"\
    )\n        // You only need to deal with numbers whose first two digits are divisible\
    \ by 3.\n        // All numbers that have a first two digit that isn't divisible\
    \ by 3 are already in Roman numerals.\n        // The remainder of the number\
    \ is divisible by 3, and we know it's between 100 and 900\n        if (number\
    \ % 3 != 0) return \"NOT AN INTEGER GREATER THAN THAT SORTABLY\"\n        // Get\
    \ the last two digits\n        val lastTwoDigits = number % 100\n        // Round\
    \ the value off to remove decimal precision\n        val intValue = number / 100\n\
    \        // Convert each of the three digits to its Roman numeral\n        val\
    \ threeToOne = (\"M\" #-> \"CM\" #-> \"D\" #-> \"CD\" #-> \"C\" #-> \"XC\" #->\
    \ \"L\" #-> \"XL\" #-> \"X\" #-> \"IX\" #-> \"V\" #-> \"IV\" #-> \"I\" #-> \"\
    II\")\n        val intPart = (threeToOne #-> intValue)\n        // Create the\
    \ final string\n        var result = \"\"\n        result ++= intPart.filter{\
    \ case (k,v) => lastTwoDigits % v == 0 }.map{ case (k,v) => k.toString }\n   \
    \     result ++= threeToOne.filter{ case (k,v) => lastTwoDigits % v != 0 }.map{\
    \ case (k,v) => v.toString }\n        result ++= intPart.filter{ case (k,v) =>\
    \ lastTwoDigits % v == 0 }.map{ case (k,v) => v.toString }\n        result", " \
    \       val romanNum = (10000000000000l).min(number).max(1l).toInt\n        var\
    \ num : String = \"\"\n        var index = 0\n        while(romanNum > 0l){\n\
    \            if(romanNum % 10l == 0l){\n                num += romanNum / 10l.toString\
    \ + \"\"\n            }else{\n                num += romanNum % 10l.toString +\
    \ \"\"\n            }\n            romanNum = romanNum / 10l\n            index++\n\
    \        }\n        while(index > 0){\n            num += \"M\"\n            index--\n\
    \        }\n        num.toLowerCase()", "        val roman = mutable.Map[Int,\
    \ String]()\n        val numberString = number.toString\n        val romanNums\
    \ = numberString.split(\"(\\\\d+)\".toList)\n        romanNums match {\n     \
    \       case List(xs) => romanNums.tail.foreach { x =>\n                if (roman.contains(x.toInt))\
    \ {\n                    val oldVal = roman.getOrElse(x.toInt, \"\").asInstanceOf[String]\n\
    \                    val newVal = oldVal + x\n                    roman(x.toInt)\
    \ = newVal\n                }\n                else roman(x.toInt) = x\n     \
    \       }\n            case _ => throw new Exception(\"Invalid input \" + romanNums.mkString(\"\
    [\", \",\", \"]\"))\n        }\n\n        val map = (romanNums zip roman) map\
    \ {\n            case (romanNum, romanNumber) => romanNumber + \"\\\"\" + romanNum\
    \ + \"\\\"\" -> romanNumber\n        }.toMap\n\n        val sortedMap = map.toSeq.sortBy(_._1).map(_._2).toMap\n\
    \n        val romanStrings = sortedMap.map { x => x + \" \" + x }\n\n        val\
    \ romanList = romanStrings.toList.sorted\n        val romanStringsString = romanList.mkString(\"\
    \")\n\n        val romanStringsFinal = romanStringsString.replace(\"x\", \"\"\
    )\n        val romanStringsFinalString = romanStringsFinal.toLowerCase()\n\n \
    \       val result = romanStringsFinalString\n        result", "        var roman\
    \ = mutable.ListBuffer.empty[String]\n        while(number > 0) {\n          \
    \  roman += intToRoman(number%10)\n            number /= 10\n        }\n     \
    \   roman.reverse", "        val numString = number.toString\n        if (numString.length\
    \ <= 0) \"\"\n        else {\n            val max = (math.pow(10, numString.length).toInt)\n\
    \            val vals = mutable.ArrayBuffer.empty[String]\n            for (x\
    \ <- 1 to max) {\n                if (numString % x == 0) {\n                \
    \    val val = numString / x\n                    vals += (val + (if (val == 1)\
    \ \"\" else x)).toString\n                }\n            }\n            vals.mkString(\"\
    \")\n        }", "        val intArr = Array(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16)\n\
    \        val numArr = Array(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127)\n\
    \        val romanArr = Array(\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"\
    VI\", \"VII\", \"VIII\", \"IX\", \"X\", \"XI\", \"XII\", \"XIII\", \"XIV\", \"\
    XV\", \"XVI\", \"XVII\", \"XVIII\", \"XIX\", \"XX\", \"XXI\", \"XXII\", \"XXIII\"\
    , \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\", \"XXVIII\", \"XXIX\", \"XXX\", \"XXXI\"\
    , \"XXXII\", \"XXXIII\", \"XXXIV\", \"XXXV\", \"XXXVI\", \"XXXVII\", \"XXXVIII\"\
    , \"XXXIX\")\n        def intToRoman(num: Long) = {\n            def numToInt(num:\
    \ Long): Int = {\n                if (num > 1000 || num < 1) throw new IllegalArgumentException\n\
    \                num.toInt % 100\n            }\n            val sum: Long = intArr.foldLeft(num)\
    \ { (x, y) => x + y }\n            (romanArr(numToInt(sum - number) - 1) + romanArr(numToInt(number))).toLowerCase\n\
    \        }\n        if (number > 1000 || number < 1) throw new IllegalArgumentException\n\
    \        intToRoman(number).replaceAll(\"M\", \"MM\")", "        val romans =\
    \ List(\n            List(\"I\", \"V\", \"X\", \"L\"),\n            List(\"XII\"\
    , \"VII\", \"XIII\", \"IX\"),\n            List(\"LXXXII\", \"LXXXIII\", \"LXXXIV\"\
    , \"LXXXV\", \"LXXXVI\", \"LXXXVII\", \"LXXXIX\"),\n            List(\"M\", \"\
    CM\", \"D\", \"CD\", \"C\"),\n            List(\"M\", \"D\", \"CD\", \"C\"),\n\
    \            List(\"MMM\", \"MMM\", \"MMMM\", \"MMMMM\"),\n            List(\"\
    MMMMMM\", \"MMMMMM\", \"MMMMMMM\", \"MMMMMMMM\", \"MMMMMMMMM\"),\n           \
    \ List(\"MMMMMMMMM\", \"MMMMMMMMMM\", \"MMMMMMMMMMM\", \"MMMMMMMMMMMM\", \"MMMMMMMMMMMMM\"\
    ),\n            List(\"X\", \"XL\", \"L\", \"XC\", \"C\", \"CD\", \"C\", \"XC\"\
    , \"C\", \"XL\", \"L\"),\n            List(\"X\", \"XL\", \"L\", \"XC\", \"C\"\
    , \"CD\", \"C\", \"XC\", \"C\", \"XL\", \"L\"),\n            List(\"X\", \"XL\"\
    , \"L\", \"XC\", \"C\", \"CD\", \"C\", \"XC\", \"C\", \"XL\", \"L\"),\n      \
    \      List(\"X\", \"XL\", \"L\", \"XC\", \"C\", \"CD\", \"C\", \"XC\", \"C\"\
    , \"XL\", \"L\"),\n            List(\"X\", \"XL\", \"L\", \"XC\", \"C\", \"CD\"\
    , \"C\", \"XC\", \"C\", \"XL\", \"L\"),\n            List(\"I\", \"IV\", \"III\"\
    , \"II\", \"I\"),\n            List(\"IV\", \"III\", \"II\", \"I\"),\n       \
    \     List(\"V\", \"VII\", \"VIII\", \"IX\"),\n            List(\"VIII\", \"VII\"\
    , \"VIII\", \"X\"),\n            List(\"IX\", \"VIII\", \"VIII\", \"X\"),\n  \
    \          List(\"X\", \"XX\", \"XXI\", \"XXII\", \"XXIII\", \"XXIV\", \"XXV\"\
    , \"XXVI\", \"XXVII\", \"XXVIII\", \"XXIX\"),\n            List(\"XX\", \"XXI\"\
    , \"XXII\", \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\", \"XXVIII\", \"\
    XXIX\"),\n            List(\"X\", \"XX\", \"XXI\", \"XXII\", \"XXIII\", \"XXIV\"\
    , \"XXV\", \"XXVI\", \"XXVII\", \"XXVIII\", \"XXIX\"),\n            List(\"XX\"\
    , \"XXI\", \"XXII\", \"XXIII\", \"XXIV\", \"XXV\", \"XXVI", "        var i = 0\n\
    \        var romanNumberString = \"\"\n        var isLast = false\n        while(number\
    \ > 0){\n            romanNumberString += romanNumeral(i++).toLowerCase\n    \
    \        number -= romanNumeral(i).romanDigitValue\n            isLast = i ==\
    \ romanNumeral.size\n        }\n        if (isLast)\n            romanNumberString\
    \ += romanNumeral(i).toLowerCase\n        return romanNumberString", "       \
    \ val romanList = List(\n            List(\"M\", \"MM\", \"MMM\", \"MMMM\", \"\
    MMMMM\"),\n            List(\"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\"),\n\
    \            List(\"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\"),\n          \
    \  List(\"V\", \"VV\", \"VVV\", \"IV\", \"I\", \"II\"),\n            List(\"I\"\
    ),\n            List(\"N\", \"NN\", \"NNN\", \"NNNN\")\n        )\n        val\
    \ roman = romanList.find( x => x.forall(_.contains(number.toString)) ).get\n \
    \       val integer = number.toInt\n        val romanString = (roman.head + roman.drop(1)).mkString(\"\
    \")\n        val romanStringWithN = (romanString.replaceFirst(\"N\", \"M\") +\
    \ roman.drop(1).mkString(\"\"))\n        val romanStringWith0 = romanStringWithN.replaceAll(\"\
    0\", \"\")\n        val romanStringWithI = romanStringWith0.replaceFirst(\"I\"\
    , \"V\")\n        val romanStringWithII = romanStringWithI.replaceFirst(\"II\"\
    , \"VII\")\n        val romanStringWithIII = romanStringWithII.replaceFirst(\"\
    III\", \"VIII\")\n        romanStringWithIII.replaceFirst(\"IIII\", \"IX\").replaceFirst(\"\
    IV\", \"X\")", "        def isDivisible : Int => Boolean = {\n            val\
    \ remainder = number % 10\n            val isDivisible = remainder == 0\n    \
    \        if (isDivisible) {\n                number / 10\n            } else {\n\
    \                false\n            }\n        }\n\n        // Add zeros until\
    \ number is evenly divisible\n        def addZero : Int => Int = {\n         \
    \   var i = number\n            while (isDivisible(i)) {\n                i /=\
    \ 10\n            }\n            i\n        }\n\n        // Add ones to number\n\
    \        def addOnes : Int => Int = {\n            var i = number\n          \
    \  while (!isDivisible(i)) {\n                i = i * 10 + 1\n            }\n\
    \            i\n        }\n\n        def addOnesOrZeros : Int => Int = {\n   \
    \         var i = number\n            while (!isDivisible(i)) {\n            \
    \    i = i * 10 + 1\n                i /= 10\n            }\n            i\n \
    \       }\n\n        // Remove one from number\n        def removeOne : Int =>\
    \ Int = {\n            var i = number\n            while (isDivisible(i)) {\n\
    \                i /= 10\n            }\n            i\n        }\n\n        def\
    \ getMiniRoman(i : Int) : String = {\n            val n1 = addOnesOrZeros(i)\n\
    \            val n2 = addOnes(n1)\n            val n3 = addOnes(n2)\n        \
    \    val n4 = addOnes(n3)\n            val n5 = addOnes(n4)\n            val n6\
    \ = addOnes(n5)\n            val n7 = removeOne(n6)\n            val n8 = removeOne(n7)\n\
    \            val n9 = removeOne(n8)\n            val n10 = addOnes(n9)\n     \
    \       val n11 = addOnes(n10)\n            val n12 = removeOne(n11)\n       \
    \     val n13 = removeOne(n12)\n            val n14 = addOnes(n13)\n         \
    \   val n15 = addOnes(n14)\n            val n16 = removeOne(n15)\n           \
    \ val n17 = removeOne(n16)\n            val n18 = addOnes(n17)\n            val\
    \ n19 = addOnes(n18)\n            val n20 = addOnes(n19)\n            val n21\
    \ = removeOne(n20)\n            val n22 = removeOne(n21)\n            val n23\
    \ = addOnes(n22)\n            val n24 = addOnes(n23)\n            val n25 = removeOne(n24)\n\
    \            val n26 = removeOne(n25)\n            val n27 = addOnes(n26)\n  \
    \          val n", "      val romans    = new mutable.TreeMap[Int, String]()\n\
    \      val thousands = \"M\"\n      val millions  = \"CM\"\n      val hundreds\
    \  = \"D\"\n      val thousandss = \"M\"\n      val millionss = \"CM\"\n     \
    \ val hundredss = \"D\"\n      val tens      = \"CD\"\n      val ones      = \"\
    C\"\n      val tenss = \"CD\"\n      val oness = \"C\"\n      var currentRoman\
    \ = \"\"\n      var currentNumber = 0\n      while(number > 0) {\n        currentNumber\
    \ += 1\n        val romanInt = number % 1000\n        if(romanInt > 0) {\n   \
    \       currentRoman = romans.get romanInt\n          if(currentRoman == null)\
    \ {\n            romans.put(romanInt, ones + currentNumber)\n          }\n   \
    \       number -= romanInt\n        }\n        if(number % 1000 < 100) {\n   \
    \       currentRoman = romans.get number % 1000\n          number -= number %\
    \ 1000\n          if(currentRoman == null) {\n            romans.put(number %\
    \ 1000, ones + number / 1000)\n          }\n        }\n        if(number % 100\
    \ < 10) {\n          currentRoman = romans.get number % 100\n          number\
    \ -= number % 100\n          if(currentRoman == null) {\n            romans.put(number\
    \ % 100, ones + number / 100)\n          }\n        }\n        if(number % 10\
    \ < 1) {\n          currentRoman = romans.get number % 10\n          number -=\
    \ number % 10\n          if(currentRoman == null) {\n            romans.put(number\
    \ % 10, ones + number / 10)\n          }\n        }\n      }\n      romans.values.toList.reverse.mkString",
  "        // Initialize result to empty string\n        var result : String = \"\"\
    \n        // Iterate from right to left (towards minus number) and append a letter\n\
    \        // as long as the number is divisible by 3\n        for(i <- number;\
    \ number >= 3; i -= 3) {\n            result += (number % 3).toChar\n        \
    \    number /= 3\n        }\n        // Append the rest in reverse order\n   \
    \     result ++= number.toCharArray.takeWhile(_ < '3').reverse\n        return\
    \ result", "        val digits = BigDecimal(number).toBigDecimal.toString().split('')\n\
    \        val romanNum = BigInteger.valueOf(number.toInt).divide(BigInteger.valueOf(1000))\n\
    \        val miniRoman = \"\"\n        for (digit <- digits) {\n            val\
    \ number = romanNum.multiply(BigInteger.valueOf(10)).add(BigInteger.valueOf(digit))\n\
    \            val num = number.divide(BigInteger.valueOf(1000))\n            miniRoman\
    \ = miniRoman+(if (num.equals(BigInteger.ZERO)) \"M\" else if (num.equals(BigInteger.ONE))\
    \ \"D\" else if (num.equals(BigInteger.TEN)) \"CM\" else if (num.equals(BigInteger.FIFTY))\
    \ \"CD\" else if (num.equals(BigInteger.THIRTY)) \"XC\" else num.toString())\n\
    \        }\n        return miniRoman", "        val result: List[String] = for\
    \ {\n            i  <- number /  100\n            r <- RomanDigits(i)\n      \
    \  } yield {\n            val rr = r.mkString\n            val rs = r.mkString.reverse\n\
    \            rr + rs + RomanDigits(number - i * 100)\n        }\n        result.minBy(_.length)",
  "        val romanNum: mutable.Queue[String] = mutable.Queue(\"\")\n        val\
    \ numDigit = number.toString().length\n        var i = numDigit - 1\n        while\
    \ (i >= 0) {\n            romanNum.enqueue(number.toString(i))\n            i\
    \ -= 1\n        }\n        val romanNumReverse: mutable.Queue[String] = mutable.Queue(\"\
    \")\n        romanNum.dequeueAll()(romanNumReverse)\n        val stringReverse\
    \ = romanNumReverse.reverse().mkString\n        for (item <- stringReverse) {\n\
    \            romanNum.enqueue(item)\n        }\n        val romanNumAsString =\
    \ romanNum.reverse().mkString(\"\")\n        val romanNumAsStringUpper = romanNumAsString.toUpperCase()\n\
    \        val miniRomanNumAsString = romanNumAsStringUpper.dropRight(1)\n     \
    \   return miniRomanNumAsString", "        var remainder = number\n        var\
    \ result = \"\"\n        while (remainder > 0) {\n            remainder -= 1\n\
    \            if (remainder >= 1000) {\n                result += convert(remainder\
    \ / 1000) + \"k\"\n                remainder %= 1000\n            }\n        \
    \    result += convert(remainder)\n        }\n        result", "        def intToRoman(number\
    \ : Int) : String = { \n            if (number > 999) {\n                return\
    \ \"999\"\n            }\n            val romans = (100 to 400 by 10)\n      \
    \      var result: String = \"\"\n            var remaining: Int = number\n  \
    \          romans.foreach(r => remaining -= r)\n            while (remaining >=\
    \ 10) {\n                result += romans(remaining % 10) + \"\"\n           \
    \     remaining /= 10\n            }\n            result += romans(remaining +\
    \ \"\")\n            result \n        }\n\n        if (number <= 0) {\n      \
    \      throw new RuntimeException(\"Number cannot be <= 0\")\n        }\n    \
    \    if (number >= 1000) {\n            throw new RuntimeException(\"Number cannot\
    \ be >= 1000\")\n        }\n        val numeral = (0 to number by 10).map(i =>\
    \ intToRoman(i))\n        (numeral ++ numeral.drop(1)).mkString", "        var\
    \ roman = \"M\"\n        var digits = \"\"\n        var currentNumber = 0l\n \
    \       while (currentNumber < number) {\n            currentNumber = number /\
    \ 100l\n            digits = digits() + roman\n            roman = roman(\"x\"\
    )\n            roman = roman(\"v\")\n            roman = roman(\"l\")\n      \
    \      roman = roman(\"c\")\n            roman = roman(\"d\")\n            roman\
    \ = roman(\"m\")\n            number = number % 100\n        }\n        roman\
    \ = roman(digits)\n        roman = roman.charAt(0).toLower\n        return roman",
  "        val nums = Map(\"I\" -> 1, \"V\" -> 5, \"X\" -> 10, \"L\" -> 50, \"C\"\
    \ -> 100, \"D\" -> 500, \"M\" -> 1000)\n        val s = nums.get(number.toInt)\
    \ match {\n            case Some(number) => s\"${number}\"\n            case None\
    \          => \"none\"\n        }\n        s + \"_\"", "        def roman(number\
    \ : Long): String = {\n            def gt(n : Long, n1 : Long, n2 : Long): Boolean\
    \ = {\n                if(n>n1 && n>n2) true else false\n            }\n     \
    \       def roman(m : Int, n1 :Long, n2 : Long): String = {\n                val\
    \ res = \"\"\n                val c = m - n1\n                if(c>=0) res +=\
    \ roman(c, n1, n2)\n                if(c<0) res += roman(-c, n1, n2)\n       \
    \         res\n            }\n            val x = number%100\n            val\
    \ y = number%10\n            if(y>2) roman(y,x,100) ++ roman(y-1, x-1,10)\n  \
    \          else roman(x,100,10)\n        }\n        val n = number\n        val\
    \ i = Math.floor(n/100l)\n        val m = n%100l\n        val r = roman(i, 100,\
    \ 10)\n        val o = roman(i, 10, 10)\n        if(m==100 && r==o) r\n      \
    \  else r+o", "        // write your code\n        return \"\"", "        // Create\
    \ a list of characters that will be used as the roman numerals.\n        val numerals\
    \ = List.tabulate(8)(_ => \"M\")\n        // Add the letters for the corresponding\
    \ numbers.\n        numerals(number % 100l) :: numerals(number % 100l / 10l) ::\
    \ numerals(number / 10l) :: numerals(number % 10l) :: List.empty", "        var\
    \ roman : String = \"\"\n        var i = 2\n        while(i < (number / 1000)){\n\
    \            roman += (100 * i) + \"-\" + i\n            i = i + 1\n        }\n\
    \        roman += ((number % 1000) * i)\n        roman = roman.substring(0, roman.length\
    \ - 1)\n        return roman", "        if (number < 1 || number > 1000) throw\
    \ new IllegalArgumentException(\"invalid argument\")\n        val romanList =\
    \ List(\"M\", \"D\", \"C\", \"L\", \"X\", \"V\", \"I\")\n        val res = romanList.foldLeft(\"\
    X\")((acc, val) => if (val <= number) acc + val + 1 else \"X\")\n        res",
  "        val roman = mutable.Queue[String]()\n        for (i <- 1 to number) {\n\
    \            val romanNum = numberToRoman(i)\n            roman.addFirst(romanNum)\n\
    \        }\n        roman.pollFirst().toLowerCase + (roman.pollFirst() match {\n\
    \            case \"\" => \"\"\n            case s => s\n        })", "      \
    \  var results = new Array[String](1000);\n        var numeral = number % 1000;\n\
    \        var divisor = number / 1000;\n        var last = 0;\n        var length\
    \ : Int = 0;\n        while (divisor > 0) {\n            divisor = divisor / 10;\n\
    \            last = last + 1;\n        }\n        results(last) = \"M\"\n    \
    \    divisor = number / 1000;\n        while (divisor > 0) {\n            divisor\
    \ = divisor / 10;\n            last = last + 1;\n        }\n        results(last)\
    \ = \"CM\"\n        divisor = number / 1000;\n        while (divisor > 0) {\n\
    \            divisor = divisor / 10;\n            last = last + 1;\n        }\n\
    \        results(last) = \"D\"\n        divisor = number / 1000;\n        while\
    \ (divisor > 0) {\n            divisor = divisor / 10;\n            last = last\
    \ + 1;\n        }\n        results(last) = \"CD\"\n        divisor = number /\
    \ 1000;\n        while (divisor > 0) {\n            divisor = divisor / 10;\n\
    \            last = last + 1;\n        }\n        results(last) = \"C\"\n    \
    \    divisor = number / 1000;\n        while (divisor > 0) {\n            divisor\
    \ = divisor / 10;\n            last = last + 1;\n        }\n        results(last)\
    \ = \"XC\"\n        divisor = number / 1000;\n        while (divisor > 0) {\n\
    \            divisor = divisor / 10;\n            last = last + 1;\n        }\n\
    \        results(last) = \"L\"\n        divisor = number / 1000;\n        while\
    \ (divisor > 0) {\n            divisor = divisor / 10;\n            last = last\
    \ + 1;\n        }\n        results(last) = \"XL\"\n        divisor = number /\
    \ 1000;\n        while (divisor > 0) {\n            divisor = divisor / 10;\n\
    \            last = last + 1;\n        }\n        results(last) = \"X\"\n    \
    \    divisor = number / 1000;\n        while (divisor > 0) {\n            divisor\
    \ = divisor / 10;\n            last = last + 1;\n        }\n        results(last)\
    \ = \"IX\"\n        divisor = number / 1000;\n        while (divisor > 0) {\n\
    \            divisor = divisor / 10;\n            last = last + 1;\n        }\n\
    \        results(last) = \"V\"\n        divisor = number / 1000;\n        while\
    \ (divisor > 0) {\n            divisor = divisor / 10;\n            last = last\
    \ + 1;\n        }\n        results(last) = \"IV\"\n        divisor = number /\
    \ 1000;\n        while (divisor > 0) {\n            divisor = divisor / 10;\n\
    \            last = last + 1;\n        }\n        results(last) = \"I\"\n    \
    \    divisor = ", "        def romanToInt(roman: String, i: Int, count: Int) :\
    \ Int = {\n            if (roman == \"\") count\n            else {\n        \
    \        if (roman == \"I\" && i == 0) i\n                else {\n           \
    \         if (roman == \"V\" && i == 1) i + 1\n                    else if (roman\
    \ == \"X\" && i == 2) i + 3\n                    else romanToInt(roman.dropRight(i),\
    \ i - 1, count + 1)\n                }\n            }\n        }\n        def\
    \ digitToInt(digit: Int) : Int = digit\n        val zero = 0\n        var roman\
    \ = \"\"\n        var remaining = number\n        while(number.isEven) {\n   \
    \         remaining = remaining.dropRight(1)\n            roman = \"M\" + roman\n\
    \        }\n        while(remaining.isEven) {\n            remaining = remaining.dropRight(1)\n\
    \            roman = roman + \"C\"\n        }\n        remaining = (remaining\
    \ - zero) * 10 + zero\n        var i = zero\n        while(roman.length > 0) {\n\
    \            i = romanToInt(roman, i, 0)\n            roman = roman.dropRight(1)\n\
    \        }\n        roman = roman.toString\n        var i = zero\n        var\
    \ romanNumber = 0\n        while(i < roman.length) {\n            romanNumber\
    \ += digitToInt(roman(i))\n            i = i + 1\n        }\n        roman = roman.dropRight(1)\n\
    \        (romanNumber toString) toLowerCase", "        if(number > 1000 || number\
    \ <= 0) {\n            throw new IllegalArgumentException(\"Invalid Arguments\"\
    )\n        }\n        var result = \"\"\n        var base = 1\n        var digits\
    \ = \"\"\n        var rem = 0\n        // Loop to obtain the last remainder\n\
    \        while(number >= base)\n        {\n            rem = number % base\n \
    \           number = number / base\n            digits = digits + rem\n      \
    \  }\n        if(digits == \"\") {\n            digits = \"0\"\n        }\n  \
    \      // Loop to obtain the final roman\n        for(i <- 0 until digits.length)\
    \ {\n            val remainder = digits.charAt(i) - '0'\n            val output\
    \ = rem * base\n            val newOutput = output + remainder\n            result\
    \ += Integer.toString(newOutput)\n            base *= 10\n        }\n        result.toLowerCase",
  "        val stringToReturn = string.empty\n        val firstTen = number % 10\n\
    \        if (firstTen < 3) {\n            stringToReturn += firstTen.toString\n\
    \        } else if (firstTen < 6) {\n            stringToReturn += \"v\"\n   \
    \     } else if (firstTen < 9) {\n            stringToReturn += \"vi\"\n     \
    \   } else if (firstTen < 12) {\n            stringToReturn += \"i\"\n       \
    \ } else if (firstTen < 15) {\n            stringToReturn += \"x\"\n        }\
    \ else if (firstTen < 17) {\n            stringToReturn += \"l\"\n        } else\
    \ if (firstTen < 20) {\n            stringToReturn += \"c\"\n        } else if\
    \ (firstTen < 24) {\n            stringToReturn += \"d\"\n        } else if (firstTen\
    \ < 27) {\n            stringToReturn += \"h\"\n        } else if (firstTen <\
    \ 30) {\n            stringToReturn += \"m\"\n        } else {\n            stringToReturn\
    \ += \"n\"\n        }\n        val tenToFifteen = number % 100\n        if (tenToFifteen\
    \ < 50) {\n            stringToReturn += \"l\"\n        } else if (tenToFifteen\
    \ < 90) {\n            stringToReturn += \"c\"\n        } else if (tenToFifteen\
    \ < 140) {\n            stringToReturn += \"d\"\n        } else if (tenToFifteen\
    \ < 190) {\n            stringToReturn += \"h\"\n        } else if (tenToFifteen\
    \ < 240) {\n            stringToReturn += \"m\"\n        } else {\n          \
    \  stringToReturn += \"n\"\n        }\n        val fifty = number % 1000\n   \
    \     if (fifty < 500) {\n            stringToReturn += \"l\"\n        } else\
    \ if (fifty < 1000) {\n            stringToReturn += \"c\"\n        } else if\
    \ (fifty < 2000) {\n            stringToReturn += \"d\"\n        } else if (fifty\
    \ < 3000) {\n            stringToReturn += \"h\"\n        } else if (fifty < 4000)\
    \ {\n            stringToReturn += \"m\"\n        } else {\n            stringToReturn\
    \ += \"n\"\n        }\n        stringToReturn", "        val romanTable = scala.collection.mutable.Map[Int,\
    \ String]()\n        romanTable += (0l -> \"i\")\n        romanTable += (1l ->\
    \ \"ii\")\n        romanTable += (3l -> \"iii\")\n        romanTable += (4l ->\
    \ \"iv\")\n        romanTable += (5l -> \"v\")\n        romanTable += (6l -> \"\
    vi\")\n        romanTable += (9l -> \"vii\")\n        romanTable += (10l -> \"\
    viii\")\n        romanTable += (40l -> \"ix\")\n        romanTable += (50l ->\
    \ \"x\")\n        romanTable += (90l -> \"xix\")\n        romanTable += (100l\
    \ -> \"xix\")\n\n        var result : String = \"\"\n        var tempString :\
    \ String = \"\"\n\n        number match {\n            case 1l | 9l => return\
    \ romanTable(number).asInstanceOf[String]\n            case other => {\n     \
    \           val value = romanTable(number)\n                tempString = value.substring(0,\
    \ value.length-1)\n                result = tempString + romanTable(other).asInstanceOf[String]\n\
    \            }\n        }\n        result.toLower", "        val numStr = number.toString.substring(1,number.toString)\n\
    \        val numDigit = numStr.length\n        val roman = numStr.groupBy(_ ==\
    \ 'M').mapValues(_.size)\n                .filter(_._2 > 1).map(_._1).reverse\n\
    \        val romStr = \"\"\n        var i = 0\n        var j = 0\n        while(i\
    \ < numDigit) {\n            j += 1\n            val r = roman(j)\n          \
    \  val c = numStr(i).toLowerCase\n            if (r > 0) romStr += c + roman(j-1)\
    \ + \" \"\n            i += r\n        }\n        val ret = romStr.trim\n    \
    \    ret = ret.substring(0, ret.length - 1)\n        return ret", "        val\
    \ n = number.toInt\n        val roman = mutable.MutableList[String]()\n      \
    \  val romanNums = List[Long](0, 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9,\
    \ 5, 4, 1)\n        for (romanNum <- romanNums) {\n            if (romanNum <=\
    \ n) roman.append(romanNum.toString)\n            else\n                roman.append(romanNum.toString.substring(0,\
    \ romanNum - n))\n        }\n        roman.reverse.mkString", "        def intToRoman(num:\
    \ Int) : String = {\n            val result: StringBuilder = new StringBuilder();\n\
    \            if (num == 0) result.append(\"0\");\n            else while (num\
    \ > 0) {\n                val roman: String = num % 1000;\n                num\
    \ /= 1000;\n                result.append(roman);\n            }\n           \
    \ val numRoman: String = result.toString;\n            val int: Int = numRoman.toInt;\n\
    \            val str: String = (int + \"\").toLowerCase();\n            str\n\
    \        }\n        val str: String = (number + \"\").toLowerCase;\n        val\
    \ numberList: Seq[Long] = str.split('');\n        val numRoman: Seq[String] =\
    \ numberList.map { intToRoman(_) };\n        numRoman.mkString.trim", "      \
    \  // Convert int to an array of chars\n        val chars = number.toCharArray\n\
    \        // Make chars mutable (by creating a mutable list\n        val charList\
    \ = chars map (_ -> 1) toList\n        // Loop through the array of chars, adding\
    \ one to each value\n        charList.foreach { case (count, value) =>\n     \
    \       if (count == 1)\n                chars(value) = chars(value) + 1\n   \
    \     }\n        // Return the string with one char per line\n        chars.toList.map(_.toLower).mkString(\"\
    \")", "        var roman = \"\"\n        var max = 0\n        while (number >\
    \ 0) {\n            if (number > max) {\n                max = number\n      \
    \          roman = roman + romanLetters(number)\n            } else {\n      \
    \          if (number % 10 > 5) {\n                    roman = roman + romanLetters(number\
    \ / 10) + romanLetters(number % 10)\n                } else {\n              \
    \      roman = roman + romanLetters(number / 10) + romanLetters(number % 10) +\
    \ romanLetters(5)\n                }\n            }\n            number = number\
    \ / 10\n        }\n        return roman", "        if (number == 0) {\n      \
    \      return \"\"\n        }\n        var roman = \"\"\n        var remainder\
    \ = number\n        var i = 0\n        while (remainder >= 1000) {\n         \
    \   remainder -= 1000\n            roman += romanToChar(1000)\n        }\n   \
    \     while (remainder >= 100) {\n            remainder -= 100\n            roman\
    \ += romanToChar(100)\n        }\n        while (remainder >= 10) {\n        \
    \    remainder -= 10\n            roman += romanToChar(10)\n        }\n      \
    \  roman += romanToChar(remainder)\n        return roman", "        val romanNum\
    \ = number map {\n            case i if i <= 1000 => (100 * (i - 1)) + i\n   \
    \         case i if i > 1000 => (i - 100) * 100 + 100\n            case _ => 0\n\
    \        }\n        romanNum collect {\n            case i if i > 0 => (i / 1000).romanNum\
    \ ++ romanNum(i % 1000)\n        }.mkString", "        val roman = Array.ofDim[String](1000)\n\
    \        var index = 0\n        for(i <- 0 until roman.length){\n            roman(i)\
    \ = \"\"\n        }\n        index = 1000\n        var i = 0\n        var j =\
    \ 0\n        while(number > 0){\n            roman(i) = roman(i-1)+(number/pow(10,j).toDouble).toChar\n\
    \            number %= pow(10,j).toDouble\n            i = i + 1\n           \
    \ j = j + 1\n        }\n        for(i <- roman.indices) {\n            if(i !=\
    \ roman.size - 1) {\n                roman(i) = \"\"\n            }\n        }\n\
    \        roman.map(_.replaceAll(\"(?i)^(\\\\d)\", \"I$1\"))", "        val bigDecimal\
    \ = BigDecimal(number.toString.toInt)\n        var str = \"\"\n        for (i\
    \ <- 0 until bigDecimal.precision) {\n            val a = bigDecimal.intValue()\
    \ % 10\n            val b = bigDecimal.intValue() / 10\n            str +=  if\
    \ (a > 1) romanNumMap(a-1) else romanNumMap(a) //(a - 1) because we want to display\
    \ number before the digit\n            str += if (b > 0) romanNumMap(b) else \"\
    \"\n        }\n        str", "        val lookup = mutable.HashMap[Long, String]()\n\
    \        def addLookup(number : Long, roman : String) : Unit = {\n           \
    \ if (lookup.contains(number)) {\n                lookup(number) = roman\n   \
    \         } else {\n                val string = \"mnop\"\n                for\
    \ (i <- 0 until string.length) {\n                    addLookup(number * 1000\
    \ + string.charAt(i), roman)\n                }\n                lookup.put(number,\
    \ roman)\n            }\n        }\n        addLookup(number, \"\")", "      \
    \  var result = \"\"\n        var value = 1l\n        while (number >= value)\
    \ {\n            val temp = Math.round(number / value)\n            result = result\
    \ + romanDigit(temp) + romanDigit(number % temp).lower()\n            value =\
    \ value * 10\n        }\n        result", "        if (number == 0) \"0\"\n  \
    \      else if (number == 1) \"i\"\n        else if (number == 2) \"ii\"\n   \
    \     else if (number == 3) {\n            var temp = number.toString.toLower\n\
    \            var result = \"v\"\n            var roman = \"\"\n            var\
    \ current = 0\n            var next = 1\n            var prev = 1\n          \
    \  while (next <= temp.length) {\n                prev = current\n           \
    \     current = next\n                next = prev + next\n                roman\
    \ = (roman.substring(0, roman.length - 1) + roman.substring(prev + 1, next) +\
    \ roman.substring(current + 1))\n            }\n            result = roman\n \
    \       }\n        else if (number < 3999) {\n            var temp = number.toString.toLower\n\
    \            var result = \"m\"\n            var roman = \"\"\n            var\
    \ current = 0\n            var next = 1\n            var prev = 1\n          \
    \  while (next <= temp.length) {\n                prev = current\n           \
    \     current = next\n                next = prev + next\n                roman\
    \ = (roman.substring(0, roman.length - 1) + roman.substring(prev + 1, next) +\
    \ roman.substring(current + 1))\n            }\n            result = roman\n \
    \       }\n        else if (number < 79999) {\n            var temp = number.toString.toLower\n\
    \            var result = \"c\"\n            var roman = \"\"\n            var\
    \ current = 0\n            var next = 1\n            var prev = 1\n          \
    \  while (next <= temp.length) {\n                prev = current\n           \
    \     current = next\n                next = prev + next\n                roman\
    \ = (roman.substring(0, roman.length - 1) + roman.substring(prev + 1, next) +\
    \ roman.substring(current + 1))\n            }\n            result = roman\n \
    \       }\n        else if (number < 3999000l) {\n            var temp = number.toString.toLower\n\
    \            var result = \"d\"\n            var roman = \"\"\n            var\
    \ current = 0\n            var next = 1\n            var prev = 1\n          \
    \  while (next <= temp.length) {\n                prev = current\n           \
    \     current = next\n                next = prev + next\n                roman\
    \ = (roman.substring(0, roman.length - 1) + roman.substring(prev + 1, next) +\
    \ roman.substring(current + 1))\n            }\n            result = roman\n \
    \       }\n        else if (number < 79999999l) {\n            var temp = number.toString.toLower\n\
    \            var result = \"f\"\n            var roman = \"\"\n            var\
    \ current = 0\n            var next = 1\n            var prev = 1\n          \
    \  while (next <= temp.length) {\n                prev = current\n           \
    \     current = next\n                next = prev + next\n                roman\
    \ = (roman.substring(0, roman.length - 1) + roman.substring(prev + 1, next) +\
    \ roman.substring(current + 1))\n            }\n            result = roman\n \
    \       }\n        else if (number < 99999999l) {\n            var temp = number.toString.toLower\n\
    \            var ", "        var output : String = \"\"\n        val roman = List(\"\
    M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"\
    I\")\n        var lastLetter = \"\"\n        for (number <- 0 to roman.length-1)\
    \ {\n            val value = number % roman.length\n            lastLetter = roman(value)\n\
    \            number -= value\n            output += lastLetter\n        }\n  \
    \      output.toLower", "        var result = \"\"\n        var hundredsPlace\
    \ = number / 1000\n        var remainder = number % 1000\n        var thousandsPlace\
    \ = remainder / 1000\n        remainder = remainder % 1000\n        var tensPlace\
    \ = remainder / 100\n        remainder = remainder % 100\n        var unitsPlace\
    \ = remainder / 10\n        remainder = remainder % 10\n        val tensNum =\
    \ List(\"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"dx\"\
    , \"xc\", \"xcc\", \"xccc\", \"xx\", \"xdxx\", \"xdccx\",\n                \"\
    xdccr\", \"xdcr\", \"xdcc\", \"xdccc\", \"xdccr\", \"xdcr\", \"xdcc\", \"xdccc\"\
    , \"xdcr\", \"xdcr\", \"xdcc\", \"xdccc\")\n        val unitsNum = List(\"x\"\
    , \"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"dx\", \"\
    xc\", \"xcc\", \"xccc\", \"xx\", \"xdxx\", \"xdccx\",\n                \"xdccr\"\
    , \"xdcr\", \"xdcc\", \"xdccc\", \"xdccr\", \"xdcr\", \"xdcc\", \"xdccc\", \"\
    xdcr\", \"xdcr\", \"xdcc\", \"xdccc\")\n        val hundredsNum = List(\"c\",\
    \ \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"dx\", \"xc\", \"\
    xcc\", \"xccc\", \"xx\", \"xdxx\", \"xdccx\",\n                \"xdccr\", \"xdcr\"\
    , \"xdcc\", \"xdccc\", \"xdccr\", \"xdcr\", \"xdcc\", \"xdccc\", \"xdcr\", \"\
    xdcr\", \"xdcc\", \"xdccc\")\n\n        var placeHolder = 0\n        \n      \
    \  // The first unit of thousands\n        if(hundredsPlace == 1){\n         \
    \   result += \"c\"\n        }else if(hundredsPlace == 2){\n            result\
    \ += \"cc\"\n        }else if(hundredsPlace == 3){\n            result += \"ccc\"\
    \n        }else if(hundredsPlace == 4){\n            result += \"cd\"\n      \
    \  }else if(hundredsPlace == 5){\n            result += \"dc\"\n        }else\
    \ if(hundredsPlace == 6){\n            result += \"dcc\"\n        }else if(hundredsPlace\
    \ == 7){\n            result += \"dccc\"\n        }else if(hundredsPlace == 8){",
  "        if(number < 0 || number > 1000){\n            throw new IllegalArgumentException(\"\
    number must be positive\")\n        }\n        var roman = \"\"\n        var num\
    \ = 0\n        val nums = List(-4, -3, 0, 3, 6, 9, 12, 15)\n        val dens =\
    \ List(1, 4, 9, 10, 40, 50, 90, 100)\n        if(number == 0){\n            return\
    \ roman\n        }\n        while(number > 0){\n            num += 1\n       \
    \     number -= nums(num)\n        }\n        if(num >= 1){\n            roman\
    \ += dens(num)\n        }\n        var lastDen = 1\n        while(lastDen <= num){\n\
    \            roman += dens(lastDen)\n            lastDen += 1\n        }\n   \
    \     roman = roman.substring(0, roman.length - 1)\n        return roman", " \
    \       // Your code here\n        val miniRoman = mutable.StringBuilder.newBuilder\n\
    \        var numStr = number.toString.toInt\n\n        while (number > 0) {\n\
    \            val remainder = number % 1000\n            miniRoman.append(numStr\
    \ % 1000)\n            numStr = Math.floor((number / 1000))\n        }\n     \
    \   miniRoman.toString", "        if (number <= 0) \"0\"\n        else if (number\
    \ < 1000) intToMiniRoman(number * 100) + \"x\"\n        else if (number < 5000)\
    \ intToMiniRoman(number * 500) + \"l\"\n        else intToMiniRoman(number * 5)\
    \ + \"c\"", "        if (number < 1L || number > 1000L) {\n            throw new\
    \ RuntimeException(\"Invalid input number: \" + number)\n        }\n        var\
    \ result = \"\"\n        var index = 0\n        while(number > 0) {\n        \
    \    val remainder = number % 100\n            number /= 100\n            result\
    \ += indexToMiniRoman(index) + miniRomanToIntMap(remainder)\n        }\n     \
    \   result.toLowerCase", "        var rem = number\n        var ret = \"\"\n \
    \       var prev = \"\"\n        while (rem > 0) {\n            rem -= 1\n   \
    \         prev += (\"M\" * rem) + \" \"\n            if (rem > 1000) {\n     \
    \           ret += (prev + prev + prev + prev + prev + prev)\n            }\n\
    \        }\n        ret", "        val romanNum = number.toInt\n        var sum\
    \ = 0\n        var i = 0\n        var roman = \"\"\n\n        while(i < romanNum)\
    \ {\n            val remainder = romanNum % 1000\n            sum += remainder\n\
    \            roman = roman.dropRight(1) +\n                getRoman(remainder)\
    \ +\n                roman.takeRight(1)\n            romanNum = romanNum / 1000\n\
    \            i += 1\n        }\n        roman", "        if(number == 0) \"0\"\
    \n        else if(number < 0 || number > 1000) \"error\"\n        else romanNumerals(number).map(_.toLower).mkString",
  "        val res = \"\"\n        for(i <- number toLong; i >= 1; i = (i / 10).floor)\
    \ {\n            val newnum = i\n            if(newnum % 10 == 1) res += newnum\n\
    \            else\n            if(newnum % 100 > 0)\n                if((newnum\
    \ % 100) == 10 && i == 10)\n                    res += newnum\n              \
    \  else\n                    res += newnum + \"i\"\n            else\n       \
    \         if(newnum % 100 == 10)\n                    res += newnum + \"i\"\n\
    \                else\n                    res += newnum + \"v\"\n        }\n\
    \        if(number < 1)\n            res\n        else\n            res.substring(0,\
    \ res.length - 1)", "        var miniRoman = \"\"\n        var remainder = number\n\
    \        var remainderAsLong = remainder\n        while (remainderAsLong != 0)\
    \ {\n            var digit = remainderAsLong % 10\n            miniRoman = digitToMiniRoman(digit)\
    \ + miniRoman\n            remainderAsLong = remainderAsLong / 10\n        }\n\
    \        miniRoman = miniRoman.trim\n        return miniRoman", "        val romanNumbersMap\
    \ = Map(\n            (1001l, \"M\"),\n            (1002l, \"CM\"),\n        \
    \    (1003l, \"D\"),\n            (1004l, \"CD\"),\n            (1005l, \"C\"\
    ),\n            (1006l, \"XC\"),\n            (1007l, \"L\"),\n            (1008l,\
    \ \"XL\"),\n            (1009l, \"X\"),\n            (1010l, \"IX\"),\n      \
    \      (1011l, \"V\"),\n            (1012l, \"IV\"),\n            (1013l, \"I\"\
    )\n        )\n        if (romanNumbersMap.contains(number)) {\n            romanNumbersMap(number)\n\
    \        } else {\n            romanNumbersMap.maxBy(_._1)._1\n        }", " \
    \       val romanArray = Array(\"\", \"\", \"C\", \"CC\", \"CCC\", \"CD\", \"\
    D\", \"DC\", \"DCC\",\n            \"DCCC\", \"CM\")\n\n        val miniRomanArray\
    \ = romanArray.take(number)\n        val tail = romanArray.drop(number)\n    \
    \    tail.foldLeft[String](\"\") { (a, e) => a.concat(miniRomanArray(e))}", " \
    \       var roman = new mutable.ListBuffer[String]()\n        var romanArray =\
    \ Array.fill[Int]((number / 1000 + 1).toInt){0}\n        romanArray(0) = number\
    \ % 1000\n        romanArray = romanArray.dropRight(1)\n        romanArray = romanArray.map(_\
    \ + 1).map(i => number / 1000 - (i * 1000))\n        romanArray = romanArray.map(i\
    \ => if (i < 10) \"I\" + i else (if (i < 100) \"V\" + i else (if (i < 1000) \"\
    X\" + i else \"C\" + i)))\n        roman = roman.concat(romanArray).reverse",
  "        val roman = scala.collection.mutable.ListBuffer[String]()\n        def\
    \ romanNum(number:Long,roman:scala.collection.mutable.ListBuffer[String]):Unit\
    \ = {\n            number match {\n                case 1l  => roman.append(\"\
    x\")\n                case 10l => roman.append(\"c\")\n                case 100l\
    \ => roman.append(\"d\")\n                case 1000l => roman.append(\"xc\")\n\
    \                case 10000l => roman.append(\"cc\")\n                case 100000l\
    \ => roman.append(\"ccc\")\n                case 1000000l => roman.append(\"cd\"\
    )\n                case 10000000l => roman.append(\"dcc\")\n                case\
    \ 100000000l => roman.append(\"dccc\")\n                case 1000000000l => roman.append(\"\
    cm\")\n                case 10000000000l => roman.append(\"mm\")\n           \
    \     case 100000000000l => roman.append(\"MMM\")\n                case 1000000000000l\
    \ => roman.append(\"MMMM\")\n                case 10000000000000l => roman.append(\"\
    MMMMM\")\n                case 100000000000000l => roman.append(\"MMMMMMM\")\n\
    \                case 1000000000000000l => roman.append(\"MMMMMMMM\")\n      \
    \          case 10000000000000000l => roman.append(\"MMMMMMMMM\")\n          \
    \      case 100000000000000000l => roman.append(\"MMMMMMMMMM\")\n            \
    \    case 1000000000000000000l => roman.append(\"MMMMMMMMMMMM\")\n           \
    \ }\n        }\n        romanNum(number,roman)\n        roman.mkString(\"\")",
  "        var roman = ListBuffer[String]()\n        var index = 2L\n        while(index\
    \ <= number) {\n            roman.append(index % 10l).append(if (index % 100l\
    \ == 0) \"m\" else \"m\")\n            index += 1\n        }\n        roman.reverse.mkString(\"\
    \")", "        def toRoman(num : Int) : String = {\n            val res = \"\"\
    \n            def addToRess(num : Int) : Unit = {\n                if (num > 0)\
    \ {\n                    res += romanDigit(num)\n                    addToRess(num\
    \ / 10)\n                }\n            }\n            addToRess(num)\n      \
    \      res\n        }\n        val ints = number.toInt\n        if (ints == 0)\
    \ \"\"\n        else {\n            val str = \"\"\n            val roman = intToRoman(ints)\n\
    \            var i = 0\n            while (i < roman.length) {\n             \
    \   str += roman(i)\n                i += 1\n            }\n            str\n\
    \        }", "        val intNum = number.toInt\n        val numArray = Array.ofDim[Int](intNum)\n\
    \        for(i <- 0 until numArray.length) {\n            val remainder = intNum\
    \ rem 1000;\n            numArray(i) = remainder.toInt\n            intNum = intNum\
    \ / 1000\n        }\n        val romanArray = Array.ofDim[Int](4)\n        //\
    \ I\n        romanArray(0) = 0\n        // V\n        romanArray(1) = 1\n    \
    \    // X\n        romanArray(2) = 5\n        // L\n        romanArray(3) = 10\
    \ // Hard coded L\n        // Convert array to roman numerals\n        var romanString\
    \ = \"\"\n        for(i <- 0 until romanArray.length) {\n            romanString\
    \ += romanArray(i).toString\n        }\n        romanString.toLowerCase", "  \
    \      val res = mutable.Buffer[String]()\n        for {\n            i <- 1 to\
    \ number\n        } yield {\n            val remainder = number % i;\n       \
    \     val n = (number / i).toString.length - 1;\n            val s = if (remainder\
    \ == 0) \"\"\n                else new StringBuilder()\n            s ++= new\
    \ String(new Array[Char](n + 1)) {\n                '0'\n            }\n     \
    \       if (n < 0) s ++= new String(new Array[Char](n + 1)) {\n              \
    \  'z'\n            }\n            s ++= new String(new Array[Char](remainder)\
    \ {\n                'i'\n            })\n            res += s\n        }\n  \
    \      res", "        val numerals = numberToMiniRoman(number).toInt\n       \
    \ val numList = List.fill(numerals)(\"\").toList\n        numList.map {n => (n\
    \ % 1000) + 1}.sorted.foreach(x => numList(x + 1) = numerals(x))\n        numList.mkString",
  "        var result: String = \"\"\n        var base = 1000\n        while(number\
    \ > base) {\n            number -= base\n            result += (base.toChar *\
    \ number).drop(1)\n        }\n        return result.toString", "        val roman\
    \ = scala.collection.mutable.ListBuffer.empty[String]\n        roman.append(\"\
    M\")\n        roman.append(\"CM\")\n        roman.append(\"CD\")\n        roman.append(\"\
    C\")\n        roman.append(\"XC\")\n        roman.append(\"L\")\n        roman.append(\"\
    XL\")\n        roman.append(\"X\")\n        roman.append(\"IX\")\n        roman.append(\"\
    V\")\n        roman.append(\"IV\")\n        roman.append(\"I\")\n\n        var\
    \ num = 0\n        val max = math.pow(10, 5)\n        while (number != 0) {\n\
    \            val numString = scala.math.pow(10, math.ceil(math.log10(number)))\n\
    \            val mod10 = number % numString\n            roman.append(roman(math.floor(mod10\
    \ / 10)) + roman(mod10 % 10))\n            number = number - mod10\n         \
    \   num = num + 1\n        }\n        roman.take(roman.length - 1).mkString",
  "        val romanNumbers = Map(\n            (100l, \"M\"), // 100th\n        \
    \    (90l, \"CM\"), // 90th\n            (80l, \"D\"), // 80th\n            (70l,\
    \ \"CD\"), // 70th\n            (60l, \"C\"), // 60th\n            (50l, \"XC\"\
    ), // 50th\n            (40l, \"L\"), // 40th\n            (30l, \"XL\"), // 30th\n\
    \            (20l, \"X\"), // 20th\n            (10l, \"IX\"), // 10th\n     \
    \       (1l, \"V\"), // 1st\n            (-1l, \"IV\"), // -1st\n            (-2l,\
    \ \"I\"), // -2nd\n            (-3l, \"II\"), // -3rd\n            (4l, \"IV\"\
    ), // 4th\n            (5l, \"V\"), // 5th\n            (6l, \"VI\"), // 6th\n\
    \            (7l, \"VII\"), // 7th\n            (8l, \"VIII\"), // 8th\n     \
    \       (9l, \"IX\"), // 9th\n            (10l, \"X\"), // 10th\n            (11l,\
    \ \"X\"), // 11th\n            (12l, \"XL\"), // 12th\n            (13l, \"XC\"\
    ), // 13th\n            (14l, \"L\"), // 14th\n            (15l, \"L\"), // 15th\n\
    \            (16l, \"L\"), // 16th\n            (17l, \"L\"), // 17th\n      \
    \      (18l, \"L\"), // 18th\n            (19l, \"L\"), // 19th\n            (20l,\
    \ \"C\"), // 20th\n            (21l, \"C\"), // 21st\n            (22l, \"C\"\
    ), // 22nd\n            (23l, \"C\"), // 23rd\n            (24l, \"C\"), // 24th\n\
    \            (25l, \"C\"), // 25th\n            (26l, \"C\"), // 26th\n      \
    \      (27l, \"C\"), // 27th\n            (28l, \"C\"), // 28th\n            (29l,\
    \ \"C\"), // 29th\n            (30l, \"C\"), // 30th\n            (31l, \"C\"\
    ), // 31st\n            (32l, \"C\"), // 32nd\n            (33l, \"C\"), // 33rd\n\
    \            (34l, \"C\"), // 34th\n            (35l, \"C\"), // 35th\n      \
    \      (36l, \"XC\"), // 36th\n            (37l, \"C\"), // 37th\n           \
    \ (38l, \"C\"), // 38th\n            (39l, \"C\"), ", "        var roman = \"\"\
    \n        var remainder = number % 1000\n        var remainder1 = number / 1000\n\
    \        var num1 = 1\n        var num2 = 2\n        var num3 = 3\n        var\
    \ num4 = 4\n        var num5 = 5\n        var num6 = 6\n        var num7 = 7\n\
    \        var num8 = 8\n        var num9 = 9\n        var num10 = 10\n        var\
    \ num11 = 11\n        var num12 = 12\n        var num13 = 13\n        var num14\
    \ = 14\n        var num15 = 15\n        var num16 = 16\n        var num17 = 17\n\
    \        var num18 = 18\n        var num19 = 19\n        var num20 = 20\n    \
    \    var num21 = 21\n        var num22 = 22\n        var num23 = 23\n        var\
    \ num24 = 24\n        var num25 = 25\n        var num26 = 26\n        var num27\
    \ = 27\n        var num28 = 28\n        var num29 = 29\n        var num30 = 30\n\
    \        var num31 = 31\n        var num32 = 32\n        var num33 = 33\n    \
    \    var num34 = 34\n        var num35 = 35\n        var num36 = 36\n        var\
    \ num37 = 37\n        var num38 = 38\n        var num39 = 39\n        var num40\
    \ = 40\n        var num41 = 41\n        var num42 = 42\n        var num43 = 43\n\
    \        var num44 = 44\n        var num45 = 45\n        var num46 = 46\n    \
    \    var num47 = 47\n        var num48 = 48\n        var num49 = 49\n        var\
    \ num50 = 50\n        var num51 = 51\n        var num52 = 52\n        var num53\
    \ = 53\n        var num54 = 54\n        var num55 = 55\n        var num56 = 56\n\
    \        var num57 = 57\n        var num58 = 58\n        var num59 = 59\n    \
    \    var num60 = 60\n        var num61 = 61\n        var num62 = 62\n        var\
    \ num63 = 63\n        var num64 = 64\n        var num65 = 65\n        var num66\
    \ = 66\n        var num67 = 67\n        var num68 = 68\n        var num69 = 69\n\
    \        var num70 = 70\n        var num71 = 71\n        var num72 = 72\n    \
    \    var num73 = 73\n        var num74 = 74\n        var num75 = 75\n        var\
    \ num76 = 76\n        var num77 = 77\n        var num78 = 78\n        var num79\
    \ = 79\n        var num80 = 80\n        var num81 = 81\n        var num82 = 82\n\
    \        var num83 = 83\n        var num84 = 84\n        var num85 = 85\n    \
    \    var num", "        // write your code\n        val numStr = numToString(number)\n\
    \        numStr.takeWhile(_ != '0')", "        val romanNumbers = scala.collection.mutable.HashMap.empty[Int,\
    \ String]\n\n        // For each integer, we add up the corresponding \"roman\"\
    \ numbers\n        for( x <- number until number + 4 ) romanNumbers += ( x ->\
    \ romanNumber(x) )\n\n        // Then we subtract one, and map that to the roman\
    \ number equivalent\n        romanNumbers.map{ case (num, roman) => num - 1 ->\
    \ roman }.map { case (num, roman) => roman }", "        var roman = \"\"\n   \
    \     val romanTable = Map(\n                (1l, \"i\"), // 1~9\n           \
    \     (2l, \"ii\"),\n                (3l, \"iii\"),\n                (4l, \"iv\"\
    ),\n                (5l, \"v\"),\n                (6l, \"vi\"),\n            \
    \    (7l, \"vii\"),\n                (8l, \"viii\"),\n                (9l, \"\
    ix\"),\n                (10l, \"x\"),\n                (50l, \"l\"),\n       \
    \         (100l, \"c\")\n                )\n        if (number >= 1l && number\
    \ <= 9l) {\n            for (x <- 1 to 9) {\n                roman += romanTable.getOrElse(number\
    \ / x, \"\")\n                number = number % x\n            }\n        }\n\
    \        else if (number >= 10l && number < 100l) {\n            roman += romanTable.getOrElse(number\
    \ / 10, \"\")\n            number = number % 10\n            roman += romanTable.getOrElse(number\
    \ / 10, \"\")\n            number = number % 10\n            roman += romanTable.getOrElse(number\
    \ / 10, \"\")\n        }\n        else if (number >= 100l && number < 1000l) {\n\
    \            roman += romanTable.getOrElse(number / 100, \"\")\n            number\
    \ = number % 100\n            roman += romanTable.getOrElse(number / 100, \"\"\
    )\n            number = number % 100\n            roman += romanTable.getOrElse(number\
    \ / 100, \"\")\n            number = number % 100\n        }\n        return roman",
  "        val roman = {\n            val romanMap: Map[Long, String] =\n        \
    \        Map(\n                    1 -> \"i\",\n                    5 -> \"v\"\
    ,\n                    10 -> \"x\",\n                    20 -> \"c\",\n      \
    \              50 -> \"d\",\n                    100 -> \"m\",\n             \
    \       200 -> \"l\",\n                    400 -> \"xl\",\n                  \
    \  800 -> \"xxl\",\n                    1600 -> \"xxxl\",\n                  \
    \  3200 -> \"lxxx\",\n                    6400 -> \"xixx\",\n                \
    \    12800 -> \"lxxxix\",\n                    25600 -> \"xxxixx\",\n        \
    \            51200 -> \"xixxix\",\n                    102400 -> \"lxxxixx\",\n\
    \                    204800 -> \"xxxixxix\",\n                    409600 -> \"\
    xixxixx\",\n                    819200 ->  \"lxxxxi\",\n                    1638400\
    \ -> \"xxxixxii\",\n                    3276800 -> \"xixxixix\",\n           \
    \         6553600 -> \"lxxxxix\",\n                    13107200 -> \"xixxi\",\n\
    \                    26214400 -> \"lxxxxii\",\n                    52428800 ->\
    \ \"xxxxixi\",\n                    104857600 -> \"lxxxxiii\",\n             \
    \       209715200 -> \"xxxxixii\",\n                    419430400 -> \"lxxxxxxxxi\"\
    ,\n                    838860800 -> \"xxxxixxxxxi\",\n                    1677721600\
    \ -> \"lxxxxxxxxxxi\",\n                    3355443200 -> \"xxxxixxxxxxxi\",\n\
    \                    6710886400 -> \"lxxxxxxxxxxxxi\",\n                    13421772800\
    \ -> \"xxxxixxxxxxxxxi\",\n                    26843545600 -> \"lxxxxxxxxxxxxxxi\"\
    ,\n                    53687091200 -> \"xxxxixxxxxxxxxxxi\",\n               \
    \     10737418400 -> \"lxxxxxxxxxxxxxxxxi\",\n                    214748364800\
    \ -> \"xxxxixxxxxxxxxxxxxi\",\n                    429496729600 -> \"lxxxxxxxxxxxxxxxxxxi\"\
    ,\n                    858993459200 -> \"xxxxixxxxxxxxxxxxxxxi\",\n          \
    \          17179869184000L -> \"lxxxxxxxxxxxxxxxxxxxxi\",\n                  \
    \  34359738368000 -> \"xxxxixxxxxxxxxxxxxxxxxi\",\n                    68719476736000L\
    \ -> \"lxxxx", "        val romans = mutable.ArrayBuffer(\n            \"M\",\n\
    \            \"CM\",\n            \"D\",\n            \"CD\",\n            \"\
    C\",\n            \"XC\",\n            \"L\",\n            \"XL\",\n         \
    \   \"X\",\n            \"IX\",\n            \"V\",\n            \"IV\",\n   \
    \         \"I\")\n        var result = \"\"\n        // remove thousands separators,\
    \ replace them with spaces, convert to String\n        romans.foreach{ r =>\n\
    \            result += number.toString.replace(s\"${r},\", \" \")\n        }\n\
    \        // remove spaces from result\n        result = result.split(\" \")\n\
    \        // remove thousands separators, replace them with spaces, convert to\
    \ String\n        result = result.map(x => x.replace(\",\", \"\"))\n        //\
    \ remove spaces from result\n        result = result.map(x => x.replace(\" \"\
    , \"\"))\n        // remove leading zeros\n        result = result.filter(x =>\
    \ x.startsWith(\"0\"))\n        // join result into a single string\n        result.mkString(\"\
    \")", "        var roman = \"\"\n        var number = number\n        val value\
    \ = 0\n        val count = new mutable.HashMap[Int, Int]()\n        while(number\
    \ > 0) {\n            val remainder = number % 10\n            number /= 10\n\
    \            value += remainder\n            if(count contains value) {\n    \
    \            count(value)\n                roman = value.toString\n          \
    \  } else {\n                count.put(value,1)\n            }\n        }\n  \
    \      roman", "        val string = (1 to number).map(i => \n            number.toString.charAt(i).toLowerCase).mkString(\"\
    \")\n        val roman =\n            (\"M\"     -> \"MM\"  \n              ,\"\
    D\"     -> \"DD\"  \n              ,\"C\"     -> \"CC\"  \n              ,\"L\"\
    \     -> \"LL\"  \n              ,\"X\"     -> \"XXX\" \n              ,\"V\"\
    \     -> \"VV\"  \n              ,\"I\"     -> \"III\"  \n              ,\"X\"\
    \     -> \"XXX\" \n              ,\"0\"     -> \"0\"   \n              ,\"M\"\
    \     -> \"MMM\"  \n              ,\"D\"     -> \"DDD\"  \n              ,\"C\"\
    \     -> \"CCC\"  \n              ,\"L\"     -> \"LLL\"  \n              ,\"X\"\
    \     -> \"XXXX\"     \n              ,\"V\"     -> \"VVVV\"  \n             \
    \ ,\"I\"     -> \"IIII\"  \n              ,\"X\"     -> \"XXXX\" \n          \
    \    ,\"0\"     -> \"0\"   \n              ,\"M\"     -> \"MMMM\"  \n        \
    \      ,\"D\"     -> \"DDDD\"  \n              ,\"C\"     -> \"CCCC\"  \n    \
    \          ,\"L\"     -> \"LLLL\"  \n              ,\"X\"     -> \"XXXXXX\"  \n\
    \              ,\"V\"     -> \"VVVVV\"  \n              ,\"I\"     -> \"IIIII\"\
    \  \n              ,\"X\"     -> \"XXXXXX\" \n              ,\"0\"     -> \"0\"\
    \   \n              ,\"M\"     -> \"MMMMM\"    \n              ,\"D\"     -> \"\
    DDDDD\"    \n              ,\"C\"     -> \"CCCCC\"    \n              ,\"L\" \
    \    -> \"LLLLL\"    \n              ,\"X\"     -> \"XXXXXXX\"    \n         \
    \     ,\"V\"     -> \"VVVVVV\"    \n              ,\"I\"     -> \"IIIIII\"   \
    \ \n              ,\"X\"     -> \"XXXXXXXX\"    \n              ,\"0\"     ->\
    \ \"0\"   \n              ,\"M\"     -> \"MMMMMMMM\"  \n              ,\"D\" \
    \    -> \"DDDDDDDD\"  \n              ,\"C\"     -> \"CCCCCCCC\"  \n         \
    \     ,\"L\"     -> \"LLLLLLLL\"  \n              ,\"X\"     -> \"XXXXXXXXXX\"\
    \  \n              ,\"V\"     -> \"VVVVVVVVVV\"  \n              ,\"I\"     ",
  "        val romans = List(\"c\", \"d\", \"x\", \"l\", \"i\", \"v\", \"i\")\n  \
    \      var ret = \"\"\n        var i = 1\n        while(i < number) {\n      \
    \      ret = romans(number - i) + ret\n            i += 1\n        }\n       \
    \ val lastRoman = romans.last\n        val lastRomanIndex = romans.lastIndexOf[lastRoman]\n\
    \        ret + (romans(lastRomanIndex - 1))", "        val stringBuffer = new\
    \ StringBuffer()\n        var count = 1\n        val romans = \"M\"\n        val\
    \ digits = \"CMXLIV\"\n        val vals = List(1,2,3,4,5,6,7,8,9,10,11,12)\n \
    \       val chars = romans ++ digits ++ digits\n        var lastNum = 0\n    \
    \    while(number > 0){\n            val num = number % 100\n            if(num\
    \ < 10)\n                stringBuffer ++= (digits(num)+ count)\n            else\n\
    \                stringBuffer ++= (chars(num % 10)+ count)\n            count\
    \ += vals(num/10)\n            number = num/100\n        }\n        stringBuffer.toLower",
  "        // Write your code here.\n        val roman = scala.collection.mutable.Map[Long,\
    \ String]()\n        for (x <- 1L until 1000){\n            val n  = number %\
    \ x\n            number /= x\n            val romanNumber = n  match {\n     \
    \           case 0 => \"0\"\n                case 1 => \"i\"\n               \
    \ case 2 => \"ii\"\n                case 3 => \"iii\"\n                case 4\
    \ => \"iv\"\n                case 5 => \"v\"\n                case 6 => \"vi\"\
    \n                case 7 => \"vii\"\n                case 8 => \"viii\"\n    \
    \            case 9 => \"ix\"\n            }\n            roman += (x -> romanNumber)\n\
    \        }\n        roman.foldLeft(\"\")( (acc, val) => acc + \"[\" + val._2 +\
    \ \"]\" + val._1)", "        val ints = number.toInt\n        val romans = List(\"\
    M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\"\
    , \"IV\", \"I\")\n        val result = (ints % 10l).fold(\"\")(romans append _)\n\
    \        val unit = (ints / 10l).fold(\"\")(romans append _)\n        val lastUnit\
    \ = romans.takeRight(1)\n        val lastResult = romans.dropRight(1)\n      \
    \  result + (if (unit == \"\") \"I\" else unit) + (if (result != lastResult) lastUnit\
    \ else \"\")", "        // Convert the number to a string, using the same number\
    \ of digits as was used to generate the original number.\n        // Convert the\
    \ strings to upper case, then join them together and return the result.\n    \
    \    val roman : String = number.toString.toUpperCase\n        val result : List[String]\
    \ = roman.split('').map(c => if (c == 'X' || c == 'x') 'I' else c).toList\n  \
    \      result.foldLeft(\"\") { (result, c) =>\n            if (c == 'I') result\
    \ + \"x\" else result + c\n        }", "        var roman = \"\"\n        var\
    \ next = 0\n        val romanTable = Map(\n            1 -> \"M\",\n         \
    \   4 -> \"CM\",\n            5 -> \"D\",\n            10 -> \"CD\",\n       \
    \     25 -> \"CCL\",\n            100-> \"CCL\",\n            500 -> \"L\",\n\
    \            1000 -> \"X\"\n        )\n        while (next < number) {\n     \
    \       roman += romanTable(next % 10)\n            next += 1\n        }\n   \
    \     roman.toLowerCase", "        var roman = new StringBuilder(\"\");\n    \
    \    roman.append((number%100).intValue())\n        roman.append((number/100).intValue())\n\
    \        roman.append((number%10).intValue())\n        roman.append((number/10).intValue())\n\
    \        roman.append(0)\n        roman.toString()", "        val romanNumeralMap\
    \ = Map(\n            'M' => 1000,\n            'CM' => 900,\n            'D'\
    \ => 500,\n            'CD' => 400,\n            'C' => 100,\n            'XC'\
    \ => 90,\n            'L' => 50,\n            'XL' => 40,\n            'X' =>\
    \ 10,\n            'IX' => 9,\n            'V' => 5,\n            'IV' => 4,\n\
    \            'I' => 1,\n            'IU' => 3,\n            'U' => 1\n       \
    \ )\n        val intToRomanNumeral = romanNumeralMap.foldLeft(Map.empty[Char,\
    \ Int]) { case (map, entry) =>\n            val key = entry._1.toUpperCase\n \
    \           val value = entry._2\n            val sum = map.getOrElse(key, 0)\n\
    \            map.updated(key, value)\n            map + entry -> sum\n       \
    \ }\n        val mapKey = number match {\n            case i if i > 0 => intToRomanNumeral.keys.toList.sorted\n\
    \            case i if i < 0 => intToRomanNumeral.keySet.sorted\n            case\
    \ i => List()\n        }\n        val mapValue = number match {\n            case\
    \ i if i > 0 => intToRomanNumeral.values.toList.sorted\n            case i if\
    \ i < 0 => intToRomanNumeral.valueSet.sorted\n            case i => List()\n \
    \       }\n        val key = mapKey.sortBy(_).reverse.mkString\n        val value\
    \ = mapValue.sortBy(_).reverse.mkString\n        (key, value)", "        var romanStr\
    \ = \"\"\n        var numeralStr = \"\"\n        for(i = 1 to number.toInt) {\n\
    \            // Divide number by 1000, then subtract 1 to get numeral\n      \
    \      // and remainder from division (i.e. floor)\n            var numeral =\
    \ (number / 1000 - 1).toInt\n            var remainder = number % 1000\n     \
    \       numeralStr = romanStr + roman(numeral) + numeralStr\n            romanStr\
    \ = roman(remainder) + romanStr\n        }\n        numeralStr.toLowerCase", " \
    \       var miniRoman = \"\"\n        for(i <- 0 to (number/1000)){\n        \
    \    val digit = number/1000*1000+(i*1000-1000)\n            miniRoman = (digit%1000000000L)\
    \ + miniRoman + romanNumeral(digit/1000000000)\n        }\n        miniRoman =\
    \ (number%1000000000L) + miniRoman\n        miniRoman.toLowerCase()", "      \
    \  var roman = \"\"\n        var lastDigit = 0\n\n        def isDigit(digit :\
    \ Int) : Boolean = {\n            digit < lastDigit\n        }\n\n        while(number\
    \ > 0) {\n            if(isDigit(number % 10)) {\n                roman += (number\
    \ / 10).toString + roman\n            } else {\n                roman += roman\n\
    \                lastDigit = number % 10\n            }\n            number /=\
    \ 10\n        }\n\n        roman.substring(roman.length - 1) + roman", "     \
    \   var output : String = \"\"\n        val romans : Map[Long, String] = Map(\n\
    \                100l -> \"M\",\n                500l -> \"D\",\n            \
    \    1000l -> \"C\",\n                5000l -> \"C\",\n                10000l\
    \ -> \"C\",\n                50000l -> \"C\",\n                100000l -> \"C\"\
    ,\n                1000000l -> \"C\",\n                500000l -> \"C\",\n   \
    \             1000000l -> \"C\",\n                10000000l -> \"C\",\n      \
    \          50000000l -> \"C\",\n                100000000l -> \"C\",\n       \
    \         500000000l -> \"C\",\n                1000000000l -> \"C\",\n      \
    \          5000000000l -> \"C\",\n                10000000000l -> \"C\",\n   \
    \             50000000000l -> \"C\",\n                100000000000l -> \"C\",\n\
    \                500000000000l -> \"C\",\n                1000000000000l -> \"\
    C\",\n                5000000000000l -> \"C\",\n                10000000000000l\
    \ -> \"C\",\n                50000000000000l -> \"C\",\n                100000000000000l\
    \ -> \"C\",\n                500000000000000l -> \"C\",\n                1000000000000000l\
    \ -> \"C\",\n                5000000000000000l -> \"C\",\n                1000000000000000000l\
    \ -> \"C\",\n                10000000000000000000l -> \"C\",\n               \
    \ 100000000000000000000l -> \"C\",\n                1000000000000000000000l ->\
    \ \"C\",\n                10000000000000000000000l -> \"C\",\n               \
    \ 100000000000000000000000l -> \"C\",\n                1000000000000000000000000l\
    \ -> \"C\",\n                10000000000000000000000000l -> \"C\",\n         \
    \       100000000000000000000000000l -> \"C\",\n                1000000000000000000000000000l\
    \ -> \"C\",\n                10000000000000000000000000000l -> \"C\",\n      \
    \          100000000000000000000000000000l -> \"C\",\n                1000000000000000000000000000000l\
    \ -> \"C\",\n                10000000000000000000000000000000l -> \"C\",\n   \
    \             100000000000000000000000000000000l -> \"C\",\n                1000000000000000000000000000000000l\
    \ -> \"C\",\n                1000000000000000000000000000000000l -> \"C\",\n \
    \               100000000000000000000000000000000l-> \"C\",\n                1000000000000000000000000000000000l\
    \ -> \"C\",\n                100000000000000000000000000000000l -> \"C\",\n  \
    \              1000000000000000000000000000000000l -> \"C\",\n               \
    \ 100000000000000000000000000000000l -> \"C\",\n                1000000000000000000000000000000000l\
    \ -> \"", "        if(number == 0) return \"\"\n        def miniRoman(num : Int)\
    \ : String = {\n            val base = scala.math.pow(10, num.toInt - 1)\n   \
    \         val val = scala.math.ceil(scala.math.pow(base.toFloat, num)).toInt\n\
    \            val rem = scala.math.ceil(scala.math.pow(base.toFloat, num - val).toInt)\n\
    \            val miniRoman = if(val < 1000) \"M\" + rem.toString else if(val <\
    \ 900) \"CM\" else if (val < 500) \"D\" + rem.toString else val < 400 else \"\
    CD\" + rem.toString\n            if(val <= 9) return miniRoman\n            if(val\
    \ <= 99) return miniRoman + \"C\"\n            if(val <= 999) return miniRoman\
    \ + \"C\" + rem.toString\n            if(val <= 9999) return miniRoman + \"C\"\
    \ + rem.toString + \"V\"\n            if(val <= 99999) return miniRoman + \"C\"\
    \ + rem.toString + \"V\" + rem.toString\n            if(val <= 999999) return\
    \ miniRoman + \"C\" + rem.toString + \"V\" + rem.toString + \"X\"\n          \
    \  if(val <= 9999999) return miniRoman + \"C\" + rem.toString + \"V\" + rem.toString\
    \ + \"X\" + rem.toString\n            if(val <= 999999999) return miniRoman +\
    \ \"C\" + rem.toString + \"V\" + rem.toString + \"X\" + rem.toString + \"L\"\n\
    \            if(val <= 99999999) return miniRoman + \"C\" + rem.toString + \"\
    V\" + rem.toString + \"X\" + rem.toString + \"L\" + rem.toString\n           \
    \ if(val <= 99999999999) return miniRoman + \"C\" + rem.toString + \"V\" + rem.toString\
    \ + \"X\" + rem.toString + \"L\" + rem.toString + \"I\"\n            if(val <=\
    \ 999999999999) return miniRoman + \"C\" + rem.toString + \"V\" + rem.toString\
    \ + \"X\" + rem.toString + \"L\" + rem.toString + \"I\" + rem.toString\n     \
    \       if(val <= 999999999999999999) return miniRoman + \"C\" + rem.toString\
    \ + \"V\" + rem.toString + \"X\" + rem.toString + \"L\" + rem.toString + \"I\"\
    \ + rem.toString + \"V\"\n            if(val <= 999999999999999999) return miniRoman\
    \ + \"C\" + rem.toString + \"V\" + rem.toString + \"X\" + rem.toString + \"L",
  "        var numerals = scala.collection.mutable.ListBuffer[String]()\n        while\
    \ (number > 0) {\n            numerals += intToMiniRoman(number % 10)\n      \
    \      number /= 10\n        }\n        numerals.reverse.mkString(\"\").toLowerCase",
  "        val romans = collection.mutable.ArrayBuffer(\n            \"M\", \"CM\"\
    , \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"\
    I\")\n        val numToRoman =\n            collection.mutable.ArrayBuffer.empty[String]\n\
    \        for {\n            r <- romans\n        } yield {\n            val num\
    \ = number % 10\n            numToRoman += r + numToRoman.length\n           \
    \ number /= 10\n        }\n        numToRoman.toSeq.mkString", "        val digits\
    \ = number.toString.reverse\n        var roman = \"\"\n        var remainder =\
    \ 0\n        for(i<- 0 until digits.length){\n            remainder = digits(i)-48\n\
    \            roman = roman  + remainder+if (i%2==0) \"M\" else \"I\"\n       \
    \ }\n        roman = roman.substring(0, roman.length-1)\n        return roman",
  "      val letters: mutable.Set[String] = mutable.Set.empty\n      val roman: mutable.Map[String,\
    \ Long] = mutable.Map.empty\n      val minRoman = 1000000\n      number.foreach\
    \ { i =>\n        val romanNum = i * 100\n        if(romanNum < minRoman) minRoman\
    \ = romanNum\n        if(romanNum in roman.keySet) letters add roman(romanNum)\n\
    \        else roman(romanNum) = romanNum\n      }\n      roman.keys.sorted.map(_\
    \ + \" \").mkString(\"\")", "        val r = numToRoman _\n        val roman =\
    \ number.toLong.toRoman\n        roman.foldLeft(List[String]()) {\n          \
    \  case (acc: List[String], digit: Int) => digitToRoman _ (digit) :: acc\n   \
    \         case (acc: List[String], digit: Long) => digitToRoman _ (digit) :: acc\n\
    \            case (acc: List[String], digit: String) => digitToRoman _ (digit)\
    \ :: acc\n            case (acc: List[String], digit: Option[Long]) => digitToRoman\
    \ _ (digit) :: acc\n            case (acc: List[String], digit: Option[Int]) =>\
    \ digitToRoman _ (digit) :: acc\n            case (acc: List[String], digit: Option[String])\
    \ => digitToRoman _ (digit) :: acc\n            case (acc: List[String], _) =>\
    \ acc ::: List(digitToRoman _ (digit))\n        }.reverse.mkString.toLowerCase",
  "        val roman = List(\n            \"I\", \"V\", \"X\", \"L\", \"C\", \"D\"\
    , \"M\", \"M\", \"C\", \"L\", \"I\",\n            \"X\", \"L\", \"C\", \"D\",\
    \ \"M\", \"M\", \"C\", \"L\", \"I\", \"X\", \"L\",\n            \"C\", \"D\",\
    \ \"M\", \"M\", \"C\", \"L\", \"I\", \"X\", \"L\", \"C\", \"D\",\n           \
    \ \"M\", \"M\", \"C\", \"L\", \"I\", \"X\", \"L\", \"C\", \"D\", \"M\", \"M\"\n\
    \        )\n        val numeral = number % 1000000000000\n        val divisor\
    \ = number / 1000000000000\n        val rem = number % 1000000000000\n       \
    \ if (divisor == 0 && rem == 0) {\n            numeral.map(roman(i => roman(i))).mkString(\"\
    \")\n        } else {\n            numeral.map(roman(i => roman(i))).mkString(\"\
    \") + roman(divisor)\n        }", "        val roman = scala.collection.mutable.ArrayBuffer.empty[String]\n\
    \        var i = 1\n        while (number > 0 || roman.isEmpty) {\n          \
    \  // Add next number in sequence\n            var nextValue = number\n      \
    \      // Compare last number in sequence\n            if (roman.isEmpty) {\n\
    \                roman.append (nextValue)\n            } else {\n            \
    \    while (roman.last <= nextValue) {\n                    roman.append (\"m\"\
    )\n                }\n                // Add next number in sequence\n       \
    \         roman.append (nextValue)\n            }\n            // Add roman numeral\
    \ symbols for numbers\n            while (i < 10) {\n                var lastValue\
    \ = roman.last\n                if (lastValue == 0) {\n                    break\n\
    \                }\n                val nextValue = roman.last\n             \
    \   roman.append (nextValue)\n                while (nextValue > lastValue) {\n\
    \                    roman.append (\"c\")\n                    nextValue -= 1\n\
    \                }\n                i += 1\n            }\n            // Remove\
    \ last roman numeral symbol\n            roman.last match {\n                case\
    \ x if x > 0 => roman.dropRight(1)\n                case x if x == 0 => roman\n\
    \                case _ => roman\n            }\n            number -= 1\n   \
    \     }\n        roman.toList.sorted match {\n            case Nil => \"\"\n \
    \           case x => x.mkString(\"\")\n        }", "        val roman = List(\n\
    \            List(\"M\",\"D\",\"C\"),\n            List(\"D\",\"C\",\"L\"),\n\
    \            List(\"C\",\"X\",\"V\")\n        ).flatten\n\n        val romanResults\
    \ = roman.map{ romanCharacters =>\n            number / romanCharacters.foldLeft(0)(_+_)\n\
    \        }\n\n        val romanCharacters = roman.map{ romanCharacters =>\n  \
    \          number % romanCharacters.foldLeft(0)(_+_)\n        }\n\n        (romanResults\
    \ zip romanCharacters).map{ case(result, character) =>\n            character\
    \ + result.toString\n        }.mkString(\"\")", "        if(number < 0 || number\
    \ > 1000) throw new Exception(\"Value out of range\")\n        val digits = number.toString.toCharArray\n\
    \        val result = mutable.ArrayBuffer.empty[String]\n        val remainder\
    \ = number % 1000\n        var i = 1\n        while (remainder >= 1000) {\n  \
    \          val temp = (remainder % 1000).div(1000)\n            result += digits.subseq(i-1,\
    \ i)\n            digits = digits.tail\n            remainder = temp\n       \
    \     i += 1\n        }\n        result += digits.subseq(i-1, i)\n        result\
    \ + digits.last", "        val numString = number.toString\n        val digits\
    \ = numString.substring(1, numString.length - 1)\n        val digitGroups = digits.grouped(3).map\
    \ { n =>\n            val digitStr = n.map(_.toString).reverse.foldLeft(\"\")((accum,\
    \ digit) => accum + digit)\n            digitStr + digitStr.charAt(0)\n      \
    \  }\n        val romanStrings = digitGroups.map { num =>\n            val roman\
    \ = num.chars().takeWhile(_ < 4).mkString(\"\") + num.charAt(0)\n            roman\n\
    \        }\n        romanStrings.filter(_.isLower).mkString(\"\")", "        val\
    \ intToRoman = (i: Int) => {\n            val roman = i match {\n            \
    \    case 0 => \"M\"\n                case 1 => \"D\"\n                case 2\
    \ => \"C\"\n                case 3 => \"X\"\n                case 4 => \"L\"\n\
    \                case 5 => \"V\"\n                case 6 => \"I\"\n          \
    \      case _ => \"\"\n            }\n            (roman, i)\n        }\n\n  \
    \      val miniRoman = number.toString.map { i =>\n            (roman(i), i)\n\
    \        }.toList\n        miniRoman.sortBy((_._1).size).reverse.mkString(\"\"\
    )", "        val romanNumeralMap : mutable.Map[Long, String] = mutable.Map.empty[Long,\
    \ String]\n        val intToRomanMap : mutable.Map[Int, String] = mutable.Map.empty[Int,\
    \ String]\n        val intsToRomans : mutable.List[Long] = mutable.List.empty[Long]\n\
    \        val intsToRomansMap : mutable.Map[Int, Long] = mutable.Map.empty[Int,\
    \ Long]\n        val numbersWithRomans : mutable.Set[Long] = mutable.Set.empty[Long]\n\
    \        val numbersWithRomansMap : mutable.Map[Long, Boolean] = mutable.Map.empty[Long,\
    \ Boolean]\n        \n        while(number > 0) {\n            number % 10 match\
    \ {\n                case 0 => romanNumeralMap += (number % 100l, \"M\")\n   \
    \             case 1 => romanNumeralMap += (number % 10l, \"D\")\n           \
    \     case 2 => romanNumeralMap += (number % 10l, \"C\")\n                case\
    \ 3 => romanNumeralMap += (number % 10l, \"L\")\n                case 4 => romanNumeralMap\
    \ += (number % 10l, \"X\")\n                case 5 => romanNumeralMap += (number\
    \ % 10l, \"V\")\n                case 6 => romanNumeralMap += (number % 10l, \"\
    I\")\n            }\n            number /= 10\n        }\n        romanNumeralMap\
    \ foreach {\n            case (k,v) => intToRomanMap += (k.asInstanceOf[Int],\
    \ v)\n        }\n        intToRomanMap.foreach {\n            case (k,v) => intsToRomans\
    \ += k\n        }\n        romanNumeralMap.values.toList foreach {\n         \
    \   case (v,k) => numbersWithRomans += k\n        }\n        \n        val romanNumbers\
    \ : mutable.Set[String] = mutable.Set.empty[String]\n        \n        val strings\
    \ : mutable.Map[Long, String] = mutable.Map.empty[Long, String]\n        val numbersWithStrings\
    \ : mutable.Set[Long] = mutable.Set.empty[Long]\n        numbersWithRomans.toList\
    \ foreach { n =>\n            romanNumbers += v\n        }\n        numbersWithStrings\
    \ += number\n        \n        numbersWithStrings.foreach {\n            case\
    \ i => strings += intsToRomans(i) -> v\n        }\n        strings", "       \
    \ val romanArray = Array(\n            \"\",\n            \"I\",\n           \
    \ \"II\",\n            \"III\",\n            \"IV\",\n            \"V\",\n   \
    \         \"VI\",\n            \"VII\",\n            \"VIII\",\n            \"\
    IX\",\n            \"X\"\n        )\n        val counter = new mutable.HashMap[Long,\
    \ String]()\n        val roman = new mutable.Stack[String]()\n\n        while\
    \ (number > 0) {\n            val remainder = number % 10\n            number\
    \ /= 10\n            counter(remainder) += 1\n        }\n\n        roman.clear()\n\
    \        counter.foreach { case (counter, romanNumeral) =>\n            roman.append(romanNumeral)\n\
    \            while (counter > 0) {\n                roman.push(\"I\")\n      \
    \          counter -= 1\n            }\n        }\n\n        val miniRoman = roman.toArray.mkString\n\
    \        miniRoman.toUpperCase", "        var roman = new mutable.HashMap[Long,\
    \ String]();\n        roman.put(0l, \"i\");\n        roman.put(1l, \"i\");\n \
    \       roman.put(2l, \"iix\");\n        roman.put(3l, \"iix\");\n        roman.put(4l,\
    \ \"iix\");\n        roman.put(5l, \"iv\");\n        roman.put(6l, \"iv\");\n\
    \        roman.put(7l, \"v\");\n        roman.put(8l, \"v\");\n        roman.put(9l,\
    \ \"vi\");\n        roman.put(10l, \"vi\");\n        roman.put(11l, \"vii\");\n\
    \        roman.put(12l, \"vii\");\n        roman.put(13l, \"vii\");\n        roman.put(14l,\
    \ \"vii\");\n        roman.put(15l, \"vii\");\n        roman.put(16l, \"vii\"\
    );\n        roman.put(17l, \"vii\");\n        roman.put(18l, \"vii\");\n     \
    \   roman.put(19l, \"vii\");\n        roman.put(20l, \"vi\");\n        roman.put(21l,\
    \ \"vi\");\n        roman.put(22l, \"vi\");\n        roman.put(23l, \"vi\");\n\
    \        roman.put(24l, \"v\");\n        roman.put(25l, \"v\");\n        roman.put(26l,\
    \ \"v\");\n        roman.put(27l, \"v\");\n        roman.put(28l, \"v\");\n  \
    \      roman.put(29l, \"vi\");\n        roman.put(30l, \"vi\");\n        roman.put(31l,\
    \ \"vi\");\n        roman.put(32l, \"vi\");\n        roman.put(33l, \"vi\");\n\
    \        roman.put(34l, \"vi\");\n        roman.put(35l, \"vi\");\n        roman.put(36l,\
    \ \"vi\");\n        roman.put(37l, \"vi\");\n        roman.put(38l, \"vi\");\n\
    \        roman.put(39l, \"vi\");\n        roman.put(40l, \"vi\");\n        roman.put(41l,\
    \ \"vi\");\n        roman.put(42l, \"vi\");\n        roman.put(43l, \"vi\");\n\
    \        roman.put(44l, \"vi\");\n        roman", "        val romanNumbers =\
    \ mutable.ArrayBuffer.empty[String]\n        val romanNumerals = mutable.ArrayBuffer.empty[String]\n\
    \        romanNumerals += \"M\"\n        romanNumerals += \"CM\"\n        romanNumerals\
    \ += \"D\"\n        romanNumerals += \"CD\"\n        romanNumerals += \"C\"\n\
    \        romanNumerals += \"XC\"\n        romanNumerals += \"L\"\n        romanNumerals\
    \ += \"XL\"\n        romanNumerals += \"X\"\n        romanNumerals += \"IX\"\n\
    \        romanNumerals += \"V\"\n        romanNumerals += \"IV\"\n        romanNumerals\
    \ += \"I\"\n        var romanDigits = scala.collection.mutable.ArrayBuffer.empty[String]\n\
    \        var romanString = \"\"\n        val factors = scala.collection.mutable.ArrayBuffer.empty[Long]\n\
    \        factors += 2\n        factors += 3\n        factors += 5\n        factors\
    \ += 10\n        factors += 50\n        factors += 100\n        factors += 500\n\
    \        factors += 1000\n        while(number > 0) {\n            val currentFactor\
    \ = number % factors\n            number /= factors\n            factors -= currentFactor\n\
    \            romanDigits += romanNumerals(currentFactor)\n        }\n        romanDigits\
    \ ++= romanNumerals.reverse.dropWhile(_.isNotEmpty)\n        romanDigits ++= romanNumerals.reverse.takeWhile(_.isEmpty)\n\
    \        romanDigits ++= romanNumerals.reverse.drop(romanNumerals.length).take(romanNumerals.length)\n\
    \        romanString += romanDigits.reverse.mkString(\"\")\n        return romanString.toLowerCase",
  "        val miniRomanStrings = List(\n            (\"M\", 1000),\n            (\"\
    CM\", 900),\n            (\"D\", 500),\n            (\"CD\", 400),\n         \
    \   (\"C\", 100),\n            (\"XC\", 90),\n            (\"L\", 50),\n     \
    \       (\"XL\", 40),\n            (\"X\", 10),\n            (\"IX\", 9),\n  \
    \          (\"V\", 5),\n            (\"IV\", 4),\n            (\"I\", 1)\n   \
    \     )\n        // Keep track of the current total and current power\n      \
    \  var totalPower = 1\n        var currentTotal = 0\n        // Convert the number\
    \ into roman numerals using recursion\n        def convertRecursively(numerals\
    \ : List[Long], currentTotal : Long) : String = {\n            // Exit the recursion\
    \ base case (numerals is empty)\n            if (numerals.isEmpty) {\n       \
    \         if (currentTotal > 9) {\n                    return (currentTotal)\n\
    \                } else {\n                    return (currentTotal.toString)\n\
    \                }\n            }\n            // Get the next number in the numeral\
    \ list and convert it\n            var nextNum = numerals.head\n            numerals.head\
    \ = numerals.tail.head\n            currentTotal += nextNum\n            // Recursively\
    \ convert the next number in numerals\n            var nextNumRoman = convertRecursively(numerals.tail,\
    \ currentTotal)\n            // Return the converted number and the remaining\
    \ numeral list\n            return (nextNumRoman + nextNum.toString)\n       \
    \ }\n        // Convert the number into roman numerals using a loop\n        def\
    \ convertLoop(number : Long) : String = {\n            // Keep track of the current\
    \ total and current power\n            var totalPower = 1\n            var currentTotal\
    \ = 0\n            // Convert the number into roman numerals using loop\n    \
    \        while (currentTotal < number) {\n                currentTotal += 2\n\
    \                // Add the next number to the current total\n               \
    \ currentTotal += (number / currentTotal).toInt\n                // Update the\
    \ power\n                totalPower *= 3\n            }\n            // Convert\
    \ the number into roman numerals using recursion\n            var nextNumRoman\
    \ = convertRecursively(List(number), currentTotal)\n            // Return the\
    \ converted number and the remaining numeral list\n            return (nextNumRoman\
    \ + nextNum.toString)\n        }\n        // Return the result from the two methods\n\
    \        val result = convertLoop(number)\n        val expectedResult = miniRomanStrings.foldLeft(\"\
    \")((res, e) => res + e._1)\n        assert(result == expectedResult)\n      \
    \  \"\"", "        val romanList = List(\"M\", \"D\", \"C\", \"L\", \"X\", \"\
    V\", \"I\")\n        val romanMapList = List((\"M\", 1000), (\"D\", 500), (\"\
    C\", 100), (\"L\", 50), (\"X\", 10), (\"V\", 5), (\"I\", 1))\n        val num\
    \ = number.toInt\n        val intMap = (romanMapList.reverse zip romanMapList).toMap\n\
    \n        val romanStr = (romanList.filter { romanMapList.forall { case (roman,\
    \ amt) => num mod amt == 0 }}).reverse\n        val romanStrList = romanStr.filter\
    \ { romanStr => romanStr != \"I\"}\n        val numOfRomanStr = romanStrList.size\n\
    \        val intNum = num - numOfRomanStr\n        val intMapReverse = intMap.reverse\n\
    \        val intMapStr = (intMapReverse._2 zip intMapReverse._1).filter { case\
    \ (roman, amt) => numOfRomanStr mod amt == 0 }.reverse\n        val intMapStrList\
    \ = intMapStr.filter { intMapStr => intMapStr != \"I\"}\n        val intMapStrListSize\
    \ = (intMapStrList.length + 1)/2\n        val intMapStrListLength = intMapStrList.length\n\
    \        val intMapStrListOffset = intMapStrList.length - (intMapStrListSize -\
    \ 1)\n        val intMapStrListOffsetOffset = (intMapStrListOffset + intMapStrListOffset)/2\n\
    \        val intMapStrListOffsetLen = intMapStrListOffset - intMapStrListOffsetOffset\n\
    \        val intMapStrListLen = intMapStrListLength - intMapStrListOffsetLen\n\
    \        val intMapStrListLenLen = intMapStrListLen / 2\n        val intMapStrListLenLen\
    \ = intMapStrListLen - (intMapStrListLenLen-1)\n        val intMapStrListLenOffset\
    \ = intMapStrListLen - (intMapStrListLenLen-1)\n        val intMapStrListLenOffsetOffset\
    \ = intMapStrListLenOffset - intMapStrListLenLen\n        val intMapStrListLenOffsetLen\
    \ = intMapStrListLenOffset - intMapStrListLenOffsetOffset\n        val intMapStrListLenOffsetLenOffset\
    \ = intMapStrListLenOffsetLen - intMapStrListLenOffsetOffset\n        val intMapStrListLenOffsetLen",
  "        var nStr = \"\"\n        var i = number.toInt\n\n        // Convert i to\
    \ the corresponding Roman numeral\n        while (i>0)\n        {\n          \
    \  nStr = String.valueOf(i%10)+nStr\n            i = (i/10).toInt\n        }\n\
    \n        // Convert to lowercase\n        nStr.toLowerCase()", "        val roman\
    \ = mutable.ArrayBuffer(\"\",\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\"\
    ,\"X\",\"IX\",\"V\",\"IV\",\"I\")\n        val decimal = number / 1000d\n    \
    \    val num = number % 1000d\n        if (num == 0) roman(0)\n        else {\n\
    \            var n = (num / 100d).toInt\n            roman(n) = roman(n-1) + \"\
    H\"\n        }\n        roman(n+1).reverse", "        val num = (number / (1000l))\
    \ % 100\n        val roman = num.toString.toList.map(num => {\n            val\
    \ mod10 = ((num / 10) % 10)\n            val mod5 = ((num / 5) % 10)\n       \
    \     val mod3 = ((num % 10))\n            val mod1 = ((num % 5))\n          \
    \  val mod2 = num % 10\n            val s = if (mod1 == 0) \"i\" else if (mod1\
    \ == 1) \"v\" else if (mod1 == 2) \"x\" else \"\"\n            val m = \"M\" *\
    \ mod1\n            val t = \"C\" * mod2\n            val h = \"H\" * mod3\n \
    \           val d = \"D\" * mod5\n            val c = \"C\" * mod10\n        \
    \    val ms = if (mod10 == 0) \"m\" else if (mod10 == 1) \"cm\" else if (mod10\
    \ == 2) \"cd\" else if (mod10 == 3) \"dc\" else \"\"\n            val ts = if\
    \ (mod5 == 0) \"t\" else if (mod5 == 1) \"tc\" else if (mod5 == 2) \"cd\" else\
    \ if (mod5 == 3) \"d\" else \"\"\n            val hs = if (mod3 == 0) \"h\" else\
    \ if (mod3 == 1) \"ch\" else if (mod3 == 2) \"xc\" else if (mod3 == 3) \"x\" else\
    \ \"\"\n            val ds = if (mod2 == 0) \"d\" else if (mod2 == 1) \"dh\" else\
    \ if (mod2 == 2) \"dx\" else if (mod2 == 3) \"d\" else \"\"\n            s + m\
    \ + t + h + d + c + ms + ts + hs\n        }).mkString(\"\")\n        return roman",
  "        var str = \"\"\n        var index = 0\n        var prev = 0\n        while(number\
    \ > 0){\n            val next = number / 1000\n            val remainder = number\
    \ % 1000\n            val temp = (prev*100) + (remainder)\n            prev =\
    \ temp\n            str = temp + str\n            number -= next\n        }\n\
    \        return str.toLowerCase", "        // initialize a mutable string builder\n\
    \        var builder = new StringBuilder();\n        // initialize a mutable string\
    \ array \n        var roman =  Array(\"I\", \"II\", \"III\", \"IV\", \"V\", \"\
    VI\", \"VII\", \"VIII\", \"IX\", \"X\", \"XI\", \"XII\", \"XIII\", \"XIV\", \"\
    XV\", \"XVI\", \"XVII\", \"XVIII\", \"XIX\", \"XX\", \"XXI\", \"XXII\", \"XXIII\"\
    , \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\", \"XXVIII\", \"XXIX\", \"XXX\", \"XXXI\"\
    , \"XXXII\", \"XXXIII\", \"XXXIV\", \"XXXV\", \"XXXVI\", \"XXXVII\", \"XXXVIII\"\
    , \"XXXIX\", \"XL\", \"L\", \"LI\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\",\
    \ \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\"\
    , \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\"\
    , \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\"\
    , \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\"\
    , \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\"\
    , \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\"\
    , \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\"\
    , \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\"\
    , \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\"\
    , \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\"\
    , \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\"\
    , \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\"\
    , \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\"\
    , \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\"\
    , \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\"\
    , \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L", "        var num = 0\n     \
    \   var roman = \"\"\n\n        while (number > 0) {\n            val mod = number\
    \ % 100\n            number /= 100\n            num = num * 10 + mod\n       \
    \ }\n\n        while (num > 0) {\n            val mod = num % 10\n           \
    \ num /= 10\n            roman = roman * mod + chars(mod)\n        }\n\n     \
    \   return roman", "        val nums = scala.collection.mutable.ListBuffer.empty[String]\n\
    \        // Iterate through each digit, adding it to a string in reverse, adding\
    \ to a list\n        for (i <- number toString reverse collect { case '0' => \"\
    M\"; case '1' => \"D\"; case '2' => \"C\"; case '3' => \"L\"; case '4' => \"X\"\
    ; case '5' => \"V\"; case '6' => \"I\"; case '7' => \"V\"; case '8' => \"X\";\
    \ case '9' => \"I\" }) {\n            nums.append(i)\n        }\n        // Return\
    \ string\n        nums.reverse.mkString", "        val roman = mutable.ListBuffer[String]()\n\
    \        for {\n            i <- 0 until number\n            count <- math.max(0,\
    \ math.min(number - i, 12))\n        } roman.append(romanHead(i) + romanTail(count))\n\
    \        roman.foldLeft(\"\")((acc, x) => acc + (x.toChar))", "        def intToRoman(number:\
    \ Long): String = {\n            def romanToInt(string : String) : Int = {\n \
    \               def romanToInt(string : String, i: Int) : Int = {\n          \
    \          def romanToInt(string : String, i : Int, j : Int) : Int = {\n     \
    \                   if (i >= j) i\n                        else romanToInt(string,\
    \ i+1, j)\n                    }\n                    if (i == 1) {\n        \
    \                i.toInt\n                    } else romanToInt(string, 1, 1)\n\
    \                }\n                if (string.length < 1) 1\n               \
    \ else {\n                    romanToInt(string, string.length-1, 0)\n       \
    \         }\n            }\n            var roman = \"\"\n            while (number\
    \ > 0) {\n                val digit = number % 100\n                roman ++=\
    \ digitToRoman(digit)\n                number /= 100\n            }\n        \
    \    roman\n        }\n        def digitToRoman(digit: Int): String = {\n    \
    \        if (digit == 0) \"\"\n            else {\n                if (digit ==\
    \ 1) \"m\" //singular\n                else if (digit == 2) \"cm\" //dual\n  \
    \              else if (digit == 3) \"dam\" //tridual\n                else if\
    \ (digit == 4) \"x\" //quinary\n                else if (digit == 5) \"xx\" //sex\n\
    \                else if (digit == 6) \"l\" //double\n                else if\
    \ (digit == 7) \"c\" //triple\n                else if (digit == 8) \"dc\" //quint\n\
    \                else if (digit == 9) \"cm\" //septic\n                else \"\
    \"\n            }\n        }\n        var roman = intToRoman(number)\n       \
    \ roman = roman.substring(0,roman.length-1)\n        return roman", "        var\
    \ roman = \"\"\n        val numToRoman = (100d -> \"M\", \n                  \
    \      1000d -> \"D\", \n                        10000d -> \"C\", \n         \
    \               100000d -> \"L\", \n                        1000000d -> \"X\"\
    , \n                        1000000000d -> \"V\", \n                        100000000000d\
    \ -> \"I\")\n        while(number > 0) {\n            roman += numToRoman(number\
    \ % 10)\n            number /= 10\n        }\n        roman", "        val arr\
    \ : Array[String] = number match {\n            case n if n < 1000000 -> {\n \
    \               val roman = n.toString.toCharArray.map(c => \n               \
    \     if (c.toInt < 58) c.toString else c.toString + \"m\")\n                roman.map(c\
    \ => c + \"c\").mkString(\"\")\n            }\n            case n if n < 1000000000\
    \ -> {\n                val roman = n.toString.toCharArray.map(c => \n       \
    \             if (c.toInt < 58) c.toString else c.toString + \"m\")\n        \
    \        roman.map(c => c + \"c\").mkString(\"\")\n            }\n           \
    \ case n if n < 1000000000000 -> {\n                val roman = n.toString.toCharArray.map(c\
    \ => \n                    if (c.toInt < 58) c.toString else c.toString + \"m\"\
    )\n                roman.map(c => c + \"c\").mkString(\"\")\n            }\n \
    \           case n if n < 1000000000000000 -> {\n                val roman = n.toString.toCharArray.map(c\
    \ => \n                    if (c.toInt < 58) c.toString else c.toString + \"m\"\
    )\n                roman.map(c => c + \"c\").mkString(\"\")\n            }\n \
    \           case n if n < 1000000000000000000 -> {\n                val roman\
    \ = n.toString.toCharArray.map(c => \n                    if (c.toInt < 58) c.toString\
    \ else c.toString + \"m\")\n                roman.map(c => c + \"c\").mkString(\"\
    \")\n            }\n            case n if n < 1000000000000000000000 -> {\n  \
    \              val roman = n.toString.toCharArray.map(c => \n                \
    \    if (c.toInt < 58) c.toString else c.toString + \"m\")\n                roman.map(c\
    \ => c + \"c\").mkString(\"\")\n            }\n            case n if n < 100000000000000000000000\
    \ -> {\n                val roman = n.toString.toCharArray.map(c => \n       \
    \             if (c.toInt < 58) c.toString else c.toString + \"m\")\n        \
    \        roman.map(c => c + \"c\").mkString(\"\")\n            }\n           \
    \ case n if n < 1000000000000000000000000 -> {\n                val roman = n.toString.toCharArray.map(c\
    \ => \n                    if (c.toInt < 58) c.toString else c.toString + \"m\"\
    )\n                roman.map(c => c + \"c\").mkString(\"\")\n            }\n \
    \           case n if n < 1000000000000000000000000000 -> {\n                val\
    \ roman = n.toString.toChar", "        val romanValues = List(\n            new\
    \ LongList(\"M\", 1000),\n            new LongList(\"CM\", 900),\n           \
    \ new LongList(\"D\", 500),\n            new LongList(\"CD\", 400),\n        \
    \    new LongList(\"C\", 100),\n            new LongList(\"XC\", 90),\n      \
    \      new LongList(\"L\", 50),\n            new LongList(\"XL\", 40),\n     \
    \       new LongList(\"X\", 10),\n            new LongList(\"IX\", 9),\n     \
    \       new LongList(\"V\", 5),\n            new LongList(\"IV\", 4),\n      \
    \      new LongList(\"I\", 1)\n        )\n        val remainder = number % 1000\n\
    \        val quotient = number / 1000\n        for (value <- romanValues) {\n\
    \            if (value.first == quotient) {\n                return value.last\
    \ + intToMiniRoman(remainder)\n            } else if (value.first > quotient &&\
    \ remainder >= value.last) {\n                return value.first + intToMiniRoman(remainder)\n\
    \            }\n        }\n        throw new IllegalArgumentException(s\"Unknown\
    \ integer $number\")", "        // First, get the largest numeral and count of\
    \ digits.\n        val largest = math.pow(10, number.toInt)\n        val digits\
    \ = number % largest\n        val numberOfDigits = digits.toInt\n\n        //\
    \ Second, find the largest integer less than or equal to 'largest' that has 'numberOfDigits'\
    \ digits\n        val largestInRange = largest / numberOfDigits\n        val nextLargest\
    \ = largestInRange * numberOfDigits\n        val nextLargestInRange = nextLargest\
    \ / numberOfDigits\n        val nextNextLargest = nextLargestInRange * numberOfDigits\n\
    \n        // Third, find the first integer greater than or equal to 'largest'\
    \ that is smaller than or equal to 'nextNextLargest'\n        val nextLargestInRangeInRange\
    \ = nextNextLargest / numberOfDigits\n        val firstLargestInRange = nextLargestInRangeInRange\
    \ * numberOfDigits\n\n        // Fourth, find the corresponding numerals for the\
    \ first integer\n        val numerals = (0 until firstLargestInRange).map(i =>\
    \ if (i == 0) \"M\" else if (i == 1) \"D\" else \"C\")\n\n        // Fifth, append\
    \ the string to the numerals string\n        numerals.reverse.mkString + numerals.head\n",
  "        if(number < 1l) throw new IllegalArgumentException(\"number must be positive\"\
    )\n        if(number > 1000) throw new IllegalArgumentException(\"number too large\"\
    )\n        def romanDigit(d: Long): String = {\n            if(d == 999l) 999\n\
    \            if(d == 99l) c\n            if(d == 9l) \"x\"\n            else if(d\
    \ == 9000l) c\n            else {\n                if(d == 8l) l\n           \
    \     else if(d == 800l) c\n                else if(d == 80l) l\n            \
    \    else if(d == 7l) i\n                else if(d == 70l) i\n               \
    \ else if(d == 6l) i\n                else if(d == 600l) i\n                else\
    \ if(d == 5l) i\n                else if(d == 500l) i\n                else if(d\
    \ == 4l) i\n                else if(d == 400l) i\n                else if(d ==\
    \ 3l) i\n                else if(d == 300l) i\n                else if(d == 2l)\
    \ i\n                else if(d == 20l) i\n                else if(d == 10l) i\n\
    \                else if(d == 1l) i\n                else if(d == 100l) i\n  \
    \              else if(d == .1d) i\n                else if(d == .10d) i\n   \
    \             else if(d == .05d) i\n                else if(d == .01d) i\n   \
    \             else c\n            }\n        }\n        def romanDigits(d: Long):\
    \ String = {\n            if(d == 999l) 999\n            if(d == 99l) c\n    \
    \        if(d == 9l) \"x\"\n            else if(d == 9000l) c\n            else\
    \ {\n                if(d == 8l) l\n                else if(d == 800l) c\n   \
    \             else if(d == 80l) l\n                else if(d == 7l) i\n      \
    \          else if(d == 70l) i\n                else if(d == 6l) i\n         \
    \       else if(d == 600l) i\n                else if(d == 5l) i\n           \
    \     else if(d == 500l) i\n                else if(d == 4l) i\n             \
    \   else if(d == 400l) i\n                else if(d == 3l) i\n               \
    \ else if(d == 300l) i\n                else if(d == 2l) i\n                else\
    \ if(d == 20l) i\n                else if(d == 10l) i\n                else if(d\
    \ == 1l) i\n                else if(d == 100l) i\n                else if(d ==\
    \ .1d) i\n                else if(d == .10d) i\n                else if(d == .05d)\
    \ i\n                else if(d == .01d) i\n                else c\n          \
    \  }\n        }\n        val r = scala.collection.mutable.ListBuffer.empty[String]\n\
    \        while(number > 0l) {\n            val newDigit = number ", "        val\
    \ result = new mutable.ListBuffer[String]()\n        var remainder = number\n\
    \        var power = 0\n        while(number > 0) {\n            var digit = remainder\
    \ % 10\n            remainder = remainder / 10\n            power = power + 1\n\
    \            number -= digit\n            number -= 1\n            if(digit ==\
    \ 0) {\n                result += (power + \"\").reverse\n                power\
    \ = 0\n            }\n        }\n        result.toList.reverse.mkString(\"M\")",
  "        val numerals = number.toInt/1000 % 10 +\n            (number.toInt/1000\
    \ - numerals).toString.reverse +\n            number.toInt%1000\n        val romans\
    \ = mutable.ArrayBuffer.empty[String]\n        val romanNums = mutable.ArrayBuffer.empty[String]\n\
    \n        // Iterate over each roman numeral. Find the correct roman numeral\n\
    \        // using integer division and remainder.\n        // Then store the roman\
    \ numeral and the integer value for each one\n        // as tuples in a list.\n\
    \        for (i <- 0 until numerals) {\n            romanNums += (numerals % 10).toString.reverse\
    \ +\n                (numerals / 10).toString.reverse +\n                (romans\
    \ ++ romanNums).toList\n            romans = romans +\n                ((numerals\
    \ % 10).toString.reverse +\n                (numerals / 10).toString.reverse +\n\
    \                (romans ++ romanNums).toList)\n            numerals /= 10\n \
    \       }\n        romanNums", "        def toRoman (n       : Int) : String \
    \ = {\n            val remainder = n % 10\n            val digit     = n % 100\n\
    \            val suffix    = \"M\"\n            val first     = (remainder % 100)\
    \ == 0 ? \"C\" : \n                                (remainder % 10) == 0 ? \"\
    L\" : \"D\"\n            (if (digit <= 4) \n                digit.toString + \"\
    M\"\n            else if (digit == 0) \n                first.toString + suffix\n\
    \            else toRoman(digit / 10) + first + suffix)\n        }\n\n       \
    \ if (number < 0 || number > 999)\n            return \"\"\n        else if (number\
    \ == 0) \n            return \"0\"\n        else if (number < 10)\n          \
    \  return number.toString\n        else\n            return toRoman(number).toLowerCase()",
  "        if (number == 0)\n            number\n        else {\n            var i\
    \ = 0\n            var list = new scala.collection.mutable.ListBuffer[String]()\n\
    \            while (i <= number) {\n                val remainder = number % 1000\n\
    \                list += ((remainder / 100) match {\n                    case\
    \ 0 => \"m\"\n                    case 1 => \"b\"\n                    case _\
    \ => \"x\"\n                })\n                number -= remainder\n        \
    \        i += 1\n            }\n            list.toList.reverse.foldLeft(\"\"\
    )((acc, x) => acc + x)\n        }", "        val roman =\n            (number\
    \ toString 'm' filter (_ == '1')) +\n            (number toString 'm' filter (_\
    \ == '3')) +\n            (number toString 'm' filter (_ == '5')) +\n        \
    \    (number toString 'm' filter (_ == '7')) +\n            (number toString 'm'\
    \ filter (_ == '9')) +\n            (number toString 'm' filter (_ == '11')) +\n\
    \            (number toString 'm' filter (_ == '13')) +\n            (number toString\
    \ 'm' filter (_ == '15')) +\n            (number toString 'm' filter (_ == '17'))\
    \ +\n            (number toString 'm' filter (_ == '19')) +\n            (number\
    \ toString 'm' filter (_ == '21')) +\n            (number toString 'm' filter\
    \ (_ == '23')) +\n            (number toString 'm' filter (_ == '25')) +\n   \
    \         (number toString 'm' filter (_ == '27')) +\n            (number toString\
    \ 'm' filter (_ == '29')) +\n            (number toString 'm' filter (_ == '31'))\
    \ +\n            (number toString 'm' filter (_ == '33')) +\n            (number\
    \ toString 'm' filter (_ == '35')) +\n            (number toString 'm' filter\
    \ (_ == '37')) +\n            (number toString 'm' filter (_ == '39')) +\n   \
    \         (number toString 'm' filter (_ == '41')) +\n            (number toString\
    \ 'm' filter (_ == '43')) +\n            (number toString 'm' filter (_ == '45'))\
    \ +\n            (number toString 'm' filter (_ == '47')) +\n            (number\
    \ toString 'm' filter (_ == '49')) +\n            (number toString 'm' filter\
    \ (_ == '51')) +\n            (number toString 'm' filter (_ == '53')) +\n   \
    \         (number toString 'm' filter (_ == '55')) +\n            (number toString\
    \ 'm' filter (_ == '57')) +\n            (number toString 'm' filter (_ == '59'))\
    \ +\n            (number toString 'm' filter (_ == '61')) +\n            (number\
    \ toString 'm' filter (_ == '63')) +\n            (number toString 'm' filter\
    \ (_ == '65')) +\n            (number toString 'm' filter (_ == '67')", "    \
    \    val numberString = number.toString\n        val reversed = ListBuffer(numberString.reverse)\n\
    \        var result = \"error\"\n\n        for (index <- 0 until reversed.size)\
    \ {\n            val numeral = reversed(index).toInt\n            val miniRoman\
    \ = if(numeral >= 1000) {\n                val miniRomanString = numeral / 1000;\n\
    \                val miniRomanStringReversed = ListBuffer(miniRomanString.reverse)\n\
    \                val numRest = numeral % 1000;\n                val rest = ListBuffer(numRest)\n\
    \                for(numRestLength <- 0 until rest.size) {\n                 \
    \   val restStr = rest(numRestLength).toString\n                    val restStringReversed\
    \ = ListBuffer(restStr.reverse)\n                    miniRomanStringReversed :::\
    \ restStringReversed\n                }\n                miniRomanString ::: rest\n\
    \            } else {\n                val roman = numeral.toString\n        \
    \        roman\n            }\n            val miniRomanStringReversed = ListBuffer(miniRoman.reverse)\n\
    \            result ::: miniRomanStringReversed\n        }\n        result", " \
    \       val roman = scala.collection.mutable.ArrayBuffer.empty[String]\n     \
    \   val intToRoman = roman.add(\"\")\n        def intToRoman(n: Long, nAccum :String)\
    \ : String = {\n            if (n < 0) intToRoman(-n, nAccum)\n            else\
    \ if (n < 10) return intToRoman(n, nAccum)\n            else if (n % 10 == 0)\
    \ intToRoman(n / 10, nAccum+RomanNumerals(n % 10).toChar)\n            else intToRoman((n\
    \ / 10) % 10, nAccum+RomanNumerals(n % 10).toChar)\n        }\n        number\
    \ match {\n            case n if n > 1000 && n < 10000 => intToRoman(n, \"i\"\
    )\n            case n if n > 10000 && n < 1000000 => intToRoman(n, \"ii\")\n \
    \           case n if n > 1000000 && n < 1000000000 => intToRoman(n, \"iii\")\n\
    \            case n if n > 1000000000 && n < 10000000000 => intToRoman(n, \"iv\"\
    )\n            case n if n > 10000000000 && n < 1000000000000 => intToRoman(n,\
    \ \"v\")\n            case n if n > 1000000000000 && n < 100000000000000 => intToRoman(n,\
    \ \"vi\")\n            case n if n > 100000000000000 && n < 100000000000000000\
    \ => intToRoman(n, \"vii\")\n            case n if n > 100000000000000000 && n\
    \ < 100000000000000000 => intToRoman(n, \"viii\")\n            case n if n > 100000000000000000\
    \ && n < 100000000000000000 => intToRoman(n, \"ix\")\n            case n if n\
    \ > 100000000000000000 && n < 100000000000000000 => intToRoman(n, \"x\")\n   \
    \         case n if n > 100000000000000000 && n < 100000000000000000 => intToRoman(n,\
    \ \"xii\")\n            case n if n > 100000000000000000 && n < 100000000000000000\
    \ => intToRoman(n, \"xiii\")\n            case n if n > 100000000000000000 &&\
    \ n < 100000000000000000 => intToRoman(n, \"xiv\")\n            case n if n >\
    \ 100000000000000000 && n < 100000000000000000 => intToRoman(n, \"xx\")\n    \
    \        case n if n > 100000000000000000 && n < 100000000000000000 => intToRoman(n,\
    \ \"xxi\")\n            case n if n > 100000000000000000 && n < 100000000000000000\
    \ => intToRoman(n, \"xxii\")\n            case n if n > 100000000000000000 &&\
    \ n < 100000000000000000 => int", "        val romanMap: Map[Long, String] = Map(\n\
    \            1->\"i\",\n            2->\"ii\",\n            3->\"iii\",\n    \
    \        5->\"v\",\n            6->\"vi\",\n            8->\"vii\",\n        \
    \    9->\"ix\",\n            10->\"x\",\n            12->\"xii\",\n          \
    \  14->\"xiii\",\n            16->\"xiv\",\n            17->\"xvi\",\n       \
    \     20->\"xx\"\n        )\n        val numberInRoman = romanMap.get(number).orElse(throw\
    \ new RuntimeException(\"Invalid number \" + number))\n        numberInRoman.toLowerCase",
  "        val roman = scala.collection.mutable.ListBuffer.empty[String]\n       \
    \ var index = 0\n        while (index < number) {\n            roman += scala.math.pow(1000,\
    \ index).toString.toLowerCase\n            index += 1\n        }\n        roman.head\
    \ + (roman.drop(1).reverse.toSeq: _*)", "        val roman = (1l to 1000l).filter(_\
    \ >= number).toList\n        val res = roman.map {\n            case (_, i) =>\
    \ if (number >= i) s\"${number} ${roman.indexOf(_)}\" else s\"${roman.indexOf(_)}\"\
    \n        }.mkString(\"\").toLower\n        return res", "        val roman =\
    \ mutable.Buffer.empty[Char]\n        val base = 1000\n        while (number >\
    \ 0) {\n            val value = number % base\n            roman.append(value)\n\
    \            number /= base\n        }\n        roman.foldLeft(\"\")(_ + _ + _)",
  "      var s = \"\"\n      while (number > 0) {\n        if (number % 1000 > 999)\
    \ {\n          if (number % 1000 < 500) {\n            s += miniRoman(number/1000)\
    \ + \"k\"\n            number %= 1000\n          } else {\n            s += miniRoman(number/100)\
    \ + \"m\"\n            number %= 1000\n          }\n        } else {\n       \
    \   s += miniRoman(number/1000) + \"\"\n          number %= 1000\n        }\n\
    \      }\n      s", "      val numMap = Map(\"M\" -> 1000l, \"D\" -> 500l, \"\
    C\" -> 100l, \"L\" -> 50l, \"X\" -> 10l, \"V\" -> 5l, \"I\" -> 1l)\n      var\
    \ outStr = \"\"\n      var cur = number\n      while(cur > 0) {\n        val numStr\
    \ = numMap.get(cur.floor).toString\n        outStr += numStr.dropRight(1)\n  \
    \      cur = cur - numStr.last\n      }\n      outStr", "        var numeral =\
    \ \"\"\n        var counter = -1\n        var last = 0\n\n        var romanChars\
    \ = scala.collection.mutable.Map[Long, String]()\n\n        for(i <- 0 to 4) {\n\
    \            counter = number.toInt\n            romanChars += (counter -> romanNumToChar(i))\n\
    \        }\n\n        for(i <- romanChars.keys.toList) {\n            val romanNum\
    \ = i\n            val romanChar = romanChars(i)\n\n            if(romanNum >\
    \ 0) {\n                if(number % romanNum == 0) {\n                    numeral\
    \ += romanChar\n                    number /= romanNum\n                } else\
    \ if(number != 0) {\n                    numeral += romanChar\n              \
    \      number = number / romanNum\n                }\n            }\n        }\n\
    \n        if(number > 0) {\n            numeral += romanNumToChar(counter)\n \
    \           numeral += romanNumToChar(number.toInt)\n        }\n\n        numeral.toLowerString",
  "        val nums = number.toString.toInt\n        val letters = mutable.StringBuilder.newBuilder\n\
    \        \n        for (i <- 0 until nums) {\n            val index = nums - i\
    \ - 1\n            val d = index / 100\n            val c = index % 100\n    \
    \        val l = i.toString.charAt(0).toLowerCase\n\n            val r = if (c\
    \ >= 10) \"M\" else if (c >= 5) \"D\" else \"C\"\n            val v = if (d >=\
    \ 10) { if (c == 0) \"M\" else \"CM\" }\n                    else if (d >= 5)\
    \ \"D\" else \"C\"\n\n            val x = if (d >= 10) \"X\" else if (d >= 5)\
    \ \"L\" else \"C\"\n            letters.append(if (d >= 10) l + r else l + r +\
    \ v + x)\n        }\n        letters.result", "        val romanStrings = romanStrings(number)\n\
    \        romanStrings.map(x=>x.toLowerCase).mkString(\"\")", "        var result:\
    \ String = \"\"\n        val digits = scala.collection.mutable.ArrayBuffer(0,\
    \ 4, 9, 13, 27, 40, 51, 60)\n        var i = 1\n        var roman = 0\n      \
    \  while(i <= number) {\n            roman += (number % 10) * i\n            number\
    \ = number / 10\n            i += 1\n        }\n        val romans = scala.collection.mutable.ArrayBuffer(\"\
    \", \"M\", \"MM\", \"MMM\", \"MMMM\", \"MMMMM\", \"MMMMMM\", \"MMMMMMM\", \"MMMMMMMM\"\
    )\n        val length = romans.length\n        var romanLength = 0\n        while(romanLength\
    \ < length) {\n            if(romans[romanLength] == \"\") {\n               \
    \ romanLength += 1\n            } else {\n                break\n            }\n\
    \        }\n        romanLength -= 1\n        while(romanLength > 0) {\n     \
    \       result += romans(romanLength)\n            romanLength -= 1\n        }\n\
    \        while(roman > 0) {\n            if(roman % 1000 == 0) {\n           \
    \     result += \"M\"\n                roman -= 1000\n            } else if(roman\
    \ % 100 == 0) {\n                result += \"D\"\n                roman -= 100\n\
    \            } else if(roman % 10 == 0) {\n                result += \"C\"\n \
    \               roman -= 10\n            } else if(roman == 1) {\n           \
    \     result += \"M\"\n            } else {\n                result += \"M\"\n\
    \            }\n        }\n        return result"]
stop_tokens:
- "\n    }\n"
