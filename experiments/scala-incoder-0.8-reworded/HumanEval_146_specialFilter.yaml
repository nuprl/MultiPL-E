name: HumanEval_146_specialFilter
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Write a function that takes a list of numbers as input and returns \n  \
  \  // the number of elements in the list that are greater than 10 and both \n  \
  \  // first and last digits of a number are odd (1, 3, 5, 7, 9).\n    // For example:\n\
  \    // >>> specialFilter((List[Long](15l.toLong, -73l.toLong, 14l.toLong, -15l.toLong)))\n\
  \    // (1l)\n    // >>> specialFilter((List[Long](33l.toLong, -2l.toLong, -3l.toLong,\
  \ 45l.toLong, 21l.toLong, 109l.toLong)))\n    // (2l)\n    def specialFilter(nums\
  \ : List[Long]) : Long = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(specialFilter((List[Long](5l.toLong,\
  \ -2l.toLong, 1l.toLong, -5l.toLong))) == (0l));\n    assert(specialFilter((List[Long](15l.toLong,\
  \ -73l.toLong, 14l.toLong, -15l.toLong))) == (1l));\n    assert(specialFilter((List[Long](33l.toLong,\
  \ -2l.toLong, -3l.toLong, 45l.toLong, 21l.toLong, 109l.toLong))) == (2l));\n   \
  \ assert(specialFilter((List[Long](43l.toLong, -12l.toLong, 93l.toLong, 125l.toLong,\
  \ 121l.toLong, 109l.toLong))) == (4l));\n    assert(specialFilter((List[Long](71l.toLong,\
  \ -2l.toLong, -33l.toLong, 75l.toLong, 21l.toLong, 19l.toLong))) == (3l));\n   \
  \ assert(specialFilter((List[Long](1l.toLong))) == (0l));\n    assert(specialFilter((List[Long]()))\
  \ == (0l));\n    }\n\n}\n"
completions: ['        nums.filter { x => x > 10 && x.isOdd && x.isOdd }.size', " \
    \       nums.filter(x => x > 10).count(x => x.toString.takeWhile(_ == '1').tail.forall(x\
    \ => x % 2 == 1)) + nums.filter(x => x > 10).count(x => x.toString.takeWhile(_\
    \ == '1').tail.forall(x => x % 2 == 1))", "        var count = 1\n        for\
    \ (nn <- nums) {\n            if (nn.toLong > 10l && nn.toLong % 2 == 1 && nn.toLong\
    \ % 2 == 1) count ++\n        }\n        count", "        val numbers = nums.map(\
    \ _ % 2 == 0 );\n        val evens  = nums.filter(n => n % 2 == 0);\n        val\
    \ firstEven = evens.head\n        val lastEven  = evens.last\n        val firstOdd\
    \ = evens.find(_ % 2 == 1)\n        val lastOdd = evens.find(_ % 2 == 0)\n   \
    \     val evensCount = ( evens diff evens.head ).length\n        val oddsCount\
    \ = ( odds diff odds.last ).length\n        val count = (firstEven + lastEven)\
    \ * (firstOdd + lastOdd)\n        numbers.reduce( _ + _ )", "        require(nums.length\
    \ >= 2)\n        val odds = nums.filter(x => (x % 2) != 0)\n        require(odds.length\
    \ == 2)\n        val first = odds.head\n        val last = odds.last\n       \
    \ require(odds.tail.forall(x => (x % 2) == 0) && odds.head.asInstanceOf[Int] ==\
    \ odds.last.asInstanceOf[Int])\n        if (first > 10 && last > 10 && odds.head\
    \ % 2 == 1) {\n            nums.count(x => x > 10) && odds.tail.forall(x => x\
    \ % 2 == 1)\n        } else {\n            nums.count(x => x > 10) || odds.tail.forall(x\
    \ => x % 2 == 1)\n        }", "        var count = 0\n        nums.foreach{i =>\
    \ \n            if (i>10 && i%2==0 && i/10==i%10){\n                count = count+1\n\
    \            }\n        }\n        count", '      nums.filter( x => x > 10l).filter(
    x => (x % 2) == 1).filter( x => (x % 2) != 0).count', "      val odd = mutable.Buffer[Long]()\n\
    \      \n      // Step 1: \n      //    Iterate through the list\n      //   \
    \ If element is a Long, add it to the odd list\n      //    If element is anything\
    \ else, throw an exception\n      //    \n      \n      // Step 2: \n      //\
    \    Iterate through the list\n      //    If element is a Long, remove first\
    \ digit from element\n      //    If element is a Long, remove last digit from\
    \ element\n      //    If element is a Long, add it to the odd list\n      //\
    \    If element is anything else, throw an exception\n      //    \n      \n \
    \     odd.size", "        nums.toList flatMap { n =>\n            val oddFirst\
    \ = n % 10 % 2 != 0\n            val oddLast = n % 10 != 0\n            if (n\
    \ > 10 && oddFirst && oddLast)\n                Some(n)\n            else\n  \
    \              None\n        }.size ", "        val n = nums.count(_ > 10)\n \
    \       val m = nums.filter(_ % 2 != 0).length\n        val f = nums.filter(_\
    \ % 2 == 0).last\n        val odd = (f.toString.charAt(f.toString.length() - 1).toChar\
    \ == '1')\n        (n - m) < (n - 1) * ((n - 1) * (odd ? 2 : 1)) + (m - f) < (m\
    \ - 1) * ((m - 1) * (odd ? 2 : 1))", "        var count = 0\n        for (num\
    \ <- nums)\n        {\n            if (num > 10 && num.firstDigit % 2 == 1 &&\
    \ num.lastDigit % 2 == 1)\n                count += 1\n        }\n        count",
  "        var count = 0\n        nums.foreach { number =>\n            if (number.toString.toLong\
    \ > 10 && number.toString.toLong % 2 == 0) {\n                if (number.toString.toLong\
    \ % 2 != 0 && number.toString.toLong % 2 != 1) {\n                    count +=\
    \ 1\n                }\n            }\n        }\n        count", "        val\
    \ even = nums.filter{ x => x.toInt % 2 == 0 }\n        val odd = nums.filter{\
    \ x => x.toInt % 2 != 0 }\n        val odd_even = odd.filter{ x => x.toInt % 2\
    \ == 0 }\n        val odd_odd = odd.filter{ x => x.toInt % 2 != 0 }\n\n      \
    \  if (odd_even.size == 0) 1\n        else if (odd_odd.size == 0) 2\n        else\
    \ odd_even.size + odd_odd.size", "        val filteredList = nums.filter(num=>\
    \ num > 10 && num % 2 == 0 && num % 2 != 0)\n        val firstOdd = filteredList.head\n\
    \        val lastOdd = filteredList.last\n        val result = (lastOdd - firstOdd)\
    \ / 2 + firstOdd\n        return result", "        val odd = nums.find(_ % 2 ==\
    \ 1).toList\n        val first = nums.find(_ % 2 == 0).toList\n        nums.filter(x\
    \ => x > 10).count(x => odd.contains(x) && first.contains(x))", "        nums.count(_.toString.toLong\
    \ > 10) && (nums.exists(_ % 2 == 1) && nums.exists(_ % 2 == 0)).fold(0l) {\n \
    \           (nums, nums.length) => (nums, nums.length + 1)\n        }._1", " \
    \       val even = nums.filter(x => x%2==0).size\n        val odd = nums.filter(x\
    \ => x%2==1).size\n        val firstOdd  = nums.filter(x => x%3==1).size\n   \
    \     val lastOdd  = nums.filter(x => x%3==0).size\n        return (even + odd)\
    \ + (firstOdd + lastOdd)", "        if (nums.isEmpty) return 0\n        var count\
    \ = 0\n        for (x <- nums) {\n            if (x > 10) count += 1\n       \
    \     if (x % 2 == 0 && x % 2 != 1) count += 1\n        }\n        count", " \
    \       var count = 0\n        for (n <- nums) {\n            if (n > 10l) {\n\
    \                for (i <- 0 until n.toString.length) {\n                    if\
    \ (n.toString.charAt(i) == '1') count += 1\n                }\n            } else\
    \ {\n                for (i <- 0 until n.toString.length) {\n                \
    \    if (n.toString.charAt(i) == '1') count += 1\n                }\n        \
    \    }\n        }\n        count", "        \n        def oddNumber(x : Long)\
    \ : Boolean = {\n            if (x % 2 == 0) true\n            else false\n  \
    \      }\n        \n        def oddFirst(x : Long) : Boolean = {\n           \
    \ if (x % 2 != 0 && x % 2 == 1) true\n            else false\n        }\n    \
    \    \n        def oddLast(x : Long) : Boolean = {\n            if (x % 2 != 0\
    \ && x % 2 != 1 && x % 2 != 0) true\n            else false\n        }\n     \
    \   \n        def oddAndFirst(x : Long) : Boolean = {\n            if (x % 2 !=\
    \ 0 && x % 2 == 1) true\n            else false\n        }\n        \n       \
    \ def oddAndLast(x : Long) : Boolean = {\n            if (x % 2 != 0 && x % 2\
    \ != 1 && x % 2 != 0) true\n            else false\n        }\n        \n    \
    \    var count : Long = 0\n        \n        for (x <- nums) {\n            if\
    \ (oddNumber(x)) {\n                if (oddFirst(x)) {\n                    if\
    \ (oddLast(x)) {\n                        if (oddAndFirst(x)) {\n            \
    \                if (oddAndLast(x)) count+=1\n                        } else count+=1\n\
    \                    } else count+=1\n                } else count+=1\n      \
    \      } else count+=1\n        }\n        \n        return count", "        var\
    \ evenCounter = 0\n        var oddCounter = 0\n        for (i<- nums){\n     \
    \       if (i % 2 == 0){\n                evenCounter += 1\n            }\n  \
    \          else {\n                oddCounter += 1\n            }\n        }\n\
    \        if (evenCounter >= 2 && oddCounter >= 2) {\n            evenCounter *\
    \ oddCounter\n        }\n        else {\n            0\n        }", "        var\
    \ count : Long = 0\n        var firstDigit : Long = 0\n        var lastDigit :\
    \ Long = 0\n        for( x <- nums) {\n            if(x>10 && firstDigit % 2 ==\
    \ 1 && lastDigit % 2 == 1) {\n                count += 1\n            }\n    \
    \        firstDigit = x / 10 % 10\n            lastDigit = x % 10\n        }\n\
    \        count", '      nums.count(x => x > 10 && nums.last.mod(2) == 1 && nums.head.mod(2)
    == 1) ', "        var count = 0;\n        var lastOdd = nums.last.asInstanceOf[Int]\
    \ % 2 != 0;\n        for {\n            first <- nums.headOption;\n          \
    \  last <- nums.lastOption;\n            if ((first.asInstanceOf[Int] + last.asInstanceOf[Int]).asInstanceOf[Int]\
    \ > 10) {\n                count = count + 1;\n            }\n        } while\
    \ (lastOdd);\n        count ", "        if(nums.isEmpty) return 0\n        var\
    \ count = 0\n        var first = nums(0).toInt\n        var last = nums(nums.length-1).toInt\n\
    \        for(i <- 0 until nums.length) {\n            if(nums(i) > 10) {\n   \
    \             if(nums(i) % 2 == 1 && first % 2 == 1 && last % 2 == 1) count+=1\n\
    \            }\n        }\n        count", "        var oddDigit = 0\n       \
    \ var firstEvenDigit = 0\n        var lastEvenDigit = 0\n        var firstEvenOdd\
    \ = 0\n        var lastEvenOdd = 0\n        var firstOdd = 0\n        var lastOdd\
    \ = 0\n        for (n <- nums) {\n            oddDigit += n % 10\n           \
    \ lastOdd += n % 10\n            firstOdd += n / 10\n            lastEvenOdd +=\
    \ n / 10\n            firstEvenOdd += n / 10\n            lastEvenDigit += n %\
    \ 10\n            firstEvenDigit += n / 10\n            lastEvenDigit += n % 10\n\
    \        }\n        return (oddDigit / 2 + (firstEvenOdd % 2) + (lastEvenOdd %\
    \ 2)) / 3", "        val listEven = nums.filter(_ % 2 == 0)\n        listEven.size",
  "        val counts = nums.map{n => if(n > 10l) 1L else 0L}.groupBy(_).mapValues(_.length)\n\
    \        if (counts.contains(\"1\"))\n            1\n        else if (counts.contains(\"\
    2\"))\n            2\n        else\n            0", "        nums.filter(i =>\
    \ i >= 10).count { i => \n            i % 2 == 1 && \n            i / 10 % 2 ==\
    \ 1 && \n            i / 100 % 2 == 1 && \n            i / 1000 % 2 == 1 && \n\
    \            i / 10000 % 2 == 1 && \n            i / 100000 % 2 == 1 && \n   \
    \         i / 1000000 % 2 == 1 && \n            i / 10000000 % 2 == 1 && \n  \
    \          i / 100000000 % 2 == 1 && \n            i / 1000000000 % 2 == 1 &&\
    \ \n            i / 10000000000 % 2 == 1 && \n            i / 100000000000 % 2\
    \ == 1 && \n            i / 1000000000000 % 2 == 1 && \n            i / 10000000000000\
    \ % 2 == 1 && \n            i / 100000000000000 % 2 == 1 && \n            i /\
    \ 1000000000000000 % 2 == 1 && \n            i / 10000000000000000 % 2 == 1 &&\
    \ \n            i / 100000000000000000 % 2 == 1 && \n            i / 1000000000000000000\
    \ % 2 == 1 && \n            i / 10000000000000000000 % 2 == 1 && \n          \
    \  i / 100000000000000000000 % 2 == 1 && \n            i / 1000000000000000000000\
    \ % 2 == 1 && \n            i / 10000000000000000000000 % 2 == 1 && \n       \
    \     i / 100000000000000000000000 % 2 == 1 && \n            i / 1000000000000000000000000\
    \ % 2 == 1 && \n            i / 10000000000000000000000000 % 2 == 1 && \n    \
    \        i / 100000000000000000000000000 % 2 == 1 && \n            i / 1000000000000000000000000000\
    \ % 2 == 1 && \n            i / 10000000000000000000000000000 % 2 == 1 && \n \
    \           i / 100000000000000000000000000000 % 2 == 1 && \n            i / 1000000000000000000000000000000\
    \ % 2 == 1 && \n            i / 10000000000000000000000000000000 % 2 == 1 && \n\
    \            i / 100000000000000000000000000000000 % 2 == 1 && \n            i\
    \ / 1000000000000000000000000000000000 % 2 == 1 && \n            i / 10000000000000000000000000000000000\
    \ % 2 == 1 && \n            i / 100000000000000000000000000000000000 % 2 == 1\
    \ && \n            i / 1000000000000000000000000000000000000 % 2 == 1 && \n  \
    \          i / 10000000000000000000000000000000000000 % 2 == 1 && \n         \
    \   i / 100000000000000000000000000000000000000 % 2 == 1 && \n            i /\
    \ 1000000000000000000000000000000000000000 % 2 == 1 && \n            i / 10000000000000000000000000000000000000000\
    \ % 2 == 1 && \n            i / 100000000000000000000000000000000000000000 % 2\
    \ == 1 && \n            i / 1000000000000000000000000000000000000000000 % 2 ==\
    \ 1 && \n            i / 100000000000000000000000000000000000 % 2 == 1 && \n \
    \           i / 1000000000000000000000000000000000000 % 2 == 1 && \n         \
    \   i / 10000000000", '        nums.filter(x=>x>10 && ((x % 1).toInt % 2).toLong
    == (x % 1).toInt).size', "        require(nums.nonEmpty)\n        val n = nums.head\n\
    \        val odd = nums.dropWhile(x => x < 10).last\n        val odd_digit = nums.filter(_\
    \ % 10 == 0)\n        if (odd_digit.last % 2 == 1)\n            n - odd\n    \
    \    else\n            n - 10", "        val numsAsString = nums.mkString(\"[\"\
    , \",\", \"]\")\n        nums.count(_ > 10) && nums.last.asDigit.isOdd && nums.head.asDigit.isOdd\
    \ && (nums.mkString.toInt % 2) != 0", "        val odd = nums.filter(x => (x.toInt\
    \ % 2).toDouble == 1.0)\n        odd.length", '        nums.count(n => n.toInt
    > 10 && n.toInt == n.toInt.&(1))', "        val numsFiltered = nums.filter(x =>\
    \ x > 10).flatMap(x => List(x, x / 10)).groupBy(x => x / 10).mapValues(x => x.size)\n\
    \        val odd = numsFiltered.filter(x => x._2 == 1 && x._3 % 2 != 0).map(_._1).sum\n\
    \        numsFiltered.filter(_._2 == 1 || _._2 == odd).map(_._1).sum", "     \
    \   val ns = nums\n        ns.count(num) =>\n            ((num % 10l > 10l) \n\
    \                && ((num % 10l%2 == 1l)\n                    && ((num % 10l%2\
    \ == 1l) && (num.last%2 == 1l)))\n                    && ((ns.head % 10l%2 ==\
    \ 1l)\n                        && (ns.last%2 == 1l)))", "        val numsGreaterThan10\
    \ = nums.filter{n => n > 10}\n        val numsFirstAndLastOdd = numsGreaterThan10.filter{\
    \ n =>\n                val last = n % 10\n                (last % 2 == 1) &&\
    \ last > 0\n            }\n        return numsFirstAndLastOdd.length", "     \
    \   val numsM = nums.filter(num => num > 10)\n        numsM.size", "        val\
    \ counter: mutable.Map[Long, Int] = mutable.Map.empty[Long, Int]\n        for\
    \ (n <- nums) {\n            val l = n.toLong\n            if (l % 2 != 0 && l\
    \ % 1 != 0) {\n                counter(l) = 0\n            }\n            counter(l)\
    \ += 1\n        }\n        counter.filter(_._2 == 1).size", "        val ans =\
    \ nums.filter(x => x > 10 && x % 2 == 1 && x % 3 == 1)\n        ans.length", '      nums.filter(x
    => x > 10 and x % 2 != 0 && (x % 10 == 1)).length', "        val ns = nums.filter(_\
    \ % 2 == 1).map(_ / 2)\n        if (ns.size > 1)\n            ns.count(x => x\
    \ > 10) && (ns.head % 2 == 1 && (ns.last % 2 == 1))\n        else\n          \
    \  ns.head > 10", "        if (nums.isEmpty) {\n            return 0\n       \
    \ }\n        \n        var count : Long = 0\n        \n        var first = nums.head\n\
    \        \n        while (count < nums.size) {\n            var last = nums.last\n\
    \            \n            while (last > 10) {\n                last = last.abs\n\
    \            }\n            \n            if (first % 2 != 0 && last % 2 != 0)\
    \ {\n                count += 1\n            }\n            \n            nums\
    \ = nums.tail\n            first = nums.head\n        }\n        \n        count",
  '        nums.filter(_ > 10).length', '        nums.filter { n => n > 10 && n.toString.charAt(0)
    % 2 == 1 && n.toString.charAt(n.toString.length-1)%2 == 1 }.size', "        var\
    \ count = 0\n        for (n <- nums if n.toString.length > 1) {\n            if\
    \ (n.toString.charAt(0).toInt == 1 && (n.toString.charAt(1).toInt == 1 || n.toString.charAt(1).toInt\
    \ == 3)\n                    && (n.toString.charAt(2).toInt == 1 || n.toString.charAt(2).toInt\
    \ == 3)) {\n                count += 1\n            }\n        }\n        count ",
  "        val sum = 0\n        for(num <- nums) {\n            sum += num\n     \
    \       if(num > 10l){\n                val last = num % 10\n                if(last.equals(1))\
    \ {\n                    sum += 1\n                }\n                if(last.equals(3))\
    \ {\n                    sum += 1\n                }\n            }\n        }\n\
    \        sum", "        var sum = 0\n        for (i <- nums) {\n            if\
    \ (i > 10) {\n                if (i % 2 == 0) {\n                    sum += i\n\
    \                }\n            } else {\n                if (i % 2 != 0) {\n\
    \                    sum += i\n                }\n            }\n        }\n \
    \       return sum", "        var count = 0\n        var i = 1 // iterate over\
    \ the first element\n        while(i < nums.length) {\n            if(nums(i)\
    \ > 10) {\n                if(nums(i) % 2 == 1) {\n                    count +=\
    \ 1\n                }\n                i += (nums(i) - 10) / 2\n            }\n\
    \            else {\n                i += 1\n            }\n        }\n      \
    \  count", "        val set1 = Set(nums.takeWhile(_ > 10).toSet)\n        val\
    \ set2 = Set(nums.last.asInstanceOf[Int] - nums.head.asInstanceOf[Int])\n    \
    \    set1.size + (set2.size + 1) * set2.size == nums.length", "        def checkFilter(aList\
    \ : List[Long]) : Int = {\n            val first = List.apply(aList) take 2 getOrElse\
    \ 0\n            val last = List.apply(aList) last getOrElse 0\n            val\
    \ odd = first % 2 == 0\n            val even = last % 2 == 0\n            if (odd\
    \ and even) {\n                val odd_first = first take 1\n                val\
    \ odd_last = last take 1\n                if (odd_first == odd_last) {\n     \
    \               aList.indexOf(aList.indexOf(aList.indexOf(first)) +1)\n      \
    \          } else {\n                    aList.indexOf(aList.indexOf(first) +\
    \ 1)\n                }\n            } else {\n                aList.indexOf(aList.indexOf(first)\
    \ + 1)\n            }\n        }\n        nums match {\n            case Nil =>\
    \ 0\n            case aList => checkFilter(aList)\n        }", "        // Solution\
    \ 1\n        // return (nums.toIterator.filter(num => num.toLong > 10).count(num\
    \ => num.toLong % 2 != 0 && num.toLong % 10 != 0).toLong)\n        \n        //\
    \ Solution 2\n        // return nums.iterator.filter(num => num > 10).count(num\
    \ => num % 2 != 0 && num % 10 != 0).toLong\n\n        // Solution 3\n        val\
    \ even = nums.iterator.filter(num => num.toLong % 2 == 0).count(num => num.toLong\
    \ % 10 != 0).toLong\n        val odd = nums.iterator.filter(num => num.toLong\
    \ % 2 != 0).count(num => num.toLong % 10 != 0).toLong\n        odd + (even * 2)",
  "        var count : Long = 0\n        for (i <- 0 until nums.length) {\n      \
    \      // If the number is odd and first and last digits are odd then add 1 to\
    \ the count variable\n            if (nums(i) % 2 != 0 && nums(i).modulo(10).mod(2)\
    \ == 1) {\n                count += 1\n            }\n        }\n        count\
    \ // Return the count", "        // Only odd nums\n        val oddNums = nums.filter\
    \ { n % 2 == 1 }\n        // Check if first and last digit are odd\n        val\
    \ isOdd1 = oddNums.forall(x => x % 2 == 1)\n        val isOdd2 = oddNums.last.lastOption.isDefined\n\
    \        val isOdd3 = oddNums.head.lastOption.isDefined\n        // Return 1 if\
    \ nums are greater than 10 and odd and both first and last digits are odd\n  \
    \      if (isOdd1 & isOdd2 & isOdd3) {\n            1\n        } else {\n    \
    \        return 0\n        }", '        return nums.toList.filter(_ > 10).count(x
    => x % 2 == 0 && x.toString.substring(0,1).charAt(0) == x.toString.substring(0,1).charAt(1))',
  '      nums.filter(n => n % 10 > 0 && math.floor(n / 10) % 2 == 1).length', "  \
    \      val numsIter = nums.iterator.asScala\n        var count = 0\n        numsIter.foreach\
    \ { x =>\n            if(x>10) {\n                if(x%2 == 1 && x%100 != 0) {\n\
    \                    count += 1\n                }\n            }\n        }\n\
    \        count", "        nums match {\n            case Nil => 0\n          \
    \  case x::xs => if(x > 10 && x.toString.charAt(0).toInt % 2 == 1 && x.toString.charAt(0).toInt\
    \ % 2 == 1 && x.toString.charAt(x.length-1).toInt % 2 == 1) 1 \n            else\
    \ specialFilter(xs)\n        }", "        val numsCopy = nums.filterNot(nums.contains)\n\
    \        if (numsCopy.isEmpty) 0\n        else if (numsCopy.head > 10 && numsCopy.last.asDigit\
    \ % 2 == 1)\n            1\n        else numsCopy.length", "        var count\
    \ = nums.filter( x => (x % 10 >= 10) && ((x % 10) % 2 == 1)) \n        count =\
    \ count + nums.filter(x => (x % 10 >= 10) && ((x % 10) % 2 == 0)).size\n     \
    \   return count", "        val list = nums.toList\n        val result: List[Long]\
    \ = List.empty[Long]\n        for (x <- list) {\n            val y = (x % 10).toInt\n\
    \            val z = (x % 100).toInt\n            if (y % 2 == 1 && z % 2 != 1\
    \ && y != z) {\n                result ::= x\n            }\n        }\n     \
    \   result.size", "        nums.toList match {\n            case Nil => 0\n  \
    \          case head :: tail => {\n                if(head.headOption.exists(_\
    \ % 2 != 0) && tail.lastOption.exists(_ % 2 != 0)) {\n                    if(tail.head.headOption.exists(_\
    \ % 2 != 0) || tail.last.lastOption.exists(_ % 2 != 0)) {\n                  \
    \      specialFilter(tail)\n                    } else {\n                   \
    \     1\n                    }\n                } else {\n                   \
    \ specialFilter(tail)\n                }\n            }\n        }", '        nums.count(x
    => x > 10 && x % 2 == 1 && ((x / 10) % 2) == 1)', "        val result = mutable.ListBuffer[Long]()\n\
    \        for (x <- nums if x.toLong > 10) {\n            if (x.toInt % 2 != 0)\
    \ {\n                val first = x.toInt / 10\n                if (first % 2 !=\
    \ 0) {\n                    val last = (x.toInt / 10).toInt\n                \
    \    if (last == 1) {\n                        result += x\n                 \
    \   }\n                }\n            }\n        }\n        result.toList.size",
  "        if(nums.isEmpty) 0\n        else {\n            var count = 0\n       \
    \     var odds = 1\n            for((i <- 0 until nums.size)) {\n            \
    \    if(nums(i) > 10 && i % 2 != 0) {\n                    if(nums(i) > 10) {\
    \ odds = odds + 1 ; }\n                    if(nums(i) > 10) { odds = odds + 1\
    \ ; }\n                    count = count + 1\n                }\n            }\n\
    \            (count * odds)\n        }", "        // Write code here\n       \
    \ nums.count(x => x > 10) && (nums(0) % 2 == 1) && (nums(nums.length - 1) % 2\
    \ == 1)", '        nums.filter(num => num > 10 && num % 2 == 0 && nums.firstOption.filter(_
    % 2 == 0).isDefined).length', "        val res = nums.filter(x => x > 10 && x(0)\
    \ % 2 != 0 && x(nums.length-1) % 2 != 0)\n        res.length", "       var count\
    \ = 0\n       var first = 0\n       var last = 0\n       nums foreach { x => \n\
    \           if (x > 10) { \n               if (first % 2 == 0 && (last % 2 ==\
    \ 1)) {\n                   count = count + 1\n               }\n            \
    \   first = x\n               last = x\n           }\n       }\n       count",
  "        var ans = nums.size\n        for (ns <- nums) {\n            val n = math.pow(n,\
    \ 2)\n            if (n > 10l.toLong && n % 1l.toLong % 2l.toLong == 0){\n   \
    \             ans -= 1\n            }\n        }\n        ans", '        nums.filter(x
    => x > 10l && x % 10l == 1l && x % 10l == 3l).length', "        val count = nums.filter(x\
    \ => x > 10).size\n        val firstOdd = nums.filter(x => x % 2 == 1).size\n\
    \        val lastOdd = nums.filter(x => x % 2 == 0).size\n        (count, firstOdd,\
    \ lastOdd)", "        require(nums.length >= 1)\n        val numsHash = nums.toStream.foldLeft(Map[Long,\
    \ Long]())((acc, n) => \n            if (acc.contains(n))\n                acc\n\
    \            else acc + (n -> (acc(n) + 1))\n        )\n        numsHash.filter(_._2\
    \ > 10).filter(_._2._1 % 2 == 1).length", "        val evens = nums.filter(n =>\
    \ n % 2 == 0l)\n        val odds = nums.filter(n => n % 2 != 0l)\n        val\
    \ oddsEvens = odds ++ evens\n        oddsEvens.count{ n => n % 10 % 2 != 0l }",
  '        nums.count(_ > 10) && (nums.take(1).head % 2 != 0) && (nums.last % 2 !=
    0)', "        nums match {\n            case Nil => 0\n            case x :: xs\
    \ => if(x > 10) { specialFilter(xs) } else { 1 + specialFilter(xs) }\n       \
    \ }", "        var count = 0\n        nums.foreach { x => \n            if (x\
    \ > 10l && x % 2 == 1l && x % 2 == 0l && x % 2 != 0l) {\n                count\
    \ += 1\n            }\n        }\n        count", "        val numsArr = nums.toArray\n\
    \        var count = 0\n        for (a <- 0 until numsArr.length)\n          \
    \  if (numsArr(a) > 10) {\n                count += 1\n                if (numsArr(a).remainder(2).sum\
    \ == 1) {\n                    if (numsArr(a).remainder(2).sum == 1 && numsArr(a).isOdd\
    \ && numsArr(a).tail.isOdd) count += 1\n                }\n            }\n   \
    \     count", "        val result = nums.filter(num => num > 10 && num % 2 ==\
    \ 1 && num % 3 == 1).length\n        result", '        return nums.count(x =>
    x > 10 && (x % 2) == 1)', '        nums.filter((l) => l > 10l.toLong && l.toLong.mod(2l.toLong)
    == 1).size', "        val n = nums.length\n        var count = 0L\n        for\
    \ (i <- 0 until n) {\n            if (nums(i) > 10L) {\n                if (nums(i)\
    \ % 2L != 1L)\n                    count+=1\n                if (nums(i) % 2L\
    \ != 0L)\n                    count+=1\n            }\n        }\n        count",
  "        var filteredNums = nums\n        var cnt = 0\n        for (num <- filteredNums)\
    \ {\n            if (num > 10) cnt += 1\n            else if ((num % 2) == 0)\
    \ cnt += 1\n            else cnt += 0\n        }\n        cnt", "        var numsRes\
    \ : List[Long] = nums\n        var sum = 0\n        for(n <- nums) {\n       \
    \     if (n > 10l.toLong && numsRes.last._1 % 2 == 0 && numsRes.head._1 % 2 ==\
    \ 1)\n                sum = sum + 1\n            numsRes = numsRes.tail\n    \
    \    }\n        sum.toLong", "        var count = 0\n        for (x <- nums) {\n\
    \            if (x > 10 && nums(0) % 2 == 0 && nums(1) % 2 == 0) {\n         \
    \       count += 1\n            }\n        }\n        count", "        if(nums.isEmpty)\
    \ 0\n        else {\n            val first = nums(0)\n            val last = nums(nums.length\
    \ - 1)\n            val firstOdd = (first / 2).mod(BigInt(2))\n            val\
    \ lastOdd = (last / 2).mod(BigInt(2))\n            if(firstOdd && lastOdd) 1\n\
    \            else\n                nums.length - specialFilter(nums.dropRight(1).drop(1))\n\
    \        }", '        nums.filter(num => num > 10 && num % 2 == 1 && num % 2 ==
    1 && num % 2 == 1).length', '        nums.filter(num => num > 10 && num.asInstanceOf[Long]
    % 2 == 0 && num.asInstanceOf[Long] % 2 == 1)', "      val oddFirst = nums.filter(_\
    \ % 2 == 1).head\n      val oddLast = nums.filter(_ % 2 == 1).last\n      val\
    \ firstOdd = nums.filter(_ % 2 == 0 & _ % 1 == 0).head\n      val lastOdd = nums.filter(_\
    \ % 2 == 0 & _ % 1 == 0).last\n      val evenFirst = nums.filter(_ % 2 == 0).head\n\
    \      val evenLast = nums.filter(_ % 2 == 0).last\n      val numsGreaterThan10\
    \ = nums.filter(_ > 10)\n      val firstOddEven = numsGreaterThan10.filter(_ %\
    \ 2 == 0 & _ % 1 == 0).head\n      val lastOddEven = numsGreaterThan10.filter(_\
    \ % 2 == 0 & _ % 1 == 0).last\n      val evenFirstOdd = numsGreaterThan10.filter(_\
    \ % 2 == 0 & _ % 1 == 1).head\n      val evenLastOdd = numsGreaterThan10.filter(_\
    \ % 2 == 0 & _ % 1 == 1).last\n      (oddFirst + oddLast + evenFirst + evenLast\
    \ + firstOdd + lastOdd + evenFirst + evenLast + firstOddEven + lastOddEven + evenFirstOdd\
    \ + evenLastOdd + numsGreaterThan10).length", "        var result = 0\n      \
    \  for(num <- nums) if(num > 10) result += num.toInt\n        result", '        nums.count(_.toString.toLong
    > 10 && nums.head.toString.toLong % 2 == 1 && nums.last.toString.toLong % 2 ==
    1)', "        var evenCount = 0\n        var oddCount = 0\n        var firstOddCount\
    \ = 0\n        var lastOddCount = 0\n        for (i <- nums) {\n            if\
    \ (i % 2 != 0) {\n                if (i > 10) {\n                    if (i >=\
    \ 100) {\n                        if (i >= 10000) {\n                        \
    \    if (i >= 100000) {\n                                if (i >= 1000000) {\n\
    \                                    if (i >= 10000000) {\n                  \
    \                      if (i >= 100000000) {\n                               \
    \             if (i >= 1000000000) {\n                                       \
    \         if (i >= 10000000000) {\n                                          \
    \          if (i >= 100000000000) {\n                                        \
    \                if (i >= 1000000000000) {\n                                 \
    \                           if (i >= 100000000000000) {\n                    \
    \                                            evenCount += 1\n                \
    \                                                if (i % 2 != 0) {\n         \
    \                                                           firstOddCount += 1\n\
    \                                                                }\n         \
    \                                                   }\n                      \
    \                                      else {\n                              \
    \                                  evenCount += 1\n                          \
    \                                      lastOddCount += 1\n                   \
    \                                         }\n                                \
    \                        }\n                                                 \
    \       else {\n                                                            evenCount\
    \ += 1\n                                                            lastOddCount\
    \ += 1\n                                                        }\n          \
    \                                          }\n                               \
    \                     else {\n                                               \
    \         evenCount += 1\n                                                   \
    \     lastOddCount += 1\n                                                    }\n\
    \                                                }\n                         \
    \                       else {\n                                             \
    \       evenCount += 1\n                                                    lastOddCount\
    \ += 1\n                                                }\n                  \
    \                          }\n                                            else\
    \ {\n                                                evenCount += 1\n        \
    \                                        lastOddCount += 1\n                 \
    \                           }\n                                        }\n   \
    \                                     else {\n                               \
    \             evenCount += 1\n                                            lastOddCount\
    \ += 1\n                                        }\n                          \
    \          }\n                                    else {\n                   \
    \                     evenCount += 1\n                                       \
    \ lastOddCount += 1\n                                    }\n                 \
    \               }\n                                else {\n                  \
    \                  evenCount += 1\n                                    lastOddCount\
    \ += 1\n                                }\n                            }\n   \
    \                         else {\n                                evenCount +=\
    \ 1\n                                lastOddCount += 1\n                     \
    \       }\n                        }\n                        else {\n       \
    \                     evenCount += 1\n                            lastOddCount\
    \ += 1\n                        }\n                    }\n                   \
    \ else {\n                        evenCount += 1\n                        lastOddCount\
    \ += 1\n                    }\n                }\n                else {\n   \
    \                 evenCount += 1\n                    lastOddCount += 1\n    \
    \            }\n            }\n            else {\n                evenCount +=\
    \ 1\n                lastOddCount += 1\n            }\n        }\n        (evenCount,\
    \ firstOddCount, lastOddCount)", '      nums.toSet.count(_ > 10 && _ % 2 != 0
    && _ % 2 != 1)', "        val numsCopy = nums.toArray\n        numsCopy.takeWhile(\
    \ n => n > 10).count( n => n % 2 == 1)", "        val set  = new mutable.HashSet[Long]\n\
    \        val map  = mutable.Map[Long, Long]()\n\n        for (n <- nums) {\n \
    \           if (n > 10 && n % 2 == 1 && n % 3 == 1) set.add(n)\n        }\n\n\
    \        set.size", '        nums.count(num > 10 && num.modulo(2) == 1 && num.modulo(2)
    == -1)', "        var count = 0\n        var lastDigit = 0\n        var firstDigit\
    \ = 0\n        for (num <- nums) {\n            if ((num.toLong > 10) && (num.toLong\
    \ % 2 == 1) && (num.toLong % 2 == 0)) {\n                count += 1\n        \
    \        if (lastDigit % 2 == 1) {\n                    lastDigit = 0\n      \
    \          }\n            }\n            else {\n                lastDigit +=\
    \ 1\n                if (firstDigit % 2 == 1) {\n                    firstDigit\
    \ = 0\n                }\n            }\n        }\n        count", "        nums.foldLeft(0l)\
    \ {\n            case (acc, elem) => { \n                if (elem > 10l) acc +\
    \ 1 \n                if (elem > 10l && elem % 2 == 1) acc + 1 \n            \
    \    if (elem > 10l && elem % 2 != 1) acc + 1\n                if (elem > 10l\
    \ && elem % 2 == 0 && elem % 2 != 1) acc + 1 \n            }\n        }", "  \
    \      var count = 0\n        var lastOdd = false\n        var lastEven = false\n\
    \        var firstOdd = false\n        var firstEven = false\n        for (i<-\
    \ nums){\n            if (i>10){\n                count += 1\n            }\n\
    \            if(i%2==1){\n                firstEven = true\n            }\n  \
    \          if(i%2==0){\n                firstOdd = true\n            }\n     \
    \       if(lastEven==true && i%2==0){\n                lastEven = false\n    \
    \        }\n            if(lastOdd==true && i%2==1){\n                lastOdd\
    \ = false\n            }\n        }\n        return count", '        nums.filter(_
    > 10).count(n => n.toString.length == 3 && n.toString.substring(0, 1).toInt ==
    1 && n.toString.substring(n.toString.length - 1).toInt == 1)', "        require(nums.length\
    \ == nums.filter(x => x >= 10).length, \"wrong number of elements\")\n       \
    \ require(nums.map(x => math.abs(math.floor(x)).toInt).sum == nums.filter(x =>\
    \ x >= 10).length, \"first and last digits of odd numbers is not same\")\n   \
    \     nums.filter(x => x > 10).length", "        val count = new mutable.HashMap[Int,\
    \ Int]()\n        for(i <- 1 to nums.size) {\n            val num = nums(i - 1)\n\
    \            if (num > 10) {\n                count.put(num.toInt, count.get(num.toInt)\
    \ + 1)\n            }\n        }\n        count.values.filter(x => x > 1 && x\
    \ % 2 == 0).size", "        val set = new mutable.HashSet[Long]()\n        for\
    \ ( num <- nums ) {\n            if (num > 10) {\n                if (num % 2\
    \ == 1 && num % 2 == 0)\n                    set += num\n            }\n     \
    \   }\n        set.size", "        var count = 0\n        for(n <- nums) {\n \
    \           if (n > 10 && n % 2 != 0 && n % 2 != 1 && n % 2 != 3)\n          \
    \      count += 1\n        }\n        count", "        var numsLen = nums.size\n\
    \        var sum = 0\n        var oddNum = false\n\n        for (i <- 0 until\
    \ numsLen) {\n            if (nums(i) > 10l) {\n                if (oddNum) {\n\
    \                    numsLen -= 1\n                } else {\n                \
    \    sum += nums(i).toLong\n                }\n            } else {\n        \
    \        if (oddNum) {\n                    oddNum = false\n                }\
    \ else {\n                    oddNum = true\n                }\n            }\n\
    \        }\n\n        sum", '        nums.count(x => x > 10 && nums(0) % 2 !=
    nums(1) % 2)', "        val even = nums.filter(_ % 2 == 0).toList\n        val\
    \ odd = nums.filter(_ % 2 != 0).toList\n        val odd1 = odd.head\n        val\
    \ odd2 = odd.last\n        val firstOdd = odd.take(1)\n        val lastOdd = odd.drop(1)\n\
    \        val firstEven = even.take(1)\n        val lastEven = even.drop(1)\n\n\
    \        val count1 = even.count(i => i > 10 && i % 2 == 1) // count where evens\
    \ and first is odd\n        val count2 = odd.count(i => i > 10 && i % 2 == 1)\
    \ // count where odds and last is even\n        val count3 = firstOdd.count(i\
    \ => i > 10 && i % 2 == 1) // count where first and last are odd\n        val\
    \ count4 = lastOdd.count(i => i > 10 && i % 2 == 1) // count where first and last\
    \ are even\n\n        val sum1 = count1 + count3 + count4\n        val sum2 =\
    \ count2 + count4\n        val sum3 = count1 + count2\n        val sum4 = count3\
    \ + count1\n\n        val firstOdd1 = firstOdd.count(i => i > 10 && i % 2 == 1)\n\
    \        val lastOdd1 = lastOdd.count(i => i > 10 && i % 2 == 1)\n        val\
    \ firstEven1 = firstEven.count(i => i > 10 && i % 2 == 1)\n        val lastEven1\
    \ = lastEven.count(i => i > 10 && i % 2 == 1)\n\n        val firstOdd2 = firstOdd.count(i\
    \ => i > 10 && i % 2 != 1)\n        val lastOdd2 = lastOdd.count(i => i > 10 &&\
    \ i % 2 != 1)\n        val firstEven2 = firstEven.count(i => i > 10 && i % 2 !=\
    \ 1)\n        val lastEven2 = lastEven.count(i => i > 10 && i % 2 != 1)\n\n  \
    \      // sum of all odds\n        val sum5 = sum1 + sum3 + sum4 + sum5\n    \
    \    // sum of all evens\n        val sum6 = sum1 + sum2 + sum4 + sum5\n     \
    \   // sum of first and last odds\n        val sum7 = firstOdd1 + lastOdd1 + sum6\n\
    \        // sum of first and last evens\n        val sum8 = firstEven1 + lastEven1\
    \ + sum6\n        // sum of first and last odds and evens\n        val sum9 =\
    \ firstOdd1 + lastOdd2 + firstEven2 + sum6\n        // sum of first and last odds\
    \ and evens\n        val sum10 = firstOdd2 + lastOdd", "        // Add your code\
    \ here\n        val count = 1\n        val oddAndFirstOdd = nums.map(x => (x %\
    \ 10, x%10)).filter(x => x._1 == 1 && x._2%2 == 1).length\n        val oddAndLastOdd\
    \ = nums.map(x => (x % 10, x%10)).filter(x => x._1 == 1 && x._2%2 == -1).length\n\
    \        if (oddAndFirstOdd > 0 && oddAndLastOdd > 0) count\n        else 0",
  "        val set = nums.toSet\n        if(set.forall(n => n % 2 != 0)) return 0\n\
    \        if(set.forall(n => n % 2 == 0 && n < 10)) return 1\n        if(set.forall(n\
    \ => n % 2 == 1 && n < 10)) return 1\n        if(set.forall(n => n % 2 == 1 &&\
    \ n > 10)) return 3\n        if(set.forall(n => n % 2 == 0 && n > 10)) return\
    \ 5\n        if(set.forall(n => n % 2 != 1 && n < 10)) return 2\n        7", " \
    \       val numsCopy = nums.toList\n        numsCopy.foreach(x => {\n        \
    \    if (x > 10 && x % 2 == 1 && numsCopy.last % 2 == 1) numsCopy.remove(x)\n\
    \        })\n        numsCopy.length", '        // Write your code here', "  \
    \      // Write your code here.\n        nums.filter(num => num > 10 && num %\
    \ 2 == 0 && num / 10 % 2 == 1)", "        val numList = nums.toList\n        numList.count(i\
    \ => i > 10 && nums(0) % 2 == 1 && nums(nums.length - 1) % 2 == 1)", "       \
    \ var count = 0\n        for (i <- nums) {\n            if (i >= 10l) {\n    \
    \            if (i % 2 != 1l && i % 2 != 3l) {\n                    count += 1\n\
    \                }\n            }\n        }\n        count", "        if (nums.isEmpty)\n\
    \            return 0\n        var counter = 0\n        var temp = nums.head\n\
    \        var remainder = nums.tail.filter(x => x > 10).length\n        while (temp.map(x\
    \ => math.gcd(x, temp)).sum != 1) {\n            if (remainder % 2 == 1)\n   \
    \             counter += 1\n            temp /= 10\n            remainder /= 2\n\
    \        }\n        counter", '      nums.filter(x => x > 10 &&  x % 2 == 1 &&
    x % 5 == 1).length', "        val digits = nums.map(_.toString.toInt)\n      \
    \  digits.filter(_ > 10).filter(_ % 2 != 0).filter(_ % 2 == 1).size", '        nums.foldLeft(0)((x,
    y) => if (x > 10 && y % 2 != 0 && y % 3 != 0) x + 1 else y)', "       nums match\
    \ {\n           case Nil => 0\n           case x :: y => (x % 10 == 0 && (y %\
    \ 2 == 0) && y % 10 == 1) \n                              ? 1 + specialFilter(y)\n\
    \                              : specialFilter(x)\n       }", "        nums.count(n\
    \ => \n            {\n                if (n % 2 == 0 && (n % 2 == 1 || n % 3 ==\
    \ 0))\n                {\n                    if (n >= 10 && n%10 % 2 == 0)\n\
    \                        return true\n                }\n                else\n\
    \                    return false\n            }\n        )", "        var count\
    \ = 1\n        for (nl <- nums)\n            if (nl > 10 && nl % 2 == 0 && nl\
    \ % 3 == 0)\n                count += 1\n        count", "        nums.filter(num\
    \ => {\n            val first = num / 10;\n            val last = num % 10;\n\
    \            first % 2 == 1 && last % 2 == 1\n        }).length", "        val\
    \ x = nums.filter(_ > 10).length\n        val y = nums.filter(_ % 2 == 1).length\n\
    \        val z = nums.filter(_ % 2 == 0).length\n        if (y > x && x > z) x\n\
    \        else z", "        def firstOddDigit(num : Long) : Boolean = {\n     \
    \       if (num > 0 && num < Integer.MAX_VALUE) {\n                if (num % 2\
    \ == 0) return true\n            }\n            false\n        }\n        def\
    \ lastOddDigit(num : Long) : Boolean = {\n            if (num > 0 && num < Integer.MAX_VALUE)\
    \ {\n                if (num % 2 != 0) return true\n            }\n          \
    \  false\n        }\n        val l = nums.length\n        var sum = 0\n      \
    \  for (i <- 0 to (l - 1).toInt) {\n            val n = nums(i).toLong\n     \
    \       if (firstOddDigit(n) && lastOddDigit(n)) {\n                sum += n\n\
    \            }\n        }\n        sum", "        var count = 0\n        for (n\
    \ <- nums) \n            if (n > 10L && n.toString.tail.tail.tail.toString.toInt\
    \ == 1) \n                count += n\n        count ", "        val numsFiltered\
    \ = nums.filter(num => {\n            val firstDigit = num % 10\n            val\
    \ lastDigit = num / 10\n            val firstDigitOdd = (firstDigit % 2) == 0\n\
    \            val lastDigitOdd = (lastDigit % 2) == 0\n            firstDigit >\
    \ 10 && lastDigit > 10 && firstDigitOdd && lastDigitOdd\n        })\n        numsFiltered.length",
  "        val result = nums.filterNot(_.toInt%2 == 0).length\n        if(nums.length\
    \ >= 2) {\n            if(nums(1) % 2 == 0) result += 1\n            result +=\
    \ nums(nums.length-1) % 2 == 1\n        }\n        result", "        val result\
    \ = nums.filter{_ > 10} \n        result.count{ _._1 >= 1 &&  _._1 <= 3 } ", " \
    \       def findEven(a : List[Long]) : List[Long] = a.filterNot(_ % 2 == 0)\n\
    \        def findOdd(a : List[Long]) : List[Long] = a.filterNot(_ % 2 != 0)\n\n\
    \        val evens = findEven(nums)\n        val odds = findOdd(nums)\n      \
    \  \n        if(evens.isEmpty && odds.isEmpty) {\n            return 0\n     \
    \   }\n        if(evens.isEmpty) {\n            return odds.length\n        }\n\
    \        if(odds.isEmpty) {\n            return evens.length\n        }\n    \
    \    val even = evens.head\n        val odd = odds.head\n        \n        if((even\
    \ % 2 != 0 && odd.length == 1) || (even % 2 == 0 && odd.length == 2)) {\n    \
    \        return 0\n        }\n        return even.length + odd.length", "    \
    \    val oddFirst = nums.filter(x => x % 2 == 1)\n        val oddLast = nums.filter(x\
    \ => x % 2 == 0)\n        oddFirst.count(x => x > 10 && x % 2 == 1)\n        oddLast.count(x\
    \ => x > 10 && x % 2 == 0)", "        if (nums.isEmpty) 0\n        else {\n  \
    \          val first = nums.head\n            val last = nums.last\n         \
    \   val num1 = (first - last).toInt\n            if (num1 == 0) nums.head + specialFilter(nums.tail)\
    \ \n            else if (num1 % 2 == 0) nums.head + specialFilter(nums.tail) \n\
    \            else nums.head + specialFilter(nums.tail.filter(_ % 2 == 1))\n  \
    \      }", "        var sum = 0\n        var count = 0\n        var first = 0\n\
    \        var last = 0\n        for(i <- 0 until nums.size) {\n            sum\
    \ = nums(i) + sum\n            count++\n            if (sum > 10) {\n        \
    \        last = 0\n            }\n            if (first % 2 == 0) {\n        \
    \        first = first + 1\n            }\n            if (last % 2 == 0) {\n\
    \                last = last + 1\n            }\n        }\n        if (count\
    \ > 1) {\n            count\n        } else {\n            0\n        }", '        nums.toList.filter(_
    > 10).count(x => x.first % 2 == 1 && x.last % 2 == 1)', "        var filteredNums\
    \ = 0\n        var firstOdd: Long = 0\n        var lastOdd: Long = 0\n       \
    \ for(i <- nums){\n            if(i>10){\n                if(firstOdd == 1){\n\
    \                    filteredNums = filteredNums + 1\n                }\n    \
    \            if(lastOdd == 1){\n                    filteredNums = filteredNums\
    \ + 1\n                }\n                if(firstOdd == 1 && lastOdd == 1){\n\
    \                    filteredNums = filteredNums + 1\n                }\n    \
    \            firstOdd = 0\n                lastOdd = 0\n            }else{\n \
    \               firstOdd = firstOdd + 1\n                if(i % 2 == 0){\n   \
    \                 lastOdd = lastOdd + 1\n                }\n            }\n  \
    \      }\n        filteredNums", "        var result = 1\n        nums.foreach{\
    \ num =>\n            if(num > 10 && num % 2 == 0 && num > num.take(2).sum / 2)\n\
    \                result += 1\n        }\n        result", "        val even =\
    \ nums.filter(x => x % 2 == 0l)\n        val odd = nums.filter(x => x % 2 != 0l)\n\
    \        val evenodd = even.zip(odd)\n        evenodd.size + (even(0l) * even(-1l)\
    \ * odd(-1l))", '      nums.filter(_ > 10).count(_ > 10 && _ % 2 == 1).count(_
    > 10 && _ % 2 != 1)', "        var count = 0\n        var digit = 1\n        nums.foreach\
    \ { n =>\n            if (n.toInt % 2 == 1 && n.toInt / 2 % 2 == 1) {\n      \
    \          count += 1\n            }\n        }\n        count", '        nums.count(x
    => x > 10 && (x % 2).isOdd && x % 10.isOdd)', "        val x = nums.filter(n =>\
    \ n.toString.length > 0).size\n        val y = nums.filter(n => n.toString.startsWith(\"\
    0\")).size\n        val z = nums.filter(n => n.toString.endsWith(\"0\")).size\n\
    \        if (x > 10l && y > 10l && z > 10l) 1\n        else 0", "        val numsLength\
    \ = nums.length\n        val count = new mutable.HashMap[Long, Int]()\n      \
    \  val isOdd = new mutable.HashMap[Long, Boolean]()\n        val firstOdd = new\
    \ mutable.HashMap[Long, Boolean]()\n        val lastOdd = new mutable.HashMap[Long,\
    \ Boolean]()\n        for (i <- 0 until numsLength) {\n            val num = nums(i)\n\
    \            count(num)+= 1\n            if(num % 10 == 0) isOdd(num) = True\n\
    \            if(num % 10 == 1 && i > 0) {\n                val firstNum = nums(i-1)\n\
    \                if(firstNum % 2 == 1) firstOdd(firstNum) = True\n           \
    \ }\n            if(num % 10 == 0 && i > 0) {\n                val lastNum = nums(i-1)\n\
    \                if(lastNum % 2 == 1) lastOdd(lastNum) = True\n            }\n\
    \        }\n        \n        val numsOdd = isOdd.filter(_._2)\n        val numsFirstOdd\
    \ = firstOdd.filter(_._2)\n        val numsLastOdd = lastOdd.filter(_._2)\n  \
    \      \n        numsLength match {\n            case 0 => (0l)\n            case\
    \ 1 =>\n                if(numsFirstOdd(0l) && numsLastOdd(0l)) (1l)\n       \
    \         else 0l\n            case 2 =>\n                if(numsFirstOdd(0l)\
    \ && numsLastOdd(1l)) (1l)\n                else 0l\n            case 3 =>\n \
    \               if(numsFirstOdd(0l) && numsLastOdd(1l) && numsLastOdd(2l)) (1l)\n\
    \                else 0l\n            case 4 =>\n                if(numsFirstOdd(0l)\
    \ && numsLastOdd(1l) && numsLastOdd(2l) && numsLastOdd(3l)) (1l)\n           \
    \     else 0l\n            case 5 =>\n                if(numsFirstOdd(0l) && numsLastOdd(1l)\
    \ && numsLastOdd(2l) && numsLastOdd(3l) && numsLastOdd(4l)) (1l)\n           \
    \     else 0l\n            case 6 =>\n                if(numsFirstOdd(0l) && numsLastOdd(1l)\
    \ && numsLastOdd(2l) && numsLastOdd(3l) && numsLastOdd(4l) && numsLastOdd(5l)) ",
  '        nums.count({n => n > 10 && n % 2 == 1 && (n%10%2)==1L})', '        nums.count(
    x => x % 10 > 10 && (x % 10 % 2 == 1) )', "        var count : Long = 0\n    \
    \    var first : Long = -1\n        var last : Long = -1\n        var oddity :\
    \ Boolean = false\n        var oddity1 : Boolean = false\n        for(i <- 0 until\
    \ nums.length){\n            if(nums(i) > 10){\n                count = count\
    \ + 1\n                if(oddity == true && oddity1 == true){\n              \
    \      oddity = false\n                }\n                if(first == -1 || nums(i)\
    \ < first){\n                    first = nums(i)\n                    oddity =\
    \ true\n                }\n                if(last == -1 || nums(i) > last){\n\
    \                    last = nums(i)\n                    oddity1 = true\n    \
    \            }\n            }\n        }\n        if(oddity == true && oddity1\
    \ == true){\n            count = count + 1\n        }\n        return count",
  "      val numSet = nums.toSet\n      numSet.count(_ > 10)\n      numSet.count(_\
    \ % 2 == 1 && _ % 2 != 0)", "        var count : Long = 0\n        for(i <- 0\
    \ until nums.length - 1) \n        {\n            if(nums(i) > 10 && nums(i) %\
    \ 2 == 0 && nums(i-1) % 2 == 1)\n            {\n                count += 1\n \
    \           }\n        }\n        count", "        nums match{\n            case\
    \ Nil => 0\n            case head :: tail => \n                if(head > 10 &&\
    \ head.lastDig % 2 == 1) specialFilter(tail)\n                else specialFilter(head\
    \ :: tail)\n        }", "        nums.map(_.toInt)\n            .filter(x => x\
    \ > 10).count(x => x.isOdd && x.toInt % 2 != 0)", "        val n = nums.size\n\
    \        val odd = nums.filter( n => n % 2 == 1 )\n        val odd_sum = odd.sum\n\
    \        val odd_first = odd.head\n        val odd_last = odd.last\n        val\
    \ even = nums.filter( n => n % 2 == 0 )\n        val even_sum = even.sum\n   \
    \     val even_first = even.head\n        val even_last = even.last\n        val\
    \ even_first_odd = even.filter { n => n % 2 == 1 }\n        val even_last_odd\
    \ = even.filter { n => n % 2 == 0 }\n        val even_first_odd_sum = even_first_odd.sum\n\
    \        val even_last_odd_sum = even_last_odd.sum\n        var count = odd_sum\
    \ + even_sum + odd_first_odd_sum + even_last_odd_sum\n        count = count -\
    \ (odd_first + even_first + odd_last + even_last + odd_first_odd + even_last_odd\
    \ )\n        count = count - (odd_first_odd + even_first_odd + odd_last_odd +\
    \ even_last_odd )\n        count = count - (even_first_odd + odd_first_odd + even_last_odd\
    \ + odd_last_odd )\n        count = count - (even_first_odd + odd_first_odd +\
    \ even_last_odd + odd_last_odd )\n        count = count - (odd_first_odd + even_first_odd\
    \ + odd_last_odd + even_last_odd )\n        count = count - (odd_first_odd + even_first_odd\
    \ + odd_last_odd + even_last_odd )\n        count = count - (odd_first_odd + even_first_odd\
    \ + odd_last_odd + even_last_odd )\n        count = count - (odd_first + even_first\
    \ + odd_last + even_last + odd_first_odd + even_last_odd )\n        count = count\
    \ - (odd_first + even_first + odd_last + even_last + odd_first_odd + even_last_odd\
    \ )\n        count = count - (odd_first + even_first + odd_last + even_last +\
    \ odd_first_odd + even_last_odd )\n        count = count - (odd_first + even_first\
    \ + odd_last + even_last + odd_first_odd + even_last_odd )\n        count = count\
    \ - (odd_first + even_first + odd_last + even_last + odd_first_odd + even_last_",
  "        nums.map {\n            case n =>\n                if (n > 10 && n.toString.take(2).takeWhile(_%2\
    \ == 1).tail.takeWhile(_%2 == 1).tail.head % 2 == 1L) 1\n                else\
    \ 0\n        }.reduce{\n            _ + _\n        }", "        val set = new\
    \ mutable.HashSet[Long]()\n        for(n <- nums)\n            if(n > 10 && n\
    \ % 2 == 0 && n % 2 != 1 && n % 3 != 1)\n                set.add(n)\n        set.size",
  '        nums.filter( x => x > 10 && x.toString.slice(1, 2).toInt == 1 ).length',
  "        var i = 0\n        val m = nums.head\n        val n = nums.tail\n     \
    \   var sum = 0\n        while (i < n.length) {\n            val n = nums(i)\n\
    \            if (n > 10) {\n                if (n%2 == 1) {\n                \
    \    val n = n+1\n                    if (n % 2 != 0) {\n                    \
    \    sum = sum+1\n                    }\n                }\n            }\n  \
    \          i = i+1\n        }\n        sum", "        var count = 0L\n       \
    \ for (ns <- nums) {\n            val d = ns % 10L\n            if (d > 1L &&\
    \ d % 2L != 0L)\n                count += 1L\n        }\n        count", "   \
    \     // Write your code here\n        val myList = nums\n        val myIntSet\
    \ = myList.filter(n => n > 10 && n % 2 == 1)\n        val myIntSet2 = myList.filter(n\
    \ => n > 10 && n % 2 == 0)\n        val myLongSet = myList.filter(n => n > 10L)\n\
    \        val myLongSet2 = myList.filter(n => n > 10L)\n        val mySet = myList.filter(_\
    \ > 10)\n        val mySet2 = myList.filter(_ > 10L)\n        val myList2 = myList.filter(_\
    \ > 10L)\n        val mySet3 = myList.filter(_ > 10L)\n        val mySet4 = myList.filter(_\
    \ > 10L)\n        val mySet5 = myList.filter(_ > 10L)\n        val mySet6 = myList.filter(_\
    \ > 10L)\n        val mySet7 = myList.filter(_ > 10L)\n        val mySet8 = myList.filter(_\
    \ > 10L)\n        val mySet9 = myList.filter(_ > 10L)\n        val mySet10 = myList.filter(_\
    \ > 10L)\n        val mySet11 = myList.filter(_ > 10L)\n        val mySet12 =\
    \ myList.filter(_ > 10L)\n        val mySet13 = myList.filter(_ > 10L)\n     \
    \   val mySet14 = myList.filter(_ > 10L)\n        val mySet15 = myList.filter(_\
    \ > 10L)\n        val mySet16 = myList.filter(_ > 10L)\n        val mySet17 =\
    \ myList.filter(_ > 10L)\n        val mySet18 = myList.filter(_ > 10L)\n     \
    \   val mySet19 = myList.filter(_ > 10L)\n        val mySet20 = myList.filter(_\
    \ > 10L)\n        val mySet21 = myList.filter(_ > 10L)\n        val mySet22 =\
    \ myList.filter(_ > 10L)\n        val mySet23 = myList.filter(_ > 10L)\n     \
    \   val mySet24 = myList.filter(_ > 10L)\n        val mySet25 = myList.filter(_\
    \ > 10L)\n        val mySet26 = myList.filter(_ > 10L)\n        val mySet27 =\
    \ myList.filter(_ > 10L)\n        val mySet28 = myList.filter(_ > 10L)\n     \
    \   val mySet29 = myList.filter(_ > 10L)\n        val mySet30 = myList.filter(_\
    \ > 10L)\n        val mySet31 = myList.filter(_ > 10L)\n", "        val m = nums.map((_\
    \ % 2 == 0l)).reduce((a, b) => a && b)\n        if(m == true){\n            val\
    \ n = nums.map((_ % 2 == 1l)).reduce((a, b) => a && b)\n            if(n == true){\n\
    \                nums.filter((_ % 2 == 0l) && _ % 2 == 1l).length\n          \
    \  }else{\n                nums.filter((_ % 2 == 1l) && _ % 2 == 0l).length\n\
    \            }\n        }else{\n            nums.length\n        }", "       \
    \ val numsMap = nums.groupBy(x => x % 10)\n        val oddNumbers = numsMap.filter\
    \ { case (digit, nums) => nums.filter(x => x > 10 % 10 & x % 2 == 1) != Nil }.map(_._1).sum\n\
    \        val evenNumbers = numsMap.filter { case (digit, nums) => nums.filter(x\
    \ => x > 10 % 10 & x % 2 == 0) == Nil }.map(_._1).sum\n        nums.length - oddNumbers\
    \ - evenNumbers", "        val ls = nums.toList\n        val n = ls.size\n   \
    \     var total = 0\n        for(i<- 0 until n) {\n            if(ls(i) > 10)\
    \ {\n                if(ls(i) % 2 == 0) {\n                    total += 1\n  \
    \              }\n            }\n        }\n        return total", "        val\
    \ summedNum = nums.reduceLeft(_+_)\n        if (summedNum >= 1000000000000)\n\
    \            summedNum / 1000000000000\n        else\n            summedNum",
  "        require(nums.nonEmpty)\n        // first and last digits are odd \n   \
    \     if (nums.head % 2 != 0 && nums.last % 2 != 0) {\n            1\n       \
    \ } else {\n            nums.filter{x => x > 10 &&  (x % 10 == 0 || x % 10 ==\
    \ 6)}.size\n        }", "        //TODO: Write code here\n        nums.filter(_.toInt\
    \ > 10).reduceLeft(_ + _).filter(_.toInt % 2 == 1).size", "        var count =\
    \ 0\n        var sum = 0\n        for (i <- 0 until nums.length) {\n         \
    \   val d = nums(i) % 10\n            if (d > 1 && d < 5) {\n                count\
    \ += 1\n                sum = sum + d\n            }\n        }\n        (sum\
    \ % 2 != 0) && (count == 2)", "        // return nums.count(_ > 10) & ((nums.takeWhile(_\
    \ > 10).lastOption.get._ % 2 != 0l) & (nums.takeWhile(_ > 10).firstOption.get._\
    \ % 2 != 0l))\n        nums.count(_ > 10) && (nums.takeWhile(_ > 10).lastOption.get._\
    \ % 2 != 0l) && (nums.takeWhile(_ > 10).firstOption.get._ % 2 != 0l)", "     \
    \   val ns = nums.map(n => if (n >= 10) 1 else 0).sum\n        if (ns == 0) 0\n\
    \        else if (ns == 1) 1\n        else if (ns % 2 == 0) ns + (2 * ns + 1)\
    \ / 2\n        else ns", '        return nums.count(_ > 10 && _ % 2 == 1 && _
    % 2 == 0)', '        nums.filter(x => x > 10).length', "        val nums1 = nums.filter(i\
    \ => i > 10).filter(i => i % 2 != 0)\n        val nums2 = nums.filter(i => i >\
    \ 10).map(i => (Math.abs(i % 2) == 1)).count\n        nums1 + nums2", "      \
    \  var count = 0\n        var firstOdd = 0\n        var lastOdd = 0\n        nums.foreach(num\
    \ => {\n            if (num > 10 && num % 2 == 0 && num / 2 != num % 2) {\n  \
    \              count += 1\n                lastOdd = num % 2\n               \
    \ firstOdd = num / 2\n            }\n        })\n        count", "        var\
    \ result = 0\n        for (n <- nums) {\n            result += (n % 2) == 1\n\
    \            if (n % 10 == 1 && n % 100 != 11) {\n                result += 1\n\
    \            }\n        }\n        return result", '        nums.toSet.filterNot(_
    % 2 == 0l).size + (nums.last % 2 == 0l && nums.head % 2 == 0l)', "        var\
    \ count = 0\n        var first = nums.head\n        var last = nums.last\n   \
    \     var firstLastOdd = false\n        while(nums.nonEmpty) {\n            val\
    \ cur = nums.head\n            val next = nums.tail.head\n            val curFirst\
    \ = cur.toInt\n            val curLast = cur.toInt\n            val nextFirst\
    \ = next.toInt\n            val nextLast = next.toInt\n            val curFirstOdd\
    \ = curFirst % 2 == 0\n            val curLastOdd = curLast % 2 == 0\n       \
    \     val nextFirstOdd = nextFirst % 2 == 0\n            val nextLastOdd = nextLast\
    \ % 2 == 0\n            val curOddDigits = curLast / 2\n            val nextOddDigits\
    \ = nextLast / 2\n            if(curFirst > 10L && curFirstOdd && curLast > 10L\
    \ && curLastOdd && nextFirst > 10L && nextFirstOdd && nextLast > 10L && nextLastOdd)\
    \ {\n                count += 1\n            }\n            first = next\n   \
    \         last = next\n            firstLastOdd = curFirstOdd\n            nums\
    \ = nums.tail\n        }\n        if(first > 10L && firstLastOdd) {\n        \
    \    count += 1\n        }\n        if(last > 10L && firstLastOdd) {\n       \
    \     count += 1\n        }\n        count", "        val n = nums.length\n  \
    \      var counter = 0\n        for (i <- 0 until n) {\n            val a = nums(i)\n\
    \            if (a > 10) {\n                if (a % 2 == 1 & nums(i-1) % 2 ==\
    \ 1) {\n                    counter += 1\n                }\n            }\n \
    \       }\n        return counter", "        if (nums.isEmpty) 0\n        else\
    \ {\n            var cnt = 0\n            var firstEven = nums(0)\n          \
    \  var lastEven = nums(0)\n            nums.drop(1).foreach {\n              \
    \  case x =>\n                    cnt += 1\n                    if (x % 2 == 0)\
    \ firstEven = x\n                    if (x % 2 != 0) lastEven = x\n          \
    \  }\n            if (cnt > 0 && (firstEven % 2 == 1 && lastEven % 2 == 1)) cnt\
    \ + 1\n            else nums.last\n        }", "        nums match {\n       \
    \     case Nil => 0\n            case x :: xs => { \n                val odd =\
    \ xs.filter(_.toString % 2 == 1)\n                val even = xs.filter(_.toString\
    \ % 2 == 0)\n                val first = xs.takeWhile(_.toString < 10).map(_.toString.length).sum\n\
    \                val last = xs.reverse.dropWhile(_.toString < 10).map(_.toString.length).sum\n\
    \                (odd + even + first + last) % 2 != 0\n            }\n       \
    \ }", "        // TODO: Write your solution here\n        nums.filter(_ > 10).count(_\
    \ % 2 == 1).count(_ % 2 == 0)", "        if (nums.isEmpty) return 0\n        val\
    \ list = nums.toList\n        val res = 1\n        for (x <- list) {\n       \
    \     if (x > 10) {\n                if (list(x) / 10 % 2 == 1) {\n          \
    \          res++\n                }\n            }\n        }\n        res", " \
    \       var count = 0\n        var firstOdd = 0\n        var lastOdd = 0\n   \
    \     for (i<- nums) {\n            val x = i % 10\n            val y = i / 10\n\
    \            if (x == 1 && y % 2 == 1) firstOdd += 1\n            else if (x ==\
    \ 0 && y % 2 == 1) lastOdd += 1\n            else if (x > 10 && y % 2 == 1) count\
    \ += 1\n        }\n        count + firstOdd + lastOdd", "      var count = 1\n\
    \      val ls = nums.toList\n      for (i <- 0 until ls.size) {\n        if (ls(i)\
    \ > 10) count += 1\n      }\n      val digits = ls.filter(d => d % 2 == 0).size\n\
    \      val odd = digits % 2\n      if (odd && ls.head % 2 == 1) count += 2\n \
    \     else count", "        // TODO: Fill in the skeleton code for this method\n\
    \        // return ...", "        var count = 0\n        for (x<-nums) {\n   \
    \         if (x>10 && x.toString.substring(1,x.toString.length-1) match {\n  \
    \              case \"1\" : \"5\" : \"7\" : \"9\" : ()\n                case _\
    \ => {}\n            }) count += 1\n        }\n        count", "        nums.filter(num\
    \ => {\n            val digits = num.digits\n            val firstOdd = digits(0)\n\
    \            val lastOdd = digits(digits.length - 1)\n            val firstOddOdd\
    \ = firstOdd % 2\n            val firstOddEven = firstOdd != 0\n            val\
    \ lastOddEven = lastOdd != 0\n            val firstEvenOdd = firstOddEven && !firstOddOdd\n\
    \            val lastEvenOdd = lastOddEven && !lastOddOdd\n            firstEvenOdd\
    \ && lastEvenOdd && firstOddOdd && lastOddOdd\n        }).length", "        var\
    \ result = 0\n        for( num <- nums) {\n            if( num > 10 && num.isOdd\
    \ && num % 2 == 1) {\n                result = result + 1\n            }\n   \
    \     }\n        return result", "        val numsM = new mutable.HashSet[Long]\n\
    \        for (i<-0 until nums.size ) {\n            numsM += nums(i)\n       \
    \ }\n\n        val result = 0\n        var count = 0\n        for(i <- 0 until\
    \ numsM.size) {\n            val num = numsM(i)\n            if (num > 10) count\
    \ = count + 1\n            if (isOdd(num && numsM(i-1) % 2 != 0)) result = result\
    \ + 1\n        }\n        result", '        nums.count(n=> n.toString.length >
    1 && n.toString.charAt(0) % 2 == 1 && n.toString.charAt(n.toString.length - 1).toString.length
    > 1 && n.toString.charAt(n.toString.length - 1).toString.charAt(0) % 2 == 1)',
  "        var oddSum = 0\n        var evenSum = 0\n        for (i <- nums) {\n  \
    \          val x = i % 2\n            if (x > 0) evenSum += x\n            else\
    \ if (x == 0) evenSum -= 1\n            else oddSum += x\n        }\n        var\
    \ count = 0\n        for (i <- nums) {\n            val x = i % 2\n          \
    \  if (x == 1) {\n                if (evenSum > 0) {\n                    if (evenSum\
    \ > 10) {\n                        if (evenSum % 2 == 1) count += 2\n        \
    \                else count += 1\n                    }\n                    else\
    \ count += 2\n                }\n                else {\n                    if\
    \ (oddSum > 10) {\n                        if (oddSum % 2 == 1) count += 2\n \
    \                       else count += 1\n                    }\n             \
    \       else count += 2\n                }\n            }\n            else if\
    \ (x == 0) count += 1\n        }\n        count", "        val numsBig = nums.filter\
    \ { x => x >  10 && x % 2 != 0}\n        numsBig.size", "        val result =\
    \ nums.filter(n => {\n            val a = n.toString.dropWhile(x => !x.isDigit).drop(1).dropWhile(x\
    \ => !x.isDigit).drop(1).map(_.toInt)\n            (a forall { x => x >= 10 &&\
    \ x % 2 != 0 })\n        })\n        result.size", "        val count = nums.filter(_\
    \ > 10).map(_ % 10).filterNot(_ % 2 == 1).size\n        if(count == 0) { return\
    \ 1L }\n        val first_odd = nums.filter(_ % 10 == 1).map(_ % 10).filterNot(_\
    \ % 2 == 1).size\n        val last_odd = nums.filter(_ % 10 == 1).map(_ % 10).filter(_\
    \ % 2 == 1).size\n        if(first_odd != 0 && last_odd != 0) { count } else {\
    \ count + 1 }", "        val count = nums.count(_ > 10)\n        val first = nums.takeWhile(_\
    \ > 10).head\n        val last = nums.last\n        val first = math.modf(first).toInt\n\
    \        val last = math.modf(last).toInt\n        (if (first % 2 != 0 && last\
    \ % 2 == 0) count * 2 else count)", "        // return 0 if an empty list\n  \
    \      if (nums.isEmpty) 0\n        // else return nums.length if all list elements\
    \ are even\n        else if (nums.filter(_ % 2 == 0).length == nums.length) nums.length\n\
    \        // else return a count of elements with odd first and odd last numbers\n\
    \        else nums.count(x => { if (x > 10) x > 10 && (x % 2 == 0) }) ", "   \
    \     var count = 0\n        var even = nums.filter(x => x % 2 == 0)\n       \
    \ var odd = nums.filter(x => x % 2 != 0)\n        for (x <- even; y <- odd) \n\
    \            if (x > 10 && x % 2 != 0 && y % 2 != 0) count += 1\n        return\
    \ count", "        var count = 0\n        for ( i <- nums ) \n        {\n    \
    \        if ( i % 2 == 0 && ( i / 10 ) % 2 == 1) \n            {\n           \
    \     count = count + 1\n            }\n        }\n        count", "        if\
    \ (nums.isEmpty)\n            return 0\n        val result: mutable.ArrayBuffer[Long]\
    \ = mutable.ArrayBuffer[Long]()\n        for (num <- nums) {\n            if (num\
    \ > 10 && num.asInstanceOf[Long] % 2 == 0 && num.asInstanceOf[Long] % 2 != 0)\n\
    \                result += num\n        }\n        result.toList.last", "    \
    \    nums.filter {\n            case i => i > 10 && i % 2 == 1 && i % 2 != 0\n\
    \        }.size", '        return nums.count(_ > 10 && _ % 2 != 0 && _ % 3 !=
    0)', "        var count = 0\n        for (i <- 0 until nums.size) {\n        \
    \    val n = nums(i)\n            if (n > 10 && nums(i) < 10 && nums(i%2) == 1)\
    \ {\n                count += 1\n            }\n        }\n        count", " \
    \       val evens = nums.filter(_ % 2 == 0)\n        val odds = nums.filter(_\
    \ % 2 == 1)\n        val counts = evens.takeWhile(x => x < 10).count() + odds.takeWhile(x\
    \ => x < 10).count()\n        (odds(0) != odds(1)) match {\n            case true\
    \ => counts\n            case false => evens.takeWhile(x => x < 10).count() +\
    \ evens.takeWhile(x => x < 10).count()\n        }", "        nums match {\n  \
    \          case Nil => 0\n            case head :: tail =>\n                if\
    \ (head > 10 && tail.last.isOdd && tail.head > 10) {\n                    head.toLong\
    \ + 1\n                } else {\n                    specialFilter(tail)\n   \
    \             }\n        }", '        ', "        // your code goes here\n   \
    \     "]
stop_tokens:
- "\n    }\n"
