name: HumanEval_130_tri
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
  \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
  \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    // tri(1)\
  \ = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n - 1) + tri(n\
  \ - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2) = 1 + (2 /\
  \ 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n    // =\
  \ 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n, you have\
  \ to a return a list of the \n    // first n + 1 numbers of the Tribonacci sequence.\n\
  \    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong, 3l.toLong,\
  \ 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
  \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
  \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
  \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
  \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n    assert(tri((7l)).equals((List[Long](1l.toLong,\
  \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n\
  \    assert(tri((8l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
  \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong,\
  \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
  \ 5l.toLong, 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong,\
  \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
  \ 5l.toLong, 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong,\
  \ 80l.toLong, 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n\
  \    assert(tri((0l)).equals((List[Long](1l.toLong))));\n    assert(tri((1l)).equals((List[Long](1l.toLong,\
  \ 3l.toLong))));\n    }\n\n}\n"
completions: ["        if (n <= 1) \n            List(n.toLong)\n        else {\n\
    \            val (first,second) = tri(n - 1) + tri(n - 2) + tri(n + 1)\n     \
    \       second :: first :: second \n        }", "        var l = List (3L) \n\
    \        while ( l size < n) l.add (l.last.plus ( n / 2L )) \n        l", "  \
    \      val list = new mutable.LinkedList[Long]()\n        list += (3l)\n     \
    \   n match {\n            case n if n >= 1 => list += (1l)\n            case\
    \ n if n % 2 == 0 => list += (n / 2l)\n            case n => list += ((n - 1)\
    \ + n / 2l)\n        }\n        list.toList", "        var l1 = n / 2\n      \
    \  var l2 = (l1 + l1) / 2\n        var l3 = l2 + l1 + l2\n        l3.toList",
  "        val list1 = ListBuffer[Long](1L)\n        val list2 = ListBuffer[Long](3L)\n\
    \        val list3 = ListBuffer[Long](2L)\n        val list4 = ListBuffer[Long](8L)\n\
    \        for (i <- 1 to n) {\n            list1 += i\n            list2 += tri(n\
    \ - i)\n            list3 += tri(n - i) + tri(n - i - 1)\n            list4 +=\
    \ tri(n - i) + tri(n - i - 1) + tri(n - i + 1)\n        }\n        list3.toList",
  "        def triHelper(n: Long, acc: Long): Long = {\n            acc match {\n\
    \                case 2 => acc.toLong\n                case 1 => acc.toLong\n\
    \                case n => triHelper(n - 1, acc) + triHelper(n - 2, acc + n.toLong)\n\
    \            }\n        }\n        val result = new ArrayList[Long]()\n      \
    \  result ::= triHelper(n, 3l.toLong)\n        return result.toList.map(_.toLong)",
  "        val l = n % 2 == 0\n        val f = (if (l) 1L else 2L) + n\n        val\
    \ res = List(f,f+f,f+f+f)\n        if (n<2) res\n        else res + tri(n-1)",
  "        val list = List[Long]()\n        if (n <= 3) {\n            list += n toLong\n\
    \        }\n        else {\n            list += n / 2 toLong\n            list\
    \ += n / 2 toLong\n            list += n + 1 toLong\n        }\n        list",
  "      var x = 1\n      var y = 1\n      val newList = new Array[Long](n)\n    \
    \  newList(0) = y\n      newList(1) = x\n      newList(n) = x + y + (newList(n\
    \ - 1) +  newList(n - 2) +  newList(n - 3))\n      newList", "        val list\
    \ = mutable.ArrayBuffer.empty[Long]\n        if (n.toInt % 2 == 0) list.toList\
    \ ++= 0 +: tri(n.toInt/2)\n        else list.toList ++= 1 +: tri(n.toInt/2 + 1)\n\
    \        list.toList", "        val a = 1 + n / 2\n        if (n % 2 == 0) {\n\
    \            n / 2\n        } else {\n            tri(n-1) + tri(n-2) + tri(n+1)\n\
    \        }", "        if (n < 0) Nil\n        else n match {\n            case\
    \ 0 => List(1L, 0L, 0L)\n            case 1 => List(3L, 2L, 1L)\n            case\
    \ n => tri(n-1) + tri(n-2) + tri(n+1)\n        }", "        if (n < 3) {\n   \
    \         List[Long](n, n, n).reverse\n        } else if (n >= 3) {\n        \
    \    val n2 = n - 2\n            val n3 = n + 3\n            val n1 = 3n\n   \
    \         val n4 = (1 + n2).max(1)(2) + ((n3 - n).max(n4).max(1))\n          \
    \  val n5 = (1 + n3).max(1)(2)\n            val n6 = (1 + n4).max(1)(2)\n    \
    \        List(n1, n4, n5, n6)\n        }", "        // This is O(N) because we\
    \ are iterating through every number in the sequence \n        // which means\
    \ we are iterating through every power of two until we get to the \n        //\
    \ point where n is even (n / 2 is even).\n        var result: List[Long] = List(1,\
    \ n)\n        while (result.length < n) result = result ::: (List(result.last.toLong\
    \ + result.last.toLong + result.last.toLong, result.last.toLong + result.last.toLong,\
    \ result.last.toLong + result.last.toLong))\n        result", "        n match\
    \ {\n            case 0 => List(1l)\n            case n if n <= 1 => List(n.toLong)\n\
    \            case n if n % 2 == 0 =>\n                val left = tri(n - 2).toList\n\
    \                val right = tri(n - 1).toList\n                left.reverse :::\
    \ right\n            case n => tri(n - 1) + tri(n - 2) + tri(n + 1)\n        }",
  "        if (n == 0) List(1l.toLong)\n        else if (n % 2 == 0) List(3l.toLong,\
    \ 1l.toLong)\n        else tri(n-1)  ++ tri(n-1) + tri(n+1)", "        require(n\
    \ > 0);\n        val t0 = 2l;\n        val t1 = (1l + 1l) / 2;\n        val t2\
    \ = ((1l - 1l + 1l - 2l) / 3) + t1\n        val result = List(t0, t2, n + 1l);\n\
    \        result", "        val tria = 3L\n        var listTrib = new mutable.ListBuffer[Long]()\n\
    \        for(i <- 0 until n) listTrib += tria + tria + tria\n        listTrib.toList",
  "        if(n==0) List(3l.toLong)\n        if(n==1) List(1l.toLong)\n        if(n==2)\
    \ List(2l.toLong)\n        if(n%3 == 0) List(tri(n.toInt-1) + tri(n.toInt-2) +\
    \ tri(n.toInt+1))\n        else List(tri(n.toInt-1) + tri(n.toInt-2))", "    \
    \    if (n < 3l)\n            return List(1l, 3l)\n        if (n % 2 == 0)\n \
    \           return List(1l, tri(n / 2)(1) + tri(n / 2)(2))\n        else\n   \
    \         return List(tri(n - 1)(1) + tri(n - 1)(2) + tri(n / 2)(1))", "     \
    \ val r = mutable.MutableList[Long]()\n      r += n.toLong\n      n match {\n\
    \        case x if x < 3 => r\n        case x if x > 3 =>\n          val n1 =\
    \ (n-1).toLong\n          val n2 = (n-2).toLong\n          val n3 = n+1.toLong\n\
    \          n1 +: n2 +: n3 +: r.reverse\n        case _ =>\n      }", "       \
    \ val res : List[Long] = new ListBuffer[Long]()\n        val base : Long = 3\n\
    \        var n2 : Long = 1\n\n        if (n <= 1) {\n            res.append(n)\n\
    \        } else {\n            while (n > 0) {\n                n2 = (n + n) /\
    \ base\n                if (n2 % 2 == 0) {\n                    res.append (n2)\n\
    \                }\n                n = n2\n            }\n        }\n\n     \
    \   res.toList", "        def go(n: Long, result: List[Long]): List[Long] = {\n\
    \            if (n <= 0) {\n                result\n            } else {\n   \
    \             go(n / 2, result :: (n + result))\n            }\n        }\n  \
    \      go(n, Nil)", "        val rec = new mutable.ListBuffer[Long]()\n      \
    \  def addrec(n:Long, prev:Long): Unit = { \n            if (n<=0) rec += prev\n\
    \            else { \n                addrec(n-1, prev+n) // Add previous number\
    \ to the current tribonacci number\n                addrec(n-2, prev+n-1) // Add\
    \ previous two numbers to the current tribonacci number\n                addrec(n+2,\
    \ prev+n-2)  // Add previous three numbers to the current tribonacci number\n\
    \            }\n        }\n        addrec(n+1, 0l) // Add the initial number to\
    \ the recusive method\n        rec.toList", "        val t0 = if (n==0) 1L else\
    \ 3L\n        val t1 = t0 + 1L / 2\n        val t2 = tri(t1) - tri(t0) - tri(t1+1)\n\
    \        (t0 :: t1 :: t2 :: Nil).reverse", "        if (n <= 0) {\n          \
    \  return Nil\n        }\n        if (n == 1 || n == 2) {\n            return\
    \ List(1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong)\n        }\n        if (n %\
    \ 2 == 0) {\n            return tri(n - 1) + tri(n - 2) + tri(n + 1)\n       \
    \ } else {\n            return tri(n - 2) + tri(n - 1) + tri(n + 1)\n        }",
  "        def helper(n1: Long, n2: Long, n3: Long, n4: Long): List[Long] = {\n  \
    \          if (n1 == 0l) List(1l, n2l, n3l, n4l)\n            if (n2 == 0l) List(1l,\
    \ n2l, n3l, n4l)\n            if (n3 == 0l) List(1l, n2l, n3l, n4l)\n        \
    \    if (n4 == 0l) List(1l, n2l, n3l, n4l)\n            else {\n             \
    \   val n5l = n1 + n2\n                val n6l = n3 + n4\n                val\
    \ n7l = n5l + n6l\n                val n8l = n7l + n1\n                val n9l\
    \ = n8l + n2l\n                val n10l = n9l + n3l\n                val n11l\
    \ = n10l + n4l\n                val n12l = n11l + n5l\n                val n13l\
    \ = n12l + n6l\n                val n14l = n13l + n7l\n                val n15l\
    \ = n14l + n8l\n                val n16l = n15l + n9l\n                val n17l\
    \ = n16l + n10l\n                val n18l = n17l + n11l\n                val n19l\
    \ = n18l + n12l\n                val n20l = n19l + n13l\n                val n21l\
    \ = n20l + n14l\n                val n22l = n21l + n15l\n                val n23l\
    \ = n22l + n16l\n                val n24l = n23l + n17l\n                val n25l\
    \ = n24l + n18l\n                val n26l = n25l + n19l\n                val n27l\
    \ = n26l + n20l\n                val n28l = n27l + n21l\n                val n29l\
    \ = n28l + n22l\n                val n30l = n29l + n23l\n                val n31l\
    \ = n30l + n24l\n                val n32l = n31l + n25l\n                val n33l\
    \ = n32l + n26l\n                val n34l = n33l + n27l\n                val n35l\
    \ = n34l + n28l\n                val n36l = n35l + n29l\n                val n37l\
    \ = n36l + n30l\n                val n38l = n37l + n31l\n                val n39l\
    \ = n38l + n32l\n                val n40l = n39", "        if (n < 2l)\n     \
    \       List(1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong)\n        else\n     \
    \       List(\n                tri(n - 1l) + \n                tri(n - 2l) + \n\
    \                tri(n + 1l)\n                )", "        if(n <= 0) Nil\n  \
    \      else {\n            val rem = n % 2 == 0\n            val a1 = n + rem\
    \ + 1\n            val a2 = (n + rem) + a1 + 1\n            val a3 = n + a2 +\
    \ 1\n            val a4 = n + (a3 + a2)\n            val result = List(a1.toLong,a2.toLong,a3.toLong,a4.toLong)\n\
    \            result ::: tri(a2)\n        }", "        def tri(n: Long, acc: List[Long])\
    \ : List[Long] = n match {\n            case 0 => acc\n            case 1 => tri(2,\
    \ List(0l, 1l))\n            case 2 => tri(2, acc :+ tri(2, List(0l, 1l)) :+ tri(3,\
    \ acc :+ 2l))\n            case n => tri(n-1, acc :+ tri(n-1, List(n/2, n/2, n+1)))\
    \ :+ tri(n+1, acc :+ n+1)\n        }\n        tri(n, List(0l))", "        var\
    \ fibo : List[Long] = Nil\n        var tribo = List (3l)\n        for (i <- 0\
    \ until n) {\n            tribo = tribo :+ tribo :+ (i+1l)/2\n            fibo\
    \ = fibo :+ fibo :+ (i+1l)\n        }\n        fibo", "        val list1 = (3l).toList\n\
    \        val list2 = (2l toList drop 1l drop 1l)\n        val list3 = list1 ++\
    \ list2\n        list3.reverse drop 1 toList", "        val fibonacci = mutable.ListBuffer[Long]()\n\
    \        fibonacci.+=((3l).toLong)\n        var i = 0\n        while (i < n) {\n\
    \            fibonacci.+=((fibonacci(i -1) -1) +1)\n            i += 1\n     \
    \   }\n        fibonacci.slice(1, fibonacci.size).toList", "        val r = List(1,\
    \ 3, 2);\n        val r = r.reduce(_ + _);\n        val r = r.reduceLeft((a, b)\
    \ => a + b + b + a)\n        val r = r.reduceRight((a, b) => a + b + b + a)\n\
    \        r match {\n            case n+1 => List(n)\n            case n => List(n)\n\
    \            case _ => tri(n-1) + tri(n-2) + tri(n+1) + tri(n+2)\n        }",
  "        if (n == 0) List(3l.toLong)\n        else if (n % 2 == 0) List(1l.toLong,\
    \ tri(n.toInt -1) + tri(n.toInt -2) + tri(n.toInt + 1))\n        else tri(n.toInt\
    \ -1) + tri(n.toInt -2) + tri(n.toInt + 1) + tri(n.toInt + 2)", "        val fib_lst\
    \ = List(0l, 1l, 2l)\n        var lst : List[Long] = null\n        var sum : Long\
    \ = 0\n        for ( a <- 0 to (n - 1) ) {\n            lst += fib_lst\n     \
    \   }\n        if ( n > 0 ) {\n            lst = lst.drop(1).take(n).reverse.map\
    \ { n =>\n                sum += n\n                n\n            }\n       \
    \     lst\n        } else {\n            List.empty\n        }", "        val\
    \ fib = Seq(1,1,2)\n        val ls = (1 to n).foldLeft(List(0l)) { \n        \
    \   case (acc, i) => acc :: (i+1l) :: (fib.drop(i).take(n-i).drop(1).map(_+_))\
    \ \n        }\n        ls.reverse", "        val list = ListBuffer.empty[Long]\n\
    \        \n        val n1 = n + 1\n        \n        list.add(3l)\n        \n\
    \        if (n % 2 == 0) {\n            for (i <- 1 to n1){\n                list.add(tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1))\n            }\n        } else {\n         \
    \   for (i <- 1 to n1){\n                list.add(tri(n - 1) + tri(n - 2) + tri(n))\n\
    \            }\n        }\n        list.toList", "      if (n == 0) List(0l)\n\
    \      if (n == 1) List(3l)\n      if (n % 2 == 0) List(tri(n - 1) + tri(n - 2)\
    \ + tri(n + 1), tri(n - 2) + tri(n + 1))\n      else tri(n - 2) + tri(n + 1)",
  "        if (n <= 0) List(1l, 0l, 0l, 0l)\n        else if (n % 2 == 0) tri(n -\
    \ 1) + tri(n - 2) + tri(n - 1).toList\n        else tri(n - 1) + tri(n - 2) +\
    \ tri(n - 1).toList + tri(n - 1).toList", "        if (n <= 0) {\n           \
    \ List.empty\n        } else {\n            val a = List(1)\n            val b\
    \ = List(3, 2)\n            val m = n / 2\n            List(a + b + b.dropRight(m))\n\
    \        }", "        val fib  = mutable.ListBuffer[Long]()\n        fib += 3l\n\
    \        fib ++= (n/2).filter(_%2==0).toList\n        if (n%2==1) {\n        \
    \    fib ++= (n-1).filter(_%2==1).toList\n        }\n        fib.toList", "  \
    \      val first = (if(isEven(n)) 3l else 1l).toLong\n        val second = (if(isEven(n))\
    \ (n - 1l).toLong else (1l + (n - 1l).toLong)).toLong\n        val third = (if\
    \ (isEven(n)) (n - 2l).toLong else (second + (n - 2l).toLong)).toLong\n      \
    \  List(first, second, third)", "        if (n == 0) \n            List(1L, 3L,\
    \ 2L, 8L)\n        else if (n % 2 == 1)\n            List((tri(n / 2).toLong +\
    \ tri(n / 2 + 1).toLong + tri(n / 2 + 2).toLong).toList)\n        else\n     \
    \       List((tri(n / 2).toLong + tri(n / 2 + 1).toLong + tri(n / 2 + 2).toLong).toList)",
  "        def triR(n: Long, prev: Long): List[Long] = {\n            if (n == 0)\
    \ List(1l.toLong, 3l.toLong, 2l.toLong)\n            else {\n                if\
    \ (n % 2 == 1) triR(n + 1, prev + (n / 2l.toLong))\n                else triR(n\
    \ - 1, prev + n + 1)\n            }\n        }\n        triR(n, 0l).toList", " \
    \       var ans = ListBuffer[Long]()\n        \n        if (n == 0) ans += 1\n\
    \        if (n == 1) ans += 3\n        \n        if (n % 2 == 0)\n           \
    \ ans ++= tri(n - 1) + tri(n - 2) + tri(n + 1)\n        else\n            ans\
    \ ++= tri(n - 3) + tri(n - 2) + tri(n - 1)\n        \n        ans.toList", " \
    \       if (n < 0) return Nil\n        val a = tri(n - 1).toList\n        val\
    \ b = tri(n - 2).toList\n        val c = tri(n - 3).toList\n        if (n % 2\
    \ == 0) a ::: b ::: c\n        else if (n % 2 == 1) a ::: c ::: b\n        else\
    \ a ::: b ::: c", "      require(n > 0)\n      if (n <= 2l){\n        List(1l.toLong,\
    \ 3l.toLong)\n      } else if (n <= 4l){\n        List(2l.toLong, 3l.toLong, 1l.toLong)\n\
    \      } else {\n        val tri_list_1 = tri(n - 1l) + tri(n - 2l)\n        val\
    \ tri_list_2 = tri(n - 1l) + tri(n - 2l) + tri(2n + 3l)\n        List(tri_list_1,\
    \ tri_list_2)\n      }", "        require(n >= 0)\n        if (n <= 2) List(n)\
    \ \n        else List(tri(n-1) + tri(n - 2) + tri(n + 1), tri(n - 1) + tri(n -\
    \ 2), tri(n + 1))", "        def helper(n: Long, prev: Long, cur: List[Long])\
    \ : List[Long] = {\n            if ((n & 1) == 1) {\n                cur.head\
    \ :: prev\n            } else {\n                prev :: cur.head :: cur.tail\n\
    \            }\n        }\n        val prev = 0l\n        val cur = List(0l).reverse\n\
    \        while (n > 0) {\n            val next = cur.head + cur.tail\n       \
    \     val newN = n - 1\n            cur = helper(newN, prev, cur)\n          \
    \  prev = next\n            n -= 1\n        }\n        cur.reverse", "       \
    \ def tri(n: Long, n1: Int, n2: Int, n3: Int): List[Long] = {\n            if\
    \ (n == 0) {\n                return List(1L.asInstanceOf[Long], 3L.asInstanceOf[Long],\
    \ 2L.asInstanceOf[Long], 8L.asInstanceOf[Long])\n            } else if (n % 2\
    \ == 0) {\n                return tri(n - 1, n1 + n2, n2, n3 + n3)\n         \
    \   } else {\n                return tri(n - 1, n1, n1 + n2 + n3, n3)\n      \
    \      }\n        }\n        tri(n, 0, 1, 2)", "        if (n == 0) List(0l)\n\
    \        if (n == 1) List(1l)\n        if (n % 2 == 0) tri(n - 1l :: 1l :: 3l\
    \ :: nl :: nl :: nl)\n        else  tri(n - 1l :: 1l :: 2l :: nl :: nl :: nl)",
  "        def fib(n: Long) = if (n==0) 1 else if (n==1) 1 else fib(n-1)+fib(n-2)\n\
    \        val list = mutable.ListBuffer(1l, 3l)\n        for (i <- 0 to n-1) {\n\
    \            list += fib(list.last)\n        }\n        list.toList", "      \
    \  val nn = n.toInt\n        val firstList = List(1, 3)\n        var firstTribonacci\
    \ = firstList.head\n\n        def tri(i : Long) : List[Long] = {\n           \
    \ val result = i + firstTribonacci + i\n            if (result%2 == 0) firstTribonacci\
    \ = i else firstTribonacci = i + 3\n            firstTribonacci\n        }\n\n\
    \        if (nn == 0) firstList else tri(nn-1) + tri(nn-2) + tri(nn+1)", "   \
    \     val a = ListBuffer.empty[Long]\n        val b = ListBuffer.empty[Long]\n\
    \        val c = ListBuffer.empty[Long]\n        a(0) = 3\n        b(0) = 1\n\
    \        for(x <- 1 to n){\n            if(x % 2 == 0) a(x) = a(x-1) + a(x-2)\n\
    \            else a(x) = a(x-1) + a(x-2) + a(x+1)\n            if(x+2 > n) b(x)\
    \ = a(x+1) + a(x+2)\n            else b(x) = a(x+1) + a(x+2) + a(x+2)\n      \
    \  }\n        for(x <- 1 to n) c(x) = a(x) + b(x)\n        for(x <- 1 to n) a(x)\
    \ = c(x)\n        a.toList", "        if(n == 0)\n            List(0l)\n     \
    \   else if(n == 1)\n            List(3l)\n        else if(n == 2)\n         \
    \   List(1l, 3l)\n        else\n            List(0l, 1l, 3l, 2l, 8l, 3l, 6l, 5l,\
    \ 7l, 4l, 9l, 8l, 7l, 5l, 3l, 6l, 2l)", "        def fib(i : Int) : Long = {\n\
    \            if (i == 0) 1L else fib(i - 1) + fib(i - 2)\n        }\n        val\
    \ ans = mutable.ListBuffer.empty[Long]\n        fib(n.toInt) match {\n       \
    \     case i if i != 0 =>\n            ans += i.toLong\n            i match {\n\
    \                case i if i % 2 == 0 => \n                    ans += tri(n -\
    \ 1) + tri(n - 2) + tri(n + 1) \n                case i if i % 2 == 1 => \n  \
    \                  ans += tri(n - 1) + tri(n - 2) \n                case i =>\n\
    \            }\n            case i =>\n        }\n        ans", "        val result\
    \ = mutable.ListBuffer.empty[Long]\n        val l1 = n / 2\n        val l2 = l1\
    \ + l1\n        val l3 = l2 + l2\n        result :+= l1\n        if (n % 2 ==\
    \ 0) {\n            result :+= l2\n            result :+= l3\n        }\n    \
    \    result.toList", "        // Write your solution here\n        var firstThree\
    \ = List(1)\n        var secondThree = List(1)\n        var thirdThree = List(1)\n\
    \        var nextN = n + 1\n        if (nextN % 2 == 0) {\n            firstThree\
    \ = thirdThree = nextN / 2\n            nextN = nextN >> 1\n        }\n      \
    \  else {\n            secondThree = thirdThree = nextN - 1\n            nextN\
    \ = nextN >> 1\n        }\n        List((firstThree, secondThree, thirdThree))",
  "        val li = new scala.collection.mutable.ListBuffer[Long]\n        li.+=(n)\n\
    \        if (n.toLong % 2 == 0) {\n            li.+=((tri(n.toLong - 1).map( x\
    \ => x + x ) + tri(n.toLong - 2).map( x => x + x )).filter( x => x <= n ).toList);\n\
    \        }\n        else {\n            li.+=((tri(n.toLong - 1).map( x => x +\
    \ x ) + tri(n.toLong - 2).map( x => x + x )).filter( x => x > n ).toList);\n \
    \       }\n        li.+=((tri(n.toLong + 1).map( x => x + x ) + tri(n.toLong +\
    \ 2).map( x => x + x )).filter( x => x >= n ).toList);\n        li.filter(x =>\
    \ x % 1 == 0).toList;", "        if(n<=0) return Nil\n        if(n==1) return\
    \ List(3l.toLong)\n        val f1 = (n % 2 == 0) ?  tri(n - 1)+(tri(n-1) + tri(n\
    \ +1))/3 : tri(n - 1) \n        val f2 = tri(n - 2) + (tri(n -1) + tri(n +2))/3\n\
    \        val f3 = tri(n + 1) + (tri(n -1) + tri(n +2))/3\n        List(f1, f2,\
    \ f3)", "        val list = new mutable.ListBuffer[Long]()\n        var fibonacci\
    \ : Long = 0\n        var tribonacci : Long = 0\n        var i : Long = 1\n  \
    \      while(i<=n){\n            fibonacci = fibonacci + i\n            tribonacci\
    \ = tribonacci + fibonacci\n            list.+=(i.toLong)\n            i = i +\
    \ 1\n        }\n        list.+=(i.toLong)\n        return list.toList", "    \
    \    val evenN : Long = n%2 == 0\n        val evenTribonacci = List(1l, 3l, 2l).filter(_\
    \ % 2 == 0)\n        val oddeTribonacci = List(1l, 3l, 2l).filter(_ % 2 == 1).filter(_\
    \ != evenN)\n        (evenTribonacci ++ oddeTribonacci).take(n + 1).map(_.toLong)",
  "      import scala.math._\n      val a = List(3, tri(n - 1) + tri(n - 2) + tri(n\
    \ + 1))\n      a.drop(1).take(n + 1).map(_.toLong)", "        def tri_aux(n :\
    \ Long, acc : List[Long]): List[Long] = {\n            if (n == 0) acc\n     \
    \       else tri_aux(n - 1, (tri_aux(n - 2, acc :+ tri(n - 1) + tri(n - 2)) :\
    \ List[Long]) + tri(n + (n % 2 == 0 ? 1 : 2)))\n        }\n        tri_aux(n +\
    \ 1, Nil)", "        if (n == 1) List(n) \n        else if (n % 2 == 0) {\n  \
    \          val list1 = tri(n - 1) + tri(n - 2)\n            list1.take(n + 1).reverse\n\
    \        } \n        else {\n            val list2 = tri(n - 3) + tri(n - 2) +\
    \ tri(n - 1) + tri(n + 1)\n            list2.take(n + 1).reverse\n        }",
  "        val l = new mutable.ListBuffer[Long]()\n        if(n % 2 == 0) {\n    \
    \        l.append(3L);\n            n.toLong match {\n                case n if\
    \ n > 1L => l.append(tri(n-1) + tri(n-2) + tri(n+1))\n                case _ =>\
    \ l.append(n)\n            }\n        }\n        else if(n % 2 == 1) {\n     \
    \       l.append(1L);\n            n.toLong match {\n                case n if\
    \ n > 2L => l.append(tri(n-1) + tri(n-2) + tri(n+1))\n                case _ =>\
    \ l.append(n)\n            }\n        }\n        else if(n % 2 == 0) {\n     \
    \       l.append(2L);\n            n.toLong match {\n                case n if\
    \ n > 3L => l.append(tri(n-1) + tri(n-2) + tri(n+1))\n                case _ =>\
    \ l.append(n)\n            }\n        }\n        else if(n % 2 == 1) {\n     \
    \       l.append(8L);\n            n.toLong match {\n                case n if\
    \ n > 5L => l.append(tri(n-1) + tri(n-2) + tri(n+1))\n                case _ =>\
    \ l.append(n)\n            }\n        }\n        else if(n % 2 == 0) {\n     \
    \       l.append(3L);\n            n.toLong match {\n                case n if\
    \ n > 5L => l.append(tri(n-1) + tri(n-2) + tri(n+1))\n                case _ =>\
    \ l.append(n)\n            }\n        }\n        else if(n % 2 == 1) {\n     \
    \       l.append(8L);\n            n.toLong match {\n                case n if\
    \ n > 7L => l.append(tri(n-1) + tri(n-2) + tri(n+1))\n                case _ =>\
    \ l.append(n)\n            }\n        }\n        else l.append(1L)\n        l.toList",
  "        def aux(tris : List[Long], acc : Long) : List[Long] =\n            if (tris.size\
    \ < n + 1) tris.reverse else aux(tris.take(n + 1).reverse :: tris.drop(tris.size\
    \ - (n + 1)),\n                (n + 1) * (tris(n).toLong + tris(n + 1).toLong))\n\
    \        aux(Nil, 0)", "        val l = new ArrayList[Long]\n        if (n.toLong\
    \ == 0) l :+ 0\n        else if (n.toLong == 1) l :+ 1\n        else if (n.toLong\
    \ == 2) l :+ 2\n        else if (n.toLong % 2 == 0) l :+ tri(n - 1) + tri(n -\
    \ 2) + tri(n +1)\n        else l :+ tri(n - 1) + tri(n - 2) + tri(n + 1) + tri(n\
    \ + 2)", "        require(n > 0)\n        if (n == 1L) {\n            return Nil\n\
    \        }\n        else {\n            val n2 = n/2\n            val n3 = n2\
    \ + n\n            val n5 = n3 + n\n            val n7 = n5 + n\n            return\
    \ List(1L + n2, n3, n5, n7)\n        }", "        val fibo = mutable.Stack[Long]()\n\
    \        fibo += 3\n        fibo.takeWhile(_ < n).map(_+_)", "        // Your\
    \ code here\n        var n = 3\n        var triSeq = mutable.List.empty[Long]\n\
    \        while(n>0) {\n            triSeq :+= n\n            n += n / 2\n    \
    \    }\n        triSeq :+= triSeq.last\n        triSeq", "        if (n < 0L)\
    \ throw new RuntimeException(\"n must be positive\")\n        val a = 3L\n   \
    \     val b = ((a + 1L) / 2L)\n        val c = ((a+b+1L) / 3L)\n        val tri\
    \ = List(1L,b+1,c)\n        if (n % 2L == 0L)\n            tri.toList\n      \
    \  else\n            tri.tail.toList ::: tri.init.toList", "        require(n\
    \ >= 0, \"n should be non-negative\")\n        if (n == 0 || n == 1)\n       \
    \     List(1l.toLong)\n        else if (n % 2 == 0)\n            tri(n - 1) +\
    \ tri(n - 2)\n        else\n            tri(n - 1) + tri(n - 2) + tri(n / 2)",
  "        if (n == 0 || n == 1) {\n            return List(1l, 3l)\n        }\n \
    \       if (n == 2) {\n            return List(n1l(2l), n1l(1l))\n        }\n\
    \        val r0 = tri(n-1)\n        val r1 = tri(n-2)\n        val r2 = tri(n-3)\n\
    \        return r0 ::: r1 ::: r2 ::: n4l(n-4)", "        val a = new Array[Long](3L)\n\
    \        a(0) = 1\n        a(1) = 3\n        var b = 1\n        for(i <- 2 to\
    \ n+1)\n        {\n            a(i) = b\n            b = (b + a(i-1)).toLong\n\
    \        }\n        a(n) = b\n        a.toList", "        val res : List[Long]\
    \ = n match {\n            case 0 | 1 | 2 => List(1l.toLong, 3l.toLong, 2l.toLong)\n\
    \            case 4 | 5 | 6 => List(3l.toLong, 2l.toLong, 1l.toLong)\n       \
    \     case 7 | 8 => List(2l.toLong, 1l.toLong, 0l.toLong)\n        }\n       \
    \ n match {\n            case 0 => res\n            case k => res.flatMap(n =>\
    \ tri(n - 1) + tri(n - 2) + tri(n + 1))\n        }", "        val list = new Array[Long](n\
    \ +1)\n        val evenList = list.drop(0)\n        val oddList = list.drop(1)\n\
    \        list.foreach { x =>\n            if (x%2 == 0) evenList += x\n      \
    \      else oddList += x\n        }\n        list", "        // Base case\n  \
    \      if (n == 0) List(1L, 3L) \n        // Recursion step\n        else if (n\
    \ % 2 == 0) \n            tri(n - 1) + tri(n - 2) + tri(n + 1) \n        else\
    \ \n            tri(n - 1) + tri(n - 2) + tri(n + 1) + tri(n / 2) ", "       \
    \ val triSeq = mutable.Seq[Long](3l.toLong, 1l.toLong, 1l.toLong, 2l.toLong)\n\
    \        val lastVal = triSeq.last\n        val newTriSeq = triSeq.map { x =>\
    \ if (x % 2 == 0) x + lastVal else x - lastVal }\n        val lastIndex = triSeq.size\
    \ - 1\n        newTriSeq.take(n - (lastIndex + 1))", "        n match {\n    \
    \        case 0 => List(0l.toLong)\n            case 1 => List(1l.toLong)\n  \
    \          case n => \n                val a = tri(n / 2)\n                val\
    \ b = tri(n - 1) + tri(n - 2) + tri(n + 1)\n                a ++ b\n        }",
  "        // We store all numbers in the sequence\n        val numbers = new ArrayList[Long]\n\
    \        numbers.add(1L)\n        numbers.add(3L)\n        // The first three\
    \ fibonacci numbers are stored in numbers list\n        if (n >= 2) numbers.add(2L)\n\
    \        // The last two fibonacci numbers are stored in numbers list\n      \
    \  \n        // The last number in the sequence is calculated by adding the last\
    \ two numbers in the sequence\n        val last = numbers.get(n-2) + numbers.get(n-1)\n\
    \        numbers.add(last)\n        // The last fibonacci number after the first\
    \ two numbers in the sequence is calculated by adding the last two numbers after\
    \ the third number in the sequence\n        val lastTwo = numbers.get(n-2) + numbers.get(n-1)\
    \ + numbers.get(n)\n        numbers.add(lastTwo)\n        numbers.asInstanceOf[List[Long]]",
  "        if (n == 0) Nil\n        else if (n % 2 == 0) (n to 1l) map (_.toLong)\
    \ ::: tri(n - 1l) ::: tri(n - 2l) ::: tri(n + 1l) \n        else (n to 1l) map\
    \ (_.toLong) ::: tri(n - 1l) ::: tri(n + 2l) ::: tri(n + 3l) ", "        if(n\
    \ == 0) List(1l, 3l, 2l)\n        else tri(n - 1) + tri(n - 2) + tri(n + 1)",
  "        var lst = ListBuffer.empty[Long]\n        var prev = 0\n        var cur\
    \ = 1\n        var next = cur + prev + cur\n        while ( n > 0) {\n       \
    \     lst.append(prev)\n            prev = cur\n            cur = next\n     \
    \       next = cur + prev + cur\n            n -= 1\n        }\n        lst.iterator",
  "        var list: List[Long] = List().init\n        if (n < 2)\n            list\
    \ = (1 to n).map(tri(n + 1))\n        else\n            list = (tri(n - 1) + tri(n\
    \ - 2) + tri(n + 1)).take(n + 1).reverse\n        list.toList", "        var a\
    \ = 0\n        var b = 1\n        var c = 2\n        var ls = List(a, b, c).toList\n\
    \        var i = 0\n        while(i < n) {\n            ls = ls :+ c\n       \
    \     b = c\n            c = a + b\n            a = b\n            i += 1\n  \
    \      }\n        return ls", "        val fibo = mutable.ListBuffer(\n      \
    \      mutable.ListBuffer((1L).toLong, 3L).toList\n        )\n        for (i<-1\
    \ to n / 2) fibo ::= (fibo(i).zip(fibo(i + 1)).map(x => x(0) + x(1))).toList\n\
    \        if (n % 2 == 1) fibo.flatMap(x => List(x.toLong, x.toLong + x.toLong))\n\
    \        else fibo.flatMap(x => List(x.toLong, x.toLong + x.toLong + x.toLong))",
  "        def add(a: Long, c : Long, d: Long) : List[Long] = {\n            a ::\
    \ c :: d :: Nil\n        }\n        def recur(n: Long, a: Long, c : Long, d :\
    \ Long) : List[Long] = {\n            n match {\n                case 1 => List(d)\n\
    \                case 2 => List(a, d)\n                case 3 => List(a, c, d)\n\
    \                case _ => {\n                    val newA = add(a, c, d)\n  \
    \                  recur(n - 1, newA, c, d)\n                }\n            }\n\
    \        }\n        recur(n, 1, 1, 1)", "        def fib(n: Int): Int = {\n  \
    \          if(n == 1) 2 else if (n == 0) 1 else {\n                val next =\
    \ fib(n-1) + fib(n-2)\n                if (n % 2 == 0) next else next + 1\n  \
    \          }\n        }\n        val list = mutable.MutableList[Long]()\n    \
    \    for(i <- 1 to n){\n            list += fib(2*i).toLong\n        }\n     \
    \   list.slice(0,n+1)", "        // Recursion is elegant\n        // But this\
    \ one is harder to explain for beginners.\n        // Let's use 'lazy evaluation'\
    \ technique to get familiar with recursion.\n        // We can use 'recursion\
    \ method' instead of 'while loop'.\n        // First, let's define what this function\
    \ should do.\n        // We are given a list of n numbers, and we want to create\
    \ new list of numbers,\n        // the first n + 1 numbers is the same as the\
    \ first n + 1 numbers of the Fibonacci sequence.\n        // And we can easily\
    \ do that, because we can use the recurrence tri(1) = 3, tri(n) = 1 + n/2, if\
    \ n is even.\n        // And if we want to create new list of numbers, we will\
    \ do that by using tri(n - 1) + tri(n - 2) + tri(n + 1), \n        // if we want\
    \ to create new list of numbers, we will do that by using tri(n - 1) + tri(n -\
    \ 2) + tri(n + 1),\n        // and we know that we must use 'recursion method'\
    \ instead of 'while loop'.\n        // We can solve this problem by using a recursive\
    \ function.\n        // So, let's start by defining this function:\n        def\
    \ fib(n: Long) : List[Long] = {\n            val list = scala.collection.mutable.ListBuffer[Long]()\n\
    \            if (n == 0 || n == 1) {\n                list += n\n            \
    \    return list.toList\n            } else {\n                fib(n-1) + fib(n-2)\
    \ + fib(n+1) + n // recursive call\n            }\n        }\n        // Now,\
    \ we can get familiar with recursive function by using recursion.\n        //\
    \ First, let's define what this function should do.\n        // We are given a\
    \ list of n numbers, and we want to create new list of numbers,\n        // the\
    \ first n + 1 numbers is the same as the first n + 1 numbers of the Fibonacci\
    \ sequence.\n        // And we can easily do that, because we can use the recurrence\
    \ tri(1) = 3, tri(n) = 1 + n/2, if n is even.\n        // And if we want to create\
    \ new list of numbers, we will do that by using tri(n - 1) + tri(n - 2) + tri(n\
    \ + 1), \n        // if we want to create new list of numbers, we will do that\
    \ by using tri(n - 1) + tri(n - 2) + tri(n + 1),\n        // and we know that\
    \ we must use 'recursion method' instead of 'while loop'.\n        // We can solve\
    \ this problem by using a recursive function.\n        // So, let's start by defining\
    \ this function:\n        def fib(n: Long) : List[Long] = {\n            val list\
    \ = scala.collection.mutable.ListBuffer[Long]()\n            if (n == 0 || n ==\
    \ 1) {\n                list += n\n                return list.toList\n      \
    \      } else {\n                fib(n-1) + fib(n-2) + fib(n+1) + n // recursive\
    \ call\n            }\n        }\n", "        require(n >= 0, s\"n must be non-negative,\
    \ got $n\")\n        require(n % 2 == 0, s\"n must be even, got $n\")\n      \
    \  if (n == 0) List(1L, 3L)\n        else (n / 2 :: tri(n-1) + tri(n-2) :: tri(n+1)).toList",
  "        if(n < 3) {\n            List.empty[Long]\n        } else if (n % 2 ==\
    \ 0) {\n            tri(n - 1) + tri(n - 2) + tri(n + 1)\n        } else {\n \
    \           tri(n - 1) + tri(n - 2) + tri(n + 1) + tri(2 * n + 1)\n        }",
  "        def tri_rec(n : Long, acc : List[Long]) : List[Long] = {\n            n\
    \ match {\n                case 0 => acc.reverse\n                case 1 => acc.reverse\
    \ ::: List(1)\n                case 2 => acc.reverse ::: List(1, 3)\n        \
    \        case _ => tri_rec(n-1, acc ::: (tri_rec(n-2, acc ::: List(3, 1))))\n\
    \            }\n        }\n        tri_rec(n, List())", "        if(n == 0) List(1l,\
    \ 3l) \n        else tri(n-1) + tri(n-2) + tri(n+1)", "        val res = List(1L,\
    \ n/2, n-1+(n%2)/2, n-1+(n%2)/2)\n        res.filter(_%2 != 0)", "        val\
    \ rec = new mutable.ListBuffer[Long]\n        if(n <= 0) rec.clear()\n       \
    \ else {\n            val a = tri(n - 1).toLong\n            val b = tri(n - 2).toLong\n\
    \            val c = tri(n - 3).toLong\n            rec += a\n            rec\
    \ += b\n            rec += c\n        }\n        rec.toList", "        n match\
    \ {\n            case 0 | 1 | 2 => List(1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong)\n\
    \            case n => tri(n - 1) + tri(n - 2) + tri(n + 1)\n        }", "   \
    \     var ret: List[Long] = List[Long]()\n        if (n == 0) {\n            ret\
    \ ++= List(0l)\n        } else if (n == 1) {\n            ret ++= List(1l)\n \
    \       } else {\n            val half = n / 2\n            ret ++= tri(n - 1)\
    \ + tri(n - 2) + tri(n + 1)\n        }\n        ret", "        def loop(i: Long,\
    \ result : List[Long], tri : List[Long]) =\n            if (i < 0) tri\n     \
    \       else loop(i-1, result :+ tri(i - 1) + tri(i - 2), tri :+ tri(i - 1))\n\
    \        loop(n, new mutable.ListBuffer[Long](), new mutable.ListBuffer[Long]())",
  "        require(n >= 0) \n        if(n == 0) \n            Nil\n        else \n\
    \            Nil + n :: tri(n - 1) + tri(n - 2) + tri(n - 3)", "        val res\
    \ : List[Long] = ListBuffer[Long]()\n        var tri : Long = n + 3\n        if\
    \ (tri > 0)\n        res += (tri.toLong)\n        if (tri % 2 == 0) {\n      \
    \      var tri : Long = 1\n            while (tri < tri + tri) {\n           \
    \     tri = tri + tri\n                if (tri > 0)\n                res += (tri.toLong)\n\
    \            }\n        }\n        res", "        def f(x : Long, y : Long, sum\
    \ : Long) : List[Long] = if (y == 0) x :: sum\n        else {\n            if\
    \ (x % 2 != 0) y :: sum\n            else\n                f(x-1, y+1, sum + y)\n\
    \        }\n        f(n, n, List())", "        val arr : mutable.ArrayList[Long]\
    \ = new mutable.ArrayList[Long]\n        arr(0) = 1\n        arr(1) = 3\n    \
    \    for(i <- 2 to n) arr(i) = arr(i-1) + arr(i-2)\n        arr(n+1) = arr(n)\
    \ + arr(n-1)\n        arr.toList", "        require(n > 0)\n        val list:\
    \ List[Long] = List().view.map(_.toLong)\n        val fibo = mutable.ArrayBuffer(3l,\
    \ 1l, 2l)\n        var n2 =  if (n >= 0) n else n + 1\n        var n1 = 0\n  \
    \      while (n2 > 0) {\n            n1 += 1\n            list(n1) = fibo(2l)\
    \ + 1l\n            fibo.push(n2)\n            n2 -= 1\n        }\n        list",
  "        var list = List[Long]()\n        if (n == 0) list += 0\n        if (n ==\
    \ 1) list += 3\n        if (n % 2 == 0) list += n + tri(n - 1) + tri(n - 2) +\
    \ tri(n + 1)\n        else list += n / 2 + tri(n / 2) + tri(n / 2 - 1) + tri(n\
    \ / 2 + 1)\n        list.reverse", "        val result = mutable.ListBuffer[Long]()\n\
    \        result += 3l\n        result += n.toLong / 2l\n        if (n.toLong %\
    \ 2 == 0) {\n            result += n.toLong / 2l\n        }\n        result.toList",
  "        var a = 1 \n        var b = 1 \n        var l = 1 \n        var result:\
    \ List[Long] = Nil\n        var currentNumber: Long = n \n        while (currentNumber\
    \ > 2) {\n            a = currentNumber\n            b = b + a \n            l\
    \ = l + currentNumber \n            currentNumber = b + a \n            result\
    \ ::=  b + a + l \n        } \n        result.reverse", "        var fibs = scala.collection.mutable.ListBuffer[Long]()\n\
    \        fibs = fibs.updated(1, 3l)\n        n match {\n            case _ if\
    \ n == 1 => fibs.toList\n            case _ if n % 2 == 0 => fibs = fibs.updated(fibs.tail,\
    \ fibs.head + fibs.tail)\n            case _ if n % 2 != 0 => fibs = fibs.updated(fibs.tail,\
    \ fibs.head + fibs.tail)\n        }", "        val recurrence = if (n % 2 == 0)\
    \ tri(n - 1) else tri(n - 2) + tri(n - 1)\n        val result: List[Long] = recurrence.take(n\
    \ + 1).map(_ + _)\n        result.reverse", "        n match {\n            case\
    \ 0 => List(0l)\n            case 1 => List(0l, 1l)\n            case 2 => List(0l,\
    \ 1l, 2l)\n            case x => {\n                var rec : Long = x match {\n\
    \                    case 0 => 3\n                    case 1 => 1 + x / 2\n  \
    \                  case 2 => tri(x - 1) + tri(x - 2) + tri(x + 1)\n          \
    \      }\n                List(tri(x -1) + rec, rec)\n            }\n        }",
  "        var tri = List(1, 3)\n        if (n%2 == 0) {\n            for (i <- 0\
    \ to n-1) {\n                tri = tri.::(tri(tri.length-1) + tri(tri.length -\
    \ 2) + tri(tri.length))\n            }\n        }\n        else {\n          \
    \  for (i <- 0 to n-1) {\n                tri = tri.::(tri(tri.length-1) + tri(tri.length\
    \ - 2))\n            }\n        }\n        tri.toList", "        var a = 3l\n\
    \        var b = 1l\n        var c: Long = 1l\n        val list = collection.mutable.ListBuffer[Long]()\n\
    \        for {\n            x <- 1 to n \n            if x % 2 == 0\n        \
    \    b = b + a \n            a = a + (2 * b) \n            c <- 1l to n\n    \
    \        if x % 2 == 1\n            list.add(a + c +b)\n        } yield list.toList ",
  "        if (n <= 1) List(n) else {\n            val tri1 = tri(n - 1)\n       \
    \     val tri2 = tri(n - 2) + tri(n - 1) + tri(n - 2)\n            tri1 ::: tri2\n\
    \        }", "        def f1(a : Long, i : Long) : List[Long] = if(i < n) i ::\
    \ f1(a + tri(n - i), i + 1) else List(a)\n        f1(3, 0)", "        if (n ==\
    \ 0) List(1L)\n        else if (n == 1) List(3L)\n        else List(3L, n * ((n-1L)\
    \ + 1L) / 2)", "        def tri0(i: Long, acc: List[Long]) : List[Long] = {\n\
    \            if (i <= 0) List() else tri0(i - 1, tri0(i - 2, acc + i::acc))\n\
    \        }\n        tri0(n + 1, List())", "        val first = n.toLong\n    \
    \    val second = (first+1).toLong\n        val third = (first+second).toLong\n\
    \        val fourth = (first+second+third).toLong\n        val ls = List((first.toLong,3),\
    \ (second.toLong,2), (third.toLong,1), (fourth.toLong,0))\n        ls.flatten",
  "        val n = n.toInt\n        if (n < 3) return List(1)\n        val res = List(1)\n\
    \        if (n % 2 == 0) res += (tri(n - 1)) + (tri(n - 2)) + tri(n +1) + 1\n\
    \        else res += (tri(n - 1) + tri(n - 2) + tri(n + 1))\n        res", " \
    \       def triTri(i : Int) : Long = i.toLong + n/2 - n/(2*i.toLong) + n/(2*(i.toLong+1))\n\
    \        val t0 = -1L\n        val t1 = -1L\n        val t3 = -1L\n        var\
    \ list : List[Long] = List(t0,t1,t3)\n        var i = 2\n        while (i<=n)\
    \ {\n            list ::= triTri(i)\n            i += 1\n        }\n        list.reverse",
  "        val n = n.toLong\n        val temp = new mutable.ArrayBuffer.ofDouble()\n\
    \        val temp2 = new mutable.ArrayBuffer.ofDouble()\n        val temp3 = new\
    \ mutable.ArrayBuffer.ofDouble()\n        var count = 1\n        for(i <- 0 to\
    \ (n+2)/2) {\n            if (i % 2 == 0) {\n                temp += i.toDouble\n\
    \                temp2 += temp.toDouble\n                temp3 += temp2.toDouble\n\
    \            } else {\n                temp += ((temp3 * ((count-1).toDouble)).toDouble)\n\
    \                temp2 += ((temp2 * ((count-1).toDouble)).toDouble)\n        \
    \        temp3 += ((temp3 * ((count-1).toDouble)).toDouble)\n                temp2\
    \ += temp2.toDouble\n                temp3 += temp3.toDouble\n               \
    \ count += 1\n            }\n        }\n        temp.clear()\n        temp2.clear()\n\
    \        temp3.clear()\n        val ls = ListBuffer.ofLong()\n        for(i <-\
    \ 0 to (n+2)/2) {\n            if (i % 2 == 0) {\n                ls += temp(i)\n\
    \            } else {\n                ls += ((temp3 * ((i-1).toDouble)).toLong)\n\
    \            }\n        }\n        ls.toList", "        var temp: Long = 1\n \
    \       var seq: List[Long] = Nil\n        var i: Long = 0\n        if (n <= 0)\
    \ {\n            return Nil\n        }\n        while (i <= n) {\n           \
    \ temp += n\n            seq = Seq(temp.toLong, temp.toLong + seq(1), seq(2) +\
    \ seq(3))\n            i += 1\n        }\n        return seq", "        var a\
    \ = n.toLong + 1\n        var b = a\n        var c = a\n        var list = List[Long](1l,3l,2l,8l)\n\
    \        var newList: List[Long] = list.takeRight(n + 1)\n        while (b < n){\n\
    \            var c = a + b + c\n            a += b\n            b += c\n     \
    \       list += c\n            newList += c\n        }\n        newList.takeRight(n\
    \ + 1).reverse", "        val l: List[Long] = List()\n        if (n <= 2) {\n\
    \            l += n.toLong\n        }\n        else {\n            val leftTri:\
    \ Long = tri(n - 2)\n            val rightTri: Long = tri(n - 1)\n           \
    \ l += leftTri\n            l += rightTri\n            l += leftTri + rightTri\n\
    \        }\n        l", "        val lst = mutable.ListBuffer(3l.toLong)\n   \
    \     if(n > 3l) {\n            lst += tri(n - 3l) + tri(n - 2l) + tri(n + 1l)\n\
    \        }\n        lst.map(_.toLong)", "        if (n == 0) List(0l)\n      \
    \  else {\n            val (a,b,c) = (2l, 1l, 3l)\n            var sum = a + b\
    \ + c\n            var newSum = sum\n            var lastTwo = a + b\n       \
    \     var lastThree = b + c\n            var newList = List(0l)\n            var\
    \ listIter = Iterator.iterate(1l) { _ => \n                newSum += a\n     \
    \           if (newSum > n) {\n                    newSum += c\n             \
    \       lastTwo += b\n                    lastThree += c\n                }\n\
    \                listIter += newSum\n                newSum -= a\n           \
    \     if (newSum > n) newSum -= c\n                listIter += newSum\n      \
    \          newSum -= a\n                if (newSum > n) newSum -= c\n        \
    \        listIter += newSum\n                newSum -= a\n                if (newSum\
    \ > n) newSum -= c\n                listIter += newSum\n                newSum\
    \ -= a\n                if (newSum > n) newSum -= c\n                listIter\
    \ += newSum\n                newSum += b\n                if (newSum > n) {\n\
    \                    newSum += c\n                    lastTwo += b\n         \
    \           lastThree += c\n                }\n                listIter += newSum\n\
    \                newSum -= b\n                if (newSum > n) newSum -= c\n  \
    \              listIter += newSum\n                newSum -= b\n             \
    \   if (newSum > n) newSum -= c\n                listIter += newSum\n        \
    \        newSum -= b\n                if (newSum > n) newSum -= c\n          \
    \      listIter += newSum\n                newSum += c\n                if (newSum\
    \ > n) {\n                    newSum += b\n                    lastTwo += b\n\
    \                    lastThree += b\n                }\n                listIter\
    \ += newSum\n                newSum -= c\n                if (newSum > n) newSum\
    \ -= b\n                listIter += newSum\n                newSum -= c\n    \
    \            if (newSum > n) newSum -= b\n                listIter += newSum\n\
    \                newSum -= c\n                if (newSum > n) newSum -= b\n  \
    \              listIter += newSum\n                newSum += 0\n             \
    \   if (newSum > n) {\n                    newSum += a\n                    lastTwo\
    \ += a\n                    lastThree += a\n                }\n              \
    \  listIter += newSum\n                newSum -= a\n                if (newSum\
    \ > n) newSum -= a\n                listIter += newSum\n                newSum\
    \ -= a\n                if (newSum > n", "        if (n < 3) {\n            List.fill(3).reverse\n\
    \        }\n        else {\n            var a = 1L\n            var b = 2L\n \
    \           var n2 = n\n            var m = 3\n            val list: List[Long]\
    \ = List.fill(5)(List(0L)) \n            while (n2 != 0) {\n                if\
    \ (n2 % 2 == 0) {\n                    list = list ::: (a + b)\n             \
    \       a = b\n                    b = m\n                }\n                else\
    \ {\n                    list = list ::: (m+b)\n                    m = b\n  \
    \                  b = a + m\n                }\n                n2 -= 1\n   \
    \         }\n            list\n        }", '        if(n<2) List[Long](n) else
    tri(n-2)+tri(n-1)+tri(n+1)', "        val recurrence = (n, 3, n, 1)\n        val\
    \ sum = recurrence.foldLeft(0)((total, _) => total + _)\n        val last = recurrence.foldLeft(List[Long]())((lastList,\
    \ number) => lastList :+ number)\n        last.headOption.toList :+ last.last",
  "        val l = (n + 2l).quot(2l)\n        val l1 = l.quot(1l)\n        val l2\
    \ = l.quot(2l)\n        (l1, l2, l2.add(1l))", "        var list = List[Long]()\n\
    \        var temp = 1 \n        // write your code here\n        if (n<=1) {\n\
    \            list += temp\n        }\n        else if ((n%2==0)){\n          \
    \  list = list :+ temp\n            temp = temp + n / 2\n            list = list\
    \ :+ temp\n            list = list :+ temp + n/2\n        }\n        else if ((n%2==1)){\n\
    \            list = list :+ temp\n            temp = temp + n / 2\n          \
    \  list = list :+ temp\n            list = list :+ temp + n\n        }\n     \
    \   return list", "        if(n<2) List(1l.toLong)\n        else tri(n - 1) +\
    \ tri(n - 2) + tri(n + 1) + List(n)", "        if (n == 0) \n            return\
    \ Nil\n        if (n == 1)\n            return Nil\n        val xs = (tri(n-1)\
    \ + tri(n-2) + tri(n+1)).foldLeft(Vector(3))((acc, x) => x :: acc)\n        xs.headOption\
    \ map (x=> x * x) ", "        val list = new mutable.ArrayBuffer[Long]()\n   \
    \     var tri1 = tri(n/3l)\n        list.push(tri1.head)\n        list.push(tri1.last)\n\
    \        var tri2 = tri(n-2l)\n        list.push(tri2.last)\n        list.push(tri2.last+tri2.head)\n\
    \        list", "        if (n == 1) List(1, n)\n        else if (n % 2 == 0)\
    \ tri(n - 1) + tri(n - 2) + tri(n + 1)\n        else tri(n - 1) + tri(n - 2) +\
    \ tri(n + 1) + tri(n + 2)", "      val list = new mutable.ListBuffer[Long]()\n\
    \      def fibonacci(n: Long, list: List[Long]): List[Long] = n match {\n    \
    \    case 1 => list.copy(n -> 1l)\n        case 2 => list.copy(1 -> list.last,\
    \ n -> list.last)\n        case 3 => list.copy(list.last -> list.last + list.last)\n\
    \        case _ => {\n          val a = fibonacci(n - 1, list)\n          val\
    \ b = fibonacci(n - 2, list)\n          val c = fibonacci(n + 1, list)\n     \
    \     a ::: b ::: c\n        }\n      }\n      fibonacci(n, list)", "        val\
    \ first = n / 2\n        val second = (n - first)\n        val third = (first\
    \ + second)\n        List(n, first, second, third, n + first)", "        require(n\
    \ > 0, \"Tribonacci sequence defined only from n>=0.\")\n        require(n % 2\
    \ == 0, \"Tribonacci sequence defined only for even n. Try tri(n-2).\")\n    \
    \    var ret : List[Long] = Nil\n        if (n <= 1) ret = List(n)\n        else\
    \ {\n            val f = tri(n-2)\n            val l = f(0) :: f(1) :: f(2) ::\
    \ f(3) :: Nil\n            ret = f(0) :: l ::  f(1) :: f (3) :: Nil\n        }\n\
    \        ret", "        require(n >= 1, \"n must be positive\")\n        val triArray\
    \ = ListBuffer[Long]()\n        triArray.append(1l)\n        triArray.append(3l)\n\
    \        if ((n + 1) % 2 == 0) {\n            triArray.append(3l)\n          \
    \  triArray.append(2l)\n        } else {\n            triArray.append(1l)\n  \
    \          triArray.append(triArray(1) + triArray(2) + triArray(3))\n        }\n\
    \        return triArray.toList", "        def triaux(n: Long) : List[Long] =\
    \ \n            if (n == 1L) List(1L.toLong)\n            else \n            \
    \    triaux(n / 2L) ++ triaux((n / 2L) + 1L)\n        triaux(n) ", "        //\
    \ write your code in Scala\n        // return List[Long](1, n, tri(n - 1), tri(n\
    \ - 2))\n        val li = new ListBuffer[Long]\n        li += n\n        li.map(_\
    \ + 1) + (if (n % 2 == 0) tri(n - 1) else tri(n - 2))", "        if (n <= 0) Nil\n\
    \        else (n to 1 by -1).map(tri(_ + _)).mkList", "       val ls = mutable.ListBuffer[Long]()\n\
    \       if (n == 0) ls += 0\n       else if (n % 2 == 0) ls += 1 + tri(n / 2)\n\
    \       else ls += tri(n - 1) + tri(n - 2) + tri(n + 1)\n       ls.toList", " \
    \       n match {\n            case 0 => List.empty[Long]\n            case 1\
    \ => List(3L)\n            case 2 => List((1L).toLong, 3L, (2L).toLong, 8L).toList\n\
    \            case 3 => List((1L).toLong, 3L, (2L).toLong, 8L, \n             \
    \       (3L).toLong, 9L, (5L).toLong, 15L, 18L, 20L, 23L, 24L, 25L, \n       \
    \             26L, 28L, 31L, 35L, 36L, 37L, 38L, 39L, 40L, 42L, 43L, 45L, \n \
    \                   46L, 47L, 48L, 49L, 50L, 51L, 52L, 53L, 54L, 55L, 56L, 57L,\
    \ \n                    58L, 59L, 60L, 61L, 62L, 63L, 64L, 65L, 66L, 67L, 68L,\
    \ 69L, \n                    70L, 71L, 72L, 73L, 74L, 75L, 76L, 77L, 78L, 79L,\
    \ 80L, 81L, \n                    82L, 83L, 84L, 85L, 86L, 87L, 88L, 89L, 90L,\
    \ 91L, 92L, 93L, \n                    94L, 95L, 96L, 97L, 98L, 99L, 100L, 101L,\
    \ 102L, 103L, 104L, \n                    105L, 106L, 107L, 108L, 109L, 110L,\
    \ 111L, 112L, 113L, 114L, \n                    115L, 116L, 117L, 118L, 119L,\
    \ 120L, 121L, 122L, 123L, 124L, \n                    125L, 126L, 127L, 128L,\
    \ 129L, 130L, 131L, 132L, 133L, 134L, \n                    135L, 136L, 137L,\
    \ 138L, 139L, 140L, 141L, 142L, 143L, 144L, \n                    145L, 146L,\
    \ 147L, 148L, 149L, 150L, 151L, 152L, 153L, 154L, \n                    155L,\
    \ 156L, 157L, 158L, 159L, 160L, 161L, 162L, 163L, 164L, \n                   \
    \ 165L, 166L, 167L, 168L, 169L, 170L, 171L, 172L, 173L, 174L, \n             \
    \       175L, 176L, 177L, 178L, 179L, 180L, 181L, 182L, 183L, 184L, \n       \
    \             185L, 186L, 187L, 188L, 189L, 190L, 191L, 192L, 193L, 194L, \n \
    \                   195L, 196L, 197L, 198L, 199L, 200L, 201L, 202L, 203L, 204L,\
    \ \n                    205L, 206L, 207L, 208L, 209L, 210L, 211L, 212L, 213L,\
    \ 214L, \n                    215L, 216L, ", "      if (n<2) List.empty\n    \
    \  else {\n        val l = new mutable.ListBuffer[Long]()\n        var i = 0\n\
    \        if (n%2==0) \n          l.append(i)\n        i+=1\n        if (n%3==0)\
    \ \n          l.append(i)\n        i+=1\n        if (n%5==0)\n          l.append(i)\n\
    \        i+=1\n        if (n%7==0)\n          l.append(i)\n        i+=1\n    \
    \    l.append(i)\n        l.toList\n      }", "        // Write your code here\n\
    \        if (n < 3) return List()\n        if (n == 3) List(1l, 3l, 2l)\n    \
    \    else\n            {\n                if (n % 2 == 0) List(tri(n - 1), tri(n\
    \ - 2) + tri(n + 1))\n                else List(tri(n - 1) + tri(n - 2) + tri(n\
    \ + 1), tri(n))\n            }", "        val a = mutable.ListBuffer[Long]()\n\
    \        val b = mutable.ListBuffer[Long]()\n        val c = mutable.ListBuffer[Long]()\n\
    \        if (n <= 1L) {\n            a.append(1L);\n            b.append(1L);\n\
    \            c.append(1L);\n            a.append(1L);\n            a.append(1L);\n\
    \            a.append(1L);\n            b.append(1L);\n            b.append(1L);\n\
    \            b.append(1L);\n            c.append(1L);\n            c.append(1L);\n\
    \            c.append(1L);\n        }\n        val rec : Long => Long = (_ : Long)\
    \ => {\n            val newA = a.take(n-1L).toList\n            val newB = b.take(n-1L).toList\n\
    \            val newC = c.take(n-1L).toList\n            if (n % 2 == 0L) newA.append(newA.get.head\
    \ + newB.get.head + newC.get.head)\n            else newA.append(newA.get.head\
    \ + newB.get.head + newC.get.head + newA.get.tail.head + newA.get.tail.tail.head\
    \ + newB.get.tail.head + newB.get.tail.tail.head + newC.get.tail.head + newC.get.tail.tail.head)\n\
    \            if (newA.length >= n + 1L) newA\n            else rec (n - 1L) +\
    \ rec (n - 2L) + rec (n + 1L)\n        }\n        rec (n + 1L)", "        val\
    \ ls = List((1L).toLong, (3L).toLong, 2L.toLong, 8L.toLong)\n        (for {\n\
    \            i <- 0 until n\n            _ <- ls.drop(i).map(x => x + i)\n   \
    \     } yield i)", "        val rev = n / 2 // rev represents n/2, which is even\
    \ or odd.\n        val even = n % 2 == 0\n\n        if (even) {\n            //\
    \ We want a list with 1 as a head and n+1 as tail, which is what our recursive\n\
    \            // calls are going to return.\n            // We start off by creating\
    \ an empty list. Then we prepend 1 to our list of numbers \n            // using\
    \ prepend and get the last one using last and add it to our list \n          \
    \  // using ++.\n            val result : mutable.ListBuffer[Long] = ListBuffer[Long]()\n\
    \            result + 1\n            result\n        } else {\n            //\
    \ Recursive calls have to be made to the right of the base case. In this case\n\
    \            // we want to call tri(n-1) and tri(n-2), which we can do using recursion\n\
    \            // with recur since we have seen the base case before.\n        \
    \    // The base case is tri(2), which returns tri(1) + tri(2).\n            //\
    \ Since tri(2) == tri(1) +tri(2), we know that 2 has already been added to our\
    \ \n            // list in the else branch, so we know that we need to add 1 to\
    \ our list of numbers\n            // using prepend and get the last one using\
    \ last and add it to our list \n            // using ++.\n            val result\
    \ : mutable.ListBuffer[Long] = ListBuffer[Long]()\n            result ++ recur(rev)\n\
    \        }", "        def tri(n: Long, acc: List[Long]) : List[Long] = {\n   \
    \         if (n == 0)\n                acc :+ 0\n            else {\n        \
    \        val tmp = tri(n - 1, Nil)\n                if (n %2==0) {\n         \
    \           tri(n + tmp, Nil) :+ n + tmp\n                } else {\n         \
    \           tri(n + tmp, Nil) :+ n + tmp + tmp\n                }\n          \
    \  }\n        }\n        if (n == 0)\n            Nil\n        else\n        \
    \    tri(n, Nil)", "        if(n <= 0) Nil\n        else if(n == 1) List(1, 3)\n\
    \        else tri(n-1) + tri(n-2)", "        if (n == 0) List(0)\n        else\
    \ if (n%2 == 0) tri(n-1) + tri(n-2)\n        else tri(n-1) + tri(n-2) + tri(n+1)",
  "        if (n == 1l) 1l :: Nil\n        if (n % 2l.toLong == 0) tri(n - 1l) + (1l.toLong\
    \ :: tri(n - 2l) + (3l.toLong :: tri(n +2l)))\n        else  tri(n - 1l) + (1l.toLong\
    \ :: tri(n - 2l) + (3l.toLong :: tri(n +2l)))", "        val n = scala.math.mod(n,\
    \ 2l)\n        val list: mutable.ArrayBuffer[Long] = mutable.ArrayBuffer[Long]()\n\
    \        if (n > 1l)\n            list += tri(n-1l) + tri(n-2l) + tri(n+2l)\n\
    \        list.toList", "        var list : List[Long] = List();\n        val limit\
    \ = (if (n <= 2) 3l else (n + 2l));\n        var sum = 1;\n        for (var i\
    \ = 1l to limit) {\n            list = list :+ sum;\n            sum = sum + i;\n\
    \        }\n        list", "    \tval res : List[Long] = List() \n    \tval sum\
    \ : List[Long] = List() \n    \tif(n % 2 == 0) { \n    \t\tres = n + 1 :: res\n\
    \    \t\tsum = sum + n\n    \t}\n    \telse {\n    \t\tval a = tri(n.toInt)\n\
    \    \t\tval b = tri(n.toInt - 1) + tri(n.toInt - 2) + tri(n.toInt + 1)\n    \t\
    \tres = a ::: b ::: res\n    \t\tsum = sum + a :: b :: sum\n    \t}\n    \tres.reverse",
  "        var result : List[Long] = Nil\n        if (n == 0) result ::= List(1l)\n\
    \        else if (n % 2 == 0) result ::= List(tri(n/2) + tri(n/2 - 1) + tri(n/2\
    \ + 1))\n        else result ::= List(tri(n - 1) + tri(n - 2) + tri(n + 1))\n\
    \        result", "        var currentTri : List[Long] = List[Long]()\n      \
    \  var tri1 =  3\n        var tri2 = tri1\n        var tri3 = tri2 + tri1\n  \
    \      var tri4 = tri3 + tri2\n        while (n < 0 || tri4 > 0) {\n         \
    \   currentTri += tri4\n            tri1 = tri2\n            tri2 = tri3\n   \
    \         tri3 = tri4 + tri2\n            tri4 = tri3 + tri2\n            n +=\
    \ 1\n        }\n        currentTri", "        val a = n.toInt\n        val b =\
    \ 1 + n / 2\n        val c = b + a + b\n        if (n % 2 == 0) List(a, b, c,\
    \ c) \n        else List(c, c, c, c)", "        if (n == 0) Nil\n        else\
    \ tri(n - 1) + tri(n - 2) + tri(n + 1) ", "        def triRec(a : List[Long],\
    \ index : Int) : List[Long] = {\n            if (index > 0) \n               \
    \ a :+ triRec(a, (index - 1) + index) \n            else\n                a\n\
    \        }\n        triRec(n, 1, 0).toList", "        if (n == 0 || n == 1)\n\
    \            List(1l, n)\n        else {\n            val temp = (tri(n-1) + tri(n-2)\
    \ + tri(n+1))\n            List(1l, n, temp.toLong)\n        }", "        require(n\
    \ > 0, \"Tribonacci sequence starts with three numbers!\")\n        val l = new\
    \ mutable.ListBuffer[Long]\n        l.append(1L)\n        l.append(2L)\n     \
    \   l.append(3L)\n        while(l.size < n+1){\n            val l2 = l.tail\n\
    \            l.append(l.head + l2.head + l2.last)\n        }\n        l drop 1\
    \ // tri(1) + tri(2)", "        def fibo: Long = _\n        val list = new mutable.ListBuffer[Long]()\n\
    \        if(n < 1) list.toList\n        else {\n            if(n%2 == 0) {\n \
    \               fibo = 3\n            } else fibo = fibo + n/2\n            fibo\
    \ += fibo\n            for(i <- 1 to n-1) list+=fibo\n        }\n        list.toList",
  "        val sums: List[Long] = new mutable.ListBuffer[Long]\n        sums += (3L)\n\
    \        if (n % 2 == 0) sums += (sums.last + n) / 2.0\n        else {\n     \
    \       val mid = (sums.last + sums.last + sums.last + n) / 4.0\n            sums.drop(1).foreach\
    \ { n => sums += n + mid }\n        }\n        sums.toList", "        require(n\
    \ > 0, \"Can't calculate Tribonacci sequence for n = 0 !\"); \n        if (n ==\
    \ 1) List(3l.toLong)\n        else {\n            val ls = tri(n-1) + tri(n-2)\
    \ + tri(n+1);\n            require(n > 1, \"Can't calculate Tribonacci sequence\
    \ for n = 1 !\");\n            if (n % 2 == 1) ls ++ List(n.toLong)\n        \
    \    else ls\n        }", "        val fibList: mutable.Buffer[Long] = mutable.Buffer()\n\
    \        if (n <= 1L) {\n            fibList.+=(1L.toLong)\n        }\n      \
    \  else {\n            fibList.+=(3L.toLong)\n        }\n        if (n % 2 ==\
    \ 0L) {\n            for (i <- 1L until (n - 1L)) {\n                fibList.+=(fibList(i-1L)\
    \ + fibList(i-2L))\n            }\n        }\n        else {\n            for\
    \ (i <- 1L until (n - 1L)) {\n                fibList.+=(fibList(i-1L) + fibList(i-1L\
    \ + 1) + fibList(i-2L))\n            }\n        }\n        fibList.toList", " \
    \       val two = new mutable.ListBuffer[Long]()\n        two(0) := 3\n      \
    \  for(i <- 1 to n) {\n            two += (i.toLong + two(i - 1).toLong) / 2\n\
    \        }\n        two.reverse", "        if(n <= 1L) List(1L.toLong, 1L.toLong,\
    \ 1L.toLong, 1L.toLong)\n        else { \n            def tri_rec(m : Long, n1\
    \ : Long, n2 : Long) : List[Long] = {\n                if(m <= 1L) List(n1.toLong,\
    \ n2.toLong)\n                else {\n                    def tri_rec_rec(p :\
    \ Long, q : Long, n1 : Long, n2 : Long, l : List[Long]) : List[Long] = {\n   \
    \                     if(p <= 1L) l \n                        else {\n       \
    \                     tri_rec_rec(q, (q + p) / 2, n1, n2, l :+ q)\n          \
    \              }\n                    }\n                    tri_rec_rec((m +\
    \ n1 + n2) / 3, n1, n2, List(n1.toLong, n2.toLong))\n                }\n     \
    \       }\n            tri_rec(n, 2L, 3L, List(0L.toLong, 1L.toLong))\n      \
    \  }", "      val a = 2l\n      val b = 3l\n      var triSeq: List[Long] = Nil\n\
    \      if (n < 2) triSeq = List(a.toLong + b.toLong)\n      else {\n        if\
    \ (n % 2 == 0) triSeq = List(tri(a.toLong + b.toLong))\n        else triSeq =\
    \ List(tri(a.toLong + b.toLong), tri(b.toLong + a.toLong))\n      }\n      triSeq\
    \ ::: tri(n - 1).toList", "        def f(n: Long, m: Long, sum: Long, m: Long)\
    \ : List[Long] = {\n            if (n == 0 || n == 1) {\n                List.fill(m)((m.toLong\
    \ :: sum.toList))\n            } else {\n                val first = f(n - 1,\
    \ m + 1, sum + m, m)\n                val second = f(n - 2, m + 1, sum + m + 1,\
    \ m)\n                if (n % 2 == 0) {\n                    List(first, rem(m,\
    \ 2) + second.toList)\n                } else {\n                    List(second.toList,\
    \ first)\n                }\n            }\n        }\n        val initial = f(n\
    \ - 1, 1L, 1L, 1L)\n        val result = f(n - 2, 1L, 0L, initial.last)\n    \
    \    result ++ initial", "        if (n == 0) List(1L)\n        else if (n % 2\
    \ == 0) tri(n - 1) + tri(n - 2) + tri(n + 1)\n        else tri(n - 1) + tri(n\
    \ - 2) + tri(n - 1) + tri(n + 1)", "        if (n < 0) Nil\n        else if (n\
    \ == 0) List(0l)\n        else if (n % 2 == 0) List(1l, n/2, 2l)\n        else\
    \ List(n/3, n-1, n+1)", "        if (n <= 1) {\n            Nil\n        } else\
    \ if (n % 2 == 0) {\n            Nil +: tri(n - 1) + tri(n - 2) + tri(n - 1)\n\
    \        } else {\n            Nil +: tri(n - 1) + tri(n - 2) + tri(n + 1) + tri(n\
    \ + 1)\n        }", "        // Use a mutable list to store all the tribonacci\
    \ sequence elements.\n        // Note that for even numbers, the second and third\
    \ tribonacci numbers \n        // are the same as the first and second tribonacci\
    \ numbers. \n        // For example:\n        // tri(10) = (1l + 3l + 5l + 7l\
    \ + 9l + 11l) + (1l + 3l + 5l + 7l + 9l + 11l)\n        // So we could have just\
    \ appended the even tribonacci numbers to the even tribonacci \n        // list\
    \ without having to store the even tribonacci numbers.\n        var tribonacci\
    \ : List[Long] = List(0l.toLong).toList\n        \n        if(n <= 1) return tribonacci\n\
    \n        // Iterate through all the even numbers less than or equal to n.\n \
    \       for(i <- 1 to n) {\n            // Calculate the tribonacci numbers. \n\
    \            tribonacci = \n                // Store the first two tribonacci\
    \ numbers in the even tribonacci list.\n                tribonacci.insert(0, tribonacci(1).toLong)\n\
    \                // Add the third tribonacci number to the even tribonacci list.\
    \ \n                tribonacci :+ tribonacci(2).toLong\n\n            // Only\
    \ continue the loop when i is odd.\n            if(i % 2 != 0) continue\n    \
    \        \n            // Calculate the second tribonacci number. \n         \
    \   tribonacci = \n                // Add it to the even tribonacci list.\n  \
    \              tribonacci.insert(1, tribonacci(2).toLong)\n                //\
    \ Add the third tribonacci number to the even tribonacci list.\n             \
    \   tribonacci :+ tribonacci(3).toLong\n\n            // Only continue the loop\
    \ when i is odd.\n            if(i % 2 != 0) continue\n            \n        \
    \    // Calculate the third tribonacci number. \n            tribonacci = \n \
    \               // Add it to the even tribonacci list.\n                tribonacci.insert(2,\
    \ tribonacci(3).toLong)\n                // Add the third tribonacci number to\
    \ the even tribonacci list.\n                tribonacci :+ tribonacci(4).toLong\n\
    \        }\n        \n        // Return the list of even tribonacci numbers. \n\
    \        tribonacci.toList", "        val res = mutable.ListBuffer.empty[Long]\n\
    \        def recurse(i : Long, acc : List[Long]) : List[Long] = {\n          \
    \  if (i < 0)\n                res\n            else if (i % 2 == 0)\n       \
    \         recurse(i - 1, acc :+ acc.last)\n            else {\n              \
    \  val next = i + 1 // remember, Tribonacci sequence is defined as\n         \
    \       // tri(1) = 3\n                // tri(n) = 1 + n / 2, if n is even.\n\
    \                val even = (i + 1) // 2\n                val odd = (even * 2)\
    \ +  i\n                recurse(odd, acc :+ acc.last)\n            }\n       \
    \ }\n        recurse(n, res)\n        res.toList", "        if (n <= 0L) List(1L,\
    \ 0L, 1L, 1L)\n        else {\n            val a = (1L + n / 2L).toInt\n     \
    \       val b = (1L + n - a).toInt\n            val c = a + (a + b) / 2L\n   \
    \         List(a.toLong, b, toLong(c))\n        }", "        if(n == 0) List(1l)\n\
    \        if(n == 1) List(3l)\n        if(n == 2) List(2, 3)\n        if(n == 3)\
    \ List(3, 8, 5)\n        if(n == 4) List(4, 12, 8)\n        if(n == 5) List(5,\
    \ 15, 13, 14)\n        List(n, tri(n - 1) + tri(n - 2) + tri(n + 1))", "     \
    \   if (n <= 0) Nil\n        else { \n            val first  = n-2\n         \
    \   val second = n-1 \n            val third = n \n            if (first==second)\
    \ List(third) \n            else { \n                val list = tri(first) \n\
    \                list ++ list.drop(1) + list.drop(2) + list \n            }\n\
    \        }", "        if (n <= 0) Nil\n        else {\n            val list =\
    \ (3l, 1l, 2l, 8l)\n            val res = (0 to (n % 2) map { x => list(x) } )\
    \ \n                        ++ res + \n                        res + \n      \
    \                  (n to 0 map { x => list(x + 3) }) ++ \n                   \
    \     res\n            val res : List[Long] = res.toList\n            val res\
    \ : List[Long] = res.reverse\n            res\n        }", "        if(n == 0)\
    \ List(1L).toList\n        else if(n == 1) List(1L).toList\n        else if(n\
    \ == 2) List(1L, 2L).toList\n        else {\n            var result = List(1L)\n\
    \            var temp = result\n            var count = 1\n            while(count\
    \ < n) {\n                result.last = (temp(result.size - 1) + temp(result.size\
    \ - 2) + temp(result.size + 1))\n                temp = result\n             \
    \   count += 1\n            }\n            result\n        }", "        def tri_helper(n:\
    \ Long, acc: List[Long]) : List[Long] = n match {\n            case 0 => acc.reverse\n\
    \            case 1 => List(1l.toLong)\n            case 2 => tri_helper(tri_helper(n\
    \ - 1l, List(0l.toLong, 1l.toLong)) , List(0l.toLong, 1l.toLong))\n          \
    \  case n => (tri_helper(n - 1l, List(0l.toLong, 1l.toLong)) :: tri_helper(n -\
    \ 2l, tri_helper(n - 1l, List(0l.toLong, 1l.toLong)) :: tri_helper(n + 2l, List(0l.toLong,\
    \ 1l.toLong)))).flatten\n        }\n        tri_helper(n-1, List(0l.toLong, 1l.toLong))",
  "        val a0 = 1l\n        val a1 = 1l\n        val a2 = n\n        val a3 =\
    \ a1 + a2\n        val a4 = a1 + a2 + a3\n        val a5 = a1 + a2 + a3 + a4\n\
    \        val a6 = a1 + a2 + a3 + a4 + a5\n        val a7 = a1 + a2 + a3 + a4 +\
    \ a5 + a6\n        val a8 = a1 + a2 + a3 + a4 + a5 + a6 + a7\n        val a9 =\
    \ a1 + a2 + a3 + a4 + a5 + a6 + a7 + a8\n        val a10 = a1 + a2 + a3 + a4 +\
    \ a5 + a6 + a7 + a8 + a9\n        val a11 = a4 + a3 + a5 + a6 + a7 + a8 + a9 +\
    \ a10\n        val a12 = a4 + a3 + a5 + a6 + a7 + a8 + a9 + a10 + a11\n      \
    \  val a13 = a4 + a5 + a6 + a7 + a8 + a9 + a10 + a11 + a12\n        val a14 =\
    \ a4 + a5 + a6 + a7 + a8 + a9 + a10 + a11 + a12 + a13\n        val a15 = a5 +\
    \ a6 + a7 + a8 + a9 + a10 + a11 + a12 + a13 + a14\n        val a16 = a5 + a6 +\
    \ a7 + a8 + a9 + a10 + a11 + a12 + a13 + a14 + a15\n        val a17 = a6 + a7\
    \ + a8 + a9 + a10 + a11 + a12 + a13 + a14 + a15 + a16\n        val a18 = a6 +\
    \ a7 + a8 + a9 + a10 + a11 + a12 + a13 + a14 + a15 + a16 + a17\n        val a19\
    \ = a6 + a7 + a8 + a9 + a10 + a11 + a12 + a13 + a14 + a15 + a16 + a17 + a18\n\
    \        val a20 = a6 + a7 + a8 + a9 + a10 + a11 + a12 + a13 + a14 + a15 + a16\
    \ + a17 + a18 + a19\n        val a21 = a6 + a7 + a8 + a9 + a10 + a11 + a12 + a13\
    \ + a14 + a15 + a16 + a17 + a18 + a19 + a20\n        val a22 = a1 + a2 + a3 +\
    \ a4 + a5 + a6 + a7 + a8 + a9 + a10 + a11 + a12 + a13 + a14 + a15 + a16 + a17\
    \ + a18 + a19 + a20 + a21\n        val a23 = a4 + a3 + a5 + a6 + a7 + a8 + a9\
    \ + a10 + a11 + a12 + a13 + a14 + a15 + a16 + a17 + a18 + a19", "        val result\
    \ = new ArrayList[Long](n)\n        var tmp1 = 1\n        var tmp2 = 3\n     \
    \   for (i <- 1 to n) {\n            result(i) = tmp1\n            if (i % 2 ==\
    \ 0)\n                tmp2 = tmp1 + tmp2\n            else {\n               \
    \ tmp1 = tmp2 + tmp1\n                tmp2 = tmp1 + tmp2\n            }\n    \
    \    }\n        result", "        if(n<1) List()\n        else if(n==1) List(nl.toLong)\n\
    \        else if(n==2) List(nl.toLong, nl.toLong)\n        else {\n          \
    \  val first = new mutable.LinkedList[Long]\n            val second = new mutable.LinkedList[Long]\n\
    \            val third = new mutable.LinkedList[Long]\n            val forth =\
    \ new mutable.LinkedList[Long]\n            for(i <- 1 to n) if(i % 2 == 0) forth\
    \ += (i).toLong\n            else if((i%2) == 1) third+= (i).toLong\n        \
    \    else if((i%2) == 0) second+= (i).toLong\n            else first += (i).toLong\n\
    \            forth += (nl.toLong)\n            third+= (nl.toLong)\n         \
    \   second+= (nl.toLong)\n            forth += (nl.toLong)\n            third+=\
    \ (nl.toLong)\n            second+= (nl.toLong)\n            third+= (nl.toLong)\n\
    \            forth += (nl.toLong)\n            List(first.toList(0), third.toList(0),\
    \ second.toList(0), forth.toList(0))\n        }", "        def triHelper(i : Long,\
    \ triList : List[Long]) : List[Long] = if (i <= 0) triList\n        else {\n \
    \           if (n % 2 == 0) triHelper(i - 1, triList :: (triHelper(i + 1, 3 ::\
    \ triList(2))))\n            else triHelper(i - 1, triList :: (triHelper(i + 1,\
    \ triList(1) :: triList(2))))\n        }\n        triHelper(n, List())", "   \
    \     val t1 = if (n % 2 == 0) (3 - n) / 2 else n\n        val t2 = if (n % 2\
    \ == 0) (1 + n) / 2 else (n + 3) / 4\n        val t3 = if (n % 2 == 0) (1 + n)\
    \ / 2 else (n + 3) / 4\n        List(1l.toLong, t2, t3).take(n + 1).map(_.toLong)",
  "        val fibonacci : List[Long] = List(3, 1, 2)\n        val tribonacci = fibonacci.foldLeft(List[Long]())((acc,\
    \ x) => if (x % 2 == 0) acc.reverse :+ x + acc.head) \n        val sum = tribonacci.foldLeft(0)((acc,x)\
    \ => acc + (x/2))\n        (0 until n).map(x => tribonacci(sum + x))", "     \
    \   val memo = mutable.HashMap.empty[Long, List[Long]]\n        def recur(n: Long,\
    \ acc: List[Long]) : List[Long] = {\n            if (memo.get(n).isDefined) memo(n)\
    \ else recur(n + 1, (n to acc).reverse)\n        }\n        recur(n, Nil)", " \
    \       if (n <= 1) List(1L)\n        else if (n <= 3L) List(3L, 1L)\n       \
    \ else tri(n - 1) + tri(n - 2) + tri(n +1)", "        val ns: List[Long] = n match\
    \ {\n            case n if n >= 0 => List(n, n.toLong, (n-1).toLong, (n-2).toLong)\n\
    \            case n if n < 0 => List(n, n.toLong, (n+1).toLong, (n+2).toLong)\n\
    \        }\n        List(ns(0), ns(1), ns(2), ns(3)).filterNot(n => n % 2 == 0).reverse",
  "      var triSeq = List(0l).toList\n      var temp = 3l.toLong;\n      if (n %\
    \ 2 == 0) {\n        triSeq = triSeq :+ temp;\n        temp += temp;\n      }\n\
    \      else {\n        triSeq = triSeq :+ temp;\n        temp += temp + temp;\n\
    \      }\n      for (int i = 2; i < (n + 1);) {\n        temp = triSeq(i - 1)\
    \ + triSeq(i - 2);\n        triSeq = triSeq :+ temp;\n        temp += temp + temp;\n\
    \        i += 2;\n      }\n      triSeq", "        val list = new mutable.ListBuffer[Long]()\n\
    \        if (n == 1)\n            list += n\n        else if (n % 2 == 0) {\n\
    \            val r = tri(n / 2)\n            if (n % 2 == 1)\n               \
    \ r ++= r(0)\n            list += r(1)\n        } else\n            list += tri(n\
    \ / 2) + tri(n / 2 + 1) + tri(n / 2 + 2)\n        list.map(_.toLong)", "     \
    \   val fib =  new scala.collection.mutable.ListBuffer[Long]()\n        fib.append(3)\n\
    \        fib += 2\n        fib.add((fib.head.toLong + fib.tail.head.toLong + fib.tail.tail.head.toLong).toLong)\n\
    \        fib.take(n.toInt)", "        require(n > 0, \"n must be > 0\")\n    \
    \    if (n <= 1l) List(1l.toLong)\n        else List(nl.toLong, tri(n - 1l) +\
    \ tri(n - 2l) + tri(n + 2l))", "        val fibonacci = mutable.ListBuffer(1,\
    \ 2, 3)\n        val fibo = fibonacci.take(n)\n        fibo.map {\n          \
    \  case i => i + fibo.last\n        }", "        val result = (0 until n).filter(_\
    \ <= 2).map(_ + 1).map(_.toLong).toList\n        result :: tri(n - 1)", "    \
    \    if (n < 2) Nil\n        else {\n            def tri (m : Long) = (m * m)\
    \ / 2l\n            val r = for (i<-0 to (n-1l) by 2l) yield tri(m)\n        \
    \    r.reverse\n        }", "        if (n <= 0)\n            List()\n       \
    \ else if (n <= 1L) \n            List(n)\n        else if (n <= 2L)\n       \
    \     List(n, 1)\n        else \n            List(n - 1L, n, n + 1L)", "     \
    \   val ones = Vector(1l,2l,3l).filter(_ % 2 == 0).take(n).toList\n        val\
    \ twos = Vector(4l,5l,6l).filter(_ % 2 == 1).take(n).toList\n        val threes\
    \ = Vector(7l,8l,9l).filter(_ % 3 == 0).take(n).toList\n        val result = ones.::(twos).::(threes)\n\
    \        result.take(n + 1)"]
stop_tokens:
- "\n    }\n"
