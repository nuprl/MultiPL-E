{
  "language": "scala",
  "name": "HumanEval_108_count_nums",
  "results": [
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        // Count the number that has the sum of digits > 0, the number is negative\n        // and has the first sign digit negative\n        // e.g.\n        // >>> countNums([1, 2, 3, -4, 5, -5, 6, 7, 8, -9, 0])\n        // 2\n        // >>> countNums([1, -3, 4, -5, 6, 7, 8, -9, 0])\n        // 1\n        // >>> countNums([1, -3, 4, -5, 6, 7, 8, 0, -9, 0])\n        // 0\n        // >>> countNums([1, -3, 4, -5, 6, 7, 8, -9, 0])\n        // 1\n        val firstSign = (arr map (_.toInt) filter (_.signum != 0) get 0).signum\n        val first = arr filter (_.toInt > 0) take 1\n        if (firstSign < 0) first else first filter (a => firstSign < 0 || (a.toInt.signum * firstSign < 0))\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp77b9o3a5.scala:26:66 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mfirstSign\u001b[0m = (arr map (_.toInt) filter (_.signum != \u001b[31m0\u001b[0m) get \u001b[31m0\u001b[0m).signum\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m    value get is not a member of List[Int] - did you mean List[Int].seq?\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp77b9o3a5.scala:28:27 --------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        \u001b[33mif\u001b[0m (firstSign < \u001b[31m0\u001b[0m) first \u001b[33melse\u001b[0m first filter (\u001b[36ma\u001b[0m => firstSign < \u001b[31m0\u001b[0m || (a.toInt.signum * firstSign < \u001b[31m0\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                           ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                           Found:    (first : List[Long])\n\u001b[31m   |\u001b[0m                           Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp77b9o3a5.scala:28:38 --------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        \u001b[33mif\u001b[0m (firstSign < \u001b[31m0\u001b[0m) first \u001b[33melse\u001b[0m first filter (\u001b[36ma\u001b[0m => firstSign < \u001b[31m0\u001b[0m || (a.toInt.signum * firstSign < \u001b[31m0\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                      Found:    \u001b[1m\u001b[31mList\u001b[0m\u001b[1m\u001b[31m[\u001b[0mLong\u001b[1m\u001b[31m]\u001b[0m\n\u001b[31m   |\u001b[0m                                      Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660009910
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n      val ns = arr.toSet\n      val n1 = arr.filter { n => n.toInt == 1L}.toSet\n      val n2 = arr.filter { n => n.toInt == 2L}.toSet\n      val n3 = arr.filter { n => n.toInt == 3L}.toSet\n      val n4 = arr.filter { n => n.toInt == 4L}.toSet\n      val n5 = arr.filter { n => n.toInt == 5L}.toSet\n      val n6 = arr.filter { n => n.toInt == 6L}.toSet\n      val n7 = arr.filter { n => n.toInt == 7L}.toSet\n      val n8 = arr.filter { n => n.toInt == 8L}.toSet\n      val n9 = arr.filter { n => n.toInt == 9L}.toSet\n      if (ns.contains(0L)) {\n        0L\n      }\n      else if (n1.size > 0) {\n        n1.size\n      }\n      else if (n2.size > 0) {\n        n2.size\n      }\n      else if (n3.size > 0) {\n        n3.size\n      }\n      else if (n4.size > 0) {\n        n4.size\n      }\n      else if (n5.size > 0) {\n        n5.size\n      }\n      else if (n6.size > 0) {\n        n6.size\n      }\n      else if (n7.size > 0) {\n        n7.size\n      }\n      else if (n8.size > 0) {\n        n8.size\n      }\n      else if (n9.size > 0) {\n        n9.size\n      }\n      else {\n        0L\n      }\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpeng_z6tf.scala:62)\n\tat Problem.main(tmpeng_z6tf.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009911
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        val digits = arr.reverse.map(_.toInt).zipWithIndex\n        val firstDigit = digits(0)._2\n        val secondDigit = digits(1)._2\n        val thirdDigit = digits(2)._2\n        val sum = firstDigit + secondDigit + thirdDigit + 2\n        if (sum < 0 || sum > 9)\n            0\n        else\n            sum.toLong\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.IndexOutOfBoundsException: 0\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\tat Problem$.countNums(tmpl4x_l36l.scala:16)\n\tat Problem$.main(tmpl4x_l36l.scala:26)\n\tat Problem.main(tmpl4x_l36l.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009910
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        arr.foldLeft(0l)((acc, num) => {\n            val digit = num % 10\n            val firstDigit = num / 10\n            if (digit > 0 && firstDigit > 0) {\n                val num1 = firstDigit % 10\n                val num2 = digit + num1\n                acc += num2\n            }\n            acc\n        })\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp4k1ctlbn.scala:21:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m                acc += num2\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                value += is not a member of Long - did you mean acc.!=?\n1 error found\n",
      "stdout": "",
      "timestamp": 1660009907
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        arr.foldLeft(0L) {\n            (count, num) =>\n                val (digits, isNegative) = num.abs\n                if (digits.isMultipleOf(2)) {\n                    val sign = if (isNegative) -1 else 1\n                    count + sign * digits.toInt\n                }\n                else count\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpssl3dk2m.scala:18:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m                \u001b[33mif\u001b[0m (digits.isMultipleOf(\u001b[31m2\u001b[0m)) {\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    value isMultipleOf is not a member of Any\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpssl3dk2m.scala:19:35 --------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m                    \u001b[33mval\u001b[0m \u001b[36msign\u001b[0m = \u001b[33mif\u001b[0m (isNegative) -\u001b[31m1\u001b[0m \u001b[33melse\u001b[0m \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                                   ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                   Found:    (isNegative : Any)\n\u001b[31m   |\u001b[0m                                   Required: Boolean\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpssl3dk2m.scala:20:42 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m                    count + sign * digits.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                                   ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue toInt is not a member of Any, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might make progress towards fixing the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.Fractional.Implicits.infixFractionalOps\n\u001b[31m   |\u001b[0m  import math.Integral.Implicits.infixIntegralOps\n\u001b[31m   |\u001b[0m  import math.Numeric.Implicits.infixNumericOps\n\u001b[31m   |\u001b[0m\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660009911
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        var count = 0\n        var n = 0\n        var cur = 0\n\n        arr.zipWithIndex.foreach(n => { \n            cur += n._2 % 10 \n            if (cur > 0) \n                count += 1\n            cur = 0 \n        })\n        count \n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpzzfokhqv.scala:29)\n\tat Problem.main(tmpzzfokhqv.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009911
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.filter(x => x >= 0)\n        val sum = arr.filter(x => x == 0).reduceLeft(_ + _)\n        if (sum > 0) {\n            val numSums = nums.filter(x => x >= 0).filter(x => x >= 0).size\n            if (numSums == 0) 0 else numSums\n        } else {\n            0\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.UnsupportedOperationException: empty.reduceLeft\n\tat scala.collection.IterableOnceOps.reduceLeft(IterableOnce.scala:727)\n\tat scala.collection.IterableOnceOps.reduceLeft$(IterableOnce.scala:724)\n\tat scala.collection.AbstractIterable.reduceLeft(Iterable.scala:926)\n\tat Problem$.countNums(tmp_3cajkbn.scala:16)\n\tat Problem$.main(tmp_3cajkbn.scala:25)\n\tat Problem.main(tmp_3cajkbn.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009911
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        val total = 0L\n        arr.foreach( x => {\n            val digits = x - x.toInt\n            if(digits > 0) {\n                total += digits\n            }\n        })\n        total\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpcqzxhqcd.scala:19:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m                total += digits\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m               value += is not a member of Long - did you mean total.!=?\n1 error found\n",
      "stdout": "",
      "timestamp": 1660009908
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        val arr = arr.sortBy(_ * _)\n        val sum = 0L\n        var sum1 = -1L\n        var sum2 = -1L\n        var sum3 = -1L\n        for(i <- 0 until arr.size) {\n            if(sum + arr(i).toLong <= 0) {\n                if(sum1 == -1L) {\n                    sum1 = sum + arr(i).toLong\n                } else {\n                    sum2 = sum + arr(i).toLong\n                }\n            } else {\n                sum3 = sum + arr(i).toLong\n                if(sum1 == -1L && sum2 == -1L) {\n                    if(sum3 == -1L) return sum\n                } else {\n                    if(sum2 == -1L) return sum\n                }\n            }\n            sum += arr(i).toLong\n        }\n        sum3\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp780gtluq.scala:15:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = arr.sortBy(_ * _)\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Recursive \u001b[33mvalue\u001b[0m \u001b[35marr\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp780gtluq.scala:35:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m            sum += arr(i).toLong\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value += is not a member of Long - did you mean sum.!=?\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660009908
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        // Your code goes here.\n        var n = 0\n        var lastsum = 0\n        arr.foreach{x => lastsum = lastsum + x}\n        arr.foreach{x => if (lastsum > 0 && ((lastsum / 10) % 10) != 0) n = n + 1}\n        n\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp8bdwb0of.scala:18:35 --------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        arr.foreach{\u001b[36mx\u001b[0m => lastsum = lastsum + x}\n\u001b[31m\u001b[31m   |\u001b[0m                                   ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                   Found:    Long\n\u001b[31m   |\u001b[0m                                   Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660009908
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        var nums = arr.toList\n        var count = 0\n        while(nums.nonEmpty){\n            val sum = nums.reduce{\n                case(acc, elem) => acc + elem\n            }\n            if(sum > 0) count = count + 1\n            nums = nums.tail\n        }\n        count \n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp0ejsuhyg.scala:29)\n\tat Problem.main(tmp0ejsuhyg.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009911
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n      var count = 0\n      var num: Long = 0\n      for (i <- arr.length) {\n        num = arr(i)\n        count = count + 1\n        while (num > 0) {\n          num -= (Math.pow(10,i) % num).toLong\n          i += 1\n          if (i == arr.length) break\n        }\n      }\n      count\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpe_d91n57.scala:17:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m      \u001b[33mfor\u001b[0m (i <- arr.length) {\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                value foreach is not a member of Int\n1 error found\n",
      "stdout": "",
      "timestamp": 1660009909
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        arr match {\n            case Nil => 0\n            case x :: Nil => 1\n            case x :: y => 1 + countNums(y.map(z => z match {\n                case x if x < (0 | 0) => x.toLong\n                case x => -x\n            }))\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp44dvhti2.scala:26)\n\tat Problem.main(tmp44dvhti2.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009911
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n       arr.filter(x => x.toString.sum.toLong > 0l).length\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpeou9joqr.scala:19)\n\tat Problem.main(tmpeou9joqr.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009911
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        arr match {\n            case List() => (0l)\n            case xs => (xs.foldLeft((0l))((acc, x) => {\n                if (acc >= 10) {\n                    acc += x\n                } else {\n                    acc += (x - acc.toInt)\n                }\n                acc\n            }))\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp32ulypvt.scala:19:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m                    acc += x\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                 value += is not a member of Long - did you mean acc.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp32ulypvt.scala:21:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m                    acc += (x - acc.toInt)\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                 value += is not a member of Long - did you mean acc.!=?\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660009910
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        var count = 0\n        var digit = arr.head\n        while (digit > 0) {\n            digit = digit.signum\n            count += 1\n        }\n        arr.toList.sortWith(_.signum < 0).foreach(x => {\n            if (x < 0) {\n                count += 1\n            }\n        })\n        count\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E086] Syntax Error: /tmp/tmpok0d5igo.scala:21:28 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        arr.toList.sortWith(_.signum < \u001b[31m0\u001b[0m).foreach(\u001b[36mx\u001b[0m => {\n\u001b[31m\u001b[31m   |\u001b[0m                            ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                            Wrong number of parameters, expected: 2\n1 error found\n",
      "stdout": "",
      "timestamp": 1660009902
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        val digits = arr.map(_.toInt)\n        val n = arr.map(_.toInt)\n        digits.scanLeft(0)((_ + _ + _) * _) match {\n            case 0 => n\n            case n if (n > 0) => n\n            case n => n\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E086] Syntax Error: /tmp/tmpp02bp8_k.scala:17:27 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        digits.scanLeft(\u001b[31m0\u001b[0m)((_ + _ + _) * _) \u001b[33mmatch\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m                           ^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                           Wrong number of parameters, expected: 2\n\u001b[31m\u001b[31m-- Error: /tmp/tmpp02bp8_k.scala:18:17 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m            \u001b[33mcase\u001b[0m \u001b[31m0\u001b[0m => n\n\u001b[31m\u001b[31m   |\u001b[0m                 ^\u001b[0m\n\u001b[31m   |\u001b[0m      Values of types Int and List[Int] cannot be compared with == or !=\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpp02bp8_k.scala:18:22 --------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m            \u001b[33mcase\u001b[0m \u001b[31m0\u001b[0m => n\n\u001b[31m\u001b[31m   |\u001b[0m                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                      Found:    (n : List[Int])\n\u001b[31m   |\u001b[0m                      Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpp02bp8_k.scala:19:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m            \u001b[33mcase\u001b[0m n \u001b[33mif\u001b[0m (n > \u001b[31m0\u001b[0m) => n\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue > is not a member of List[Int], but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might make progress towards fixing the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.Ordered.orderingToOrdered\n\u001b[31m   |\u001b[0m  import math.Ordering.Implicits.infixOrderingOps\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpp02bp8_k.scala:19:33 --------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m            \u001b[33mcase\u001b[0m n \u001b[33mif\u001b[0m (n > \u001b[31m0\u001b[0m) => n\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Found:    (n : List[Int])\n\u001b[31m   |\u001b[0m                                 Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E",
      "stdout": "",
      "timestamp": 1660009911
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        arr.count(num(arr))\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp12ctx4_a.scala:15:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        arr.count(num(arr))\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  Not found: num\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660009902
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        var i = 0\n        var total = 0\n        var nums = arr.toSet\n        while (i < arr.size) {\n            total += nums(i)\n            if (total > 9)\n                total -= 10\n            i += nums.size\n        }\n        total\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpm9anrq9c.scala:19:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m            total += nums(i)\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value += is not a member of Int - did you mean Int.!=?\n1 error found\n",
      "stdout": "",
      "timestamp": 1660009908
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.filter(i => i >= 0).toList\n        val res = arr.filter(i => i >= 0 && !i.isMinusOne).foldLeft[Long](0) {\n            (a, b) => if (a >= 0) (b + a) else if (b >= 0) a else b\n        }\n        res + nums.map(_.toString.map(_.digits).sum).sum\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmprobgos_u.scala:16:47 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mres\u001b[0m = arr.filter(\u001b[36mi\u001b[0m => i >= \u001b[31m0\u001b[0m && !i.isMinusOne).foldLeft[\u001b[35mLong\u001b[0m](\u001b[31m0\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                             ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                value isMinusOne is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmprobgos_u.scala:19:40 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        res + nums.map(_.toString.map(_.digits).sum).sum\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                    value digits is not a member of Char\n\u001b[31m\u001b[31m-- Error: /tmp/tmprobgos_u.scala:19:56 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        res + nums.map(_.toString.map(_.digits).sum).sum\n\u001b[31m\u001b[31m   |\u001b[0m                                                        ^\u001b[0m\n\u001b[31m   |\u001b[0mambiguous given instances: both \u001b[33mobject\u001b[0m \u001b[35mShortIsIntegral\u001b[0m in \u001b[33mobject\u001b[0m \u001b[35mNumeric\u001b[0m and \u001b[33mobject\u001b[0m \u001b[35mLongIsIntegral\u001b[0m in \u001b[33mobject\u001b[0m \u001b[35mNumeric\u001b[0m match type Numeric[B] of parameter num of \u001b[33mmethod\u001b[0m \u001b[35msum\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mIterableOnceOps\u001b[0m\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660009910
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n       val list = arr.toList.sortWith(_ < _)\n       var cnt = 0\n       list.foreach { x => \n         if (x >= 0) cnt += math.floor(x/10) + math.mod(x,10)\n         else cnt += math.floor(x/10) + math.mod(x,10)*2\n       }\n       cnt\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpwd0ah21z.scala:18:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m         \u001b[33mif\u001b[0m (x >= \u001b[31m0\u001b[0m) cnt += math.floor(x/\u001b[31m10\u001b[0m) + math.mod(x,\u001b[31m10\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  value += is not a member of Int - did you mean Int.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpwd0ah21z.scala:18:52 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m         \u001b[33mif\u001b[0m (x >= \u001b[31m0\u001b[0m) cnt += math.floor(x/\u001b[31m10\u001b[0m) + math.mod(x,\u001b[31m10\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                               ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                       value mod is not a member of math\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpwd0ah21z.scala:19:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m         \u001b[33melse\u001b[0m cnt += math.floor(x/\u001b[31m10\u001b[0m) + math.mod(x,\u001b[31m10\u001b[0m)*\u001b[31m2\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              value += is not a member of Int - did you mean Int.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpwd0ah21z.scala:19:45 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m         \u001b[33melse\u001b[0m cnt += math.floor(x/\u001b[31m10\u001b[0m) + math.mod(x,\u001b[31m10\u001b[0m)*\u001b[31m2\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                                        ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                       value mod is not a member of math\n4 errors found\n",
      "stdout": "",
      "timestamp": 1660009910
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        if(arr.isEmpty) 0\n        else arr.map(i => math.abs(i)).filter(_ > 0).toList.foldLeft(0)(_ + _)\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpu6utyb5_.scala:16:72 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33melse\u001b[0m arr.map(i => math.abs(i)).filter(_ > \u001b[31m0\u001b[0m).toList.foldLeft(\u001b[31m0\u001b[0m)(_ + _)\n\u001b[31m\u001b[31m   |\u001b[0m                                                                        ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                                          Found:    Long\n\u001b[31m   |\u001b[0m                                                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660009907
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        var sum = 0\n        for (i <- arr ) {\n            var digit = i % 10\n            sum += if (digit < 0) digit * 10 - digit else digit\n        }\n        arr.count(x => sum % 10 == 0)\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpunhmjl2l.scala:18:19 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m            sum += \u001b[33mif\u001b[0m (digit < \u001b[31m0\u001b[0m) digit * \u001b[31m10\u001b[0m - digit \u001b[33melse\u001b[0m digit\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^\u001b[0m\n\u001b[31m   |\u001b[0m                   expression expected but \u001b[31mif\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpunhmjl2l.scala:18:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m            sum += \u001b[33mif\u001b[0m (digit < \u001b[31m0\u001b[0m) digit * \u001b[31m10\u001b[0m - digit \u001b[33melse\u001b[0m digit\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value += is not a member of Int - did you mean Int.!=?\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660009908
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        var count = 0L\n        var neg = 0\n        for (num <- arr) {\n            val digit = num % 10\n            if (num >= 0) {\n                if (digit >= 0) {\n                    if (num % 100 >= 0) count+=1\n                    else {\n                        if (digit < 0) neg+=1\n                    }\n                } else {\n                    if (num < 0) neg+=1\n                }\n            } else {\n                if (digit < 0) neg+=1\n            }\n        }\n        return count\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp1yay2woq.scala:36)\n\tat Problem.main(tmp1yay2woq.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009927
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.filter(x => x > 0).map(x => (x / 10).toInt)\n        val sum = (0 to 9).filter(x => nums.contains(x)).map(x => (x / 10).toInt).sum\n        arr.count(x => x > 0 && sum > 0)\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpwtk9d560.scala:22)\n\tat Problem.main(tmpwtk9d560.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009926
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n      arr.map(x => x + 1).filter(x => x >= 0).sum\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp2o39thzh.scala:19)\n\tat Problem.main(tmp2o39thzh.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009930
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        val n = arr.length\n        val m = arr.max\n        val nums = new mutable.HashSet[Long]()\n        for (i<- 0 until n) {\n            val num = (arr(i) - m).abs\n            if (num > 0) {\n                nums += num\n            }\n        }\n        nums.size\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmppv7h00wq.scala:17:23 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnums\u001b[0m = \u001b[33mnew\u001b[0m mutable.HashSet[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660009922
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        arr.size\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp16nrlvao.scala:19)\n\tat Problem.main(tmp16nrlvao.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009929
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        var sum : Long = 0\n        arr.map(i => sum += (i / 10).toInt)\n        if(arr.isEmpty) 0\n        else {\n            var sumOfFirstDigits : Long = 0\n            var sumOfOtherDigits : Long = 0\n            arr.map(i => sumOfFirstDigits += (i % 10).toInt)\n            arr.map(i => sumOfOtherDigits += i.toInt)\n            var countDigit = 0\n            sumOfFirstDigits + sumOfOtherDigits - sum\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpkxok6_2p.scala:29)\n\tat Problem.main(tmpkxok6_2p.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009930
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        // If the list is empty\n        if(arr.isEmpty) {\n            return 0\n        }\n\n        // Get the first element\n        var first_element = arr.head\n\n        // If the first element is a negative number then add its first digit\n        // to the total number\n        if(first_element < 0) {\n            return countNums(arr.tail)\n        }\n\n        // If the first element is 0, count it\n        if(first_element == 0) {\n            return countNums(arr.tail)\n        }\n\n        // If it has a first digit greater than 0, then add it to the total\n        // number of elements which has a sum of digits > 0.\n        // The final return value is the sum of (first_element + digits_sum)\n        var sum_of_digits = 0\n\n        // Iterate through the list and add up the digits of the numbers\n        // whose sum is > 0.\n        for(i <- 0 until arr.size) {\n            var digit_sum = arr(i)\n            for(j =  0 until digit_sum) {\n                var digit = digit_sum - j\n                sum_of_digits += digit\n            }\n        }\n\n        // Return the total numbers of elements whose sum is > 0\n        return sum_of_digits + countNums(arr.tail)\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp7bz6mt7d.scala:43:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m43 |\u001b[0m            \u001b[33mfor\u001b[0m(j =  \u001b[31m0\u001b[0m until digit_sum) {\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  ')' expected, but '=' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp7bz6mt7d.scala:43:40 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m43 |\u001b[0m            \u001b[33mfor\u001b[0m(j =  \u001b[31m0\u001b[0m until digit_sum) {\n\u001b[31m\u001b[31m   |\u001b[0m                                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                                        '<-' expected, but '{' found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp7bz6mt7d.scala:46:13 ------------------------\u001b[0m\u001b[0m\n\u001b[31m46 |\u001b[0m            }\n\u001b[31m\u001b[31m   |\u001b[0m             ^\u001b[0m\n\u001b[31m   |\u001b[0mvalue foreach is not a member of Null, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import Option.option2Iterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip2.lazyZip2ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip3.lazyZip3ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip4.lazyZip4ToIterable\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.list asScalaBuffer\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.properties AsScalaMap\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.enumeration AsScalaIterator\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.iterator asScala\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.map AsScalaConcurrentMap\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.set asScala\n\u001b[31m   |\u001b[0m\n\u001b[31m47 |\u001b[0m        }\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660009930
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        var n = 0\n        for (i <- 0 until arr.length) {\n            val cur = arr(i)\n            if (cur < 0l) {\n                val s = math.abs(cur)\n                n += (s - math.min(s).toInt).toLong\n            } else {\n                n += 1\n            }\n        }\n        n\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpzwxqhx6v.scala:20:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m                n += (s - math.min(s).toInt).toLong\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                value += is not a member of Int - did you mean Int.!=?\n\u001b[31m\u001b[31m-- [E134] Type Error: /tmp/tmpzwxqhx6v.scala:20:31 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m                n += (s - math.min(s).toInt).toLong\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mNone of the overloaded alternatives of \u001b[33mmethod\u001b[0m \u001b[35mmin\u001b[0m in \u001b[33mpackage\u001b[0m \u001b[35mscala.math\u001b[0m with types\n\u001b[31m   |\u001b[0m (x: Double, y: Double): Double\n\u001b[31m   |\u001b[0m (x: Float, y: Float): Float\n\u001b[31m   |\u001b[0m (x: Long, y: Long): Long\n\u001b[31m   |\u001b[0m (x: Int, y: Int): Int\n\u001b[31m   |\u001b[0mmatch arguments ((s : Long))\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660009927
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        def count_nums(arr : List[Long]) : Long = {\n            var i = 0\n            var n = 0\n            var neg = 0\n            while (i < arr.length) {\n                if (arr(i) < 0) {\n                    neg = 1\n                }\n                else {\n                    var sum = arr(i)\n                    for (j <- 0 until arr(i).length-1) {\n                        val remainder = arr(i).mod(10).asInstanceOf[Int]\n                        sum = sum + remainder\n                        if (sum > 9) {\n                            sum = 1\n                        }\n                    }\n                    if (neg) {\n                        sum = sum * -1\n                    }\n                    n = n + 1 if (sum > 0)\n                }\n                i += 1\n            }\n            n - (neg)\n        }\n        count_nums(arr)\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmpmoglzxwj.scala:35:30 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m                    n = n + \u001b[31m1\u001b[0m \u001b[33mif\u001b[0m (sum > \u001b[31m0\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^\u001b[0m\n\u001b[31m   |\u001b[0m                              end of statement expected but 'if' found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpmoglzxwj.scala:25:45 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m                    \u001b[33mfor\u001b[0m (j <- \u001b[31m0\u001b[0m until arr(i).length-\u001b[31m1\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                    value length is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpmoglzxwj.scala:26:47 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m                        \u001b[33mval\u001b[0m \u001b[36mremainder\u001b[0m = arr(i).mod(\u001b[31m10\u001b[0m).asInstanceOf[\u001b[35mInt\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                                        ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue mod is not a member of Long, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mThe following import might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.BigInt.long2bigInt\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpmoglzxwj.scala:32:24 --------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m                    \u001b[33mif\u001b[0m (neg) {\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        Found:    (neg : Int)\n\u001b[31m   |\u001b[0m                        Required: Boolean\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "stdout": "",
      "timestamp": 1660009930
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        var total = 0L\n        for (i <- arr) {\n            total += i / 10\n        }\n        return arr.filter(i => { i / 10 > 0 }).length\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp8aqhi6v5.scala:24)\n\tat Problem.main(tmp8aqhi6v5.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009931
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        arr.filter(x => (x % 10).signum > 0).size\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp96v2jzh6.scala:22)\n\tat Problem.main(tmp96v2jzh6.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009932
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        val digits = arr.map(_ % 10).asInstanceOf[List[Int]]\n        val sumDigits = arr.map(_ % 10).sum\n        val count = digits.count(_ > 0)\n        val result = count / Math.pow(10, sumDigits)\n        val sign = sumDigits < 0 \n        if(sign) -result else result\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpwrtovljo.scala:20:17 --------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mif\u001b[0m(sign) -result \u001b[33melse\u001b[0m result\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                 Found:    Double\n\u001b[31m   |\u001b[0m                 Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpwrtovljo.scala:20:30 --------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mif\u001b[0m(sign) -result \u001b[33melse\u001b[0m result\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              Found:    (result : Double)\n\u001b[31m   |\u001b[0m                              Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660009930
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        arr.foldLeft(0l){\n            (total,num)=>\n                val rem = num % 10\n                if(rem > 0) total + rem\n                else total - (10 - rem)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmprf31eemc.scala:24)\n\tat Problem.main(tmprf31eemc.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009932
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.foldLeft(0)(_ + _)\n        if(nums < 0) -nums.signum else nums\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpdpo78pz9.scala:15:35 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnums\u001b[0m = arr.foldLeft(\u001b[31m0\u001b[0m)(_ + _)\n\u001b[31m\u001b[31m   |\u001b[0m                                   ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                   Found:    Long\n\u001b[31m   |\u001b[0m                                   Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660009930
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        def sum(l: List[Long]) : Long = {\n            l match {\n                case List() => 0\n                case Nil => 0\n                case x::xs => x.toLong + sum(xs)\n            }\n        }\n        val m = sum(arr)\n        (m % 10).signum match {\n            case 0 => 0\n            case 1 => 1\n            case _ => m / 10 match {\n                case m if m > 9 => m\n                case m => 1 + countNums(arr.drop(1))\n            }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp0llzo5qs.scala:34)\n\tat Problem.main(tmp0llzo5qs.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009933
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        var total = 0L\n        for(n <- arr){\n            total += n\n        }\n        for(n <- arr){\n            val m = n.toInt\n            total -= m\n        }\n        total\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpr4_00evo.scala:28)\n\tat Problem.main(tmpr4_00evo.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009932
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        val positiveSum = arr.filter { x =>\n            val x = Math.abs(x)\n            val z = x.toString.split('')\n            if (z.length == 1) 1\n            else {\n                val last = z.last\n                if (last >= 10) 0\n                else z.last.toInt - 10\n            }\n        }\n        positiveSum.size\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmpugckrhuo.scala:17:37 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mz\u001b[0m = x.toString.split('')\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                                     empty character literal\n\u001b[31m\u001b[31m-- Error: /tmp/tmpugckrhuo.scala:18:31 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m            \u001b[33mif\u001b[0m (z.length == \u001b[31m1\u001b[0m) \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                               ^\u001b[0m\n\u001b[31m   |\u001b[0m                     end of statement expected but integer literal found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpugckrhuo.scala:18:12 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m            \u001b[33mif\u001b[0m (z.length == \u001b[31m1\u001b[0m) \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^\u001b[0m\n\u001b[31m   |\u001b[0m            Not found: 'if\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660009925
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        val sum = arr.foldLeft(0){\n            (sum, value) =>\n                if (value > 0) sum + value * value else sum\n        }\n        sum :: arr.filter(n => n % sum == 0).length\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpn6za0hbk.scala:17:31 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m                \u001b[33mif\u001b[0m (value > \u001b[31m0\u001b[0m) sum + value * value \u001b[33melse\u001b[0m sum\n\u001b[31m\u001b[31m   |\u001b[0m                               ^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                               Found:    Long\n\u001b[31m   |\u001b[0m                               Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpn6za0hbk.scala:19:12 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        sum :: arr.filter(\u001b[36mn\u001b[0m => n % sum == \u001b[31m0\u001b[0m).length\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value :: is not a member of Int\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660009931
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        var total = 0\n        var count = 0\n        for ( i <- arr.iterator ) total += i\n        arr.foreach {\n          i =>\n            if ( i < 0 || i >= 10 ) {\n              if ( i < 0 ) count = count + 1\n              else {\n                for ( j <- 0 until -i-10 ) {\n                  total -= 10\n                  total += i\n                  if ( total > 10 ) break\n                }\n              }\n            } else {\n              if ( i < 0 ) count = count + 1\n              else {\n                for ( j <- 0 until i-10 ) {\n                  total -= 10\n                  total += i\n                  if ( total > 10 ) break\n                }\n              }\n            }\n        }\n        count\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpeg29fg6j.scala:17:40 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        \u001b[33mfor\u001b[0m ( i <- arr.iterator ) total += i\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  value += is not a member of Int - did you mean Int.!=?\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpeg29fg6j.scala:23:35 --------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m                \u001b[33mfor\u001b[0m ( j <- \u001b[31m0\u001b[0m until -i-\u001b[31m10\u001b[0m ) {\n\u001b[31m\u001b[31m   |\u001b[0m                                   ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                   Found:    Long\n\u001b[31m   |\u001b[0m                                   Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpeg29fg6j.scala:25:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m                  total += i\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  value += is not a member of Int - did you mean Int.!=?\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpeg29fg6j.scala:26:36 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m                  \u001b[33mif\u001b[0m ( total > \u001b[31m10\u001b[0m ) break\n\u001b[31m\u001b[31m   |\u001b[0m                                    ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                    Not found: break\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpeg29fg6j.scala:32:35 --------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m                \u001b[33mfor\u001b[0m ( j <- \u001b[31m0\u001b[0m until i-\u001b[31m10\u001b[0m ) {\n\u001b[31m\u001b[31m   |\u001b[0m                                   ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                   Found:    Long\n\u001b[31m   |\u001b[0m                                   Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpeg29fg6j.scala:34:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m                  total += i\n\u001b[31m\u001b",
      "stdout": "",
      "timestamp": 1660009933
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n      val firstDig = arr(0)\n      val arrCopy = arr.toList\n      val digitCount = arr.length\n      val sumDig = arrCopy.foldLeft(0) { (sum, n) =>\n        sum + n.signum\n      }\n      firstDig == arrCopy.head && sumDig == arrCopy.last\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp985gkjxj.scala:21:6 ---------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m      firstDig == arrCopy.head && sumDig == arrCopy.last\n\u001b[31m\u001b[31m   |\u001b[0m      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      Found:    Boolean\n\u001b[31m   |\u001b[0m      Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660009931
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n      var sum = 0l\n      val arr = arr.reverse\n      for (i <- arr) {\n        sum += i\n      }\n      if (sum == 0) 0l\n      else if (sum < 0) arr.takeWhile(_.isNegative).reverse |> count { n => n % 10 > 0 }\n      else arr.count { n => n % 10 > 0 }\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp_kmtf35x.scala:16:16 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m      \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = arr.reverse\n\u001b[31m\u001b[31m   |\u001b[0m                ^\u001b[0m\n\u001b[31m   |\u001b[0m                Recursive \u001b[33mvalue\u001b[0m \u001b[35marr\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660009925
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        // TODO: use foldLeft, map, and a mutable count\n        val count_arr : mutable.Map[Long, Long] = mutable.Map.empty[Long, Long]\n        arr.map(_ % 100).toList.foreach(x => count_arr += x -> (count_arr.getOrElse(x, 0) + 1l))\n        count_arr.reduceLeft((a, b) => (a + b)).sum\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpq8g7lcv8.scala:16:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mcount_arr\u001b[0m : mutable.Map[\u001b[35mLong\u001b[0m, \u001b[35mLong\u001b[0m] = mutable.Map.empty[\u001b[35mLong\u001b[0m, \u001b[35mLong\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpq8g7lcv8.scala:16:50 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mcount_arr\u001b[0m : mutable.Map[\u001b[35mLong\u001b[0m, \u001b[35mLong\u001b[0m] = mutable.Map.empty[\u001b[35mLong\u001b[0m, \u001b[35mLong\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                                                  ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                                  Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660009925
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n      arr.foreach( x => {\n        if( x < 0 ){\n          x = x * -1\n        }\n        for( i <- 0 until 10 ){\n          if( x % 10 == i ){\n            if( x % 100 != 0 ) x += 1\n          }\n        }\n        if( x >= 10 ){\n          x += 1\n        }\n      })\n      arr.count( x => x > 0 )\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmprajbwid0.scala:17:12 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m          x = x * -\u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m          ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m          Reassignment to val x\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmprajbwid0.scala:21:33 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m            \u001b[33mif\u001b[0m( x % \u001b[31m100\u001b[0m != \u001b[31m0\u001b[0m ) x += \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                               ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   value += is not a member of Long - did you mean x.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmprajbwid0.scala:25:12 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m          x += \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m          ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m          value += is not a member of Long - did you mean x.!=?\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660009932
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        val first = arr.head\n        val rest = arr.tail\n        val negative = arr.head.signum\n        val n = rest.length\n        if (n < 2) first\n        else (negative) ? ((rest.sum >= 0) ? (n + 1) : ((rest(n - 1) - first).signum + 1) + 1) : (rest.sum >= 0) ? ((rest.sum + first).signum + 1) : 1\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpq4g5ut2e.scala:20:61 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33melse\u001b[0m (negative) ? ((rest.sum >= \u001b[31m0\u001b[0m) ? (n + \u001b[31m1\u001b[0m) : ((rest(n - \u001b[31m1\u001b[0m) - first).signum + \u001b[31m1\u001b[0m) + \u001b[31m1\u001b[0m) : (rest.sum >= \u001b[31m0\u001b[0m) ? ((rest.sum + first).signum + \u001b[31m1\u001b[0m) : \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                                                             ^\u001b[0m\n\u001b[31m   |\u001b[0m                                             ')' expected, but '(' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpq4g5ut2e.scala:20:77 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33melse\u001b[0m (negative) ? ((rest.sum >= \u001b[31m0\u001b[0m) ? (n + \u001b[31m1\u001b[0m) : ((rest(n - \u001b[31m1\u001b[0m) - first).signum + \u001b[31m1\u001b[0m) + \u001b[31m1\u001b[0m) : (rest.sum >= \u001b[31m0\u001b[0m) ? ((rest.sum + first).signum + \u001b[31m1\u001b[0m) : \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                                                                             ^\u001b[0m\n\u001b[31m   |\u001b[0m                                             ')' expected, but '.' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpq4g5ut2e.scala:20:134 --------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33melse\u001b[0m (negative) ? ((rest.sum >= \u001b[31m0\u001b[0m) ? (n + \u001b[31m1\u001b[0m) : ((rest(n - \u001b[31m1\u001b[0m) - first).signum + \u001b[31m1\u001b[0m) + \u001b[31m1\u001b[0m) : (rest.sum >= \u001b[31m0\u001b[0m) ? ((rest.sum + first).signum + \u001b[31m1\u001b[0m) : \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                                                                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                                             ')' expected, but '.' found\n\u001b[31m\u001b[31m-- Error: /tmp/tmpq4g5ut2e.scala:20:147 ----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33melse\u001b[0m (negative) ? ((rest.sum >= \u001b[31m0\u001b[0m) ? (n + \u001b[31m1\u001b[0m) : ((rest(n - \u001b[31m1\u001b[0m) - first).signum + \u001b[31m1\u001b[0m) + \u001b[31m1\u001b[0m) : (rest.sum >= \u001b[31m0\u001b[0m) ? ((rest.sum + first).signum + \u001b[31m1\u001b[0m) : \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                                                    ",
      "stdout": "",
      "timestamp": 1660009943
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        arr.foldLeft(0l){ (acc, elem) =>\n            acc + (math.abs(elem).asDigits(10).filter(_.isDigit).sum > 0 ? 1 : 0)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpfwzr8_fi.scala:16:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            acc + (math.abs(elem).asDigits(\u001b[31m10\u001b[0m).filter(_.isDigit).sum > \u001b[31m0\u001b[0m ? \u001b[31m1\u001b[0m : \u001b[31m0\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   value asDigits is not a member of Long\n1 error found\n",
      "stdout": "",
      "timestamp": 1660009945
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        arr.foldLeft((0l, 0)) { ((acc, element), (acc1, digit)) =>\n            digit.signum match {\n                case -1 => acc -> (acc1 + 1l)\n                case _ =>\n                    if (element % 10 != 0) acc -> (acc1 + 1)\n                    else acc -> (acc1 + digit)\n            }\n        }._1\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmp05f97rck.scala:15:33 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        arr.foldLeft((\u001b[31m0l\u001b[0m, \u001b[31m0\u001b[0m)) { ((acc, element), (acc1, digit)) =>\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 not a legal formal parameter\n\u001b[31m\u001b[31m-- Error: /tmp/tmp05f97rck.scala:15:49 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        arr.foldLeft((\u001b[31m0l\u001b[0m, \u001b[31m0\u001b[0m)) { ((acc, element), (acc1, digit)) =>\n\u001b[31m\u001b[31m   |\u001b[0m                                                 ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                            not a legal formal parameter\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp05f97rck.scala:16:12 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            digit.signum \u001b[33mmatch\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            Not found: digit\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp05f97rck.scala:17:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m                \u001b[33mcase\u001b[0m -\u001b[31m1\u001b[0m => acc -> (acc1 + \u001b[31m1l\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                           ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                           Not found: acc\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp05f97rck.scala:19:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m                    \u001b[33mif\u001b[0m (element % \u001b[31m10\u001b[0m != \u001b[31m0\u001b[0m) acc -> (acc1 + \u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        Not found: element\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp05f97rck.scala:19:43 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m                    \u001b[33mif\u001b[0m (element % \u001b[31m10\u001b[0m != \u001b[31m0\u001b[0m) acc -> (acc1 + \u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0",
      "stdout": "",
      "timestamp": 1660009938
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        // We need to do two passes:\n        // Pass 1: Count the number of positive numbers in the array\n        val nums = arr.filter(_ > 0).toList\n        var count = 0L\n        for (n <- nums)\n            if ((n - 1).toString.sum > 0)\n                count = count + 1L\n        \n        // Pass 2: Remove all those negative numbers we counted in pass 1\n        var newArr = (0 until count).map(_ => -1).toList\n        newArr = newArr ++ nums\n        \n        // Convert the new array to an array\n        val newNums = (0 until newArr.length).map(_ => newArr.toArray[Long](0))\n        \n        // Now do the count\n        var numsWithSum = 0\n        for (n <- newNums)\n            if ((n - 1).toString.sum > 0)\n                numsWithSum = numsWithSum + 1L\n        \n        numsWithSum\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpmpjc0p1i.scala:24:30 --------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mnewArr\u001b[0m = (\u001b[31m0\u001b[0m until count).map(_ => -\u001b[31m1\u001b[0m).toList\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              Found:    (count : Long)\n\u001b[31m   |\u001b[0m                              Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpmpjc0p1i.scala:25:27 --------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        newArr = newArr ++ nums\n\u001b[31m\u001b[31m   |\u001b[0m                           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                           Found:    (nums : List[Long])\n\u001b[31m   |\u001b[0m                           Required: IterableOnce[Int]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpmpjc0p1i.scala:28:76 --------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnewNums\u001b[0m = (\u001b[31m0\u001b[0m until newArr.length).map(_ => newArr.toArray[\u001b[35mLong\u001b[0m](\u001b[31m0\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                                                                            ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Found:    (\u001b[31m0\u001b[0m : Int)\n\u001b[31m   |\u001b[0m                                  Required: scala.reflect.ClassTag[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpmpjc0p1i.scala:33:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m            \u001b[33mif\u001b[0m ((n - \u001b[31m1\u001b[0m).toString.sum > \u001b[31m0\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue - is not a member of Array[Long], but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might make progress towards fixing the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.Fractional.Implicits.infixFractionalOps\n\u001b[31m   |\u001b[0m  import math.Integral.Implicits.i",
      "stdout": "",
      "timestamp": 1660009949
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        arr.map(i => abs(i)).filter(_ > 0).count() \n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmpoorohry3.scala:15:48 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        arr.map(\u001b[36mi\u001b[0m => abs(i)).filter(_ > \u001b[31m0\u001b[0m).count() \n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmissing argument for parameter p of \u001b[33mmethod\u001b[0m \u001b[35mcount\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mIterableOnceOps\u001b[0m: (p: Long => Boolean): Int\n1 error found\n",
      "stdout": "",
      "timestamp": 1660009942
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n       val sum = arr.filter(_ % 10).length\n       if (sum < 0) (-arr.head % 10).asInstanceOf[Int] else sum\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpa9azbr8g.scala:15:28 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m       \u001b[33mval\u001b[0m \u001b[36msum\u001b[0m = arr.filter(_ % \u001b[31m10\u001b[0m).length\n\u001b[31m\u001b[31m   |\u001b[0m                            ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                            Found:    Long\n\u001b[31m   |\u001b[0m                            Required: Boolean\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660009947
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n       var count = 0\n       arr.foreach(x => {\n           val sum = x.toString.toLong\n           if (sum > 0) count += sum\n       })\n       count\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp3gmz79fa.scala:18:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m           \u001b[33mif\u001b[0m (sum > \u001b[31m0\u001b[0m) count += sum\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  value += is not a member of Int - did you mean Int.!=?\n1 error found\n",
      "stdout": "",
      "timestamp": 1660009947
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        val digits = arr.map(i => math.abs(i)).toSet\n        // Sum all digits if they're positive => sum if x > 0 else sum if x < 0\n        var sum = 0\n        for( i <- digits if i > 0 ){ sum += i}\n        // Sum all negative digits if they're positive => sum if x < 0 else sum if x > 0 \n        for( i <- digits if i < 0 ){ sum += i}\n        sum\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmphisn67ec.scala:18:41 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mfor\u001b[0m( i <- digits \u001b[33mif\u001b[0m i > \u001b[31m0\u001b[0m ){ sum += i}\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  value += is not a member of Int - did you mean Int.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmphisn67ec.scala:20:41 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mfor\u001b[0m( i <- digits \u001b[33mif\u001b[0m i < \u001b[31m0\u001b[0m ){ sum += i}\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  value += is not a member of Int - did you mean Int.!=?\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660009952
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        if (arr.isEmpty) 0\n        else {\n            var count = 0\n            var sign = 1\n            var i = -1\n            while (i < arr.length) {\n                val digit = arr(i).toInt\n                i += sign\n                if (digit > 0) {\n                    count += 1\n                }\n                sign *= -1\n            }\n            count\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.IndexOutOfBoundsException: -1\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:115)\n\tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\tat Problem$.countNums(tmp7igb7fk1.scala:21)\n\tat Problem$.main(tmp7igb7fk1.scala:33)\n\tat Problem.main(tmp7igb7fk1.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009953
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        if(arr.isEmpty) return 0\n        val n = arr.size\n        val res = mutable.ListBuffer.empty[Long]\n        var nSum = 0\n        var last: Long = 0\n        arr.foreach(x => {\n            if(x == 0) return\n            if(nSum > 0) last = x % 10\n            nSum += x % 10\n        })\n        if(last.signum <= 0) nSum -= last\n        res += nSum\n        arr.filter(_ > 0).foreach(x => {\n            val diff = last - x % 10\n            if(diff > 0) res += diff\n        })\n        res.sum\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpd7olxuuc.scala:17:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mres\u001b[0m = mutable.ListBuffer.empty[\u001b[35mLong\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpd7olxuuc.scala:21:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m            \u001b[33mif\u001b[0m(x == \u001b[31m0\u001b[0m) \u001b[33mreturn\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    Unit\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpd7olxuuc.scala:23:17 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m            nSum += x % \u001b[31m10\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value += is not a member of Int - did you mean Int.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpd7olxuuc.scala:25:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mif\u001b[0m(last.signum <= \u001b[31m0\u001b[0m) nSum -= last\n\u001b[31m\u001b[31m   |\u001b[0m                             ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  value -= is not a member of Int - did you mean Int.!=?\n4 errors found\n",
      "stdout": "",
      "timestamp": 1660009952
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        var total = 0l\n        var i = 0\n        while (i < arr.length) {\n            if (arr(i) <= 0) break\n            if (arr(i) > 0 && arr(i) != arr(i - 1)) total += 1\n            i += 1\n        }\n        total\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp1p6529ok.scala:18:29 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m            \u001b[33mif\u001b[0m (arr(i) <= \u001b[31m0\u001b[0m) break\n\u001b[31m\u001b[31m   |\u001b[0m                             ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                             Not found: break\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660009944
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        arr.map {\n            case x if x.signum <= 0 => -x.signum\n            case x => x.signum\n        }.distinct().count { x => x > 0 }\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmpq520ld3g.scala:18:18 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        arr.map {\n\u001b[31m16 |\u001b[0m            \u001b[33mcase\u001b[0m x \u001b[33mif\u001b[0m x.signum <= \u001b[31m0\u001b[0m => -x.signum\n\u001b[31m17 |\u001b[0m            \u001b[33mcase\u001b[0m x => x.signum\n\u001b[31m18 |\u001b[0m        }.distinct().count { \u001b[36mx\u001b[0m => x > \u001b[31m0\u001b[0m }\n\u001b[31m\u001b[31m   |\u001b[0m        ^\u001b[0m\n\u001b[31m   |\u001b[0mmissing argument for parameter n of \u001b[33mmethod\u001b[0m \u001b[35mapply\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mLinearSeqOps\u001b[0m: (n: Int): Int\n1 error found\n",
      "stdout": "",
      "timestamp": 1660009946
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        arr match {\n            case x :: xs => x.toString.map(_.asDigit).toList.filter(d => d > 0).sum\n            case Nil => 0\n            case _   => sys.error(\"Not a List[Long]\")\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpmjydhm4m.scala:23)\n\tat Problem.main(tmpmjydhm4m.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009955
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        def sumDigits(num : Long) : List[Int] = num.toString.map(_.toInt).map(_.toInt)\n        // For each number in the array, see if it is negative by looking at the\n        // first sign of the number.\n        val negativeCount = arr.count(x => x < 0)\n        var count = 0L\n        var negSum = Long.MinValue\n        for(num <- arr) {\n            if(num < 0)\n                negSum += num\n            val digits = sumDigits(num)\n            for((digit, countDigit) <- digits) {\n                count += countDigit\n                if( negSum <= digit * countDigit )\n                    count -= (digit * countDigit - negSum)\n            }\n        }\n        count - negativeCount\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpc6f672wt.scala:15:77 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mdef\u001b[0m \u001b[36msumDigits\u001b[0m(\u001b[36mnum\u001b[0m : \u001b[35mLong\u001b[0m) : \u001b[35mList\u001b[0m[\u001b[35mInt\u001b[0m] = num.toString.map(_.toInt).map(_.toInt)\n\u001b[31m\u001b[31m   |\u001b[0m                                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                               Found:    IndexedSeq[Int]\n\u001b[31m   |\u001b[0m                                               Required: List[Int]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpc6f672wt.scala:26:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m                count += countDigit\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                value += is not a member of Long - did you mean Long.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpc6f672wt.scala:27:36 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m                \u001b[33mif\u001b[0m( negSum <= digit * countDigit )\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue * is not a member of Any, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might make progress towards fixing the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.Fractional.Implicits.infixFractionalOps\n\u001b[31m   |\u001b[0m  import math.Integral.Implicits.infixIntegralOps\n\u001b[31m   |\u001b[0m  import math.Numeric.Implicits.infixNumericOps\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpc6f672wt.scala:28:26 ------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m                    count -= (digit * countDigit - negSum)\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                value -= is not a member of Long - did you mean Long.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpc6f672wt.scala:28:36 ------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m                    count -= (digit * countDigit - negSum)\n\u001b[31m\u001b[31m   |\u001b[0m  ",
      "stdout": "",
      "timestamp": 1660009955
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.filter(_ > 0)\n        val list = nums.takeWhile(_ < Integer.MAX_VALUE).toList\n        val neg = (list.head - list.last).abs\n        val len = list.size - neg.toLong\n        val sum = (list.sum - list.take(len).toList.sum).toLong\n        len.abs() * sum\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpgi0lnf_r.scala:19:40 --------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36msum\u001b[0m = (list.sum - list.take(len).toList.sum).toLong\n\u001b[31m\u001b[31m   |\u001b[0m                                        ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                        Found:    (len : Long)\n\u001b[31m   |\u001b[0m                                        Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpgi0lnf_r.scala:20:12 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        len.abs() * sum\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        \u001b[33mmethod\u001b[0m \u001b[35mabs\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mRichLong\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660009951
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n      var counter = 0\n      for (i <- arr) {\n        if (i < 0l) {\n          i += 10\n        }\n        val digit = math.abs(i)\n        if (digit > 9) {\n          counter += digit % 10\n        } else {\n          counter += digit\n        }\n      }\n      counter\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmphp417t3d.scala:18:12 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m          i += \u001b[31m10\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m          ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m          value += is not a member of Long - did you mean i.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmphp417t3d.scala:22:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m          counter += digit % \u001b[31m10\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m          ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m          value += is not a member of Int - did you mean Int.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmphp417t3d.scala:24:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m          counter += digit\n\u001b[31m\u001b[31m   |\u001b[0m          ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m          value += is not a member of Int - did you mean Int.!=?\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660009954
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        var cnt = 0\n        arr.foreach(n => {\n            if (n > 0) cnt += math.gcd(n, arr.sum)\n        })\n        cnt\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp38v4irc6.scala:17:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m            \u001b[33mif\u001b[0m (n > \u001b[31m0\u001b[0m) cnt += math.gcd(n, arr.sum)\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  value += is not a member of Int - did you mean Int.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp38v4irc6.scala:17:35 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m            \u001b[33mif\u001b[0m (n > \u001b[31m0\u001b[0m) cnt += math.gcd(n, arr.sum)\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              value gcd is not a member of math\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660009954
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        val arr2 = arr.map{x => if(x > 0) x else -x}\n        arr2.count(x=> x > 0)\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpaitn4ymo.scala:20)\n\tat Problem.main(tmpaitn4ymo.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009956
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        var count = 0\n        val arr = arr.toList\n        for (i <- arr) {\n            if (i != 0l) {\n                val sum = i.asInstanceOf[Long].toString.dropWhile(x => x < 48).drop(1).dropWhile(x => x < 58).toString.toInt\n                if (sum > 0) count += 1 \n            }\n        }\n        arr match {\n            case x :: y => countNums(y)\n            case Nil => count\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpyuzsdto6.scala:16:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = arr.toList\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Recursive \u001b[33mvalue\u001b[0m \u001b[35marr\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpyuzsdto6.scala:24:37 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m            \u001b[33mcase\u001b[0m x :: y => countNums(y)\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                                     Not found: y\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660009947
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        arr.filter(_.nonEmpty).foldLeft((0l,0l)) { case ((sum, digits), n) => \n            val d = n.toString.toLong;\n            (sum + d.toInt*10, digits + (if (d < 0) -d.toInt else 0))}._1\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpxpj3glv7.scala:15:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        arr.filter(_.nonEmpty).foldLeft((\u001b[31m0l\u001b[0m,\u001b[31m0l\u001b[0m)) { \u001b[33mcase\u001b[0m ((sum, digits), n) => \n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   value nonEmpty is not a member of Long\n1 error found\n",
      "stdout": "",
      "timestamp": 1660009953
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        arr.foldLeft(0l){ \n            case (nums, num) => \n                val digits = num.toString.reverse.foldLeft(\"\")(_ + _)\n                (digits.tail.toLong, nums, digits.head.toLong * 10) match {\n                    case (acc, (acc, sum, mult)) => (acc + sum * mult) \n                }\n        }._2\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E005] Naming Error: /tmp/tmpg22_oi6f.scala:19:32 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m                    \u001b[33mcase\u001b[0m (acc, (acc, sum, mult)) => (acc + sum * mult) \n\u001b[31m\u001b[31m   |\u001b[0m                                ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                duplicate pattern variable: acc\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpg22_oi6f.scala:19:57 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m                    \u001b[33mcase\u001b[0m (acc, (acc, sum, mult)) => (acc + sum * mult) \n\u001b[31m\u001b[31m   |\u001b[0m                                                     ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue + is not a member of Any, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might make progress towards fixing the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.Fractional.Implicits.infixFractionalOps\n\u001b[31m   |\u001b[0m  import math.Integral.Implicits.infixIntegralOps\n\u001b[31m   |\u001b[0m  import math.Numeric.Implicits.infixNumericOps\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpg22_oi6f.scala:19:63 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m                    \u001b[33mcase\u001b[0m (acc, (acc, sum, mult)) => (acc + sum * mult) \n\u001b[31m\u001b[31m   |\u001b[0m                                                           ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue * is not a member of Any, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might make progress towards fixing the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.Fractional.Implicits.infixFractionalOps\n\u001b[31m   |\u001b[0m  import math.Integral.Implicits.infixIntegralOps\n\u001b[31m   |\u001b[0m  import math.Numeric.Implicits.infixNumericOps\n\u001b[31m   |\u001b[0m\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660009955
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        val m = arr.head\n        val d = arr.tail.foldLeft(0L)((i, x) => i + x * x.toLong)\n        m / d + 1\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.util.NoSuchElementException: head of empty list\n\tat scala.collection.immutable.Nil$.head(List.scala:662)\n\tat scala.collection.immutable.Nil$.head(List.scala:661)\n\tat Problem$.countNums(tmp884ez1g6.scala:15)\n\tat Problem$.main(tmp884ez1g6.scala:20)\n\tat Problem.main(tmp884ez1g6.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009957
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        val res = new mutable.HashMap[Long, Long]()\n        for (i <- arr.indices)\n            if ((arr(i).toLong & 0xFFFF0000) < 0)\n                res.update(-(arr(i).toLong & 0xFFFF0000), (1L*res.size))\n            else\n                res.update(arr(i).toLong, (1L*res.size))\n        res.values.sum\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp62k0hwb2.scala:15:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mres\u001b[0m = \u001b[33mnew\u001b[0m mutable.HashMap[\u001b[35mLong\u001b[0m, \u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660009949
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        val digitSums = arr.foldLeft(Map[Long, Int]())((map, x) => {\n            val digit = math.abs(x)\n            val oldValue = map.getOrElse(digit, 0)\n            val newValue = oldValue + digit\n            map += digit -> newValue\n            map\n        })\n        digitSums.values.sum\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpcugbdnq0.scala:19:28 --------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m            map += digit -> newValue\n\u001b[31m\u001b[31m   |\u001b[0m                            ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                            Found:    (newValue : Long)\n\u001b[31m   |\u001b[0m                            Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660009960
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        arr.foreach { x =>\n            // If x is negative, get the absolute value of x and add 1 to the count\n            val absVal = math.abs(x)\n            if (absVal < 1L) x + 1L\n            else 0L\n        }.sum\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp280ufl2k.scala:20:10 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        arr.foreach { \u001b[36mx\u001b[0m =>\n\u001b[31m16 |\u001b[0m            \u001b[34m// If x is negative, get the absolute value of x and add 1 to the count\u001b[0m\n\u001b[31m17 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mabsVal\u001b[0m = math.abs(x)\n\u001b[31m18 |\u001b[0m            \u001b[33mif\u001b[0m (absVal < \u001b[31m1L\u001b[0m) x + \u001b[31m1L\u001b[0m\n\u001b[31m19 |\u001b[0m            \u001b[33melse\u001b[0m \u001b[31m0L\u001b[0m\n\u001b[31m20 |\u001b[0m        }.sum\n\u001b[31m\u001b[31m   |\u001b[0m        ^\u001b[0m\n\u001b[31m   |\u001b[0m        value sum is not a member of Unit\n1 error found\n",
      "stdout": "",
      "timestamp": 1660009962
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.map(x => x.toString.toInt)\n        var numOfPositive = 0\n        var numOfNegative = 0\n        for (xs <- nums) {\n            val n = xs.toInt\n            if (n < 0) numOfNegative += 1\n            else if (n >= 0) numOfPositive += 1\n        }\n        numOfPositive + numOfNegative\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp72i57c0i.scala:27)\n\tat Problem.main(tmp72i57c0i.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009969
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        val result = arr.foldLeft(0l) { (acc: Long, num: Long) => acc + num / 10 }\n        if (result < 0L) -result else result\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpp2ewn1yc.scala:21)\n\tat Problem.main(tmpp2ewn1yc.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009969
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        val list = arr.toList\n        val n = list.size\n        var sum : Long = 0\n        var lastDigit : Option[Long] = None\n\n        for (i <- 0 until n) {\n            val curDigit = if (list(i) > 0) list(i).asDigit else 0\n            sum = sum + curDigit\n\n            // if sum >= 10, then the last digit must be zero\n            if (sum >= 10) {\n                lastDigit = Some(sum % 10)\n                sum = 0\n            }\n        }\n\n        // the last digit must be zero\n        sum = sum + lastDigit.get // use getOrElse to handle None case\n        list.length.filter(_ > 0).foldLeft(0)((count, i) => count + i)\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp8sudttca.scala:21:52 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mcurDigit\u001b[0m = \u001b[33mif\u001b[0m (list(i) > \u001b[31m0\u001b[0m) list(i).asDigit \u001b[33melse\u001b[0m \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                                            ^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                   value asDigit is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp8sudttca.scala:33:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        list.length.filter(_ > \u001b[31m0\u001b[0m).foldLeft(\u001b[31m0\u001b[0m)((\u001b[36mcount\u001b[0m, \u001b[36mi\u001b[0m) => count + i)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        value filter is not a member of Int\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660009967
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        val sum = 0\n        var count = 0\n        for (num <- arr) {\n            if (num > 0) {\n                count += (math.ceil(num / 10.toDouble) * 10)\n                sum += num % 10\n            }\n            else {\n                count += 1\n                sum += num.toLong % 10\n            }\n        }\n        sum + (math.ceil((count - 1) / 10) * 10) - sum\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp6wh6yaz8.scala:19:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m                count += (math.ceil(num / \u001b[31m10\u001b[0m.toDouble) * \u001b[31m10\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                value += is not a member of Int - did you mean Int.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp6wh6yaz8.scala:20:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m                sum += num % \u001b[31m10\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                value += is not a member of Int - did you mean sum.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp6wh6yaz8.scala:24:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m                sum += num.toLong % \u001b[31m10\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                value += is not a member of Int - did you mean sum.!=?\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp6wh6yaz8.scala:27:8 ---------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        sum + (math.ceil((count - \u001b[31m1\u001b[0m) / \u001b[31m10\u001b[0m) * \u001b[31m10\u001b[0m) - sum\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Found:    Double\n\u001b[31m   |\u001b[0m        Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "stdout": "",
      "timestamp": 1660009971
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        var count = 0\n        var num = 0\n        for (i <- 0 until arr.size) {\n            if (arr(i) < 0) {\n                val d = arr(i) mod 10 // get first digit of number\n                val sign = if (d < 0) -1 else 1\n                num += sign * d\n            }\n            else {\n                num += arr(i)\n            }\n            num %= 10 // remove the first digit\n            count += 1\n            if (count == arr.size) {\n                num\n            }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpihrgr9c4.scala:19:31 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m                \u001b[33mval\u001b[0m \u001b[36md\u001b[0m = arr(i) mod \u001b[31m10\u001b[0m \u001b[34m// get first digit of number\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue mod is not a member of Long, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mThe following import might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.BigInt.long2bigInt\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpihrgr9c4.scala:24:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m                num += arr(i)\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                value += is not a member of Int - did you mean Int.!=?\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660009971
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        if(arr.isEmpty) {\n            return 0\n        }\n\n        val digits = arr.map(_.toString.toDouble)\n            .map(_.toInt)\n\n        if(digits.isEmpty) {\n            return 0\n        }\n\n        val max = digits.max()\n        val maxIdx = digits.indexOf(max)\n        val sumOfDigits = digits.sum\n\n        // negative numbers have negative first (sign) digit\n        if(arr.head < 0){\n            sumOfDigits *= -1\n        }\n\n        if(sumOfDigits == 0){\n            return 1\n        }\n\n        val currSum = sumOfDigits / (1l / 10)\n        val currIdx = (maxIdx + 1) % arr.length\n        val newSum = digits(currIdx) + digits(currIdx + 1)\n\n        if(newSum == 0){\n            return 1\n        }\n\n        val nextIdx = (currIdx + 1) % arr.length\n        val nextSum = digits(nextIdx) + digits(nextIdx + 1)\n\n        val newSumNewIdx = currIdx + (newSum / digits(currIdx))\n        val nextSumNewIdx = nextIdx + (nextSum / digits(nextIdx))\n\n        if(newSumNewIdx == 0 && nextSumNewIdx == 0){\n            return 1\n        }\n\n        if(newSumNewIdx < 0){\n            newSumNewIdx += 1\n        }\n\n        if(nextSumNewIdx < 0){\n            nextSumNewIdx += 1\n        }\n\n        if(newSumNewIdx > arr.length){\n            newSumNewIdx -= 1\n        }\n\n        if(nextSumNewIdx > arr.length){\n            nextSumNewIdx -= 1\n        }\n\n        val newDigits = digits.drop(newSumNewIdx)\n        val nextDigits = digits.drop(nextSumNewIdx)\n        val newMaxIdx = newDigits.indexOf(newDigits.max())\n        val nextMaxIdx = nextDigits.indexOf(nextDigits.max())\n\n        val newIdx = (newMaxIdx + 1) % newDigits.length\n        val nextIdx = (nextMaxIdx + 1) % nextDigits.length\n\n        val newSumNewIdx2 = newSumNewIdx + (newSum / newDigits(newSumNewIdx))\n        val nextSumNewIdx2 = nextSumNewIdx + (nextSum / nextDigits(nextSumNewIdx))\n\n        if(newSumNewIdx2 == 0 && nextSumNewIdx2 == 0){\n            return 1\n        }\n\n        if(newSumNewIdx < 0){\n            newSumNewIdx2 += 1\n        }\n\n        if(nextSumNewIdx < 0){\n            nextSumNew\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmprr5hgzp8.scala:107:0 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m107 |\u001b[0m\n\u001b[31m\u001b[31m    |\u001b[0m^\u001b[0m\n\u001b[31m    |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmprr5hgzp8.scala:79:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m79 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnextIdx\u001b[0m = (nextMaxIdx + \u001b[31m1\u001b[0m) % nextDigits.length\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnextIdx is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnextIdx\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- Error: /tmp/tmprr5hgzp8.scala:26:28 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmax\u001b[0m = digits.max()\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmissing argument for parameter ord of \u001b[33mmethod\u001b[0m \u001b[35mmax\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mIterableOnceOps\u001b[0m: (\u001b[33mimplicit \u001b[0mord: Ordering[B]): Int\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmprr5hgzp8.scala:32:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m            sumOfDigits *= -\u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m          value *= is not a member of Int - did you mean sumOfDigits.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmprr5hgzp8.scala:58:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m58 |\u001b[0m            newSumNewIdx += \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m         value += is not a member of Int - did you mean newSumNewIdx.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmprr5hgzp8.scala:62:26 ------------------------\u001b[0m\u001b[0m\n\u001b[31m62 |\u001b[0m            nextSumNewIdx += \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        value += is not a member of Int - did you mean nextSumNewIdx.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmprr5hgzp8.scala:66:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m66 |\u001b[0m            newSumNewIdx -= \u001b[31m1\u001b[0m\n\u001b[",
      "stdout": "",
      "timestamp": 1660009974
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        val m = arr.foldLeft(new mutable.HashMap[Long, Int]()){\n            case (acc, x) =>\n                acc.getOrElse(x * 10 + x.signum(), 0) += 1;\n                acc\n            }\n        m.values.sum;\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp0k1feib8.scala:15:33 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mm\u001b[0m = arr.foldLeft(\u001b[33mnew\u001b[0m mutable.HashMap[\u001b[35mLong\u001b[0m, \u001b[35mInt\u001b[0m]()){\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp0k1feib8.scala:17:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m                acc.getOrElse(x * \u001b[31m10\u001b[0m + x.signum(), \u001b[31m0\u001b[0m) += \u001b[31m1\u001b[0m;\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                value getOrElse is not a member of Any\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp0k1feib8.scala:17:41 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m                acc.getOrElse(x * \u001b[31m10\u001b[0m + x.signum(), \u001b[31m0\u001b[0m) += \u001b[31m1\u001b[0m;\n\u001b[31m\u001b[31m   |\u001b[0m                                       ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        \u001b[33mmethod\u001b[0m \u001b[35msignum\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mScalaNumberProxy\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp0k1feib8.scala:20:10 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        m.values.sum;\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        value values is not a member of Any\n4 errors found\n",
      "stdout": "",
      "timestamp": 1660009972
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        val digits = arr.map(_.toInt)\n        val sumOfDigits = digits.foldLeft(0)((acc, x) => acc + x)\n        sumOfDigits > 0\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpqtf_hpjb.scala:17:8 ---------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        sumOfDigits > \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Found:    Boolean\n\u001b[31m   |\u001b[0m        Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660009971
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        val counts = mutable.Map[Long, Int]()\n        arr.foreach{numOfDigits =>\n            val countOfDigits = counts(numOfDigits)\n            countOfDigits += 1\n            counts(numOfDigits) = countOfDigits\n        }\n        arr.zipWithIndex.filter(f => f._2 > 0).map(f => f._1).sum\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp7a5ei8ij.scala:15:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mcounts\u001b[0m = mutable.Map[\u001b[35mLong\u001b[0m, \u001b[35mInt\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660009965
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n      var count = 0\n      arr.foreach(x => {\n        if ((x % 10) > 0) {\n          count += 1\n        }\n      })\n      count\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpm77oprg8.scala:28)\n\tat Problem.main(tmpm77oprg8.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009975
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        arr.foldLeft(0l)((n, x) => n + (x % 10 > 0 ? 1 :\n            (x % 10 < 0 ? -1 : 0)))\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmps_kdkvqz.scala:16:29 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            (x % \u001b[31m10\u001b[0m < \u001b[31m0\u001b[0m ? -\u001b[31m1\u001b[0m : \u001b[31m0\u001b[0m)))\n\u001b[31m\u001b[31m   |\u001b[0m                             ^\u001b[0m\n\u001b[31m   |\u001b[0m                             ')' expected, but ':' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmps_kdkvqz.scala:16:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            (x % \u001b[31m10\u001b[0m < \u001b[31m0\u001b[0m ? -\u001b[31m1\u001b[0m : \u001b[31m0\u001b[0m)))\n\u001b[31m\u001b[31m   |\u001b[0m                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: type <\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmps_kdkvqz.scala:15:51 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        arr.foldLeft(\u001b[31m0l\u001b[0m)((\u001b[36mn\u001b[0m, \u001b[36mx\u001b[0m) => n + (x % \u001b[31m10\u001b[0m > \u001b[31m0\u001b[0m ? \u001b[31m1\u001b[0m :\n\u001b[31m\u001b[31m   |\u001b[0m                                                 ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                          value ? is not a member of Int\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660009972
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        if (arr.isEmpty)\n            return 0l\n        if (arr(0) < 0)\n            return countNums(arr diff 0l)\n        var sum = 0l\n        val digits = arr.map(_.toString.map(_.toInt))\n        val nums = digits(0)\n        var sumOfDigits = 0\n        for (i<-0 to nums.size-1)\n            if (nums(i) > 0)\n                sumOfDigits += nums(i)\n        if (sumOfDigits >= 10)\n            sum += nums.size\n        else\n            for ((digit, index) <- digits.zip(Array.range(0, digits.size))) {\n                if (digit > 0)\n                    sum += digit\n            }\n        return sum\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpr3mmdoqr.scala:18:38 --------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m            \u001b[33mreturn\u001b[0m countNums(arr diff \u001b[31m0l\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^^\u001b[0m\n\u001b[31m   |\u001b[0m                                    Found:    (\u001b[31m0L\u001b[0m : Long)\n\u001b[31m   |\u001b[0m                                    Required: scala.collection.Seq[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpr3mmdoqr.scala:30:26 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m                \u001b[33mif\u001b[0m (digit > \u001b[31m0\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue > is not a member of IndexedSeq[Int], but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might make progress towards fixing the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.Ordered.orderingToOrdered\n\u001b[31m   |\u001b[0m  import math.Ordering.Implicits.infixOrderingOps\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpr3mmdoqr.scala:31:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m                    sum += digit\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                value += is not a member of Long - did you mean Long.!=?\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660009977
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        var sum = 0L\n        for (num <- arr) {\n            if (num > 0) sum += num\n            else return sum\n        }\n        return sum\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpc_5xx9wt.scala:25)\n\tat Problem.main(tmpc_5xx9wt.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009978
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.filter(_ > 0)\n        if (nums.isEmpty) {\n            return 0\n        }\n        val first = nums.head\n        val last  = nums.last\n        var count = 0\n        for (i<- first until last){\n            count += i / 10 + (i % 10 != 0)\n        }\n        count\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpxjzvhyxt.scala:23:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m            count += i / \u001b[31m10\u001b[0m + (i % \u001b[31m10\u001b[0m != \u001b[31m0\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value += is not a member of Int - did you mean Int.!=?\n\u001b[31m\u001b[31m-- [E134] Type Error: /tmp/tmpxjzvhyxt.scala:23:28 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m            count += i / \u001b[31m10\u001b[0m + (i % \u001b[31m10\u001b[0m != \u001b[31m0\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mNone of the overloaded alternatives of \u001b[33mmethod\u001b[0m \u001b[35m+\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mLong\u001b[0m with types\n\u001b[31m   |\u001b[0m (x: Double): Double\n\u001b[31m   |\u001b[0m (x: Float): Float\n\u001b[31m   |\u001b[0m (x: Long): Long\n\u001b[31m   |\u001b[0m (x: Int): Long\n\u001b[31m   |\u001b[0m (x: Char): Long\n\u001b[31m   |\u001b[0m (x: Short): Long\n\u001b[31m   |\u001b[0m (x: Byte): Long\n\u001b[31m   |\u001b[0m (x: String): String\n\u001b[31m   |\u001b[0mmatch arguments (Boolean)\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660009975
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        var sum = 0\n        var count = 0\n        for (i <- arr) {\n            if (i <= 0)\n                continue\n            sum += i\n            count += 1\n        }\n        sum\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp8fgzegjq.scala:19:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m                continue\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: continue\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp8fgzegjq.scala:20:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m            sum += i\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value += is not a member of Int - did you mean Int.!=?\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660009974
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        val counts = mutable.Map.empty[Long, Long]\n        val minSum = 0\n        arr.foreach { e =>\n            val sum = e.toString.sum.toLong\n            val sumOfDigits = sum % 10\n            if (sumOfDigits > 0)\n                if (minSum == 0 || sumOfDigits < minSum)\n                    minSum = sumOfDigits\n                counts(sumOfDigits) = counts(sumOfDigits) + 1 \n            }\n        minSum\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpcszik1lb.scala:15:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mcounts\u001b[0m = mutable.Map.empty[\u001b[35mLong\u001b[0m, \u001b[35mLong\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpcszik1lb.scala:22:29 --------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m                    minSum = sumOfDigits\n\u001b[31m\u001b[31m   |\u001b[0m                             ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                             Found:    (sumOfDigits : Long)\n\u001b[31m   |\u001b[0m                             Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660009974
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        var count = 0\n        for (el <- arr) {\n            val l = abs(el)\n            val digits = l % 10\n            val num = (l / 10).floor\n            if (num > 0) {\n                // we know all digits must be positive, so if the remaining\n                // digits are negative, then they will be positive and we'll want\n                // to count them.\n                if (digits < 0) {\n                    count += 1\n                }\n            }\n        }\n        count\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpc5mde087.scala:19:31 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mnum\u001b[0m = (l / \u001b[31m10\u001b[0m).floor\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value floor is not a member of Long.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          floatWrapper(l./(\u001b[31m10\u001b[0m))\n1 error found\n",
      "stdout": "",
      "timestamp": 1660009971
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        var count = 0\n        var sum = 0\n        var sumOfDigits = 0\n        arr.foreach(x => {\n            sum += x\n            sumOfDigits += x.toString.reverse.foldLeft(0)(_ + _)\n        })\n        if (sumOfDigits > 0) count += sumOfDigits / 10\n        count += arr.length\n        count += arr.count(x => x < 0)\n        val nums = arr.filter(x => x.toString.reverse.foldLeft(0)(_ + _) <= 9 && x.toString.reverse.foldLeft(0)(_ + _) >= 0)\n        count += nums.count(x => x.toString.reverse.foldLeft(0)(_ + _) > 9)\n        count += arr.count(x => x > 9)\n        count += arr.count(x => x.toString.reverse.foldLeft(0)(_ + _) < 9)\n        count += arr.count(x => x.toString.reverse.foldLeft(0)(_ + _) >= 9)\n        count += arr.count(x => x.toString.reverse.foldLeft(0)(_ + _) <= 9)\n        count += arr.count(x => x.toString.reverse.foldLeft(0)(_ + _) < 9)\n        count += arr.count(x => x.toString.reverse.foldLeft(0)(_ + _) <= 9)\n        count += arr.count(x => x.toString.reverse.foldLeft(0)(_ + _) >= 9)\n        count += arr.count(x => x.toString.reverse.foldLeft(0)(_ + _) <= 9)\n        count += arr.count(x => x.toString.reverse.foldLeft(0)(_ + _) >= 9)\n        count += arr.count(x => x.toString.reverse.foldLeft(0)(_ + _) <= 9)\n        count += arr.count(x => x.toString.reverse.foldLeft(0)(_ + _) >= 9)\n        count += arr.count(x => x.toString.reverse.foldLeft(0)(_ + _) <= 9)\n        count += arr.count(x => x.toString.reverse.foldLeft(0)(_ + _) >= 9)\n        count += arr.count(x => x.toString.reverse.foldLeft(0)(_ + _) <= 9)\n        count += arr.count(x => x.toString.reverse.foldLeft(0)(_ + _) >= 9)\n        count += arr.count(x => x.toString.reverse.foldLeft(0)(_ + _) <= 9)\n        count += arr.count(x => x.toString.reverse.foldLe\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpv8180wrz.scala:44:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m44 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    ')' expected, but '}' found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpv8180wrz.scala:19:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m            sum += x\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value += is not a member of Int - did you mean Int.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpv8180wrz.scala:43:14 ------------------------\u001b[0m\u001b[0m\n\u001b[31m43 |\u001b[0m        count += arr.count(\u001b[36mx\u001b[0m => x.toString.reverse.foldLe\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        value += is not a member of Int - did you mean Int.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpv8180wrz.scala:43:51 ------------------------\u001b[0m\u001b[0m\n\u001b[31m43 |\u001b[0m        count += arr.count(\u001b[36mx\u001b[0m => x.toString.reverse.foldLe\n\u001b[31m\u001b[31m   |\u001b[0m                                ^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                value foldLe is not a member of String\n4 errors found\n",
      "stdout": "",
      "timestamp": 1660009980
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        val ns = arr.groupBy(x => Math.abs(x).toInt).values\n        ns.reduce{(x, y) => x + y.toLong}\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp8sc5ti49.scala:16:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        ns.reduce{(\u001b[36mx\u001b[0m, \u001b[36my\u001b[0m) => x + y.toLong}\n\u001b[31m\u001b[31m   |\u001b[0m                            ^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue + is not a member of List[Long], but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might make progress towards fixing the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.Fractional.Implicits.infixFractionalOps\n\u001b[31m   |\u001b[0m  import math.Integral.Implicits.infixIntegralOps\n\u001b[31m   |\u001b[0m  import math.Numeric.Implicits.infixNumericOps\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp8sc5ti49.scala:16:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        ns.reduce{(\u001b[36mx\u001b[0m, \u001b[36my\u001b[0m) => x + y.toLong}\n\u001b[31m\u001b[31m   |\u001b[0m                                ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue toLong is not a member of List[Long], but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might make progress towards fixing the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.Fractional.Implicits.infixFractionalOps\n\u001b[31m   |\u001b[0m  import math.Integral.Implicits.infixIntegralOps\n\u001b[31m   |\u001b[0m  import math.Numeric.Implicits.infixNumericOps\n\u001b[31m   |\u001b[0m\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660009979
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        val counter = scala.collection.mutable.Map[Long, Long]()\n        for (i <- arr.indices) {\n            val firstDigit = arr(i).toInt\n            val secondDigit = arr(i+1).toInt\n            val thirdDigit = arr(i+2).toInt\n            val fourthDigit = arr(i+3).toInt\n            val fifthDigit = arr(i+4).toInt\n            val sixthDigit = arr(i+5).toInt\n            val seventhDigit = arr(i+6).toInt\n            val eighthDigit = arr(i+7).toInt\n            val ninthDigit = arr(i+8).toInt\n            val tenthDigit = arr(i+9).toInt\n            if (firstDigit > 0 && firstDigit < 10 && secondDigit > 0 && secondDigit < 10 && thirdDigit > 0 && thirdDigit < 10 && fourthDigit > 0 && fourthDigit < 10 && fifthDigit > 0 && fifthDigit < 10 && sixthDigit > 0 && sixthDigit < 10 && seventhDigit > 0 && seventhDigit < 10 && eighthDigit > 0 && eighthDigit < 10 && ninthDigit > 0 && ninthDigit < 10 && tenthDigit > 0 && tenthDigit < 10) {\n                val sum = firstDigit * 10 + secondDigit * 10 + thirdDigit * 10 + fourthDigit * 10 + fifthDigit * 10 + sixthDigit * 10 + seventhDigit * 10 + eighthDigit * 10 + ninthDigit * 10 + tenthDigit\n                counter.put(sum, 0)\n                counter.getOrElseUpdate(sum, 1)._1\n            }\n        }\n        counter.size + 1\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp1lpoapnq.scala:30:48 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m                counter.getOrElseUpdate(sum, \u001b[31m1\u001b[0m)._1\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                value _1 is not a member of Long\n1 error found\n",
      "stdout": "",
      "timestamp": 1660009978
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        var cnt = 0\n        var num = 0\n        for (x <- arr) {\n            num = (x.toInt)*10\n            if (num > 0){\n                cnt += num\n            }\n        }\n        cnt\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpwxm1hqxe.scala:28)\n\tat Problem.main(tmpwxm1hqxe.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009982
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        // Initialize countNums\n        var count = 0;\n        // Initialize a mutable list to hold numbers with positive sums\n        var arr2 = arr.filter(_ > 0);\n        for (n <- arr2) count += n.abs\n        // Return the count of numbers with positive sums\n        count\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp8fw0rbj6.scala:19:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mfor\u001b[0m (n <- arr2) count += n.abs\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  value += is not a member of Int - did you mean Int.!=?\n1 error found\n",
      "stdout": "",
      "timestamp": 1660009982
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        var count = 0\n        for (x <- arr) {\n            count += count_nums(x).toLong\n        }\n        count\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpfrjp1qd0.scala:17:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m            count += count_nums(x).toLong\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value += is not a member of Int - did you mean Int.!=?\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpfrjp1qd0.scala:17:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m            count += count_nums(x).toLong\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: count_nums\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660009984
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        arr.filter(x => x > 0).length\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpuuidx8cx.scala:23)\n\tat Problem.main(tmpuuidx8cx.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009989
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        if (arr.isEmpty || arr.head < 0)\n            return 0\n        var sum : Long = 0\n        for (i<-arr.indices) {\n            val n = arr(i)\n            var sum : Long = 0\n            while (n > 0) {\n                sum = sum + n % 10\n                n = n / 10\n            }\n            if (sum > 0) {\n                sum = 1\n            }\n            sum = sum * 10 + sum\n        }\n        return sum\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmpc7epkzl3.scala:23:18 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m                n = n / \u001b[31m10\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Reassignment to val n\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660009982
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        var result : Long = 0\n        var currentSum : Long = 0\n        for (i <- arr) {\n            currentSum += i\n            if (currentSum > 0) {\n                result+=1\n            }\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp9qmmafef.scala:28)\n\tat Problem.main(tmp9qmmafef.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009992
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        val zeros = arr.count(i => i <= 0)\n        val numbers = arr.count(_ > 0)\n        val firstPositive = arr.count(_ > 0 && _ > 0)\n        (numbers - firstPositive) / arr.size.toLong\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E086] Syntax Error: /tmp/tmpiv63elzn.scala:17:38 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mfirstPositive\u001b[0m = arr.count(_ > \u001b[31m0\u001b[0m && _ > \u001b[31m0\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Wrong number of parameters, expected: 1\n1 error found\n",
      "stdout": "",
      "timestamp": 1660009983
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        val n = arr.length\n        var nums : List[Long] = null\n        var j = 0\n        var sum : Long = 0\n        while (j < n) {\n            sum += arr(j)\n            j += 1\n        }\n        nums = arr.filter(_ > 0).filter(_ % 10 != 0)\n        nums.filter(_ > 0).filter(_ % 10 == 0).foldLeft((0l)) { (acc, val) =>\n            val d = math.signum(val)\n            val i = acc._2 + (d * 10)\n            val j = (d * 10) - i\n            (i, j) match {\n                case (null, 0) -> acc\n                case (null, 1) => acc\n                case (i, 0) -> acc\n                case (i, 1) -> if (i < n) acc + 1 else acc\n            }\n        }._2\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmp0qve175r.scala:24:70 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        nums.filter(_ > \u001b[31m0\u001b[0m).filter(_ % \u001b[31m10\u001b[0m == \u001b[31m0\u001b[0m).foldLeft((\u001b[31m0l\u001b[0m)) { (\u001b[36macc\u001b[0m, \u001b[33mval\u001b[0m) =>\n\u001b[31m\u001b[31m   |\u001b[0m                                                                      ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                       expression expected but \u001b[31mval\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmp0qve175r.scala:25:32 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36md\u001b[0m = math.signum(\u001b[33mval\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                expression expected but \u001b[31mval\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp0qve175r.scala:30:16 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m                \u001b[33mcase\u001b[0m (\u001b[31mnull\u001b[0m, \u001b[31m1\u001b[0m) => acc\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                '=>' expected, but 'case' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp0qve175r.scala:32:16 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m                \u001b[33mcase\u001b[0m (i, \u001b[31m1\u001b[0m) -> \u001b[33mif\u001b[0m (i < n) acc + \u001b[31m1\u001b[0m \u001b[33melse\u001b[0m acc\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                '=>' expected, but 'case' found\n\u001b[31m\u001b[31m-- [E134] Type Error: /tmp/tmp0qve175r.scala:25:25 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36md\u001b[0m = math.signum(\u001b[33mval\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mNone of the overloaded alternatives of \u001b[33mmethod\u001b[0m \u001b[35msignum\u001b[0m in \u001b[33mpackage\u001b[0m \u001b[35mscala.math\u001b[0m with types\n\u001b[31m   |\u001b[0m (x: Double): Double\n\u001b[31m   |\u001b[0m (x: Float): Float\n\u001b[31m   |\u001b[0m (x: Long): Long\n\u001b[31m   |\u001b[0m (x: Int): Int\n\u001b[31m   |\u001b[0mmatch argume",
      "stdout": "",
      "timestamp": 1660009990
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        // TODO: write your code here\n        return arr.filter(x => x % 2 != 0) match {\n            case x :: y => x + y\n            case _ => 0\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E134] Type Error: /tmp/tmp3ivg1ne_.scala:17:29 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m            \u001b[33mcase\u001b[0m x :: y => x + y\n\u001b[31m\u001b[31m   |\u001b[0m                           ^^^\u001b[0m\n\u001b[31m   |\u001b[0mNone of the overloaded alternatives of \u001b[33mmethod\u001b[0m \u001b[35m+\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mLong\u001b[0m with types\n\u001b[31m   |\u001b[0m (x: Double): Double\n\u001b[31m   |\u001b[0m (x: Float): Float\n\u001b[31m   |\u001b[0m (x: Long): Long\n\u001b[31m   |\u001b[0m (x: Int): Long\n\u001b[31m   |\u001b[0m (x: Char): Long\n\u001b[31m   |\u001b[0m (x: Short): Long\n\u001b[31m   |\u001b[0m (x: Byte): Long\n\u001b[31m   |\u001b[0m (x: String): String\n\u001b[31m   |\u001b[0mmatch arguments ((y : List[Long]))\n1 error found\n",
      "stdout": "",
      "timestamp": 1660009987
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        if (arr.isEmpty) 0\n        else {\n            var result = arr.foldLeft(0l)( (acc, e) => acc + math.abs(e) )\n            if (result < 0) result * -1\n            else result\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpdbpmlhox.scala:24)\n\tat Problem.main(tmpdbpmlhox.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009995
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        val count = mutable.HashMap.empty[Long, Long]\n        var sum = 0l\n        for (i <- arr) {\n            sum += i\n            count.get(sum) match {\n                case None =>\n                    count(sum) = i\n                case Some(count) => count.get += 1\n            }\n        }\n        count.filter(_._2 > 0).size\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpyxyae5tt.scala:15:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mcount\u001b[0m = mutable.HashMap.empty[\u001b[35mLong\u001b[0m, \u001b[35mLong\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660009987
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        var count = 0\n        arr.foreach(x => {\n            val sum = x.toString.toLong.sum\n            val sign = if (x.toString.toLong.signum <= 0) 1 else -1\n            if (sum > 0) count += sign * sum\n        })\n        count\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpt0gebno0.scala:17:40 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36msum\u001b[0m = x.toString.toLong.sum\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      value sum is not a member of Long\n1 error found\n",
      "stdout": "",
      "timestamp": 1660009991
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        var sum = 0\n        for (i <- arr) {\n            if (i < 0)\n                sum += i.toInt - Math.max(0l, i.toInt)\n            else\n                sum += i.toInt\n        }\n        sum\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp9jmlemag.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m                sum += i.toInt - Math.max(\u001b[31m0l\u001b[0m, i.toInt)\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                value += is not a member of Int - did you mean Int.!=?\n1 error found\n",
      "stdout": "",
      "timestamp": 1660009992
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        var nums = arr.filter(x => x >= 0).map(x => x - x.toInt).distinct\n        nums.foldLeft(0)((acc, x) => acc * x).toLong\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpr0ugw5nu.scala:16:37 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        nums.foldLeft(\u001b[31m0\u001b[0m)((\u001b[36macc\u001b[0m, \u001b[36mx\u001b[0m) => acc * x).toLong\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                     Found:    Long\n\u001b[31m   |\u001b[0m                                     Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660009995
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        if(arr.isEmpty) 0\n        else if(arr.head._2 >= 0) arr.head._1 + countNums(arr.tail)\n        else -countNums(arr.tail)\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpz9020asf.scala:16:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m(arr.head._2 >= \u001b[31m0\u001b[0m) arr.head._1 + countNums(arr.tail)\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                value _2 is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpz9020asf.scala:16:43 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m(arr.head._2 >= \u001b[31m0\u001b[0m) arr.head._1 + countNums(arr.tail)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                  value _1 is not a member of Long\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660009995
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        if (arr.isEmpty) 0\n        else arr.head + countNums(arr.tail)\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmphb9zxofs.scala:20)\n\tat Problem.main(tmphb9zxofs.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009996
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        val n = arr.length\n        var count = 0\n        for ((sum, val) <- arr.zipWithIndex collect {case (s, i) => if (s > 0) (s, i) }) {\n            val rem = sum % 10\n            if (rem == 0) count += 1\n        }\n        count\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpw6xqsoda.scala:17:19 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        \u001b[33mfor\u001b[0m ((sum, \u001b[33mval\u001b[0m) <- arr.zipWithIndex collect {\u001b[33mcase\u001b[0m (s, i) => \u001b[33mif\u001b[0m (s > \u001b[31m0\u001b[0m) (s, i) }) {\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpw6xqsoda.scala:17:24 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        \u001b[33mfor\u001b[0m ((sum, \u001b[33mval\u001b[0m) <- arr.zipWithIndex collect {\u001b[33mcase\u001b[0m (s, i) => \u001b[33mif\u001b[0m (s > \u001b[31m0\u001b[0m) (s, i) }) {\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^\u001b[0m\n\u001b[31m   |\u001b[0m                        ')' expected, but '<-' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpw6xqsoda.scala:17:89 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        \u001b[33mfor\u001b[0m ((sum, \u001b[33mval\u001b[0m) <- arr.zipWithIndex collect {\u001b[33mcase\u001b[0m (s, i) => \u001b[33mif\u001b[0m (s > \u001b[31m0\u001b[0m) (s, i) }) {\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                                            '<-' expected, but '{' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpw6xqsoda.scala:22:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '<-' expected, but '}' found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpw6xqsoda.scala:20:9 -------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        }\n\u001b[31m\u001b[31m   |\u001b[0m         ^\u001b[0m\n\u001b[31m   |\u001b[0mvalue withFilter is not a member of Null, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import Option.option2Iterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip2.lazyZip2ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip3.lazyZip3ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip4.lazyZip4ToIterable\n\u001b[31m   |\u001b[0m  import collection.",
      "stdout": "",
      "timestamp": 1660009998
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        var sum = 0\n        var last = 0\n        var count = 0\n        for (i <- arr.length) {\n            val temp = arr(i)\n            sum += temp\n            if (temp > 0) {\n                if (sum > 0) {\n                    last = temp\n                } else {\n                    if (temp < 0)\n                        count -= 1\n                }\n            }\n        }\n        if (count == 0)\n            count\n        else\n            countNums(arr.drop(count).toList).filter(_ > 0).last\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpjtyy_6di.scala:18:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- arr.length) {\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  value foreach is not a member of Int\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpjtyy_6di.scala:33:46 ------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m            countNums(arr.drop(count).toList).filter(_ > \u001b[31m0\u001b[0m).last\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value filter is not a member of Long\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660009998
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        arr.foreach { x =>\n            var count = 0\n            var s = Math.abs(x)\n            while (s != 0) {\n                count += 1\n                if (s % 10 > 0) {\n                    s = s / 10\n                } else {\n                    s = s * 10\n                }\n            }\n            if (count > 0) {\n                arr.remove(x)\n            }\n        }\n        arr.length\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpyg5eclan.scala:27:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m                arr.remove(x)\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m   value remove is not a member of List[Long] - did you mean arr.reduce?\n1 error found\n",
      "stdout": "",
      "timestamp": 1660009997
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        var count : Long = 0\n        for (i <- arr) count += i.asInstanceOf[Long]\n        count + arr.filter(_.asInstanceOf[Long] < 0).headOption.map(_.asInstanceOf[Long]).getOrElse(0)\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E134] Type Error: /tmp/tmp4s9dpt8w.scala:17:14 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        count + arr.filter(_.asInstanceOf[\u001b[35mLong\u001b[0m] < \u001b[31m0\u001b[0m).headOption.map(_.asInstanceOf[\u001b[35mLong\u001b[0m]).getOrElse(\u001b[31m0\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mNone of the overloaded alternatives of \u001b[33mmethod\u001b[0m \u001b[35m+\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mLong\u001b[0m with types\n\u001b[31m   |\u001b[0m (x: Double): Double\n\u001b[31m   |\u001b[0m (x: Float): Float\n\u001b[31m   |\u001b[0m (x: Long): Long\n\u001b[31m   |\u001b[0m (x: Int): Long\n\u001b[31m   |\u001b[0m (x: Char): Long\n\u001b[31m   |\u001b[0m (x: Short): Long\n\u001b[31m   |\u001b[0m (x: Byte): Long\n\u001b[31m   |\u001b[0m (x: String): String\n\u001b[31m   |\u001b[0mmatch arguments (AnyVal)\n1 error found\n",
      "stdout": "",
      "timestamp": 1660009994
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        val digits = arr.flatMap(_.toString.toLong)\n        val zero = digits.sum - digits.filter(_ < 0).sum\n        if (zero > 0) zero else digits.foldLeft(0)((sum, digit) => sum + digit)\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp6m5iycpd.scala:15:44 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mdigits\u001b[0m = arr.flatMap(_.toString.toLong)\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Found:    Long\n\u001b[31m   |\u001b[0m                                 Required: IterableOnce[Any]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- Error: /tmp/tmp6m5iycpd.scala:16:29 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mzero\u001b[0m = digits.sum - digits.filter(_ < \u001b[31m0\u001b[0m).sum\n\u001b[31m\u001b[31m   |\u001b[0m                             ^\u001b[0m\n\u001b[31m   |\u001b[0mambiguous given instances: both \u001b[33mobject\u001b[0m \u001b[35mFloatIsFractional\u001b[0m in \u001b[33mobject\u001b[0m \u001b[35mNumeric\u001b[0m and \u001b[33mobject\u001b[0m \u001b[35mBigIntIsIntegral\u001b[0m in \u001b[33mobject\u001b[0m \u001b[35mNumeric\u001b[0m match type Numeric[B] of parameter num of \u001b[33mmethod\u001b[0m \u001b[35msum\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mIterableOnceOps\u001b[0m\n\u001b[31m\u001b[31m-- [E051] Reference Error: /tmp/tmp6m5iycpd.scala:17:71 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        \u001b[33mif\u001b[0m (zero > \u001b[31m0\u001b[0m) zero \u001b[33melse\u001b[0m digits.foldLeft(\u001b[31m0\u001b[0m)((\u001b[36msum\u001b[0m, \u001b[36mdigit\u001b[0m) => sum + digit)\n\u001b[31m\u001b[31m   |\u001b[0m                                                                   ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mAmbiguous overload. The overloaded alternatives of \u001b[33mmethod\u001b[0m \u001b[35m+\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mInt\u001b[0m with types\n\u001b[31m   |\u001b[0m (x: Int): Int\n\u001b[31m   |\u001b[0m (x: Char): Int\n\u001b[31m   |\u001b[0m (x: Short): Int\n\u001b[31m   |\u001b[0m (x: Byte): Int\n\u001b[31m   |\u001b[0mall match arguments ((digit : Nothing))\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660009998
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        var count = new collection.mutable.HashMap[Long, Long]();\n        for(number <- arr) {\n            val digits = math.abs(number);\n            var newCount = count.get(number);\n            if (newCount == null)\n                newCount = digits;\n            else\n                newCount += digits;\n            count.put(number, newCount);\n        }\n        val total = count.values.sum;\n        return total;\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpn7518qvw.scala:20:27 --------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m                newCount = digits;\n\u001b[31m\u001b[31m   |\u001b[0m                           ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                           Found:    (digits : Long)\n\u001b[31m   |\u001b[0m                           Required: Option[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpn7518qvw.scala:22:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m                newCount += digits;\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue += is not a member of Option[Long] - did you mean Option[Long].!=?\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpn7518qvw.scala:23:30 --------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m            count.put(number, newCount);\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              Found:    (newCount : Option[Long])\n\u001b[31m   |\u001b[0m                              Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660010002
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        // Iterate through each element in the list until you find a negative\n        // number and stop when you have found all the positive numbers.\n        var pos = arr.head - 1\n        var neg = 0\n        for(n <- arr) {\n            if (n < 0) pos = n\n            else {\n                neg += 1\n                break\n            }\n        }\n        // Now that you have all the positive numbers, count the number of numbers\n        // whose sum of the digits is > 0 (i.e. the first positive number is the\n        // answer)\n        var ans = 1\n        for(n <- arr) {\n            if (n < 0) break\n            ans += 1\n            val d = n.toString.split('')\n            val sum = d.sum.toLong\n            if (sum > 0) continue\n            val sumDigits = sum / 10 % 10\n            if (sumDigits < 0) sumDigits *= -1\n            if (sumDigits == 0) continue\n            if (sumDigits < 3) sumDigits *= -1\n            ans += (sumDigits.toLong)\n        }\n        ans + (arr.length - neg)\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmpn_h0ewf8.scala:33:37 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36md\u001b[0m = n.toString.split('')\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                                     empty character literal\n\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpn_h0ewf8.scala:34:20 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36msum\u001b[0m = d.sum.toLong\n\u001b[31m\u001b[31m   |\u001b[0m                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                    expression expected but \u001b[31m=\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpn_h0ewf8.scala:23:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m                break\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: break\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpn_h0ewf8.scala:31:23 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m            \u001b[33mif\u001b[0m (n < \u001b[31m0\u001b[0m) break\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Not found: break\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpn_h0ewf8.scala:34:12 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36msum\u001b[0m = d.sum.toLong\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^\u001b[0m\n\u001b[31m   |\u001b[0m            Not found: 'val\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpn_h0ewf8.scala:35:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m            \u001b[33mif\u001b[0m (sum > \u001b[31m0\u001b[0m) continue\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: sum\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /",
      "stdout": "",
      "timestamp": 1660009996
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        val nums   = arr.filter(x => x != 0).map(x => math.abs(x)).sum\n        val sign   = arr.takeWhile(_ < 0).last\n        val digits = math.abs(sign / 10)\n        val rest  = arr.drop(sign)\n        nums * digits\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpbpig0ipi.scala:18:29 --------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mrest\u001b[0m  = arr.drop(sign)\n\u001b[31m\u001b[31m   |\u001b[0m                             ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                             Found:    (sign : Long)\n\u001b[31m   |\u001b[0m                             Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010002
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        arr match {\n            case Nil => 0\n            case x :: xs => val result = countNums(xs)\n                           if (x >= 0) (x + result) else if (x < 0) (-x + result) else result\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpcu933fhh.scala:23)\n\tat Problem.main(tmpcu933fhh.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660010006
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        var count = 0\n        for(i <- arr)\n            count += count_nums(i.toList)\n        count\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpih58vbva.scala:17:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m            count += count_nums(i.toList)\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value += is not a member of Int - did you mean Int.!=?\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpih58vbva.scala:17:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m            count += count_nums(i.toList)\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: count_nums\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpih58vbva.scala:17:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m            count += count_nums(i.toList)\n\u001b[31m\u001b[31m   |\u001b[0m                                ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value toList is not a member of Long - did you mean i.toInt?\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660010004
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        // TODO: Write your solution here\n        val list = arr.toList\n        val sum = (list.foldLeft(1l){_ + _ })\n        val digits = list.map(_.toString.toLong).sum\n        if(sum > digits) {\n            sum - digits\n        } else {\n            0\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp_bq5hnmj.scala:26)\n\tat Problem.main(tmp_bq5hnmj.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660010007
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        def countNums_helper(acc: Long, i : Long, acc2 : List[Long]) : Long = {\n            if (i >= 0) {\n                acc += i\n                countNums_helper(acc, i-1, acc2)\n            } else if (i < 0) {\n                acc2 += i\n                acc += i\n                countNums_helper(acc, i, acc2)\n            }\n        }\n        countNums_helper(0l, arr.head.asInstanceOf[Long], Nil)\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpg5bpkhyl.scala:17:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m                acc += i\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                value += is not a member of Long - did you mean acc.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpg5bpkhyl.scala:20:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m                acc2 += i\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m          value += is not a member of List[Long] - did you mean acc2.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpg5bpkhyl.scala:21:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m                acc += i\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                value += is not a member of Long - did you mean acc.!=?\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660010009
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        // Initialize two counters, i and j\n        var i = 0\n        var j = 0\n        var sum = 0\n\n        // Find the sum of the digits of the given number\n        for( x <- arr ) {\n            sum += x\n            if( sum > 10 ) {\n                sum += x-10\n                i += 1\n                j = 0\n            } else if( sum < -10 ) {\n                sum -= x\n                i += 1\n                j = 0\n            } else {\n                j += 1\n            }\n        }\n\n        // Return the count of elements with sum greater than 0\n        return j\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpj8036_d0.scala:22:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            sum += x\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value += is not a member of Int - did you mean Int.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpj8036_d0.scala:24:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m                sum += x-\u001b[31m10\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                value += is not a member of Int - did you mean Int.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpj8036_d0.scala:28:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m                sum -= x\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                value -= is not a member of Int - did you mean Int.!=?\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660010009
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        arr.foldLeft(0l) { (sum, el) =>\n            val sum = sum + el % 10;\n            val sign = el % 10 < 0 ? -1 : 1;\n            sum * sign\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpxkrssu0o.scala:16:22 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36msum\u001b[0m = sum + el % \u001b[31m10\u001b[0m;\n\u001b[31m\u001b[31m   |\u001b[0m                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                      Recursive \u001b[33mvalue\u001b[0m \u001b[35msum\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpxkrssu0o.scala:17:35 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36msign\u001b[0m = el % \u001b[31m10\u001b[0m < \u001b[31m0\u001b[0m ? -\u001b[31m1\u001b[0m : \u001b[31m1\u001b[0m;\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 value ? is not a member of Int\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660010008
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        if (arr.isEmpty) 0\n        else arr.head match {\n            case 0 => arr.length\n            case x if (x > 0) => countNums(arr.tail) if (isSigned(x)) else (countNums(arr.tail) * -1)\n            case x if (x < 0) => countNums(arr.tail) * (isSigned(x) ? -1 : 1l)\n            case x => countNums(arr.tail) + (isSigned(x) ? x.toLong % 10 : 0l)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmp31s7k69w.scala:18:53 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m            \u001b[33mcase\u001b[0m x \u001b[33mif\u001b[0m (x > \u001b[31m0\u001b[0m) => countNums(arr.tail) \u001b[33mif\u001b[0m (isSigned(x)) \u001b[33melse\u001b[0m (countNums(arr.tail) * -\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                                     ^^\u001b[0m\n\u001b[31m   |\u001b[0m                                end of statement expected but 'if' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp31s7k69w.scala:19:56 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m            \u001b[33mcase\u001b[0m x \u001b[33mif\u001b[0m (x < \u001b[31m0\u001b[0m) => countNums(arr.tail) * (isSigned(x) ? -\u001b[31m1\u001b[0m : \u001b[31m1l\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                                        ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                                     Not found: isSigned\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp31s7k69w.scala:20:45 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m            \u001b[33mcase\u001b[0m x => countNums(arr.tail) + (isSigned(x) ? x.toLong % \u001b[31m10\u001b[0m : \u001b[31m0l\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                             ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                             Not found: isSigned\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660010004
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        // initialize counts\n        val counts = (0 until arr.length).map(i => 0 until arr.length).map(j => 0)\n        var cnt = 0\n        for (i <- 0 until arr.length) {\n            val v = arr(i).toInt\n            val l = v.floor.toInt\n            val h = v.ceil.toInt\n            if (l < 0) counts(l-1) += 1\n            if (h < 0) counts(h-1) += 1\n        }\n        cnt\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpbe0us6yz.scala:20:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36ml\u001b[0m = v.floor.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value floor is not a member of Int.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          floatWrapper(v)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpbe0us6yz.scala:21:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mh\u001b[0m = v.ceil.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value ceil is not a member of Int.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          floatWrapper(v)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpbe0us6yz.scala:22:35 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            \u001b[33mif\u001b[0m (l < \u001b[31m0\u001b[0m) counts(l-\u001b[31m1\u001b[0m) += \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  value += is not a member of Int - did you mean Int.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpbe0us6yz.scala:23:35 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m            \u001b[33mif\u001b[0m (h < \u001b[31m0\u001b[0m) counts(h-\u001b[31m1\u001b[0m) += \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  value += is not a member of Int - did you mean Int.!=?\n4 errors found\n",
      "stdout": "",
      "timestamp": 1660010016
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        arr.foldLeft((0l,0l)) {\n            (sum, elem) => elem.toString.toLong.signum match {\n                case -1 => (sum._1 + 1, sum._2)\n                case 0 => (sum._1, sum._2 + 1)\n                case 1 => (sum._1 + 1, sum._2)\n            }\n        }._1\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpbqp1wry8.scala:25)\n\tat Problem.main(tmpbqp1wry8.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660010016
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n      val zero = new Array[Int](arr.size)\n      zero.foreach(x => arr(x) >= 0)\n      arr.foldLeft((0l, zero)) {\n        case ((a, zero), x :: tail) => (a + x, zero) //(a,x) + zero\n      }._1 //the final result\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E134] Type Error: /tmp/tmpi9m8rika.scala:18:42 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mcase\u001b[0m ((a, zero), x :: tail) => (a + x, zero) \u001b[34m//(a,x) + zero\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                                        ^^^\u001b[0m\n\u001b[31m   |\u001b[0mNone of the overloaded alternatives of \u001b[33mmethod\u001b[0m \u001b[35m+\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mLong\u001b[0m with types\n\u001b[31m   |\u001b[0m (x: Double): Double\n\u001b[31m   |\u001b[0m (x: Float): Float\n\u001b[31m   |\u001b[0m (x: Long): Long\n\u001b[31m   |\u001b[0m (x: Int): Long\n\u001b[31m   |\u001b[0m (x: Char): Long\n\u001b[31m   |\u001b[0m (x: Short): Long\n\u001b[31m   |\u001b[0m (x: Byte): Long\n\u001b[31m   |\u001b[0m (x: String): String\n\u001b[31m   |\u001b[0mmatch arguments ((x : Any))\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010008
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        val summedArr = arr.foldLeft(List[Long]())((acc, element) => {\n            if(element < 0) {\n                acc.flatMap(x => List[Long](x - element.toLong, element + x.toLong, x))\n            } else {\n                acc ++ List(element + x.toLong, x)\n            }\n        })\n        summedArr.foldRight(0) {\n            case (acc, element) => acc if element % 10 == 0 else acc + element % 10\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmpejnp25z3.scala:23:39 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m            \u001b[33mcase\u001b[0m (acc, element) => acc \u001b[33mif\u001b[0m element % \u001b[31m10\u001b[0m == \u001b[31m0\u001b[0m \u001b[33melse\u001b[0m acc + element % \u001b[31m10\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                                       ^^\u001b[0m\n\u001b[31m   |\u001b[0m                                end of statement expected but 'if' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpejnp25z3.scala:19:38 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m                acc ++ List(element + x.toLong, x)\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                                      Not found: x\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpejnp25z3.scala:19:48 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m                acc ++ List(element + x.toLong, x)\n\u001b[31m\u001b[31m   |\u001b[0m                                                ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                Not found: x\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpejnp25z3.scala:23:35 --------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m            \u001b[33mcase\u001b[0m (acc, element) => acc \u001b[33mif\u001b[0m element % \u001b[31m10\u001b[0m == \u001b[31m0\u001b[0m \u001b[33melse\u001b[0m acc + element % \u001b[31m10\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                                   ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                   Found:    (acc : Long)\n\u001b[31m   |\u001b[0m                                   Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "stdout": "",
      "timestamp": 1660010014
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        def digitSum(x: Long, digits: List[Long]) : Long = {\n            digits(x) ++ digits(x + 1)\n        }\n        var count = 0\n        val digitSums = arr.map(digitSum)\n        for (sum <- digitSums) {\n            if (sum > 0) {\n                count += 1\n            }\n        }\n        count\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmph2lkg2zj.scala:16:19 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            digits(x) ++ digits(x + \u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                   Found:    (x : Long)\n\u001b[31m   |\u001b[0m                   Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmph2lkg2zj.scala:16:32 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            digits(x) ++ digits(x + \u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                Found:    Long\n\u001b[31m   |\u001b[0m                                Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmph2lkg2zj.scala:19:32 --------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mdigitSums\u001b[0m = arr.map(digitSum)\n\u001b[31m\u001b[31m   |\u001b[0m                                ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                Found:    \u001b[1m\u001b[31m(\u001b[0mLong\u001b[1m\u001b[31m,\u001b[0m \u001b[1m\u001b[31mList\u001b[0m\u001b[1m\u001b[31m[\u001b[0m\u001b[1m\u001b[31mLong\u001b[0m\u001b[1m\u001b[31m]\u001b[0m\u001b[1m\u001b[31m)\u001b[0m\u001b[1m\u001b[31m \u001b[0m=> Long\n\u001b[31m   |\u001b[0m                                Required: Long => Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660010018
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        arr.foldLeft(0l) { (res, num) => res + num / 10 }\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmphwd0uw5b.scala:20)\n\tat Problem.main(tmphwd0uw5b.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660010018
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        arr.foldLeft(0L){(sum, v) => sum + math.pow(10, math.abs(v.toInt))}\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp487gkig8.scala:15:37 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        arr.foldLeft(\u001b[31m0L\u001b[0m){(\u001b[36msum\u001b[0m, \u001b[36mv\u001b[0m) => sum + math.pow(\u001b[31m10\u001b[0m, math.abs(v.toInt))}\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                     Found:    Double\n\u001b[31m   |\u001b[0m                                     Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010017
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        if (arr.isEmpty)\n            return 0\n        val nums = arr.toSet\n        var sum = 0\n        while(sum < 10)\n            sum += nums.foldLeft(0){\n                case (acc, x) => acc + (x.signum() * ((10 - sum) * x.toLong))\n            }\n        return sum\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp8ia6qdr2.scala:20:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m            sum += nums.foldLeft(\u001b[31m0\u001b[0m){\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value += is not a member of Int - did you mean Int.!=?\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp8ia6qdr2.scala:21:42 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m                \u001b[33mcase\u001b[0m (acc, x) => acc + (x.signum() * ((\u001b[31m10\u001b[0m - sum) * x.toLong))\n\u001b[31m\u001b[31m   |\u001b[0m                                        ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        \u001b[33mmethod\u001b[0m \u001b[35msignum\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mScalaNumberProxy\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660010016
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        def countDigits(arr : List[Long], sum : Long) : Long = {\n            val n = arr.length\n            if (n == 0) sum\n            else {\n                val lSum = arr.foldLeft(0)( (sum, element) => sum + element%10 )\n                if (lSum < 0) sum + Math.abs(lSum) * Math.signum(arr(n - 1))\n                else countDigits(arr.dropRight(1), lSum)\n            }\n        }\n        countDigits(arr, 0l)\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpn8569s33.scala:19:62 --------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m                \u001b[33mval\u001b[0m \u001b[36mlSum\u001b[0m = arr.foldLeft(\u001b[31m0\u001b[0m)( (\u001b[36msum\u001b[0m, \u001b[36melement\u001b[0m) => sum + element%\u001b[31m10\u001b[0m )\n\u001b[31m\u001b[31m   |\u001b[0m                                                              ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                                          Found:    Long\n\u001b[31m   |\u001b[0m                                                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpn8569s33.scala:20:30 --------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m                \u001b[33mif\u001b[0m (lSum < \u001b[31m0\u001b[0m) sum + Math.abs(lSum) * Math.signum(arr(n - \u001b[31m1\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              Found:    Float\n\u001b[31m   |\u001b[0m                              Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660010018
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        if (arr.isEmpty) return 0\n        val maxSum = arr.foldLeft(0l)( (maxSum, v) => v > 0 ? maxSum + v % 10 + (v / 10).abs : 0)\n        val digitSums = arr.map { v => (v % 10).abs + v / (10).abs }.distinct\n        digitSums.filter(_ > 0).sum * maxSum\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp8_kypmxo.scala:16:60 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxSum\u001b[0m = arr.foldLeft(\u001b[31m0l\u001b[0m)( (\u001b[36mmaxSum\u001b[0m, \u001b[36mv\u001b[0m) => v > \u001b[31m0\u001b[0m ? maxSum + v % \u001b[31m10\u001b[0m + (v / \u001b[31m10\u001b[0m).abs : \u001b[31m0\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                                          ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                          value ? is not a member of Int\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010017
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        var sum = 0\n        for (x <- arr) if (x > 0) sum+= abs(x)\n        sum\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmprjbuv4lr.scala:16:37 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mfor\u001b[0m (x <- arr) \u001b[33mif\u001b[0m (x > \u001b[31m0\u001b[0m) sum+= abs(x)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  value += is not a member of Int - did you mean Int.!=?\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010018
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        val total = 0L\n        for (i <- 0 until arr.length) {\n            total += arr(i).abs\n            if (total < 0) {\n                return total.toLong - arr(i).toLong\n            }\n        }\n        return 0\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpd1p9iekj.scala:17:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m            total += arr(i).abs\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value += is not a member of Long - did you mean total.!=?\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010020
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        val newArr: mutable.Buffer[Long] = arr.filter(i => i.isPositive)\n        if (newArr(0).isPositive) {\n            newArr.drop(1).sum\n        } else {\n            arr.sum\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpgijaegf4.scala:15:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnewArr\u001b[0m: mutable.Buffer[\u001b[35mLong\u001b[0m] = arr.filter(\u001b[36mi\u001b[0m => i.isPositive)\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpgijaegf4.scala:15:61 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnewArr\u001b[0m: mutable.Buffer[\u001b[35mLong\u001b[0m] = arr.filter(\u001b[36mi\u001b[0m => i.isPositive)\n\u001b[31m\u001b[31m   |\u001b[0m                                                           ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                value isPositive is not a member of Long\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660010019
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        var ans = 0\n        var sum = 0\n        for (i <- arr.indices) {\n            sum += arr(i)\n            if (sum > 0) {\n                ans += sum\n            }\n        }\n        ans\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpbg9v2c8l.scala:18:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m            sum += arr(i)\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value += is not a member of Int - did you mean Int.!=?\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010019
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        arr.reduceLeft(l => if(l.toString.filter(_.isDigit).isEmpty) 0 else 1) + (arr.filter(_.toString.filter(_.isDigit).nonEmpty).isEmpty)\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E086] Syntax Error: /tmp/tmpj81rgaj1.scala:15:25 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        arr.reduceLeft(\u001b[36ml\u001b[0m => \u001b[33mif\u001b[0m(l.toString.filter(_.isDigit).isEmpty) \u001b[31m0\u001b[0m \u001b[33melse\u001b[0m \u001b[31m1\u001b[0m) + (arr.filter(_.toString.filter(_.isDigit).nonEmpty).isEmpty)\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Wrong number of parameters, expected: 2\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010019
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        var count = 0\n        for( n <- arr if n > 0 ) count += sum(n/10.toInt).drop(1).map( x => (x*10+n.toInt) ).drop(1).length\n        count\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpast0stcc.scala:16:39 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mfor\u001b[0m( n <- arr \u001b[33mif\u001b[0m n > \u001b[31m0\u001b[0m ) count += sum(n/\u001b[31m10\u001b[0m.toInt).drop(\u001b[31m1\u001b[0m).map( \u001b[36mx\u001b[0m => (x*\u001b[31m10\u001b[0m+n.toInt) ).drop(\u001b[31m1\u001b[0m).length\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  value += is not a member of Int - did you mean Int.!=?\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpast0stcc.scala:16:42 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mfor\u001b[0m( n <- arr \u001b[33mif\u001b[0m n > \u001b[31m0\u001b[0m ) count += sum(n/\u001b[31m10\u001b[0m.toInt).drop(\u001b[31m1\u001b[0m).map( \u001b[36mx\u001b[0m => (x*\u001b[31m10\u001b[0m+n.toInt) ).drop(\u001b[31m1\u001b[0m).length\n\u001b[31m\u001b[31m   |\u001b[0m                                          ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                          Not found: sum\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660010023
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        val result = arr.filter(_ > 0).length\n        result + (if (arr.head < 0l) -arr.head else 0)\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.util.NoSuchElementException: head of empty list\n\tat scala.collection.immutable.Nil$.head(List.scala:662)\n\tat scala.collection.immutable.Nil$.head(List.scala:661)\n\tat Problem$.countNums(tmpj25j1ih1.scala:16)\n\tat Problem$.main(tmpj25j1ih1.scala:19)\n\tat Problem.main(tmpj25j1ih1.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660010028
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        var result = 0\n        arr.foreach { i =>\n            if ((i > 0L) && (i % 10L > 0L)) {\n                result = result + 1\n            }\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp35wnhk1z.scala:28)\n\tat Problem.main(tmp35wnhk1z.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660010028
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        arr match {\n            case Nil => 0\n            case h :: t => {\n                val d = Math.max(h.signum, t) //first signed digit\n                val sign = if (d < 0) -d else d\n                (h % 10) + sign * countNums(t.filter(_ < h))\n            }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E134] Type Error: /tmp/tmpesru6nxj.scala:18:29 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m                \u001b[33mval\u001b[0m \u001b[36md\u001b[0m = Math.max(h.signum, t) \u001b[34m//first signed digit\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mNone of the overloaded alternatives of \u001b[33mmethod\u001b[0m \u001b[35mmax\u001b[0m in \u001b[33mobject\u001b[0m \u001b[35mMath\u001b[0m with types\n\u001b[31m   |\u001b[0m (x$0: Double, x$1: Double): Double\n\u001b[31m   |\u001b[0m (x$0: Float, x$1: Float): Float\n\u001b[31m   |\u001b[0m (x$0: Long, x$1: Long): Long\n\u001b[31m   |\u001b[0m (x$0: Int, x$1: Int): Int\n\u001b[31m   |\u001b[0mmatch arguments ((scala.runtime.RichLong#signum : => Int), (t : List[Long]))\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010023
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        arr.foldRight(0)(_ + _.sumDigits > 0) ? arr.foldRight(0)(_ + _.sumDigits > 0) ? arr.foldRight(0)(_ + _.sumDigits > 0) ? arr.foldRight(0)(_ + _.sumDigits > 0) ? arr.foldRight(0)(_ + _.sumDigits > 0) ? arr.foldRight(0)(_ + _.sumDigits > 0) ? arr.foldRight(0)(_ + _.sumDigits > 0) ? arr.foldRight(0)(_ + _.sumDigits > 0) ? arr.foldRight(0)(_ + _.sumDigits > 0) ? arr.foldRight(0)(_ + _.sumDigits > 0) ? arr.foldRight(0)(_ + _.sumDigits > 0) ? arr.foldRight(0)(_ + _.sumDigits > 0) ? arr.foldRight(0)(_ + _.sumDigits > 0) ? arr.foldRight(0)(_ + _.sumDigits > 0) ? arr.foldRight(0)(_ + _.sumDigits > 0) ? arr.foldRight(0)(_ + _.sumDigits > 0) ? arr.foldRight(0)(_ + _.sumDigits > 0) ? arr.foldRight(0)(_ + _.sumDigits > 0) ? arr.foldRight(0)(_ + _.sumDigits > 0) ? arr.foldRight(0)(_ + _.sumDigits > 0) ? arr.foldRight(0)(_ + _.sumDigits > 0) ? arr.foldRight(0)(_ + _.sumDigits > 0) ? arr.foldRight(0)(_ + _.sumDigits > 0) ? arr.foldRight(0)(_ + _.sumDigits > 0) ? arr.foldRight(0)(_ + _.sumDigits > 0) ? arr.foldRight(0)(_ + _.sumDigits > 0) ? arr.foldRight(0)(_ + _.sumDigits > 0) ? arr.foldRight(0)(_ + _.sumDigits > 0) ? arr.foldRight(0)(_ + _.sumDigits > 0) ? arr.foldRight(0)(_ + _.sumDigits > 0) ? arr.foldRight(0)(_ + _.sumDigits > 0) ? arr.foldRight(0)(_ + _.sumDigits > 0) ? arr.foldRight(0)(_ + _.sumDigits > 0) ? arr.foldRight(0)(_ + _.sumDigits > 0) ? arr.foldRight(0)(_ + _.sumDigits > 0) ? arr.foldRight(0)(_ + _.sumDigits > 0) ? arr.foldRight(0)(_ + _.sumDigits > 0) ? arr.foldRight(0)(_ + _.sumDigits > 0) ? arr.foldRight(0)(_ + _.sumDigits > 0) ? arr.foldRight(0)(_ + _.sumDigits > 0) ? arr.foldRight(0)(_ + _.sumDigits > 0) ? arr.foldRight(0)(_ + _.sumDigits > 0) ? arr.foldRight(0)(_ + _.\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpkdoyuh0y.scala:16:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    an identifier expected, but '}' found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpkdoyuh0y.scala:15:31 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        arr.foldRight(\u001b[31m0\u001b[0m)(_ + _.sumDigits > \u001b[31m0\u001b[0m) ? arr.foldRight(\u001b[31m0\u001b[0m)(_ + _.sumDigits > \u001b[31m0\u001b[0m) ? arr.foldRight(\u001b[31m0\u001b[0m)(_ + _.sumDigits > \u001b[31m0\u001b[0m) ? arr.foldRight(\u001b[31m0\u001b[0m)(_ + _.sumDigits > \u001b[31m0\u001b[0m) ? arr.foldRight(\u001b[31m0\u001b[0m)(_ + _.sumDigits > \u001b[31m0\u001b[0m) ? arr.foldRight(\u001b[31m0\u001b[0m)(_ + _.sumDigits > \u001b[31m0\u001b[0m) ? arr.foldRight(\u001b[31m0\u001b[0m)(_ + _.sumDigits > \u001b[31m0\u001b[0m) ? arr.foldRight(\u001b[31m0\u001b[0m)(_ + _.sumDigits > \u001b[31m0\u001b[0m) ? arr.foldRight(\u001b[31m0\u001b[0m)(_ + _.sumDigits > \u001b[31m0\u001b[0m) ? arr.foldRight(\u001b[31m0\u001b[0m)(_ + _.sumDigits > \u001b[31m0\u001b[0m) ? arr.foldRight(\u001b[31m0\u001b[0m)(_ + _.sumDigits > \u001b[31m0\u001b[0m) ? arr.foldRight(\u001b[31m0\u001b[0m)(_ + _.sumDigits > \u001b[31m0\u001b[0m) ? arr.foldRight(\u001b[31m0\u001b[0m)(_ + _.sumDigits > \u001b[31m0\u001b[0m) ? arr.foldRight(\u001b[31m0\u001b[0m)(_ + _.sumDigits > \u001b[31m0\u001b[0m) ? arr.foldRight(\u001b[31m0\u001b[0m)(_ + _.sumDigits > \u001b[31m0\u001b[0m) ? arr.foldRight(\u001b[31m0\u001b[0m)(_ + _.sumDigits > \u001b[31m0\u001b[0m) ? arr.foldRight(\u001b[31m0\u001b[0m)(_ + _.sumDigits > \u001b[31m0\u001b[0m) ? arr.foldRight(\u001b[31m0\u001b[0m)(_ + _.sumDigits > \u001b[31m0\u001b[0m) ? arr.foldRight(\u001b[31m0\u001b[0m)(_ + _.sumDigits > \u001b[31m0\u001b[0m) ? arr.foldRight(\u001b[31m0\u001b[0m)(_ + _.sumDigits > \u001b[31m0\u001b[0m) ? arr.foldRight(\u001b[31m0\u001b[0m)(_ + _.sumDigits > \u001b[31m0\u001b[0m) ? arr.foldRight(\u001b[31m0\u001b[0m)(_ + _.sumDigits > \u001b[31m0\u001b[0m) ? arr.foldRight(\u001b[31m0\u001b[0m)(_ + _.sumDigits > \u001b[31m0\u001b[0m) ? arr.foldRight(\u001b[31m0\u001b[0m)(_ + _.sumDigits > \u001b[31m0\u001b[0m) ? arr.foldRight(\u001b[31m0\u001b[0m)(_ + _.sumDigits > \u001b[31m0\u001b[0m) ? arr.foldRight(\u001b[31m0\u001b[0m)(_ + _.sumDigits > \u001b[31m0\u001b[0m) ? arr.foldRight(\u001b[31m0\u001b[0m)(_ + _.sumDigits > \u001b[31m0\u001b[0m) ? arr.foldRight(\u001b[31m0\u001b[0m)(_ + _.sumDigits > \u001b[31m0\u001b[0m) ? arr.foldRight(\u001b[31m0\u001b[0m)(_ + _.sumDigits > \u001b[31m0\u001b[0m) ? arr.foldRight(\u001b[31m0\u001b[0m)(_ + _.sumDigits > \u001b",
      "stdout": "",
      "timestamp": 1660010029
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        if(arr.isEmpty) 0\n        else arr.map(x => (x * x).toInt).count(x => x > 0)\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp55riweu0.scala:20)\n\tat Problem.main(tmp55riweu0.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660010033
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        val s = arr.foldLeft(0l){\n            case (count, e) => if (e < 0) -count else count}\n        if (s == 0) 0 else (Math.log10(s).toDouble - Math.log10(s)).toLong\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp6797vrvf.scala:22)\n\tat Problem.main(tmp6797vrvf.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660010032
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        val count = mutable.Map[Long, Int]()\n        for(i <- arr) {\n            if(i.signum <= 0)\n                count += i -> 0\n            else {\n                val j = i - i.abs\n                if(j > 0)\n                    count += i -> count.getOrElse(i, 0) + 1\n                else {\n                    count += i -> 0\n                }\n            }\n        }\n        count.values.sum\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpx5_spwtp.scala:15:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mcount\u001b[0m = mutable.Map[\u001b[35mLong\u001b[0m, \u001b[35mInt\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010024
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        val n = arr.size\n        var count = 0\n        var sum = 0\n        for (x <- arr) {\n            sum = sum + x.toInt\n            if (sum < 0) {\n                count = count - 1\n                sum = sum + 10\n            }\n            else {\n                count = count + 1\n            }\n        }\n        (count) //.toLong\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp_clc4vlt.scala:32)\n\tat Problem.main(tmp_clc4vlt.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660010032
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        val digits = arr.map(_.toString.toInt)\n        digits.foldLeft(0l)((acc, digit) =>\n            if (digits.tail.forall(digit2 => digit + digit2 > 0)) acc + 1\n            else acc\n        )\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpj6u74jt2.scala:24)\n\tat Problem.main(tmpj6u74jt2.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660010036
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        // Your code here!\n        val list = arr.map(_.toString.toInt)\n        val n = arr.length\n        val sum = 0\n        for(i <- 0 until n)\n            sum = sum + list(i)\n        sum\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmp_uuyxcql.scala:20:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m            sum = sum + list(i)\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            Reassignment to val sum\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010031
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        var n = 0L\n        var sum = 0L\n        var firstDigit = arr(0)\n        for (x <- arr) {\n            if (x > 0) sum += x\n            else {\n                if (firstDigit < 0)\n                    firstDigit = -x\n                sum += firstDigit + x\n                n++\n                firstDigit = 0\n            }\n        }\n        n\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmp_ejazxqe.scala:25:27 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m                firstDigit = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                           end of statement expected but '=' found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp_ejazxqe.scala:24:17 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m                n++\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                value ++ is not a member of Long\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660010034
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        arr.map(x => if(x<0) x+(x%10)*-1 else x).foldLeft(0L){(x,n) => x+n}\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp2a7_l9dy.scala:15:37 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        arr.map(\u001b[36mx\u001b[0m => \u001b[33mif\u001b[0m(x<\u001b[31m0\u001b[0m) x+(x%\u001b[31m10\u001b[0m)*-\u001b[31m1\u001b[0m \u001b[33melse\u001b[0m x).foldLeft(\u001b[31m0L\u001b[0m){(\u001b[36mx\u001b[0m,\u001b[36mn\u001b[0m) => x+n}\n\u001b[31m\u001b[31m   |\u001b[0m                               ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                               value *- is not a member of Long\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010035
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n       var cnt : Long = 0\n       for (i <- 0 until arr.length) {\n          val s = arr.take(i).sum\n          if (s > 0) cnt += 1\n       }\n       cnt\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpihd71sxj.scala:26)\n\tat Problem.main(tmpihd71sxj.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660010040
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n       var n = arr.size\n       val n1 = arr.foldLeft(0)(_ + _)\n       n = arr.size - n1\n       val n2 = arr.foldRight(0)(_ + _)\n       return (n2 - n) / n \n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp01yz4ogf.scala:16:32 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m       \u001b[33mval\u001b[0m \u001b[36mn1\u001b[0m = arr.foldLeft(\u001b[31m0\u001b[0m)(_ + _)\n\u001b[31m\u001b[31m   |\u001b[0m                                ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                Found:    Long\n\u001b[31m   |\u001b[0m                                Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp01yz4ogf.scala:18:33 --------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m       \u001b[33mval\u001b[0m \u001b[36mn2\u001b[0m = arr.foldRight(\u001b[31m0\u001b[0m)(_ + _)\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Found:    Long\n\u001b[31m   |\u001b[0m                                 Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660010038
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.flatMap{\n            // Get each digit\n            val digit = (it + 10).floorToInt\n            // Get the last digit of the sum\n            val last = it.subtract(digit)\n            if (last < 0) then -last else digit\n        }\n        nums.length\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp0axtkf5g.scala:17:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mdigit\u001b[0m = (it + \u001b[31m10\u001b[0m).floorToInt\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: it\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp0axtkf5g.scala:19:23 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mlast\u001b[0m = it.subtract(digit)\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Not found: it\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660010032
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n      var sum = 0\n      var neg = 0\n      arr.foreach(x => {\n        if(x >= 0) {\n          sum += x\n          neg = 0\n        } else {\n          sum += x * Math.pow(10,-neg)\n          neg = -1\n        }\n      })\n      return arr.size * (sum / 10)\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp35h5pbae.scala:19:14 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m          sum += x\n\u001b[31m\u001b[31m   |\u001b[0m          ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m          value += is not a member of Int - did you mean Int.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp35h5pbae.scala:22:14 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m          sum += x * Math.pow(\u001b[31m10\u001b[0m,-neg)\n\u001b[31m\u001b[31m   |\u001b[0m          ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m          value += is not a member of Int - did you mean Int.!=?\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660010039
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        val sum: Long = 0\n        for (i <- arr.indices) {\n            sum += arr(i)\n        }\n        sum\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp9j7kj020.scala:17:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m            sum += arr(i)\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value += is not a member of Long - did you mean sum.!=?\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010036
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        val totalSum = 0\n        arr.foreach { x => totalSum+=x }\n        arr.toSet.filter(x => x == totalSum).length\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpqnokhe2b.scala:16:35 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        arr.foreach { \u001b[36mx\u001b[0m => totalSum+=x }\n\u001b[31m\u001b[31m   |\u001b[0m                           ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m             value += is not a member of Int - did you mean totalSum.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpqnokhe2b.scala:17:45 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        arr.toSet.filter(\u001b[36mx\u001b[0m => x == totalSum).length\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        value length is not a member of Set[Long]\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660010039
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        val res = mutable.Map[Long, Int]()\n        for (i <- arr) {\n            if (i < 0)\n                res.put(i.toInt.abs, res.getOrElse(i.toInt, 0) + 1L)\n            else\n                res.put(i.toInt, res.getOrElse(i.toInt, 0) + 1L)\n        }\n        res.filter(_._2 > 0).size\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpomt9lpsx.scala:15:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mres\u001b[0m = mutable.Map[\u001b[35mLong\u001b[0m, \u001b[35mInt\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010032
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        val counts = mutable.Map.empty[Long, Int]\n        for {\n            i <- arr\n        } if (i.toString.length() > 0 && i.signum <= 0) counts += (i.toLong -> 1)\n        val res = counts.toSeq.sum\n        res match {\n            case 0 => 0\n            case l => l\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpbwmzhoh4.scala:15:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mcounts\u001b[0m = mutable.Map.empty[\u001b[35mLong\u001b[0m, \u001b[35mInt\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010034
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        var n = 0\n        for (x <- arr) {\n            if (x < 0) x += BigInt(10) * (-x)\n            n = math.max(n,\n                math.max(math.min(x - BigInt(9), BigInt(0)) - BigInt(9), 0))\n        }\n        n\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpopcckp_r.scala:17:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m            \u001b[33mif\u001b[0m (x < \u001b[31m0\u001b[0m) x += BigInt(\u001b[31m10\u001b[0m) * (-x)\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   value += is not a member of Long - did you mean x.!=?\n\u001b[31m\u001b[31m-- [E134] Type Error: /tmp/tmpopcckp_r.scala:19:36 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m                math.max(math.min(x - BigInt(\u001b[31m9\u001b[0m), BigInt(\u001b[31m0\u001b[0m)) - BigInt(\u001b[31m9\u001b[0m), \u001b[31m0\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^^^\u001b[0m\n\u001b[31m   |\u001b[0mNone of the overloaded alternatives of \u001b[33mmethod\u001b[0m \u001b[35m-\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mLong\u001b[0m with types\n\u001b[31m   |\u001b[0m (x: Double): Double\n\u001b[31m   |\u001b[0m (x: Float): Float\n\u001b[31m   |\u001b[0m (x: Long): Long\n\u001b[31m   |\u001b[0m (x: Int): Long\n\u001b[31m   |\u001b[0m (x: Char): Long\n\u001b[31m   |\u001b[0m (x: Short): Long\n\u001b[31m   |\u001b[0m (x: Byte): Long\n\u001b[31m   |\u001b[0mmatch arguments (BigInt)\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660010039
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        arr match {\n            case Nil => 0\n            case _ => {\n                var sum : Long = 0\n                var sign = 0\n                for (i <- arr) {\n                    if (i >= 0) {\n                        sum += i\n                    } else if (i < 0) {\n                        sign = i\n                        sum += sign\n                    } else {\n                        sum -= sign\n                    }\n                }\n                sum\n            }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp6g300it7.scala:24:31 --------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m                        sign = i\n\u001b[31m\u001b[31m   |\u001b[0m                               ^\u001b[0m\n\u001b[31m   |\u001b[0m                               Found:    (i : Long)\n\u001b[31m   |\u001b[0m                               Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010039
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        if(arr.isEmpty) 0\n        else {\n            val positiveSum = 0\n            arr.foreach {\n                case x if x >= 0 && positiveSum + x > 0\n                    => positiveSum += x\n                case x if x >= 0 && positiveSum + x < 0\n                    => positiveSum = Math.abs(positiveSum) + Math.abs(x)\n                case x if x >= 0 && positiveSum + x == 0\n                    => positiveSum += 1\n            }\n            positiveSum\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp7rigtd64.scala:20:35 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m                    => positiveSum += x\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m          value += is not a member of Int - did you mean positiveSum.!=?\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp7rigtd64.scala:22:37 --------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m                    => positiveSum = Math.abs(positiveSum) + Math.abs(x)\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                     Found:    Long\n\u001b[31m   |\u001b[0m                                     Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp7rigtd64.scala:24:35 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m                    => positiveSum += \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m          value += is not a member of Int - did you mean positiveSum.!=?\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660010045
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        def isSmall(xs : List[Long], digits : List[Int]) : Boolean = xs.headOption.exists(x=> digits.exists(y => y % x == 0))\n        def sumDigits(digits : List[Int], i : Int, ndigits : Int) : Long = {\n            if (i == ndigits) {\n                digits.sum\n            } else {\n                sumDigits(digits, i+1, ndigits)*10 + digits.last\n            }\n        }\n        if (arr.isEmpty) 0\n        else if (arr.head < 0 || arr.head > 9) -1\n        else {\n            var n : Long = 0\n            var digits : List[Int] = List(0)\n            while (!isSmall(arr,digits)) {\n                n += sumDigits(digits, 0, digits.size)\n                digits = List(remainder(digits.last, arr.head))\n            }\n            n\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp62_yat1x.scala:30:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m                digits = List(remainder(digits.last, arr.head))\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              Not found: remainder\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010039
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        var cnt = 0\n        var nums = arr\n        val len = nums.length\n        for(i <- 0 until len) {\n            if(nums(i) < 0) nums = nums.drop(1)\n            val d = nums(i).abs\n            val x = d.toInt\n            for(j <- 0 until x) cnt += (10L * (x.toLong - j)).toLong\n        }\n        cnt\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpc7o7a81v.scala:22:36 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            \u001b[33mfor\u001b[0m(j <- \u001b[31m0\u001b[0m until x) cnt += (\u001b[31m10L\u001b[0m * (x.toLong - j)).toLong\n\u001b[31m\u001b[31m   |\u001b[0m                                ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  value += is not a member of Int - did you mean Int.!=?\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010046
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        val m = arr.map(_ % 10).filter(_ > 0).length\n        if (arr.isEmpty) 0\n        else if (arr.forall(_.isNeg)) arr.sum.toLong\n        else {\n            val (positives, negatives) = arr.foldLeft((0l, 0l)) {\n                case ((p, _), (neg, _)) => (p, neg + m.toLong)\n            }\n            positives + negatives\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpx5som_kd.scala:17:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (arr.forall(_.isNeg)) arr.sum.toLong\n\u001b[31m\u001b[31m   |\u001b[0m                            ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                            value isNeg is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpx5som_kd.scala:20:51 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m                \u001b[33mcase\u001b[0m ((p, _), (neg, _)) => (p, neg + m.toLong)\n\u001b[31m\u001b[31m   |\u001b[0m                                               ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue + is not a member of Any, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might make progress towards fixing the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.Fractional.Implicits.infixFractionalOps\n\u001b[31m   |\u001b[0m  import math.Integral.Implicits.infixIntegralOps\n\u001b[31m   |\u001b[0m  import math.Numeric.Implicits.infixNumericOps\n\u001b[31m   |\u001b[0m\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660010050
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n      var count = 0\n      for(i <- 0 until arr.length) {\n        if(arr(i) >= 0) {\n          if(arr(i) < 10) count += 1\n          else {\n            val temp = (arr(i) - 10).toInt\n            if(temp > 0) count += 1\n          }\n        }\n        else {\n          val temp = arr(i).toInt\n          if(temp > 0) count += 1\n        }\n      }\n      count\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp2pyfnuiv.scala:33)\n\tat Problem.main(tmp2pyfnuiv.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660010052
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.map(x => math.abs(x))\n        val countNums = nums.filter(x => x > 0).size\n        val firstDigits = nums.filter(x => x < 0).takeWhile(x => x < 0).size\n        val signs = nums.takeWhile(x => x < 0).reverse.map(x => math.abs(x) < 0).reverse\n        val firstSigns = signs.takeWhile(_ == 1).size\n        signs.drop(firstSigns).size\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmp05894z53.scala:19:41 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mfirstSigns\u001b[0m = signs.takeWhile(_ == \u001b[31m1\u001b[0m).size\n\u001b[31m\u001b[31m   |\u001b[0m                                         ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Values of types Boolean and Int cannot be compared with == or !=\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010049
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        if (arr.isEmpty) 0\n        else {\n            val count = arr.filter { i => i > 0 }.size\n            arr.head > 0 ? -count : count\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp89ximzna.scala:18:36 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m            arr.head > \u001b[31m0\u001b[0m ? -count : \u001b[35mcount\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                                    ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                    Not found: type count\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp89ximzna.scala:18:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m            arr.head > \u001b[31m0\u001b[0m ? -count : \u001b[35mcount\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       value ? is not a member of Int\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660010050
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n      val nums     = arr.filter(_ >= 0).map(_.toInt)\n      val sums     = nums.map(_.toLong).sum\n      arr.filter(_ > 0).map(_.toInt).count(sums.toLong)\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpd2ugm7_t.scala:17:48 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m      arr.filter(_ > \u001b[31m0\u001b[0m).map(_.toInt).count(sums.toLong)\n\u001b[31m\u001b[31m   |\u001b[0m                                           ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                           Found:    Long\n\u001b[31m   |\u001b[0m                                           Required: Int => Boolean\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010052
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        arr.foldLeft(0l){ (x, y) =>\n            val z = Math.abs(y)\n            if (y < 0) z - y < 0 ? y + 11 : y else z\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp1ikq2jdb.scala:17:44 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m            \u001b[33mif\u001b[0m (y < \u001b[31m0\u001b[0m) z - y < \u001b[31m0\u001b[0m ? y + \u001b[31m11\u001b[0m : \u001b[35my\u001b[0m \u001b[33melse\u001b[0m z\n\u001b[31m\u001b[31m   |\u001b[0m                                            ^\u001b[0m\n\u001b[31m   |\u001b[0m                                            Not found: type y\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp1ikq2jdb.scala:17:33 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m            \u001b[33mif\u001b[0m (y < \u001b[31m0\u001b[0m) z - y < \u001b[31m0\u001b[0m ? y + \u001b[31m11\u001b[0m : \u001b[35my\u001b[0m \u001b[33melse\u001b[0m z\n\u001b[31m\u001b[31m   |\u001b[0m                               ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                               value ? is not a member of Int\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660010051
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        if (arr.isEmpty) {\n            return 0\n        }\n        var totalSum = 0\n        var sumOfDigits = 0\n        var sign = 0\n        for (i<-arr.indices) {\n            sum = arr(i) + sign*sumOfDigits\n            sumOfDigits *= 10\n            sign = 1-sign\n            totalSum += sum\n        }\n        arr.toList.count( x => x % 10 > 0 )\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpvmth169_.scala:22:12 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            sum = arr(i) + sign*sumOfDigits\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^\u001b[0m\n\u001b[31m   |\u001b[0m            Not found: sum\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpvmth169_.scala:25:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m            totalSum += sum\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value += is not a member of Int - did you mean Int.!=?\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpvmth169_.scala:25:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m            totalSum += sum\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        Not found: sum\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660010054
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        val arr = arr.reverse\n        arr.foldLeft(0) { (cnt, cur) =>\n            val digit = math.abs(math.signum(cur).toInt)\n            cnt + (digit > 0)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpmyq29h2q.scala:15:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = arr.reverse\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Recursive \u001b[33mvalue\u001b[0m \u001b[35marr\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010045
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        val arr = arr.reverse\n        val n = arr.length\n        if (n < 1) 0\n        else {\n            val digitSums = arr.map(x => x - x.toString.toLong).scanLeft(0)(_ + _)\n            val filteredDigitSums = digitSums.filter(_ > 0).last\n            if (filteredDigitSums == 0) 0\n            else {\n                val totalDigits = digitSums.sum\n                val filteredSum = digitSums.filter(x => x < 0).last\n                if (filteredSum < 0) totalDigits - filteredDigitSums\n                else if (filteredSum > 0) filteredDigitSums\n                else 0\n            }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpq0ma34_u.scala:15:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = arr.reverse\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Recursive \u001b[33mvalue\u001b[0m \u001b[35marr\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010046
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        val n = arr.size\n        var result : Long = 0\n        for ((x, i) => arr(i) < 0) arr(i) *= -1\n        for ((x, i) => arr(i) == 0) result += n\n        for ((x, i) => arr(i) > 0) result += countNums(arr.drop(i+1))\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp278074ss.scala:17:20 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        \u001b[33mfor\u001b[0m ((x, i) => arr(i) < \u001b[31m0\u001b[0m) arr(i) *= -\u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^\u001b[0m\n\u001b[31m   |\u001b[0m                    '<-' expected, but '=>' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp278074ss.scala:18:20 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mfor\u001b[0m ((x, i) => arr(i) == \u001b[31m0\u001b[0m) result += n\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^\u001b[0m\n\u001b[31m   |\u001b[0m                    '<-' expected, but '=>' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp278074ss.scala:19:20 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mfor\u001b[0m ((x, i) => arr(i) > \u001b[31m0\u001b[0m) result += countNums(arr.drop(i+\u001b[31m1\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^\u001b[0m\n\u001b[31m   |\u001b[0m                    '<-' expected, but '=>' found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp278074ss.scala:17:33 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        \u001b[33mfor\u001b[0m ((x, i) => arr(i) < \u001b[31m0\u001b[0m) arr(i) *= -\u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^\u001b[0m\n\u001b[31m   |\u001b[0mvalue withFilter is not a member of Null, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import Option.option2Iterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip2.lazyZip2ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip3.lazyZip3ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip4.lazyZip4ToIterable\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.list asScalaBuffer\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.properties AsScalaMap\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.enumeration AsScalaIterator\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.iterator asScala\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.map AsScalaConcurrentMap\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.s",
      "stdout": "",
      "timestamp": 1660010061
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        var count = 0;\n        arr.foreach(x => if (x < 0) x *= -1l else x += x%10l.toLong);\n        arr.foreach(x => if (x == 0 && !arr.contains(x)) count += 1) else count += arr.count(_ == x))\n        count\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmp98gesgiz.scala:17:69 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        arr.foreach(\u001b[36mx\u001b[0m => \u001b[33mif\u001b[0m (x == \u001b[31m0\u001b[0m && !arr.contains(x)) count += \u001b[31m1\u001b[0m) \u001b[33melse\u001b[0m count += arr.count(_ == x))\n\u001b[31m\u001b[31m   |\u001b[0m                                                                     ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              end of statement expected but 'else' found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp98gesgiz.scala:16:38 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        arr.foreach(\u001b[36mx\u001b[0m => \u001b[33mif\u001b[0m (x < \u001b[31m0\u001b[0m) x *= -\u001b[31m1l\u001b[0m \u001b[33melse\u001b[0m x += x%\u001b[31m10l\u001b[0m.toLong);\n\u001b[31m\u001b[31m   |\u001b[0m                                    ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   value *= is not a member of Long - did you mean x.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp98gesgiz.scala:16:52 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        arr.foreach(\u001b[36mx\u001b[0m => \u001b[33mif\u001b[0m (x < \u001b[31m0\u001b[0m) x *= -\u001b[31m1l\u001b[0m \u001b[33melse\u001b[0m x += x%\u001b[31m10l\u001b[0m.toLong);\n\u001b[31m\u001b[31m   |\u001b[0m                                                  ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   value += is not a member of Long - did you mean x.!=?\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660010057
    },
    {
      "exit_code": -1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        arr match {\n            case Nil => 0\n            case x :: Nil => x.toInt\n            case x :: xs =>\n                var count = 0\n                var sum = 0\n                var digits = 0\n                for (i <- x to xs.head) sum += i.toInt\n                while (sum > 0) {\n                    if (sum >= 10) {\n                        digits += 1\n                        sum -= 10\n                    } else if (sum < 0) {\n                        digits -= 1\n                        sum -= Math.abs(sum)\n                    } else {\n                        sum -= digits\n                    }\n                    count += 1\n                }\n                count\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Timeout",
      "stderr": "None",
      "stdout": "None",
      "timestamp": 1660010063
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        var count = 0\n        var prev = 0L\n        for (i <- arr) {\n            prev = i\n            val digit = math.abs(math.floor((i - prev) / 10)) + 1\n            count += (digit > 0)\n        }\n        count\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpg4a85bd_.scala:20:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m            count += (digit > \u001b[31m0\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value += is not a member of Int - did you mean Int.!=?\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010056
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        if (arr.isEmpty) 0\n        else if (arr.head < 0) arr.head - arr(0)\n        else arr.head - arr(0)\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpumgguwk5.scala:22)\n\tat Problem.main(tmpumgguwk5.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660010061
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        var cnt = 0\n        arr.foreach{ x =>\n            if (x > 0) {\n                cnt += math.abs(math.log10(x))\n            }\n        }\n        cnt\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmplo0jma8i.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m                cnt += math.abs(math.log10(x))\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                value += is not a member of Int - did you mean Int.!=?\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010058
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        val m = arr.size\n        arr.foreach { num =>\n            if (num < 0) num *= -1\n            var count = 0\n            while (num > 0) {\n                val d = num %10\n                num /= 10\n                count += d*d\n            }\n            if (num >= 0 && count > 0) count\n            else 0\n        }.sum\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp7p_49i2e.scala:17:29 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m            \u001b[33mif\u001b[0m (num < \u001b[31m0\u001b[0m) num *= -\u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                 value *= is not a member of Long - did you mean num.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp7p_49i2e.scala:21:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m                num /= \u001b[31m10\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                value /= is not a member of Long - did you mean num.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp7p_49i2e.scala:22:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m                count += d*d\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                value += is not a member of Int - did you mean Int.!=?\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660010062
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n      var count = 0L\n      arr foreach (x => if (x < 0) -x else x)\n      for (x <- arr) {\n        for (y <- arr) {\n          if (x != y) { count += Math.signum(x - y) * (y - x + 1) }\n        }\n      }\n      count\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp1lnfyohm.scala:19:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m          \u001b[33mif\u001b[0m (x != y) { count += Math.signum(x - y) * (y - x + \u001b[31m1\u001b[0m) }\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                value += is not a member of Long - did you mean Long.!=?\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010060
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        if (arr.isEmpty) {\n            return 0\n        }\n        val firstDigit = arr(0)\n        if (firstDigit.signum <= 0)\n            countNums(arr.filter(_ > 0))\n        else\n            countNums(arr.filter(_ >= 0 && _ % firstDigit != 0))\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E086] Syntax Error: /tmp/tmp7ugrcxsr.scala:22:33 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            countNums(arr.filter(_ >= \u001b[31m0\u001b[0m && _ % firstDigit != \u001b[31m0\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Wrong number of parameters, expected: 1\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010055
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        val len = arr.size\n        val counter = mutable.Map.empty[Long, Long]\n        for (i <- 0 until len){\n            val tmp = arr(i)\n            if(tmp <= 0) break\n            val lastDigit = tmp % 10\n            val count = counter.get(lastDigit)\n            val newCount = if (count == null) 0 else count + 1\n            val newCount = newCount.max(tmp / 10)\n            counter.put(lastDigit, newCount)\n        }\n        val result = counter.keys.toSet.count() match {\n            case 0 => 0\n            case 1 => counter.get(0) + 1\n            case _ => counter.keys.toSet.count() + 1\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp59zevdw5.scala:16:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mcounter\u001b[0m = mutable.Map.empty[\u001b[35mLong\u001b[0m, \u001b[35mLong\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp59zevdw5.scala:23:16 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mnewCount\u001b[0m = newCount.max(tmp / \u001b[31m10\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnewCount is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnewCount\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp59zevdw5.scala:19:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m            \u001b[33mif\u001b[0m(tmp <= \u001b[31m0\u001b[0m) break\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: break\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660010057
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        // Your code here\n        var sum = 0\n        for(i <- 0 until arr.length) {\n            sum = sum + arr(i)\n        }\n        return sum\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp4bjejgmk.scala:18:18 --------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m            sum = sum + arr(i)\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  Found:    Long\n\u001b[31m   |\u001b[0m                  Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010061
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        arr.filter(x => x.isDefined).count(x => if (x.toString.reverse.length == 1) x.toString.reverse else x.toString.reverse.head + x.toString.reverse.last) > 0\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp5esppzeh.scala:15:26 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        arr.filter(\u001b[36mx\u001b[0m => x.isDefined).count(\u001b[36mx\u001b[0m => \u001b[33mif\u001b[0m (x.toString.reverse.length == \u001b[31m1\u001b[0m) x.toString.reverse \u001b[33melse\u001b[0m x.toString.reverse.head + x.toString.reverse.last) > \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        value isDefined is not a member of Long\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp5esppzeh.scala:15:95 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        arr.filter(\u001b[36mx\u001b[0m => x.isDefined).count(\u001b[36mx\u001b[0m => \u001b[33mif\u001b[0m (x.toString.reverse.length == \u001b[31m1\u001b[0m) x.toString.reverse \u001b[33melse\u001b[0m x.toString.reverse.head + x.toString.reverse.last) > \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                    ^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                                       Found:    String\n\u001b[31m   |\u001b[0m                                                       Required: Boolean\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp5esppzeh.scala:15:108 -------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        arr.filter(\u001b[36mx\u001b[0m => x.isDefined).count(\u001b[36mx\u001b[0m => \u001b[33mif\u001b[0m (x.toString.reverse.length == \u001b[31m1\u001b[0m) x.toString.reverse \u001b[33melse\u001b[0m x.toString.reverse.head + x.toString.reverse.last) > \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                                       Found:    Int\n\u001b[31m   |\u001b[0m                                                       Required: Boolean\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660010062
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n      var count = 1\n      for(v <- arr) {\n        val d = (v >>> 0) % 10\n        val sign = if (v < 0) -1 else 1\n        count *= sign\n        if(count > 9) count -= 10\n      }\n      count\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmppixboxeh.scala:25)\n\tat Problem.main(tmppixboxeh.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660010069
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        var sum = 0\n        for (i<- arr) {\n            sum += math.abs(i)\n        }\n        if (arr.isEmpty) 0\n        else if (sum < 0) arr.head * -1\n        else arr.size\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp76uxu43p.scala:17:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m            sum += math.abs(i)\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value += is not a member of Int - did you mean Int.!=?\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010066
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        var count = 0;\n        for (i <- arr) {\n            if (i < 0) i += Math.pow(10, i.toInt)\n            var sum = 0\n            for (j <- 0 until i) {\n                sum += j % 10\n            }\n            if (sum > 0) count++\n        }\n        count\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmp7i8cgw8z.scala:22:32 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            \u001b[33mif\u001b[0m (sum > \u001b[31m0\u001b[0m) count++\n\u001b[31m\u001b[31m   |\u001b[0m                                ^\u001b[0m\n\u001b[31m   |\u001b[0m                                expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp7i8cgw8z.scala:17:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m            \u001b[33mif\u001b[0m (i < \u001b[31m0\u001b[0m) i += Math.pow(\u001b[31m10\u001b[0m, i.toInt)\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   value += is not a member of Long - did you mean i.!=?\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp7i8cgw8z.scala:19:30 --------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m            \u001b[33mfor\u001b[0m (j <- \u001b[31m0\u001b[0m until i) {\n\u001b[31m\u001b[31m   |\u001b[0m                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                              Found:    (i : Long)\n\u001b[31m   |\u001b[0m                              Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660010067
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        arr.headOption match {\n            case Some(num) =>\n                var numSum = 0\n                val digits = arr.map(_.toString.toLong).toList\n                for (i <- 0 until digits.length) {\n                    if (digits(i) < 0)\n                        digits(i) *= -1\n                    numSum += digits(i)\n                }\n                numSum\n            case None =>\n                0\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpc4ylt2i7.scala:21:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m                        digits(i) *= -\u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                value *= is not a member of Long - did you mean Long.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpc4ylt2i7.scala:22:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m                    numSum += digits(i)\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  value += is not a member of Int - did you mean Int.!=?\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660010068
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        val count = mutable.HashMap[Long, Long]().withDefaultValue(0l)\n        arr.foreach{ x =>\n            val l = x.toInt\n            if (l > 0) {\n                val l = scala.math.abs(l)\n                if (count.contains(l)) {\n                    count(l) = (count(l) + 1)\n                } else {\n                    count(l) = 1\n                }\n            }\n        }\n        count(arr.head) match {\n            case (_, 0) => 0\n            case (n, 1) => n\n            case (n, _) => countNums(arr.tail)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpt3lfxs8t.scala:15:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mcount\u001b[0m = mutable.HashMap[\u001b[35mLong\u001b[0m, \u001b[35mLong\u001b[0m]().withDefaultValue(\u001b[31m0l\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpt3lfxs8t.scala:29:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m            \u001b[33mcase\u001b[0m (n, \u001b[31m1\u001b[0m) => n\n\u001b[31m\u001b[31m   |\u001b[0m                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                           Not found: n\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660010063
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        arr.foldLeft(0L) { (acc,num) =>\n            if(num < 0) num * -num.toLong - acc\n            else num.toLong * acc\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp0vbt7vbm.scala:23)\n\tat Problem.main(tmp0vbt7vbm.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660010070
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        arr.groupBy(x => (x % 9).abs).map {\n        case (k,v) => (k,v.size)\n        }.filter(_._2 > 0).sum\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmpebr7ncxk.scala:17:30 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        }.filter(_._2 > \u001b[31m0\u001b[0m).sum\n\u001b[31m\u001b[31m   |\u001b[0m                              ^\u001b[0m\n\u001b[31m   |\u001b[0m           No implicit Ordering defined for B\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m           where:    B is a type variable with constraint >: (Long, Int)\n\u001b[31m   |\u001b[0m           .\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010069
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n      val len = arr.size\n      val sumOfDigit = arr.foldLeft(0)( (s, x) => s + (x/10).abs.asInstanceOf[Long])\n      val numOfNums = arr.filter(i => i > 0).size\n      numOfNums * (len - sumOfDigit + numOfNums)\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp11p6xpll.scala:16:50 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m      \u001b[33mval\u001b[0m \u001b[36msumOfDigit\u001b[0m = arr.foldLeft(\u001b[31m0\u001b[0m)( (\u001b[36ms\u001b[0m, \u001b[36mx\u001b[0m) => s + (x/\u001b[31m10\u001b[0m).abs.asInstanceOf[\u001b[35mLong\u001b[0m])\n\u001b[31m\u001b[31m   |\u001b[0m                                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                                  Found:    Long\n\u001b[31m   |\u001b[0m                                                  Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010069
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        arr.foldLeft(0l) { (n,x) => n + (x match {\n            case Long(0) => 1\n            case Long(x) if (x>0) => x - math.pow(10,math.log10(x)) + 1\n            case _ => 0\n        })}\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E127] Syntax Error: /tmp/tmp31zzjmph.scala:16:17 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            \u001b[33mcase\u001b[0m Long(\u001b[31m0\u001b[0m) => \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^^^\u001b[0m\n\u001b[31m   |\u001b[0mLong cannot be used as an extractor in a pattern because it lacks an unapply or unapplySeq method\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E127] Syntax Error: /tmp/tmp31zzjmph.scala:17:17 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m            \u001b[33mcase\u001b[0m Long(x) \u001b[33mif\u001b[0m (x>\u001b[31m0\u001b[0m) => x - math.pow(\u001b[31m10\u001b[0m,math.log10(x)) + \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^^^\u001b[0m\n\u001b[31m   |\u001b[0mLong cannot be used as an extractor in a pattern because it lacks an unapply or unapplySeq method\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660010067
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        val zeroIndex = arr.indexWhere(_ > 0)\n        val len = arr.length\n        if (arr.isEmpty) 0\n        else if (arr.last > 0) arr.last + countNums(arr.init)\n        else len - zeroIndex + 1 + countNums(arr.init.reverse)\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpfto3ty6h.scala:23)\n\tat Problem.main(tmpfto3ty6h.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660010071
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        var num = 0\n        arr.foreach(x => {\n            val n = Math.abs(x)\n            if(n > 0) {\n                num += 1\n                if(n % 10 > 0) num += 1\n            }\n        })\n        num\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpm0cjggz7.scala:27)\n\tat Problem.main(tmpm0cjggz7.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660010072
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.map(_/10).distinct\n\n        val result: Map[Int, Int] = Map()\n\n        nums.foreach { num =>\n            val digits = num.abs\n            val digitSum = digits.toInt\n            if (digitSum > 0) {\n                num.abs match {\n                    case -l if l > 0 =>\n                        result(0) = result(0) + 1\n                    case _ =>\n                        result(1) = result(1) + 1\n                }\n            }\n        }\n\n        if (result.size > 1) {\n            val maxKeyValue = result.maxBy(_._1)\n            val maxKey = maxKeyValue._1\n            val maxVal = maxKeyValue._2\n            val nonMaxKeys = nums.filter(_ <= maxKey).toList\n            val nonMaxVals = nonMaxKeys.map { _ =>\n                val digitSum = (_/10).abs\n                val digits = (_/10).abs\n                val val = digits * maxVal + _\n                val firstDigit = if (val < 0) -digitSum + digits else digits\n                firstDigit * 10\n            }\n            val result = nonMaxVals.reduce((x, y) => x + y)\n            result\n        }\n        else {\n            0\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmp2igg37j_.scala:24:28 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m                    \u001b[33mcase\u001b[0m -l \u001b[33mif\u001b[0m l > \u001b[31m0\u001b[0m =>\n\u001b[31m\u001b[31m   |\u001b[0m                            ^^\u001b[0m\n\u001b[31m   |\u001b[0m                            pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmp2igg37j_.scala:40:20 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m                \u001b[33mval\u001b[0m \u001b[33mval\u001b[0m = digits * maxVal + _\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmp2igg37j_.scala:41:37 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m                \u001b[33mval\u001b[0m \u001b[36mfirstDigit\u001b[0m = \u001b[33mif\u001b[0m (\u001b[33mval\u001b[0m < \u001b[31m0\u001b[0m) -digitSum + digits \u001b[33melse\u001b[0m digits\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                     expression expected but \u001b[31mval\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp2igg37j_.scala:24:26 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m                    \u001b[33mcase\u001b[0m -l \u001b[33mif\u001b[0m l > \u001b[31m0\u001b[0m =>\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Not found: l\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp2igg37j_.scala:34:25 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mmaxKey\u001b[0m = maxKeyValue._1\n\u001b[31m\u001b[31m   |\u001b[0m                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                         Recursive \u001b[33mvalue\u001b[0m \u001b[35mmaxKeyValue\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E081] Type Error: /tmp/tmp2igg37j_.sca",
      "stdout": "",
      "timestamp": 1660010072
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        var sum = 0\n        var index = 0\n        var num = 0\n        while(index < arr.length) {\n            sum += arr(index)\n            if(sum > 0) {\n                num += 1\n            }\n            index += 1\n        }\n        num\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmprzxxyzls.scala:19:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m            sum += arr(index)\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value += is not a member of Int - did you mean Int.!=?\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010071
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        val res = mutable.MutableList[Long]()\n        var i = 0\n        var sum = 0L\n        while (i < arr.size) {\n            sum = arr(i) + sum\n            if (sum > 0) {\n                res.add(sum)\n                sum = 0L\n            }\n            i += 1\n        }\n        \n        if (sum > 0) {\n            res.add(sum)\n        }\n\n        res.length\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmptn4w0upi.scala:15:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mres\u001b[0m = mutable.MutableList[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010069
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        var count = 0\n        arr.filter(_ > 0).foreach(num => {\n            val s = num.toString.reverse.charAt(0)\n            if (s.toLong > 0) {\n                count += 1\n            }\n        })\n        count\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpk3r_69g3.scala:30)\n\tat Problem.main(tmpk3r_69g3.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660010072
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes a list of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    // (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    // (3l)\n    def countNums(arr : List[Long]) : Long = {\n        var count = 0\n        var sign = arr(0) < 0\n        var signCount = 1\n        var digit = arr(0)\n        var digitCount = 0\n        for (i<-arr.indices-1) {\n            val l = arr(i).toLong\n            digitCount += 1\n            if (sign && !l.isMinusOne)\n                signCount += 1\n            sign <- (l < 0)\n            l % 10 == 0 ? l += 10 else sign -= 1\n            digit += l\n            digit %= 10\n            if (digit == 0 && count < signCount)\n                count += 1\n        }\n        count\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmpf6kmlbpu.scala:25:17 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m            sign <- (l < \u001b[31m0\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^\u001b[0m\n\u001b[31m   |\u001b[0m                 end of statement expected but '<-' found\n\u001b[31m\u001b[31m-- Error: /tmp/tmpf6kmlbpu.scala:26:34 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m            l % \u001b[31m10\u001b[0m == \u001b[31m0\u001b[0m ? l += \u001b[31m10\u001b[0m \u001b[33melse\u001b[0m sign -= \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              end of statement expected but 'else' found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpf6kmlbpu.scala:20:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mfor\u001b[0m (i<-arr.indices-\u001b[31m1\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue - is not a member of Range, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might make progress towards fixing the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.Fractional.Implicits.infixFractionalOps\n\u001b[31m   |\u001b[0m  import math.Integral.Implicits.infixIntegralOps\n\u001b[31m   |\u001b[0m  import math.Numeric.Implicits.infixNumericOps\n\u001b[31m   |\u001b[0m\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660010072
    }
  ]
}