language: scala
name: HumanEval_116_sort_array
results:
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        var maxLen :Int = 0\n        var sortedArr = arr.toList\n\
    \        var resultArr = arr.toList\n        val oneBitCount = arr.count{x =>\
    \ x & 1 == 1}\n        var remainArr = arr.toList\n        var oneBitCountNew\
    \ = 0\n        while(sortedArr.nonEmpty) {\n            maxLen = maxLen + oneBitCountNew\n\
    \            remainArr.toList.sortWith{\n                (x: Long, y: (Long)=>Boolean)\
    \ => {\n                    if((x % 2) == 0) (x == y) || (y == (x%2))\n      \
    \              else (x == y)\n                }\n            }\n            oneBitCountNew\
    \ = oneBitCountNew + oneBitCount\n            resultArr = resultArr ++ remainArr\n\
    \            sortedArr = sortedArr.drop(maxLen)\n        }\n        resultArr\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmp8pxtme5t.scala:18:43 -----------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36moneBitCount\e[0m = arr.count{\e\
    [36mx\e[0m => x & \e[31m1\e[0m == \e[31m1\e[0m}\n\e[31m\e[31m   |\e[0m       \
    \                                  ^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded\
    \ alternatives of \e[33mmethod\e[0m \e[35m&\e[0m in \e[33mclass\e[0m \e[35mLong\e\
    [0m with types\n\e[31m   |\e[0m (x: Long): Long\n\e[31m   |\e[0m (x: Int): Long\n\
    \e[31m   |\e[0m (x: Char): Long\n\e[31m   |\e[0m (x: Short): Long\n\e[31m   |\e\
    [0m (x: Byte): Long\n\e[31m   |\e[0mmatch arguments ((\e[31mtrue\e[0m : Boolean))\n\
    \e[31m\e[31m-- Error: /tmp/tmp8pxtme5t.scala:25:38 -----------------------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m                    \e[33mif\e[0m((x % \e[31m2\e[0m)\
    \ == \e[31m0\e[0m) (x == y) || (y == (x%\e[31m2\e[0m))\n\e[31m\e[31m   |\e[0m\
    \                                      ^^^^^^\e[0m\n\e[31m   |\e[0mValues of types\
    \ Long and Long => Boolean cannot be compared with == or !=\n\e[31m\e[31m-- Error:\
    \ /tmp/tmp8pxtme5t.scala:25:50 -----------------------------------------\e[0m\e\
    [0m\n\e[31m25 |\e[0m                    \e[33mif\e[0m((x % \e[31m2\e[0m) == \e\
    [31m0\e[0m) (x == y) || (y == (x%\e[31m2\e[0m))\n\e[31m\e[31m   |\e[0m       \
    \                                           ^^^^^^^^^\e[0m\n\e[31m   |\e[0mValues\
    \ of types Long => Boolean and Long cannot be compared with == or !=\n\e[31m\e\
    [31m-- Error: /tmp/tmp8pxtme5t.scala:26:26 -----------------------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m                    \e[33melse\e[0m (x == y)\n\e[31m\e\
    [31m   |\e[0m                          ^^^^^^\e[0m\n\e[31m   |\e[0mValues of types\
    \ Long and Long => Boolean cannot be compared with == or !=\n4 errors found\n"
  stdout: ''
  timestamp: 1660003967
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        arr.sortWith( x => countOnes(x) )\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E086] Syntax Error: /tmp/tmp07lnvg0x.scala:15:24 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        arr.sortWith( \e[36mx\e[0m => countOnes(x) )\n\
    \e[31m\e[31m   |\e[0m                      ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      Wrong number of parameters, expected: 2\n1 error found\n"
  stdout: ''
  timestamp: 1660003961
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        if (arr.size < 2) arr\n        else if (arr.lastOption.orElse(0L)\
    \ == -1L) arr.reverse\n        else arr.sortWith(compare)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong,\
    \ -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong,\
    \ -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp9gwjp8jn.scala:16:39\
    \ --------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33melse\e[0m \e[33mif\e\
    [0m (arr.lastOption.orElse(\e[31m0L\e[0m) == -\e[31m1L\e[0m) arr.reverse\n\e[31m\e\
    [31m   |\e[0m                                       ^^\e[0m\n\e[31m   |\e[0m \
    \                                      Found:    (\e[31m0L\e[0m : Long)\n\e[31m\
    \   |\e[0m                                       Required: Option[Long]\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp9gwjp8jn.scala:17:26 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33melse\e[0m arr.sortWith(compare)\n\e[31m\e\
    [31m   |\e[0m                          ^^^^^^^\e[0m\n\e[31m   |\e[0m         \
    \                 Not found: compare\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660003966
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        def rec(arr : List[Long]) : List[Long] = {\n     \
    \       arr.head match {\n                case x if x == 0l => arr.tail\n    \
    \            case x if x == 1l => arr.head :: rec(arr.tail)\n                case\
    \ x => {\n                    val numOnes = arr.filter(x => (x & 1l).toLong).length\n\
    \                    if (numOnes > arr.length / 2l) {\n                      \
    \  rec(arr.tail)\n                    } else {\n                        rec(arr.head\
    \ :: arr.tail)\n                    }\n                }\n            }\n    \
    \    }\n        rec(arr)\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpqc_k13q3.scala:20:59\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m                    \e[33mval\e\
    [0m \e[36mnumOnes\e[0m = arr.filter(\e[36mx\e[0m => (x & \e[31m1l\e[0m).toLong).length\n\
    \e[31m\e[31m   |\e[0m                                                  ^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                                  Found: \
    \   Long\n\e[31m   |\e[0m                                                  Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660003965
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val n = arr.size\n        val ones = arr.filter(_\
    \ % 2 == 1).size\n        val twos = arr.filter(_ % 2 == 0).size\n\n        var\
    \ res = List[Long]()\n        for (i<- 0 until n)\n        {\n            if (ones\
    \ > twos)\n            {\n                val tempArray = arr.slice(i+1,n).filter(_\
    \ % 2 == 0).sortBy(_ => -(_ % 10).toLong)\n                val tempArray2 = tempArray.filter(_\
    \ % 2 == 1).sortBy(_ => -(_ % 10).toLong)\n                res = res + tempArray2\n\
    \            }\n            else if (ones == twos)\n            {\n          \
    \      val tempArray = arr.slice(i+1,n).filter(_ % 2 == 1).sortBy(_ => -(_ % 10).toLong)\n\
    \                val tempArray2 = tempArray.filter(_ % 2 == 0).sortBy(_ => -(_\
    \ % 10).toLong)\n                res = res + tempArray2\n            }\n     \
    \       else if (ones < twos)\n            {\n                val tempArray =\
    \ arr.slice(i+1,n).filter(_ % 2 == 0).sortBy(_ => -(_ % 10).toLong)\n        \
    \        val tempArray2 = tempArray.filter(_ % 2 == 1).sortBy(_ => -(_ % 10).toLong)\n\
    \                res = res + tempArray2\n            }\n        }\n        res\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E081] Type Error: /tmp/tmpj80h6lao.scala:24:82 -----------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m                \e[33mval\e[0m \e[36mtempArray\e[0m =\
    \ arr.slice(i+\e[31m1\e[0m,n).filter(_ % \e[31m2\e[0m == \e[31m0\e[0m).sortBy(_\
    \ => -(_ % \e[31m10\e[0m).toLong)\n\e[31m\e[31m   |\e[0m                     \
    \                                                             ^\e[0m\n\e[31m \
    \  |\e[0m   Missing parameter type\n\e[31m   |\e[0m\n\e[31m   |\e[0m   I could\
    \ not infer the type of the parameter _$5 of expanded function:\n\e[31m   |\e\
    [0m   _$5 => _$5 % 10.\n\e[31m\e[31m-- Error: /tmp/tmpj80h6lao.scala:24:97 -----------------------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m                \e[33mval\e[0m \e[36mtempArray\e[0m =\
    \ arr.slice(i+\e[31m1\e[0m,n).filter(_ % \e[31m2\e[0m == \e[31m0\e[0m).sortBy(_\
    \ => -(_ % \e[31m10\e[0m).toLong)\n\e[31m\e[31m   |\e[0m                     \
    \                                                                            ^\e\
    [0m\n\e[31m   |\e[0mambiguous given instances: both \e[33mobject\e[0m \e[35mByte\e\
    [0m in \e[33mobject\e[0m \e[35mOrdering\e[0m and \e[33mobject\e[0m \e[35mBigDecimal\e\
    [0m in \e[33mobject\e[0m \e[35mOrdering\e[0m match type Ordering[B] of parameter\
    \ ord of \e[33mmethod\e[0m \e[35msortBy\e[0m in \e[33mtrait\e[0m \e[35mSeqOps\e\
    [0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpj80h6lao.scala:26:26 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m                res = res + tempArray2\n\e[31m\e[31m\
    \   |\e[0m                      ^^^^^\e[0m\n\e[31m   |\e[0mvalue + is not a member\
    \ of List[Long], but could be made available as an extension method.\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0mOne of the following imports might make progress towards\
    \ fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- [E081] Type Error: /tmp/tmpj80h6lao.scala:30:82 -----------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m                \e[33mval\e[0m \e[36mtempArray\e[0m =\
    \ arr.slice(i+\e[31m1\e[0m,n).filter("
  stdout: ''
  timestamp: 1660003967
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        var i = arr.length\n        val ans = arr.toList\n\
    \        while ( i >= 1 ) {\n            var count = 1\n            while ( i\
    \ >= 1 ) {\n                if ( arr(i) % 2 != 0 ) {\n                    ans(i)\
    \ = 0l.toLong\n                    count = count+1\n                }\n      \
    \          i = i-1\n            }\n            if ( count == 1 ) {\n         \
    \       ans(i) = 0l.toLong\n            }\n            i = i-1\n        }\n  \
    \      ans.toList\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpgtdmnm4l.scala:21:20 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m                    ans(i) = \e[31m0l\e[0m.toLong\n\e\
    [31m\e[31m   |\e[0m                    ^^^\e[0m\n\e[31m   |\e[0m  value update\
    \ is not a member of List[Long] - did you mean ans.updated?\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpgtdmnm4l.scala:27:16 ------------------------\e[0m\e\
    [0m\n\e[31m27 |\e[0m                ans(i) = \e[31m0l\e[0m.toLong\n\e[31m\e[31m\
    \   |\e[0m                ^^^\e[0m\n\e[31m   |\e[0m  value update is not a member\
    \ of List[Long] - did you mean ans.updated?\n2 errors found\n"
  stdout: ''
  timestamp: 1660003966
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        arr.zipWithIndex.sortBy(t => t._2).map(t => t._1).reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpulk0_qof.scala:18)\n\tat Problem.main(tmpulk0_qof.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660003967
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        var ans = mutable.ListBuffer.empty[Long]\n       \
    \ for (i <- 0 until arr.length){\n            val bin = Long.numberOfLeadingZeros(arr(i))\n\
    \            val dec = arr(i).toString.toInt\n            val value = dec / bin\n\
    \            ans += value\n        }\n        ans.toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong,\
    \ -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong,\
    \ -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp3x3h865e.scala:15:18 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mvar\e[0m \e[36mans\e[0m = mutable.ListBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                  ^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                  Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmp3x3h865e.scala:17:27 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m            \e[33mval\e[0m \e[36mbin\e[0m = Long.numberOfLeadingZeros(arr(i))\n\
    \e[31m\e[31m   |\e[0m                      ^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m               value numberOfLeadingZeros is not a member of object\
    \ Long\n2 errors found\n"
  stdout: ''
  timestamp: 1660003965
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        arr.sortBy((x) => x.toString match {\n           \
    \ case s if (s.startsWith(\"1\")) => 1\n            case s if (s.startsWith(\"\
    0\")) => -1\n            case _ => 0\n        })\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpjws2iv45.scala:22)\n\tat Problem.main(tmpjws2iv45.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660003966
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        if (arr.isEmpty) {\n            List()\n        }\n\
    \        val onesCount = arr.map(n => 1l.toLong.asInstanceOf[Long] & n).toArray\n\
    \        val zerosCount = arr.map(n => 0l.toLong.asInstanceOf[Long] & n).toArray\n\
    \        val maxOnesCount = onesCount.max\n        val maxZeroesCount = zerosCount.max\n\
    \        val onesIndex = onesCount.zipWithIndex.sortBy(_._1).last._2\n       \
    \ val zerosIndex = zerosCount.zipWithIndex.sortBy(_._1).last._2\n        val onesDiff\
    \ = maxOnesCount - onesCount\n        val zerosDiff = maxZeroesCount - zerosCount\n\
    \        val onesMax = (onesIndex.toDouble / maxOnesCount).floor.toInt\n     \
    \   val zerosMax = (zerosIndex.toDouble / maxZeroesCount).floor.toInt\n      \
    \  val onesMaxDiff = onesDiff - onesMax\n        val zerosMaxDiff = zerosDiff\
    \ - zerosMax\n        val onesMin = (onesIndex.toDouble / maxOnesCount).ceil.toInt\n\
    \        val zerosMin = (zerosIndex.toDouble / maxZeroesCount).ceil.toInt\n  \
    \      val onesMinDiff = onesMax - onesMin\n        val zerosMinDiff = zerosMax\
    \ - zerosMin\n        val onesMaxOnesDiff = onesMaxDiff + onesMaxDiff\n      \
    \  val zerosMaxZeroesDiff = zerosMaxDiff + zerosMaxDiff\n        val onesMinZeroesDiff\
    \ = onesMinDiff + onesMinDiff\n        val zerosMinOnesDiff = zerosMinDiff + zerosMinDiff\n\
    \        val onesMaxOnesMaxDiff = onesMaxOnesDiff + onesMaxOnesDiff\n        val\
    \ zerosMaxZeroesMaxDiff = zerosMaxZeroesDiff + zerosMaxZeroesDiff\n        val\
    \ onesMinZeroesMaxDiff = onesMinZeroesDiff + onesMinZeroesDiff\n        val zerosMinOnesMaxDiff\
    \ = zerosMinOnesDiff + zerosMinOnesDiff\n        val onesMaxOnesMinDiff = onesMaxOnesDiff\
    \ + onesMaxOnesDiff\n        val zerosMaxZeroesMinDiff = zerosMaxZeroesDiff +\
    \ zerosMaxZeroesDiff\n        val onesMinZeroesMinDiff\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong,\
    \ -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong,\
    \ -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpxe63dl0_.scala:45:4 ----------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpxe63dl0_.scala:24:36\
    \ -----------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e\
    [0m \e[36monesDiff\e[0m = maxOnesCount - onesCount\n\e[31m\e[31m   |\e[0m    \
    \                   ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded\
    \ alternatives of \e[33mmethod\e[0m \e[35m-\e[0m in \e[33mclass\e[0m \e[35mLong\e\
    [0m with types\n\e[31m   |\e[0m (x: Double): Double\n\e[31m   |\e[0m (x: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long): Long\n\e[31m   |\e[0m (x: Int): Long\n\e[31m\
    \   |\e[0m (x: Char): Long\n\e[31m   |\e[0m (x: Short): Long\n\e[31m   |\e[0m\
    \ (x: Byte): Long\n\e[31m   |\e[0mmatch arguments ((onesCount : Array[Long]))\n\
    \e[31m\e[31m-- [E134] Type Error: /tmp/tmpxe63dl0_.scala:25:39 -----------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mzerosDiff\e[0m = maxZeroesCount\
    \ - zerosCount\n\e[31m\e[31m   |\e[0m                        ^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e\
    [35m-\e[0m in \e[33mclass\e[0m \e[35mLong\e[0m with types\n\e[31m   |\e[0m (x:\
    \ Double): Double\n\e[31m   |\e[0m (x: Float): Float\n\e[31m   |\e[0m (x: Long):\
    \ Long\n\e[31m   |\e[0m (x: Int): Long\n\e[31m   |\e[0m (x: Char): Long\n\e[31m\
    \   |\e[0m (x: Short): Long\n\e[31m   |\e[0m (x: Byte): Long\n\e[31m   |\e[0mmatch\
    \ arguments ((zerosCount : Array[Long]))\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpxe63dl0_.scala:45:5 ---------------------\e[0m\e[0m\n\e[31m45\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660003966
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        arr.toList.sortWith((x, y) => compare(x, y) == 0)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpwuvms7mr.scala:15:38 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        arr.toList.sortWith((\e[36mx\e[0m, \e[36my\e\
    [0m) => compare(x, y) == \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m                \
    \                      ^^^^^^^\e[0m\n\e[31m   |\e[0m                         \
    \             Not found: compare\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660003961
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.toSet.map(i => i.toBinary.length.toLong).toArray\n\
    \        val binary = arr.toSet.map(i => i.toBinary.toLong).toArray\n        val\
    \ count = binary.filter(i => i.toLong == 1).size\n        var newArray = Array[Long](arr.size)\n\
    \        var index = 0\n        var i = 0\n        while (i < binary.length) {\n\
    \            if (binary(i) == 1) {\n                var j = 0\n              \
    \  while (j < ones.length) {\n                    if (ones(j) == binary(i)) {\n\
    \                        newArray(index) = ones(j)\n                        index\
    \ = index + 1\n                        break\n                    }\n        \
    \            j = (j + 1).toInt\n                }\n                i = i + 1\n\
    \            }\n            i = i + 1\n        }\n        newArray.sortWith((i,\
    \ j) => i.toInt < j.toInt)\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpgs0lr90e.scala:15:40 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mones\e[0m = arr.toSet.map(\e\
    [36mi\e[0m => i.toBinary.length.toLong).toArray\n\e[31m\e[31m   |\e[0m       \
    \                               ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m             \
    \                     value toBinary is not a member of Long\n\e[31m\e[31m-- Error:\
    \ /tmp/tmpgs0lr90e.scala:15:71 -----------------------------------------\e[0m\e\
    [0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mones\e[0m = arr.toSet.map(\e\
    [36mi\e[0m => i.toBinary.length.toLong).toArray\n\e[31m\e[31m   |\e[0m       \
    \                                                                ^\e[0m\n\e[31m\
    \   |\e[0m                     No ClassTag available for B\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m                     where:    B is a type variable with constraint\
    \ >: B\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpgs0lr90e.scala:16:42 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = arr.toSet.map(\e\
    [36mi\e[0m => i.toBinary.toLong).toArray\n\e[31m\e[31m   |\e[0m              \
    \                          ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                  \
    \                value toBinary is not a member of Long\n\e[31m\e[31m-- Error:\
    \ /tmp/tmpgs0lr90e.scala:16:66 -----------------------------------------\e[0m\e\
    [0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = arr.toSet.map(\e\
    [36mi\e[0m => i.toBinary.toLong).toArray\n\e[31m\e[31m   |\e[0m              \
    \                                                    ^\e[0m\n\e[31m   |\e[0m \
    \                    No ClassTag available for B\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m                     where:    B is a type variable with constraint >: B\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpgs0lr90e.scala:28:24 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m                        break\n\e[31m\e[31m   |\e[0m\
    \                        ^^^^^\e[0m\n\e[31m   |\e[0m                        Not\
    \ found: break\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpgs0l"
  stdout: ''
  timestamp: 1660003967
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val binArr = arr.map(n => bin(n))\n        val sortedBin\
    \ = binArr.sortWith(_ < _)\n        val sortedStr = sortedBin.map(x => x.reverse.toInt).map(x\
    \ => x.toLong).map(Long2Int)\n        sortedStr.map(_.toLong).sorted\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmplia_oz6x.scala:15:34 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mbinArr\e[0m = arr.map(\e\
    [36mn\e[0m => bin(n))\n\e[31m\e[31m   |\e[0m                                 \
    \ ^^^\e[0m\n\e[31m   |\e[0m                                  Not found: bin\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmplia_oz6x.scala:16:42\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36msortedBin\e[0m = binArr.sortWith(_ < _)\n\e[31m\e[31m   |\e[0m           \
    \                             ^^^\e[0m\n\e[31m   |\e[0mvalue < is not a member\
    \ of Nothing, but could be made available as an extension method.\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mOne of the following imports might fix the problem:\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m  import Byte.byte2double\n\e[31m   |\e[0m  import\
    \ Byte.byte2float\n\e[31m   |\e[0m  import Byte.byte2int\n\e[31m   |\e[0m  import\
    \ Byte.byte2long\n\e[31m   |\e[0m  import Byte.byte2short\n\e[31m   |\e[0m  import\
    \ Char.char2double\n\e[31m   |\e[0m  import Char.char2float\n\e[31m   |\e[0m \
    \ import Char.char2int\n\e[31m   |\e[0m  import Char.char2long\n\e[31m   |\e[0m\
    \  import math.BigDecimal.RoundingMode.ValueOrdering.mkOrderingOps\n\e[31m   |\e\
    [0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmplia_oz6x.scala:17:45 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36msortedStr\e[0m = sortedBin.map(\e\
    [36mx\e[0m => x.reverse.toInt).map(\e[36mx\e[0m => x.toLong).map(Long2Int)\n\e\
    [31m\e[31m   |\e[0m                                           ^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mvalue reverse is not a member of Nothing, but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Ordering.Implicits.seqOrdering\n\
    \e[31m   |\e[0m  import math.Ordering.Implicits.sortedSetOrdering\n\e[31m   |\e\
    [0m  import math.Ordering.Iterable\n\e[31m   |\e[0m  import math.Ordering.Option\n\
    \e[31m   |\e[0m  import math.Ordering.comparatorToOrdering\n\e[31m "
  stdout: ''
  timestamp: 1660003968
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        //  Your code here!\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp2rutxaql.scala:14:51\
    \ --------------------\e[0m\e[0m\n\e[31m14 |\e[0m    \e[33mdef\e[0m \e[36msortArray\e\
    [0m(\e[36marr\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m]) : \e[35mList\e[0m[\e[35mLong\e\
    [0m] = {\n\e[31m\e[31m   |\e[0m                                              \
    \     ^\e[0m\n\e[31m   |\e[0m                                                \
    \   Found:    Unit\n\e[31m   |\e[0m                                          \
    \         Required: List[Long]\n\e[31m15 |\e[0m        \e[34m//  Your code here!\e\
    [0m\n\e[31m16 |\e[0m    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660003965
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        arr.sortWith((x, y) => if(x.toString.toInt==y.toString.toInt)\
    \ 0 else 1)\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp0lyquzpu.scala:15:70\
    \ --------------------\e[0m\e[0m\n\e[31m15 |\e[0m        arr.sortWith((\e[36mx\e\
    [0m, \e[36my\e[0m) => \e[33mif\e[0m(x.toString.toInt==y.toString.toInt) \e[31m0\e\
    [0m \e[33melse\e[0m \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m                     \
    \                                                 ^\e[0m\n\e[31m   |\e[0m    \
    \                                                 Found:    (\e[31m0\e[0m : Int)\n\
    \e[31m   |\e[0m                                                     Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp0lyquzpu.scala:15:77\
    \ --------------------\e[0m\e[0m\n\e[31m15 |\e[0m        arr.sortWith((\e[36mx\e\
    [0m, \e[36my\e[0m) => \e[33mif\e[0m(x.toString.toInt==y.toString.toInt) \e[31m0\e\
    [0m \e[33melse\e[0m \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m                     \
    \                                                        ^\e[0m\n\e[31m   |\e\
    [0m                                                     Found:    (\e[31m1\e[0m\
    \ : Int)\n\e[31m   |\e[0m                                                    \
    \ Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660003966
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n      arr.sortWith((x,y) => if (x==0) y else x.toInt == y.toInt)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp64rte7ln.scala:15:38\
    \ --------------------\e[0m\e[0m\n\e[31m15 |\e[0m      arr.sortWith((\e[36mx\e\
    [0m,\e[36my\e[0m) => \e[33mif\e[0m (x==\e[31m0\e[0m) y \e[33melse\e[0m x.toInt\
    \ == y.toInt)\n\e[31m\e[31m   |\e[0m                                      ^\e\
    [0m\n\e[31m   |\e[0m                                      Found:    (y : Long)\n\
    \e[31m   |\e[0m                                      Required: Boolean\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660003965
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones: mutable.Map[Long, Int] = mutable.Map()\n\
    \        val negs: mutable.Map[Long, Int] = mutable.Map()\n        val zeros:\
    \ mutable.Map[Long, Int] = mutable.Map()\n        for(num <- arr) {\n        \
    \    val bin = Integer.toBinaryString(num.toInt)\n            val i = bin.length\n\
    \            val v = bin.substring(bin.length - i, bin.length).toInt\n       \
    \     val a = num.toLong\n            val b = num.toLong\n            val c =\
    \ num.toLong\n            val d = num.toLong\n            val e = num.toLong\n\
    \            if(v > 0) {\n                ones += ((a, b), v + 1)\n          \
    \  } else if(v < 0) {\n                negs += ((c, d), -v)\n            } else\
    \ if(v == 0) {\n                zeros += ((e, i), 0)\n            }\n        }\n\
    \        val sortedOnes = ones.toSeq.sortBy(_._2)\n        val sortedNegs = negs.toSeq.sortBy(_._2)\n\
    \        val sortedZeros = zeros.toSeq.sortBy(_._2)\n        val merged = sortedOnes\
    \ ++ sortedNegs ++ sortedZeros\n        val result = merged.map(x => x._1 + x._2).sorted\n\
    \        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmplsgz57_q.scala:15:18 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mones\e[0m: mutable.Map[\e\
    [35mLong\e[0m, \e[35mInt\e[0m] = mutable.Map()\n\e[31m\e[31m   |\e[0m        \
    \          ^^^^^^^\e[0m\n\e[31m   |\e[0m                  Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmplsgz57_q.scala:15:43\
    \ ------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e\
    [36mones\e[0m: mutable.Map[\e[35mLong\e[0m, \e[35mInt\e[0m] = mutable.Map()\n\e\
    [31m\e[31m   |\e[0m                                           ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                                           Not found: mutable\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmplsgz57_q.scala:16:18\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mnegs\e[0m: mutable.Map[\e[35mLong\e[0m, \e[35mInt\e[0m] = mutable.Map()\n\e\
    [31m\e[31m   |\e[0m                  ^^^^^^^\e[0m\n\e[31m   |\e[0m           \
    \       Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmplsgz57_q.scala:16:43 ------------------------\e[0m\e[0m\n\e[31m16 |\e\
    [0m        \e[33mval\e[0m \e[36mnegs\e[0m: mutable.Map[\e[35mLong\e[0m, \e[35mInt\e\
    [0m] = mutable.Map()\n\e[31m\e[31m   |\e[0m                                  \
    \         ^^^^^^^\e[0m\n\e[31m   |\e[0m                                      \
    \     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmplsgz57_q.scala:17:19 ------------------------\e[0m\e[0m\n\e[31m17 |\e\
    [0m        \e[33mval\e[0m \e[36mzeros\e[0m: mutable.Map[\e[35mLong\e[0m, \e[35mInt\e\
    [0m] = mutable.Map()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `"
  stdout: ''
  timestamp: 1660003962
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.foldLeft(0)((acc, curr) => acc + (curr.toLong\
    \ & 1))\n        val sorted = arr.sortWith((a, b) => (ones > b) match {\n    \
    \        case false => a < b\n            case true => a > b // if number of ones\
    \ is equal, sort according to decimal value\n        })\n        sorted\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp9rc6_9rr.scala:15:50\
    \ --------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mones\e\
    [0m = arr.foldLeft(\e[31m0\e[0m)((\e[36macc\e[0m, \e[36mcurr\e[0m) => acc + (curr.toLong\
    \ & \e[31m1\e[0m))\n\e[31m\e[31m   |\e[0m                                    \
    \              ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                  \
    \                                Found:    Long\n\e[31m   |\e[0m             \
    \                                     Required: Int\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660003965
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val oneBits = arr.filter(x => x != 0).map(_ => 1).count()\n\
    \        val twoBits = arr.filter(x => x != 0).map(x => x.toInt % 2L).count()\
    \ * 2\n        val threeBits = arr.filter(x => x != 0).map(x => (x.toInt % 3L)\
    \ * 3L).count() * 3\n        val fourBits = arr.filter(x => x != 0).map(x => x.toInt\
    \ % 4L).count() * 4\n\n        val oneToOne = oneBits == 1\n        val twoToOne\
    \ = twoBits == 2\n        val threeToOne = threeBits == 3\n        val fourToOne\
    \ = fourBits == 4\n\n        val oneToTwo = oneToOne && twoBits == 2\n       \
    \ val oneToThree = oneToOne && threeBits == 3\n        val oneToFour = oneToOne\
    \ && fourBits == 4\n\n        val twoToThree = twoToOne && threeBits == 3\n  \
    \      val twoToFour = twoToOne && fourBits == 4\n\n        val threeToFour =\
    \ threeToOne && fourBits == 4\n\n        val allOnes = oneToOne && twoToOne &&\
    \ threeToOne && fourToOne\n        val allTwos = twoToOne && threeToOne && fourToOne\n\
    \        val allThrees = threeToOne && fourToOne\n\n        val allOnesAndTwos\
    \ = oneToTwo && twoToTwo\n        val allOnesAndThrees = oneToThree && threeToThree\n\
    \        val allOnesAndFours = oneToFour && fourToFour\n\n        val allTwosAndThrees\
    \ = twoToThree && threeToThree\n        val allTwosAndFours = twoToFour && fourToFour\n\
    \n        val allThreesAndFours = threeToFour && fourToFour\n\n        val onlyOne\
    \ = oneBits == 1\n        val onlyTwo = twoBits == 2\n        val onlyThree =\
    \ threeBits == 3\n        val onlyFour = fourBits == 4\n\n        val oneAndOnlyOne\
    \ = oneBits == 1 && onlyOne\n        val oneAndOnlyTwo = oneBits == 1 && onlyTwo\n\
    \        val oneAndOnlyThree = oneBits == 1 && onlyThree\n        val oneAndOnlyFour\
    \ = oneBits == 1 && onlyFour\n\n        val twoAndOnlyOne = twoBits == 2 && onlyOne\n\
    \        val twoAndOnlyTwo = twoBits == 2 && onlyTwo\n        val twoAndOnlyThree\
    \ = two\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpej9d5gpn.scala:15:63 -----------------------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36moneBits\e[0m = arr.filter(\e\
    [36mx\e[0m => x != \e[31m0\e[0m).map(_ => \e[31m1\e[0m).count()\n\e[31m\e[31m\
    \   |\e[0m                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmissing argument for parameter p of \e[33mmethod\e[0m \e[35mcount\e\
    [0m in \e[33mtrait\e[0m \e[35mIterableOnceOps\e[0m: (p: Int => Boolean): Int\n\
    \e[31m\e[31m-- Error: /tmp/tmpej9d5gpn.scala:16:74 -----------------------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mtwoBits\e[0m = arr.filter(\e\
    [36mx\e[0m => x != \e[31m0\e[0m).map(\e[36mx\e[0m => x.toInt % \e[31m2L\e[0m).count()\
    \ * \e[31m2\e[0m\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmissing argument for parameter p of \e[33mmethod\e[0m \e[35mcount\e\
    [0m in \e[33mtrait\e[0m \e[35mIterableOnceOps\e[0m: (p: Long => Boolean): Int\n\
    \e[31m\e[31m-- Error: /tmp/tmpej9d5gpn.scala:17:83 -----------------------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mthreeBits\e[0m = arr.filter(\e\
    [36mx\e[0m => x != \e[31m0\e[0m).map(\e[36mx\e[0m => (x.toInt % \e[31m3L\e[0m)\
    \ * \e[31m3L\e[0m).count() * \e[31m3\e[0m\n\e[31m\e[31m   |\e[0m             \
    \           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mmissing argument for parameter p of \e[33mmethod\e[0m \e[35mcount\e\
    [0m in \e[33mtrait\e[0m \e[35mIterableOnceOps\e[0m: (p: Long => Boolean): Int\n\
    \e[31m\e[31m-- Error: /tmp/tmpej9d5gpn.scala:18:75 -----------------------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mfourBits\e[0m = arr.filter(\e\
    [36mx\e[0m => x != \e[31m0\e[0m).map(\e[36mx\e[0m => x.toInt % \e[31m4L\e[0m).count()\
    \ * \e[31m4\e[0m\n\e[31m\e[31m   |\e[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmissing argument for parameter p of \e[33mmethod\e[0m \e[35mcount\e\
    [0m in \e[33mtrait\e[0m \e[35mIterableOnceOps\e[0m: (p: Long => Boolean): Int\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tm"
  stdout: ''
  timestamp: 1660003966
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        def sort(arr: List[Long], result: List[Long], counter:\
    \ Int) : List[Long] = {\n            if (counter == arr.length) {\n          \
    \      result\n            } else if (counter == 0) {\n                if (arr(0)\
    \ == 0) {\n                    sort(arr.tail, result, 0)\n                } else\
    \ {\n                    sort(arr.tail, result, 1)\n                }\n      \
    \      } else {\n                if (arr(counter) == 1) {\n                  \
    \  sort(arr.tail, result, counter + 1)\n                } else {\n           \
    \         sort(arr.tail, result, counter)\n                }\n            }\n\
    \        }\n        sort(arr, Nil, 0)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp6hepvu7i.scala:35)\n\tat Problem.main(tmp6hepvu7i.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660003967
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        arr.sortWith((x, y) => x.toBinary.length < y.toBinary.length\
    \ || (x.toBinary.length == y.toBinary.length && x == y) ? x : y)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp6s2mbwjh.scala:15:129 -----------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        arr.sortWith((\e[36mx\e[0m, \e[36my\e[0m) =>\
    \ x.toBinary.length < y.toBinary.length || (x.toBinary.length == y.toBinary.length\
    \ && x == y) ? x : \e[35my\e[0m)\n\e[31m\e[31m   |\e[0m                      \
    \                                                                            \
    \                               ^\e[0m\n\e[31m   |\e[0m                      \
    \                                 Not found: type y\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp6s2mbwjh.scala:15:33 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        arr.sortWith((\e[36mx\e[0m, \e[36my\e[0m) =>\
    \ x.toBinary.length < y.toBinary.length || (x.toBinary.length == y.toBinary.length\
    \ && x == y) ? x : \e[35my\e[0m)\n\e[31m\e[31m   |\e[0m                      \
    \         ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                               value\
    \ toBinary is not a member of Long\n2 errors found\n"
  stdout: ''
  timestamp: 1660003965
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val n = arr.length\n        val bins = arr.map(n ->\
    \ bin(n))\n        val numOnes = bins.map(_.length).sum\n        val sortedArray\
    \ = arr.sortWith((a, b) => compare(numOnes, bins(a), bins(b)))\n        val binsToString\
    \ = bins.map(_.mkString(\",\"))\n        val numOnesToString = numOnes.toString\n\
    \        val resultArray = sortedArray.map { x =>\n            val onesArray =\
    \ binsToString.map(_.contains(x.toString.toLong))\n            if (onesArray.contains(true))\
    \ {\n                x.toString.toLong\n            } else {\n               \
    \ numOnesToString + x.toString.toLong\n            }\n        }\n        resultArray.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpx6219jyr.scala:16:32 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mbins\e[0m = arr.map(n ->\
    \ bin(n))\n\e[31m\e[31m   |\e[0m                                ^^^\e[0m\n\e[31m\
    \   |\e[0m                                Not found: bin\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpx6219jyr.scala:17:33 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mnumOnes\e[0m = bins.map(_.length).sum\n\
    \e[31m\e[31m   |\e[0m                               ^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                               value length is not a member of Nothing\n\e\
    [31m\e[31m-- Error: /tmp/tmpx6219jyr.scala:17:44 -----------------------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mnumOnes\e[0m = bins.map(_.length).sum\n\
    \e[31m\e[31m   |\e[0m                                            ^\e[0m\n\e[31m\
    \   |\e[0mambiguous given instances: both \e[33mobject\e[0m \e[35mIntIsIntegral\e\
    [0m in \e[33mobject\e[0m \e[35mNumeric\e[0m and \e[33mobject\e[0m \e[35mLongIsIntegral\e\
    [0m in \e[33mobject\e[0m \e[35mNumeric\e[0m match type Numeric[B] of parameter\
    \ num of \e[33mmethod\e[0m \e[35msum\e[0m in \e[33mtrait\e[0m \e[35mIterableOnceOps\e\
    [0m\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpx6219jyr.scala:18:49 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36msortedArray\e[0m = arr.sortWith((\e\
    [36ma\e[0m, \e[36mb\e[0m) => compare(numOnes, bins(a), bins(b)))\n\e[31m\e[31m\
    \   |\e[0m                                                 ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                                                 Not found: compare\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpx6219jyr.scala:18:71\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36msortedArray\e\
    [0m = arr.sortWith((\e[36ma\e[0m, \e[36mb\e[0m) => compare(numOnes, bins(a), bins(b)))\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \      "
  stdout: ''
  timestamp: 1660003967
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        arr.sortWith(compareNumOnes)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong,\
    \ -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong,\
    \ -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp8z2yhryk.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        arr.sortWith(compareNumOnes)\n\e[31m\e[31m  \
    \ |\e[0m                     ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            \
    \         Not found: compareNumOnes\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660003961
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        // Implementation here\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong,\
    \ -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong,\
    \ -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpq4n4_p31.scala:14:51\
    \ --------------------\e[0m\e[0m\n\e[31m14 |\e[0m    \e[33mdef\e[0m \e[36msortArray\e\
    [0m(\e[36marr\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m]) : \e[35mList\e[0m[\e[35mLong\e\
    [0m] = {\n\e[31m\e[31m   |\e[0m                                              \
    \     ^\e[0m\n\e[31m   |\e[0m                                                \
    \   Found:    Unit\n\e[31m   |\e[0m                                          \
    \         Required: List[Long]\n\e[31m15 |\e[0m        \e[34m// Implementation\
    \ here\e[0m\n\e[31m16 |\e[0m    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660003972
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val bitCounts = arr.foldLeft(Map[Int, Long]())((counts,\
    \ item) => {\n            counts + (item::item.toLong) -> (counts(item::item.toLong)\
    \ + 1)\n        })\n        val maxBitCounts = bitCounts.maxBy(_._1)\n       \
    \ val binaryCounts = maxBitCounts._1 -> maxBitCounts._2\n        val sortedBinaryCounts\
    \ = binaryCounts.sortBy(_._1)\n        val maxDecimalValues = binaryCounts.maxBy(_._2)\n\
    \        val sortedDecimalValues = maxDecimalValues._2 -> maxDecimalValues._1\n\
    \        val binaryIndexes = sortedBinaryCounts.keys\n        val decimalIndexes\
    \ = sortedDecimalValues.keys\n        sortedBinaryCounts.flatMap { case (binaryCount,\
    \ decimalCount) =>\n            val binaryPartIndex = binaryIndexes.findIndex(i\
    \ => i <= binaryCount)\n            val decimalPartIndex = decimalIndexes.findIndex(i\
    \ => i <= decimalCount)\n            (binaryPartIndex, decimalPartIndex)\n   \
    \     }.map { case (binaryPartIndex, decimalPartIndex) =>\n            (arr.apply(binaryPartIndex),\
    \ arr.apply(decimalPartIndex))\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmptkf2tth2.scala:16:26 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m            counts + (item::item.toLong) -> (counts(item::item.toLong)\
    \ + \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m                          ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                          value :: is not a member of Long\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmptkf2tth2.scala:16:56 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m            counts + (item::item.toLong) -> (counts(item::item.toLong)\
    \ + \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m                                     \
    \                   ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                      \
    \                  value :: is not a member of Long\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmptkf2tth2.scala:20:46 ------------------------\e[0m\e[0m\n\
    \e[31m20 |\e[0m        \e[33mval\e[0m \e[36msortedBinaryCounts\e[0m = binaryCounts.sortBy(_._1)\n\
    \e[31m\e[31m   |\e[0m                                 ^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                             value sortBy is not a member of (Int,\
    \ Long)\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmptkf2tth2.scala:21:44 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mmaxDecimalValues\e[0m =\
    \ binaryCounts.maxBy(_._2)\n\e[31m\e[31m   |\e[0m                            \
    \   ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                              value\
    \ maxBy is not a member of (Int, Long)\n4 errors found\n"
  stdout: ''
  timestamp: 1660003974
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        var arr = arr.toList\n        var sortedArr = arr.sortWith(_._2\
    \ > _._2)\n        var counts = arr.foldLeft((0, 0))((acc, x) => acc + (x & (-x\
    \ -> 1))._1)\n        var sortedCount = counts.max\n        var maxCount = sortedCount.toLong\n\
    \        var sortedArr2 = sortedArr.sortWith(_._2 > _._2) \n        var sortedCount2\
    \ = sortedArr2.foldLeft((0, 0))((acc, x) => acc + (x & (-x -> 1))._1)\n      \
    \  var sortedCount2max = sortedCount2.max\n        val binary = sortedArr2.map\
    \ { x => x._1.toString }\n        val decimal = sortedArr2.map { x => x._1.toString.toDouble\
    \ }\n        var binArr : List[String] = binary.toList\n        var decArr : List[Double]\
    \ = decimal.toList\n        var finalArr : List[Double] = decArr.sortWith(_._2\
    \ < _._2)\n        var finalArr1 = finalArr.reverse\n        var finalArr2 = finalArr1.sortWith(_._2\
    \ > _._2)\n        var finalArr3 = finalArr2.reverse\n        return finalArr3\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpms6k77ii.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mvar\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvariable\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpms6k77ii.scala:27:56 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mvar\e[0m \e[36mfinalArr\e[0m : \e[35mList\e\
    [0m[\e[35mDouble\e[0m] = decArr.sortWith(_._2 < _._2)\n\e[31m\e[31m   |\e[0m \
    \                                                     ^^^^\e[0m\n\e[31m   |\e\
    [0m                                      value _2 is not a member of Double\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpms6k77ii.scala:29:45 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mvar\e[0m \e[36mfinalArr2\e[0m = finalArr1.sortWith(_._2\
    \ > _._2)\n\e[31m\e[31m   |\e[0m                                           ^^^^\e\
    [0m\n\e[31m   |\e[0m                                      value _2 is not a member\
    \ of Double\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpms6k77ii.scala:31:15\
    \ --------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mreturn\e[0m finalArr3\n\
    \e[31m\e[31m   |\e[0m               ^^^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \     Found:    (finalArr3 : List[Double])\n\e[31m   |\e[0m               Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660003974
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        var oneCount = 0\n        var otherCount = 0\n   \
    \     val result = new mutable.ArrayList[Long]()\n        for (i<- 0 until arr.length)\
    \ {\n            if (arr(i).toInt % 2 == 0) {\n                oneCount += 1\n\
    \            } else {\n                otherCount += 1\n            }\n      \
    \  }\n        if (oneCount < otherCount) {\n            result.addAll(arr.filter(_\
    \ % 2 == 0).toList)\n        } else {\n            result.addAll(arr.filter(_\
    \ % 2 != 0).toList)\n        }\n        val sortedArray = result.sortWith(_.compareTo(_)\
    \ < 0)\n        sortedArray.toList\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpa6vuuj8m.scala:17:25 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m mutable.ArrayList[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m              \
    \           ^^^^^^^\e[0m\n\e[31m   |\e[0m                         Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660003971
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.map(x => 1).filter(x => x == 1)\n \
    \       val twos = arr.map(x => 2).filter(x => x == 1)\n        val threes = arr.map(x\
    \ => 3).filter(x => x == 1)\n        val fours = arr.map(x => 4).filter(x => x\
    \ == 1)\n        val fives = arr.map(x => 5).filter(x => x == 1)\n        val\
    \ sixes = arr.map(x => 6).filter(x => x == 1)\n        val twosOne = twos++ones\n\
    \        val threesOne = threes++ones\n        val foursOne = fours++ones\n  \
    \      val fivesOne = fives++ones\n        val sixesOne = sixes++ones\n      \
    \  val twosTwo = twos++twos\n        val threesTwo = threes++twos\n        val\
    \ foursTwo = fours++twos\n        val fivesTwo = fives++twos\n        val sixesTwo\
    \ = sixes++twos\n        val twosThree = twos++threes\n        val threesThree\
    \ = threes++threes\n        val foursThree = fours++threes\n        val fivesThree\
    \ = fives++threes\n        val sixesThree = sixes++threes\n        val twosFour\
    \ = twos++fours\n        val threesFour = threes++fours\n        val foursFour\
    \ = fours++fours\n        val fivesFour = fives++fours\n        val sixesFour\
    \ = sixes++fours\n        val twosFive = twos++fives\n        val threesFive =\
    \ threes++fives\n        val foursFive = fours++fives\n        val fivesFive =\
    \ fives++fives\n        val sixesFive = sixes++fives\n        val twosSix = twos++sixes\n\
    \        val threesSix = threes++sixes\n        val foursSix = fours++sixes\n\
    \        val fivesSix = fives++sixes\n        val sixesSix = sixes++sixes\n  \
    \      val allNums = twosOne++threesOne++foursOne++fivesOne++sixesOne++twosTwo++threesTwo++fours\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpa86y_ycz.scala:52:5\
    \ ---------------------\e[0m\e[0m\n\e[31m52 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660003976
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val bits = arr.map(_.toString).toList\n        val\
    \ bins = bits.grouped(8).map(_.foldLeft(\"\")((acc, i) => acc + (if (i == \"1\"\
    ) \"1\" else \"0\")))\n        val ones = bits.filter(s => s.charAt(0) == \"1\"\
    ).length\n        val decs = bins.map(i => i.dropRight(8).reverse.toInt).map(_.toLong)\n\
    \        val sortedArray = if (ones == decs.length) decs.sortBy(d => d.toInt)\
    \ else decs.sortBy(d => d.toDouble)\n        val list = new Array[Long](sortedArray.length)\n\
    \        sortedArray.zip(list) foreach { case (d, i) => list(i) = d}\n       \
    \ arr map { i => list(i) }\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpbo8hegmr.scala:17:36 -----------------------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mones\e[0m = bits.filter(\e\
    [36ms\e[0m => s.charAt(\e[31m0\e[0m) == \e[31m\"1\"\e[0m).length\n\e[31m\e[31m\
    \   |\e[0m                                    ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m        Values of types Char and String cannot be compared with == or\
    \ !=\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpbo8hegmr.scala:19:56 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36msortedArray\e[0m = \e[33mif\e\
    [0m (ones == decs.length) decs.sortBy(\e[36md\e[0m => d.toInt) \e[33melse\e[0m\
    \ decs.sortBy(\e[36md\e[0m => d.toDouble)\n\e[31m\e[31m   |\e[0m             \
    \                                      ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                     value sortBy is not a member of Iterator[Long]\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpbo8hegmr.scala:19:87 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36msortedArray\e[0m = \e[33mif\e\
    [0m (ones == decs.length) decs.sortBy(\e[36md\e[0m => d.toInt) \e[33melse\e[0m\
    \ decs.sortBy(\e[36md\e[0m => d.toDouble)\n\e[31m\e[31m   |\e[0m             \
    \                                                                     ^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                          value sortBy is not a member of\
    \ Iterator[Long]\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpbo8hegmr.scala:22:28\
    \ --------------------\e[0m\e[0m\n\e[31m22 |\e[0m        arr map { \e[36mi\e[0m\
    \ => list(i) }\n\e[31m\e[31m   |\e[0m                            ^\e[0m\n\e[31m\
    \   |\e[0m                            Found:    (i : Long)\n\e[31m   |\e[0m  \
    \                          Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660003978
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        arr.toList.sortBy(l => {\n            val ones = l.toBinaryString.drop(l.length-1)\n\
    \            (ones.length).compareTo(ones.toBinaryString.reverse)\n        }).sortWith(_.compareTo(0l)\
    \ <= 0)\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp5awxq9gn.scala:16:47 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m            \e[33mval\e[0m \e[36mones\e[0m = l.toBinaryString.drop(l.length-\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m                                           \
    \  ^^^^^^^^\e[0m\n\e[31m   |\e[0m                                    value length\
    \ is not a member of Long\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp5awxq9gn.scala:17:41\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m            (ones.length).compareTo(ones.toBinaryString.reverse)\n\
    \e[31m\e[31m   |\e[0m                                    ^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                          value toBinaryString is not a member\
    \ of String\n\e[31m\e[31m-- [E086] Syntax Error: /tmp/tmp5awxq9gn.scala:18:20\
    \ ---------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        }).sortWith(_.compareTo(\e\
    [31m0l\e[0m) <= \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                    Wrong number of parameters, expected:\
    \ 2\n3 errors found\n"
  stdout: ''
  timestamp: 1660003977
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val oneCount = arr.count(x => x == 1l.toLong).toLong\n\
    \        var result = (oneCount == 0) ? arr : arr.zipWithIndex.sortBy(_._2).map(_._1).reverse\n\
    \        if (oneCount != 0) {\n            result = sortArray(result)\n      \
    \  }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpa7fhrlyy.scala:16:68 -----------------------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mvar\e[0m \e[36mresult\e[0m = (oneCount\
    \ == \e[31m0\e[0m) ? arr : arr.zipWithIndex.sortBy(_._2).map(_._1).reverse\n\e\
    [31m\e[31m   |\e[0m                                                          \
    \          ^\e[0m\n\e[31m   |\e[0m                                 end of statement\
    \ expected but '(' found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpa7fhrlyy.scala:16:37\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mvar\e[0m \e\
    [36mresult\e[0m = (oneCount == \e[31m0\e[0m) ? arr : arr.zipWithIndex.sortBy(_._2).map(_._1).reverse\n\
    \e[31m\e[31m   |\e[0m                     ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                     value ? is not a member of Boolean\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpa7fhrlyy.scala:16:73 --------------------\e[0m\e\
    [0m\n\e[31m16 |\e[0m        \e[33mvar\e[0m \e[36mresult\e[0m = (oneCount == \e\
    [31m0\e[0m) ? arr : arr.zipWithIndex.sortBy(_._2).map(_._1).reverse\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \         ^\e[0m\n\e[31m   |\e[0m                                            \
    \        Found:    Unit\n\e[31m   |\e[0m                                     \
    \               Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660003977
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        // Write your code here\n        var resultList =\
    \ arr.sortBy(x => arr.count(bi => bi == x))\n\n        for((i, v) <- arr.zipWithIndex)\
    \ {\n            val count = resultList.count(bi => bi == v)\n            resultList(v)\
    \ = count\n            if(count == 1) {\n                resultList.indexWhere(bi\
    \ => bi == v) = i\n            }\n        }\n        resultList\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpbbglkw51.scala:20:12 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m            resultList(v) = count\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue update is not a member of\
    \ List[Long] - did you mean List[Long].updated?\n\e[31m\e[31m-- [E134] Type Error:\
    \ /tmp/tmpbbglkw51.scala:22:27 -----------------------------\e[0m\e[0m\n\e[31m22\
    \ |\e[0m                resultList.indexWhere(\e[36mbi\e[0m => bi == v) = i\n\e\
    [31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mNone\
    \ of the overloaded alternatives of \e[33mmethod\e[0m \e[35mindexWhere\e[0m in\
    \ \e[33mtrait\e[0m \e[35mSeqOps\e[0m with types\n\e[31m   |\e[0m (p: Long => Boolean):\
    \ Int\n\e[31m   |\e[0m (p: Long => Boolean, from: Int): Int\n\e[31m   |\e[0mmatch\
    \ expected type ?{ update: ? }\n2 errors found\n"
  stdout: ''
  timestamp: 1660003977
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.groupBy(x => x.toBinaryString().toInt)\n\
    \        val res = ones\n            .mapValues(x => x.size)\n            .mapValues(x\
    \ => x.toList)\n            .sortWith((x, y) => x._2 - y._2)\n            .map(_._1)\n\
    \            .toList\n        arr\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpr_y9uyir.scala:15:52 -----------------------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mones\e[0m = arr.groupBy(\e\
    [36mx\e[0m => x.toBinaryString().toInt)\n\e[31m\e[31m   |\e[0m               \
    \                     ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmissing argument\
    \ for parameter i of \e[33mmethod\e[0m \e[35mapply\e[0m in \e[33mclass\e[0m \e\
    [35mStringOps\e[0m: (i: Int): Char\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpr_y9uyir.scala:18:30\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m            .mapValues(x\
    \ => x.toList)\n\e[31m\e[31m   |\e[0m                            ^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m             value toList is not a member of Int - did you mean\
    \ x.toInt?\n2 errors found\n"
  stdout: ''
  timestamp: 1660003977
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(x => x>0)\n        val zeros\
    \ = arr.count(x => x==0)\n        val sortedOnes = arr.sortBy(x => (ones-if(x>0).negate).abs\n\
    \          ,Ordering[Long].reverse).reverse\n        val sortedZeros = arr.sortBy(x\
    \ => (zeros-if(x==0).negate).abs\n          ,Ordering[Long].reverse).reverse\n\
    \        sortedOnes :+ sortedZeros\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpfce8ee67.scala:17:47 ---------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36msortedOnes\e[0m = arr.sortBy(\e\
    [36mx\e[0m => (ones-\e[33mif\e[0m(x>\e[31m0\e[0m).negate).abs\n\e[31m\e[31m  \
    \ |\e[0m                                               ^^\e[0m\n\e[31m   |\e[0m\
    \                                        expression expected but \e[31mif\e[0m\
    \ found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpfce8ee67.scala:19:49\
    \ ---------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m\
    \ \e[36msortedZeros\e[0m = arr.sortBy(\e[36mx\e[0m => (zeros-\e[33mif\e[0m(x==\e\
    [31m0\e[0m).negate).abs\n\e[31m\e[31m   |\e[0m                               \
    \                  ^^\e[0m\n\e[31m   |\e[0m                                  \
    \      expression expected but \e[31mif\e[0m found\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E081] Type Error: /tmp/tmpfce8ee67.scala:17:36 -----------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36msortedOnes\e[0m = arr.sortBy(\e\
    [36mx\e[0m => (ones-\e[33mif\e[0m(x>\e[31m0\e[0m).negate).abs\n\e[31m\e[31m  \
    \ |\e[0m                                    ^\e[0m\n\e[31m   |\e[0m          \
    \                Missing parameter type\n\e[31m   |\e[0m\n\e[31m   |\e[0m    \
    \                      I could not infer the type of the parameter x.\n\e[31m\e\
    [31m-- Error: /tmp/tmpfce8ee67.scala:18:34 -----------------------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m          ,Ordering[Long].reverse).reverse\n\e[31m\e\
    [31m   |\e[0m                                  ^\e[0m\n\e[31m   |\e[0mambiguous\
    \ given instances: both \e[33mobject\e[0m \e[35mByte\e[0m in \e[33mobject\e[0m\
    \ \e[35mOrdering\e[0m and \e[33mobject\e[0m \e[35mChar\e[0m in \e[33mobject\e\
    [0m \e[35mOrdering\e[0m match type Ordering[B] of parameter ord of \e[33mmethod\e\
    [0m \e[35msortBy\e[0m in \e[33mtrait\e[0m \e[35mSeqOps\e[0m\n\e[31m\e[31m-- [E081]\
    \ Type Error: /tmp/tmpfce8ee67.scala:19:37 -----------------------------\e[0m\e\
    [0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e"
  stdout: ''
  timestamp: 1660003976
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val oneBitSet = arr filter (_ != 0l)\n        val\
    \ countMap = oneBitSet groupBy (_ % 2 != 0l) mapValues (_.length.toLong)\n   \
    \     val sortedNums = countMap.map (_._2) sortWith (_ < _)\n        sortedNums.map(oneBitSet\
    \ find _ != 0l).toList ::: arr\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmps532bywo.scala:17:45 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36msortedNums\e[0m = countMap.map\
    \ (_._2) sortWith (_ < _)\n\e[31m\e[31m   |\e[0m                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m           value sortWith is not a member of scala.collection.View[Long]\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660003978
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        arr.sortWith((x, y) => { \n            if (x == 1l)\
    \ y < x else x < (y==1l ? 1l : y) \n        })\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpbnjpsd3_.scala:16:54 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m            \e[33mif\e[0m (x == \e[31m1l\e[0m) y < x\
    \ \e[33melse\e[0m x < (y==\e[31m1l\e[0m ? \e[31m1l\e[0m : \e[35my\e[0m) \n\e[31m\e\
    [31m   |\e[0m                                                      ^\e[0m\n\e\
    [31m   |\e[0m                                                      Not found:\
    \ type y\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpbnjpsd3_.scala:16:47\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m            \e[33mif\e[0m\
    \ (x == \e[31m1l\e[0m) y < x \e[33melse\e[0m x < (y==\e[31m1l\e[0m ? \e[31m1l\e\
    [0m : \e[35my\e[0m) \n\e[31m\e[31m   |\e[0m                                  \
    \          ^^^^\e[0m\n\e[31m   |\e[0m                                        \
    \ value ? is not a member of Long\n2 errors found\n"
  stdout: ''
  timestamp: 1660003977
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val m = arr.size\n        val bin = arr.map(_.toBinaryString).map(_.toLong).mkString(\"\
    ,\")\n        val dec = arr.map(_.toInt).map(_.toLong).mkString(\",\")\n     \
    \   val bindec = bin+\",\"+dec\n        val sorted = sc.parallelize(bindec).map(x=>{\n\
    \            val bindec = x.split(\",\").map(_.toLong)\n            val bin =\
    \ bindec.head\n            val dec = bindec.last\n            val binaryString\
    \ = bin.toBinaryString\n            val str = s\"${binary.substring(bin.indexOf(0)+1)}(${dec.toInt})\"\
    \n            val str = binaryString + str\n            val binary = binaryString\
    \ + str\n            binary\n        }).map(x=>{\n            val bindec = x.split(\"\
    ,\").map(_.toLong)\n            val bin = bindec.head\n            val dec = bindec.last\n\
    \            (bin,dec).zipWithIndex.sortBy(_._1).map(_._2)\n        }).flatMap(x=>x).collect.toList\n\
    \        val resArr = sorted.map(_.toLong)\n        resArr\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong,\
    \ -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong,\
    \ -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpj81ix4ml.scala:19:21 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36msorted\e[0m = sc.parallelize(bindec).map(\e\
    [36mx\e[0m=>{\n\e[31m\e[31m   |\e[0m                     ^^\e[0m\n\e[31m   |\e\
    [0m                     Not found: sc\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660003974
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        arr.sort((x,y) => {\n                val bin = Integer.toString(x.toInt,\
    \ 2)\n                val bin2 = Integer.toString(y.toInt, 2)\n              \
    \  val bin3 = bin.concat(bin2)\n                val bin4 = bin3.toCharArray\n\
    \                val bin5 = bin4(0)\n                val bin6 = bin4.drop(1)\n\
    \                val bin7 = bin6.map(Integer.parseInt)\n                val bin8\
    \ = bin7.take(bin7.length-1)\n                val bin9 = bin8.reverse\n      \
    \          val bin10 = bin9.map(Integer.toString)\n                val bin11 =\
    \ bin10.reverse\n                val bin12 = bin11.toList\n                bin12.sortWith((x,y)\
    \ => x-y)\n                })\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpqohyn562.scala:15:12 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        arr.sort((\e[36mx\e[0m,\e[36my\e[0m) => {\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^\e[0m\n\e[31m   |\e[0m     value sort is not\
    \ a member of List[Long] - did you mean arr.sortBy?\n1 error found\n"
  stdout: ''
  timestamp: 1660003978
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        // Use a Map to record how many ones in each number\n\
    \        // For instance, a number with 1 will be recorded as 1\n        // A\
    \ number with 0 will be recorded as 0\n        val oneCountMap = new mutable.HashMap[Long,\
    \ Int]()\n        for (a <- arr) {\n            val bin = Integer.toBinaryString(a)\n\
    \            if (bin.length == 1) {\n                oneCountMap += (a -> 1)\n\
    \            } else {\n                oneCountMap += (a -> bin.length)\n    \
    \        }\n        }\n        \n        // Sort the map and create an array to\
    \ return\n        val sortedMap = new TreeMap[Long, Int]()(oneCountMap)\n    \
    \    val sortedArray = sortedMap.map(kv => kv.key).toArray\n        val returnArray\
    \ = Array.ofDim[Int](sortedArray.size)\n        System.arraycopy(sortedArray,\
    \ 0, returnArray, 0, sortedArray.size)\n        returnArray\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong,\
    \ -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong,\
    \ -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmppap67e6x.scala:18:30 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36moneCountMap\e[0m = \e[33mnew\e\
    [0m mutable.HashMap[\e[35mLong\e[0m, \e[35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m\
    \                              ^^^^^^^\e[0m\n\e[31m   |\e[0m                 \
    \             Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmppap67e6x.scala:20:45 --------------------\e[0m\e[0m\n\e[31m20\
    \ |\e[0m            \e[33mval\e[0m \e[36mbin\e[0m = Integer.toBinaryString(a)\n\
    \e[31m\e[31m   |\e[0m                                             ^\e[0m\n\e[31m\
    \   |\e[0m                                             Found:    (a : Long)\n\e\
    [31m   |\e[0m                                             Required: Int\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmppap67e6x.scala:30:49 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36msortedArray\e[0m = sortedMap.map(\e\
    [36mkv\e[0m => kv.key).toArray\n\e[31m\e[31m   |\e[0m                        \
    \                      ^^^^^^\e[0m\n\e[31m   |\e[0m                          \
    \      value key is not a member of (Long, Int)\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmppap67e6x.scala:33:8 ---------------------\e[0m\e[0m\n\e[31m33\
    \ |\e[0m        returnArray\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m        Found:    (returnArray : Array[Int])\n\e[31m   |\e[0m   \
    \     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660003980
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        arr.toSeq.sorted.map { x => (x % 2) == 0l) ? x : -x\
    \ }.toList\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmplwi9i47j.scala:15:49 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        arr.toSeq.sorted.map { \e[36mx\e[0m => (x % \e\
    [31m2\e[0m) == \e[31m0l\e[0m) ? x : -x }.toList\n\e[31m\e[31m   |\e[0m       \
    \                                          ^\e[0m\n\e[31m   |\e[0m           \
    \                                  '}' expected, but ')' found\n1 error found\n"
  stdout: ''
  timestamp: 1660003975
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val oneBits = arr.map(x => (x & x.toString.toLong).map(x\
    \ => (x & x).toString.toLong).sum)\n        val decimal = arr.map(x => (x & x.toString.toLong).map(x\
    \ => (x & x).toString.toLong).sum).map(_.toDouble)\n        val result = (oneBits\
    \ zip decimal).sortBy(_._1).sortBy(_._2)\n        result.map(_._1)\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmphu41e2wu.scala:15:59 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36moneBits\e[0m = arr.map(\e\
    [36mx\e[0m => (x & x.toString.toLong).map(\e[36mx\e[0m => (x & x).toString.toLong).sum)\n\
    \e[31m\e[31m   |\e[0m                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                   value map is not a member\
    \ of Long\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmphu41e2wu.scala:16:59\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mdecimal\e[0m = arr.map(\e[36mx\e[0m => (x & x.toString.toLong).map(\e[36mx\e\
    [0m => (x & x).toString.toLong).sum).map(_.toDouble)\n\e[31m\e[31m   |\e[0m  \
    \                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                                   value map is not a member of Long\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmphu41e2wu.scala:16:104 -----------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mdecimal\e[0m = arr.map(\e\
    [36mx\e[0m => (x & x.toString.toLong).map(\e[36mx\e[0m => (x & x).toString.toLong).sum).map(_.toDouble)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                              ^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ toDouble is not a member of Nothing, but could be made available as an extension\
    \ method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might\
    \ fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import Byte.byte2double\n\
    \e[31m   |\e[0m  import Byte.byte2float\n\e[31m   |\e[0m  import Byte.byte2int\n\
    \e[31m   |\e[0m  import Byte.byte2long\n\e[31m   |\e[0m  import Byte.byte2short\n\
    \e[31m   |\e[0m  import Char.char2double\n\e[31m   |\e[0m  import Char.char2float\n\
    \e[31m   |\e[0m  import Char.char2int\n\e[31m   |\e[0m  import Char.char2long\n\
    \e[31m   |\e[0m  import math.BigDecimal.javaBigDecimal2bigDecimal\n\e[31m   |\e\
    [0m\n\e[31m\e[31m-- Error: /tmp/tmphu41e2wu.scala:17:55 -----------------------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = (oneBits zip\
    \ decimal).sortBy(_._1).sortBy"
  stdout: ''
  timestamp: 1660003979
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        // Write your logic here\n        val map = arr.reduce{\
    \ (a,b) =>\n            val key = a.toLong /+ (b :+ 1).toLong\n            (key,\
    \ a) :+ (key -> b.toLong)\n        }\n        val result = arr.groupBy(_ / 2).toList.sortWith(a\
    \ => a._1 < a._2 match {\n            case true => true\n            case false\
    \ => false\n        }).map(a => a._2.sortWith(_.toLong < a._2.toLong).head).flatMap(a\
    \ => a)\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpfs7ndwot.scala:17:31 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m            \e[33mval\e[0m \e[36mkey\e[0m = a.toLong\
    \ /+ (b :+ \e[31m1\e[0m).toLong\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                      value /+ is not a member of Long\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpfs7ndwot.scala:17:37 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m            \e[33mval\e[0m \e[36mkey\e[0m = a.toLong\
    \ /+ (b :+ \e[31m1\e[0m).toLong\n\e[31m\e[31m   |\e[0m                       \
    \            ^^^^\e[0m\n\e[31m   |\e[0m                                   value\
    \ :+ is not a member of Long\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpfs7ndwot.scala:18:21\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m            (key, a) :+ (key\
    \ -> b.toLong)\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m        value :+ is not a member of (T1, T2) - did you mean (T1, T2).++?\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m        where:    T1 is a type variable\n\e[31m\
    \   |\e[0m                  T2 is a type variable with constraint >: (a : Long)\n\
    \e[31m\e[31m-- [E086] Syntax Error: /tmp/tmpfs7ndwot.scala:20:58 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = arr.groupBy(_\
    \ / \e[31m2\e[0m).toList.sortWith(\e[36ma\e[0m => a._1 < a._2 \e[33mmatch\e[0m\
    \ {\n\e[31m\e[31m   |\e[0m                                                   \
    \     ^\e[0m\n\e[31m   |\e[0m                                 Wrong number of\
    \ parameters, expected: 2\n\e[31m21 |\e[0m            \e[33mcase\e[0m \e[31mtrue\e\
    [0m => \e[31mtrue\e[0m\n\e[31m22 |\e[0m            \e[33mcase\e[0m \e[31mfalse\e\
    [0m => \e[31mfalse\e[0m\n\e[31m23 |\e[0m        }).map(\e[36ma\e[0m => a._2.sortWith(_.toLong\
    \ < a._2.toLong).head).flatMap(\e[36ma\e[0m => a)\n\e[31m\e[31m-- [E086] Syntax\
    \ Error: /tmp/tmpfs7ndwot.scala:23:34 ---------------------------\e[0m\e[0m\n\e\
    [31m23 |\e[0m        }).map(a => a._2.sortWith(_.toLong < a._2.toLong).head).flatMap(a\
    \ => a)\n\e[31m\e[31m   |\e[0m                                  ^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                          "
  stdout: ''
  timestamp: 1660003980
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        var arr = arr.toList\n        var arrSize = arr.size\n\
    \        arr.sortWith((x, y) => arr.count(_ == y) < arr.count(_ == x))\n     \
    \   arr\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpxcn_ds2q.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mvar\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvariable\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660003975
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        // If input array is empty, return empty array\n \
    \       if(arr.isEmpty) arr.toList\n\n        // If there is only one element,\
    \ return it\n        if(arr.size == 1) arr\n\n        // Sort array from small\
    \ to big\n        var big = 0\n        var small = arr.size-1\n        while(small\
    \ != big)\n        {\n            // If there is a tie in binary representation\
    \ sort by decimal\n            if(arr(small) == 1 && arr(big) == 0)\n        \
    \    {\n                arr(small) = arr(big)\n                arr(big) = arr(small)\n\
    \                arr(small-1) = arr(big-1)\n                arr(big-1) = arr(small-1)\n\
    \                big -= 1\n                small -= 1\n            }\n       \
    \     // If there is a tie in decimal sort by binary representation\n        \
    \    else if(arr(small) == 0 && arr(big) == 1)\n            {\n              \
    \  arr(small) = arr(big)\n                arr(big) = arr(small)\n            \
    \    arr(small-1) = arr(big-1)\n                arr(big-1) = arr(small-1)\n  \
    \              big -= 1\n                small -= 1\n            }\n         \
    \   // If there is a tie in decimal and binary representation, sort by decimal\n\
    \            else if(arr(small) == 1 && arr(big) == 1)\n            {\n      \
    \          arr(small) = arr(big)\n                arr(big) = arr(small)\n    \
    \            arr(small-1) = arr(big-1)\n                arr(big-1) = arr(small-1)\n\
    \                big -= 1\n                small -= 1\n            }\n       \
    \ }\n        arr\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp0zfjk5z4.scala:29:16 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m                arr(small) = arr(big)\n\e[31m\e[31m \
    \  |\e[0m                ^^^\e[0m\n\e[31m   |\e[0m  value update is not a member\
    \ of List[Long] - did you mean arr.updated?\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmp0zfjk5z4.scala:30:16 ------------------------\e[0m\e[0m\n\e[31m30 |\e\
    [0m                arr(big) = arr(small)\n\e[31m\e[31m   |\e[0m              \
    \  ^^^\e[0m\n\e[31m   |\e[0m  value update is not a member of List[Long] - did\
    \ you mean arr.updated?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp0zfjk5z4.scala:31:16\
    \ ------------------------\e[0m\e[0m\n\e[31m31 |\e[0m                arr(small-\e\
    [31m1\e[0m) = arr(big-\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m                ^^^\e\
    [0m\n\e[31m   |\e[0m  value update is not a member of List[Long] - did you mean\
    \ arr.updated?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp0zfjk5z4.scala:32:16\
    \ ------------------------\e[0m\e[0m\n\e[31m32 |\e[0m                arr(big-\e\
    [31m1\e[0m) = arr(small-\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m                ^^^\e\
    [0m\n\e[31m   |\e[0m  value update is not a member of List[Long] - did you mean\
    \ arr.updated?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp0zfjk5z4.scala:39:16\
    \ ------------------------\e[0m\e[0m\n\e[31m39 |\e[0m                arr(small)\
    \ = arr(big)\n\e[31m\e[31m   |\e[0m                ^^^\e[0m\n\e[31m   |\e[0m \
    \ value update is not a member of List[Long] - did you mean arr.updated?\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp0zfjk5z4.scala:40:16 ------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m                arr(big) = arr(small)\n\e[31m\e[31m \
    \  |\e[0m                ^^^\e[0m\n\e[31m   |\e[0m  value update is not a member\
    \ of List[Long] - did you mean arr.updated?\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmp0zfjk5z4.scala:41:16 ------------------------\e[0m\e[0m\n\e[31m41 |\e\
    [0m                arr(small-\e[31m1\e[0m) = arr(big-\e[31m1\e[0m)\n\e[31m\e[31m\
    \   |\e[0m                ^^^\e[0m\n\e[31m   |\e[0m  value update is not a member\
    \ of List[Long] - did you mean arr.updated?\n\e[31m\e[31m-- [E008] Not Found Error:"
  stdout: ''
  timestamp: 1660003982
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val numOnes = arr.filter(_ != 0L).toList\n       \
    \ val bins = numOnes.map(_.toString(2)).map(_.toChar)\n        val binLen = bins.map(_.length).sum\n\
    \        val binMap : mutable.Map[String, List[String]] = bins.foldLeft(mutable.Map[(String,\
    \ Int), List[String]]()) {\n            case (acc, bin) => acc + (bin -> List())\n\
    \        }\n        val zeros = binMap.filter(_._2.isEmpty).map(_._1)\n      \
    \  val ones = binMap.filter(_._2.nonEmpty).map(_._1)\n        val binLists = (0\
    \ until binLen).map(x => (x -> List(bins(x - binLen).take(bin(x))))).toList\n\
    \        val sortedBins = binLists.flatMap(x => x._2).map(x => (x -> x.head))\n\
    \        val zeroBins = zeros.map(x => (x -> x._2))\n        val oneBins = ones.map(x\
    \ => (x -> x._2))\n        val binMaps = zeroBins ++ oneBins ++ sortedBins\n \
    \       binMaps.flatMap(x => x._2.map(y => (y, x._1)))\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong,\
    \ -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong,\
    \ -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp0yxinjtt.scala:16:42 -----------------------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mbins\e[0m = numOnes.map(_.toString(\e\
    [31m2\e[0m)).map(_.toChar)\n\e[31m\e[31m   |\e[0m                            \
    \              ^\e[0m\n\e[31m   |\e[0m         too many arguments for \e[33mmethod\e\
    [0m \e[35mtoString\e[0m in \e[33mclass\e[0m \e[35mAny\e[0m: (): String\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp0yxinjtt.scala:16:52 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mbins\e[0m = numOnes.map(_.toString(\e\
    [31m2\e[0m)).map(_.toChar)\n\e[31m\e[31m   |\e[0m                            \
    \                      ^^^^^^^^\e[0m\n\e[31m   |\e[0m                        \
    \          value toChar is not a member of String\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmp0yxinjtt.scala:17:32 ------------------------\e[0m\e[0m\n\e[31m17\
    \ |\e[0m        \e[33mval\e[0m \e[36mbinLen\e[0m = bins.map(_.length).sum\n\e\
    [31m\e[31m   |\e[0m                              ^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ length is not a member of Nothing, but could be made available as an extension\
    \ method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might\
    \ fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.enumeration\
    \ AsScalaIterator\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.iterator\
    \ asScala\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.list\
    \ asScalaBuffer\n\e[31m   |\e[0m  import collection.convert.ImplicitConversionsToScala.enumeration\
    \ AsScalaIterator\n\e[31m   |\e[0m  import collection.convert.ImplicitConversionsToScala.iterator\
    \ asScala\n\e[31m   |\e[0m  import collection.convert.ImplicitConversionsToScala.list\
    \ asScalaBuffer\n\e[31m   |\e[0m  import concurrent.duration.pairIntToDuration\n\
    \e[31m   |\e[0m  import concurrent.duration.pairLongToDuration\n\e[31m   |\e[0m\n\
    \e[31m\e[31m-- Error: /tmp/tmp0yxinjtt.scala:17:43 -----------------------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mbinLen\e[0m = bins.map(_.length).sum\n\
    \e[31m\e[31m   |\e[0m                   "
  stdout: ''
  timestamp: 1660003982
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val n = arr.size\n        var max = 0L\n        var\
    \ numOnes = 0L\n        var sortedArray = arr.filterNot(_ < 0).toList\n\n    \
    \    arr.foreach{\n            num =>\n            if( num == 0 ) numOnes += 1\n\
    \            if( num == max) numOnes += 1\n            if( numOnes > max ) max\
    \ = numOnes\n        }\n\n        val ones = arr.filterNot(_ == 0)\n        val\
    \ twos = arr.filterNot(_ == 1)\n        val tens = arr.filterNot(_ == 10L)\n \
    \       val hundreds = arr.filterNot(_ == 100L)\n        val thousands = arr.filterNot(_\
    \ == 1000L)\n\n        ones = ones.sortWith(_.compareTo(_) > 0).sorted\n     \
    \   twos = twos.sortWith(_.compareTo(_) > 0).sorted\n        tens = tens.sortWith(_.compareTo(_)\
    \ > 0).sorted\n        hundreds = hundreds.sortWith(_.compareTo(_) > 0).sorted\n\
    \        thousands = thousands.sortWith(_.compareTo(_) > 0).sorted\n\n       \
    \ sortedArray = ones ::: twos ::: tens ::: hundreds ::: thousands\n        sortedArray\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmpr1p_c__7.scala:33:13 -----------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        ones = ones.sortWith(_.compareTo(_) > \e[31m0\e\
    [0m).sorted\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Reassignment to val ones\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E052] Type Error: /tmp/tmpr1p_c__7.scala:34:13 -----------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        twos = twos.sortWith(_.compareTo(_) > \e[31m0\e\
    [0m).sorted\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Reassignment to val twos\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E052] Type Error: /tmp/tmpr1p_c__7.scala:35:13 -----------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        tens = tens.sortWith(_.compareTo(_) > \e[31m0\e\
    [0m).sorted\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Reassignment to val tens\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E052] Type Error: /tmp/tmpr1p_c__7.scala:36:17 -----------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        hundreds = hundreds.sortWith(_.compareTo(_) >\
    \ \e[31m0\e[0m).sorted\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Reassignment to val hundreds\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E052] Type Error: /tmp/tmpr1p_c__7.scala:37:18 -----------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        thousands = thousands.sortWith(_.compareTo(_)\
    \ > \e[31m0\e[0m).sorted\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Reassignment to val thousands\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n5 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660003978
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_.toInt == 1)\n        val twos\
    \ = arr.filter(_.toInt == 2)\n        val tens = arr.filter(_.toInt == 10)\n \
    \       val hundreds = arr.filter(_.toInt == 100)\n        val thousands = arr.filter(_.toInt\
    \ == 1000)\n        val tHundreds = arr.filter(_.toInt == 10000)\n        val\
    \ onesAndHundreds = ones + hundreds\n        val tensAndHundreds = tens + hundreds\n\
    \        val onesAndTensAndHundreds = ones + tens + hundreds\n        val onesAndHundredsAndHundreds\
    \ = ones + hundreds + hundreds\n        val onesAndHundredsAndTens = ones + hundreds\
    \ + tens\n        val onesAndHundredsAndTensAndHundreds = ones + hundreds + tens\
    \ + hundreds\n        val onesAndHundredsAndHundredsAndHundreds = ones + hundreds\
    \ + hundreds + hundreds\n        val onesAndHundredsAndHundredsAndTens = ones\
    \ + hundreds + hundreds + tens\n        val onesAndHundredsAndHundredsAndTensAndHundreds\
    \ = ones + hundreds + hundreds + tens + hundreds\n        val onesAndHundredsAndHundredsAndHundredsAndTens\
    \ = ones + hundreds + hundreds + hundreds + tens\n        val onesAndHundredsAndHundredsAndHundredsAndTensAndHundreds\
    \ = ones + hundreds + hundreds + hundreds + tens + hundreds\n        val onesAndHundredsAndHundredsAndTensAndHundreds\
    \ = ones + hundreds + hundreds + tens + hundreds\n        val onesAndHundredsAndTensAndHundredsAndHundreds\
    \ = ones + hundreds + tens + hundreds + hundreds\n        val onesAndHundredsAndTensAndHundredsAndTensAndHundreds\
    \ = ones + hundreds + tens + hundreds + hundreds + tens\n        val onesAndHundredsAndTensAndHundredsAndHundredsAndTensAndHundreds\
    \ = ones + hundreds + tens + hundreds + hundreds + hundreds + tens + hundreds\n\
    \        val onesAndHundredsAndTensAndH\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp8jd_26e1.scala:37:4 ----------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp8jd_26e1.scala:32:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m\
    \ \e[36monesAndHundredsAndHundredsAndTensAndHundreds\e[0m = ones + hundreds +\
    \ hundreds + tens + hundreds\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesAndHundredsAndHundredsAndTensAndHundreds is already defined\
    \ as \e[33mvalue\e[0m \e[35monesAndHundredsAndHundredsAndTensAndHundreds\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmp8jd_26e1.scala:21:35 ------------------------\e[0m\e[0m\n\e[31m21 |\e\
    [0m        \e[33mval\e[0m \e[36monesAndHundreds\e[0m = ones + hundreds\n\e[31m\e\
    [31m   |\e[0m                              ^^^^^^\e[0m\n\e[31m   |\e[0mvalue +\
    \ is not a member of List[Long], but could be made available as an extension method.\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might make progress\
    \ towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp8jd_26e1.scala:22:35 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mtensAndHundreds\e[0m = tens\
    \ + hundreds\n\e[31m\e[31m   |\e[0m                              ^^^^^^\e[0m\n\
    \e[31m   |\e[0mvalue + is not a member of List[Long], but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e\
    [0m  import math.Integral.Implicit"
  stdout: ''
  timestamp: 1660003989
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        if (arr.isEmpty || arr.head < 0)\n            throw\
    \ new RuntimeException(\"Input array cannot be empty or negative elements.\");\n\
    \        var result = [];\n        var countOne = 0;\n        var countZero =\
    \ 0;\n        for (i<- 0 until arr.size) {\n            if (arr(i) == 1)\n   \
    \             countOne += 1;\n            else\n                countZero += 1;\n\
    \        }\n        for (i<- 0 until arr.size) {\n            if (countOne < countZero)\
    \ {\n                if (arr(i) == 1) {\n                    countOne += 1;\n\
    \                } else {\n                    result += arr(i).toLong\n     \
    \           }\n            } else if (countOne == countZero) {\n             \
    \   if (arr(i) == 0)\n                    countZero += 1;\n                else\n\
    \                    result += arr(i).toLong\n            }\n        }\n     \
    \   result\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpvmriml15.scala:17:22 ---------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mvar\e[0m \e[36mresult\e[0m = [];\n\e[31m\e\
    [31m   |\e[0m                      ^\e[0m\n\e[31m   |\e[0m                   \
    \   an identifier expected, but ']' found\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tmpvmriml15.scala:17:23 ---------------------------\e[0m\e[0m\n\e[31m17\
    \ |\e[0m        \e[33mvar\e[0m \e[36mresult\e[0m = [];\n\e[31m\e[31m   |\e[0m\
    \                       ^\e[0m\n\e[31m   |\e[0m                       '=>' expected,\
    \ but ';' found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpvmriml15.scala:31:27\
    \ ------------------------\e[0m\e[0m\n\e[31m31 |\e[0m                    result\
    \ += arr(i).toLong\n\e[31m\e[31m   |\e[0m                    ^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                value += is not a member of Null - did you mean Null.!=?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpvmriml15.scala:37:27 ------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m                    result += arr(i).toLong\n\e[31m\e\
    [31m   |\e[0m                    ^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue += is not\
    \ a member of Null, but could be made available as an extension method.\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mOne of the following imports might fix the problem:\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.properties\
    \ AsScalaMap\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.list\
    \ asScalaBuffer\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.map\
    \ AsScalaConcurrentMap\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.set\
    \ asScala\n\e[31m   |\e[0m  import collection.convert.ImplicitConversionsToScala.list\
    \ asScalaBuffer\n\e[31m   |\e[0m  import collection.convert.ImplicitConversionsToScala.map\
    \ AsScalaConcurrentMap\n\e[31m   |\e[0m  import collection.convert.ImplicitConversionsToScala.properties\
    \ AsScalaMap\n\e[31m   |\e[0m  import collection.convert.ImplicitConversionsToScala.set\
    \ asScala\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.map\
    \ AsScala\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.diction"
  stdout: ''
  timestamp: 1660003987
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        arr.sortWith(_>_)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmps2w89xlz.scala:18)\n\tat Problem.main(tmps2w89xlz.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660003988
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        if (arr.isEmpty) arr\n        else if (arr.head ==\
    \ 0l) sortArray(arr.tail)\n        else {\n            val binStr = arr.map(x\
    \ => (x.toBinary.length.toInt, x)).toMap\n            val bins = binStr.sortWith((x,y)\
    \ =>\n                if (binStr(x) > binStr(y)) 1\n                else -1\n\
    \            )\n            val arr1 = arr.map { x => bins(binStr(x).toInt) }\n\
    \            sortArray(arr1)\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpz5bmzdd7.scala:18:41 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m            \e[33mval\e[0m \e[36mbinStr\e[0m = arr.map(\e\
    [36mx\e[0m => (x.toBinary.length.toInt, x)).toMap\n\e[31m\e[31m   |\e[0m     \
    \                                  ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \                        value toBinary is not a member of Long\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpz5bmzdd7.scala:19:30 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m            \e[33mval\e[0m \e[36mbins\e[0m = binStr.sortWith((\e\
    [36mx\e[0m,\e[36my\e[0m) =>\n\e[31m\e[31m   |\e[0m                       ^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                    value sortWith is not a member of Map[Nothing,\
    \ Long]\n2 errors found\n"
  stdout: ''
  timestamp: 1660003987
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        // convert array to a vector and sort it\n       \
    \ val vecArr = arr.toVector\n        vecArr.sortWith(compareNumber)\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp3m0bs50g.scala:17:24 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        vecArr.sortWith(compareNumber)\n\e[31m\e[31m\
    \   |\e[0m                        ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        \
    \                Not found: compareNumber\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660003984
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        def count(a : Long, b : Long) : Long = {\n       \
    \     val ones = a & b\n            a ^ b ^ ones\n        }\n        val binary\
    \ = arr.map( x => (count(x, 2l), x))\n        binary.sortBy(x => x._1)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp63xgcnrn.scala:20:8\
    \ ---------------------\e[0m\e[0m\n\e[31m20 |\e[0m        binary.sortBy(\e[36mx\e\
    [0m => x._1)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m        Found:    List[\e[1m\e[31m(\e[0mLong\e[1m\e[31m,\e[0m\e[1m\e\
    [31m \e[0m\e[1m\e[31mLong\e[0m\e[1m\e[31m)\e[0m]\n\e[31m   |\e[0m        Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660003987
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        arr.sortWith(compareToOne)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong,\
    \ -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong,\
    \ -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp9ru71t2p.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        arr.sortWith(compareToOne)\n\e[31m\e[31m   |\e\
    [0m                     ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                   \
    \  Not found: compareToOne\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660003983
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        arr.sortWith((x, y) => if (x.toInt == 1) y.toInt else\
    \ x.toInt - y.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpiw5uw51e.scala:15:51\
    \ --------------------\e[0m\e[0m\n\e[31m15 |\e[0m        arr.sortWith((\e[36mx\e\
    [0m, \e[36my\e[0m) => \e[33mif\e[0m (x.toInt == \e[31m1\e[0m) y.toInt \e[33melse\e\
    [0m x.toInt - y.toInt)\n\e[31m\e[31m   |\e[0m                                \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                              \
    \                   Found:    Int\n\e[31m   |\e[0m                           \
    \                      Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpiw5uw51e.scala:15:62 --------------------\e[0m\e\
    [0m\n\e[31m15 |\e[0m        arr.sortWith((\e[36mx\e[0m, \e[36my\e[0m) => \e[33mif\e\
    [0m (x.toInt == \e[31m1\e[0m) y.toInt \e[33melse\e[0m x.toInt - y.toInt)\n\e[31m\e\
    [31m   |\e[0m                                                              ^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                                       Found:\
    \    Int\n\e[31m   |\e[0m                                                    \
    \   Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660003989
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val res =\n            if(arr.isEmpty)\n         \
    \       List(arr.head.toLong)\n            else\n                arr.head match\
    \ {\n                    case 0l => sortArray(arr.tail)\n                    case\
    \ _ if arr.head.signum == -1l =>\n                        val l2 = List(arr.tail.head)\n\
    \                        val l3 = sortArray(arr.tail.tail)\n                 \
    \       l2 ++ l3.map(x => x + l2.last)\n                    case _ =>\n      \
    \                  val l2 = List(arr.tail.head)\n                        val l3\
    \ = sortArray(arr.tail.tail)\n                        l2.reverse.tail.map(x =>\
    \ x + l2.last)\n                }\n        res\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.util.NoSuchElementException: head of empty list\n\tat scala.collection.immutable.Nil$.head(List.scala:662)\n\
    \tat scala.collection.immutable.Nil$.head(List.scala:661)\n\tat Problem$.sortArray(tmpt5mb3x36.scala:26)\n\
    \tat Problem$.sortArray(tmpt5mb3x36.scala:27)\n\tat Problem$.sortArray(tmpt5mb3x36.scala:27)\n\
    \tat Problem$.main(tmpt5mb3x36.scala:33)\n\tat Problem.main(tmpt5mb3x36.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660003990
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val res = arr.sortWith( (l, r) => {\n            if\
    \ (l = 0L) {\n                if (r = 1L) return 1L\n                else if (r\
    \ = 0L) return -1L\n                else return 0L\n            }\n          \
    \  else if (r = 0L) {\n                if (l = 1L) return 1L\n               \
    \ else if (l = 0L) return -1L\n                else return 0L\n            }\n\
    \            else if (l > r) {\n                if (l == 0L) return 0L\n     \
    \           else if (r == 1L) return 1L\n                else if (r == 0L) return\
    \ -1L\n                else if (l == 1L) return 1L\n                else if (l\
    \ == 0L) return -1L\n                else return 0L\n            }\n         \
    \   else if (l < r) {\n                if (l == 0L) return -1L\n             \
    \   else if (r == 1L) return 1L\n                else if (r == 0L) return 0L\n\
    \                else if (l == 1L) return 1L\n                else if (l == 0L)\
    \ return 0L\n                else return -1L\n            }\n            else\
    \ return 0\n        })\n        val resultArr = new mutable.ArrayBuffer[Long]()\n\
    \        for (i <- 0 until res.size) {\n            resultArr += (res(i))\n  \
    \      }\n        resultArr\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmp3a9v4vk_.scala:16:18 -----------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m            \e[33mif\e[0m (l = \e[31m0L\e[0m) {\n\e[31m\e\
    [31m   |\e[0m                ^^^^^^\e[0m\n\e[31m   |\e[0m                Reassignment\
    \ to val l\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmp3a9v4vk_.scala:17:22\
    \ -----------------------------\e[0m\e[0m\n\e[31m17 |\e[0m                \e[33mif\e\
    [0m (r = \e[31m1L\e[0m) \e[33mreturn\e[0m \e[31m1L\e[0m\n\e[31m\e[31m   |\e[0m\
    \                    ^^^^^^\e[0m\n\e[31m   |\e[0m                    Reassignment\
    \ to val r\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp3a9v4vk_.scala:17:35\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m                \e[33mif\e[0m\
    \ (r = \e[31m1L\e[0m) \e[33mreturn\e[0m \e[31m1L\e[0m\n\e[31m\e[31m   |\e[0m \
    \                                  ^^\e[0m\n\e[31m   |\e[0m                  \
    \                 Found:    (\e[31m1L\e[0m : Long)\n\e[31m   |\e[0m          \
    \                         Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E052] Type Error: /tmp/tmp3a9v4vk_.scala:18:27 -----------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m                \e[33melse\e[0m \e[33mif\e[0m (r = \e\
    [31m0L\e[0m) \e[33mreturn\e[0m -\e[31m1L\e[0m\n\e[31m\e[31m   |\e[0m         \
    \                ^^^^^^\e[0m\n\e[31m   |\e[0m                         Reassignment\
    \ to val r\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp3a9v4vk_.scala:18:40\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m                \e[33melse\e\
    [0m \e[33mif\e[0m (r = \e[31m0L\e[0m) \e[33mreturn\e[0m -\e[31m1L\e[0m\n\e[31m\e\
    [31m   |\e[0m                                        ^^^\e[0m\n\e[31m   |\e[0m\
    \                                        Found:    (\e[31m-1L\e[0m : Long)\n\e\
    [31m   |\e[0m                                        Required: List[Long]\n\e\
    [31m   |\e[0m\n\e[31m"
  stdout: ''
  timestamp: 1660003991
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        arr.sortWith(_.compareTo(_.toBinaryString) == 0)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E086] Syntax Error: /tmp/tmpt3u94zm6.scala:15:21 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        arr.sortWith(_.compareTo(_.toBinaryString) ==\
    \ \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                     Wrong number of parameters, expected:\
    \ 2\n1 error found\n"
  stdout: ''
  timestamp: 1660003985
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        if (arr.length == 0) arr\n        else {\n       \
    \     val ones = arr.count(_ == 1)\n            val negatives = arr.count(_ <\
    \ 0)\n            val zeros = arr.count(_ == 0)\n            val base = (ones\
    \ + negatives + zeros).toLong\n            val base2 = base.toString + base.toString\n\
    \            val onesBase = base2.indexOf(\"1\")\n            val negativesBase\
    \ = base2.indexOf(\"0\")\n            val zerosBase = base2.lastIndexOf(\"0\"\
    )\n            val negativesOnesBase = base2.lastIndexOf(\"1\", negativesBase)\n\
    \            val zerosOnesBase = base2.lastIndexOf(\"0\", zeros)\n           \
    \ val negativesOnesBase2 = base2.indexOf(\"1\", negativesOnesBase)\n         \
    \   val zerosOnesBase2 = base2.indexOf(\"0\", zerosOnesBase)\n            val\
    \ negOnesBase = base2.indexOf(\"1\", negativesOnesBase2)\n            val negOnesBase2\
    \ = base2.indexOf(\"0\", negOnesBase)\n            val negOnesBase3 = base2.lastIndexOf(\"\
    1\", negOnesBase2)\n            val negOnesBase3 = base2.lastIndexOf(\"0\", negOnesBase3)\n\
    \n            val arr2 = arr.reverse\n            val arr3 = arr2.reverse\n  \
    \          val arr4 = arr3.reverse\n            val arr5 = arr4.reverse\n\n  \
    \          var arr = arr\n            while (arr.length != 0) {\n            \
    \    val nextOne = arr.find(_ == 1)\n                val nextNegative = arr.find(_\
    \ < 0)\n                val nextZero = arr.find(_ == 0)\n                val nextBase\
    \ = (nextOne + nextNegative + nextZero).toLong\n                val nextBase2\
    \ = nextBase.toString + nextBase.toString\n                val nextOnesBase =\
    \ nextBase2.indexOf(\"1\")\n                val nextNegativesBase = nextBase2.indexOf(\"\
    0\")\n                val nextZerosBase = nextBase2.lastIndexOf(\"0\")\n     \
    \           val nextNegativesOnesBase = nextBase2.lastIndexOf(\"1\", nextNegativesBase)\n\
    \                val nextZerosOnesBase = nextBase2.lastIndexOf(\"0\", nextZerosBase)\n\
    \                val nextNegativesOnesBase2 = nextBase2.indexOf(\"1\", nextNegativesOnesBase)\n\
    \                val nextZerosOnesBase2 = nextBase2.indexOf(\"0\", nextZerosOnesBase)\n\
    \                val nextNegOnesBase = nextBase2.indexOf(\"1\", nextNegative\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpopr1a6xy.scala:54:4 ----------------------------\e\
    [0m\e[0m\n\e[31m54 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpopr1a6xy.scala:67:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m67 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpopr1a6xy.scala:32:16 ---------------------------\e[0m\e[0m\n\e\
    [31m32 |\e[0m            \e[33mval\e[0m \e[36mnegOnesBase3\e[0m = base2.lastIndexOf(\e\
    [31m\"0\"\e[0m, negOnesBase3)\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mnegOnesBase3 is already defined as \e[33mvalue\e[0m \e[35mnegOnesBase3\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmpopr1a6xy.scala:39:22 ---------------------------\e[0m\e[0m\n\e\
    [31m39 |\e[0m            \e[33mvar\e[0m \e[36marr\e[0m = arr\n\e[31m\e[31m   |\e\
    [0m                      ^\e[0m\n\e[31m   |\e[0m                      Recursive\
    \ \e[33mvariable\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpopr1a6xy.scala:66:1 ---------------------\e\
    [0m\e[0m\n\e[31m66 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e[0m\n\e[31m   |\e[0m Found:\
    \    Unit\n\e[31m   |\e[0m Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[33m\e[33m--\
    \ Warning: /tmp/tmpopr1a6xy.scala:55:4 ----------------------------------------\e\
    [0m\e[0m\n\e[33m55 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m\
    \   |\e[0m    Line is indented too far to the left, or a `}` is missing\n1 warning\
    \ found\n5 errors found\n"
  stdout: ''
  timestamp: 1660003989
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val map = mutable.Map[Long, List[Long]]()\n      \
    \  arr.foreach{a => val b = bin(a)\n                       if(map.getOrElse(b,\
    \ 0).getOrElse(0) <= 1) map += a -> b\n                       else map += b ->\
    \ a }\n        val m = map.toSeq.sortWith((x,y) => x._2 > y._2)\n        m.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp8l8l3uf0.scala:15:18 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mmap\e[0m = mutable.Map[\e\
    [35mLong\e[0m, \e[35mList\e[0m[\e[35mLong\e[0m]]()\n\e[31m\e[31m   |\e[0m    \
    \              ^^^^^^^\e[0m\n\e[31m   |\e[0m                  Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp8l8l3uf0.scala:16:33\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        arr.foreach{\e[36ma\e\
    [0m => \e[33mval\e[0m \e[36mb\e[0m = bin(a)\n\e[31m\e[31m   |\e[0m           \
    \                      ^^^\e[0m\n\e[31m   |\e[0m                             \
    \    Not found: bin\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660003985
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        var arr1 = arr.toSet\n        arr1 = arr1.filter(_\
    \ != 0).toSet\n        arr1 = arr1.map(_ / 2).toSet\n        arr1 = arr1.sortBy(identity).sorted\n\
    \        arr1.toList\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpqk5wxb3p.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        arr1 = arr1.sortBy(identity).sorted\n\e[31m\e\
    [31m   |\e[0m               ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m               value\
    \ sortBy is not a member of Set[Long]\n1 error found\n"
  stdout: ''
  timestamp: 1660003989
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        //Write your code here\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong,\
    \ -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong,\
    \ -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpdez0gv1l.scala:14:51\
    \ --------------------\e[0m\e[0m\n\e[31m14 |\e[0m    \e[33mdef\e[0m \e[36msortArray\e\
    [0m(\e[36marr\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m]) : \e[35mList\e[0m[\e[35mLong\e\
    [0m] = {\n\e[31m\e[31m   |\e[0m                                              \
    \     ^\e[0m\n\e[31m   |\e[0m                                                \
    \   Found:    Unit\n\e[31m   |\e[0m                                          \
    \         Required: List[Long]\n\e[31m15 |\e[0m        \e[34m//Write your code\
    \ here\e[0m\n\e[31m16 |\e[0m    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660003989
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        var result = arr.sortBy(x => -math.log2(x % 1L))\n\
    \        for (i <- 0 until arr.length)\n            if (math.log2(arr(i) % 1L)\
    \ == math.log2(result(i) % 1L))\n                result = result.sortWith((x,\
    \ y) => x - y)\n        result\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpt6jbvngw.scala:15:43 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mvar\e[0m \e[36mresult\e[0m = arr.sortBy(\e\
    [36mx\e[0m => -math.log2(x % \e[31m1L\e[0m))\n\e[31m\e[31m   |\e[0m          \
    \                            ^^^^^^^^^\e[0m\n\e[31m   |\e[0m                 \
    \                     value log2 is not a member of math\n\e[31m\e[31m-- Error:\
    \ /tmp/tmpt6jbvngw.scala:15:56 -----------------------------------------\e[0m\e\
    [0m\n\e[31m15 |\e[0m        \e[33mvar\e[0m \e[36mresult\e[0m = arr.sortBy(\e[36mx\e\
    [0m => -math.log2(x % \e[31m1L\e[0m))\n\e[31m\e[31m   |\e[0m                 \
    \                                       ^\e[0m\n\e[31m   |\e[0mambiguous given\
    \ instances: both \e[33mobject\e[0m \e[35mBigDecimal\e[0m in \e[33mobject\e[0m\
    \ \e[35mOrdering\e[0m and \e[33mobject\e[0m \e[35mChar\e[0m in \e[33mobject\e\
    [0m \e[35mOrdering\e[0m match type Ordering[B] of parameter ord of \e[33mmethod\e\
    [0m \e[35msortBy\e[0m in \e[33mtrait\e[0m \e[35mSeqOps\e[0m\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpt6jbvngw.scala:17:21 ------------------------\e[0m\e\
    [0m\n\e[31m17 |\e[0m            \e[33mif\e[0m (math.log2(arr(i) % \e[31m1L\e[0m)\
    \ == math.log2(result(i) % \e[31m1L\e[0m))\n\e[31m\e[31m   |\e[0m            \
    \    ^^^^^^^^^\e[0m\n\e[31m   |\e[0m                value log2 is not a member\
    \ of math\n3 errors found\n"
  stdout: ''
  timestamp: 1660003990
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        var res = arr.sortWith(greaterThan(_, _)) // sorts\
    \ the array with the right order\n        val i = res(0).toInt // pick the first\
    \ value\n        var inv = -1\n        for(j <- 1 to res.size - 1) \n        \
    \    if(res(j).toInt == i)\n                inv += 1\n            else\n     \
    \           if(res(j).toInt == i) res(j) <- res(j) - inv\n        res\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpzt0o9kq4.scala:22:45 -----------------------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m                \e[33mif\e[0m(res(j).toInt == i) res(j)\
    \ <- res(j) - inv\n\e[31m\e[31m   |\e[0m                                     \
    \        ^^\e[0m\n\e[31m   |\e[0m                                end of statement\
    \ expected but '<-' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpzt0o9kq4.scala:15:31\
    \ ------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mvar\e[0m \e\
    [36mres\e[0m = arr.sortWith(greaterThan(_, _)) \e[34m// sorts the array with the\
    \ right order\e[0m\n\e[31m\e[31m   |\e[0m                               ^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                               Not found: greaterThan\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660003987
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n      arr.sortWith(compareTwoOnesFirst)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong,\
    \ -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong,\
    \ -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpixtwfobd.scala:15:19 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m      arr.sortWith(compareTwoOnesFirst)\n\e[31m\e[31m\
    \   |\e[0m                   ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m       \
    \            Not found: compareTwoOnesFirst\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660003987
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        var zeros : List[Long] = Nil\n        var ones : List[Long]\
    \ = Nil\n        var numOfOnes = 0\n        var sortedList : List[Long] = Nil\n\
    \        for(i <- arr) {\n            if(i < 0l) {\n                if(numOfOnes\
    \ <= 0) {\n                    ones = List(i)\n                }\n           \
    \     else {\n                    zeros = List(i)\n                }\n       \
    \         numOfOnes = 1\n            }\n            else if(i > 0l) {\n      \
    \          if(numOfOnes <= 0) {\n                    zeros = List(i)\n       \
    \         }\n                else {\n                    ones = List(i)\n    \
    \            }\n                numOfOnes += 1\n            }\n        }\n\n \
    \       if(numOfOnes > 0) {\n            sortedList = ones\n        }\n      \
    \  else {\n            sortedList = zeros\n        }\n\n        sortedList\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp6k4iph9e.scala:50)\n\tat Problem.main(tmp6k4iph9e.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660003993
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        arr.sortWith((a,b) => if(b==0) a else b).reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp97a6wuqu.scala:15:39\
    \ --------------------\e[0m\e[0m\n\e[31m15 |\e[0m        arr.sortWith((\e[36ma\e\
    [0m,\e[36mb\e[0m) => \e[33mif\e[0m(b==\e[31m0\e[0m) a \e[33melse\e[0m b).reverse\n\
    \e[31m\e[31m   |\e[0m                                       ^\e[0m\n\e[31m   |\e\
    [0m                                       Found:    (a : Long)\n\e[31m   |\e[0m\
    \                                       Required: Boolean\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp97a6wuqu.scala:15:46 --------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        arr.sortWith((\e[36ma\e[0m,\e[36mb\e[0m) => \e\
    [33mif\e[0m(b==\e[31m0\e[0m) a \e[33melse\e[0m b).reverse\n\e[31m\e[31m   |\e\
    [0m                                              ^\e[0m\n\e[31m   |\e[0m     \
    \                                         Found:    (b : Long)\n\e[31m   |\e[0m\
    \                                              Required: Boolean\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660003992
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        arr.map(x => (arr.count(y => (x & y) == x) + x.toInt,\
    \ x)).sortBy(_._1).map(x => x._2)\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5_k90ldu.scala:18)\n\tat Problem.main(tmp5_k90ldu.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660003994
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val n = arr.size\n        val bin = arr.map(x => (x.toString.toInt,\
    \ (x.toString map {\n          case '1' => 1\n          case '0' => 0\n      \
    \  }).sum)).toList\n        val dec = bin.map(x => x._2 / 10).sortBy(x => x).toList\n\
    \        val sorted = dec.map(x => bin.find(y => y._1 < (x - x) / x.toLong * x.toLong)\
    \ == Some(y))\n        if (sorted.size == n) {\n            sorted\n        }\
    \ else {\n            sortArray(sorted)\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong,\
    \ -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong,\
    \ -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpsjade8mg.scala:21:94 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36msorted\e[0m = dec.map(\e\
    [36mx\e[0m => bin.find(\e[36my\e[0m => y._1 < (x - x) / x.toLong * x.toLong) ==\
    \ Some(y))\n\e[31m\e[31m   |\e[0m                                            \
    \                                                  ^\e[0m\n\e[31m   |\e[0m   \
    \                                                         Not found: y\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpsjade8mg.scala:23:12 --------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            sorted\n\e[31m\e[31m   |\e[0m           \
    \ ^^^^^^\e[0m\n\e[31m   |\e[0m            Found:    (sorted : List[Boolean])\n\
    \e[31m   |\e[0m            Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpsjade8mg.scala:25:22 --------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m            sortArray(sorted)\n\e[31m\e[31m   |\e[0m\
    \                      ^^^^^^\e[0m\n\e[31m   |\e[0m                      Found:\
    \    (sorted : List[Boolean])\n\e[31m   |\e[0m                      Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660003994
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        arr.sortBy(elem => arr.count(i => i & elem == i))\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmp6ny1f3at.scala:15:44 -----------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        arr.sortBy(\e[36melem\e[0m => arr.count(\e[36mi\e\
    [0m => i & elem == i))\n\e[31m\e[31m   |\e[0m                                \
    \          ^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e\
    [33mmethod\e[0m \e[35m&\e[0m in \e[33mclass\e[0m \e[35mLong\e[0m with types\n\e\
    [31m   |\e[0m (x: Long): Long\n\e[31m   |\e[0m (x: Int): Long\n\e[31m   |\e[0m\
    \ (x: Char): Long\n\e[31m   |\e[0m (x: Short): Long\n\e[31m   |\e[0m (x: Byte):\
    \ Long\n\e[31m   |\e[0mmatch arguments (Boolean)\n1 error found\n"
  stdout: ''
  timestamp: 1660003991
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(x => x.toInt == 1)\n       \
    \ val zeros = arr.filter(x => x.toInt == 0)\n        val oneAndZeros = ones.toList\
    \ ++ zeros.toList\n        val sortList = oneAndZeros.sortWith((x,y) => x.toLong\
    \ > y.toLong)\n        sortList.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpqyocr_d3.scala:22)\n\tat Problem.main(tmpqyocr_d3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660003997
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        arr.sortWith(_ < _)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpvflt3x6i.scala:18)\n\tat Problem.main(tmpvflt3x6i.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660003997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        var ones = mutable.MutableList[Long]()\n        var\
    \ decimals = mutable.MutableList[Long]()\n        for (i <- 0 until arr.size)\
    \ {\n            val binary = arr(i).toBinaryString\n            ones += if(binary.contains(\"\
    1\")) 1l else 0l\n            decimals += if(binary.contains(\"1\")) arr(i) else\
    \ None\n        }\n        ones.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpy55sc7mw.scala:19:20 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m            ones += \e[33mif\e[0m(binary.contains(\e\
    [31m\"1\"\e[0m)) \e[31m1l\e[0m \e[33melse\e[0m \e[31m0l\e[0m\n\e[31m\e[31m   |\e\
    [0m                    ^^\e[0m\n\e[31m   |\e[0m                    expression\
    \ expected but \e[31mif\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmpy55sc7mw.scala:20:24 ---------------------------\e[0m\e[0m\n\e[31m20\
    \ |\e[0m            decimals += \e[33mif\e[0m(binary.contains(\e[31m\"1\"\e[0m))\
    \ arr(i) \e[33melse\e[0m None\n\e[31m\e[31m   |\e[0m                        ^^\e\
    [0m\n\e[31m   |\e[0m                        expression expected but \e[31mif\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpy55sc7mw.scala:15:19\
    \ ------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mvar\e[0m \e\
    [36mones\e[0m = mutable.MutableList[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m\
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                   Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpy55sc7mw.scala:16:23\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mvar\e[0m \e\
    [36mdecimals\e[0m = mutable.MutableList[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e\
    [0m                       ^^^^^^^\e[0m\n\e[31m   |\e[0m                      \
    \ Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660003993
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.map(x => if (x == 1l.toLong) 1\n  \
    \      else 0l).toList\n        val zeros = arr.filter(_ == 0l.toLong).toList\n\
    \        val onesZeros = arr.zip(ones).zip(zeros)\n        val sortedArr = onesZeros.sortWith\
    \ { (a, b) => a._2 < b._2 }\n        val sortedZeros = sortedArr.filter(_._1 ==\
    \ 0l.toLong).toList\n        val sortedOnes = sortedArr.filter(_._1 == 1l.toLong).toList\n\
    \        val sortedListOfOnesZeros = sortedZeros.zip(sortedOnes)\n        val\
    \ zeroIndex = sortedListOfOnesZeros.filter(_._2 == 1l.toLong).toList\n       \
    \ val oneIndex = sortedListOfOnesZeros.filter(_._2 == 0l.toLong).toList\n    \
    \    val zerosAndOnes = sortedArr.zip(zeroIndex).zip(oneIndex)\n        val sortedZeroAndOnes\
    \ = sortedZeroAndOnes.sortWith { (a, b) => a._1 < b._1 }\n        sortedZeroAndOnes.filter(_._1\
    \ == 0l.toLong).map(_._2).toList.zip(onesZeros).map(_._1).toList\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp2aht3dwn.scala:20:43 -----------------------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36msortedZeros\e[0m = sortedArr.filter(_._1\
    \ == \e[31m0l\e[0m.toLong).toList\n\e[31m\e[31m   |\e[0m                     \
    \                      ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  Values of types\
    \ (Long, Long) and Long cannot be compared with == or !=\n\e[31m\e[31m-- Error:\
    \ /tmp/tmp2aht3dwn.scala:21:42 -----------------------------------------\e[0m\e\
    [0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36msortedOnes\e[0m = sortedArr.filter(_._1\
    \ == \e[31m1l\e[0m.toLong).toList\n\e[31m\e[31m   |\e[0m                     \
    \                     ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  Values of types\
    \ (Long, Long) and Long cannot be compared with == or !=\n\e[31m\e[31m-- Error:\
    \ /tmp/tmp2aht3dwn.scala:23:53 -----------------------------------------\e[0m\e\
    [0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mzeroIndex\e[0m = sortedListOfOnesZeros.filter(_._2\
    \ == \e[31m1l\e[0m.toLong).toList\n\e[31m\e[31m   |\e[0m                     \
    \                                ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mValues\
    \ of types ((Long, Long), Long) and Long cannot be compared with == or !=\n\e\
    [31m\e[31m-- Error: /tmp/tmp2aht3dwn.scala:24:52 -----------------------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36moneIndex\e[0m = sortedListOfOnesZeros.filter(_._2\
    \ == \e[31m0l\e[0m.toLong).toList\n\e[31m\e[31m   |\e[0m                     \
    \                               ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mValues\
    \ of types ((Long, Long), Long) and Long cannot be compared with == or !=\n\e\
    [31m\e[31m-- [E045] Cyclic Error: /tmp/tmp2aht3dwn.scala:26:32 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36msortedZeroAndOnes\e[0m =\
    \ sortedZeroAndOnes.sortWith { (\e[36ma\e[0m, \e[36mb\e[0m) => a._1 < b._1 }\n\
    \e[31m\e[31m   |\e[0m                                ^\e[0m\n\e[31m   |\e[0m \
    \                           Recursive \e[33mvalue\e[0m \e[35msortedZeroAndOnes\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n5 errors fo"
  stdout: ''
  timestamp: 1660003999
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        arr.sortBy(l => l % 2l.toLong) ++\n            arr.sortBy(l\
    \ => l.toInt).reverse\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpav30cnh0.scala:19)\n\tat Problem.main(tmpav30cnh0.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660004000
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ % 2 == 0).size\n        val\
    \ negs = arr.filter(_ % 2 == 1).size\n\n        if(ones > negs) {\n          \
    \  arr.sortBy(x => (x - ones).toInt)\n        } else if (negs > ones) {\n    \
    \        arr.sortBy(x => (x + negs).toInt)\n        } else {\n            arr.sortBy(x\
    \ => (x - negs).toInt)\n        }\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_zbm6elp.scala:27)\n\tat Problem.main(tmp_zbm6elp.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660004000
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        arr.zipWithIndex.sortBy(l => {\n            if (l._1\
    \ == 0) -1 else l._1.bitLength\n        }).map(x => x._2).map(x => x.toLong).reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmptql04q8g.scala:16:40 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m            \e[33mif\e[0m (l._1 == \e[31m0\e[0m) -\e\
    [31m1\e[0m \e[33melse\e[0m l._1.bitLength\n\e[31m\e[31m   |\e[0m             \
    \                      ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue bitLength is\
    \ not a member of Long @uncheckedVariance, but could be made available as an extension\
    \ method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mThe following import might fix the\
    \ problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.BigInt.long2bigInt\n\
    \e[31m   |\e[0m\n1 error found\n"
  stdout: ''
  timestamp: 1660003999
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val n = arr.length\n        val ones = arr.zipWithIndex.filter(x\
    \ => x._1 == 1)\n        val zeros = arr.zipWithIndex.filter(x => x._1 == 0)\n\
    \        val oneInd = ones.map(x => x._2).sortBy(x => x.toLong)\n        val zeroInd\
    \ = zeros.map(x => x._2).sortBy(x => x.toLong)\n        val onedArr = oneInd.map(_\
    \ => arr(_))\n        val zerodArr = zeroInd.map(_ => arr(_))\n        val maxOneCount\
    \ = ones.maxBy(x => x._2)._2.toLong\n        val maxZeroCount = zeros.maxBy(x\
    \ => x._2)._2.toLong\n        val resultArr = (zeroInd.toList zip oneInd.toList).sortBy(x\
    \ => {\n            val oneCount = x._2.toLong\n            val zeroCount = x._1.toLong\n\
    \            oneCount / maxOneCount > zeroCount / maxZeroCount ? oneCount : zeroCount\n\
    \        }).map(_._1)\n        resultArr.map(x => arr(x))\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong,\
    \ -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong,\
    \ -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmphi_b2oag.scala:27:75 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m            oneCount / maxOneCount > zeroCount / maxZeroCount\
    \ ? oneCount : \e[35mzeroCount\e[0m\n\e[31m\e[31m   |\e[0m                   \
    \                                                        ^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                                               Not found: type zeroCount\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmphi_b2oag.scala:27:62\
    \ ------------------------\e[0m\e[0m\n\e[31m27 |\e[0m            oneCount / maxOneCount\
    \ > zeroCount / maxZeroCount ? oneCount : \e[35mzeroCount\e[0m\n\e[31m\e[31m \
    \  |\e[0m                                                 ^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                         value ? is not a member\
    \ of Long\n\e[31m\e[31m-- Error: /tmp/tmphi_b2oag.scala:28:10 -----------------------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        }).map(_._1)\n\e[31m\e[31m   |\e[0m         \
    \ ^\e[0m\n\e[31m   |\e[0mambiguous given instances: both \e[33mobject\e[0m \e\
    [35mByte\e[0m in \e[33mobject\e[0m \e[35mOrdering\e[0m and \e[33mobject\e[0m \e\
    [35mChar\e[0m in \e[33mobject\e[0m \e[35mOrdering\e[0m match type Ordering[B]\
    \ of parameter ord of \e[33mmethod\e[0m \e[35msortBy\e[0m in \e[33mtrait\e[0m\
    \ \e[35mSeqOps\e[0m\n3 errors found\n"
  stdout: ''
  timestamp: 1660003999
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        arr.toList match {\n            case head :: tail\
    \ =>\n                val m = head % 2\n                val ones = arr.filter(x\
    \ => x % 2 == 0).toList.sorted\n                if (ones.length == 1) head else\
    \ (head + ones(0))\n            case _ => arr.toList\n        }\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5o2s1kip.scala:19:38\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m                \e[33mif\e[0m\
    \ (ones.length == \e[31m1\e[0m) head \e[33melse\e[0m (head + ones(\e[31m0\e[0m))\n\
    \e[31m\e[31m   |\e[0m                                      ^^^^\e[0m\n\e[31m \
    \  |\e[0m                                      Found:    (head : Long)\n\e[31m\
    \   |\e[0m                                      Required: List[Long]\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5o2s1kip.scala:19:49 --------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m                \e[33mif\e[0m (ones.length == \e[31m1\e\
    [0m) head \e[33melse\e[0m (head + ones(\e[31m0\e[0m))\n\e[31m\e[31m   |\e[0m \
    \                                                ^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0m                                                 Found:    Long\n\e[31m\
    \   |\e[0m                                                 Required: \e[1m\e[32mList\e\
    [0m\e[1m\e[32m[\e[0mLong\e[1m\e[32m]\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660004000
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        arr.sortWith(a => a < (arr.last) match {\n       \
    \     case true => false\n            case false => true\n        })\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E086] Syntax Error: /tmp/tmp4divy3di.scala:15:23 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        arr.sortWith(\e[36ma\e[0m => a < (arr.last) \e\
    [33mmatch\e[0m {\n\e[31m\e[31m   |\e[0m                     ^\e[0m\n\e[31m   |\e\
    [0m                     Wrong number of parameters, expected: 2\n\e[31m16 |\e\
    [0m            \e[33mcase\e[0m \e[31mtrue\e[0m => \e[31mfalse\e[0m\n\e[31m17 |\e\
    [0m            \e[33mcase\e[0m \e[31mfalse\e[0m => \e[31mtrue\e[0m\n\e[31m18 |\e\
    [0m        })\n1 error found\n"
  stdout: ''
  timestamp: 1660003995
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        // your code goes here\n        arr.foldLeft(List[Long]())(_\
    \ ++ sortArray(_))\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmprpcl8tac.scala:16:50\
    \ --------------------\e[0m\e[0m\n\e[31m16 |\e[0m        arr.foldLeft(List[\e\
    [35mLong\e[0m]())(_ ++ sortArray(_))\n\e[31m\e[31m   |\e[0m                  \
    \                                ^\e[0m\n\e[31m   |\e[0m                     \
    \                             Found:    (_$2 : Long)\n\e[31m   |\e[0m        \
    \                                          Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660004000
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        var arrList = arr\n        var newArrList = List[Long]()\n\
    \        for (i <- 0 until arrList.size) {\n            if (arrList(i) == 0) {\n\
    \                newArrList ::= arrList(i)\n            } else {\n           \
    \     val m = ((arrList(i) - 1) >>> 0).toInt\n                newArrList ::= (m\
    \ << 1) | arrList(i)\n            }\n        }\n        return newArrList\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp1shb2ew0.scala:28)\n\tat Problem.main(tmp1shb2ew0.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660004002
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        var ans = arr.toList\n        var max = 0L\n     \
    \   var i = 0\n        while (i < arr.length) {\n            if (ans.lastOption.isDefined)\
    \ {\n                max = ans.lastOption.get + max\n            }\n         \
    \   ans += (i.toLong + max / 2).toLong\n            i += max\n            max\
    \ /= 2\n        }\n        ans\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpzw507jv5.scala:22:16 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m            ans += (i.toLong + max / \e[31m2\e[0m).toLong\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^\e[0m\n\e[31m   |\e[0m    value += is not\
    \ a member of List[Long] - did you mean List[Long].!=?\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpzw507jv5.scala:23:14 ------------------------\e[0m\e\
    [0m\n\e[31m23 |\e[0m            i += max\n\e[31m\e[31m   |\e[0m            ^^^^\e\
    [0m\n\e[31m   |\e[0m            value += is not a member of Int - did you mean\
    \ Int.!=?\n2 errors found\n"
  stdout: ''
  timestamp: 1660004001
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        var maxVal = 0L\n        var maxIdx = 0\n        var\
    \ i = 0\n        for(l <- arr) {\n            val current = l\n            var\
    \ j = i\n            for(k <- i + 1 to arr.length) {\n                if(current\
    \ & (1L << k).toLong == current) {\n                    j -= 1\n             \
    \   }\n            }\n            var temp = arr(i)\n            arr(i) = arr(j)\n\
    \            arr(j) = temp\n            maxVal = Math.max(maxVal, arr(i))\n  \
    \          if(maxVal == current) {\n                maxIdx = j\n            }\n\
    \            i += 1\n        }\n        arr.drop(maxIdx).reverse\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmp7cok1b63.scala:22:27 -----------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m                \e[33mif\e[0m(current & (\e[31m1L\e[0m\
    \ << k).toLong == current) {\n\e[31m\e[31m   |\e[0m                   ^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e\
    [35m&\e[0m in \e[33mclass\e[0m \e[35mLong\e[0m with types\n\e[31m   |\e[0m (x:\
    \ Long): Long\n\e[31m   |\e[0m (x: Int): Long\n\e[31m   |\e[0m (x: Char): Long\n\
    \e[31m   |\e[0m (x: Short): Long\n\e[31m   |\e[0m (x: Byte): Long\n\e[31m   |\e\
    [0mmatch arguments (Boolean)\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp7cok1b63.scala:27:12\
    \ ------------------------\e[0m\e[0m\n\e[31m27 |\e[0m            arr(i) = arr(j)\n\
    \e[31m\e[31m   |\e[0m            ^^^\e[0m\n\e[31m   |\e[0m  value update is not\
    \ a member of List[Long] - did you mean arr.updated?\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmp7cok1b63.scala:28:12 ------------------------\e[0m\e[0m\n\
    \e[31m28 |\e[0m            arr(j) = temp\n\e[31m\e[31m   |\e[0m            ^^^\e\
    [0m\n\e[31m   |\e[0m  value update is not a member of List[Long] - did you mean\
    \ arr.updated?\n3 errors found\n"
  stdout: ''
  timestamp: 1660004002
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        if (arr.isEmpty) arr\n        else if (arr.head <\
    \ 0 && arr.tail.head < 0) arr.head :: sortArray(arr.tail)\n        else if (arr.head\
    \ < 0 && arr.tail.head >= 0) arr.head :: sortArray(arr.tail.reverse)\n       \
    \ else if (arr.head >= 0 && arr.tail.head < 0) sortArray(arr.tail)\n        else\
    \ if (arr.head >= 0 && arr.tail.head >= 0) sortArray(arr.tail.reverse)\n     \
    \   else arr\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.util.NoSuchElementException: head of empty list\n\tat scala.collection.immutable.Nil$.head(List.scala:662)\n\
    \tat scala.collection.immutable.Nil$.head(List.scala:661)\n\tat Problem$.sortArray(tmp5ty9xeh3.scala:18)\n\
    \tat Problem$.main(tmp5ty9xeh3.scala:23)\n\tat Problem.main(tmp5ty9xeh3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660004002
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        arr.sortWith((x, y) => x.toLong compareTo y.toLong)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmph9q0mg9l.scala:15:31\
    \ --------------------\e[0m\e[0m\n\e[31m15 |\e[0m        arr.sortWith((\e[36mx\e\
    [0m, \e[36my\e[0m) => x.toLong compareTo y.toLong)\n\e[31m\e[31m   |\e[0m    \
    \                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                               Found:    Int\n\e[31m   |\e[0m               \
    \                Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660004001
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        arr.sortWith(x => {\n            val binStr = x.toString\n\
    \            val bin = binStr.length.toLong\n            val ones = binStr.count('1')\n\
    \            val dec = (bin.toLong - ones) / 2\n            if (ones == bin) true\
    \ else dec > x\n        })\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E086] Syntax Error: /tmp/tmpsqxevsx5.scala:15:23 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        arr.sortWith(\e[36mx\e[0m => {\n\e[31m\e[31m\
    \   |\e[0m                     ^\e[0m\n\e[31m   |\e[0m                     Wrong\
    \ number of parameters, expected: 2\n\e[31m16 |\e[0m            \e[33mval\e[0m\
    \ \e[36mbinStr\e[0m = x.toString\n\e[31m17 |\e[0m            \e[33mval\e[0m \e\
    [36mbin\e[0m = binStr.length.toLong\n\e[31m18 |\e[0m            \e[33mval\e[0m\
    \ \e[36mones\e[0m = binStr.count(\e[31m'1'\e[0m)\n\e[31m19 |\e[0m            \e\
    [33mval\e[0m \e[36mdec\e[0m = (bin.toLong - ones) / \e[31m2\e[0m\n\e[31m20 |\e\
    [0m            \e[33mif\e[0m (ones == bin) \e[31mtrue\e[0m \e[33melse\e[0m dec\
    \ > x\n\e[31m21 |\e[0m        })\n1 error found\n"
  stdout: ''
  timestamp: 1660003999
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        var sortedArr = arr.toList\n        sortedArr.sortBy(x\
    \ => (-(x%2l).compareTo(x)))\n        sortedArr\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp40sg5dsd.scala:20)\n\tat Problem.main(tmp40sg5dsd.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660004004
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        if (arr.isEmpty) {\n            return arr\n     \
    \   }\n        var list = arr.toList\n        list.sortWith((x, y) => if (x %\
    \ 2 == 0 && y % 2 == 0) {\n            x - y\n        } else if (y % 2 == 0) {\n\
    \            y - x\n        } else {\n            x - y\n        })\n        list.toArray\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpsa8wlrob.scala:20:12\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m            x - y\n\e[31m\e[31m\
    \   |\e[0m            ^^^^^\e[0m\n\e[31m   |\e[0m            Found:    Long\n\e\
    [31m   |\e[0m            Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpsa8wlrob.scala:22:12 --------------------\e[0m\e\
    [0m\n\e[31m22 |\e[0m            y - x\n\e[31m\e[31m   |\e[0m            ^^^^^\e\
    [0m\n\e[31m   |\e[0m            Found:    Long\n\e[31m   |\e[0m            Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpsa8wlrob.scala:24:12\
    \ --------------------\e[0m\e[0m\n\e[31m24 |\e[0m            x - y\n\e[31m\e[31m\
    \   |\e[0m            ^^^^^\e[0m\n\e[31m   |\e[0m            Found:    Long\n\e\
    [31m   |\e[0m            Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpsa8wlrob.scala:26:8 ---------------------\e[0m\e\
    [0m\n\e[31m26 |\e[0m        list.toArray\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    \e[1m\e[31mArray\e[0m[Long]\n\e[31m   |\e\
    [0m        Required: \e[1m\e[32mList\e[0m[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660004003
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val l = arr.length\n        val m = 2l\n        var\
    \ i = 0\n        val r = arr\n        var j = l-1\n        var k = m-1\n     \
    \   while (i != j){\n            while ((k <= l) && (r.head(k).asInstanceOf[Long]==1)){\n\
    \                k += 1\n            }\n            val temp = r.tail(k)\n   \
    \         r.tail(k) = r.tail(j)\n            r.tail(j) = temp\n            j +=\
    \ 1\n            i -= 1\n            k += 1\n            k += 1\n        }\n \
    \       arr\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E050] Type Error: /tmp/tmp9dmqlmf_.scala:22:34 -----------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m            \e[33mwhile\e[0m ((k <= l) && (r.head(k).asInstanceOf[\e\
    [35mLong\e[0m]==\e[31m1\e[0m)){\n\e[31m\e[31m   |\e[0m                       \
    \         ^^^^^^\e[0m\n\e[31m   |\e[0m               \e[33mmethod\e[0m \e[35mhead\e\
    [0m in \e[33mtrait\e[0m \e[35mIterableOps\e[0m does not take parameters\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp9dmqlmf_.scala:25:30 --------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m            \e[33mval\e[0m \e[36mtemp\e[0m = r.tail(k)\n\
    \e[31m\e[31m   |\e[0m                              ^\e[0m\n\e[31m   |\e[0m   \
    \                           Found:    (k : Long)\n\e[31m   |\e[0m            \
    \                  Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmp9dmqlmf_.scala:26:12 ------------------------\e[0m\e[0m\n\e[31m26 |\e\
    [0m            r.tail(k) = r.tail(j)\n\e[31m\e[31m   |\e[0m            ^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue update is not a member of List[Long @uncheckedVariance]\
    \ - did you mean List[Long @uncheckedVariance].updated?\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp9dmqlmf_.scala:27:12 ------------------------\e[0m\e\
    [0m\n\e[31m27 |\e[0m            r.tail(j) = temp\n\e[31m\e[31m   |\e[0m      \
    \      ^^^^^^\e[0m\n\e[31m   |\e[0mvalue update is not a member of List[Long @uncheckedVariance]\
    \ - did you mean List[Long @uncheckedVariance].updated?\n4 errors found\n"
  stdout: ''
  timestamp: 1660004003
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        // TODO: Write code here\n        var arr1 = arr.map(_\
    \ => 0)\n        var arr2 = arr.map(_ => 0)\n        var i = 0\n        var j\
    \ = 0\n        var k = 0\n        while(i < arr.length && j < arr.length) {\n\
    \            arr1(i) = arr(i)\n            arr2(j) = arr(j)\n            if(arr1(i)\
    \ == arr2(j)) {\n                arr1(i) += 1\n                arr2(j) += 1\n\
    \                i += 1\n                j += 1\n            } else if(arr1(i)\
    \ < arr2(j)) {\n                arr1(k) = arr1(i)\n                arr1(i) +=\
    \ 1\n                k += 1\n            } else {\n                arr2(k) = arr2(j)\n\
    \                arr2(j) += 1\n                k += 1\n            }\n       \
    \ }\n        if(i < arr.length) {\n            for(x <- 0 until i) {\n       \
    \         arr1(k) = arr1(x)\n                arr2(k) = arr2(x)\n             \
    \   k += 1\n            }\n        }\n        if(j < arr.length) {\n         \
    \   for(x <- 0 until j) {\n                arr1(k) = arr1(x)\n               \
    \ arr2(k) = arr2(j)\n                k += 1\n            }\n        }\n      \
    \  arr1.toList\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmplw3nu0e2.scala:22:12 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m            arr1(i) = arr(i)\n\e[31m\e[31m   |\e[0m \
    \           ^^^^\e[0m\n\e[31m   |\e[0mvalue update is not a member of List[Int]\
    \ - did you mean List[Int].updated?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmplw3nu0e2.scala:23:12\
    \ ------------------------\e[0m\e[0m\n\e[31m23 |\e[0m            arr2(j) = arr(j)\n\
    \e[31m\e[31m   |\e[0m            ^^^^\e[0m\n\e[31m   |\e[0mvalue update is not\
    \ a member of List[Int] - did you mean List[Int].updated?\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmplw3nu0e2.scala:25:24 ------------------------\e[0m\e\
    [0m\n\e[31m25 |\e[0m                arr1(i) += \e[31m1\e[0m\n\e[31m\e[31m   |\e\
    [0m                ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                value += is\
    \ not a member of Int - did you mean Int.!=?\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmplw3nu0e2.scala:26:24 ------------------------\e[0m\e[0m\n\e[31m26\
    \ |\e[0m                arr2(j) += \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m       \
    \         ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                value += is not a member\
    \ of Int - did you mean Int.!=?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmplw3nu0e2.scala:30:16\
    \ ------------------------\e[0m\e[0m\n\e[31m30 |\e[0m                arr1(k) =\
    \ arr1(i)\n\e[31m\e[31m   |\e[0m                ^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ update is not a member of List[Int] - did you mean List[Int].updated?\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmplw3nu0e2.scala:31:24 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m                arr1(i) += \e[31m1\e[0m\n\e[31m\e[31m\
    \   |\e[0m                ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                value\
    \ += is not a member of Int - did you mean Int.!=?\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmplw3nu0e2.scala:34:16 ------------------------\e[0m\e[0m\n\
    \e[31m34 |\e[0m                arr2(k) = arr2(j)\n\e[31m\e[31m   |\e[0m      \
    \          ^^^^\e[0m\n\e[31m   |\e[0mvalue update is not a member of List[Int]\
    \ - did you mean List[Int].updated?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmplw3nu0e2.scala:35:24\
    \ ------------------------\e[0m\e[0m\n\e[31m3"
  stdout: ''
  timestamp: 1660004006
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        var result = Array[Long](arr.size)\n        var count\
    \ = 0\n        arr.foreach(num => {\n            if (num == -1l.toLong) count\
    \ = 0\n            if (num == -2l.toLong) count = -1\n            count = count\
    \ + 1\n            if (count == 0) result = result.updated(count, num)\n     \
    \   })\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp8snvy5kz.scala:23:8\
    \ ---------------------\e[0m\e[0m\n\e[31m23 |\e[0m        result\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    (result : Array[Long])\n\
    \e[31m   |\e[0m        Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660004005
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        var result: List[Long] = Nil\n        var oneCounts\
    \ = mutable.Map[Long, Long]()\n        var negCounts = mutable.Map[Long, Long]()\n\
    \        for(i <- 0 until arr.size) {\n            val i = arr(i)\n          \
    \  if(i < 0) {\n                negCounts += (i.toLong -> 1L)\n            } else\
    \ {\n                oneCounts += (i.toLong -> 1L)\n            }\n        }\n\
    \        val negCount = negCounts.toSeq.sortBy(_._1).reverse\n        val oneCount\
    \ = oneCounts.toSeq.sortBy(_._1).reverse\n        oneCount ::: negCount ::: result\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpjx1jplf0.scala:16:24 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mvar\e[0m \e[36moneCounts\e[0m = mutable.Map[\e\
    [35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                     \
    \   ^^^^^^^\e[0m\n\e[31m   |\e[0m                        Not found: mutable\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpjx1jplf0.scala:17:24\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mvar\e[0m \e\
    [36mnegCounts\e[0m = mutable.Map[\e[35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e\
    [31m   |\e[0m                        ^^^^^^^\e[0m\n\e[31m   |\e[0m           \
    \             Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmpjx1jplf0.scala:19:24 ---------------------------\e[0m\e[0m\n\e[31m19\
    \ |\e[0m            \e[33mval\e[0m \e[36mi\e[0m = arr(i)\n\e[31m\e[31m   |\e[0m\
    \                        ^\e[0m\n\e[31m   |\e[0m                        Recursive\
    \ \e[33mvalue\e[0m \e[35mi\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660004002
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val len = arr.length\n        val map = new mutable.LinkedHashMap[Long,\
    \ Long]()\n        for(i <- 0 until len) {\n            map.put(arr(i), map.getOrElse(arr(i),\
    \ 0l))\n            map.put(arr(i), map.get(arr(i))+1)\n        }\n        val\
    \ res = new mutable.ArrayBuffer[Long]()\n        for(i <- 0 until len) {\n   \
    \         if(map.get(arr(i)) != 0) {\n                res.insert(i, arr(i))\n\
    \            }\n        }\n        res\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpnwtmqeuf.scala:16:22 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mmap\e[0m = \e[33mnew\e[0m\
    \ mutable.LinkedHashMap[\e[35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m   |\e\
    [0m                      ^^^^^^^\e[0m\n\e[31m   |\e[0m                      Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpnwtmqeuf.scala:21:22\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mres\e[0m = \e[33mnew\e[0m mutable.ArrayBuffer[\e[35mLong\e[0m]()\n\e[31m\e\
    [31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m   |\e[0m             \
    \         Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660004003
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        arr.sortWith(_ == 0) || (arr.sortWith(_ == 1) || (arr.sortWith(_\
    \ > 0) && arr.sortWith(_ > 1)))\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E086] Syntax Error: /tmp/tmp8pr9lp8n.scala:15:21 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        arr.sortWith(_ == \e[31m0\e[0m) || (arr.sortWith(_\
    \ == \e[31m1\e[0m) || (arr.sortWith(_ > \e[31m0\e[0m) && arr.sortWith(_ > \e[31m1\e\
    [0m)))\n\e[31m\e[31m   |\e[0m                     ^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                     Wrong number of parameters, expected: 2\n\e[31m\e[31m--\
    \ [E086] Syntax Error: /tmp/tmp8pr9lp8n.scala:15:46 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        arr.sortWith(_ == \e[31m0\e[0m) || (arr.sortWith(_\
    \ == \e[31m1\e[0m) || (arr.sortWith(_ > \e[31m0\e[0m) && arr.sortWith(_ > \e[31m1\e\
    [0m)))\n\e[31m\e[31m   |\e[0m                                              ^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                 Wrong number of parameters,\
    \ expected: 2\n\e[31m\e[31m-- [E086] Syntax Error: /tmp/tmp8pr9lp8n.scala:15:71\
    \ ---------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        arr.sortWith(_\
    \ == \e[31m0\e[0m) || (arr.sortWith(_ == \e[31m1\e[0m) || (arr.sortWith(_ > \e\
    [31m0\e[0m) && arr.sortWith(_ > \e[31m1\e[0m)))\n\e[31m\e[31m   |\e[0m       \
    \                                                                ^^^^^\e[0m\n\e\
    [31m   |\e[0m                                 Wrong number of parameters, expected:\
    \ 2\n\e[31m\e[31m-- [E086] Syntax Error: /tmp/tmp8pr9lp8n.scala:15:94 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        arr.sortWith(_ == \e[31m0\e[0m) || (arr.sortWith(_\
    \ == \e[31m1\e[0m) || (arr.sortWith(_ > \e[31m0\e[0m) && arr.sortWith(_ > \e[31m1\e\
    [0m)))\n\e[31m\e[31m   |\e[0m                                                \
    \                                              ^^^^^\e[0m\n\e[31m   |\e[0m   \
    \                              Wrong number of parameters, expected: 2\n4 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660004004
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val sortedList = mutable.ArrayBuffer.empty[Long]\n\
    \        arr.foreach(x=>\n            if(x>0){\n                sortedList +=\
    \ x\n            }\n        )\n        val sortedList = sortedList.sorted\n  \
    \      val reverseList = sortedList.map(x=>(x>>>1).map(x=>x*2-(x*2>>>1)+1).reduceLeft((x,y)=>(x*2+1)+y)\n\
    \        return reverseList.toList\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpfhxio83o.scala:23:8 ----------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mreturn\e[0m reverseList.toList\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^\e[0m\n\e[31m   |\e[0m        ')' expected, but 'return'\
    \ found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpfhxio83o.scala:21:12 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36msortedList\e[0m = sortedList.sorted\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0msortedList is already defined as \e[33mvalue\e[0m \e[35msortedList\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E006] Not\
    \ Found Error: /tmp/tmpfhxio83o.scala:15:25 ------------------------\e[0m\e[0m\n\
    \e[31m15 |\e[0m        \e[33mval\e[0m \e[36msortedList\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                         ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                         Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpfhxio83o.scala:24:5 ---------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1660004007
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        arr\n            .sortBy(x => countOnes(x))\n    \
    \        .sortBy(x => x.toDouble / 10)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmptzyksi1y.scala:16:25 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m            .sortBy(x => countOnes(x))\n\e[31m\e[31m\
    \   |\e[0m                         ^^^^^^^^^\e[0m\n\e[31m   |\e[0m           \
    \              Not found: countOnes\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- Error: /tmp/tmptzyksi1y.scala:16:38\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m16 |\e[0m       \
    \     .sortBy(x => countOnes(x))\n\e[31m\e[31m   |\e[0m                      \
    \                ^\e[0m\n\e[31m   |\e[0mambiguous given instances: both \e[33mobject\e\
    [0m \e[35mByte\e[0m in \e[33mobject\e[0m \e[35mOrdering\e[0m and \e[33mobject\e\
    [0m \e[35mDeprecatedDoubleOrdering\e[0m in \e[33mobject\e[0m \e[35mOrdering\e\
    [0m match type Ordering[B] of parameter ord of \e[33mmethod\e[0m \e[35msortBy\e\
    [0m in \e[33mtrait\e[0m \e[35mSeqOps\e[0m\n2 errors found\n"
  stdout: ''
  timestamp: 1660004005
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        arr.sortBy { x =>\n            val bs = x.toBinaryString\n\
    \            val bits = bs.substring(bs.length - 1, bs.length)\n            val\
    \ ones = bits.toLong\n            val num = ones - 1\n            if(num == 0)\
    \ num else num.toInt\n        }\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpiqbhhnhx.scala:21:9 ------------------------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        }\n\e[31m\e[31m   |\e[0m         ^\e[0m\n\e[31m\
    \   |\e[0mNo implicit Ordering defined for AnyVal..\n\e[31m   |\e[0mI found:\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m    scala.math.Ordering.ordered[\e[35mAnyVal\e\
    [0m](\n\e[31m   |\e[0m      /* missing */summon[scala.math.Ordering.AsComparable[AnyVal]]\n\
    \e[31m   |\e[0m    )\n\e[31m   |\e[0m\n\e[31m   |\e[0mBut no implicit values were\
    \ found that match type scala.math.Ordering.AsComparable[AnyVal].\n1 error found\n"
  stdout: ''
  timestamp: 1660004010
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val n = arr.length\n        val m = n\n        val\
    \ s = arr.head\n        val v = arr.tail\n\n        // 1. Get sorted index for\
    \ every number\n        // 2. Get sorted value for every index\n        // 3.\
    \ Rearrange the list\n        val newArr = new Array[Long](m)\n        for( i\
    \ <- 0 until m )\n            newArr(i) = i\n\n        var sortedIdx = 0\n   \
    \     var sortedVal = s\n        var i = 0\n        while( i < n ) {\n       \
    \     var j = 0\n            while( j < m ) {\n                if( arr(i) < arr(j)\
    \ ) j++\n                else {\n                    if( sortedIdx == j ) {\n\
    \                        sortedVal = arr(j)\n                        sortedIdx\
    \ = i\n                    }\n                    newArr(i) = arr(j)\n       \
    \             newArr(j) = 0\n                    j++\n                }\n    \
    \        }\n            i++\n        }\n        newArr.toList\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp5algs55x.scala:33:41 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m                \e[33mif\e[0m( arr(i) < arr(j) ) j++\n\
    \e[31m\e[31m   |\e[0m                                         ^\e[0m\n\e[31m \
    \  |\e[0m                                      expression expected but \e[31melse\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp5algs55x.scala:44:15\
    \ ---------------------------\e[0m\e[0m\n\e[31m44 |\e[0m            i++\n\e[31m\e\
    [31m   |\e[0m               ^\e[0m\n\e[31m   |\e[0m               expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660004007
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        arr.sortWith(a => a._2 > a._1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong,\
    \ -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong,\
    \ -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E086] Syntax Error: /tmp/tmp3sj5faxn.scala:15:23 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        arr.sortWith(\e[36ma\e[0m => a._2 > a._1)\n\e\
    [31m\e[31m   |\e[0m                     ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                     Wrong number of parameters, expected: 2\n1 error found\n"
  stdout: ''
  timestamp: 1660004007
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        arr.foldLeft(List.empty[Long]) { (acc, x) => acc append\
    \ (x :: acc.lastOption.getOrElse(List.empty[Long])) }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong,\
    \ -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong,\
    \ -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp9568bi09.scala:15:57 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        arr.foldLeft(List.empty[\e[35mLong\e[0m]) { (\e\
    [36macc\e[0m, \e[36mx\e[0m) => acc append (x :: acc.lastOption.getOrElse(List.empty[\e\
    [35mLong\e[0m])) }\n\e[31m\e[31m   |\e[0m                                    \
    \                 ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m value append is not a member\
    \ of List[Long] - did you mean acc.appended?\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmp9568bi09.scala:15:67 ------------------------\e[0m\e[0m\n\e[31m15\
    \ |\e[0m        arr.foldLeft(List.empty[\e[35mLong\e[0m]) { (\e[36macc\e[0m, \e\
    [36mx\e[0m) => acc append (x :: acc.lastOption.getOrElse(List.empty[\e[35mLong\e\
    [0m])) }\n\e[31m\e[31m   |\e[0m                                              \
    \                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                                   value :: is not a member of Matchable\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660004011
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val arr = arr.sortWith { (a, b) => if (a==1) 1l else\
    \ -1l }\n        // Sorting by decimal value\n        if (arr.isEmpty) arr\n \
    \       else {\n            val cur = arr(1)\n            val curNum = arr.sum\n\
    \            val prev = arr(0)\n            val prevNum = arr.sum * -1\n     \
    \       val prevBin = \"0\"\n            val curBin = Array(prevBin.length, 0).map(\"\
    0\").toList\n            val arr = arr.tail\n            val bin = arr.map(_.toString.toBinaryString).toList\n\
    \            val diff = 1\n            while (diff > 0 && bin.length > 1) {\n\
    \                val preBin = bin.tail\n                val preNum = bin.sum\n\
    \                val curBin = preBin.reverse.zipWithIndex.foldLeft(\"0\") {\n\
    \                    case ((str, i), v) =>\n                        if (i < preBin.length)\
    \ str ++ v.toString else str\n                }\n                val curNum =\
    \ preNum * -1\n                val diff = curNum - prevNum\n                prev\
    \ = cur\n                prevBin = preBin.reverse\n                prevNum = preNum\n\
    \                curBin = preBin.reverse.zipWithIndex.foldLeft(\"0\") { case ((str,\
    \ i), v) =>\n                    if (i < preBin.length) str ++ v.toString else\
    \ str\n                }\n                bin = bin.tail\n            }\n    \
    \        Array(prev, curBin.reverse, diff, arr).filter(_ != 0).toList\n      \
    \  }\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpr3tlm12d.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortWith\
    \ { (\e[36ma\e[0m, \e[36mb\e[0m) => \e[33mif\e[0m (a==\e[31m1\e[0m) \e[31m1l\e\
    [0m \e[33melse\e[0m -\e[31m1l\e[0m }\n\e[31m\e[31m   |\e[0m                  ^\e\
    [0m\n\e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m\
    \ needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpr3tlm12d.scala:25:22\
    \ ---------------------------\e[0m\e[0m\n\e[31m25 |\e[0m            \e[33mval\e\
    [0m \e[36marr\e[0m = arr.tail\n\e[31m\e[31m   |\e[0m                      ^\e\
    [0m\n\e[31m   |\e[0m                      Recursive \e[33mvalue\e[0m \e[35marr\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmpr3tlm12d.scala:37:21\
    \ -----------------------------\e[0m\e[0m\n\e[31m37 |\e[0m                prev\
    \ = cur\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                Reassignment to val prev\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E052]\
    \ Type Error: /tmp/tmpr3tlm12d.scala:38:24 -----------------------------\e[0m\e\
    [0m\n\e[31m38 |\e[0m                prevBin = preBin.reverse\n\e[31m\e[31m   |\e\
    [0m                ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            \
    \    Reassignment to val prevBin\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E052] Type Error:\
    \ /tmp/tmpr3tlm12d.scala:39:24 -----------------------------\e[0m\e[0m\n\e[31m39\
    \ |\e[0m                prevNum = preNum\n\e[31m\e[31m   |\e[0m              \
    \  ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                Reassignment to val prevNum\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmpr3tlm12d.scala:40:23 -----------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m                curBin = preBin.reverse.zipWithInde"
  stdout: ''
  timestamp: 1660004010
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val s = arr.map(v => v.asInstanceOf[Long] & (1 <<\
    \ v.asInstanceOf[Long]) - 1)\n        val m = s.sortWith(_ < _)\n        val r\
    \ = m.toList + m.head\n        r.sortWith(_ > _)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpcv1lsskj.scala:17:25 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = m.toList + m.head\n\
    \e[31m\e[31m   |\e[0m                ^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue + is\
    \ not a member of List[Long], but could be made available as an extension method.\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might make progress\
    \ towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n1 error found\n"
  stdout: ''
  timestamp: 1660004012
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1).toLong\n        val zeros\
    \ = arr.count(_ == 0).toLong\n        if (ones <= zeros) {\n            val s\
    \ = arr.sortWith(_ < _)\n            s\n        } else {\n            val d =\
    \ arr.map(x => x.toString.toInt).sorted\n            val r = d.zip(ones.to(1).toLong).takeWhile(_._2\
    \ != 0).map(_._1)\n            r.sorted\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong,\
    \ -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong,\
    \ -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp5if4kscj.scala:22:37 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m            \e[33mval\e[0m \e[36mr\e[0m = d.zip(ones.to(\e\
    [31m1\e[0m).toLong).takeWhile(_._2 != \e[31m0\e[0m).map(_._1)\n\e[31m\e[31m  \
    \ |\e[0m                          ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ toLong is not a member of scala.collection.immutable.NumericRange.Inclusive[Long],\
    \ but could be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mOne of the following imports might make progress towards fixing the\
    \ problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmp5if4kscj.scala:23:12 --------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            r.sorted\n\e[31m\e[31m   |\e[0m         \
    \   ^^^^^^^^\e[0m\n\e[31m   |\e[0m            Found:    List[\e[1m\e[31mInt\e\
    [0m]\n\e[31m   |\e[0m            Required: List[\e[1m\e[32mLong\e[0m]\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660004011
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val sortedArray = arr sortWith { case (b1, b2) =>\n\
    \            b1.toLong match {\n                case 0 => b2.toLong\n        \
    \        case 1 => 1\n                case _ => b1.toLong.toInt*10 + b2.toLong\n\
    \            }\n        }\n        sortedArray\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpn9poiagk.scala:17:29\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m                \e[33mcase\e\
    [0m \e[31m0\e[0m => b2.toLong\n\e[31m\e[31m   |\e[0m                         \
    \ ^^^^^^^^^\e[0m\n\e[31m   |\e[0m                          Found:    Long\n\e\
    [31m   |\e[0m                          Required: Boolean\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpn9poiagk.scala:18:26 --------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m                \e[33mcase\e[0m \e[31m1\e[0m => \e[31m1\e\
    [0m\n\e[31m\e[31m   |\e[0m                          ^\e[0m\n\e[31m   |\e[0m  \
    \                        Found:    (\e[31m1\e[0m : Int)\n\e[31m   |\e[0m     \
    \                     Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpn9poiagk.scala:19:26 --------------------\e[0m\e\
    [0m\n\e[31m19 |\e[0m                \e[33mcase\e[0m _ => b1.toLong.toInt*\e[31m10\e\
    [0m + b2.toLong\n\e[31m\e[31m   |\e[0m                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                          Found:    Long\n\e[31m   |\e[0m\
    \                          Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660004012
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        arr.sortWith(compareTo)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong,\
    \ -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong,\
    \ -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmppmq1c4zz.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        arr.sortWith(compareTo)\n\e[31m\e[31m   |\e[0m\
    \                     ^^^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not\
    \ found: compareTo\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660004008
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        arr.map { x =>\n            val temp = x.toBinaryString\n\
    \            val numOnes = temp.takeWhile(_ != '0').length\n            val decimal\
    \ = Integer.parseInt(temp.dropWhile(_ != '0').mkString)\n            (numOnes,\
    \ decimal)\n        } sortBy { case (a, b) => a._1 } // Sort the array by number\
    \ of ones\n            .map { case (a, b) =>\n                // If two elements\
    \ have same number of ones, sort by their decimal value\n                if (a\
    \ == b) a._2\n                // If two elements have different number of ones,\
    \ sort by their decimal value reversed\n                else b._2\n          \
    \  } sortBy { case (a, b) => a } // Sort the array by decimal\n            .map\
    \ { case (a, b) => a }\n            .toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E081] Type Error: /tmp/tmp8w0ivox2.scala:20:19 -----------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        } sortBy { \e[33mcase\e[0m (a, b) => a._1 } \e\
    [34m// Sort the array by number of ones\e[0m\n\e[31m\e[31m   |\e[0m          \
    \         ^\e[0m\n\e[31m   |\e[0m   Missing parameter type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m   I could not infer the type of the parameter x$1 of expanded function:\n\
    \e[31m   |\e[0m   x$1 => \n\e[31m   |\e[0m     x$1\e[33m match \e[0m\n\e[31m \
    \  |\e[0m       {\n\e[31m   |\e[0m         \e[33mcase \e[0m(a, b) => \n\e[31m\
    \   |\e[0m           a._1\n\e[31m   |\e[0m       }.\n\e[31m\e[31m-- [E006] Not\
    \ Found Error: /tmp/tmp8w0ivox2.scala:20:34 ------------------------\e[0m\e[0m\n\
    \e[31m20 |\e[0m        } sortBy { \e[33mcase\e[0m (a, b) => a._1 } \e[34m// Sort\
    \ the array by number of ones\e[0m\n\e[31m\e[31m   |\e[0m                    \
    \              ^\e[0m\n\e[31m   |\e[0m                                  Not found:\
    \ a\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E081] Type Error: /tmp/tmp8w0ivox2.scala:26:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m26 |\e[0m            } sortBy\
    \ { \e[33mcase\e[0m (a, b) => a } \e[34m// Sort the array by decimal\e[0m\n\e\
    [31m\e[31m   |\e[0m                       ^\e[0m\n\e[31m   |\e[0m   Missing parameter\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m   I could not infer the type of the parameter\
    \ x$1 of expanded function:\n\e[31m   |\e[0m   x$1 => \n\e[31m   |\e[0m     x$1\e\
    [33m match \e[0m\n\e[31m   |\e[0m       {\n\e[31m   |\e[0m         \e[33mcase\
    \ \e[0m(a, b) => \n\e[31m   |\e[0m           a\n\e[31m   |\e[0m       }.\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp8w0ivox2.scala:26:38 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m            } sortBy { \e[33mcase\e[0m (a, b) => a }\
    \ \e[34m// Sort the array by decimal\e[0m\n\e[31m\e[31m   |\e[0m             \
    \                         ^\e[0m\n\e[31m   |\e[0m                            \
    \          Not found: a\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- Error: /tmp/tmp8w0ivox2.scala:26:13\
    \ --------------------------------"
  stdout: ''
  timestamp: 1660004011
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val numOnes = arr\n            .map{ x => (x >>> 0l)\
    \ }\n            .distinct\n            .foldLeft(mutable.BitSet(0l,arr.length){\n\
    \                case (acc, x) => acc.or(x)\n            }) \n        val maxOnes\
    \ = numOnes.count(x => x != 0l)\n        val bin = arr.map(x => (x >>> 0l).toInt)\n\
    \        val dec = (numOnes zip bin).sortWith((x,y) => x > y)\n        val arr2\
    \ = dec.map{\n            case (x, y) => (x * maxOnes) + y\n        }\n      \
    \  arr2\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpdoi_eb12.scala:18:22 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m            .foldLeft(mutable.BitSet(\e[31m0l\e[0m,arr.length){\n\
    \e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                 Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpdoi_eb12.scala:21:30 ------------------------\e[0m\e\
    [0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mmaxOnes\e[0m = numOnes.count(\e\
    [36mx\e[0m => x != \e[31m0l\e[0m)\n\e[31m\e[31m   |\e[0m                     \
    \ ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue count is not a member of ((Any, Long)\
    \ => Any) => Any - did you mean numOnes.clone?\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmpdoi_eb12.scala:23:27 ------------------------\e[0m\e[0m\n\e[31m23\
    \ |\e[0m        \e[33mval\e[0m \e[36mdec\e[0m = (numOnes zip bin).sortWith((\e\
    [36mx\e[0m,\e[36my\e[0m) => x > y)\n\e[31m\e[31m   |\e[0m                   ^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                value zip is not a member of ((Any, Long)\
    \ => Any) => Any\n3 errors found\n"
  stdout: ''
  timestamp: 1660004013
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val map = new mutable.HashMap[Long, Int]()\n     \
    \   for(num <- arr){\n            val b = new BigInteger(Integer.toBinaryString(num))\n\
    \            if(map.containsKey(b)){\n                map.update(b, (map.get(b)+1))\n\
    \            }else{\n                map.update(b, 1)\n            }\n       \
    \ }\n        val list = arr.sorted((b1, b2) => map.get(b1).compareTo(map.get(b2)))\n\
    \        list.map(x => x.toLong)\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpy6439pr9.scala:15:22 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mmap\e[0m = \e[33mnew\e[0m\
    \ mutable.HashMap[\e[35mLong\e[0m, \e[35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                    ^^^^^^^\e[0m\n\e[31m   |\e[0m                      Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpy6439pr9.scala:17:24\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m            \e[33mval\e[0m\
    \ \e[36mb\e[0m = \e[33mnew\e[0m \e[35mBigInteger\e[0m(Integer.toBinaryString(num))\n\
    \e[31m\e[31m   |\e[0m                        ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                        Not found: type BigInteger\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660004010
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        // sort by binary representation length\n        val\
    \ binArr = arr.sortBy(x => (x.length.bits.toLong, x))\n\n        // sort by decimal\
    \ value\n        binArr.sortBy(x => -x.toString.toDouble.toInt)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpsepry_ve.scala:16:40 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mbinArr\e[0m = arr.sortBy(\e\
    [36mx\e[0m => (x.length.bits.toLong, x))\n\e[31m\e[31m   |\e[0m              \
    \                        ^^^^^^^^\e[0m\n\e[31m   |\e[0m                      \
    \              value length is not a member of Long\n\e[31m\e[31m-- Error: /tmp/tmpsepry_ve.scala:16:63\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m16 |\e[0m       \
    \ \e[33mval\e[0m \e[36mbinArr\e[0m = arr.sortBy(\e[36mx\e[0m => (x.length.bits.toLong,\
    \ x))\n\e[31m\e[31m   |\e[0m                                                 \
    \              ^\e[0m\n\e[31m   |\e[0mambiguous given instances of type Ordering[(T1,\
    \ T2)] found for parameter ord of \e[33mmethod\e[0m \e[35msortBy\e[0m in \e[33mtrait\e\
    [0m \e[35mSeqOps\e[0m.\n\e[31m   |\e[0mI found:\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m    scala.math.Ordering.Tuple2[\e[35mT1\e[0m, \e[35mT2\e[0m](\n\e[31m   |\e\
    [0m      /* ambiguous: both \e[33mobject\e[0m \e[35mByte\e[0m in \e[33mobject\e\
    [0m \e[35mOrdering\e[0m and \e[33mobject\e[0m \e[35mBigDecimal\e[0m in \e[33mobject\e\
    [0m \e[35mOrdering\e[0m match type Ordering[T1] */\n\e[31m   |\e[0m        summon[Ordering[T1]]\n\
    \e[31m   |\e[0m    , scala.math.Ordering.Long)\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mBut both \e[33mobject\e[0m \e[35mByte\e[0m in \e[33mobject\e[0m \e[35mOrdering\e\
    [0m and \e[33mobject\e[0m \e[35mBigDecimal\e[0m in \e[33mobject\e[0m \e[35mOrdering\e\
    [0m match type Ordering[T1].\n2 errors found\n"
  stdout: ''
  timestamp: 1660004013
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val res = arr.sortWith( (x, y) => x < y )\n      \
    \  res.reverse\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpf8hsa94f.scala:19)\n\tat Problem.main(tmpf8hsa94f.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660004015
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        arr.sortWith(compare)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmppqnd2uq_.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        arr.sortWith(compare)\n\e[31m\e[31m   |\e[0m\
    \                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ compare\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660004011
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        arr.sortWith(_ < _)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpvflt3x6i.scala:18)\n\tat Problem.main(tmpvflt3x6i.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660003997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val arr0 = arr.toArray.sortWith((x, y) => math.abs(x\
    \ - y) < 0)\n        val arr1 = arr0.map(x => ((x * 8).ceil.toInt, x)).sortBy(_._1).map(_._2)\n\
    \        val arr2 = arr1.map(x => ((x * 16).ceil.toInt, x)).sortBy(_._1).map(_._2)\n\
    \        val arr3 = arr2.map(x => ((x * 32).ceil.toInt, x)).sortBy(_._1).map(_._2)\n\
    \        val arr4 = arr3.map(x => ((x * 64).ceil.toInt, x)).sortBy(_._1).map(_._2)\n\
    \        arr4.toList\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp4wya21_3.scala:16:42 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36marr1\e[0m = arr0.map(\e\
    [36mx\e[0m => ((x * \e[31m8\e[0m).ceil.toInt, x)).sortBy(_._1).map(_._2)\n\e[31m\e\
    [31m   |\e[0m                                  ^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m      value ceil is not a member of Long.\n\e[31m   |\e[0m      An extension\
    \ method was tried, but could not be fully constructed:\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m          doubleWrapper(x.*(\e[31m8\e[0m))\n\e[31m\e[31m-- Error: /tmp/tmp4wya21_3.scala:16:70\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m16 |\e[0m       \
    \ \e[33mval\e[0m \e[36marr1\e[0m = arr0.map(\e[36mx\e[0m => ((x * \e[31m8\e[0m).ceil.toInt,\
    \ x)).sortBy(_._1).map(_._2)\n\e[31m\e[31m   |\e[0m                          \
    \                                            ^\e[0m\n\e[31m   |\e[0mambiguous\
    \ given instances: both \e[33mobject\e[0m \e[35mByte\e[0m in \e[33mobject\e[0m\
    \ \e[35mOrdering\e[0m and \e[33mobject\e[0m \e[35mChar\e[0m in \e[33mobject\e\
    [0m \e[35mOrdering\e[0m match type Ordering[B] of parameter ord of \e[33mmethod\e\
    [0m \e[35msortBy\e[0m in \e[33mclass\e[0m \e[35mArrayOps\e[0m\n2 errors found\n"
  stdout: ''
  timestamp: 1660004014
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_==1).toList\n        val zeros\
    \ = arr.filter(_==0).toList\n        if (ones.isEmpty) zeros\n        else if\
    \ (zeros.isEmpty) ones\n        else {\n            val (minus, plus) = ones.minBy(x\
    \ => x.toBinaryString).splitAt(ones.size - 1)\n            val sortedZeros   \
    \ = sortArray(zeros)\n            val sortedOnes     = sortArray(plus)\n     \
    \       (sortedZeros ++ sortedOnes)\n                .sortBy(x => x.toDouble)\n\
    \                .zipWithIndex\n                .filter(_._2==0)\n           \
    \     .map(_._1)\n        }\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpni0w9eao.scala:20:66 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m            \e[33mval\e[0m (minus, plus) = ones.minBy(\e\
    [36mx\e[0m => x.toBinaryString).splitAt(ones.size - \e[31m1\e[0m)\n\e[31m\e[31m\
    \   |\e[0m                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                value splitAt is not a member\
    \ of Long\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpni0w9eao.scala:20:17 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m            \e[33mval\e[0m (minus, plus) = ones.minBy(\e\
    [36mx\e[0m => x.toBinaryString).splitAt(ones.size - \e[31m1\e[0m)\n\e[31m\e[31m\
    \   |\e[0m                 ^\e[0m\n\e[31m   |\e[0m                 Recursive \e\
    [33mvalue\e[0m \e[35m$1$\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E045]\
    \ Cyclic Error: /tmp/tmpni0w9eao.scala:20:24 ---------------------------\e[0m\e\
    [0m\n\e[31m20 |\e[0m            \e[33mval\e[0m (minus, plus) = ones.minBy(\e[36mx\e\
    [0m => x.toBinaryString).splitAt(ones.size - \e[31m1\e[0m)\n\e[31m\e[31m   |\e\
    [0m                        ^\e[0m\n\e[31m   |\e[0m                        Recursive\
    \ \e[33mvalue\e[0m \e[35m$1$\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660004014
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        arr.foldLeft((List[Long](), List[Long]()))((acc, x)\
    \ => {\n            val l = acc._2.last + acc\n            if (x == 1l.toLong)\
    \ acc._1 :+ (acc._2.last + x)\n            else acc._2 :+ (l * x)\n        })\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmptqy300_b.scala:16:32 -----------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m            \e[33mval\e[0m \e[36ml\e[0m = acc._2.last\
    \ + acc\n\e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e[35m+\e[0m\
    \ in \e[33mclass\e[0m \e[35mLong\e[0m with types\n\e[31m   |\e[0m (x: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float): Float\n\e[31m   |\e[0m (x: Long): Long\n\
    \e[31m   |\e[0m (x: Int): Long\n\e[31m   |\e[0m (x: Char): Long\n\e[31m   |\e\
    [0m (x: Short): Long\n\e[31m   |\e[0m (x: Byte): Long\n\e[31m   |\e[0m (x: String):\
    \ String\n\e[31m   |\e[0mmatch arguments ((acc : (List[Long], List[Long])))\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmptqy300_b.scala:17:32 --------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m            \e[33mif\e[0m (x == \e[31m1l\e[0m.toLong)\
    \ acc._1 :+ (acc._2.last + x)\n\e[31m\e[31m   |\e[0m                         \
    \       ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                     \
    \           Found:    List[Long]\n\e[31m   |\e[0m                            \
    \    Required: \e[1m\e[32m(\e[0mList[Long\e[1m\e[32m]\e[0m\e[1m\e[32m,\e[0m\e\
    [1m\e[32m \e[0m\e[1m\e[32mList\e[0m\e[1m\e[32m[\e[0m\e[1m\e[32mLong\e[0m]\e[1m\e\
    [32m)\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmptqy300_b.scala:18:17\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m            \e[33melse\e[0m acc._2\
    \ :+ (l * x)\n\e[31m\e[31m   |\e[0m                 ^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                 Found:    List[Long]\n\e[31m   |\e[0m          \
    \       Required: \e[1m\e[32m(\e[0mList[Long\e[1m\e[32m]\e[0m\e[1m\e[32m,\e[0m\e\
    [1m\e[32m \e[0m\e[1m\e[32mList\e[0m\e[1m\e[32m[\e[0m\e[1m\e[32mLong\e[0m]\e[1m\e\
    [32m)\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660004016
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val bin = arr.map(n => math.pow(2,n).toInt).toList\n\
    \        val sorted = bin.sortBy(x => math.floor(math.pow(2,x).toInt))\n     \
    \   bin.foldLeft(List(Long(0l,0l,0l,0l,0l,0l,0l))) { case (acc, n) => acc.zip(sorted.drop(acc.length-1)).collect\
    \ { case (a, b) => if(a == n) b else Long(math.pow(a,b)).toLong }.toList }\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E050] Type Error: /tmp/tmpbivcdthw.scala:17:26 -----------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        bin.foldLeft(List(Long(\e[31m0l\e[0m,\e[31m0l\e\
    [0m,\e[31m0l\e[0m,\e[31m0l\e[0m,\e[31m0l\e[0m,\e[31m0l\e[0m,\e[31m0l\e[0m))) {\
    \ \e[33mcase\e[0m (acc, n) => acc.zip(sorted.drop(acc.length-\e[31m1\e[0m)).collect\
    \ { \e[33mcase\e[0m (a, b) => \e[33mif\e[0m(a == n) b \e[33melse\e[0m Long(math.pow(a,b)).toLong\
    \ }.toList }\n\e[31m\e[31m   |\e[0m                          ^^^^\e[0m\n\e[31m\
    \   |\e[0m                   \e[33mobject\e[0m \e[35mLong\e[0m in \e[33mpackage\e\
    [0m \e[35mscala\e[0m does not take parameters\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E050] Type Error: /tmp/tmpbivcdthw.scala:17:152 ----------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        bin.foldLeft(List(Long(\e[31m0l\e[0m,\e[31m0l\e\
    [0m,\e[31m0l\e[0m,\e[31m0l\e[0m,\e[31m0l\e[0m,\e[31m0l\e[0m,\e[31m0l\e[0m))) {\
    \ \e[33mcase\e[0m (acc, n) => acc.zip(sorted.drop(acc.length-\e[31m1\e[0m)).collect\
    \ { \e[33mcase\e[0m (a, b) => \e[33mif\e[0m(a == n) b \e[33melse\e[0m Long(math.pow(a,b)).toLong\
    \ }.toList }\n\e[31m\e[31m   |\e[0m                                          \
    \                                                                            \
    \                                  ^^^^\e[0m\n\e[31m   |\e[0m                \
    \   \e[33mobject\e[0m \e[35mLong\e[0m in \e[33mpackage\e[0m \e[35mscala\e[0m does\
    \ not take parameters\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660004014
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n      arr.sortBy{case i => (arr.count(_ == i.toBinaryString)\
    \ - arr.count(_ == i.toBinaryString.reverse)) => i.toBinaryString.reverse}\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpkpmg52sl.scala:15:61 -----------------------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m      arr.sortBy{\e[33mcase\e[0m i => (arr.count(_ ==\
    \ i.toBinaryString) - arr.count(_ == i.toBinaryString.reverse)) => i.toBinaryString.reverse}\n\
    \e[31m\e[31m   |\e[0m                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                            not a legal formal parameter\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660004016
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ == 1).length\n        val\
    \ zeros = arr.filter(_ == 0).length\n        val minOne = math.min(ones, zeros)\n\
    \        if(minOne > ones)\n        { arr.sortWith(_ < _) }\n        else if(minOne\
    \ == ones)\n        {\n            arr.sortWith(_ < _)\n        }\n        else\n\
    \        { arr.sortWith(_ < _) }\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpzjapr8j1.scala:28)\n\tat Problem.main(tmpzjapr8j1.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660004018
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = new Array[Int](arr.length).fill(0)\n  \
    \      val twos = new Array[Int](arr.length).fill(0)\n        val decs = new Array[Long](arr.length).fill(0l)\n\
    \        val decOnes = new Array[Long](arr.length).fill(0l)\n        for (i<-\
    \ 0 until arr.length) {\n            val bin = arr(i).toString.toUpperCase\n \
    \           val i = bin.indexOf(\"1\")\n            val j = bin.indexOf(\"2\"\
    )\n            val k = bin.indexOf(\"3\")\n            val l = bin.indexOf(\"\
    4\")\n            ones(i) = 1\n            twos(i) = 2\n            decs(i) =\
    \ bin.substring(0, i).toLong\n            decOnes(i) = decs(i) * ones(i)\n   \
    \     }\n        val sorted = decs.map(dec => dec / decOnes.sum).toList.sort\n\
    \        val sortedOnes = ones\n        val res = sortedOnes.zip(sorted).map(x\
    \ => arr(x._1) + x._2).reverse\n        res\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp0ojfmpkg.scala:15:46 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mones\e[0m = \e[33mnew\e\
    [0m \e[35mArray\e[0m[\e[35mInt\e[0m](arr.length).fill(\e[31m0\e[0m)\n\e[31m\e\
    [31m   |\e[0m                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0m                   value fill is not a member of Array[Int]\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp0ojfmpkg.scala:16:46 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mtwos\e[0m = \e[33mnew\e\
    [0m \e[35mArray\e[0m[\e[35mInt\e[0m](arr.length).fill(\e[31m0\e[0m)\n\e[31m\e\
    [31m   |\e[0m                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0m                   value fill is not a member of Array[Int]\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp0ojfmpkg.scala:17:47 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mdecs\e[0m = \e[33mnew\e\
    [0m \e[35mArray\e[0m[\e[35mLong\e[0m](arr.length).fill(\e[31m0l\e[0m)\n\e[31m\e\
    [31m   |\e[0m                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   value fill is not a member of Array[Long]\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp0ojfmpkg.scala:18:50 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mdecOnes\e[0m = \e[33mnew\e\
    [0m \e[35mArray\e[0m[\e[35mLong\e[0m](arr.length).fill(\e[31m0l\e[0m)\n\e[31m\e\
    [31m   |\e[0m                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                      value fill is not a member of Array[Long]\n\e\
    [31m\e[31m-- [E045] Cyclic Error: /tmp/tmp0ojfmpkg.scala:21:20 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m            \e[33mval\e[0m \e[36mi\e[0m = bin.indexOf(\e\
    [31m\"1\"\e[0m)\n\e[31m\e[31m   |\e[0m                    ^\e[0m\n\e[31m   |\e\
    [0m                    Recursive \e[33mvalue\e[0m \e[35mbin\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n5 errors found\n"
  stdout: ''
  timestamp: 1660004020
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        // TODO: Implement this using sortWith\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpa_xqwyr5.scala:14:51\
    \ --------------------\e[0m\e[0m\n\e[31m14 |\e[0m    \e[33mdef\e[0m \e[36msortArray\e\
    [0m(\e[36marr\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m]) : \e[35mList\e[0m[\e[35mLong\e\
    [0m] = {\n\e[31m\e[31m   |\e[0m                                              \
    \     ^\e[0m\n\e[31m   |\e[0m                                                \
    \   Found:    Unit\n\e[31m   |\e[0m                                          \
    \         Required: List[Long]\n\e[31m15 |\e[0m        \e[34m// TODO: Implement\
    \ this using sortWith\e[0m\n\e[31m16 |\e[0m    }\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660004019
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        // Sort arr by number of ones in binary representation.\n\
    \        // If there are multiple ones in binary representation,\n        // sort\
    \ the ones with lower decimal value.\n        // If there are equal number of\
    \ ones in binary representation\n        // and equal number of ones in decimal\
    \ value,\n        // then sort the ones with lower binary value.\n        // If\
    \ there are equal number of ones in binary representation\n        // and different\
    \ number of ones in decimal value,\n        // then sort the ones with lower decimal\
    \ value.\n        arr.sortWith((x, y) => x.toInt == y.toInt * 2)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp65aygw1_.scala:27)\n\tat Problem.main(tmp65aygw1_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660004021
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ls = arr.map(x => (x, x.toBinaryString))\n   \
    \     ls.toList.sortBy(x => x(1)).map(x => x(1))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmps3akf9v2.scala:16:46\
    \ --------------------\e[0m\e[0m\n\e[31m16 |\e[0m        ls.toList.sortBy(\e[36mx\e\
    [0m => x(\e[31m1\e[0m)).map(\e[36mx\e[0m => x(\e[31m1\e[0m))\n\e[31m\e[31m   |\e\
    [0m                                             ^^^^\e[0m\n\e[31m   |\e[0m   \
    \                                          Found:    String\n\e[31m   |\e[0m \
    \                                            Required: Long\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660004019
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        // Implement here\n        arr.sortBy(_ / 2)\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp9rpjxufl.scala:19)\n\tat Problem.main(tmp9rpjxufl.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660004022
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        arr.sortBy(_.binary.size)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong,\
    \ -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong,\
    \ -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmptsy013bs.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        arr.sortBy(_.binary.size)\n\e[31m\e[31m   |\e\
    [0m                   ^^^^^^^^\e[0m\n\e[31m   |\e[0m                   value binary\
    \ is not a member of Long\n\e[31m\e[31m-- Error: /tmp/tmptsy013bs.scala:15:33\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m15 |\e[0m       \
    \ arr.sortBy(_.binary.size)\n\e[31m\e[31m   |\e[0m                           \
    \      ^\e[0m\n\e[31m   |\e[0mambiguous given instances: both \e[33mobject\e[0m\
    \ \e[35mBigDecimal\e[0m in \e[33mobject\e[0m \e[35mOrdering\e[0m and \e[33mobject\e\
    [0m \e[35mChar\e[0m in \e[33mobject\e[0m \e[35mOrdering\e[0m match type Ordering[B]\
    \ of parameter ord of \e[33mmethod\e[0m \e[35msortBy\e[0m in \e[33mtrait\e[0m\
    \ \e[35mSeqOps\e[0m\n2 errors found\n"
  stdout: ''
  timestamp: 1660004021
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        if (arr.isEmpty) arr.head else arr.sorted.map(x =>\
    \ (x -> (arr.count(y => y & x) == x)))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4i_50rdt.scala:15:29\
    \ --------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mif\e[0m (arr.isEmpty)\
    \ arr.head \e[33melse\e[0m arr.sorted.map(\e[36mx\e[0m => (x -> (arr.count(\e\
    [36my\e[0m => y & x) == x)))\n\e[31m\e[31m   |\e[0m                         ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                         Found:    Long\n\e[31m   |\e[0m \
    \                        Required: \e[1m\e[32mList\e[0m\e[1m\e[32m[\e[0mLong\e\
    [1m\e[32m]\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4i_50rdt.scala:15:81\
    \ --------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mif\e[0m (arr.isEmpty)\
    \ arr.head \e[33melse\e[0m arr.sorted.map(\e[36mx\e[0m => (x -> (arr.count(\e\
    [36my\e[0m => y & x) == x)))\n\e[31m\e[31m   |\e[0m                          \
    \                                                       ^^^^^\e[0m\n\e[31m   |\e\
    [0m                                                       Found:    Long\n\e[31m\
    \   |\e[0m                                                       Required: Boolean\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660004022
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        var newArr: List[Long] = new Array[Long](arr.length)\n\
    \        var sum = 0\n        var i = 0\n        while(i < arr.length) {\n   \
    \         sum = sum + (arr(i).toLong)\n            i += 1\n        }\n       \
    \ var i = 0\n        while(i < arr.length) {\n            val j = (sum - arr(i).toLong).toInt\n\
    \            newArr(j) = arr(i)\n            i += 1\n        }\n        return\
    \ newArr\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpj0nf7mum.scala:22:12 ---------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mvar\e[0m \e[36mi\e[0m = \e[31m0\e[0m\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^\e[0m\n\e[31m   |\e[0mi is already defined\
    \ as \e[33mvariable\e[0m \e[35mi\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj0nf7mum.scala:15:33 --------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mvar\e[0m \e[36mnewArr\e[0m: \e[35mList\e\
    [0m[\e[35mLong\e[0m] = \e[33mnew\e[0m \e[35mArray\e[0m[\e[35mLong\e[0m](arr.length)\n\
    \e[31m\e[31m   |\e[0m                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                 Found:    \e[1m\e[31mArray\e\
    [0m[Long]\n\e[31m   |\e[0m                                 Required: \e[1m\e[32mList\e\
    [0m[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj0nf7mum.scala:19:18\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            sum = sum + (arr(i).toLong)\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                  Found:    Long\n\e[31m   |\e[0m                  Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpj0nf7mum.scala:25:12\
    \ ------------------------\e[0m\e[0m\n\e[31m25 |\e[0m            newArr(j) = arr(i)\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^\e[0m\n\e[31m   |\e[0mvalue update is not\
    \ a member of List[Long] - did you mean List[Long].updated?\n4 errors found\n"
  stdout: ''
  timestamp: 1660004022
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        if (arr.length == 0) return arr\n        val ones\
    \ = arr.filter(_ == 1l).toSet\n        if (ones.size == 0) return arr\n      \
    \  var onesSorted = arr.filter(x => ones(x) == true).toList\n        var reSorted\
    \ = 0L\n        var onesIndex = 0\n        while (onesIndex < onesSorted.length)\
    \ {\n            if (reSorted == 0L) {\n                reSorted = onesSorted(onesIndex)\n\
    \                onesIndex += 1\n            } else if (onesSorted(onesIndex)\
    \ < reSorted) {\n                onesSorted(onesIndex) = reSorted\n          \
    \      onesIndex += 1\n                reSorted = 0L\n            } else {\n \
    \               var temp = onesSorted(onesIndex)\n                onesSorted(onesIndex)\
    \ = reSorted\n                reSorted = temp\n                onesIndex += 1\n\
    \            }\n        }\n        onesSorted.toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong,\
    \ -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong,\
    \ -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpaefy8ndi.scala:26:16 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m                onesSorted(onesIndex) = reSorted\n\e\
    [31m\e[31m   |\e[0m                ^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue update\
    \ is not a member of List[Long] - did you mean List[Long].updated?\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpaefy8ndi.scala:31:16 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m                onesSorted(onesIndex) = reSorted\n\e\
    [31m\e[31m   |\e[0m                ^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue update\
    \ is not a member of List[Long] - did you mean List[Long].updated?\n2 errors found\n"
  stdout: ''
  timestamp: 1660004023
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        arr.sortWith(_ < _)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpvflt3x6i.scala:18)\n\tat Problem.main(tmpvflt3x6i.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660003997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        arr.reverse.foldLeft(arr.sortWith((x, y) => x < y))\
    \ {\n            (acc: List[Long], x: Long) => {\n                if (acc.length\
    \ == 0)\n                    List(x)\n                else if (x % acc.head.isOne)\n\
    \                    acc :+ acc.head\n                else\n                 \
    \   x match {\n                        case 0 => acc :+ acc.head\n           \
    \             case i => acc :+ (acc.head.dec * i)\n                    }\n   \
    \         }\n        }.reverse\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpygk3hy5s.scala:19:38 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m                \e[33melse\e[0m \e[33mif\e[0m (x % acc.head.isOne)\n\
    \e[31m\e[31m   |\e[0m                             ^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                             value isOne is not a member of Long\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpygk3hy5s.scala:24:51 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m                        \e[33mcase\e[0m i => acc :+ (acc.head.dec\
    \ * i)\n\e[31m\e[31m   |\e[0m                                          ^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                       value dec is not a\
    \ member of Long\n2 errors found\n"
  stdout: ''
  timestamp: 1660004024
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        var result: List[Long] = Nil\n        for (n <- arr)\
    \ {\n            if(n != 0) {\n                val bin = n.toBinaryString()\n\
    \                val decimal = bin.filter(_ == '1').length\n                if\
    \ (result contains decimal) {\n                    result = result.sortBy(_ -\
    \ decimal)\n                } else {\n                    result = result :::\
    \ List(decimal)\n                }\n            }\n        }\n        result :::\
    \ arr.sortBy(_ - arr.max)\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpgqg919ds.scala:18:42 -----------------------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m                \e[33mval\e[0m \e[36mbin\e[0m = n.toBinaryString()\n\
    \e[31m\e[31m   |\e[0m                          ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mmissing argument for parameter i of \e[33mmethod\e[0m \e[35mapply\e\
    [0m in \e[33mclass\e[0m \e[35mStringOps\e[0m: (i: Int): Char\n\e[31m\e[31m-- Error:\
    \ /tmp/tmpgqg919ds.scala:21:55 -----------------------------------------\e[0m\e\
    [0m\n\e[31m21 |\e[0m                    result = result.sortBy(_ - decimal)\n\e\
    [31m\e[31m   |\e[0m                                                       ^\e\
    [0m\n\e[31m   |\e[0mambiguous given instances: both \e[33mobject\e[0m \e[35mByte\e\
    [0m in \e[33mobject\e[0m \e[35mOrdering\e[0m and \e[33mobject\e[0m \e[35mChar\e\
    [0m in \e[33mobject\e[0m \e[35mOrdering\e[0m match type Ordering[B] of parameter\
    \ ord of \e[33mmethod\e[0m \e[35msortBy\e[0m in \e[33mtrait\e[0m \e[35mSeqOps\e\
    [0m\n2 errors found\n"
  stdout: ''
  timestamp: 1660004021
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        // Sort the arr array in ascending order using the\
    \ number of ones\n        val zeros = arr.count(_ == 0)\n        if (zeros > 0)\
    \ {\n            val sortedArray = arr.toList.sortBy(x => -x % zeros)\n      \
    \      val zeroIndex = arr.indexOf(zeros)\n            val result = sortedArray.drop(zeroIndex).reverse.take(zeroIndex+1).reverse.take(arr.length).toList.reverse\n\
    \            result\n        } else {\n            arr.toList\n        }\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpco3bkzob.scala:27)\n\tat Problem.main(tmpco3bkzob.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660004025
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        if (arr.size < 2) arr\n        else {\n          \
    \  val twos = arr.filter(_ % 2 == 0)\n            val ones = arr.filter(_ % 2\
    \ == 1)\n            sortArray(ones) ++ sortArray(twos)\n        }\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.StackOverflowError\n\tat scala.collection.immutable.List.filter(List.scala:513)\n\
    \tat Problem$.sortArray(tmpf_jipqqq.scala:17)\n\tat Problem$.sortArray(tmpf_jipqqq.scala:19)\n\
    \tat Problem$.sortArray(tmpf_jipqqq.scala:19)\n\tat Problem$.sortArray(tmpf_jipqqq.scala:19)\n\
    \tat Problem$.sortArray(tmpf_jipqqq.scala:19)\n\tat Problem$.sortArray(tmpf_jipqqq.scala:19)\n\
    \tat Problem$.sortArray(tmpf_jipqqq.scala:19)\n\tat Problem$.sortArray(tmpf_jipqqq.scala:19)\n\
    \tat Problem$.sortArray(tmpf_jipqqq.scala:19)\n\tat Problem$.sortArray(tmpf_jipqqq.scala:19)\n\
    \tat Problem$.sortArray(tmpf_jipqqq.scala:19)\n\tat Problem$.sortArray(tmpf_jipqqq.scala:19)\n\
    \tat Problem$.sortArray(tmpf_jipqqq.scala:19)\n\tat Problem$.sortArray(tmpf_jipqqq.scala:19)\n\
    \tat Problem$.sortArray(tmpf_jipqqq.scala:19)\n\tat Problem$.sortArray(tmpf_jipqqq.scala:19)\n\
    \tat Problem$.sortArray(tmpf_jipqqq.scala:19)\n\tat Problem$.sortArray(tmpf_jipqqq.scala:19)\n\
    \tat Problem$.sortArray(tmpf_jipqqq.scala:19)\n\tat Problem$.sortArray(tmpf_jipqqq.scala:19)\n\
    \tat Problem$.sortArray(tmpf_jipqqq.scala:19)\n\tat Problem$.sortArray(tmpf_jipqqq.scala:19)\n\
    \tat Problem$.sortArray(tmpf_jipqqq.scala:19)\n\tat Problem$.sortArray(tmpf_jipqqq.scala:19)\n\
    \tat Problem$.sortArray(tmpf_jipqqq.scala:19)\n\tat Problem$.sortArray(tmpf_jipqqq.scala:19)\n\
    \tat Problem$.sortArray(tmpf_jipqqq.scala:19)\n\tat Problem$.sortArray(tmpf_jipqqq.scala:19)\n\
    \tat Problem$.sortArray(tmpf_jipqqq.scala:19)\n\tat Problem$.sortArray(tmpf_jipqqq.scala:19)\n\
    \tat Problem$.sortArray(tmpf_jipqqq.scala:19)\n\tat Problem$.sortArray(tmpf_jipqqq.scala:19)\n\
    \tat Problem$.sortArray(tmpf_jipqqq.scala:19)\n\tat Problem$.sortArray(tmpf_jipqqq.scala:19)\n\
    \tat Problem$.sortArray(tmpf_jipqqq.scala:19)\n\tat Problem$.sortArray(tmpf_jipqqq.scala:19)\n\
    \tat Problem$.sortArray(tmpf_jipqqq.scala:19)\n\tat Problem$.sortArray(tmpf_jipqqq.scala:19)\n\
    \tat Problem$.sortArray(tmpf_jipqqq.scala:19)\n\tat Problem$.sortArray(tmpf_jipqqq.scala:19)\n\
    \tat Problem$.sortArray(tmpf_jipqqq.scala:19)\n\tat Problem$.sortArray(tmpf_jipqqq.scala:19)\n\
    \tat Problem$.sortArray(tmpf_jipqqq.scala:19"
  stdout: ''
  timestamp: 1660004024
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        arr.sortWith((x,y) => if (x%2==0) y < x else x < y)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpcrt_53ba.scala:18)\n\tat Problem.main(tmpcrt_53ba.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660004025
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        def getBitCount(arr : List[Long]) : Map[Long, Long]\
    \ = {\n            val bitCount = mutable.Map.empty[Long, Long]\n            for\
    \ (elem <- arr) {\n                val binVal = elem.toBinaryString\n        \
    \        bitCount += binVal -> binVal.length\n            }\n            bitCount\n\
    \        }\n        val bitCount = getBitCount(arr)\n        val sortedBitCount\
    \ = bitCount.toSeq.sortBy(_._1)\n        val sortedLongCount = sortedBitCount.map\
    \ {\n            elem => (elem._2, elem._1)\n        }.toMap\n        arr.map(elem\
    \ => sortedLongCount(elem))\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpe_nb6w_g.scala:16:27 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m            \e[33mval\e[0m \e[36mbitCount\e[0m = mutable.Map.empty[\e\
    [35mLong\e[0m, \e[35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                       \
    \    ^^^^^^^\e[0m\n\e[31m   |\e[0m                           Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660004022
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val m = arr.foldLeft(1L) {\n            (m,v) =>\n\
    \                val m = m + 1\n                ((m.toInt, v.toInt))\n       \
    \ }._1\n        arr.sortWith(compare(arr,m))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpg75imvgs.scala:17:24 ---------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m                \e[33mval\e[0m \e[36mm\e[0m = m + \e\
    [31m1\e[0m\n\e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e\
    [0m                        Recursive \e[33mvalue\e[0m \e[35mm\e[0m needs type\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpg75imvgs.scala:18:17\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m                ((m.toInt, v.toInt))\n\
    \e[31m\e[31m   |\e[0m                 ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                 Found:    (Nothing, (v.toInt : => Int))\n\e[31m   |\e[0m   \
    \              Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpg75imvgs.scala:20:21 ------------------------\e[0m\e[0m\n\e[31m20 |\e\
    [0m        arr.sortWith(compare(arr,m))\n\e[31m\e[31m   |\e[0m               \
    \      ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found: compare\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660004024
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        arr.sortWith(_ >= _)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpj81gu6vn.scala:18)\n\tat Problem.main(tmpj81gu6vn.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660004026
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val bins = arr.map { i => Integer.toBinaryString(i)\
    \ }\n        val counts = bins.groupBy(_.length).mapValues(_.length).toMap\n \
    \       bins.map { bin =>\n            val idx = counts.get bin.length\n     \
    \       val vals = bin.drop(idx)\n            val ones = bin.take(idx)\n     \
    \       val pos = ones.mkString(\".\").length\n            vals zip ones map {\
    \ case (v, o) =>\n                if(v == o) v.toLong else if (v.length < ones.length)\
    \ ones(v.length - pos - 1) else v.charAt(v.length - ones.length) + o\n       \
    \     }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpehuu7_wa.scala:18:36 ---------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m            \e[33mval\e[0m \e[36midx\e[0m = counts.get\
    \ bin.length\n\e[31m\e[31m   |\e[0m                                    ^\e[0m\n\
    \e[31m   |\e[0m                                    expression expected but \e\
    [31m'.'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpehuu7_wa.scala:15:57\
    \ --------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mbins\e\
    [0m = arr.map { \e[36mi\e[0m => Integer.toBinaryString(i) }\n\e[31m\e[31m   |\e\
    [0m                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                    Found:    (i : Long)\n\e\
    [31m   |\e[0m                                                    Required: Int\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpehuu7_wa.scala:23:47\
    \ ------------------------\e[0m\e[0m\n\e[31m23 |\e[0m                \e[33mif\e\
    [0m(v == o) v.toLong \e[33melse\e[0m \e[33mif\e[0m (v.length < ones.length) ones(v.length\
    \ - pos - \e[31m1\e[0m) \e[33melse\e[0m v.charAt(v.length - ones.length) + o\n\
    \e[31m\e[31m   |\e[0m                                             ^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                    value length is not a member\
    \ of Char\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpehuu7_wa.scala:23:76\
    \ ------------------------\e[0m\e[0m\n\e[31m23 |\e[0m                \e[33mif\e\
    [0m(v == o) v.toLong \e[33melse\e[0m \e[33mif\e[0m (v.length < ones.length) ones(v.length\
    \ - pos - \e[31m1\e[0m) \e[33melse\e[0m v.charAt(v.length - ones.length) + o\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                  ^^^^^^^^\e[0m\n\e[31m   |\e[0m                            \
    \        value length is not a member of Char\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmpehuu7_wa.scala:23:101 -----------------------\e[0m\e[0m\n\e[31m23\
    \ |\e[0m                \e[33mif\e[0m(v == o) v.toLong \e[3"
  stdout: ''
  timestamp: 1660004026
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        arr.sortWith(compare)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmppqnd2uq_.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        arr.sortWith(compare)\n\e[31m\e[31m   |\e[0m\
    \                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ compare\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660004011
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        var bin = arr.map(_.toString(2)).map(x => x % 2 ==\
    \ 0).map(x => x.toLong)\n        bin.sortWith(x => x._1 < x._2)\n        bin.reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpukya5sno.scala:15:37 -----------------------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mvar\e[0m \e[36mbin\e[0m = arr.map(_.toString(\e\
    [31m2\e[0m)).map(\e[36mx\e[0m => x % \e[31m2\e[0m == \e[31m0\e[0m).map(\e[36mx\e\
    [0m => x.toLong)\n\e[31m\e[31m   |\e[0m                                     ^\e\
    [0m\n\e[31m   |\e[0m         too many arguments for \e[33mmethod\e[0m \e[35mtoString\e\
    [0m in \e[33mclass\e[0m \e[35mAny\e[0m: (): String\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmpukya5sno.scala:15:52 ------------------------\e[0m\e[0m\n\
    \e[31m15 |\e[0m        \e[33mvar\e[0m \e[36mbin\e[0m = arr.map(_.toString(\e[31m2\e\
    [0m)).map(\e[36mx\e[0m => x % \e[31m2\e[0m == \e[31m0\e[0m).map(\e[36mx\e[0m =>\
    \ x.toLong)\n\e[31m\e[31m   |\e[0m                                           \
    \       ^^^\e[0m\n\e[31m   |\e[0mvalue % is not a member of String, but could\
    \ be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mThe\
    \ following import might make progress towards fixing the problem:\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m\
    \   |\e[0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpukya5sno.scala:15:73\
    \ ------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mvar\e[0m \e\
    [36mbin\e[0m = arr.map(_.toString(\e[31m2\e[0m)).map(\e[36mx\e[0m => x % \e[31m2\e\
    [0m == \e[31m0\e[0m).map(\e[36mx\e[0m => x.toLong)\n\e[31m\e[31m   |\e[0m    \
    \                                                                   ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue toLong is not a member of Nothing, but could be made\
    \ available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the\
    \ following imports might fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m \
    \ import Byte.byte2double\n\e[31m   |\e[0m  import Byte.byte2float\n\e[31m   |\e\
    [0m  import Byte.byte2int\n\e[31m   |\e[0m  import Byte.byte2long\n\e[31m   |\e\
    [0m  import Byte.byte2short\n\e[31m   |\e[0m  import Char.char2double\n\e[31m\
    \   |\e[0m  import Char.char2float\n\e[31m   |\e[0m  import Char.char2int\n\e\
    [31m   |\e[0m  import Char.char2long\n\e[31m   |\e[0m  import math.BigDecimal.javaBigDecimal2bigDecimal\n\
    \e[31m   |\e[0m\n\e[31m\e[31m-- [E08"
  stdout: ''
  timestamp: 1660004027
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        arr.sortWith(x => isOnes(x)).sortWith(x => isNegative(x))\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E086] Syntax Error: /tmp/tmpxspwv7ym.scala:15:23 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        arr.sortWith(\e[36mx\e[0m => isOnes(x)).sortWith(\e\
    [36mx\e[0m => isNegative(x))\n\e[31m\e[31m   |\e[0m                     ^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                     Wrong number of parameters, expected:\
    \ 2\n\e[31m\e[31m-- [E086] Syntax Error: /tmp/tmpxspwv7ym.scala:15:48 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        arr.sortWith(\e[36mx\e[0m => isOnes(x)).sortWith(\e\
    [36mx\e[0m => isNegative(x))\n\e[31m\e[31m   |\e[0m                          \
    \                    ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                \
    \                 Wrong number of parameters, expected: 2\n2 errors found\n"
  stdout: ''
  timestamp: 1660004023
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val result = new mutable.ListBuffer[Long]()\n    \
    \    for (i <- arr.length) {\n            result.clear()\n            i match\
    \ {\n                case 0    => result.add(i)\n                case 1    =>\
    \ result.add(i + arr.length)\n                case 2    => result.add(i * 2 +\
    \ arr.length)\n                case 3    => result.add(i * 3 + arr.length)\n \
    \               case 4    => result.add(i * 4  + arr.length)\n               \
    \ case _    => println(\"Invalid element: \" + i)\n            }\n           \
    \ var ones = 0\n            var decimal = 0\n            var j = 0\n         \
    \   var maxDecimal = 0\n            while (j < arr.length) {\n               \
    \ ones += arr(j)\n                decimal += arr(j)\n                j += 4\n\
    \                maxDecimal = if (maxDecimal < decimal) decimal else maxDecimal\n\
    \            }\n            var onesNeg = false\n            var zerosNeg = false\n\
    \            while (j < arr.length) {\n                onesNeg = !ones\n     \
    \           zerosNeg = !arr(j)\n                if (onesNeg && zerosNeg) {\n \
    \                   result.add((decimal * -1).toLong + arr.length)\n         \
    \           decimal = 0\n                    maxDecimal = 0\n                }\
    \ else {\n                    result.add(ones ? arr(j) : arr.length)\n       \
    \             ones = false\n                }\n                j += 4\n      \
    \          maxDecimal = if (maxDecimal < decimal) decimal else maxDecimal\n  \
    \          }\n            result.addAll(arr(arr.length - maxDecimal.toInt))\n\
    \            result.sortWith(compareNumbers)\n        }\n        result.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpge1kun8_.scala:15:25 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m             \
    \            ^^^^^^^\e[0m\n\e[31m   |\e[0m                         Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpge1kun8_.scala:16:18\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mfor\e[0m (i\
    \ <- arr.length) {\n\e[31m\e[31m   |\e[0m                  ^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                  value foreach is not a member of Int\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660004028
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val bitSet = arr.map(v => (v.toInt, v.toBinaryString)).toMap\n\
    \        val bitSet2 = arr.map(v => (v.toInt, v.toString.reverse)).toMap\n   \
    \     val keys = arr.filter(v => (v.toInt == 0)).sorted\n        val vals = arr.filter(v\
    \ => (v.toInt == 1)).sorted\n        val bits = arr.map(v => (v.toInt, v.toBinaryString)).toMap\n\
    \        val bits2 = arr.map(v => (v.toInt, v.toString.reverse)).toMap\n     \
    \   if (arr.size == 0) arr.toList\n        else {\n            val list = new\
    \ mutable.ListBuffer[Long]()\n            val ones = mutable.ListBuffer[Int]()\n\
    \            val zeros = mutable.ListBuffer[Int]()\n            var count = 0\n\
    \            keys.foreach { k =>\n                val res = bits.get(k)\n    \
    \            val res2 = bits2.get(k)\n                if (res != 0) {\n      \
    \              if (count > 0) list.add(count, \"1\")\n                    ones\
    \ += res.toInt\n                }\n                if (res2 != 0) {\n        \
    \            if (count > 0) list.add(count, \"0\")\n                    zeros\
    \ += res2.toInt\n                }\n                count += 1\n            }\n\
    \            val zeros = zeros map {\n                case 0 => 0\n          \
    \      case 1 => -1\n                case _ => 0\n            }\n            val\
    \ ones = ones map {\n                case 0 => -1\n                case 1 => 0\n\
    \                case _ => 0\n            }\n            val diff = zeros diff\
    \ ones\n            val index = diff zip (ones) filter (_ == -1) map {\n     \
    \           case (val, 1) => val\n                case (val, -1) => val\n    \
    \        }\n            val zero = diff.toSet map {\n                case val\
    \ => val // or val.toInt, which is not the same as val => val.toInt\n        \
    \    }\n            val one = ones - zero\n            val sortedKeys = index\
    \ map (_ + key)\n            val zeros = zero map (one)\n            val result\
    \ = sortedKeys ++ zeros\n            list.toList\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong,\
    \ -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong,\
    \ -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpf8iilgg0.scala:52:22 ---------------------------\e\
    [0m\e[0m\n\e[31m52 |\e[0m                \e[33mcase\e[0m (\e[33mval\e[0m, \e[31m1\e\
    [0m) => \e[33mval\e[0m\n\e[31m\e[31m   |\e[0m                      ^^^\e[0m\n\e\
    [31m   |\e[0m                      pattern expected\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E032] Syntax Error: /tmp/tmpf8iilgg0.scala:52:36 ---------------------------\e\
    [0m\e[0m\n\e[31m52 |\e[0m                \e[33mcase\e[0m (\e[33mval\e[0m, \e[31m1\e\
    [0m) => \e[33mval\e[0m\n\e[31m\e[31m   |\e[0m                                \
    \    ^\e[0m\n\e[31m   |\e[0m                                    pattern expected\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpf8iilgg0.scala:56:21\
    \ ---------------------------\e[0m\e[0m\n\e[31m56 |\e[0m                \e[33mcase\e\
    [0m \e[33mval\e[0m => \e[33mval\e[0m \e[34m// or val.toInt, which is not the same\
    \ as val => val.toInt\e[0m\n\e[31m\e[31m   |\e[0m                     ^^^\e[0m\n\
    \e[31m   |\e[0m                     pattern expected\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpf8iilgg0.scala:40:16 ---------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m            \e[33mval\e[0m \e[36mzeros\e[0m = zeros map\
    \ {\n\e[31m\e[31m   |\e[0m            ^\e[0m\n\e[31m   |\e[0mzeros is already\
    \ defined as \e[33mvalue\e[0m \e[35mzeros\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m41 |\e[0m                \e[33mcase\e[0m \e[31m0\e[0m =>\
    \ \e[31m0\e[0m\n\e[31m42 |\e[0m                \e[33mcase\e[0m \e[31m1\e[0m =>\
    \ -\e[31m1\e[0m\n\e[31m43 |\e[0m                \e[33mcase\e[0m _ => \e[31m0\e\
    [0m\n\e[31m44 |\e[0m            }\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpf8iilgg0.scala:45:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m45 |\e[0m            \e[33mval\e\
    [0m \e[36mones\e[0m = ones map {\n\e[31m\e[31m   |\e[0m            ^\e[0m\n\e\
    [31m   |\e[0mones is already defined "
  stdout: ''
  timestamp: 1660004029
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        if (arr.isEmpty) arr\n        else {\n           \
    \ val ones = arr.count(x => x == 1l)\n            val maxOnes = arr.count(x =>\
    \ x == 0l)\n            val negOnes = arr.count(x => x == -1l)\n            val\
    \ sortOrder = math.max((ones / negOnes), maxOnes)\n            if (sortOrder >\
    \ 0) arr.sortWith(a => sortOrder * (a compare 0l))\n            else arr.sortWith(a\
    \ => math.max(a.toInt, 0))\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E086] Syntax Error: /tmp/tmp4zx110z3.scala:21:46 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m            \e[33mif\e[0m (sortOrder > \e[31m0\e[0m)\
    \ arr.sortWith(\e[36ma\e[0m => sortOrder * (a compare \e[31m0l\e[0m))\n\e[31m\e\
    [31m   |\e[0m                                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                 Wrong number of parameters,\
    \ expected: 2\n\e[31m\e[31m-- [E086] Syntax Error: /tmp/tmp4zx110z3.scala:22:32\
    \ ---------------------------\e[0m\e[0m\n\e[31m22 |\e[0m            \e[33melse\e\
    [0m arr.sortWith(a => math.max(a.toInt, \e[31m0\e[0m))\n\e[31m\e[31m   |\e[0m\
    \                              ^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                              Wrong number of parameters, expected: 2\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660004026
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        if (arr.isEmpty)\n            return arr\n       \
    \ if (arr.length == 1)\n            return List(arr(0))\n        val mn = arr.min\n\
    \        val mx = arr.max\n        val ones = arr.filter(x => x.toInt == 1)\n\
    \        val twos = arr.filter(x => x.toInt == 2)\n        val threes = arr.filter(x\
    \ => x.toInt == 3)\n        val fours = arr.filter(x => x.toInt == 4)\n      \
    \  val fives = arr.filter(x => x.toInt == 5)\n        val sixes = arr.filter(x\
    \ => x.toInt == 6)\n        val sevens = arr.filter(x => x.toInt == 7)\n     \
    \   val eights = arr.filter(x => x.toInt == 8)\n        val nines = arr.filter(x\
    \ => x.toInt == 9)\n        val hundreds = arr.filter(x => x.toInt % 100 == 0)\n\
    \        val thousands = arr.filter(x => x.toInt % 1000 == 0)\n        val tens\
    \ = arr.filter(x => x.toInt % 10 == 0)\n        val elevens = arr.filter(x =>\
    \ x.toInt % 11 == 0)\n        val twelves = arr.filter(x => x.toInt % 12 == 0)\n\
    \        val ones = ones.sorted\n        val twos = twos.sorted\n        val threes\
    \ = threes.sorted\n        val fours = fours.sorted\n        val fives = fives.sorted\n\
    \        val sixes = sixes.sorted\n        val sevens = sevens.sorted\n      \
    \  val eights = eights.sorted\n        val nines = nines.sorted\n        val hundreds\
    \ = hundreds.sorted\n        val thousands = thousands.sorted\n        val tens\
    \ = tens.sorted\n        val elevens = elevens.sorted\n        val twelves = twelves.sorted\n\
    \        val arr = ones + twos + threes + fours + fives + sixes + sevens + eights\
    \ + nines + hundreds + thousands + tens + elevens + twelves\n        arr.map(x\
    \ => if (x == mn) 0 else x)\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp5ms0rtw3.scala:35:12 ---------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e[36mones\e[0m = ones.sorted\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mones\
    \ is already defined as \e[33mvalue\e[0m \e[35mones\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp5ms0rtw3.scala:36:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m\
    \ \e[36mtwos\e[0m = twos.sorted\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mtwos is already defined as \e[33mvalue\e[0m \e[35mtwos\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp5ms0rtw3.scala:37:12 ---------------------------\e[0m\e[0m\n\e[31m37\
    \ |\e[0m        \e[33mval\e[0m \e[36mthrees\e[0m = threes.sorted\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mthrees is already\
    \ defined as \e[33mvalue\e[0m \e[35mthrees\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp5ms0rtw3.scala:38:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m\
    \ \e[36mfours\e[0m = fours.sorted\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mfours is already defined as \e[33mvalue\e[0m \e[35mfours\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp5ms0rtw3.scala:39:12 ---------------------------\e[0m\e[0m\n\e\
    [31m39 |\e[0m        \e[33mval\e[0m \e[36mfives\e[0m = fives.sorted\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mfives is already\
    \ defined as \e[33mvalue\e[0m \e[35mfives\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161]"
  stdout: ''
  timestamp: 1660004026
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val bits = arr.map(x => x.toInt)\n        val count\
    \ = new HashMap[Int, Int]()\n        for (i <- 0 until bits.length) {\n      \
    \      val b = bits(i)\n            if (b <= 0) break\n            if (count.contains(b))\
    \ {\n                count(b) = count(b) + 1\n            } else {\n         \
    \       count(b) = 1\n            }\n        }\n        val sortedList = mutable.Buffer.empty[Long]\n\
    \        for (k <- 0 until count.size) {\n            val v = count(k)\n     \
    \       val bit = 1 << k\n            val pos = bit - 1\n            for (i <-\
    \ 0 until bits.length) {\n                val b = bits(i)\n                if\
    \ (b <= 0 || b == bit) continue\n                if (b <= pos) break\n       \
    \         val bitCount = count(b) - 1\n                val min = (1 << (pos -\
    \ b - 1))\n                val max = (1 << (pos + b - 1))\n                if\
    \ (v <= min && (v & min) == 0) sortedList += b\n                if (v <= max &&\
    \ (v & max) == 0) sortedList += b\n            }\n        }\n        sortedList.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmprvtgx09x.scala:19:24 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m            \e[33mif\e[0m (b <= \e[31m0\e[0m) break\n\
    \e[31m\e[31m   |\e[0m                        ^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                   Not found: break\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmprvtgx09x.scala:26:25 ------------------------\e[0m\e\
    [0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36msortedList\e[0m = mutable.Buffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                         ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                         Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmprvtgx09x.scala:33:40 ------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m                \e[33mif\e[0m (b <= \e[31m0\e[0m || b\
    \ == bit) continue\n\e[31m\e[31m   |\e[0m                                    \
    \    ^^^^^^^^\e[0m\n\e[31m   |\e[0m                                        Not\
    \ found: continue\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmprvtgx09x.scala:34:30\
    \ ------------------------\e[0m\e[0m\n\e[31m34 |\e[0m                \e[33mif\e\
    [0m (b <= pos) break\n\e[31m\e[31m   |\e[0m                              ^^^^^\e\
    [0m\n\e[31m   |\e[0m                              Not found: break\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1660004027
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        // Convert list to array of ints\n        val arr\
    \ = arr.map(_.toInt)\n        \n        // Count the number of 1s and store in\
    \ counts\n        val counts = arr.map(x => if(x != 0) 1 else 0)\n        val\
    \ numOnes = counts.sum\n        val ones = counts.map(x => x/numOnes)\n      \
    \  \n        // Find the maximum of numOnes and store in maxNumOnes\n        val\
    \ maxNumOnes = max(numOnes)\n        val maxOnes = max(ones)\n        \n     \
    \   // Create empty list of sorted numbers\n        val res = new Array[Long](numOnes+maxNumOnes)\n\
    \        \n        // Sort the counts\n        var i = 0\n        while(i < numOnes)\
    \ {\n            val j = numOnes - i\n            val k = maxNumOnes - j\n   \
    \         val count = counts(i)\n            \n            // Assign max to numOnes\n\
    \            if(count > maxOnes(k)) {\n                res(k) = maxNumOnes\n \
    \           }\n            else {\n                res(k) = j\n            }\n\
    \            \n            // Assign j to maxNumOnes\n            if(count > maxOnes(k))\
    \ {\n                res(maxNumOnes + k + 1) = j\n            }\n            else\
    \ {\n                res(maxNumOnes + k) = maxOnes(k)\n            }\n       \
    \     i += 1\n        }\n        \n        // Assign the rest of the counts to\
    \ the remaining parts\n        var j = 0\n        while(j < maxNumOnes) {\n  \
    \          val k = maxNumOnes - j\n            res(k) = counts(j)\n          \
    \  j += 1\n        }\n        \n        res\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpkggb65kk.scala:16:18 ---------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.map(_.toInt)\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpkggb65kk.scala:63:8 ---------------------\e\
    [0m\e[0m\n\e[31m63 |\e[0m        res\n\e[31m\e[31m   |\e[0m        ^^^\e[0m\n\e\
    [31m   |\e[0m        Found:    (res : Array[Long])\n\e[31m   |\e[0m        Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660004031
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n      arr.sortWith( (x,y) => compare(x,y) < 0 ||\n       \
    \                         compare(y,x) > 0 )\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp6kti7bkr.scala:15:29 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m      arr.sortWith( (\e[36mx\e[0m,\e[36my\e[0m) => compare(x,y)\
    \ < \e[31m0\e[0m ||\n\e[31m\e[31m   |\e[0m                             ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                             Not found: compare\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660004029
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val onesCount = arr.filter(x => x.toInt == 1).size\n\
    \        val zerosCount = arr.filter(x => x.toInt == 0).size\n\n        // count\
    \ number of ones first\n        if(onesCount > 0) {\n            val ones = arr.filter(x\
    \ => x.toInt == 1)\n            val sortedOnes = ones.sortBy((x) => -x.toInt)\n\
    \            val onesIndex = ones.indexOf(onesCount)\n            val zeros =\
    \ arr.filter(x => x.toInt == 0)\n            val sortedZeros = zeros.sortBy((x)\
    \ => -x.toInt)\n            val zerosIndex = zeros.indexOf(zerosCount)\n     \
    \       val mergedArray = sortedOnes.drop(onesIndex).drop(zerosIndex)\n      \
    \      mergedArray\n        }\n        else {\n            val zerosCount = arr.filter(x\
    \ => x.toInt == 0).size\n            val zeros = arr.filter(x => x.toInt == 0)\n\
    \            val sortedZeros = zeros.sortBy((x) => -x.toInt)\n            val\
    \ zerosIndex = zeros.indexOf(zerosCount)\n            val mergedArray = sortedZeros.drop(zerosIndex)\n\
    \            mergedArray\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpiri8xbs6.scala:39)\n\tat Problem.main(tmpiri8xbs6.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660004035
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        //implement your algorithm here\n        val bin =\
    \ new Array[String](arr.length)\n        arr.foreach { i =>\n            bin(i)\
    \ = (i.toString.reverse.charAt(0) == '1' ? 1 : 0)\n        }\n        val ones\
    \ = mutable.TreeSet[Long]()\n        val zeros = mutable.TreeSet[Long]()\n   \
    \     val arr = bin.zipWithIndex.foreach { case (k, v) =>\n            if (v ==\
    \ 0) {\n                zeros.add(k)\n            } else {\n                ones.add(k)\n\
    \            }\n        }\n        var i = 0\n        while (i < ones.size) {\n\
    \            arr.sortBy(i => ones.get(i - 1))\n            i += 1\n        }\n\
    \        i += 1\n        while (i < zeros.size) {\n            arr.sortBy(i =>\
    \ zeros.get(i - 1))\n            i += 1\n        }\n        return arr.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpz__akymw.scala:22:18 ---------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = bin.zipWithIndex.foreach\
    \ { \e[33mcase\e[0m (k, v) =>\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\
    \e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35mbin\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpz__akymw.scala:20:19\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mones\e[0m = mutable.TreeSet[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m    \
    \               ^^^^^^^\e[0m\n\e[31m   |\e[0m                   Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpz__akymw.scala:21:20\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mzeros\e[0m = mutable.TreeSet[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660004029
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        arr.sortWith(compare)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmppqnd2uq_.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        arr.sortWith(compare)\n\e[31m\e[31m   |\e[0m\
    \                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ compare\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660004011
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = mutable.ListBuffer[Long]()\n        val\
    \ onesCount = mutable.ListBuffer[Int]()\n        val decs = mutable.ListBuffer[Long]()\n\
    \        arr.foreach{el =>\n            // use if instead of else to avoid duplicate\
    \ computation\n            if (el.toInt == 0) {\n                ones.append(el)\n\
    \                onesCount.append(0)\n            } else {\n                val\
    \ binary = el.toBinaryString\n                val decValue = binary.reverse.map(_.toInt).map(Integer.parseInt(_)).toList.sorted\n\
    \                onesCount.append(decValue.length)\n                ones.append(decValue)\n\
    \                decs.append(decValue)\n            }\n        }\n\n        val\
    \ onesArray = ones.toArray\n        val onesCount = onesCount.toArray\n      \
    \  val decArray = decs.toArray\n        val newArr = new Array[Long](onesCount.length)\n\
    \        val newCount = new Array[Int](onesCount.length)\n        var i = 0\n\
    \        onesCount.foreach(c => {\n            newArr(i) = onesArray(i + c)\n\
    \            newCount(i) = onesCount(i + c)\n            i += c\n        })\n\n\
    \        onesCount.foreach(c => {\n            val arr2 = decArray.slice(i + c,\
    \ i + c)\n            val arr3 = decArray.slice(i + c)\n            val arr4 =\
    \ decArray.slice(i + c)\n            val arr5 = decArray.slice(i + c)\n      \
    \      val arr6 = decArray.slice(i + c)\n            val arr7 = decArray.slice(i\
    \ + c)\n            val arr8 = decArray.slice(i + c)\n            val arr9 = decArray.slice(i\
    \ + c)\n            val arr10 = decArray.slice(i + c)\n            val arr11 =\
    \ decArray.slice(i + c)\n            val arr12 = decArray.slice(i + c)\n     \
    \       val arr13 = decArray.slice(i + c)\n            val arr14 = decArray.slice(i\
    \ + c)\n            val arr15 = decArray.slice(i + c)\n            val arr16 =\
    \ decArray.slice(i + c)\n            val arr17 = decArray.slice(i + c)\n     \
    \       val arr18 = decArray.slice(i + c)\n            val arr19 = decArray.slice(i\
    \ + c)\n            val arr20 = decArray.slice(i + c)\n            val arr21 =\
    \ decArray.slice(i + c)\n            val arr22 = decArray.slice(i + c)\n     \
    \       val arr23 = decArray.slice(i + c)\n            val arr24 = decArray.slice\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpc68vtt6p.scala:69:4 ----------------------------\e\
    [0m\e[0m\n\e[31m69 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[31m\e[31m   |\e[0m    ^^^\e[0m\n\e\
    [31m   |\e[0m    ')' expected, but 'def' found\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tmpc68vtt6p.scala:81:0 ----------------------------\e[0m\e[0m\n\e[31m81\
    \ |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpc68vtt6p.scala:33:12 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36monesCount\e[0m = onesCount.toArray\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0monesCount is already defined as \e[33mvalue\e[0m \e[35monesCount\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpc68vtt6p.scala:15:19 ------------------------\e[0m\e[0m\n\e[31m15 |\e\
    [0m        \e[33mval\e[0m \e[36mones\e[0m = mutable.ListBuffer[\e[35mLong\e[0m]()\n\
    \e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m   |\e[0m        \
    \           Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpc68vtt6p.scala:16:24 ------------------------\e[0m\e[0m\n\e[31m16 |\e\
    [0m        \e[33mval\e[0m \e[36monesCount\e[0m = mutable.ListBuffer[\e[35mInt\e\
    [0m]()\n\e[31m\e[31m   |\e[0m                        ^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                        Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpc68vtt6p.scala:17:19 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mdecs\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatc"
  stdout: ''
  timestamp: 1660004032
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        var sortedArr: List[Long] = new mutable.ListBuffer[Long]\n\
    \        var i = 0\n        arr.foreach { x =>\n            if (x == 1l) {\n \
    \               sortedArr += x\n            } else {\n                sortedArr\
    \ += x.toLong\n            }\n            i += 1\n        }\n        sortedArr\
    \ += arr.last\n        sortedArr = sortedArr.sortWith(_ >= _) // sort ascending\n\
    \        sortedArr = sortedArr.reverse.map { x => (x*2).toLong } // convert into\
    \ dec\n        sortedArr\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmptgpjc81q.scala:15:40 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mvar\e[0m \e[36msortedArr\e[0m: \e[35mList\e\
    [0m[\e[35mLong\e[0m] = \e[33mnew\e[0m mutable.ListBuffer[\e[35mLong\e[0m]\n\e\
    [31m\e[31m   |\e[0m                                        ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                                        Not found: mutable\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmptgpjc81q.scala:19:26 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m                sortedArr += x\n\e[31m\e[31m   |\e[0m\
    \                ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    value += is not a member\
    \ of List[Long] - did you mean List[Long].!=?\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmptgpjc81q.scala:21:26 ------------------------\e[0m\e[0m\n\e[31m21\
    \ |\e[0m                sortedArr += x.toLong\n\e[31m\e[31m   |\e[0m         \
    \       ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    value += is not a member of List[Long]\
    \ - did you mean List[Long].!=?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmptgpjc81q.scala:25:18\
    \ ------------------------\e[0m\e[0m\n\e[31m25 |\e[0m        sortedArr += arr.last\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    value += is\
    \ not a member of List[Long] - did you mean List[Long].!=?\n4 errors found\n"
  stdout: ''
  timestamp: 1660004034
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val res = arr.sortWith((x, y) => x.toLong > y.toLong)\n\
    \        val zeros = arr.count(_ == 0)\n        res.take(zeros.toLong + 1).map(_\
    \ - zeros.toLong).reverse\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpt418sqgt.scala:17:17\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m        res.take(zeros.toLong\
    \ + \e[31m1\e[0m).map(_ - zeros.toLong).reverse\n\e[31m\e[31m   |\e[0m       \
    \          ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                 Found:    Long\n\
    \e[31m   |\e[0m                 Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660004033
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        arr.sortWith((x, y) => compare(arr, x, y) > 0)\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpv8wtlb67.scala:15:31 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        arr.sortWith((\e[36mx\e[0m, \e[36my\e[0m) =>\
    \ compare(arr, x, y) > \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m                  \
    \             ^^^^^^^\e[0m\n\e[31m   |\e[0m                               Not\
    \ found: compare\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660004030
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        var zeros = 0\n        var ones = 0\n        for (i\
    \ <- arr.indices) {\n            if (arr(i) == 0) {\n                zeros +=\
    \ 1\n            }\n            else if (arr(i) == 1) {\n                ones\
    \ += 1\n            }\n        }\n        if (zeros > ones) {\n            for\
    \ (i <- arr.indices) {\n                if (arr(i) == 0) {\n                 \
    \   arr(i) = -arr(i)\n                }\n            }\n            arr = arr.sortWith((x,\
    \ y) => x.compare(y))\n        }\n        else {\n            arr = arr.sortWith((x,\
    \ y) => y.compare(x))\n        }\n        arr\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmphh0jflm3.scala:28:20 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m                    arr(i) = -arr(i)\n\e[31m\e[31m  \
    \ |\e[0m                    ^^^\e[0m\n\e[31m   |\e[0m  value update is not a member\
    \ of List[Long] - did you mean arr.updated?\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmphh0jflm3.scala:31:50 --------------------\e[0m\e[0m\n\e[31m31\
    \ |\e[0m            arr = arr.sortWith((\e[36mx\e[0m, \e[36my\e[0m) => x.compare(y))\n\
    \e[31m\e[31m   |\e[0m                                         ^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                         Found:    Int\n\e[31m\
    \   |\e[0m                                         Required: Boolean\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphh0jflm3.scala:34:50 --------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m            arr = arr.sortWith((\e[36mx\e[0m, \e[36my\e\
    [0m) => y.compare(x))\n\e[31m\e[31m   |\e[0m                                 \
    \        ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                                  \
    \       Found:    Int\n\e[31m   |\e[0m                                       \
    \  Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660004034
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val bin = arr.map(x => (bin2dec(x),x))\n        bin.sortBy(_._1).map(_._2)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmphiqx96ws.scala:15:32 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mbin\e[0m = arr.map(\e[36mx\e\
    [0m => (bin2dec(x),x))\n\e[31m\e[31m   |\e[0m                                ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                Not found: bin2dec\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- Error: /tmp/tmphiqx96ws.scala:16:24 -----------------------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        bin.sortBy(_._1).map(_._2)\n\e[31m\e[31m   |\e\
    [0m                        ^\e[0m\n\e[31m   |\e[0mambiguous given instances: both\
    \ \e[33mobject\e[0m \e[35mByte\e[0m in \e[33mobject\e[0m \e[35mOrdering\e[0m and\
    \ \e[33mobject\e[0m \e[35mChar\e[0m in \e[33mobject\e[0m \e[35mOrdering\e[0m match\
    \ type Ordering[B] of parameter ord of \e[33mmethod\e[0m \e[35msortBy\e[0m in\
    \ \e[33mtrait\e[0m \e[35mSeqOps\e[0m\n2 errors found\n"
  stdout: ''
  timestamp: 1660004031
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val binArr = arr.map(x => x.toBinaryString).map(x\
    \ => x(0)).map(x => x.toLong).toArray\n        val countArr = binArr.map(x =>\
    \ x.toInt).map(x => x.toBinaryString).map(x => x(0)).map(x => x.toLong).toArray\n\
    \        val valArr = binArr.map(x => x.toInt).map(x => x.toBinaryString).map(x\
    \ => x(0)).map(x => x.toLong).toArray\n        val maxArr = valArr.map(x => x.toInt).map(x\
    \ => x.toLong).max\n        val retVal = valArr.map(x => x - maxArr)\n       \
    \ retVal.sortWith((x,y) => (binArr(x) - binArr(y)) == 0 ? x : y)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpu6d6qqwc.scala:20:68 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        retVal.sortWith((\e[36mx\e[0m,\e[36my\e[0m) =>\
    \ (binArr(x) - binArr(y)) == \e[31m0\e[0m ? x : \e[35my\e[0m)\n\e[31m\e[31m  \
    \ |\e[0m                                                                    ^\e\
    [0m\n\e[31m   |\e[0m                                                       Not\
    \ found: type y\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpu6d6qqwc.scala:20:41\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        retVal.sortWith((\e[36mx\e\
    [0m,\e[36my\e[0m) => (binArr(x) - binArr(y)) == \e[31m0\e[0m ? x : \e[35my\e[0m)\n\
    \e[31m\e[31m   |\e[0m                                         ^\e[0m\n\e[31m \
    \  |\e[0m                                         Found:    (x : Long)\n\e[31m\
    \   |\e[0m                                         Required: Int\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpu6d6qqwc.scala:20:53 --------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        retVal.sortWith((\e[36mx\e[0m,\e[36my\e[0m) =>\
    \ (binArr(x) - binArr(y)) == \e[31m0\e[0m ? x : \e[35my\e[0m)\n\e[31m\e[31m  \
    \ |\e[0m                                                     ^\e[0m\n\e[31m  \
    \ |\e[0m                                                    Found:    (y : Long)\n\
    \e[31m   |\e[0m                                                    Required: Int\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpu6d6qqwc.scala:20:62\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        retVal.sortWith((\e\
    [36mx\e[0m,\e[36my\e[0m) => (binArr(x) - binArr(y)) == \e[31m0\e[0m ? x : \e[35my\e\
    [0m)\n\e[31m\e[31m   |\e[0m                                                  \
    \          ^^^\e[0m\n\e[31m   |\e[0m                                         \
    \ value ? is not a member of Int\n4 errors found\n"
  stdout: ''
  timestamp: 1660004037
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        var sortedArray : List[Long] = arr.toList.sortWith((x,\
    \ y) => x.toLong == y.toLong)\n        var i = 1;\n        val size = sortedArray.size\n\
    \        while(i <= size) {\n            var counter = i\n            var tempSum\
    \ = 0\n            var tempMin = sortedArray(i-1)\n            while(counter >\
    \ 0 && tempMin > sortedArray((counter-1)/2)){\n                tempSum += sortedArray(counter)\n\
    \                counter -= 1\n            }\n            if(tempSum > sortedArray(counter)){\n\
    \                sortedArray = sortedArray.toList.reverse\n                i =\
    \ size\n            } else {\n                sortedArray = sortedArray.toList\n\
    \                i += 1\n            }\n        }\n        sortedArray\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp6gqy9i4y.scala:23:24 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m                tempSum += sortedArray(counter)\n\e[31m\e\
    [31m   |\e[0m                ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                value\
    \ += is not a member of Int - did you mean Int.!=?\n1 error found\n"
  stdout: ''
  timestamp: 1660004036
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val numOnes = arr\n            .filter(x => x != 0l)\n\
    \            .map(x => x.toInt.toBinary)\n            .map(x => Array(x.size,\
    \ x).map(i => x.charAt(i) == '1').sum)\n            .sortWith(_ < _)\n       \
    \     .reverse\n\n        val decimals = arr.map { x => x.toInt.toDecimal }\n\
    \            .sortWith(_ < _)\n\n        numOnes.zip(decimals).toList.sortWith(_._1\
    \ < _._1)\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmph_1dfupg.scala:17:30 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m            .map(x => x.toInt.toBinary)\n\e[31m\e[31m\
    \   |\e[0m                      ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m       \
    \               value toBinary is not a member of Int\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmph_1dfupg.scala:18:30 ------------------------\e[0m\e[0m\n\
    \e[31m18 |\e[0m            .map(x => Array(x.size, x).map(i => x.charAt(i) ==\
    \ \e[31m'1'\e[0m).sum)\n\e[31m\e[31m   |\e[0m                            ^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue size is not a member of Nothing, but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import Option.option2Iterable\n\
    \e[31m   |\e[0m  import collection.LazyZip2.lazyZip2ToIterable\n\e[31m   |\e[0m\
    \  import collection.LazyZip3.lazyZip3ToIterable\n\e[31m   |\e[0m  import collection.LazyZip4.lazyZip4ToIterable\n\
    \e[31m   |\e[0m  import collection.convert.ImplicitConversions.buffer AsJavaList\n\
    \e[31m   |\e[0m  import collection.convert.ImplicitConversions.list asScalaBuffer\n\
    \e[31m   |\e[0m  import collection.convert.ImplicitConversions.properties AsScalaMap\n\
    \e[31m   |\e[0m  import collection.convert.ImplicitConversions.map AsJavaConcurrentMap\n\
    \e[31m   |\e[0m  import collection.convert.ImplicitConversions.enumeration AsScalaIterator\n\
    \e[31m   |\e[0m  import collection.convert.ImplicitConversions.iterator asScala\n\
    \e[31m   |\e[0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmph_1dfupg.scala:19:24\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m            .sortWith(_ <\
    \ _)\n\e[31m\e[31m   |\e[0m                      ^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ < is not a member of Nothing, but could be made available as an extension method.\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might fix the problem:\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m  import Byte.byte2double\n\e[31m   |\e[0m  import\
    \ Byte.byte2float\n\e[31m   |\e[0m  import Byte.byte2int\n\e[31m   |\e[0m  import\
    \ Byte.byte2long\n\e[31m   |\e[0m  import Byte.byte2short\n\e[31m  "
  stdout: ''
  timestamp: 1660004040
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        // Your code here!\n        val ones = arr.filter(\
    \ _ % 2 == 1).size\n        val tens = arr.filter( _ % 10 == 0).size\n       \
    \ val hundreds = arr.filter( _ % 100 == 0).size\n        if (ones > tens && ones\
    \ > hundreds) {\n            arr.sortBy(_ % 10)\n        } else if (tens > ones\
    \ && tens > hundreds) {\n            arr.sortBy(_ % 100)\n        } else {\n \
    \           arr.sortBy(_ % 1000)\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp12oc6sow.scala:28)\n\tat Problem.main(tmp12oc6sow.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660004039
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        arr.sortBy { i => (i & 1) == 1 }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong,\
    \ -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong,\
    \ -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmptxuufd6t.scala:18)\n\tat Problem.main(tmptxuufd6t.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660004039
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        arr.map {\n            case 0l => 0l\n           \
    \ case x => x.toLong\n        }.sortBy(x => math.log2(x).toInt)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp8xn6aaqp.scala:18:27 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        }.sortBy(x => math.log2(x).toInt)\n\e[31m\e[31m\
    \   |\e[0m                      ^^^^^^^^^\e[0m\n\e[31m   |\e[0m              \
    \        value log2 is not a member of math\n\e[31m\e[31m-- Error: /tmp/tmp8xn6aaqp.scala:18:41\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m18 |\e[0m       \
    \ }.sortBy(x => math.log2(x).toInt)\n\e[31m\e[31m   |\e[0m                   \
    \                      ^\e[0m\n\e[31m   |\e[0mambiguous given instances: both\
    \ \e[33mobject\e[0m \e[35mByte\e[0m in \e[33mobject\e[0m \e[35mOrdering\e[0m and\
    \ \e[33mobject\e[0m \e[35mChar\e[0m in \e[33mobject\e[0m \e[35mOrdering\e[0m match\
    \ type Ordering[B] of parameter ord of \e[33mmethod\e[0m \e[35msortBy\e[0m in\
    \ \e[33mtrait\e[0m \e[35mSeqOps\e[0m\n2 errors found\n"
  stdout: ''
  timestamp: 1660004038
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        var num1 = 0\n        var num2 = 0\n        var temp\
    \ : List[Long] = List()\n        var i = 0\n        while (i < arr.length) {\n\
    \            if (arr(i) == 1l) {\n                num1 += 1\n                if\
    \ (num1 > 1l) {\n                    num1 = 0\n                    num2 += 1\n\
    \                }\n            } else {\n                num2 += 1\n        \
    \    }\n            if (num1 == 1l) {\n                temp = arr(i)\n       \
    \         arr(i) = num2\n                num2 = temp\n                i += 1\n\
    \                num1 = 0\n            }\n        }\n        return arr\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmplynr2m2l.scala:30:26\
    \ --------------------\e[0m\e[0m\n\e[31m30 |\e[0m                temp = arr(i)\n\
    \e[31m\e[31m   |\e[0m                       ^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                  Found:    Long\n\e[31m   |\e[0m                       Required:\
    \ \e[1m\e[32mList\e[0m\e[1m\e[32m[\e[0mLong\e[1m\e[32m]\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmplynr2m2l.scala:31:16 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m                arr(i) = num2\n\e[31m\e[31m   |\e[0m\
    \                ^^^\e[0m\n\e[31m   |\e[0m  value update is not a member of List[Long]\
    \ - did you mean arr.updated?\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmplynr2m2l.scala:32:23\
    \ --------------------\e[0m\e[0m\n\e[31m32 |\e[0m                num2 = temp\n\
    \e[31m\e[31m   |\e[0m                       ^^^^\e[0m\n\e[31m   |\e[0m       \
    \                Found:    (temp : List[Long])\n\e[31m   |\e[0m              \
    \         Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660004039
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        arr.sortBy(_.getOnes).sortBy(_.getDecimal)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp1h7r4h8h.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        arr.sortBy(_.getOnes).sortBy(_.getDecimal)\n\e\
    [31m\e[31m   |\e[0m                   ^^^^^^^^^\e[0m\n\e[31m   |\e[0m        \
    \           value getOnes is not a member of Long\n\e[31m\e[31m-- Error: /tmp/tmp1h7r4h8h.scala:15:29\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m15 |\e[0m       \
    \ arr.sortBy(_.getOnes).sortBy(_.getDecimal)\n\e[31m\e[31m   |\e[0m          \
    \                   ^\e[0m\n\e[31m   |\e[0mambiguous given instances: both \e\
    [33mobject\e[0m \e[35mByte\e[0m in \e[33mobject\e[0m \e[35mOrdering\e[0m and \e\
    [33mobject\e[0m \e[35mShort\e[0m in \e[33mobject\e[0m \e[35mOrdering\e[0m match\
    \ type Ordering[B] of parameter ord of \e[33mmethod\e[0m \e[35msortBy\e[0m in\
    \ \e[33mtrait\e[0m \e[35mSeqOps\e[0m\n2 errors found\n"
  stdout: ''
  timestamp: 1660004037
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        var res = 0\n        var bin = arr.map(x => x.toString(2))\n\
    \        bin.foreach(x => {\n            val n = (x.toLong / 2).toInt\n      \
    \      val ones = x.toLong % 2\n            res += ones * n\n        })\n    \
    \    val dec = bin.map(x => x.toString.toLong.toInt).map(_.pow(2)).map(x => x\
    \ / res).sortBy(x => x).reverse\n        bin.map(x => x.toString(2)).sortBy(x\
    \ => x).reverse.map(x => x + dec).reduce(_ ++ _)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpsydphuyr.scala:16:42 -----------------------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mvar\e[0m \e[36mbin\e[0m = arr.map(\e[36mx\e\
    [0m => x.toString(\e[31m2\e[0m))\n\e[31m\e[31m   |\e[0m                      \
    \                    ^\e[0m\n\e[31m   |\e[0m         too many arguments for \e\
    [33mmethod\e[0m \e[35mtoString\e[0m in \e[33mclass\e[0m \e[35mAny\e[0m: (): String\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpsydphuyr.scala:20:16 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m            res += ones * n\n\e[31m\e[31m   |\e[0m  \
    \          ^^^^^^\e[0m\n\e[31m   |\e[0m            value += is not a member of\
    \ Int - did you mean Int.!=?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpsydphuyr.scala:22:62\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mdec\e[0m = bin.map(\e[36mx\e[0m => x.toString.toLong.toInt).map(_.pow(\e[31m2\e\
    [0m)).map(\e[36mx\e[0m => x / res).sortBy(\e[36mx\e[0m => x).reverse\n\e[31m\e\
    [31m   |\e[0m                                                            ^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue pow is not a member of Int, but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.BigDecimal.int2bigDecimal\n\
    \e[31m   |\e[0m  import math.BigInt.int2bigInt\n\e[31m   |\e[0m\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpsydphuyr.scala:22:81 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mdec\e[0m = bin.map(\e[36mx\e\
    [0m => x.toString.toLong.toInt).map(_.pow(\e[31m2\e[0m)).map(\e[36mx\e[0m => x\
    \ / res).sortBy(\e[36mx\e[0m => x).reverse\n\e[31m\e[31m   |\e[0m            \
    \                                                                   ^^^\e[0m\n\
    \e[31m   |\e[0mvalue / is not a member of Nothing, but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import Byte.byte2double\n\
    \e[31m   |\e[0m  import Byte.byte2float\n\e[31m   |\e[0m  import Byte.byte2int\n\
    \e[31m   |\e[0m  import Byte.byte2long\n\e[31m   |\e"
  stdout: ''
  timestamp: 1660004039
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val bits = new BitSet(arr.length.toInt)\n        val\
    \ ones = new BitSet(arr.length.toInt)\n        for (i<-0 until arr.length) {\n\
    \            ones = bits | ones | BitSet.get(i.toInt)\n            val bin = BitSet.toString(ones).dropRight(1).toString\n\
    \            bits = bits & ~(ones & BitSet(i.toInt))\n            arr(i) = bin.toLong\n\
    \        }\n        arr\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpzamu9ft2.scala:18:40 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m            ones = bits | ones | BitSet.get(i.toInt)\n\
    \e[31m\e[31m   |\e[0m                                 ^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m     value get is not a member of object scala.collection.mutable.BitSet\n\
    \e[31m\e[31m-- Error: /tmp/tmpzamu9ft2.scala:19:38 -----------------------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m            \e[33mval\e[0m \e[36mbin\e[0m = BitSet.toString(ones).dropRight(\e\
    [31m1\e[0m).toString\n\e[31m\e[31m   |\e[0m                                  \
    \    ^^^^\e[0m\n\e[31m   |\e[0m         too many arguments for \e[33mmethod\e\
    [0m \e[35mtoString\e[0m in \e[33mclass\e[0m \e[35mAny\e[0m: (): String\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpzamu9ft2.scala:20:26 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m            bits = bits & ~(ones & BitSet(i.toInt))\n\
    \e[31m\e[31m   |\e[0m                          ^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m        value unary_~ is not a member of scala.collection.mutable.BitSet\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpzamu9ft2.scala:21:12 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m            arr(i) = bin.toLong\n\e[31m\e[31m   |\e[0m\
    \            ^^^\e[0m\n\e[31m   |\e[0m  value update is not a member of List[Long]\
    \ - did you mean arr.updated?\n4 errors found\n"
  stdout: ''
  timestamp: 1660004039
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val count = arr.map(x => if (x == 1l) 0 else 1)\n\
    \        val sorted = arr.sortBy(x => count(x) * math.log10(x.toDouble))\n   \
    \     sorted.map(x => x.toLong)\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp91hdc54v.scala:16:43\
    \ --------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36msorted\e\
    [0m = arr.sortBy(\e[36mx\e[0m => count(x) * math.log10(x.toDouble))\n\e[31m\e\
    [31m   |\e[0m                                           ^\e[0m\n\e[31m   |\e[0m\
    \                                           Found:    (x : Long)\n\e[31m   |\e\
    [0m                                           Required: Int\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660004039
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val countMap : Map[Long, Long] = arr.groupBy(x =>\
    \ x).toMap\n        val oneCountMap : Map[Long, Long] = countMap.filter(_._1 ==\
    \ 1).toMap\n        val oneAndAllCountMap : Map[Long, Long] = countMap.filter(_._1\
    \ == 1 && _._2 == arr.length).toMap\n\n        oneAndAllCountMap.map{\n      \
    \      case (count, val) =>\n                val index = math.abs(val - math.max(oneAndAllCountMap.keySet).max).toInt\n\
    \                val vals = arr.drop(index).filter(_ == 1)\n                val\
    \ oneAndAllCountArray = ones.toArray[Long](oneAndAllCountMap.keySet)\n       \
    \         val oneAndAllCountArrayCopy = oneAndAllCountArray.clone()\n        \
    \        val oneAndAllCountArrayCopyScala = oneAndAllCountArray.map(x => scala.math.abs(x\
    \ - scala.math.max(oneAndAllCountArrayCopy)))\n                val oneAndAllCountArrayScala\
    \ = oneAndAllCountArrayCopyScala.map(x => scala.math.abs(x - scala.math.max(oneAndAllCountArray)))\n\
    \                (oneAndAllCountArrayCopy.toList)(scala.math.min(oneAndAllCountArrayScala).toInt)\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpbshlqm82.scala:20:25 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m            \e[33mcase\e[0m (count, \e[33mval\e[0m) =>\n\
    \e[31m\e[31m   |\e[0m                         ^^^\e[0m\n\e[31m   |\e[0m      \
    \                   pattern expected\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E018]\
    \ Syntax Error: /tmp/tmpbshlqm82.scala:21:37 ---------------------------\e[0m\e\
    [0m\n\e[31m21 |\e[0m                \e[33mval\e[0m \e[36mindex\e[0m = math.abs(\e\
    [33mval\e[0m - math.max(oneAndAllCountMap.keySet).max).toInt\n\e[31m\e[31m   |\e\
    [0m                                     ^^^\e[0m\n\e[31m   |\e[0m            \
    \                         expression expected but \e[31mval\e[0m found\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpbshlqm82.scala:15:41 --------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mcountMap\e[0m : \e[35mMap\e\
    [0m[\e[35mLong\e[0m, \e[35mLong\e[0m] = arr.groupBy(\e[36mx\e[0m => x).toMap\n\
    \e[31m\e[31m   |\e[0m                                         ^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                            Found:    Map[Long, \e[1m\e[31mList\e\
    [0m\e[1m\e[31m[\e[0mLong\e[1m\e[31m]\e[0m]\n\e[31m   |\e[0m                  \
    \          Required: \e[1m\e[32mcollection\e[0m\e[1m\e[32m.\e[0m\e[1m\e[32mmutable\e\
    [0m\e[1m\e[32m.\e[0mMap[Long, Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpbshlqm82.scala:16:44 --------------------\e[0m\e[0m\n\e[31m16\
    \ |\e[0m        \e[33mval\e[0m \e[36moneCountMap\e[0m : \e[35mMap\e[0m[\e[35mLong\e\
    [0m, \e[35mLong\e[0m] = countMap.filter(_._1 == \e[31m1\e[0m).toMap\n\e[31m\e\
    [31m   |\e[0m                                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                            Found:    Map[Long, Long]\n\e\
    [31m   |\e[0m                            Required: \e[1m\e[32mcollection\e[0m\e\
    [1m\e[32m.\e[0m\e[1m\e[32mmutable\e[0m\e[1m\e[32m.\e[0mMap[Long, Long]\n\e[31m\
    \   |\e[0"
  stdout: ''
  timestamp: 1660004043
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val l = new mutable.ArrayBuffer[Long]()\n        arr.foreach\
    \ {\n            x =>\n                val count = arr(x).toInt / 2\n        \
    \        var j = 0\n                while (j < count) {\n                    l.append(x\
    \ * (2l + (1l to count).toInt))\n                    j += 1\n                }\n\
    \        }\n        l.toList\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpf654f7fb.scala:15:20 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36ml\e[0m = \e[33mnew\e[0m\
    \ mutable.ArrayBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m              \
    \      ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found: mutable\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpf654f7fb.scala:18:32\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m                \e[33mval\e[0m\
    \ \e[36mcount\e[0m = arr(x).toInt / \e[31m2\e[0m\n\e[31m\e[31m   |\e[0m      \
    \                          ^\e[0m\n\e[31m   |\e[0m                           \
    \     Found:    (x : Long)\n\e[31m   |\e[0m                                Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660004040
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        var n = 1\n        val ones = arr filter (_ == 1)\n\
    \        val twos = arr filter (_ == 2)\n        val thres = arr filter (_ < 0)\n\
    \        val zeros = arr filter (_ < 0)\n        val zeroCounts = zeros.groupBy(0)\n\
    \        val oneCounts = ones.groupBy(1)\n        val twoCounts = twos.groupBy(2)\n\
    \        val thresCounts = thres.groupBy(0)\n        val zeroZeroCounts = zeroCounts\
    \ filter (_._2 == 0)\n        val oneOneCounts = oneCounts filter (_._2 == 1)\n\
    \        val twoTwoCounts = twoCounts filter (_._2 == 2)\n        val thresThresCounts\
    \ = thresCounts filter (_._2 == 0)\n        val zeroZeroZeroCounts = zeroZeroCounts\
    \ filter (_._2 == 0)\n        val oneOneOneCounts = oneOneCounts filter (_._2\
    \ == 1)\n        val twoTwoTwoCounts = twoTwoCounts filter (_._2 == 2)\n     \
    \   val thresThresThresCounts = thresThresCounts filter (_._2 == 0)\n        val\
    \ zeroZeroZeroZeroCounts = zeroZeroZeroCounts filter (_._2 == 0)\n        val\
    \ oneOneOneOneCounts = oneOneOneCounts filter (_._2 == 1)\n        val twoTwoTwoTwoCounts\
    \ = twoTwoTwoCounts filter (_._2 == 2)\n        val thresThresThresThresCounts\
    \ = thresThresThresCounts filter (_._2 == 0)\n        val zeroZeroZeroZeroZeroCounts\
    \ = zeroZeroZeroZeroCounts filter (_._2 == 0)\n        val oneOneOneOneOneCounts\
    \ = oneOneOneOneCounts filter (_._2 == 1)\n        val twoTwoTwoTwoTwoCounts =\
    \ twoTwoTwoTwoCounts filter (_._2 == 2)\n        val thresThresThresThresThresCounts\
    \ = thresThresThresThresCounts filter (_._2 == 0)\n        val zeroZeroZeroZeroZeroZeroCounts\
    \ = zeroZeroZeroZeroZeroCounts filter (_._2 == 0)\n        val oneOneOneOneOneOneCounts\
    \ = oneOneOneOneOneCounts filter (_._2 == 1)\n        val twoTwoTwoTwoTwoTwoCounts\
    \ = twoTwoTwoTwoTwoCounts filter (_._2 == 2)\n        val thresThresThresThresThresThresCounts\
    \ = \n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpcjt0tpzn.scala:43:50 ---------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m        \e[33mval\e[0m \e[36mthresThresThresThresThresThresCounts\e\
    [0m = \n\e[31m\e[31m   |\e[0m                                                \
    \  ^\e[0m\n\e[31m   |\e[0m                                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpcjt0tpzn.scala:20:39 --------------------\e[0m\e[0m\n\e[31m20\
    \ |\e[0m        \e[33mval\e[0m \e[36mzeroCounts\e[0m = zeros.groupBy(\e[31m0\e\
    [0m)\n\e[31m\e[31m   |\e[0m                                       ^\e[0m\n\e[31m\
    \   |\e[0m                                       Found:    (\e[31m0\e[0m : Int)\n\
    \e[31m   |\e[0m                                       Required: Long => Any\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpcjt0tpzn.scala:21:37\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36moneCounts\e\
    [0m = ones.groupBy(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m                      \
    \               ^\e[0m\n\e[31m   |\e[0m                                     Found:\
    \    (\e[31m1\e[0m : Int)\n\e[31m   |\e[0m                                   \
    \  Required: Long => Any\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpcjt0tpzn.scala:22:37 --------------------\e[0m\e[0m\n\e[31m22\
    \ |\e[0m        \e[33mval\e[0m \e[36mtwoCounts\e[0m = twos.groupBy(\e[31m2\e[0m)\n\
    \e[31m\e[31m   |\e[0m                                     ^\e[0m\n\e[31m   |\e\
    [0m                                     Found:    (\e[31m2\e[0m : Int)\n\e[31m\
    \   |\e[0m                                     Required: Long => Any\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpcjt0tpzn.scala:23:40 --------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mthresCounts\e[0m = thres.gr"
  stdout: ''
  timestamp: 1660004045
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n      require(arr.size >= 1, \"Cannot sort an empty list.\"\
    );\n      var oneCount = 0;\n      var result = arr.toList\n      for (i <- 0\
    \ until arr.size) {\n        oneCount += arr(i) match {\n          case 0 => 0\n\
    \          case 1 => 1\n          case 2 => 2\n          case 3 => 3\n       \
    \   case 4 => 4\n          case 5 => 5\n          case 6 => 6\n          case\
    \ 7 => 7\n          case 8 => 8\n          case 9 => 9\n          case _ => 10\n\
    \        }\n      }\n      for (i <- 0 until oneCount) {\n        result = result.sortWith(_.compare(arr.head))\n\
    \      }\n      result\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpruimfnvl.scala:19:17 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        oneCount += arr(i) \e[33mmatch\e[0m {\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        value += is not\
    \ a member of Int - did you mean Int.!=?\n\e[31m\e[31m-- [E086] Syntax Error:\
    \ /tmp/tmpruimfnvl.scala:34:33 ---------------------------\e[0m\e[0m\n\e[31m34\
    \ |\e[0m        result = result.sortWith(_.compare(arr.head))\n\e[31m\e[31m  \
    \ |\e[0m                                 ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                                 Wrong number of parameters, expected: 2\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660004042
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n      val ones : List[Long] = arr.filter(_ % 2 == 0l).toList\n\
    \      val zeros : List[Long] = arr.filter(_ % 2 == 1l).toList\n      val onesByTwos\
    \ : List[Long] = ones.zip(ones.map(_ * 2).toList).sortBy(_._1).map(_._2)\n   \
    \   val zerosByTwos : List[Long] = zeros.zip(zeros.map(_ * 2).toList).sortBy(_._1).map(_._2)\n\
    \      onesByTwos.union(zerosByTwos)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpmlksdj8u.scala:22)\n\tat Problem.main(tmpmlksdj8u.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660004045
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        // Your code goes here.\n        val m = arr.map(i\
    \ => (i, (i.toInt * 10).asInstanceOf[Long])).toMap\n        val n = arr.map(i\
    \ => ((i.toInt * 10).asInstanceOf[Long], i)).toMap\n        arr.map(i => (i, (m.getOrElse(i,\
    \ 0).toInt + n.getOrElse(i, 0).toInt)).asInstanceOf[Long]).toList\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpfuhr4810.scala:18:44 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        arr.map(\e[36mi\e[0m => (i, (m.getOrElse(i, \e\
    [31m0\e[0m).toInt + n.getOrElse(i, \e[31m0\e[0m).toInt)).asInstanceOf[\e[35mLong\e\
    [0m]).toList\n\e[31m\e[31m   |\e[0m                          ^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue toInt is not a member of AnyVal, but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e\
    [0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import\
    \ math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n1 error found\n"
  stdout: ''
  timestamp: 1660004044
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        var onesCount = 0.0\n        var result = arr.toList\n\
    \        for( item <- arr) {\n            onesCount += item\n        }\n     \
    \   var i = 0\n        while(i < arr.length) {\n            if( arr(i) > 0 &&\
    \ onesCount > 0) {\n                for( j <- i until arr.length) {\n        \
    \            if( arr(j) > 0) {\n                        arr(j) = arr(j) + onesCount\n\
    \                        break\n                    } else if( arr(j) == 0) {\n\
    \                        arr(j) = arr(j) + onesCount\n                       \
    \ result.add(arr(j))\n                        onesCount = 0.0\n              \
    \          break\n                    } else {\n                        onesCount\
    \ = onesCount - arr(j)\n                    }\n                }\n           \
    \ } else {\n                result.add(arr(i))\n            }\n            onesCount\
    \ = 0.0\n            i += 1\n        }\n        result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong,\
    \ -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong,\
    \ -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp_fii38uz.scala:25:24 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m                        arr(j) = arr(j) + onesCount\n\
    \e[31m\e[31m   |\e[0m                        ^^^\e[0m\n\e[31m   |\e[0m  value\
    \ update is not a member of List[Long] - did you mean arr.updated?\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp_fii38uz.scala:26:24 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m                        break\n\e[31m\e[31m   |\e[0m\
    \                        ^^^^^\e[0m\n\e[31m   |\e[0m                        Not\
    \ found: break\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp_fii38uz.scala:28:24\
    \ ------------------------\e[0m\e[0m\n\e[31m28 |\e[0m                        arr(j)\
    \ = arr(j) + onesCount\n\e[31m\e[31m   |\e[0m                        ^^^\e[0m\n\
    \e[31m   |\e[0m  value update is not a member of List[Long] - did you mean arr.updated?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp_fii38uz.scala:29:31 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m                        result.add(arr(j))\n\e[31m\e\
    [31m   |\e[0m                        ^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue add\
    \ is not a member of List[Long], but could be made available as an extension method.\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might fix the problem:\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.seq\
    \ AsJavaList\n\e[31m   |\e[0m  import collection.convert.ImplicitConversionsToJava.seq\
    \ AsJavaList\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.collection\
    \ asJava\n\e[31m   |\e[0m  import collection.convert.ImplicitConversionsToJava.collection\
    \ asJava\n\e[31m   |\e[0m\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp_fii38uz.scala:31:24\
    \ ------------------------\e[0m\e[0m\n\e[31m31 |\e[0m                        break\n\
    \e[31m\e[31m   |\e[0m                        ^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                   Not found: break\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E008]\
    \ Not Found"
  stdout: ''
  timestamp: 1660004045
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_%2==0).count\n        val tens\
    \ = arr.filter(_%2==1).count\n        val tensOnes = tens * ones\n        val\
    \ longs = arr.filter(_%2==0).sortBy(x => x.toLong)\n        val onesLongs = longs.filter(_%2==0).sortBy(x\
    \ => x.toLong)\n        val tensLongs = onesLongs.filter(_%2==1).sortBy(x => x.toLong)\n\
    \        val onesTensLongs = tensLongs.filter(_%2==1).sortBy(x => x.toLong)\n\
    \        val tensOnesLongs = onesTensLongs.filter(_%2==1).sortBy(x => x.toLong)\n\
    \        onesLongs.take(ones) * tensLongs.take(tens) * onesTensLongs.take(onesTens)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpntgonbxx.scala:17:28 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mtensOnes\e[0m = tens * ones\n\
    \e[31m\e[31m   |\e[0m                       ^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ * is not a member of (Long => Boolean) => Int, but could be made available as\
    \ an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports\
    \ might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e[0m  import\
    \ math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import math.Numeric.Implicits.infixNumericOps\n\
    \e[31m   |\e[0m\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpntgonbxx.scala:23:23\
    \ --------------------\e[0m\e[0m\n\e[31m23 |\e[0m        onesLongs.take(ones)\
    \ * tensLongs.take(tens) * onesTensLongs.take(onesTens)\n\e[31m\e[31m   |\e[0m\
    \                       ^^^^\e[0m\n\e[31m   |\e[0m                       Found:\
    \    (ones : (Long => Boolean) => Int)\n\e[31m   |\e[0m                      \
    \ Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpntgonbxx.scala:23:46\
    \ --------------------\e[0m\e[0m\n\e[31m23 |\e[0m        onesLongs.take(ones)\
    \ * tensLongs.take(tens) * onesTensLongs.take(onesTens)\n\e[31m\e[31m   |\e[0m\
    \                                              ^^^^\e[0m\n\e[31m   |\e[0m    \
    \                         Found:    (tens : (Long => Boolean) => Int)\n\e[31m\
    \   |\e[0m                             Required: Int\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660004045
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        arr.sortWith(compareByOnes)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong,\
    \ -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong,\
    \ -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpgmmomkq3.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        arr.sortWith(compareByOnes)\n\e[31m\e[31m   |\e\
    [0m                     ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                  \
    \   Not found: compareByOnes\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660004041
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ => 1).toLong\n        val zeros\
    \ = arr.count(_ => 0).toLong\n        val numOnes = arr.count(_ > 0).toLong\n\
    \        val numZeros = arr.count(_ < 0).toLong\n        arr.sortBy(x => (ones-(numOnes^x)),\
    \ x => (zeros-(numZeros^x)))\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpt4zmr1wr.scala:15:34\
    \ --------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mones\e\
    [0m = arr.count(_ => \e[31m1\e[0m).toLong\n\e[31m\e[31m   |\e[0m             \
    \                     ^\e[0m\n\e[31m   |\e[0m                                \
    \  Found:    (\e[31m1\e[0m : Int)\n\e[31m   |\e[0m                           \
    \       Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpt4zmr1wr.scala:16:35 --------------------\e[0m\e[0m\n\e[31m16\
    \ |\e[0m        \e[33mval\e[0m \e[36mzeros\e[0m = arr.count(_ => \e[31m0\e[0m).toLong\n\
    \e[31m\e[31m   |\e[0m                                   ^\e[0m\n\e[31m   |\e[0m\
    \                                   Found:    (\e[31m0\e[0m : Int)\n\e[31m   |\e\
    [0m                                   Required: Boolean\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E081] Type Error: /tmp/tmpt4zmr1wr.scala:19:19 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        arr.sortBy(\e[36mx\e[0m => (ones-(numOnes^x)),\
    \ \e[36mx\e[0m => (zeros-(numZeros^x)))\n\e[31m\e[31m   |\e[0m               \
    \    ^\e[0m\n\e[31m   |\e[0m                   Missing parameter type\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m                   I could not infer the type of the\
    \ parameter x.\n\e[31m\e[31m-- [E081] Type Error: /tmp/tmpt4zmr1wr.scala:19:44\
    \ -----------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        arr.sortBy(\e\
    [36mx\e[0m => (ones-(numOnes^x)), \e[36mx\e[0m => (zeros-(numZeros^x)))\n\e[31m\e\
    [31m   |\e[0m                                            ^\e[0m\n\e[31m   |\e\
    [0m                          Missing parameter type\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m                          I could not infer the type of the parameter\
    \ x.\n\e[31m\e[31m-- Error: /tmp/tmpt4zmr1wr.scala:19:70 -----------------------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        arr.sortBy(\e[36mx\e[0m => (ones-(numOnes^x)),\
    \ \e[36mx\e[0m => (zeros-(numZeros^x)))\n\e[31m\e[31m   |\e[0m               \
    \                                               "
  stdout: ''
  timestamp: 1660004047
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        arr.sortWith(_ < _)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpvflt3x6i.scala:18)\n\tat Problem.main(tmpvflt3x6i.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660003997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        var arr = arr.reverse.sortWith(_ < _)\n        var\
    \ bin = new Array[Long](64)\n        var dec = 0\n        var count = 1\n    \
    \    for(i<-arr.length-1 downto 0){\n            bin(i) = arr(i)\n           \
    \ if(arr(i) == 1){\n                count++\n            }\n            else if(arr(i)\
    \ == 0){\n                count -= 1\n            }\n            if(count > 0){\n\
    \                dec = dec + (bin(i-1) * count)\n                count = 1\n \
    \           }\n        }\n        arr = arr.reverse.sortWith(_ < _)\n        bin\
    \ = bin.reverse.dropRight(63).toArray\n        arr = arr.take(dec)\n        arr\
    \ = arr.take(arr.length - dec)\n        if(arr.length > 0){\n            arr =\
    \ arr + dec.toLong\n        }\n        else{\n            arr = dec.toLong\n \
    \       }\n        for(i<-arr.length-1 downto 0){\n            bin(i) = (arr(i)\
    \ - dec.toLong).toInt\n        }\n        bin.reverse\n        arr.reverse\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpxrhwamk_.scala:22:23 ---------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m                count++\n\e[31m\e[31m   |\e[0m      \
    \                 ^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmpxrhwamk_.scala:15:18 ---------------------------\e[0m\e[0m\n\e[31m15\
    \ |\e[0m        \e[33mvar\e[0m \e[36marr\e[0m = arr.reverse.sortWith(_ < _)\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvariable\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660004044
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val oneArray = arr.filter(x => x == 1l.toLong).toArray\n\
    \        if(oneArray.size > arr.size) {\n            oneArray.sort { a =>\n  \
    \              val zeroArray = arr.filter(x => x == 0l.toLong).toArray\n     \
    \           if(zeroArray.size > 0) {\n                    val oneArray2 = arr.filter(x\
    \ => x == 1l.toLong).toArray\n                    oneArray2.sortWith(_ > _).sortWith(_\
    \ > _).sortWith(_ > _)\n                }\n            }\n        }\n        oneArray\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpzz9tcd7c.scala:17:21 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m            oneArray.sort { \e[36ma\e[0m =>\n\e[31m\e\
    [31m   |\e[0m            ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m value sort is not\
    \ a member of Array[Long] - did you mean oneArray.wait?\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpzz9tcd7c.scala:25:8 ---------------------\e[0m\e\
    [0m\n\e[31m25 |\e[0m        oneArray\n\e[31m\e[31m   |\e[0m        ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    (oneArray : Array[Long])\n\e[31m   |\e[0m\
    \        Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660004048
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        arr.sortWith(compareByOne)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong,\
    \ -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong,\
    \ -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp9md5xo6b.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        arr.sortWith(compareByOne)\n\e[31m\e[31m   |\e\
    [0m                     ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                   \
    \  Not found: compareByOne\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660004045
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        var result: List[Long] = Nil\n        for (elem <-\
    \ arr) {\n            val bitCount = elem.toString.length\n            if (bitCount\
    \ < 1) {\n                result += arr\n                return result\n     \
    \       }\n            if (bitCount >= 1) {\n                val currentVal =\
    \ elem.toString.reverse.foldLeft(0)(_ + _)\n                val bitValue = (currentVal\
    \ & 1).toInt\n                val newVal = currentVal | (1 << bitValue)\n    \
    \            result += (newVal << bitCount).toLong\n            }\n        }\n\
    \        result\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpibpdf3dq.scala:19:23 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m                result += arr\n\e[31m\e[31m   |\e[0m\
    \                ^^^^^^^^^\e[0m\n\e[31m   |\e[0m    value += is not a member of\
    \ List[Long] - did you mean List[Long].!=?\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpibpdf3dq.scala:26:23 ------------------------\e[0m\e[0m\n\e[31m26 |\e\
    [0m                result += (newVal << bitCount).toLong\n\e[31m\e[31m   |\e[0m\
    \                ^^^^^^^^^\e[0m\n\e[31m   |\e[0m    value += is not a member of\
    \ List[Long] - did you mean List[Long].!=?\n2 errors found\n"
  stdout: ''
  timestamp: 1660004049
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        // Write your logic here\n        val len = arr.length\n\
    \        var i = 0\n        var numOfOnes = 0 // number of 1s in arr\n       \
    \ var temp = 0\n        var j = 0\n        while(i < len) {\n            if(arr(i)\
    \ == 1) numOfOnes++ else numOfOnes--\n            i += 1\n        }\n        if(numOfOnes\
    \ > 0) arr.sortBy(x=>numOfOnes.toInt/10)\n        else arr.sortBy(x=>x.toInt)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpijzl06k6.scala:22:40 ---------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m            \e[33mif\e[0m(arr(i) == \e[31m1\e[0m) numOfOnes++\
    \ \e[33melse\e[0m numOfOnes--\n\e[31m\e[31m   |\e[0m                         \
    \               ^^^^\e[0m\n\e[31m   |\e[0m                                   \
    \   expression expected but \e[31melse\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpijzl06k6.scala:22:37 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m            \e[33mif\e[0m(arr(i) == \e[31m1\e[0m) numOfOnes++\
    \ \e[33melse\e[0m numOfOnes--\n\e[31m\e[31m   |\e[0m                         \
    \   ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                            value ++ is not\
    \ a member of Int\n2 errors found\n"
  stdout: ''
  timestamp: 1660004049
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        if (arr.length == 0) return arr.toList\n        val\
    \ n = arr.head\n        val rest = arr.tail.filter(_ % n == 0)\n        val dec\
    \ = dec2dec(n)\n        if (rest.isEmpty) rest.toList else dec.reverse.head ::\
    \ dec.reverse ++ sortArray(rest)\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpikqlzufc.scala:18:18 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mdec\e[0m = dec2dec(n)\n\e\
    [31m\e[31m   |\e[0m                  ^^^^^^^\e[0m\n\e[31m   |\e[0m           \
    \       Not found: dec2dec\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660004046
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val numOfOnes = arr.map(x => math.pow(2, x)).reduceLeft(_\
    \ + _)\n        val len = arr.length\n        val maxOnesBefore = arr.filter(x\
    \ => x == 1).length\n        val maxOnesAfter = len - maxOnesBefore\n        //\
    \ sort by number of ones in ascending order\n        arr.sortWith(x => numOfOnes\
    \ - x)\n        // sort by number of ones in ascending order\n        if (maxOnesAfter\
    \ > maxOnesBefore) arr.sortWith(x => maxOnesBefore - x) else arr\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E086] Syntax Error: /tmp/tmpmgntwc3g.scala:20:23 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        arr.sortWith(\e[36mx\e[0m => numOfOnes - x)\n\
    \e[31m\e[31m   |\e[0m                     ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                     Wrong number of parameters, expected: 2\n\e[31m\e[31m--\
    \ [E086] Syntax Error: /tmp/tmpmgntwc3g.scala:22:57 ---------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mif\e[0m (maxOnesAfter > maxOnesBefore)\
    \ arr.sortWith(\e[36mx\e[0m => maxOnesBefore - x) \e[33melse\e[0m arr\n\e[31m\e\
    [31m   |\e[0m                                                       ^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                 Wrong number of parameters,\
    \ expected: 2\n2 errors found\n"
  stdout: ''
  timestamp: 1660004048
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val bits = arr.map(_ => Long.bitCount(_))\n      \
    \  val len = arr.length\n        val ones = bits.toList\n        val zeros = List(0)\n\
    \        val bins = binary(ones, len)\n        bins.sortWith((a,b) => a > b ?\
    \ 1 : a < b ? -1 : 0)\n        val decs = bins.map(_ => binaryToDecimal(_, len))\n\
    \        decs match {\n            case Seq(dec1, dec2) => dec1.zip(dec2) match\
    \ {\n                case (dec, dec2) if dec.toInt == dec2.toInt => dec\n    \
    \            case _ => decs\n            }\n            case _ => decs\n     \
    \   }\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpwv2pncz1.scala:20:54 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        bins.sortWith((\e[36ma\e[0m,\e[36mb\e[0m) =>\
    \ a > b ? \e[31m1\e[0m : \e[35ma\e[0m \e[35m<\e[0m \e[35mb\e[0m \e[35m?\e[0m -\e\
    [31m1\e[0m : \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m                            \
    \                          ^\e[0m\n\e[31m   |\e[0m                           \
    \                  ')' expected, but ':' found\n\e[31m\e[31m-- [E081] Type Error:\
    \ /tmp/tmpwv2pncz1.scala:15:46 -----------------------------\e[0m\e[0m\n\e[31m15\
    \ |\e[0m        \e[33mval\e[0m \e[36mbits\e[0m = arr.map(_ => Long.bitCount(_))\n\
    \e[31m\e[31m   |\e[0m                                              ^\e[0m\n\e\
    [31m   |\e[0m   Missing parameter type\n\e[31m   |\e[0m\n\e[31m   |\e[0m   I could\
    \ not infer the type of the parameter _$2 of expanded function:\n\e[31m   |\e\
    [0m   _$2 => Long.bitCount(_$2).\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpwv2pncz1.scala:15:37\
    \ ------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e\
    [36mbits\e[0m = arr.map(_ => Long.bitCount(_))\n\e[31m\e[31m   |\e[0m        \
    \                        ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                 \
    \          value bitCount is not a member of object Long\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpwv2pncz1.scala:19:19 ------------------------\e[0m\e\
    [0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mbins\e[0m = binary(ones, len)\n\
    \e[31m\e[31m   |\e[0m                   ^^^^^^\e[0m\n\e[31m   |\e[0m         \
    \          Not found: binary\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpwv2pncz1.scala:23:36 ------------------------\e[0m\e[0m\n\e[31m23 |\e\
    [0m            \e[33mcase\e[0m Seq(dec1, dec2) => dec1.zip(dec2) \e[33mmatch\e\
    [0m {\n\e[31m\e[31m   |\e[0m                                    ^^^^\e[0m\n\e\
    [31m   |\e[0m                                    Not found: dec1\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpwv2pncz1.scala:24:36 ------------------------\e\
    [0m\e[0m\n\e[31m24 |"
  stdout: ''
  timestamp: 1660004051
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        //1. Sort array using binary sort\n        val ones\
    \ = arr.count(_ == 1)\n        val twos = arr.count(_ == 2)\n        val threes\
    \ = arr.count(_ == 3)\n        val fours = arr.count(_ == 4)\n        val fives\
    \ = arr.count(_ == 5)\n        val sixes = arr.count(_ == 6)\n        val sevens\
    \ = arr.count(_ == 7)\n        val eights = arr.count(_ == 8)\n        val nines\
    \ = arr.count(_ == 9)\n        val tens = arr.count(_ == 10)\n        val hundreds\
    \ = arr.count(_ == 100)\n        val thousands = arr.count(_ == 1000)\n      \
    \  val millions = arr.count(_ == 1000000)\n        val billions = arr.count(_\
    \ == 1000000000)\n        val onesArr = ones + twos + threes + fours + fives +\
    \ sixes + sevens + eights + nines + tens + hundreds + thousands + millions + billions\n\
    \        val twosArr = twos + threes + fours + fives + sixes + sevens + eights\
    \ + nines + tens + hundreds + thousands + millions + billions\n        val threesArr\
    \ = threes + fours + fives + sixes + sevens + eights + nines + tens + hundreds\
    \ + thousands + millions + billions\n        val foursArr = fours + fives + sixes\
    \ + sevens + eights + nines + tens + hundreds + thousands + millions + billions\n\
    \        val fivesArr = fives + sixes + sevens + eights + nines + tens + hundreds\
    \ + thousands + millions + billions\n        val sixesArr = sixes + sevens + eights\
    \ + nines + tens + hundreds + thousands + millions + billions\n        val sevensArr\
    \ = sevens + eights + nines + tens + hundreds + thousands + millions + billions\n\
    \        val eightsArr = eights + nines + tens + hundreds + thousands + millions\
    \ + billions\n        val ninesArr = nines + tens + hundreds + thousands + millions\
    \ + billions\n        val tensArr = tens + hundreds + thousands + millions + billions\n\
    \        val \n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpt728zzbi.scala:40:11 ---------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpt728zzbi.scala:41:5 ---------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660004050
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.groupBy(x => Integer.bitCount(x))\n\
    \        val twos = arr.groupBy(x => Integer.bitCount(x) >> 1)\n        val threes\
    \ = arr.groupBy(x => Integer.bitCount(x) >> 2)\n        val fours = arr.groupBy(x\
    \ => Integer.bitCount(x) >> 3)\n        val fives = arr.groupBy(x => Integer.bitCount(x)\
    \ >> 4)\n        val sixes = arr.groupBy(x => Integer.bitCount(x) >> 5)\n\n  \
    \      val newArr: List[Long] = new mutable.ArrayList[Long]()\n\n        var i\
    \ = 0\n        while(i < arr.length) {\n            val firstGroup = ones.get(arr(i))\n\
    \            val secondGroup = twos.get(arr(i))\n            val thirdGroup =\
    \ threes.get(arr(i))\n            val fourthGroup = fours.get(arr(i))\n      \
    \      val fifthGroup = fives.get(arr(i))\n            val sixthGroup = sixes.get(arr(i))\n\
    \n            val sortByOnes = firstGroup.map(x => if (x == 0) x else Integer.MAX_VALUE).max\n\
    \            val sortByTwos = secondGroup.map(x => if (x == 0) x else Integer.MAX_VALUE).max\n\
    \            val sortByThrees = thirdGroup.map(x => if (x == 0) x else Integer.MAX_VALUE).max\n\
    \            val sortByFours = fourthGroup.map(x => if (x == 0) x else Integer.MAX_VALUE).max\n\
    \            val sortByFives = fifthGroup.map(x => if (x == 0) x else Integer.MAX_VALUE).max\n\
    \            val sortBySixes = sixthGroup.map(x => if (x == 0) x else Integer.MAX_VALUE).max\n\
    \n            if(sortByOnes > sortByTwos && sortByOnes > sortByThrees && sortByOnes\
    \ > sortByFours && sortByOnes > sortByFives && sortByOnes > sortBySixes) {\n \
    \               newArr += arr(i).toLong\n                i += 1\n            }\
    \ else if(sortByTwos > sortByOnes && sortByTwos > sortByThrees && sortByTwos >\
    \ sortByFours && sortByTwos > sortByFives && sortByTwos > sortBySixes) {\n   \
    \             newArr += arr(i).toLong\n                i += 1\n            } else\
    \ if(sortByThrees > sortByOnes && sortByThrees > sortByTwos && sortByThrees >\
    \ sortByFours && sortByThrees > sortByFives && sortByThrees > sortBySixes) {\n\
    \                newArr += arr(i).toLong\n                i += 1\n           \
    \ } else if(sortByFours > sortByOne\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpoq_46t3o.scala:50:4 ----------------------------\e\
    [0m\e[0m\n\e[31m50 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpoq_46t3o.scala:63:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m63 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmpoq_46t3o.scala:15:53 --------------------\e[0m\e[0m\n\
    \e[31m15 |\e[0m        \e[33mval\e[0m \e[36mones\e[0m = arr.groupBy(\e[36mx\e\
    [0m => Integer.bitCount(x))\n\e[31m\e[31m   |\e[0m                           \
    \                          ^\e[0m\n\e[31m   |\e[0m                           \
    \                         Found:    (x : Long)\n\e[31m   |\e[0m              \
    \                                      Required: Int\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpoq_46t3o.scala:16:53 --------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mtwos\e[0m = arr.groupBy(\e\
    [36mx\e[0m => Integer.bitCount(x) >> \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m    \
    \                                                 ^\e[0m\n\e[31m   |\e[0m    \
    \                                                Found:    (x : Long)\n\e[31m\
    \   |\e[0m                                                    Required: Int\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpoq_46t3o.scala:17:55\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mthrees\e\
    [0m = arr.groupBy(\e[36mx\e[0m => Integer.bitCount(x) >> \e[31m2\e[0m)\n\e[31m\e\
    [31m   |\e[0m                                                       ^\e[0m\n\e\
    [31m   |\e[0m                                                    Found:    (x\
    \ : Long)\n\e[31m   |\e[0m                                                   \
    \ Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpoq_46t3o.scala:18:54"
  stdout: ''
  timestamp: 1660004052
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val sortedArr = arr.sortWith(\n            (x1: Long,\
    \ x2: Long) => if (x2 == 0) x1 < x2 else x2 < x1)\n        sortedArr\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpa359l8qt.scala:20)\n\tat Problem.main(tmpa359l8qt.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660004051
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        arr\n            .foldLeft(List[Long]())((acc, x)\
    \ => {\n                val bin = x.toBinaryString\n                val count\
    \ = bin.count(_ == '1')\n                val dec = bin.toInt() % (2 * Integer.MAX_VALUE)\n\
    \                acc :+ (if(count > 0) dec else -dec)\n            })\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E050] Type Error: /tmp/tmpp6hntw1_.scala:19:30 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m                \e[33mval\e[0m \e[36mdec\e[0m = bin.toInt()\
    \ % (\e[31m2\e[0m * Integer.MAX_VALUE)\n\e[31m\e[31m   |\e[0m                \
    \          ^^^^^^^^^\e[0m\n\e[31m   |\e[0m                \e[33mmethod\e[0m \e\
    [35mtoInt\e[0m in \e[33mclass\e[0m \e[35mStringOps\e[0m does not take parameters\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660004049
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        arr.sortWith((a, b) => b - a) match {\n          \
    \  case List() => arr.sorted\n            case List(a) => a :: sortArray(arr.filter(_\
    \ <= a).reverse)\n            case _ =>  sortArray(arr.filter(_ <= arr.min))\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4pqvy5kf.scala:15:31\
    \ --------------------\e[0m\e[0m\n\e[31m15 |\e[0m        arr.sortWith((\e[36ma\e\
    [0m, \e[36mb\e[0m) => b - a) \e[33mmatch\e[0m {\n\e[31m\e[31m   |\e[0m       \
    \                        ^^^^^\e[0m\n\e[31m   |\e[0m                         \
    \      Found:    Long\n\e[31m   |\e[0m                               Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660004050
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = new mutable.HashSet[Long]()\n        val\
    \ zeros = new mutable.HashSet[Long]()\n        for (elem <- arr) {\n         \
    \   if(elem==1l.toLong){ones.add(elem)}\n            if(elem==0l.toLong){zeros.add(elem)}\n\
    \        }\n        val result = new mutable.ArrayList[Long]()\n        if(ones.isEmpty){\n\
    \            val remainedZeros = new mutable.HashSet[Long]()\n            for(elem\
    \ <- zeros){\n                if(remainedZeros.contains(elem)){\n            \
    \        result.add(-elem);\n                    remainedZeros.remove(elem)\n\
    \                }\n            }\n            result\n        }\n        else{\n\
    \            val oneRemained = new mutable.HashSet[Long]()\n            for(elem\
    \ <- ones){\n                if(oneRemained.contains(elem)){\n               \
    \     result.add(elem);\n                    oneRemained.remove(elem)\n      \
    \          }\n                else{\n                    result.add(elem);\n \
    \                   oneRemained.add(elem)\n                }\n            }\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp1c9fxx1b.scala:15:23 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mones\e[0m = \e[33mnew\e\
    [0m mutable.HashSet[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                \
    \       ^^^^^^^\e[0m\n\e[31m   |\e[0m                       Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp1c9fxx1b.scala:16:24\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mzeros\e[0m = \e[33mnew\e[0m mutable.HashSet[\e[35mLong\e[0m]()\n\e[31m\e[31m\
    \   |\e[0m                        ^^^^^^^\e[0m\n\e[31m   |\e[0m              \
    \          Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp1c9fxx1b.scala:21:25 ------------------------\e[0m\e[0m\n\e[31m21 |\e\
    [0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e[0m mutable.ArrayList[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                         ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                         Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmp1c9fxx1b.scala:23:36 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            \e[33mval\e[0m \e[36mremainedZeros\e[0m =\
    \ \e[33mnew\e[0m mutable.HashSet[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                                 ^^^^^^^\e[0m\n\e[31m   |\e[0m              \
    \                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmp1c9fxx1b.scala:33:34 ------------------------\e[0m\e\
    [0m\n\e[31m33 |\e[0m            \e[33mval\e[0m \e[36moneRemained\e[0m = \e[33mnew\e\
    [0m mutable.HashSet[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                \
    \                  ^^^^^^^\e[0m\n\e[31m   |\e[0m                             \
    \     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n5 errors f"
  stdout: ''
  timestamp: 1660004049
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        // O(n)\n        val onesInBins = arr\n          \
    \  .map(_ => 1L * _)\n            .reduce(_ + _)\n            .asInstanceOf[Long]\n\
    \            .grouped(2)\n            .toList\n            .sortWith(_._1 < _._1)\n\
    \            .map(_._2)\n            .toList\n            .reverse\n        //\
    \ O(n log n)\n        val onesInBinsSorted = onesInBins.reverse.sortWith(_ < _)\n\
    \        // O(n log n)\n        val onesInDecimal = onesInBinsSorted\n       \
    \     .groupBy(x => x.toLong)\n            .mapValues(_.map(_(0).toLong))\n  \
    \          .toList\n            .sortWith(_ < _)\n            .map(_._2)\n   \
    \         .toList\n            .reverse\n        // O(n)\n        val sortedWithDecimal\
    \ = onesInDecimal.sortWith(_ < _)\n        sortedWithDecimal\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong,\
    \ -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong,\
    \ -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E081] Type Error: /tmp/tmpi8lsiis8.scala:17:27 -----------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m            .map(_ => \e[31m1L\e[0m * _)\n\e[31m\e[31m\
    \   |\e[0m                           ^\e[0m\n\e[31m   |\e[0m   Missing parameter\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m   I could not infer the type of the parameter\
    \ _$2 of expanded function:\n\e[31m   |\e[0m   _$2 => \e[31m1L\e[0m * _$2.\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpi8lsiis8.scala:18:22 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m            .reduce(_ + _)\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^\e[0m\n\e[31m   |\e[0mvalue + is not a member of Any, but\
    \ could be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mOne of the following imports might make progress towards fixing the problem:\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660004052
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        if (arr.isEmpty || arr.size == 1) arr\n        else\
    \ {\n            var arr = arr.sortWith(compare(arr))\n            sortArray(arr.tail)\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpeic7jihz.scala:17:22 ---------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m            \e[33mvar\e[0m \e[36marr\e[0m = arr.sortWith(compare(arr))\n\
    \e[31m\e[31m   |\e[0m                      ^\e[0m\n\e[31m   |\e[0m           \
    \           Recursive \e[33mvariable\e[0m \e[35marr\e[0m needs type\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660004050
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        var ans = arr.toList.sortWith(_ > _)\n        if(arr.length\
    \ < 2) ans\n        else {\n            var m = arr.head\n            var n =\
    \ arr.last\n            var i = 0\n            while(i<ans.length-1 && ans.head==i)\
    \ i+=1\n            while(i<ans.length-1 && ans.last==i) i+=1\n            while(true){\n\
    \                if(ans.head==i) m += 1\n                if(ans.last==i) n +=\
    \ 1\n                if(i == ans.length-1) break\n                i +=1\n    \
    \        }\n            ans = arr.toList.sortWith(x => x > m && x < n)\n     \
    \   }\n        ans\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpj5p4p8uu.scala:26:38 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m                \e[33mif\e[0m(i == ans.length-\e[31m1\e\
    [0m) break\n\e[31m\e[31m   |\e[0m                                      ^^^^^\e\
    [0m\n\e[31m   |\e[0m                                      Not found: break\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E086] Syntax Error: /tmp/tmpj5p4p8uu.scala:29:40\
    \ ---------------------------\e[0m\e[0m\n\e[31m29 |\e[0m            ans = arr.toList.sortWith(\e\
    [36mx\e[0m => x > m && x < n)\n\e[31m\e[31m   |\e[0m                         \
    \             ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                      \
    \           Wrong number of parameters, expected: 2\n2 errors found\n"
  stdout: ''
  timestamp: 1660004051
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        arr.groupBy(_ % 2).keys.toList.sortWith(_ < _) //\
    \ sort by number of ones\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp3x5c1n53.scala:18)\n\tat Problem.main(tmp3x5c1n53.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660004053
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        arr.sortBy( x => (arr.count(i => i==x.toBinaryString().reverse.dropWhile(_=='0').reverse.headOption).getOrElse(1),x))\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp1g2_y0qj.scala:15:60 -----------------------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        arr.sortBy( \e[36mx\e[0m => (arr.count(\e[36mi\e\
    [0m => i==x.toBinaryString().reverse.dropWhile(_==\e[31m'0'\e[0m).reverse.headOption).getOrElse(\e\
    [31m1\e[0m),x))\n\e[31m\e[31m   |\e[0m                                       \
    \     ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmissing argument for parameter i\
    \ of \e[33mmethod\e[0m \e[35mapply\e[0m in \e[33mclass\e[0m \e[35mStringOps\e\
    [0m: (i: Int): Char\n\e[31m\e[31m-- Error: /tmp/tmp1g2_y0qj.scala:15:125 ----------------------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        arr.sortBy( \e[36mx\e[0m => (arr.count(\e[36mi\e\
    [0m => i==x.toBinaryString().reverse.dropWhile(_==\e[31m'0'\e[0m).reverse.headOption).getOrElse(\e\
    [31m1\e[0m),x))\n\e[31m\e[31m   |\e[0m                                       \
    \                                                                            \
    \          ^\e[0m\n\e[31m   |\e[0mambiguous given instances of type Ordering[(T1,\
    \ T2)] found for parameter ord of \e[33mmethod\e[0m \e[35msortBy\e[0m in \e[33mtrait\e\
    [0m \e[35mSeqOps\e[0m.\n\e[31m   |\e[0mI found:\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m    scala.math.Ordering.Tuple2[\e[35mT1\e[0m, \e[35mT2\e[0m](\n\e[31m   |\e\
    [0m      /* ambiguous: both \e[33mobject\e[0m \e[35mByte\e[0m in \e[33mobject\e\
    [0m \e[35mOrdering\e[0m and \e[33mobject\e[0m \e[35mBigDecimal\e[0m in \e[33mobject\e\
    [0m \e[35mOrdering\e[0m match type Ordering[T1] */\n\e[31m   |\e[0m        summon[Ordering[T1]]\n\
    \e[31m   |\e[0m    , scala.math.Ordering.Long)\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mBut both \e[33mobject\e[0m \e[35mByte\e[0m in \e[33mobject\e[0m \e[35mOrdering\e\
    [0m and \e[33mobject\e[0m \e[35mBigDecimal\e[0m in \e[33mobject\e[0m \e[35mOrdering\e\
    [0m match type Ordering[T1].\n2 errors found\n"
  stdout: ''
  timestamp: 1660004052
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        var zeroCount = 0\n        var oneCount = 0\n    \
    \    var sortedList = arr.toList\n        var sortedListLength = sortedList.length\n\
    \        var sortedListLength = sortedListLength - 1\n        while (oneCount\
    \ < sortedListLength - 1 && zeroCount < sortedListLength - 1) {\n            if\
    \ (sortedList(oneCount) == 1) {\n                oneCount = oneCount + 1\n   \
    \         } else {\n                zeroCount = zeroCount + 1\n            }\n\
    \        }\n        if (oneCount < sortedListLength - 1) {\n            val tempOneCount\
    \ = oneCount\n            val tempZeroCount = zeroCount\n            var zeroIndex\
    \ = 0\n            oneCount = sortedListLength - 1\n            zeroCount = 0\n\
    \            while (oneCount < sortedListLength - 1 && zeroCount < sortedListLength\
    \ - 1) {\n                if (sortedList(oneCount) == 0) {\n                 \
    \   oneCount = oneCount + 1\n                } else {\n                    zeroCount\
    \ = zeroCount + 1\n                }\n            }\n            val tempSortedList\
    \ = sortedList\n            sortedList = tempSortedList.take(tempOneCount)\n \
    \           sortedListLength = sortedList.length\n            zeroCount = tempZeroCount\n\
    \            oneCount = tempOneCount\n            sortedListLength = sortedListLength\
    \ - 1\n            val tempZeroIndex = zeroIndex\n            val tempOneIndex\
    \ = oneIndex\n            while (oneCount < sortedListLength - 1 && zeroCount\
    \ < sortedListLength - 1) {\n                if (sortedList(oneCount) == 0) {\n\
    \                    oneCount = oneCount + 1\n                } else {\n     \
    \               zeroCount = zeroCount + 1\n                }\n            }\n\
    \            zeroIndex = tempZeroIndex\n            oneIndex = tempOneIndex\n\
    \            while (oneCount < sortedListLength - 1) {\n                if (sortedList(oneCount)\
    \ == 0) {\n                    oneCount = oneCount + 1\n                } else\
    \ {\n                    zeroCount = zeroCount + 1\n                }\n      \
    \      }\n            val tempOneIndex = oneIndex\n            oneCount = sortedListLength\
    \ - 1\n            zeroCount = 0\n            while (oneCount < sortedListLength\
    \ - 1) {\n                if (sortedList(oneCount) == 1) {\n                 \
    \   oneCount = oneCount + 1\n                } else {\n                    zeroCount\
    \ = zeroCount + 1\n                }\n            }\n            oneIndex = tempOneIndex\n\
    \            val tempZeroCount = zeroCount\n            zeroCount = tempZeroCount\n\
    \            sortedList = tempSortedList.take(tempOneCount)\n            sortedListLength\
    \ = sortedList.length\n        }\n        if (zeroCount > 0) {\n            var\
    \ tempZeroCount = zeroCount\n            zeroCount = 0\n            val tempSortedList\
    \ = sortedList\n            sortedList = tempSortedList.take(tempZeroCount)\n\
    \            sortedListLength = sortedList.length\n            val tempZeroIndex\
    \ = zeroIndex\n            zeroIndex = 0\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpfrpr0qzw.scala:101:0 ---------------------------\e\
    [0m\e[0m\n\e[31m101 |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m'}'\
    \ expected, but eof found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpfrpr0qzw.scala:19:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mvar\e[0m\
    \ \e[36msortedListLength\e[0m = sortedListLength - \e[31m1\e[0m\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0msortedListLength is already defined as \e[33mvariable\e[0m \e[35msortedListLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpfrpr0qzw.scala:64:16 ---------------------------\e[0m\e[0m\n\e\
    [31m64 |\e[0m            \e[33mval\e[0m \e[36mtempOneIndex\e[0m = oneIndex\n\e\
    [31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mtempOneIndex is already defined as \e[33mvalue\e[0m \e[35mtempOneIndex\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpfrpr0qzw.scala:75:16 ---------------------------\e[0m\e[0m\n\e[31m75\
    \ |\e[0m            \e[33mval\e[0m \e[36mtempZeroCount\e[0m = zeroCount\n\e[31m\e\
    [31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mtempZeroCount\
    \ is already defined as \e[33mvalue\e[0m \e[35mtempZeroCount\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpfrpr0qzw.scala:47:31\
    \ ------------------------\e[0m\e[0m\n\e[31m47 |\e[0m            \e[33mval\e[0m\
    \ \e[36mtempOneIndex\e[0m = oneIndex\n\e[31m\e[31m   |\e[0m                  \
    \             ^^^^^^^^\e[0m\n\e[31m   |\e[0m                               Not\
    \ found: oneIndex\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpfrpr0qzw.scala:56:12\
    \ ------------------------\e[0m\e[0m\n\e[31m56 |\e[0m            oneI"
  stdout: ''
  timestamp: 1660004053
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val numOfOnes = arr.map(i => Integer.bitCount(i)).max\n\
    \        arr.sortBy(i => -numOfOnes - Integer.bitCount(i))\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong,\
    \ -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong,\
    \ -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmps9ghavk0.scala:15:54\
    \ --------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mnumOfOnes\e\
    [0m = arr.map(\e[36mi\e[0m => Integer.bitCount(i)).max\n\e[31m\e[31m   |\e[0m\
    \                                                      ^\e[0m\n\e[31m   |\e[0m\
    \                                                    Found:    (i : Long)\n\e\
    [31m   |\e[0m                                                    Required: Int\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmps9ghavk0.scala:16:54\
    \ --------------------\e[0m\e[0m\n\e[31m16 |\e[0m        arr.sortBy(\e[36mi\e\
    [0m => -numOfOnes - Integer.bitCount(i))\n\e[31m\e[31m   |\e[0m              \
    \                                        ^\e[0m\n\e[31m   |\e[0m             \
    \                                       Found:    (i : Long)\n\e[31m   |\e[0m\
    \                                                    Required: Int\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660004053
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort a list of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val res = arr.sortWith((a, b) => arr.count(b => a\
    \ & (b >> Integer.bitCount(b)) == b) <= arr.count(b => a & (b >> Integer.bitCount(b))\
    \ == a & (b >> Integer.bitCount(b))))\n        res.reverse\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong,\
    \ -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong,\
    \ -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpvlsg7hci.scala:15:83\
    \ --------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mres\e\
    [0m = arr.sortWith((\e[36ma\e[0m, \e[36mb\e[0m) => arr.count(\e[36mb\e[0m => a\
    \ & (b >> Integer.bitCount(b)) == b) <= arr.count(\e[36mb\e[0m => a & (b >> Integer.bitCount(b))\
    \ == a & (b >> Integer.bitCount(b))))\n\e[31m\e[31m   |\e[0m                 \
    \                                                                  ^\e[0m\n\e\
    [31m   |\e[0m                                                    Found:    (b\
    \ : Long)\n\e[31m   |\e[0m                                                   \
    \ Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpvlsg7hci.scala:15:58\
    \ -----------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e\
    [0m \e[36mres\e[0m = arr.sortWith((\e[36ma\e[0m, \e[36mb\e[0m) => arr.count(\e\
    [36mb\e[0m => a & (b >> Integer.bitCount(b)) == b) <= arr.count(\e[36mb\e[0m =>\
    \ a & (b >> Integer.bitCount(b)) == a & (b >> Integer.bitCount(b))))\n\e[31m\e\
    [31m   |\e[0m                                                        ^^^\e[0m\n\
    \e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e[35m&\e\
    [0m in \e[33mclass\e[0m \e[35mLong\e[0m with types\n\e[31m   |\e[0m (x: Long):\
    \ Long\n\e[31m   |\e[0m (x: Int): Long\n\e[31m   |\e[0m (x: Char): Long\n\e[31m\
    \   |\e[0m (x: Short): Long\n\e[31m   |\e[0m (x: Byte): Long\n\e[31m   |\e[0mmatch\
    \ arguments (Boolean)\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpvlsg7hci.scala:15:138\
    \ -------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mres\e\
    [0m = arr.sortWith((\e[36ma\e[0m, \e[36mb\e[0m) => arr.count(\e[36mb\e[0m => a\
    \ & (b >> Integer.bitCount(b)) == b) <= arr.count(\e[36mb\e[0m => a & (b >> Integer.bitCount(b))\
    \ == a & (b >> Integer.bitCount(b))))\n\e[31m\e[31m   |\e[0m                 \
    \                                                                            \
    \                                             ^\e[0m\n\e[31m   |\e[0m        \
    \                                            Found:    (b : Long)\n\e[31m   |\e\
    [0m  "
  stdout: ''
  timestamp: 1660004053
