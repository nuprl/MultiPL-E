name: HumanEval_79_decimal_to_binary
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // You will be given a number in decimal form and your task is to convert it\
  \ to\n    // binary format. The function should return a string, with each character\
  \ representing a binary\n    // number. Each character in the string will be '0'\
  \ or '1'.\n    // There will be an extra couple of characters 'db' at the beginning\
  \ and at the end of the string.\n    // The extra characters are there to help with\
  \ the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n    // (\"db1111db\"\
  )\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\")\n    def decimalToBinary(decimal\
  \ : Long) : String = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
  db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"\
  db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n\
  \    }\n\n}\n"
completions: ["        val binary = decimal.toBinaryString\n        val result = \"\
    db\" + binary.substring(binary.length - 3, binary.length)\n        result ++ \"\
    db\"", "        val base = 10\n        val binary = decimal.toString.reverse.foldLeft(\"\
    \") { (s, dec) => s + dec.toChar(base) }\n        val pad = \"\" * ((decimal.toString.length\
    \ + 1) - binary.length)\n        (pad + binary + \"db\")", "        if (decimal\
    \ == 0) {\n          return \"0\"\n        }\n        \n        var result: String\
    \ = \"1\"\n        var remainder: Long = decimal % 2\n        \n        for(i\
    \ <- 0 until 8) {\n          if(remainder > 0) {\n            result = (remainder.toString.charAt(0)\
    \ + result) \n          }\n          remainder = (decimal / 2).toLong\n      \
    \  }\n        \n        result += (remainder.toString.charAt(0) + result) \n \
    \       \n        result += \"db\"\n        result", "        val decimalStr =\
    \ Integer.toString(decimal)\n        val binary = mutable.ListBuffer.empty[String]\n\
    \        var i = decimalStr.length - 1\n        while (i >= 0) {\n           \
    \ if (decimalStr(i) == '0') {\n                binary.append(\"1\")\n        \
    \    } else {\n                binary.append(\"0\")\n            }\n         \
    \   i--\n        }\n        binary.reverse.toList.reverse.mkString", "       \
    \ if (decimal < 0) decimal = -1l - decimal\n        val binary = Decimal.bits(decimal).toList\n\
    \        binary.reverse.foreach(e => println(e.toBinaryString))\n        binary.reverse.tail.foreach(e\
    \ => println(e.toBinaryString))\n        binary.reverse.tail.head + binary.reverse.head\
    \ + \"db\"", "        val binary = scala.collection.mutable.ArrayBuffer.empty[String]\n\
    \        decimal match {\n            case 0 => binary.append(\"0\")\n       \
    \     case x => for(num <- 0 until decimal.toInt by 2){\n                if(num\
    \ == 0){\n                    binary.append(\"0\")\n                }\n      \
    \          else if(num % 2 == 0){\n                    binary.append(\"1\")\n\
    \                }\n                else{\n                    binary.append(\"\
    0\")\n                }\n            }\n        }\n        binary.append(\"db\"\
    )\n        binary.toList.toString()", "        // write your code here\n     \
    \   var binaryString = StringBuilder()\n        var remainder = decimal\n    \
    \    while (remainder > 0) {\n            binaryString.append(remainder % 2)\n\
    \            remainder = remainder / 2\n        }\n        binaryString.reverse\n\
    \        binaryString.append('db')\n        binaryString.reverse\n        binaryString.toString",
  "        var binaryString : String = \"\"\n        decimalToBinaryImpl(decimal,\
    \ 0, 0)\n        binaryString", "        var result : StringBuilder = new StringBuilder\n\
    \        decimal match {\n            case n if n <= 0 => \"db\"\n           \
    \ case n if n == 1 => \"db1\"\n            case n if n == 2 => \"db10\"\n    \
    \        case n if n == 3 => \"db11\"\n            case n if n == 4 => \"db100\"\
    \n            case n if n == 5 => \"db101\"\n            case n if n == 6  =>\
    \ \"db110\"\n            case n if n == 7  => \"db111\"\n            case n if\
    \ n == 8  => \"db1000\"\n            case n if n == 9  => \"db1001\"\n       \
    \     case n if n == 10 => \"db1010\"\n            case n if n == 11 => \"db1011\"\
    \n            case n if n == 12 => \"db1100\"\n            case n if n == 13 =>\
    \ \"db1101\"\n            case n if n == 14 => \"db1110\"\n            case n\
    \ if n == 15 => \"db1111\"\n        }\n        decimal match {\n            case\
    \ n if n > 15 => \"\"\n            case n if n > 14 => result.append(\"db1111\"\
    )\n            case n if n > 13 => result.append(\"db1110\")\n            case\
    \ n if n > 12 => result.append(\"db1100\")\n            case n if n > 11 => result.append(\"\
    db10\")\n            case n if n > 10 => result.append(\"db101\")\n          \
    \  case n if n > 9 => result.append(\"db100\")\n            case n if n > 8 =>\
    \ result.append(\"db1001\")\n            case n if n > 7 => result.append(\"db1000\"\
    )\n            case n if n > 6 => result.append(\"db1100\")\n            case\
    \ n if n > 5 => result.append(\"db110\")\n            case n if n > 4 => result.append(\"\
    db1101\")\n            case n if n > 3 => result.append(\"db11\")\n          \
    \  case n if n > 2 => result.append(\"db111\")\n            case n if n > 1 =>\
    \ result.append(\"db101\")\n            case n if n > 0 => result.append(\"db1\"\
    )\n        }\n        result.toString", "        val bits = decimal.toBinaryString\n\
    \        val db = \"db\".toCharArray\n\n        val res =\n            bits.padTo(8,\
    \ \"0\") + db + bits.dropRight(8).toCharArray\n\n        \"db\" + res.mkString",
  "        val remainder = decimal.toInt\n        val decimal2 = decimal - remainder\n\
    \        val stringBuilder = new StringBuilder()\n        var i = 0\n        while(decimal2\
    \ != 0) {\n            stringBuilder.append(if (decimal2 % 2 == 0) \"0\" + \"\
    1\" + \"0\" else \"1\" + \"0\" + \"0\")\n            decimal2 /= 2\n         \
    \   i += 1\n        }\n        stringBuilder.append(if (remainder != 0) \"0\"\
    \ + \"1\" else \"1\" + \"0\")\n        stringBuilder.append(\"db\")\n        stringBuilder.toString()",
  "        val n = decimal.toInt\n        val str = \"\"\n        while(decimal >\
    \ 0) {\n            str +=(decimal.toInt % 2).toString\n            decimal /=\
    \ 2\n        }\n        str + \"db\"+ str", "        val reversed = decimal.toString.reverse.grouped(2).map(_.mkString).reverse\n\
    \        val extra = \"db\".toCharArray.mkString\n        (reversed + extra +\
    \ reversed + extra).padToString(16, '0')", "        var result : String = \"\"\
    \n        var remainder : Long = decimal\n        var i = decimal.toInt\n\n  \
    \      // Convert the number to binary\n        for(j <- 0 until i) {\n      \
    \      if(remainder < 1) {\n                result += \"0\"\n                remainder\
    \ = 0\n            } else if(remainder < 2) {\n                result += \"1\"\
    \n                remainder = 0\n            } else {\n                result\
    \ += \"0\"\n                remainder = remainder - 2\n            }\n       \
    \ }\n        return result", "        val binary = new mutable.MutableList[Char]\n\
    \        for (i <- decimal.toInt until decimal + 1) {\n            if (i >= 10)\
    \ binary.addOne()\n            else binary.addZero()\n        }\n        if (decimal.equals(1l))\
    \ {\n            binary.addOne()\n        }\n        binary.addOne()\n       \
    \ binary.addOne()\n        binary.addZero()\n        binary.toList.reverse.mkString",
  "        var bitString = decimal.toBinaryString()\n        var result : String =\
    \ \"\"\n        for(i <- 0 to bitString.length -2){\n            result += \"\
    0b\"\n        }\n        result += \"0\"\n        return result", "        var\
    \ binary = decimal.toBinaryString()\n        if (decimal.isLeadingZero) binary\
    \ = \"db\" + binary\n        var lastIndex = binary.length - 1\n        var zeros\
    \ = 0\n        while (zeros < decimal.asInstanceOf[Long] - lastIndex) {\n    \
    \        binary = binary + \"0\"\n            lastIndex--\n            zeros++\n\
    \        }\n        return binary", "        val num = (decimal.toString + \"\"\
    )\n        val binary = new mutable.MutableList[Char]()\n        var index = 0\n\
    \        while (index < num.length) {\n            val remainder = num.charAt(index)\
    \ - '0';\n            if (remainder >= 10) {\n                val newValue = remainder\
    \ % 10;\n                binary.add('0' + newValue);\n                index +=\
    \ 1\n            } else {\n                binary.add('0' + remainder)\n     \
    \           index += 1\n            }\n        }\n        binary.add('d')\n  \
    \      binary.add('b')\n        binary.toList", "        def decimalToBin(num:Long)\
    \ : String = {\n            val bits = num.toBits\n            var result = \"\
    \"\n            var i = bits.length - 1;\n            while (i >= 0) {\n     \
    \           result += bits.toChar(i).toString.reverse\n                i--;\n\
    \            }\n            return result;\n        }\n        // We want to keep\
    \ the first few bits and shift everything else over\n        val bits = decimal.toBits\n\
    \        val numBits = bits.length\n        val firstBits = bits.take(numBits\
    \ - 2)\n        val rest = bits.drop(numBits - 2)\n        // We need the first\
    \ bit to determine what position the next bit should be at\n        val firstDigit\
    \ = if (firstBits.isEmpty) 0 else 1\n        val numDigits = numBits - firstDigit\
    \ - 1\n        val result = \"db\"\n        if (numDigits == 0) {\n          \
    \  // No remainder, just a single digit\n            result += decimalToBin(decimal)\n\
    \        } else {\n            // There are remainders.  Add leading zeros and\
    \ place remainder at correct position\n            val firstRemainder = if (firstDigit\
    \ == 1) 0 else rest.toChar(0).toString.reverse\n            val remainderIndex\
    \ = firstDigit - 1\n            var remainder = \"\"\n            for (i <- 0\
    \ until numDigits) {\n                remainder = \"0\" + (remainder + decimalToBin(rest.dropRight(1)))\
    \ + remainder\n                remainderIndex -= 1\n            }\n          \
    \  result = firstRemainder + remainder\n        }\n        return result;", " \
    \       val b = BigInt(decimal).toBinaryString\n        val pad = \"db\".repeat(decimal.toString.length\
    \ + 1)\n        val result = pad + b + pad\n        result", "        // Your\
    \ code here\n        val binary = new mutable.StringBuilder\n        for(i <-\
    \ 0 until decimal.toInt) {\n            val power = decimal.toInt - i\n      \
    \      if(power > 1) \n                binary.append(1l)\n            else if(power\
    \ == 1)\n                binary.append(0)\n            else\n                binary.append(1)\n\
    \        }\n        binary.reverse", "        val result = decimal.toString(2).reverse.map(x\
    \ => (x == '1').toString)\n        (result.tail, result.head) match {\n      \
    \      case (Array(), _) => result.toString\n            case (Array(head), Array(_))\
    \ => head + result.toString\n            case (_, Array(tail)) => head + tail.reverse.map(x\
    \ => (x == '1').toString).toString + result.toString\n            case _ => result.toString\n\
    \        }", "        var binary = new mutable.StringBuilder\n        var decimal2\
    \ = decimal\n        var bit = 1\n\n        while(decimal2 > 0) {\n          \
    \  if(decimal2 % 2 == 0) {\n                binary.append(\"0\")\n           \
    \ } else {\n                binary.append(\"1\")\n            }\n\n          \
    \  decimal2 /= 2\n        }\n\n        binary += binary.reverse\n\n        binary\
    \ = binary.reverse\n\n        binary.insert(0,\"db\")\n        binary.append(\"\
    db\")\n\n        return binary.toString", "        val binary = decimal.toBinaryString\n\
    \        val binaryLength = binary.length\n        val output = new StringBuilder(binary.length)\n\
    \        var i = 0\n        while(i < binaryLength) {\n            val curr =\
    \ binary(i)\n            output.append('0')\n            i += 1 while (i + 1 <\
    \ binaryLength && curr != binary(i + 1))\n            output.append('1')\n   \
    \         i += 1 while (i + 1 < binaryLength && curr == binary(i + 1))\n     \
    \   }\n        output + binary.takeRight(binaryLength)", "        val result =\
    \ decimal.toBinaryString\n        if(result.length > 32) {\n            result.substring(0,31)\
    \ + \"db\"\n        }\n        else {\n            result + \"db\"\n        }",
  "        var binary = \"\"\n        for( i <- decimal to 2l toInt by 1 ){\n    \
    \        binary += if( (i.toLong.toBinaryString).length < 8 )\n              \
    \  (\"0\" * (8 - i.toLong.toBinaryString.length)).toBinaryString + i.toLong.toBinaryString\n\
    \            else\n                i.toLong.toBinaryString\n        }\n      \
    \  binary += \"db\"\n        binary += binary.substring( binary.length - 4 )\n\
    \        binary += \"db\"\n        binary", "        if (decimal == 0) {\n   \
    \         return \"0\"\n        } else if (decimal > 0) {\n            var binary\
    \ = String.empty\n            while (decimal > 0) {\n                binary +=\
    \ decimalToBinary(decimal - 1)\n                decimal -= 1\n            }\n\
    \            return binary + \"b\"\n        } else {\n            var binary =\
    \ \"1b\"\n            while (decimal < 0) {\n                binary += \"0\" +\
    \ decimalToBinary(-decimal)\n                decimal += 1\n            }\n   \
    \         return \"db\" + binary + \"db\"\n        }", "        var currentBin\
    \ : String = \"\"\n        var binary : Int = 0\n        var remainder : Long\
    \ = decimal\n        while (decimal != 0) {\n            binary = decimal % 2\n\
    \            currentBin = binaryToBinary(binary)\n            decimal /= 2\n \
    \           if (decimal != 0) {\n                remainder = remainder + decimal\n\
    \            }\n        }\n        currentBin + binaryToBinary(remainder)", " \
    \       var binaryString = \"\"\n        var decimalToBinary = decimal.toBinaryString\n\
    \        var numberOfDigits = decimalToBinary.length\n        \n        // Removing\
    \ extra characters at the begining and at the end\n        if(decimalToBinary.length\
    \ < 3)\n        decimalToBinary = Array(0,decimalToBinary)\n        \n       \
    \ if(decimalToBinary.length > 4)\n        decimalToBinary = Array(decimalToBinary.dropRight(decimalToBinary.length-4),\
    \ decimalToBinary(0), decimalToBinary(decimalToBinary.length-4))\n        \n \
    \       \n        for(i <- 0 until decimalToBinary.length-1)\n        {\n    \
    \        if(decimalToBinary(i) != \"0\")\n            {\n                binaryString\
    \ += decimalToBinary(i)\n            }\n        }\n        \n        for(i <-\
    \ 0 until numberOfDigits - 1)\n        {\n            binaryString += \"0\"\n\
    \        }\n        \n        \n        binaryString", "        // The code below\
    \ solves the problem in one line. First we convert decimal to binary format. Then\n\
    \        // we append an extra character ('d') to mark the beginning and end of\
    \ the string to be returned\n        // (note that in python, we could directly\
    \ use \"'%s'\" % str(decimal). The reason why we use \"'%s'\" is\n        // because\
    \ the string is converted to string in scala's toString() function, which is different\
    \ from\n        // python's). Then we append 'd' and 'b' at the beginning and\
    \ end of binary string\n        (decimal.toBinaryString.reverse).padToLength(8,\
    \ 'd') + \"db\"", "      var binary = \"\"\n      var numOfDigits = 0\n      while\
    \ (decimal > 0 ) {\n        binary = binary + decimalToBinary(decimal % 2) + if\
    \ (numOfDigits % 2 == 0) \"0\" else \"1\"\n        decimal = decimal / 2\n   \
    \     numOfDigits = numOfDigits + 1\n      }\n      return binary.reverse", " \
    \       var ret = \"\"\n        var remainder = decimal\n        var remainderI\
    \ = 0\n        var remainderII = 0\n        var remainderIII = 0\n        var\
    \ remainderIV = 0\n        var remainderV = 0\n        var remainderVI = 0\n \
    \       var remainderVII = 0\n        var remainderIX = 0\n        var remainderX\
    \ = 0\n        var remainderXI = 0\n        var remainderXI = 0\n        var remainderXII\
    \ = 0\n        var remainderXIII = 0\n        var remainderXIV = 0\n        var\
    \ remainderXV = 0\n        var remainderXVI = 0\n        var remainderXVII = 0\n\
    \        var remainderXX = 0\n        var remainderXXI = 0\n        var remainderXXII\
    \ = 0\n        var remainderXXIII = 0\n        var remainderXXIV = 0\n       \
    \ var remainderXXV = 0\n        var remainderXXVI = 0\n        var remainderXXVII\
    \ = 0\n        var remainderXXX = 0\n        var remainderXXXI = 0\n        var\
    \ remainderXXXII = 0\n        var remainderXXXIII = 0\n        var remainderXXXIV\
    \ = 0\n        var remainderXXXV = 0\n        var remainderXXXVI = 0\n       \
    \ var remainderXXXVII = 0\n        var remainderXXXX = 0\n        var remainderXXIX\
    \ = 0\n        var remainderXXXIII = 0\n        var remainderXXXIV = 0\n     \
    \   var remainderXXXV = 0\n        var remainderXXXVI = 0\n        var remainderXXXVII\
    \ = 0\n        var remainderXXV = 0\n        var remainderXXVI = 0\n        var\
    \ remainderXXVII = 0\n        var remainderXXIX = 0\n        var remainderXIX\
    \ = 0\n        var remainderXXI = 0\n        var remainderXI = 0\n        var\
    \ remainderI = 0\n        var remainder = 0\n        var temp = 0\n        var\
    \ temp1 = \"\"\n        var temp2 = \"\"\n        var temp3 = \"\"\n        var\
    \ temp4 = \"\"\n        var temp5 = \"\"\n        var temp6 = \"\"\n        var\
    \ temp7 = \"\"\n        var temp8 = \"\"\n        var temp9 = \"\"\n        var\
    \ temp10 = \"\"\n        var temp11 = \"\"\n        var temp12 = \"\"\n      \
    \  var temp13 = \"\"\n        var temp14 = \"\"\n        var temp15 = \"\"\n \
    \       var temp16 = \"\"\n        var temp17 = \"\"\n        var temp18 = \"\"\
    \n        var temp19 = \"\"\n        var temp20 = \"\"\n        var temp21 = \"\
    \"\n        var temp22 = \"\"\n        var temp23 = \"\"\n        var temp24 =\
    \ \"\"\n        var temp25 = \"\"\n        var temp26 = \"\"\n        var temp27\
    \ = \"\"\n        var temp28 = \"\"\n        var temp29 = \"\"\n        var temp30\
    \ = \"\"\n        var temp31 = \"\"", "        val decimalBits = (decimal.toString.toLong).reverse\n\
    \        var binary = \"\"\n        var power = 1\n        decimalBits foreach\
    \ { b => binary += if (b == '1'){\n            power\n        } else {\n     \
    \       power = \"1\"\n            power = power + \"0\"\n        }\n        }\n\
    \        binary += if (decimalBits != 0) \"1\" + \"0\"\n        binary + if (decimalBits\
    \ == 0) \"0\"\n        binary + if (decimalBits == 1) \"1\"\n        binary +\
    \ if (decimalBits == 2l) \"10\"\n        binary + if (decimalBits == 3l) \"100\"\
    \n        binary + if (decimalBits == 4l) \"1000\"\n        binary + if (decimalBits\
    \ == 5l) \"10000\"\n        binary + if (decimalBits == 6l) \"100000\"\n     \
    \   binary + if (decimalBits == 7l) \"1000000\"\n        binary + if (decimalBits\
    \ == 8l) \"10000000\"\n        binary + if (decimalBits == 9l) \"10000000\"\n\
    \        binary + if (decimalBits == 10l) \"100000000\"\n        binary + if (decimalBits\
    \ == 11l) \"1000000000\"\n        binary + if (decimalBits == 12l) \"10000000000\"\
    \n        binary + if (decimalBits == 13l) \"100000000000\"\n        binary +\
    \ if (decimalBits == 14l) \"1000000000000\"\n        binary + if (decimalBits\
    \ == 15l) \"10000000000000\"\n        binary + if (decimalBits == 16l) \"100000000000000\"\
    \n        binary + if (decimalBits == 17l) \"1000000000000000\"\n        binary\
    \ + if (decimalBits == 18l) \"10000000000000000\"\n        binary + if (decimalBits\
    \ == 19l) \"100000000000000000\"\n        binary + if (decimalBits == 20l) \"\
    1000000000000000000\"\n        binary + if (decimalBits == 21l) \"10000000000000000000\"\
    \n        binary + if (decimalBits == 22l) \"100000000000000000000\"\n       \
    \ binary + if (decimalBits == 23l) \"1000000000000000000000\"\n        binary\
    \ + if (decimalBits == 24l) \"10000000000000000000000\"\n        binary + if (decimalBits\
    \ == 25l) \"100000000000000000000000\"\n        binary + if (decimalBits == 26l)\
    \ \"1000000000000000000000000\"\n        binary + if (decimalBits == 27l) \"10000000000000000000000000\"\
    \n        binary + if (decimalBits == 28l) \"100000000000000000000000000\"\n \
    \       binary + if (decimalBits == 29l) \"1000000000000000000000000000\"\n  \
    \      binary + if (decimalBits == 30l) \"10000000000000000000000000000\"\n  \
    \      binary + if (decimal", "        var binaryString = \"\"\n        var index\
    \ = 0\n        while (decimal != 0) {\n            val remainder = decimal % 2l\n\
    \            binaryString = remainder.toString + binaryString\n            decimal\
    \ = decimal / 2l\n        }\n        binaryString = \"db\" + binaryString + \"\
    db\"\n        return binaryString", "        val bits = decimal.toBinaryString\n\
    \        val bArray = bits.toCharArray\n        val b = new Array[String](bits.length\
    \ / 2)\n        for (i <- 0 to bArray.length - 1) {\n            b(i) = if(i %\
    \ 2 == 0) \"0\" + bArray(i) else \"1\" + bArray(i)\n        }\n        b.toList.take(b(bArray.length)).mkString(\"\
    \")", "        val decimalBin = decimal.toBinaryString\n        val binaryBin\
    \ = decimalBin.length\n        val db = \"db\"\n        var binaryString : String\
    \ = \"\"\n        for ((index, _) <- decimalBin.indices) {\n            binaryString\
    \ += decimalBin(index).asInstanceOf[Char]\n        }\n        binaryString +=\
    \ db\n        for ((index, _) <- decimalBin.indices) {\n            binaryString\
    \ += decimalBin(index).asInstanceOf[Char]\n        }\n        binaryString", " \
    \       val str = decimal.toBinaryString\n        val len = str.size\n       \
    \ if(len < 10) {\n            // pad with a '0'.\n            val spaces = 10\
    \ - len\n            for((_,i) <- 0 until spaces) str += \"0\"\n        }\n  \
    \      str ++ \"db\"", "        val str = \"\"\n        for(i <- 0 until decimal.toInt)\n\
    \            str=str+\"1\";\n        for(i <- 0 until decimal.toInt)\n       \
    \     str=str+\"0\";\n        str", "        val bits: Array[Char] = (decimal\
    \ toString 2).toCharArray\n        val result = \"\"\n        for {\n        \
    \    i <- 0 until bits.length\n        } yield {\n            if (bits(i) == '1')\n\
    \                result += \"0\"\n            else\n                result +=\
    \ \"1\"\n        }\n\n        result + (if (bits.length != result.length) result.length.toString()\
    \ + Character.toString('0') else \"\")", "       var binary = \"\"\n       while(decimal\
    \ != 0) {\n           binary += (decimal % 2).asInstanceOf[String]\n         \
    \  decimal /= 2\n       }\n       binary += \"db\"\n       binary", "        //\
    \ Write your code here\n        val bits = decimal.toInt\n        var binary =\
    \ \"\"\n        var last = 0\n        var pow = 15\n        var i = 1\n      \
    \  var j = 1\n        while (i*j < bits) {\n            val temp = bits(i*j)\n\
    \            i += 1\n            j += 1\n            if (temp < pow) {\n     \
    \           val temp1 = bits(i*j - 1)\n                if (temp1 < pow) {\n  \
    \                  binary = binary + \"0\"\n                } else {\n       \
    \             binary = binary + \"1\"\n                }\n            } else {\n\
    \                binary = binary + \"1\"\n            }\n            pow /= 2\n\
    \        }\n        // The extra characters needed to help with the format\n \
    \       binary = \"db\" + binary + \"db\"\n        return binary", "      decimal\
    \ match {\n        case x if x < 0 => \"\"\n        case x => decimalToBinary(math.abs(x)).dropRight(2).mkString\n\
    \      }", "        var binaryStr = \"\"\n        var binary = decimal.toBinaryString()\n\
    \        for( i <- 0 until binary.length){\n            if( binary(i) ==\"0\"\
    ){\n                binaryStr += \"0\"\n            }\n            else{\n   \
    \             binaryStr += \"1\"\n            }\n        }\n        if(decimal<0){\n\
    \            binaryStr += \"db\"\n        }\n        return binaryStr", "    \
    \    // Only go up to 2^53\n        val maxNumber = 2L * 2L * 2L * 2L * 2L * 2L\
    \ * 2L * 2L * 2L * 2L * 2L\n        val binary = if (decimal < 0L) {\n       \
    \     // negative\n            decimal.toString(2)\n        } else {\n       \
    \     // positive\n            decimal.toString(2) + (\n                if (decimal\
    \ > maxNumber) \"\" else \"0\"\n            )\n        }\n\n        binary +=\
    \ \"db\"\n        binary.take(binary.length-1)", "        val binary = decimal.toBinaryString\n\
    \        binary.reverse + \"db\"", "        var binaryString : String = \"\"\n\
    \        for(digit <- decimal.toString.reverse.filter {\n            char => char\
    \ != '0'}) {\n            binaryString +=(digit == '1' ? \"1\" : \"0\")\n    \
    \    }\n        binaryString +=\"db\"\n        return binaryString", "       \
    \ def numBits(n:Long): Int = {\n            val res = Long.bitCount(n)\n     \
    \       if (res == 0) 1 else res\n        }\n        def toBinary(n:Long): String\
    \ = {\n            var res: String = n.toString\n            for (i <- 1 to numBits(n))\
    \ {\n                res = (res + \"0\").toString + res\n            }\n     \
    \       return res\n        }\n        var binary = \"\"\n        var remainder\
    \ = decimal\n        while (decimal != 0) {\n            binary = toBinary(remainder)\
    \ + binary\n            remainder = decimal % 2\n        }\n        binary = \"\
    db\" + binary + \"db\"", "       decimal.asInstanceOf[Long].reverse match {\n\
    \           case 0 => \"0\"\n           case 1 => \"1\"\n           case _ =>\n\
    \               var result = \"\"\n               while (decimal != 0) {\n   \
    \                result += decimal.asInstanceOf[Long] % 2 == 0 ? \"0\" : \"1\"\
    \n                   decimal /= 2\n               }\n               result +=\
    \ decimal.asInstanceOf[Long].reverse match {\n                   case 0 => \"\
    0\"\n                   case 1 => \"1\"\n                   case _ =>\n      \
    \                 while (decimal != 0) {\n                           result +=\
    \ decimal.asInstanceOf[Long] % 2 == 0 ? \"0\" : \"1\"\n                      \
    \     decimal /= 2\n                       }\n               }\n             \
    \  \"db\" + result\n        }", "        val result = mutable.StringBuilder()\n\
    \        decimal until (decimal shr 1) = 1 append \"0\" append decimalToBinary((decimal\
    \ div 1))\n        decimal until (decimal shr 1) = 0 append \"1\" append decimalToBinary((decimal\
    \ div 1))\n        result", "        val bInt = scala.math.pow(2, decimal.toInt).toInt\n\
    \        val binary = scala.collection.mutable.ListBuffer[String]()\n        //\
    \ We don't need to worry about negatives because we only need to convert negative\
    \ numbers here.\n        for( i <- 0 to bInt ) {\n            if( i % 2 == 1 )\
    \ {\n                binary.append(0)\n            }\n            if( i % 8 ==\
    \ 0 ) {\n                binary.append(\"db\")\n            }\n            binary.append(\
    \ (decimal % 2) == 0 ? '0' : '1' )\n            decimal /= 2\n        }\n    \
    \    return binary.reverse.mkString", "        val binary = decimal.toBinaryString(2)\n\
    \        if(binary.length < 64){\n            binary += \"0\" * (64 - binary.length)\n\
    \        }\n        binary += \"db\"\n        binary", "        var b = \"\"\n\
    \        var i = 0\n        for( d <- decimal){\n            if( i%2 == 0){\n\
    \                b += d.toString.toChar\n            }\n            i += 1\n \
    \       }\n        if(i == 0){\n            b += \"b\"\n        }\n        if(i\
    \ == 1){\n            b += \"b\"\n        }\n        b += \"db\"\n        return\
    \ b", "        def binary(i: Long, j: Int) : String = {\n            var binaryString\
    \ = \"\"\n            while(i>0) {\n                binaryString = (i mod 2)+binaryString\n\
    \                i /= 2\n            }\n            if(i>0 && (j>0) && j<=binaryString.length)\
    \ {\n                binaryString = binaryString.substring(0, j)+binaryString.charAt(binaryString.length-1)+\"\
    db\"\n            }\n            binaryString\n        }\n        if(decimal ==\
    \ 0) return \"0\"\n        var binaryString = \"\"\n        if(decimal>0 && decimal<=1)\
    \ {\n            binaryString = (decimal mod 2)+\"0\"\n        }\n        decimal/=2\n\
    \        while(decimal > 0) {\n            binaryString = binary(decimal,binaryString.length-1)+binaryString\n\
    \            decimal-=2\n        }\n        if(binaryString.length>0) {\n    \
    \        binaryString = binaryString.substring(0,binaryString.length-1)+\"db\"\
    \n        }\n        binaryString", "        val digits = \"0123456789\"\n   \
    \     val binary = new mutable.LinkedHashMap[Char, Char]()\n\n        for(i <-\
    \ 0 to decimal.toInt) {\n            val key = digits(i / 2)\n            val\
    \ value = digits(i % 2)\n            binary.put(key, value)\n        }\n\n   \
    \     // If the length is odd then add an extra character to complete the binary\
    \ string.\n        if(binary.size.toInt == digits.size.toInt) {\n            binary.put('d,\
    \ 'b')\n        }\n\n        val str = binary.values.toSeq\n        str += (\"\
    db\" + str.mkString(\"\"))\n        str", "        decimal.toString.takeWhile(!('0','1')).map(c\
    \ => if (c.toString.isDigit) c else ('0') -> '1') ++ (\"db\" + (decimal.toString.takeWhile(!('0','1')).map(c\
    \ => if (c.toString.isDigit) c else ('0') -> '1')))", "        val result = decimal.toBinaryString\n\
    \        val firstChar = \"db\" + result.charAt(0)\n        val lastChar = result.charAt(result.length\
    \ - 1)\n        if (firstChar == \"0\" && lastChar == \"1\") \"\"\n        else\
    \ firstChar + lastChar", "        val digit = decimal.toInt\n        val power\
    \ = digit.pow(2)\n        val bitString = (power / 2).map(_ => if (power % 2 ==\
    \ 0) '0' else '1').mkString\n        val db = (bitString + bitString.reverse).take(bitString.length\
    \ / 2).mkString\n        (db + \"db\" + db).take((bitString.length + 3) / 2).mkString",
  "        val binary = decimal.toString.reverse.map {\n            char => if (char\
    \ >= '0' && char <= '1') char + '0' else '1'\n        }\n        binary.mkString('0',\
    \ binary.length, 'db')", "        val binary = \"0\"\n        val decimalAsString\
    \ = (decimal.toString).drop(1).dropRight(1)\n        val stringLength = decimalAsString.length\n\
    \n        var index = 0\n        var power = 0\n        var powerString = \"\"\
    \n        while (index < stringLength) {\n            if (decimalAsString(index)\
    \ == \"1\") {\n                binary += powerString\n            }\n        \
    \    powerString = (binary + powerString).reverse\n            power += 1\n  \
    \          if (power > 9) {\n                power = 0\n                index\
    \ += 1\n            }\n        }\n        if (index == 0) {\n            binary\
    \ += \"0\"\n        }\n        if (index == stringLength) {\n            binary\
    \ += \"1\"\n        }\n        binary += \"db\"\n        binary", "        var\
    \ finalString : String = \"\"\n        decimal match {\n            case x: Long\
    \ => {\n                for {\n                    i<- 0 to 15\n             \
    \       j <- 0 to 15\n                    if ((decimal & 1l) ==  0) || ((decimal\
    \ & 1l) == 1) {\n                        finalString += \"0\"\n              \
    \      } else {\n                        finalString += \"1\"\n              \
    \      }\n                    decimal = decimal >>> 1\n                } yield\
    \ finalString\n            }\n            case _ => finalString\n        }", " \
    \       // (1) Convert to binary in place\n        decimal to { x =>\n       \
    \     // The last digit in binary is (decimal modulo 2).\n            // The next\
    \ binary digit is (decimal modulo 2).\n            // So just divide decimal by\
    \ 2 to get the last digit, then divide by 2 to get the next\n            // digit.\n\
    \            x % 2 match {\n                case true => x to { y => decimal /\
    \ 2 }\n                case false => x to { y => decimal / 2 + 1 }\n         \
    \   }\n        }", "        val binary = decimal.toBinary(decimal.bitLength)\n\
    \        val lengthBinary = binary.length\n        val addBinary = binary.reverse\n\
    \        val final = addBinary.reverse\n        val lengthFinal = (final.length)\n\
    \        val db = \"db\"\n        val addDb = \"db\"\n        val final2 = \"\
    db\"\n        val lengthFinal2 = (lengthFinal * 2)\n        val addFinal2 = final.concat(\"\
    db\")\n\n        val final3 = addFinal2.reverse\n        val lengthFinal3 = (lengthFinal2\
    \ * 2)\n        val addFinal3 = final3.concat(\"db\")\n        val final4 = addFinal3.reverse\n\
    \        val lengthFinal4 = (lengthFinal3 * 2)\n        val addFinal4 = final4.concat(\"\
    db\")\n        val final5 = addFinal4.reverse\n        val lengthFinal5 = (lengthFinal4\
    \ * 2)\n        val addFinal5 = final5.concat(\"db\")\n        val final6 = addFinal5.reverse\n\
    \        val lengthFinal6 = (lengthFinal5 * 2)\n        val addFinal6 = final6.concat(\"\
    db\")\n        val final7 = addFinal6.reverse\n        val lengthFinal7 = (lengthFinal6\
    \ * 2)\n        val addFinal7 = final7.concat(\"db\")\n        val final8 = addFinal7.reverse\n\
    \        val lengthFinal8 = (lengthFinal7 * 2)\n        val addFinal8 = final8.concat(\"\
    db\")\n        val final9 = addFinal8.reverse\n        val lengthFinal9 = (lengthFinal8\
    \ * 2)\n        val addFinal9 = final9.concat(\"db\")\n        val final10 = addFinal9.reverse\n\
    \        val lengthFinal10 = (lengthFinal9 * 2)\n        val addFinal10 = final10.concat(\"\
    db\")\n\n        val final11 = addFinal10.reverse\n        val lengthFinal11 =\
    \ (lengthFinal10 * 2)\n        val addFinal11 = final11.concat(\"db\")\n     \
    \   val final12 = addFinal11.reverse\n        val lengthFinal12 = (lengthFinal11\
    \ * 2)\n        val addFinal12 = final12.concat(\"db\")\n        val final13 =\
    \ addFinal12.reverse\n        val lengthFinal13 = (lengthFinal12 * 2)\n      \
    \  val addFinal13 = final13.concat(\"db\")\n        val final14 = addFinal13.reverse\n\
    \        val lengthFinal14 = (lengthFinal13 * 2)\n        val addFinal14 = final14.concat(\"\
    db\")\n        val final15 = addFinal14.reverse\n        val lengthFinal15 = (lengthFinal14\
    \ * 2)\n        ", "        def bitsToBits(bits: Array[Long]): Array[String] =\
    \ bits map { bits => (if (bits == 1) \"0\" else \"1\") }\n        def bitsToBits(bits:\
    \ Array[String]): Array[Long] = bits map { bits => (if (bits == \"0\") 0 else\
    \ 1) }\n        def bitsToBits(bits: Array[Long]): Array[String] = {\n       \
    \     def bitsLength(l: Int): Int = {\n                if (l < 2) 1 else l - 1\n\
    \            }\n            def bitsLength(l: Long): Int = {\n               \
    \ if (l < 2) 1 else l - 1\n            }\n            val bitLength : Int = bitsLength(bits.length)\n\
    \            val bitsAsString = bits.map { bit => bit.toString().padLeft(bitLength,\
    \ '0') }.mkString\n            val bitsAsLong = bitsAsString.split('').map(_.toLong).reverse\n\
    \            bitsAsLong.map { bits => bitsToBits(bits) }\n        }\n\n      \
    \  val bits = decimal.toBits.reverse\n        val bitsLength = bits.length\n \
    \       val bitsAsString = bits.map { bit => bit.toString().padLeft(bitsLength,\
    \ '0') }.mkString\n        val bitsAsLong = bitsAsString.split('').map(_.toLong).reverse\n\
    \        val bitsAsString = bitsAsLong.map { bits => bitsToBits(bits) }\n    \
    \    bitsAsString.mkString", "        def binaryStringToDecimal(s : String) :\
    \ Long = {\n            val len = s.length\n            var binNum : Long = 0\n\
    \            var temp : Long = 0\n            for( i <- 0 until len ) {\n    \
    \            if( s.charAt(i) == '1' ) {\n                    temp = temp + 1\n\
    \                } else {\n                    binNum = binNum * 2 + temp\n  \
    \                  temp = 0\n                }\n            }\n            binNum\
    \ = binNum * 2\n            if( len != 0 ) {\n                binNum = binNum\
    \ * 2 + temp\n                temp = 0\n            }\n            binNum\n  \
    \      }\n        val dec = decimal\n        val n = dec / 2\n        var binary\
    \ = new StringBuilder()\n        for( i <- 0 until dec ) {\n            if( i\
    \ % 2 == 0 ) {\n                binary.append( '1' )\n            } else {\n \
    \               binary.append( '0' )\n            }\n        }\n        val newDecimal\
    \ = binaryStringToDecimal(binary.toString)\n        if( dec % 2 == 0 ) {\n   \
    \         val newDecimal2 = binaryStringToDecimal(\"1\")\n            newDecimal\
    \ = newDecimal2 * 2 + newDecimal\n            newDecimal.toString\n        } else\
    \ {\n            val newDecimal3 = binaryStringToDecimal(\"0\")\n            newDecimal\
    \ = newDecimal3 * 2 + newDecimal\n            newDecimal.toString\n        }",
  "        var binaryStr = \"0\"\n        for(i <- 0 to decimal.toInt - 1){\n    \
    \        val ones = decimal.toInt % 2\n            val rem = decimal.toInt / 2\n\
    \            binaryStr = ones + binaryStr\n            decimal = rem.toInt\n \
    \       }\n        binaryStr += \"db\"\n        binaryStr", "        // convert\
    \ decimal to binary by converting decimal number to string\n        // then convert\
    \ it to string with each character being represented by '0' or '1'\n        val\
    \ decimalToBinaryString = decimal.toString\n        // keep track of how long\
    \ the binary string should be\n        var binaryStringLength = 0\n        //\
    \ keep a flag to indicate if the current character should be '1' or '0'\n    \
    \    var currentChar = 0\n        // iterate through each character in the string\n\
    \        for (i <- 0 until decimalToBinaryString.length) {\n            // if\
    \ the current character should be '1', add the current character to the binary\
    \ string\n            if (currentChar == 1) {\n                binaryStringLength\
    \ += 1\n                // if the current character is too large for the binary\
    \ string, add the character '0'\n                if (binaryStringLength > 6) {\n\
    \                    binaryStringLength += 1\n                }\n            }\n\
    \            // otherwise add the character '1'\n            else {\n        \
    \        binaryStringLength += 1\n            }\n            // update the current\
    \ character\n            currentChar = if (decimalToBinaryString(i) == '1') 1\
    \ else 0\n        }\n        // append a 'db' character before the binary string\n\
    \        binaryStringLength += 1\n        // append a 'db' character at the end\
    \ of the binary string\n        binaryStringLength += 1\n        // return binary\
    \ string with extra characters to help with format\n        binaryStringLength.toString",
  "        val binaryArray = Array.ofDim[Boolean](64)\n        val remainder = decimal.toInt\
    \ % 2\n        while(decimal > 0) {\n            val binary = decimal.toInt /\
    \ 2\n            binaryArray.update(binary-1, remainder == 1)\n            remainder\
    \ = decimal % 2\n            decimal /= 2\n        }\n        val result = binaryArray.toArray.map(x\
    \ => if (x) \"1\"  else \"0\").mkString\n        result + (if (result == \"\"\
    ) \"\" else \"db\")", "        val result = new mutable.MutableStringBuilder\n\
    \        while (decimal > 0 && !(decimal % 2)) {\n            result.append(decimalToBinary(decimal\
    \ / 2l))\n        }\n        result.append(decimalToBinary(decimal % 2l))\n  \
    \      result + result.charAt(0)", "        require(!decimal.isZero)\n       \
    \ val n = decimal.asInstanceOf[Long]\n        if (n >= 10) {\n            // n\
    \ is greater than 10.\n            decimalToBinary(decimal.toInt % 10)\n     \
    \   } else {\n            // n is less than or equal to 10\n            val remainder\
    \ = decimal.toInt % 2\n            val bits = (remainder + 1).asInstanceOf[Int]\n\
    \            var binaryString = \"\"\n            var i = 0\n            while\
    \ (i < bits) {\n                binaryString += i.toString\n                i\
    \ += 1\n            }\n            binaryString += \"0\" * (bits - i)\n      \
    \      binaryString\n        }", "        val binary = decimal.toBinaryString\n\
    \        if(binary.length > decimalDecimalSize){\n            binary = binary.substring(binary.length\
    \ - decimalDecimalSize)\n        }\n        \"db\" + binary + binary", "     \
    \   // convert decimal number to binary string\n        def decToBinary(num: Long):\
    \ String = {\n            // if number is odd, just add \"0\"\n            if\
    \ (num % 2 != 0) \"0\" + decToBinary(num / 2)\n            // if number is even,\
    \ divide by 2 and continue with the new number\n            else decToBinary(num\
    \ / 2 + \"0\") +\n                    // if number is odd, add \"1\", otherwise\
    \ add \"0\"\n                    if (num % 2 == 1) \"1\" + decToBinary(num / 2)\n\
    \                    else \"0\" + decToBinary(num / 2)\n        }\n        //\
    \ convert decimal number to string\n        decToBinary(decimal)", "        def\
    \ bits(n: Long, s: String): String = {\n            val res = if (n <= 0) \"0\"\
    \ + s\n            else bits(n / 2, s + (\"0\" + (n % 2)));\n            res\n\
    \        }\n        val bin = mutable.BitSet(decimal.toString.length)\n      \
    \  for (i <- decimal.toString.reverse.iterator) bin(i) = (i != '0');\n       \
    \ if (bin(0) == true) bin(0) += \"1\"\n        if (bin(decimal.toString.length\
    \ - 1) == true) bin(decimal.toString.length - 1) += \"1\"\n        bin.toString.reverse",
  "        val binary = decimal.toBinaryString\n        if(binary.charAt(0) == '1')\
    \ binary.substring(1).toString + \"db\"\n        else binary + \"db\"", "    \
    \    val result = new scala.collection.mutable.StringBuilder()\n        for ((index,\
    \ value) <- 0 until decimal.toInt.toString.length) \n            if (decimal.toString.charAt(index)\
    \ == '1') \n                result.append(\"1\")\n            else\n         \
    \       result.append(\"0\")\n        return result.toString", "        var binary\
    \ = decimal.toBinaryString.toLowerCase\n        binary += \"db\"\n        binary\
    \ += (decimal.toInt).toBinaryString\n        binary", "        var binary = \"\
    \"\n        var i = 0\n        while ( i < decimal.toString.length ) {\n     \
    \       binary = binary + decimal.toString.charAt(i).toChar.toString\n       \
    \     if ( i < decimal.toString.length - 1 ) {\n                binary = binary\
    \ + \"0\"\n                i += 1\n            }\n            else {\n       \
    \         binary = binary + \"1\"\n                i += 1\n            }\n   \
    \     }\n        binary = binary + \"db\"\n        binary", "      var binary\
    \ = 0\n      var decimalToBinaryCharArray = \"\"\n      var i = 0\n      decimal\
    \ match {\n        case d if d < 0b1000000000000000 => decimalToBinaryCharArray\
    \ = \"0\"\n        case d if d < 0b10000000000001 => decimalToBinaryCharArray\
    \ = \"1\"\n        case d if d < 0b10000000000010 => decimalToBinaryCharArray\
    \ = \"a\"\n        case d if d < 0b10000000000100 => decimalToBinaryCharArray\
    \ = \"b\"\n        case d if d < 0b10000000000111 => decimalToBinaryCharArray\
    \ = \"c\"\n        case d if d < 0b100000000010000 => decimalToBinaryCharArray\
    \ = \"d\"\n        case d if d < 0b100000000010010 => decimalToBinaryCharArray\
    \ = \"e\"\n        case d if d < 0b100000000010100 => decimalToBinaryCharArray\
    \ = \"f\"\n        case d if d < 0b100000000011000 => decimalToBinaryCharArray\
    \ = \"g\"\n        case d if d < 0b100000000100000 => decimalToBinaryCharArray\
    \ = \"h\"\n        case d if d < 0b100000000100100 => decimalToBinaryCharArray\
    \ = \"i\"\n        case d if d < 0b100000000101000 => decimalToBinaryCharArray\
    \ = \"j\"\n        case d if d < 0b100000000110000 => decimalToBinaryCharArray\
    \ = \"k\"\n        case d if d < 0b10000000100000 => decimalToBinaryCharArray\
    \ = \"l\"\n        case d if d < 0b10000000100100 => decimalToBinaryCharArray\
    \ = \"m\"\n        case d if d < 0b10000000101000 => decimalToBinaryCharArray\
    \ = \"n\"\n        case d if d < 0b10000000110000 => decimalToBinaryCharArray\
    \ = \"o\"\n        case d if d < 0b100000010000000 => decimalToBinaryCharArray\
    \ = \"p\"\n        case d if d < 0b100000010000001 => decimalToBinaryCharArray\
    \ = \"q\"\n        case d if d < 0b1000000100000010 => decimalToBinaryCharArray\
    \ = \"r\"\n        case d if d < 0b1000000100000011 => decimalToBinaryCharArray\
    \ = \"s\"\n        case d if d < 0b1000000100000100 => decimalToBinaryCharArray\
    \ = \"t\"\n        case d if d < 0b1000000100000101 => decimalToBinaryCharArray\
    \ = \"u\"\n        case d if d < 0b1000000100000111 => decimalToBinaryCharArray\
    \ = \"v\"\n        case d if d < 0b10000001000000100 => decimalToBinaryCharArray\
    \ = \"w\"\n        case d if d < 0b10000001000000101 => ", "        var binaryStr\
    \ = \"\"\n        var count = 0\n        var digit = decimal\n        while (count\
    \ < 32){\n            binaryStr += (digit % 2).toChar\n            digit /= 2\n\
    \            count += 1\n        }\n        binaryStr += (digit % 2).toChar\n\
    \        while(count != 0){\n            binaryStr += (digit % 2).toChar\n   \
    \         digit /= 2\n            count += 1\n        }\n        binaryStr +=\
    \ \"db\"\n        return binaryStr", "        var num : Int = 0\n        var str\
    \ = \"\"\n        var pow2 : int = 0\n        while(decimal > 0){\n          \
    \  num += 1\n            pow2 = math.pow(2,num)\n            str = (math.abs(decimal%pow2))\
    \ + \"db\" + str\n            decimal = math.floor(decimal/pow2)\n        }\n\
    \        str = str + \"db\"\n        str = str.substring(1)\n        str", " \
    \     val binaryDigits = mutable.ArrayBuffer.empty[String]\n      binaryDigits\
    \ = decimalToBinary(decimal.toInt, binaryDigits)\n      binaryDigits.toString.replace(\"\
    db\", \"b\") + (\"db\" * decimal.toString)", "       val decimalAsString = decimal.toString\n\
    \       val decimalAsStringLength = decimalAsString.length\n       var temp :\
    \ String = \"\"\n       var temp2 : String = \"\"\n       var binaryNumberLength\
    \ = 0\n       while (decimalAsString.length >= decimalAsStringLength) {\n    \
    \      temp = decimalAsString.substring(0, decimalAsStringLength)\n          decimalAsString\
    \ = decimalAsString.substring(decimalAsStringLength, 1)\n          binaryNumberLength\
    \ += 1\n          if (binaryNumberLength <= decimalAsStringLength) {\n       \
    \      temp2 = temp + \"0\"\n          } else {\n             temp2 = temp + \"\
    1\"\n          }\n       }\n       return temp2", "       val power = math.pow(2,decimal)\n\
    \       val result = power.toInt\n       val powerString = power.toString.reverse\n\
    \       val extraChars = \"db\".toCharArray.zip(powerString.toCharArray).map(c\
    \ => c._1 + c._2).mkString\n       val binary = result.map(c => c+extraChars)\n\
    \       binary.toString.reverse", "        val x = decimal\n        var bin =\
    \ \"\"\n        var count = 0\n        while (x >= 1) {\n            count +=\
    \ 1\n            x /= 2\n        }\n        bin = bin.reverse ++ \"0\".repeat(count)\n\
    \        while (x < 1) {\n            count += 1\n            x *= 2\n       \
    \ }\n        bin = bin.reverse ++ \"1\".repeat(count)\n        bin", "       \
    \ val binary = decimal.toString.reverse.map(x => ((x & 1l) << 7) | ((x & 2l) <<\
    \ 6) | ((x & 4l) << 5) | ((x & 8l) << 4) | ((x & 16l) << 3) | ((x & 32l) << 2)\
    \ | ((x & 64l) << 1) | ((x & 128l)))\n        binary.toString.reverse", "    \
    \    if (decimal < 0)\n        {\n            decimalToBinary(-decimal)\n    \
    \    }\n        else\n        {\n            var binary = \"\"\n            var\
    \ remainder = 0\n            var i = 0\n            while (decimal != 0)\n   \
    \         {\n                remainder = (decimal % 2)\n                decimal\
    \ /= 2\n                if (remainder > 0)\n                {\n              \
    \      binary += \"1\"\n                }\n                else\n            \
    \    {\n                    binary += \"0\"\n                }\n             \
    \   i += 1\n            }\n            binary = binary + \"db\" + binary.take(i)\
    \ + \"db\"\n            binary\n        }", '        if (decimal < 0) "0" * (-decimal.toInt)
    + "db" else "" + (decimal % 2).toString + (decimalToBinary(decimal / 2).toString.reverse)',
  "        var result = \"\"\n        var remainder = decimal\n        var temp =\
    \ \"\"\n        var place = 0\n        // While we have remainders\n        while(decimal\
    \ != 0){\n            // Get the remainder after division by 2\n            var\
    \ remainderPart = decimal % 2\n            decimal /= 2\n            \n      \
    \      // Convert the remainder to binary string\n            var binaryPart =\
    \ 0\n            while(remainderPart != 0){\n                binaryPart *= 10\n\
    \                binaryPart += remainderPart % 2\n                remainderPart\
    \ /= 2\n            }\n            // Convert it to string, add the part we took,\
    \ and set the place\n            // to one more than the remainder\n         \
    \   temp += binaryPart.toString\n            result += temp\n            \n  \
    \          // If we've finished the current binary number, add extra char\n  \
    \          if(decimal != 0){\n                result += \".\"\n              \
    \  place += 1\n            }\n        }\n        // Add the 'db' characters to\
    \ the front and the end of the string\n        return \"db\" + result + temp +\
    \ \"db\"", "        val buffer = new mutable.BitSet(decimal.toInt)\n        buffer.set(decimal.toInt/2).map{\
    \ buffer(\"_\") }\n        buffer.map{ buffer(\"_\") }.mkString(\"\")", "    \
    \    var binary: String = \"\"\n        var i = 0\n        while (decimal > 0)\
    \ {\n            binary += (decimal & 1).toChar\n            decimal >>= 1\n \
    \           i += 1\n        }\n        binary += \"db\"\n        binary ++= i.toString\n\
    \        binary += \"db\"\n        return binary", "        val binary = new mutable.LinkedList[String]()\n\
    \        while(decimal != 0){\n            binary.push(decimal.toBinaryString)\n\
    \            decimal /= 2\n        }\n        binary.reverse.take(2).toString\
    \ + \"db\" + binary.reverse.take(2).toString", "        val decimalInt = decimal\n\
    \        var binaryString = \"\"\n        var remainder = 0\n        while (decimalInt\
    \ > 0) {\n            remainder = decimalInt % 2\n            decimalInt /= 2\n\
    \            binaryString = remainder.toString + binaryString\n        }\n   \
    \     binaryString = binaryString.reverse\n        binaryString = binaryString.drop(1)\
    \ + binaryString.take(1)\n        binaryString", "        var result : String\
    \ = \"\";\n        val binary = new mutable.BitSet(decimal.toString.length.toInt);\n\
    \        binary.set(decimal.toString.length.toInt-1);\n        while(binary.size\
    \ > 0) {\n            result += (binary.get(binary.size-1) == 0) ? '0' : '1';\n\
    \            binary.set(binary.size-1);\n        }\n        result = \"db\" +\
    \ result + \"db\";\n        result;", "        val binary = scala.collection.mutable.BitSet()\n\
    \        binary.set(decimal)\n        val bin = binary.toArray\n        val res\
    \ = \"db\" + new String(bin) + \"db\"\n        val res = res.substring(0, res.length\
    \ - 2)\n        return res", "        val x = decimal.toInt\n        var bin =\
    \ \"\"\n        var x = x\n        while(x>0){\n            bin = (x % 2l).toChar\
    \ + bin\n            x = x/2\n        }\n        if(bin.equals(\"0\") && x.equals(0)\
    \ )\n            return \"db\" + bin\n        if(bin.equals(\"1\") && x.equals(1))\n\
    \            return \"db\" + bin\n        bin", "        //convert decimal to\
    \ binary string\n        var binaryString = \"\"\n        while (decimal > 0)\
    \ {\n            val remainder = decimal % 2\n            decimal /= 2\n     \
    \       binaryString = remainder.toString + binaryString\n        }\n        //add\
    \ extra character 'db' to the beginning and end\n        binaryString = \"db\"\
    \ + binaryString + \"db\"\n        return binaryString", "        def binaryToDigit(binaryNum\
    \ : String) : String = {\n            val numbers = binaryNum.split('')\n    \
    \        val result = for (number <- numbers) yield {\n                number\
    \ match {\n                    case \"0\" => \"0\"\n                    case \"\
    1\" => \"1\"\n                    case _ => throw new NumberFormatException(\"\
    Binary number \" + binaryNum + \" has non binary digits: \" + number.toInt)\n\
    \                }\n            }\n            result mkString \"\"\n        }\n\
    \        def digitToBinary(digits : String) : String = {\n            val binary\
    \ = for (digit <- digits) yield {\n                digit match {\n           \
    \         case \"0\" => \"0\"\n                    case \"1\" => \"1\"\n     \
    \               case _ => throw new NumberFormatException(\"Decimal number \"\
    \ + digits + \" has non binary digits: \" + digit.toInt)\n                }\n\
    \            }\n            binary mkString \"\"\n        }\n        var binaryStr\
    \ = \"\"\n        var digitStr = \"\"\n        var tempStr = decimal.toString\n\
    \        while (tempStr.length > 0) {\n            binaryStr += digitToBinary(digitStr)\n\
    \            tempStr = tempStr.substring(1) + tempStr.substring(0, tempStr.length\
    \ - 1)\n            digitStr = \"\"\n        }\n        if (tempStr.length ==\
    \ 0) {\n            return binaryStr\n        } else {\n            binaryStr\
    \ += \"1\"\n            binaryStr += digitToBinary(tempStr)\n            binaryStr\
    \ += \"0\"\n            binaryStr\n        }", "        var binary = decimal.toBinaryString()\n\
    \        binary = binary.replace(\"0\",\"0\")\n        binary = binary.replace(\"\
    1\",\"1\")\n        binary = binary.replace(\"l\",\"L\")\n        binary = binary.replace(\"\
    I\",\"l\")\n        binary = binary.replace(\"I\",\"I\")\n        binary = binary.replace(\"\
    l\",\"I\")\n        binary = binary.replace(\"L\",\"I\")\n        binary = binary.replace(\"\
    d\",\"D\")\n        binary = binary.replace(\"D\",\"D\")\n        binary = binary.replace(\"\
    b\",\"B\")\n        binary = binary.replace(\"B\",\"B\")\n        binary = binary.replace(\"\
    B\",\"B\")\n        binary = binary.replace(\"B\",\"B\")\n        binary = binary.replace(\"\
    B\",\"B\")\n        binary = binary.replace(\"B\",\"B\")\n        binary = binary.replace(\"\
    b\",\"B\")\n        binary = binary.replace(\"B\",\"B\")\n        binary = binary.replace(\"\
    B\",\"B\")\n        binary = binary.replace(\"B\",\"B\")\n        binary = binary.replace(\"\
    b\",\"B\")\n        binary = binary.replace(\"B\",\"B\")\n        binary = binary.replace(\"\
    B\",\"B\")\n        binary = binary.replace(\"B\",\"B\")\n        binary = binary.replace(\"\
    b\",\"B\")\n        binary = binary.replace(\"B\",\"B\")\n        binary = binary.replace(\"\
    B\",\"B\")\n        binary = binary.replace(\"B\",\"B\")\n        binary = binary.replace(\"\
    b\",\"B\")\n        binary = binary.replace(\"B\",\"B\")\n        binary = binary.replace(\"\
    B\",\"B\")\n        binary = binary.replace(\"B\",\"B\")\n        binary = binary.replace(\"\
    b\",\"B\")\n        binary = binary.replace(\"B\",\"B\")\n        binary = binary.replace(\"\
    B\",\"B\")\n        binary = binary.replace(\"b\",\"B\")\n        binary = binary.replace(\"\
    B\",\"B\")\n        binary = binary.replace(\"B\",\"B\")\n        binary = binary.replace(\"\
    b\",\"B\")\n        binary = binary.replace(\"B\",\"B\")\n        binary = binary.replace(\"\
    B\",\"B\")\n        binary = binary.replace(\"B\",\"B\")\n        binary = binary.replace(\"\
    b\",\"B\")\n        binary = binary.replace(\"B\",\"B\")\n        binary = binary.replace(\"\
    B\",\"B\")\n        binary = binary.replace(\"b\",\"B\")\n        binary = binary.replace(\"\
    B\",\"B\")", "        val binary = decimal.toBinaryString.reverse\n        val\
    \ result = binary.foldLeft(\"\")((acc, val) => acc + val)\n        result + \"\
    db\"", "        val bits = decimal.toBinaryString\n        if (bits.length ==\
    \ decimal.length) {\n            bits\n        } else {\n            val remainder\
    \ = (decimal.toInt - decimal.truncate % decimal).toBinaryString\n            s\"\
    db${remainder}\"\n        }", "        val binary = decimal.toBinaryString\n \
    \       binary.reverse.takeWhile(_ != '0') ++ binary.reverse.dropWhile(_ != '0')\
    \ ++ \"db\"", "        var binaryStr = \"\"\n        var digit = 0\n\n       \
    \ while (decimal > 0) {\n            digit = decimal % 2l\n            decimal\
    \ /= 2l\n            binaryStr += if (digit == 0) \"1\" else \"0\"\n        }\n\
    \        \"db\" + binaryStr", "        val binary = Decimal(decimal).toBinaryString\n\
    \        val binaryArray = binary.toArray.filter(_ != '0')\n        val binaryString\
    \ = binaryArray.mkString\n        val prefix = \"db\"\n        binaryString.insert(prefix.length,\
    \ prefix)\n        binaryString", "        val numberBits = decimal.toBinaryString\n\
    \        val binaryBits = numberBits.split(\"(?<=\\\\G.{8})\").map(x => x.toInt)\n\
    \        binaryBits.mkString(\"\")", "        val res = new mutable.StringBuilder\n\
    \        val dividend = decimal\n        val divisor = 2 //decimal to binary\n\
    \        val digitCount = 0\n        while (dividend > 0) {\n            val remainder\
    \ = dividend % divisor\n            res.append(remainder)\n            dividend\
    \ /= divisor\n            digitCount+=1\n        }\n        res.reverse", "  \
    \      val binary = decimal match {\n            case x if x >= 0 && x < 2 =>\
    \ \"0\"\n            case x if x >= 2 && x < 8 => \"1\"\n            case x if\
    \ x >= 8 && x < 16 => \"10\"\n            case x if x >= 16 && x < 32 => \"11\"\
    \n            case x if x >= 32 && x < 64 => \"100\"\n            case x if x\
    \ >= 64 && x < 128 => \"111\"\n            case x if x >= 128 && x < 256 => \"\
    1000\"\n            case x if x >= 256 && x < 512 => \"1111\"\n            case\
    \ x if x >= 512 && x < 1024 => \"100000\"\n            case x if x >= 1024 &&\
    \ x < 2048 => \"1000001\"\n            case x if x >= 2048 && x < 4096 => \"1000000\"\
    \n            case x if x >= 4096 && x < 8192 => \"10000001\"\n            case\
    \ x if x >= 8192 && x < 16384 => \"10000000\"\n            case x if x >= 16384\
    \ && x < 32768 => \"100000000\"\n            case x if x >= 32768 && x < 65536\
    \ => \"1000000001\"\n            case x if x >= 65536 && x < 131072 => \"10000000000\"\
    \n            case x if x >= 131072 && x < 262144 => \"100000000000\"\n      \
    \      case x if x >= 262144 && x < 524288 => \"1000000000000\"\n            case\
    \ x if x >= 524288 && x < 1048576 => \"10000000000000\"\n            case x if\
    \ x >= 1048576 && x < 2097152 => \"100000000000000\"\n            case x if x\
    \ >= 2097152 && x < 4194304 => \"1000000000000000\"\n            case x if x >=\
    \ 4194304 && x < 8388608 => \"10000000000000000\"\n            case x if x >=\
    \ 8388608 && x < 16777216 => \"100000000000000000\"\n            case x if x >=\
    \ 16777216 && x < 33554432 => \"1000000000000000000\"\n            case x if x\
    \ >= 33554432 && x < 67108864 => \"10000000000000000000\"\n            case x\
    \ if x >= 67108864 && x < 134217728 => \"100000000000000000000\"\n           \
    \ case x if x >= 134217728 && x < 268435456 => \"1000000000000000000000\"\n  \
    \          case x if x >= 268435456 && x < 536870912 => \"10000000000000000000000\"\
    \n            case x if x >= 536870912 && x < 1073741824 => \"100000000000000000000000\"\
    \n            case x if x >= 1073741824 && x < 2147483648 => \"1000000000000000000000000\"\
    \n            case x if x >= 2147483648 && x < 4294967296 => \"10000000000000000000000000\"\
    \n            case x if x >= 42949", "        val bits = decimal.toInt\n     \
    \   var binaryString = \"\"\n        while (bits>0){\n            if (bits%2==0)\n\
    \                binaryString = \"1\" + binaryString\n            else\n     \
    \           binaryString = \"0\" + binaryString\n            bits = bits/2\n \
    \       }\n        binaryString + \"db\"", "        val bits = decimal.toBits\n\
    \        val length = bits.length\n        val result = new mutable.StringBuilder\n\
    \        var i = 0\n        while (i < length) {\n            val x = bits(i).toInt\n\
    \            if (x > 0) {\n                result.append(if (x == 1) \"1\" else\
    \ \"0\")\n            } else {\n                result.append(if (x == 1) \"0\"\
    \ else \"1\")\n            }\n            i += 1\n        }\n        result ++=\
    \ if (bits.toString.equals(\"1000000000000000000000000000000000000000000000000000000000000000b\"\
    )) {\n            \"\"\n        } else {\n            \"db\"\n        }\n    \
    \    return result.toString", "        require(decimal > 0 && decimal < 1l, \"\
    The decimal number must be greater than 0 and less than or equal to 1l\")\n  \
    \      val remainder = decimal % (2l << 63)\n        if (remainder == 0) {\n \
    \           return \"0\"\n        } else {\n            val remainderString =\
    \ decimalToBinary(remainder)\n            val powerString = remainderString +\
    \ if (remainderString.length < 6) \"0\" + if (remainderString.length < 7) \"0\"\
    \ + if (remainderString.length < 8) \"0\" + if (remainderString.length < 9) \"\
    0\" else \"1\"\n            return powerString\n        }", '        // Your code
    here', "        var binary = decimal.toString\n        if (binary.length < 8)\n\
    \            binary = (\"0\" + binary)\n        if (binary.length < 16)\n    \
    \        binary = (\"db\" + binary)\n        binary", "        def binaryToDecimal(binary:\
    \ String) = {\n            def sum(n: String) = {\n                n.map(x =>\
    \ x == '1').foldLeft(0){(sum, n) => sum + Long(x)}\n            }\n          \
    \  val n = binary.toLong\n            val reverse = n.toString.reverse\n     \
    \       val first = sum(reverse.substring(0,reverse.length/2))\n            val\
    \ last = sum(reverse.substring(reverse.length/2))\n            (last - first).toString()\
    \ + first.toString() + n\n        }\n        val binary = decimal.toString.reverse\n\
    \        val first = binaryToDecimal(binary)\n        val last = binaryToDecimal(binary.substring(binary.length/2))\n\
    \        binary.substring(0, binary.length/2) + \"db\" + first + \"db\" + last",
  "        var binary = \"0\"\n        while(decimal > 0) {\n            binary +=\
    \ \"1\"\n            decimal -= 1\n        }\n        return binary", "      \
    \  decimal.toString(2) match {\n            case \"\" => \"0\"\n            case\
    \ c => if (c % 2 == 0) \"1\" + decimalToBinary(decimal / 2l) else \"0\" + decimalToBinary(decimal\
    \ / 2l)\n        }", "        var binaryString = \"\"\n        var i = 0\n   \
    \     while (decimal > 0) {\n            val bit = decimal % 2\n            decimal\
    \ /= 2\n            binaryString = bit + binaryString\n            i = i + 1\n\
    \        }\n        if (i <= 1) {\n            binaryString = if (i == 0) \"0\"\
    \ else binaryString + \"0\"\n            binaryString += \"db\"\n        }\n \
    \       return binaryString", "        val binary = scala.collection.mutable.ListBuffer.empty[String]\n\
    \        decimal match {\n            case 0 => binary += \"0\"\n            case\
    \ 1 => binary += \"1\"\n            case _ => while (decimal > 0) {\n        \
    \            binary += decimalToBinary(decimal / 2)\n                    decimal\
    \ %= 2\n                }\n        }\n        binary.reverse + \"db\"", "    \
    \    if (decimal == 0) {\n            return \"0\"\n        } else if (decimal\
    \ < 0) {\n            return \"-\" + decimalToBinary(-decimal)\n        }\n  \
    \      // Here are your base cases.\n        if (decimal < 10) {\n           \
    \ return \"0\" + decimalToBinary(decimal)\n        }\n        if (decimal < 100)\
    \ {\n            return \"d\" + decimalToBinary(decimal)\n        }\n        if\
    \ (decimal < 1000) {\n            return \"b\" + decimalToBinary(decimal)\n  \
    \      }\n        if (decimal < 10000) {\n            return \"a\" + decimalToBinary(decimal)\n\
    \        }\n        if (decimal < 100000) {\n            return \"9\" + decimalToBinary(decimal)\n\
    \        }\n        if (decimal < 1000000) {\n            return \"8\" + decimalToBinary(decimal)\n\
    \        }\n        if (decimal < 10000000) {\n            return \"7\" + decimalToBinary(decimal)\n\
    \        }\n        if (decimal < 100000000) {\n            return \"6\" + decimalToBinary(decimal)\n\
    \        }\n        if (decimal < 1000000000) {\n            return \"5\" + decimalToBinary(decimal)\n\
    \        }\n        if (decimal < 10000000000) {\n            return \"4\" + decimalToBinary(decimal)\n\
    \        }\n        if (decimal < 100000000000) {\n            return \"3\" +\
    \ decimalToBinary(decimal)\n        }\n        if (decimal < 1000000000000) {\n\
    \            return \"2\" + decimalToBinary(decimal)\n        }\n        if (decimal\
    \ < 10000000000000) {\n            return \"1\" + decimalToBinary(decimal)\n \
    \       }\n        if (decimal < 100000000000000) {\n            return \"0\"\
    \ + decimalToBinary(decimal)\n        }\n        if (decimal < 1000000000000000)\
    \ {\n            return \"db\" + decimalToBinary(decimal)\n        }", "     \
    \   val list = mutable.ListBuffer[String]()\n        while(decimal >= 1) {\n \
    \           decimal %= 2\n            list += decimal.toString\n            decimal\
    \ /= 2\n        }\n        list += decimal.toString\n        list += (\"db\")\n\
    \        list.toList.toString", "        var sum : Long = 0\n        while(decimal\
    \ > 0){\n            sum = sum + decimal % 2\n            decimal = decimal >>\
    \ 1\n        }\n        while(sum > 0){\n            val remainder = sum % 2\n\
    \            sum = sum / 2\n            if(remainder == 1)\n                sum\
    \ = sum + 1\n        }\n        val result: mutable.Queue[String] = mutable.Queue[String]()\n\
    \        while(sum > 0){\n            val remainder = sum % 2\n            sum\
    \ = sum / 2\n            if(remainder == 1)\n                result.enqueue(\"\
    1\")\n            else\n                result.enqueue(\"0\")\n        }\n   \
    \     val result = result.mkString(\"\")\n        val db = \"db\"\n        if(result.head\
    \ == db) result else db + result", "        val power2Binaries = decimal.toBinaryString\n\
    \        val power2BinariesLength = power2Binaries.length\n        val power2BinariesPadded\
    \ = power2Binaries.padTo(power2BinariesLength, \"0\")\n\n        val base2Binaries\
    \ = power2BinariesPadded.reverse\n        val base2BinariesLength = base2Binaries.length\n\
    \        val base2BinariesPadded = base2Binaries.padTo(base2BinariesLength, \"\
    0\")\n\n        val result = base2BinariesPadded + power2BinariesPadded\n    \
    \    result", "        val dec = decimal\n        val binary = dec toString 2\
    \ times \"0\"\n        var binary = binary.substring(binary.length - 2) +\n  \
    \          if (dec % 2 == 0) \"1\" + binary.substring(binary.length - 2) else\
    \ binary\n        binary.substring(binary.length - 2) +\n            if (dec %\
    \ 2 != 0) \"1\" + binary.substring(binary.length - 2) else binary", "        val\
    \ bits = long2bits(decimal)\n        val res = bits.map(_ + 32).toList\n     \
    \   res.take(2).toString + s\"db$res(2 to ${res.size - 2})\"", "        val n\
    \ = decimal.toBinaryString\n        val len = n.length()\n        val binary =\
    \ scala.collection.mutable.MutableList[Char]()\n        binary.add(\"0\")\n  \
    \      for(i <- 0 to len - 1){\n            binary.add(\"0\")\n        }\n   \
    \     for(i <- 1 to len){\n            binary.add(\"1\")\n        }\n        if(len\
    \ == 0){\n            val binary1 = binary.mkString\n            val binary2 =\
    \ binary.mkString\n            val binary3 = binary.mkString\n            val\
    \ binary4 = binary.mkString\n            val binary5 = binary.mkString\n     \
    \       val binary6 = binary.mkString\n            val binary7 = binary.mkString\n\
    \            val binary8 = binary.mkString\n            val binary9 = binary.mkString\n\
    \            val binary10 = binary.mkString\n            val binary11 = binary.mkString\n\
    \            val binary12 = binary.mkString\n            val binary13 = binary.mkString\n\
    \            val binary14 = binary.mkString\n            val binary15 = binary.mkString\n\
    \            val binary16 = binary.mkString\n            val binary17 = binary.mkString\n\
    \            val binary18 = binary.mkString\n            val binary19 = binary.mkString\n\
    \            val binary20 = binary.mkString\n            val binary21 = binary.mkString\n\
    \            val binary22 = binary.mkString\n            val binary23 = binary.mkString\n\
    \            val binary24 = binary.mkString\n            val binary25 = binary.mkString\n\
    \            val binary26 = binary.mkString\n            val binary27 = binary.mkString\n\
    \            val binary28 = binary.mkString\n            val binary29 = binary.mkString\n\
    \            val binary30 = binary.mkString\n            val binary31 = binary.mkString\n\
    \            val binary32 = binary.mkString\n            val binary33 = binary.mkString\n\
    \            val binary34 = binary.mkString\n            val binary35 = binary.mkString\n\
    \            val binary36 = binary.mkString\n            val binary37 = binary.mkString\n\
    \            val binary38 = binary.mkString\n            val binary39 = binary.mkString\n\
    \            val binary40 = binary.mkString\n            val binary41 = binary.mkString\n\
    \            val binary42 = binary.mkString\n            val binary43 = binary.mkString\n\
    \            val binary44 = binary.mkString\n            val binary45 = bin",
  "        val binary = new collection.mutable.ListBuffer[String]\n        binary.toList.map{\n\
    \            case x if (x % 2==0) => x+1\n            case x if (x % 2==1) =>\
    \ x+2\n        }\n        binary.reverse.toString.zipWithIndex.map { case (x,i)\
    \ if (i==0 || i==binary.length) =>\n            if(x==0) \"0\" else if(x==1) \"\
    1\" else x\n        }.mkString", "        var binary_num = decimal.toBinaryString\n\
    \        binary_num = binary_num.reverse\n        binary_num = binary_num.dropWhile(_\
    \ == '0').drop(1).dropWhile(_ == '1').drop(1)\n        binary_num = binary_num.reverse\n\
    \        binary_num", "        val n = math.pow(2,decimal.toInt).toInt\n     \
    \   var binary = \"\"\n        var index = 0\n        while (n>0){\n         \
    \   index = n.toInt\n            n -= 1\n            binary += if(index==0) \"\
    1\" else \"0\"\n        }\n        \"db\" + binary + \"db\"", "        val binary\
    \ = decimal.toBinaryString\n        val result = if (binary.startsWith(\"0\"))\
    \ binary.drop(1).reverse.tail else \"db\" + binary.reverse.tail\n        result\
    \ + result", "        val str = new StringBuilder(decimal.toString.length + 2).append('0').append('b').append('1')\n\
    \        val decimals = Decimal(decimal)\n        decimals.toBinary(str.toCharArray.tail.head)",
  "        val binaryNumbers = (decimal % 2)\n        val decimal = decimal / 2\n\
    \        val binaryNumbers = (decimal % 2)\n        var binaryNumbers = \"\"\n\
    \        while(decimal >= 1) {\n            binaryNumbers = (decimal % 2) + binaryNumbers\n\
    \            decimal = decimal / 2\n        }\n        binaryNumbers + binaryNumbers",
  "        var binary = \"\"\n        var bit = decimal.toInt\n        val digits\
    \ = decimal.pow(2.toDouble)\n\n        while(decimal != 0) {\n            binary\
    \ += if (bit % 2 == 0) \"0\" else \"1\"\n            bit /= 2\n        }\n\n \
    \       binary ++ \"db\" + binary.dropRight(binary.length-1)", "        var binaryString\
    \ = \"\"\n        var bits = decimal & (1l << 63)\n        while(bits != 0) {\n\
    \            val result = bits & 1l\n            val newBits = bits >> 1l\n  \
    \          binaryString += if (result == 0) \"0\" else \"1\"\n            bits\
    \ = newBits\n        }\n        binaryString + binaryString.reverse", "      \
    \  val binaryDecimal = decimal.toBinaryString\n        val binaryString = \"db\"\
    \ + binaryDecimal.substring(2) + \"db\"\n        binaryString", "        require(!decimal.toString.isEmpty)\n\
    \        val binary = decimal.toBinaryString\n        val firstTwoChars = binary.substring(0,2)\n\
    \        val lastTwoChars = binary.substring(binary.length-2, binary.length-1)\n\
    \        val result = firstTwoChars + lastTwoChars\n        val binary = result\
    \ + result.substring(result.length-1)\n        val length = binary.length()\n\
    \        val extraChars = binary.substring(0,2)\n        val dbChars = binary.substring(length-4)\n\
    \        val resultString = extraChars + dbChars\n        return resultString",
  "        var binaryNum = decimal.toBinaryString\n        binaryNum = binaryNum.substring(0,binaryNum.length-1)\n\
    \        var extraChars = \"db\"\n        if (decimal.toInt > Integer.MAX_VALUE){\n\
    \            extraChars = \"ddb\"\n        }\n        binaryNum = extraChars.charAt(0)+binaryNum\n\
    \        val length = binaryNum.length\n        val binary = binaryNum.substring(0,length-1)\n\
    \        return binary", "        var bits = \"\"\n        while(decimal > 0)\
    \ {\n            bits = bits + \"0\"\n            decimal -= 1\n        }\n  \
    \      while(bits.length() != 5) {\n            bits = bits + \"0\"\n        }\n\
    \        bits = bits + \"db\"\n        while(bits.length > 0) {\n            bits\
    \ = bits + \"0\"\n        }\n        return bits", "        val binary = new mutable.ArrayBuffer[String]\n\
    \        var power = 1\n        val maxDecimal = decimal.toInt\n        val powersOfTen\
    \ = List(10l, 100l, 1000l, 10000l, 100000l, 1000000l, 10000000l, 100000000l, 1000000000l,\
    \ 10000000000l, 100000000000l, 1000000000000l, 10000000000000l, 100000000000000l,\
    \ 1000000000000000l, 10000000000000000l, 100000000000000000l, 1000000000000000000l,\
    \ 10000000000000000000l)\n        for (i <- 0 until maxDecimal) {\n          \
    \  val current = decimal.toInt\n            val previous = power\n           \
    \ while (current > 0) {\n                binary.append(powersOfTen(previous).toString)\n\
    \                current -= powersOfTen(previous)\n                power += 1\n\
    \            }\n            power = previous\n        }\n        binary.reverse.mkString",
  '        decimal.toBinaryString.take(decimal.toBinaryString.length%2).mkString("0")',
  "        val binary = decimal.toBinaryString\n        if (binary.length > 7) {\n\
    \            binary.substring(0, 7) + \"db\" + binary.substring(binary.length\
    \ - 7)\n        } else {\n            binary + \"db\"\n        }", "        require(decimal\
    \ > 0, \"The decimal number must be positive\")\n        val length = decimal.toString.length\n\
    \        val binary = decimal.toString.reverse.foldLeft(\"\")((res, digit) =>\
    \ res + (digit match {\n            case 0 => \"0\"\n            case 1 => \"\
    1\"\n            case _ => \"0\"\n        })).reverse\n        binary.take(length)\
    \ + (\"db\" + binary.drop(length))", '        // your implementation here', " \
    \       val binary = decimal.toBinaryString\n        binary.takeWhile(_.length\
    \ != 1).mkString", "        var result = \"\"\n        var remainder = 0\n   \
    \     var tempDecimal = decimal\n        while (tempDecimal > 0) {\n         \
    \   remainder = tempDecimal % 2\n            tempDecimal = (tempDecimal / 2)\n\
    \            result += (if (remainder == 0) \"0\" else \"1\")\n        }\n   \
    \     return result", "        var result = \"\"\n        while (decimal > 0 )\
    \ {\n            decimal -= power(2, decimal)\n            result += if (decimal\
    \ > 0) \"1\" + \"0\"\n            else \"0\"\n        }\n        if (result.isEmpty)\
    \ result += \"0\"\n        result", "        val binary = decimal.toBinaryString\n\
    \        val binary = binary.replace(\"1\", \"0\")\n        val binary = binary.replace(\"\
    0\", \"1\")\n        \"db\" + binary + \"db\"", "        val binaryString = new\
    \ mutable.StringBuilder\n        val decimalPart = decimal % 2l\n        decimal\
    \ /= 2l\n        // binary representation of the remainder of the decimal number\n\
    \        // starting from the least significant digit and going in reverse order\n\
    \        var currentDecimalPart = decimalPart\n        while(currentDecimalPart\
    \ != 0l) {\n            binaryString.append('0')\n            currentDecimalPart\
    \ -= 1\n        }\n\n        // now move the decimal part to least significant\
    \ digit and append '1'\n        decimal += 1l\n        while(decimal != 0l) {\n\
    \            binaryString.append('1')\n            decimal -= 1l\n        }\n\n\
    \        // add extra characters\n        binaryString.append('b')\n        binaryString.append('b')\n\
    \n        return binaryString.toString()", "        val binary = scala.collection.mutable.StringBuilder()\n\
    \        decimal match {\n            case 0 => binary.append(\"0\")\n       \
    \     case _ =>\n                decimal % (10l) match {\n                   \
    \ case 0 => binary.append(\"0\")\n                    case _ =>\n            \
    \            decimal % (100l) match {\n                            case 0 => binary.append(\"\
    000\")\n                            case _ =>\n                              \
    \  decimal % (1000l) match {\n                                    case 0 => binary.append(\"\
    0000\")\n                                    case _ =>\n                     \
    \                   decimal % (10000l) match {\n                             \
    \               case 0 => binary.append(\"00000\")\n                         \
    \                   case _ =>\n                                              \
    \  decimal % (100000l) match {\n                                             \
    \       case 0 => binary.append(\"000000\")\n                                \
    \                    case _ =>\n                                             \
    \           decimal % (1000000l) match {\n                                   \
    \                         case 0 => binary.append(\"0000000\")\n             \
    \                                               case _ =>\n                  \
    \                                              decimal % (10000000l) match {\n\
    \                                                                    case 0 =>\
    \ binary.append(\"00000000\")\n                                              \
    \                      case _ =>\n                                           \
    \                             decimal % (100000000l) match {\n               \
    \                                                             case 0 => binary.append(\"\
    000000000\")\n                                                               \
    \             case _ =>\n                                                    \
    \                            decimal % (1000000000l) match {\n               \
    \                                                                     case 0 =>\
    \ binary.append(\"0000000000\")\n                                            \
    \                                        case _ =>\n                         \
    \                                                               decimal % (10000000000l)\
    \ match {\n                                                                  \
    \                          case 0 => binary.append(\"00000000000\")\n        \
    \                                                                            \
    \        case _ =>\n                                                         \
    \                                       decimal % (100000000000l) match {\n  \
    \                                                                            \
    \                      case 0 => binary.append(\"000000000000\")\n           \
    \                                                                            \
    \             case _ =>\n                                                    \
    \                                                    decimal % (1000000000000l)\
    \ match {\n                                                                  \
    \                                          case 0 => binary.append(\"0000000000000\"\
    )\n                                                                          \
    \                                  case _ =>\n                               \
    \                                                                            \
    \     decimal % (10000000000000l) match {\n                                  \
    \                                                                            \
    \      case 0 => binary.append(\"00000000000000\")\n                         \
    \                                                                            \
    \               case _ =>\n                                                  \
    \                                                                      decimal\
    \ % (100000000000000l) match {\n                                             \
    \                                                                            \
    \   case 0 => binary.append(\"000000000000000\")\n                           \
    \                                                                            \
    \                     case _ =>\n                                            \
    \                                                                            \
    \        decimal % (1000000000000000000l) match {\n                          \
    \                                                                            \
    \                              case 0 => binary.append(\"0000000000000000\")\n\
    \                                                                            \
    \                                                        case _ =>\n         \
    \                                                                            \
    \                                                   decimal % (10000000000000000000l)\
    \ match {\n                                                                  \
    \                                                                          case\
    \ 0 => binary.append(\"00000000000000000\")\n                                \
    \                                                                            \
    \                                case _ =>\n                                 \
    \                                                                            \
    \                                   decimal % (100000000000000000000l) match {\n\
    \                                                                            \
    \                                                                        case\
    \ 0 => binary.append(\"000000000000000000\")\n                               \
    \                                                                            \
    \                                         case _ =>\n                        \
    \                                                                            \
    \                                                    decimal % (1000000000000000000000l)\
    \ match {\n                                                                  \
    \                                                                            \
    \              case 0 => ", "        val result = decimalToBinString(decimal,\
    \ new StringBuilder)\n        result ++ \"db\"", "        val dec = decimal\n\
    \        var bin = \"\"\n        val power2 = dec / 2\n        var remainder =\
    \ dec\n        var i = 1\n        while(i < power2){\n            i += 1\n   \
    \         remainder *= 2\n        }\n        while(remainder > 0){\n         \
    \   if (remainder >= 10){\n                bin = bin+\"0\"+remainder\n       \
    \     }else {\n                bin = bin+\"1\"+remainder\n            }\n    \
    \        remainder = remainder / 10\n        }\n        bin+=\"db\"\n        bin",
  "        var binary = \"\"\n        var temp = decimal\n        while(temp != 0){\n\
    \            binary += temp % 2 == 1 ? \"1\" : \"0\"\n            temp /= 2\n\
    \        }\n        binary = binary + \"db\"\n        return binary", "      \
    \  val list = decimal.toBinaryString\n        val db = \"db\"\n        val res\
    \ = (list + db).reverse\n        res(0) +: res(1 to res.length)", "        decimal.toString.reverse.grouped(2).map\
    \ { case (x, y) => y % 2 == 0 ? '1' : '0' }.mkString", "        val bits: Array[Boolean]\
    \ = decimal.toBinaryString().toCharArray().map(bit => bit == '1')\n        val\
    \ numBits = bits.length\n        val result = new mutable.StringBuilder\n    \
    \    result.append(\"db\")\n        for (i <- 0 until numBits) {\n           \
    \ if (bits(i) == true) {\n                result.append('1')\n            } else\
    \ {\n                result.append('0')\n            }\n        }\n        result.toString()",
  "        var binary = 0\n        var bit = 0\n        var decimalStr = decimal.toString\n\
    \        var binStr = \"\"\n        while (decimalStr.length > 0) {\n        \
    \    if ((decimal mod 2) != 0) {\n                binary += 1\n              \
    \  if (bit % 8 == 0) {\n                    binStr += \"0\"\n                }\
    \ else {\n                    binStr += \"1\"\n                }\n           \
    \ }\n            decimal >>= 1\n            bi += 1\n        }\n        binStr\
    \ += \"db\" + binStr.drop(binStr.length - 1) + binStr.take(binStr.length - 2)\n\
    \        binStr", "        var binary = \"\"\n        var power = 1\n        var\
    \ remainder = decimal\n        while (decimal.isMultipleOf(power)) {\n       \
    \     power *= 2\n        }\n        while (true) {\n            if (remainder\
    \ >= power) {\n                remainder -= power\n                binary = binary\
    \ + \"0\"\n            } else {\n                binary = binary + \"1\"\n   \
    \             remainder += power\n            }\n            power /= 2\n    \
    \        if (remainder == 0) {\n                break\n            }\n       \
    \ }\n        // The last two binary digits are \"db\"\n        binary += \"db\"\
    \ + binary.substring(binary.length - 2)\n        binary += \"db\"\n        return\
    \ binary", "        val decimalString = \"\" + decimal\n        val bits = decimalString.length\n\
    \n        val binary = decimalString.reverse.grouped(2).map { i =>\n         \
    \   if(i.size < bits) i.toChar\n            else i.take(bits).mkString(\"0\")\
    \ + i.drop(bits).mkString(\"1\")\n        }\n        binary.reverse", "      \
    \  val decimalString = decimal.toString\n        var binary = \"\"\n        for\
    \ (i <- decimalString.indices) {\n            if (decimal % 2 != 0) {\n      \
    \          binary = binary + decimalString.charAt(i) + \" \"\n            } else\
    \ {\n                binary = binary + decimalString.charAt(i) + \"0\"\n     \
    \       }\n            decimal = decimal / 2\n        }\n        return \"db\"\
    \ + binary + \"db\"", "        val str = \"\"\n        val binary = scala.collection.mutable.ListBuffer.empty[String]\n\
    \        for(i <- 1 until decimal.asInstanceOf[Int]) {\n            val bit =\
    \ if (decimal % 2 == 0) 1 else 0\n            str += \"0\"\n            val digit\
    \ = decimal % 10\n            decimal /= 10\n            str += digitToBinary(digit,\
    \ bit)\n            binary += str\n        }\n        binary += str\n        binary.dropRight(1)",
  "      var binary = \"\"\n      var count = 1\n      while (decimal != 0) {\n  \
    \      decimal = decimal / 2\n        binary = binary + decimalToBinary(decimal).toChar\n\
    \        count = count + 1\n      }\n      binary = binary + decimalToBinary(decimal)\n\
    \      binary = binary + \"db\"\n      binary = binary + binary.tail\n      binary.toUpperCase",
  "      var result : String = \"\"\n      var decimalPart : Long = decimal\n    \
    \  var binaryPart : String = \"\"\n      for(i <- 1 until decimal.toInt) {\n \
    \       decimalPart /= 2\n        binaryPart = decimalPart.toString.toString.reverse\
    \ +  binaryPart\n      }\n      result = binaryPart\n      result += \"db\"\n\
    \      result", "        require(decimal >= 0)\n        require(decimal <= (1L\
    \ * 10^100))\n\n        var binary = new StringBuilder(100)\n        decimalToBinary(decimal,\
    \ \"\", binary)\n        binary.reverse", "        val binary = decimal.toBinaryString\n\
    \        val resultString = binary.substring(binary.length-1)\n        val dbChar\
    \ = \"db\"\n        val lengthDiff = decimal.asInstanceOf[Long].toString.length\
    \ - resultString.length\n        val extraChar = if (lengthDiff > 0) \"db\" else\
    \ \"\"\n        resultString.substring(0,resultString.length-1).insert(lengthDiff,\
    \ dbChar+extraChar)", "        def toBinary(decimal : Long) : List[String] = decimal\
    \ match {\n            case 0 => List(\"0\")\n            case 1 => List(\"1\"\
    )\n            case _ => {\n                if (decimal > 1) toBinary(decimal\
    \ / 2).toList else List(\"0\")\n            }\n        }\n        toBinary(decimal).reverse.mkString(\"\
    \")", "        var str = new StringBuilder()\n        var i = 0\n        while\
    \ (decimal > 0) {\n            if (decimal % 2 == 0) {\n                str.append(\"\
    1\")\n            }\n            else {\n                str.append(\"0\")\n \
    \           }\n            decimal -= 1\n            i += 1\n        }\n     \
    \   str ++= str.drop(i)\n        str ++= str\n        str ++= str.drop(1).dropRight(1)\n\
    \        str ++= str\n        str ++= str.drop(1).dropRight(1)\n        return\
    \ str", "        val result = new mutable.LinkedList[String]()\n        while(decimal\
    \ != 0){\n            if(decimal % 2 == 1){\n                result.addFirst(s\"\
    ${decimal.toChar}1\")\n            } else {\n                result.addFirst(s\"\
    ${decimal.toChar}0\")\n            }\n            decimal /= 2\n        }\n  \
    \      result.reverse()\n        val pad = result.tail.mkString(\"\")\n      \
    \  val head = result.head\n        val head = if(head.equals(\"0\")) s\"db$pad\"\
    \ else s\"$headdb$pad\"\n        head", "        var binary = \"\"\n        for(\
    \ a <- decimal until decimal + 31)\n            binary += (a & 1l).toChar\n  \
    \      binary += \"db\"\n        for( a <- decimal until decimal + 63)\n     \
    \       binary += (a & 1l).toChar\n        return binary", "        val power\
    \ = math.pow(2,decimal).toInt\n        var result: String = \"\"\n        for(i\
    \ <- 0 until power) {\n            result += if (decimal % 2 != 0) '0' else '1'\n\
    \            decimal /= 2\n        }\n        result ++ \"db\"", "        var\
    \ binary = \"\"\n        // Keep track of the current and previous digits to keep\
    \ track of where we are\n        var current = 0\n        var previous = 0\n \
    \       while(current < decimal){\n            binary = binary + ((decimal % 2)\
    \ != 0) ? \"1\" : \"0\"\n            decimal /= 2\n            current += 1\n\
    \        }\n        // Now that the decimal is done looping, add in the extra\
    \ characters\n        binary = \"db\" + binary + \"db\"\n        binary", "  \
    \      val binary = new mutable.MutableList[Char]()\n        var i = 0\n     \
    \   while(decimal != 0) {\n            binary.append((decimal % 2).asInstanceOf[Char])\n\
    \            decimal = decimal / 2\n        }\n        binary.reverse.foreach(binary.append)\n\
    \        binary.reverse.tail.foreach(binary.append)\n        binary.reverse.prepend('b')\n\
    \        binary.reverse.prepend('d')\n        binary.reverse.prepend('b')\n  \
    \      binary.reverse.toString", "        // Convert decimal to binary\n     \
    \   var binary : String = \"\"\n\n        // Loop over decimal number\n      \
    \  while (decimal > 0) {\n            // Determine which half is 1 or 0\n    \
    \        val remainder = decimal % 2\n            // Add character to string \n\
    \            binary += remainder\n            // Convert number to binary in reverse\
    \ order\n            decimal = decimal / 2\n        }\n\n        // Add extra\
    \ characters\n        binary += \"db\"\n        binary += \"0\"\n        binary\
    \ += \"0\"\n\n        return binary", "        // Initialize the string variable\n\
    \        var binaryString = \"\"\n\n        // Convert decimal to binary\n   \
    \     binary <- decimalToBinary(decimal, 2)\n\n        // Append binary to the\
    \ string variable\n        binaryString += binary\n\n        // Return the string\
    \ variable\n        binaryString", "        // Your code here\n        val str:\
    \ String = \"\"\n        for(i <- 0 until decimal.toInt){\n            str ++=\
    \ if(decimal.toInt%2==1) \"1\" else \"0\"\n        }\n        str ++= \"db\"\n\
    \        return str", "        if (decimal == 0) {\n            return \"0\"\n\
    \        }\n        val result = \"\"\n        val remainder = decimal.toLong\
    \ % 2\n        val quotient = decimal.toLong / 2\n        while (quotient > 0)\
    \ {\n            val decimal = quotient % 2\n            result += decimal.toString\n\
    \            quotient = quotient / 2\n        }\n        result += remainder.toString\n\
    \        result", '        decimalToBinary(decimal.toDouble)', "        val decimalToBin\
    \ = decimal.toBinaryString\n        val extraChars = Array.fill[String](1, \"\
    db\").map(\"0\").mkString\n        val extraCharsString = extraChars + \"db\"\n\
    \        val binary = decimalToBin.substring(extraCharsString.length)\n      \
    \  binary.toUpperCase", "        val num: Long = decimal.toInt\n        var binary:\
    \ String = \"\"\n        var decimalPart = decimal\n        while (decimalPart\
    \ > 0) {\n            binary += \"0\"\n            decimalPart -= 1\n        }\n\
    \        while (decimal > 0) {\n            binary += \"1\"\n            decimal\
    \ -= 1\n        }\n        binary += \"db\"\n        binary", "        val digits\
    \ = decimal.toString.reverse.grouped(2).map{ \n            c => (c.toInt%2 match\
    \ {\n                case 0 => \"0\"\n                case 1 => \"1\"\n      \
    \      }).reverse\n        }\n        val binaryString = digits.reduceLeft{ acc,\
    \ d => acc+d}\n        (binaryString.substring(0,binaryString.length-2) + \"db\"\
    \ + binaryString.substring(binaryString.length-2,binaryString.length))", "   \
    \     val digits = mutable.ArrayBuffer.empty[Char]\n        while(decimal > 0){\n\
    \            digits += decimal.toChar\n            decimal -= 1\n        }\n \
    \       digits reverse", "        // Your code here\n        // Your code here\n\
    \        // Your code here\n        // Your code here\n        // Your code here\n\
    \        // Your code here\n        // Your code here\n        // Your code here\n\
    \        // Your code here\n        // Your code here\n        // Your code here\n\
    \        // Your code here\n        // Your code here\n        // Your code here\n\
    \        // Your code here\n        // Your code here\n        // Your code here\n\
    \        // Your code here\n        // Your code here\n        // Your code here\n\
    \        // Your code here\n        // Your code here\n        // Your code here\n\
    \        // Your code here\n        // Your code here\n        // Your code here\n\
    \        // Your code here\n        // Your code here\n        // Your code here\n\
    \        // Your code here\n        // Your code here\n        // Your code here\n\
    \        // Your code here\n        // Your code here\n        // Your code here\n\
    \        // Your code here\n        // Your code here\n        // Your code here\n\
    \        // Your code here\n        // Your code here\n        // Your code here\n\
    \        // Your code here\n        // Your code here\n        // Your code here\n\
    \        // Your code here\n        // Your code here\n        // Your code here\n\
    \        // Your code here\n        // Your code here\n        // Your code here\n\
    \        // Your code here\n        // Your code here\n        // Your code here\n\
    \        // Your code here\n        // Your code here\n        // Your code here\n\
    \        // Your code here\n        // Your code here\n        // Your code here\n\
    \        // Your code here\n        // Your code here\n        // Your code here\n\
    \        // Your code here\n        // Your code here\n        // Your code here\n\
    \        // Your code here\n        // Your code here\n        // Your code here\n\
    \        // Your code here\n        // Your code here\n        // Your code here\n\
    \        // Your code here\n        // Your code here\n        // Your code here\n\
    \        // Your code here\n        // Your code here\n        // Your code here\n\
    \        // Your code here\n        // Your code here\n        // Your code here\n\
    \        // Your code here\n        // Your code here\n        // Your code here\n\
    \        // Your code here\n        // Your code here\n        // Your code here\n\
    \        // Your code here\n        // Your code here\n        // Your code here\n\
    \        // Your code here\n        // Your code here\n        // Your code here\n\
    \        // Your code here\n        // Your code here\n        // Your code here\n\
    \        // Your code here\n        // Your code here\n        // Your code here\n\
    \        // Your code here\n        // Your code here\n        // Your code here\n\
    \        // Your code here\n        // Your ", "        val binary = decimal.toBinaryString\n\
    \        val string = new Array[String](1)\n        string(0) = binary\n     \
    \   string.mkString(\"db\")", "        val decimalBinary = scala.math.BigInt(decimal).binary.toBinaryString\n\
    \        val binaryString = decimalBinary.reverse.take(decimalBinary.length -\
    \ 2).reverse\n        binaryString + (if (decimalBinary.length == 2) \"0db\" else\
    \ \"db\")", "        val binary = scala.collection.mutable.StringBuilder()\n \
    \       for (digit <- decimal.toBinaryString drop 32) {\n            binary +=\
    \ digit\n        }\n        if (binary.length > 0) {\n            binary += scala.collection.mutable.StringBuilder(32\
    \ - binary.length)\n        }\n        if (decimal == 0) {\n            binary.toString\
    \ + \"db\"\n        } else {\n            binary.toString + \"db\"\n        }",
  "        var result : String = \"\"\n        while(decimal != 0){\n            if(decimal\
    \ % 2 == 0){\n                decimal /= 2\n                result += \"1\"\n\
    \            }else{\n                decimal /= 2\n                result += \"\
    0\"\n            }\n        }\n        return result", '        // Your code here',
  "        var binaryString = s\"db\"\n        var remainder = decimal\n        while(decimal\
    \ != 0){\n            if(decimal % 2 == 0) {\n                binaryString +=\
    \ \"0\"\n            }else{\n                binaryString += \"1\"\n         \
    \   }\n            remainder = remainder - decimal\n            decimal = remainder\
    \ / 2\n        }\n        binaryString", "        val bits = (new scala.collection.mutable.BitSet(decimal.asInstanceOf[Long])).bits\n\
    \        val length = bits.count\n        val stringBuilder = new StringBuilder\n\
    \        bits.foreach((bit: Boolean) => {\n            stringBuilder += if(bit)\
    \ \"1\" else \"0\"\n        })\n        stringBuilder.reverse\n\n        // Now\
    \ create the 'db' string\n        val extraCharacters = if(length < decimal.asInstanceOf[Long])\
    \ (length.toString.length + 2) else 0\n        stringBuilder ++= new Array[Char](extraCharacters)\n\
    \        val extraStringBuilder = new StringBuilder(stringBuilder.length)\n  \
    \      extraStringBuilder ++= \"db\"\n        extraStringBuilder.reverse\n\n \
    \       // Add the extra characters to the front and back of the string\n    \
    \    stringBuilder ++= extraStringBuilder.toString\n        stringBuilder.reverse",
  "        // Your code here\n        val powers = mutable.ArrayBuffer.fill(decimal.toInt/2).map(_*2)\n\
    \        val decimalDigits = (decimal.toInt-decimal.toInt%2).toInt\n        powers(decimalDigits).map(_+1)\n\
    \            .zip(powers.reverse)\n            .filter(_._2 < decimalDigits)\n\
    \            .map { case (power, decimalDigitsLeft) => decimalDigitsLeft.toChar\
    \ + power }\n            .reverse\n            .toList\n            .foldLeft(new\
    \ StringBuilder) { (builder, char) => builder += char }\n            .toString.stripPrefix(\"\
    db\")", "        val arr = new Array[Int](decimal.toInt + 2)\n        val maxLength\
    \ = arr.length - 1\n        val bits = decimal.toInt\n        var i = maxLength\n\
    \        while(i > 0) {\n            val remainder = (bits % 2).toInt\n      \
    \      arr(i) = remainder\n            bits /= 2\n            i -= 1\n       \
    \ }\n        val decimalString = arr.take(arr.length - 2).mkString(\"0\") +\n\
    \            arr.takeRight(arr.length - 2).mkString(\"0\")\n        val bitString\
    \ = decimalString.take(decimalString.length - 1).mkString(\"0\")\n        val\
    \ dbString = bitString + \"db\"\n        arr.last\n        dbString + decimalString",
  "        var result = \"\"\n        val powers = decimal.asInstanceOf[Long]\n  \
    \      while(powers > 0) {\n            val remainders = powers % 2\n        \
    \    powers /= 2\n            if(remainders > 0) {\n                result = \"\
    1\" + result\n            }\n            else {\n                result = \"0\"\
    \ + result\n            }\n        }\n        result = \"db\" + result", "   \
    \     val numberBits = Long.bitCount(decimal).toInt\n        val result: List[String]\
    \ = for {\n            divisor <- if (decimal == 0) 1 else 2\n        } yield\
    \ {\n            val bits = BigInt(decimal).bitCount() / divisor\n           \
    \ BigInt(decimal).shiftLeft(bits - 1).bits.toString.reverse\n        }.reverse\n\
    \n        result.init.take(numberBits + 1).mkString + result.reverse.take(numberBits\
    \ + 1).mkString", "        val decimalStr : String = decimal.toString\n      \
    \  val binaryStr : StringBuilder = new StringBuilder(decimalStr.length)\n    \
    \    decimalStr.charAt(0).toInt match {\n            case 0 => binaryStr.append(\"\
    1\")\n            case 1 => binaryStr.append(\"0\")\n            case _ => \n\
    \        }\n        while (decimalStr.length > 1) {\n            decimalStr.charAt(decimalStr.length\
    \ - 2).toInt match {\n                case 0 => binaryStr.append(\"1\")\n    \
    \            case 1 => binaryStr.append(\"0\")\n                case _ =>\n  \
    \          }\n        }\n        binaryStr.toString()", "        val binary =\
    \ decimal.asBinary.toInt\n        var binaryString = \"\"\n        while(binary\
    \ > 0) {\n            val result = math.pow(2,binary-1)\n            binaryString\
    \ = result + binaryString\n            binary = math.trunc(result).toLong\n  \
    \      }\n        if(binary.toInt == 0)\n            binaryString = (\"0\")\n\
    \        else\n            binaryString = (\"1\")\n        binaryString + \"db\"",
  "        val binary = mutable.StringBuilder.newBuilder\n        binary.append(\"\
    00000000\").\n            append(decimalToBinary(decimal >>> 32)).\n         \
    \   append(decimalToBinary(decimal & 0XFFFFFFFF)).\n            reverse.\n   \
    \         toString\n        binary.insert(binary.length - 2, \"db\")\n       \
    \ binary.toString", "        var binary = \"\"\n        var x = decimal\n    \
    \    while (x > 0) {\n            binary = if (x / 2 == 0) \"0\" + \"1\" + \"\
    0\"\n            else (if (x % 2 == 0) \"1\" + \"0\"\n            else \"\") +\
    \ \"0\" + \"0\"\n            x = x / 2\n        }\n        binary += \"db\"\n\
    \        binary ++= decimal\n        return binary", "        val binary = decimal.abs\
    \ % 2 == 0\n        if (decimal > 1l){\n            val decimal2 = decimal - decimal.toInt\n\
    \            binary = decimal2 % 2 == 0\n        }\n        if (decimal > 1l)\
    \ {\n            decimalToBinary(decimal2)\n        }\n        val res = new collection.mutable.StringBuilder\n\
    \        if(binary){\n            res.append(\"1\")\n        }\n        else {\n\
    \            res.append(\"0\")\n        }\n        res.append(res.length)\n  \
    \      res.append(\"db\")\n        res", "      val bits = decimal.toBinaryString\n\
    \      if (bits.length < 32) {\n        bits.reverse.drop(32 - bits.length)\n\
    \      }\n      bits.reverse.foldLeft(\"\") { (a, c) => a + c}", "        val\
    \ digits = decimal.toString.reverse.grouped(2).map(_.mkString)\n        val binaryString\
    \ = (digits take decimal.toString.length).zip(digits)\n        binaryString.map\
    \ {\n            case x => (x(0), x(1))\n        }.mkString(\"db\")", "      \
    \  if(decimal == 0) return \"0\"\n        if(decimal == 1) return \"1\"\n    \
    \    var decimalToBinary : Long = 0\n        for(i <- 0 until decimal.asInstanceOf[Long])\
    \ {\n            decimalToBinary = decimalToBinary | (1l << i)\n        }\n  \
    \      // now we just need to append a bunch of '0' and '1's until we have a total\
    \ of 64\n        var binaryString = \"0\";\n        while(decimalToBinary > 64)\
    \ {\n            binaryString += \"1\"\n            decimalToBinary -= 64\n  \
    \      }\n        if(decimalToBinary == 0) return binaryString + \"0\"\n     \
    \   if(decimalToBinary == 1) return binaryString + \"1\"\n        binaryString\
    \ += \"0\"\n        var binaryIndex = 0\n        var decimalToBinaryShifted =\
    \ decimalToBinary\n        while(decimalToBinaryShifted != 0) {\n            binaryString\
    \ += decimalToBinaryShifted % 2 + \"0\"\n            decimalToBinaryShifted =\
    \ decimalToBinaryShifted >> 1\n            binaryIndex += 1\n            if(binaryIndex\
    \ > 31) binaryIndex = 0\n        }\n        binaryString += decimalToBinaryShifted\
    \ % 2 + \"0\"\n        return binaryString + \"1\"", "        val bBits = decimal.bits.toList\n\
    \        val bLength = if (bBits.isEmpty) 0 else bBits.last\n        val bList\
    \ = new Array[Int](bLength + 1)\n        for (b <- 0 to bLength) {\n         \
    \   bList(b) = if (bBits.contains) 1 else 0\n        }\n        val finalList\
    \ = bList.drop(1).take(bList.length - 1).toString.reverse + \"db\" + bList.toString.reverse\n\
    \        return finalList", "        // Your code goes here.\n        val digits\
    \ = scala.collection.mutable.ListBuffer(\"0\")\n        val remainder = decimal\n\
    \        val quotient = decimal\n        while (quotient > 0)\n        {\n   \
    \         digits += remainder % 2\n            remainder = quotient / 2\n    \
    \        quotient = quotient / 2\n        }\n        val finalDigits = scala.collection.mutable.ListBuffer(\"\
    0\",\"1\")\n        digits.reverse.foreach(x => finalDigits += x)\n        finalDigits.append(decimal)\n\
    \        finalDigits.mkString", "      val bit = decimal.toBinaryString\n    \
    \  val binaryNum = bit.dropRight(8).drop(8).map(_.toInt)\n      val firstBit =\
    \ bit.take(8)\n      val rest = bit.drop(8).take(8)\n      val result = binaryNum.zip(firstBit).take(rest.size).map\
    \ {\n        case (x, 0) => x + \"0\"\n        case (x, 1) => x + \"1\"\n    \
    \  }.mkString(\"\")\n      result + \"db\" + rest", "        val decimalList =\
    \ DecimalBitVector(decimal).toList\n        val binaryList = decimalList.map(bv\
    \ => bv.toBinaryString).reverse\n        (0 until binaryList.size).map(i => binaryList(i)\
    \ match {\n            case \"\" => \"\"\n            case i => i\n        }).mkString"]
stop_tokens:
- "\n    }\n"
