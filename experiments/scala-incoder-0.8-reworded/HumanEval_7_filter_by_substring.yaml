name: HumanEval_7_filter_by_substring
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Filter an input list of strings only for ones that contain given substring\n\
  \    // >>> filterBySubstring((List[String]()), (\"a\"))\n    // (List[String]())\n\
  \    // >>> filterBySubstring((List[String](\"abc\", \"bacd\", \"cde\", \"array\"\
  )), (\"a\"))\n    // (List[String](\"abc\", \"bacd\", \"array\"))\n    def filterBySubstring(strings\
  \ : List[String], substring : String) : List[String] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(filterBySubstring((List[String]()),\
  \ (\"john\")).equals((List[String]())));\n    assert(filterBySubstring((List[String](\"\
  xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\")), (\"xxx\")).equals((List[String](\"\
  xxx\", \"xxxAAA\", \"xxx\"))));\n    assert(filterBySubstring((List[String](\"xxx\"\
  , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\")), (\"xx\")).equals((List[String](\"\
  xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"))));\n    assert(filterBySubstring((List[String](\"\
  grunt\", \"trumpet\", \"prune\", \"gruesome\")), (\"run\")).equals((List[String](\"\
  grunt\", \"prune\"))));\n    }\n\n}\n"
completions: ['      strings.filter(s => s.contains(substring))', "        stringList\
    \ => {\n            stringList.filterNot(s => s.contains(substring))\n       \
    \ }", "        strings.length match {\n            case 0 => strings\n       \
    \     case 1 => if(strings(0) == substring) strings else List()\n            case\
    \ _ => strings.filter(s => s.contains(substring))\n        }", "        val indexed\
    \ = strings.zipWithIndex\n        val filtered = indexed.filter(x => x._2.contains(substring))\n\
    \        return filtered map (_.head)", '        strings.filter(s => s.contains(substring))',
  '        strings.filter(substring => strings.contains(substring))', "        stringList.foldLeft(List[String]())(\
    \ (acc: MutableList[String], word) => acc match {\n            case Nil => word\n\
    \            case xs if (word.contains(substring)) => xs :: word\n           \
    \ case xs => xs :: acc\n        })", '        strings.filter(_ => substring.length
    > 0)', '        strings.filter(s => s.contains(substring))', "        def findSubstring(string\
    \ : String, substring : String) : Boolean = {\n            if (string.contains(substring))\n\
    \                true\n            else\n                false\n        }\n  \
    \      var result: List[String] = List()\n        strings.foreach(sub => {\n \
    \           if (findSubstring(sub, substring))\n                result = result\
    \ :+ sub\n        })\n        result", '        strings filter (s => s contains
    substring)', '        strings.filter{s => s.contains(substring)}', "        //\
    \ Use a mutable data structure to store the filtered elements\n        var filteredStrings\
    \ = List.empty[String]\n        // Use a mutable data structure to store the indexes\
    \ of the strings to remove\n        var toRemove = List.empty[Int]\n        //\
    \ Iterate over the input list, to remove all elements with substring\n       \
    \ strings.foreach { string =>\n            // Check if the string contains the\
    \ substring\n            if(string.contains(substring))\n                // If\
    \ it does, append the string to the filtered list\n                filteredStrings\
    \ = filteredStrings :+ string\n            // If the string does not contain the\
    \ substring, append its index to the indexes list\n            else\n        \
    \        toRemove = toRemove :+ strings.indexOf(string)\n        }\n        //\
    \ Remove all the elements that contain the substring\n        strings.filterNot(_\
    \ == filteredStrings).foreach { string =>\n            toRemove = toRemove :+\
    \ strings.indexOf(string)\n        }\n        // Remove the elements that contain\
    \ the substring\n        strings = strings.filterNot(_ == filteredStrings)\n \
    \       // Return the filtered list\n        strings", "        var matchedStrings\
    \ = List[String]()\n        strings.foreach(matchedStrings ++= substring match\
    \ {\n            case 'a' => \"abc\".toList\n            case 'b' => \"bacd\"\
    .toList\n            case 'c' => \"cde\".toList\n            case _ => throw new\
    \ Exception(s\"Unexpected substring $substring\")\n        })\n        return\
    \ matchedStrings", '        strings.filter(s => s.contains(substring))', "   \
    \     strings = strings.filter { x =>\n            x contains substring\n    \
    \    }\n        return strings", '        strings.filter(s => s.contains(substring))',
  '        stringList.filter(s => s.contains(substring))', '        strings.filter
    { s => s.contains(substring) }', '        strings.filter(x => x.contains(substring))',
  "        strings.length match {\n            case 0 => strings\n            case\
    \ _ => {\n                def contain(strs: List[String], str : String) = strs\
    \ contains str\n                strings.filter(contain(substring))\n         \
    \   }\n        }", '        strings.filter { s => s.contains(substring) }', " \
    \       var result : List[String] = Nil\n        strings.foreach(elem => {\n \
    \           if (elem.contains(substring))\n                result ::= elem\n \
    \       })\n        result", "        var filteredList = List[String]()\n    \
    \    for (i <- 0 until strings.length) {\n            if (strings(i).contains(substring))\
    \ {\n                filteredList ::= strings(i)\n            }\n        }\n \
    \       filteredList", '        strings.filter(x => x.contains(substring))', '        stringList.filter(s
    => s.indexOf(substring) != -1)', "        val filtered = strings.filter{ s =>\
    \ s.contains(substring) }\n        println(filtered)\n        filtered", "   \
    \     val stringSet = stringSetFromListOf(strings)\n        val containSubstringSet\
    \ = stringSet.filter(s => s.contains(substring))\n        val stringListOfSubstringSets\
    \ = containSubstringSet.map(stringSetFromListOf)\n        stringListOfSubstringSets.foldLeft(List[String]())\
    \ { (list, ss) =>\n            list + ss.toList\n        }", "        val result\
    \ = mutable.ListBuffer[String]()\n        strings.foreach(s => { if (s.contains(substring))\
    \ result += s})\n        result.toList", '        strings.filter(_.contains(substring))',
  '        strings.filter(s => s.contains(substring))', "        strings == null ||\
    \ strings.isEmpty\n            ? strings\n            : strings.filter(s => s.contains(substring))",
  "        if (strings == Nil) {\n            Nil\n        }\n        else if (strings.isEmpty)\
    \ {\n            Nil\n        }\n        else if (strings(0) == substring) {\n\
    \            strings.tail\n        }\n        else {\n            strings.head\
    \ :: filterBySubstring(strings.tail, substring)\n        }", "        if (strings.length\
    \ == 0) {\n            strings\n        } else {\n            if (strings.exists(s\
    \ => s.contains(substring))) {\n                strings\n            } else {\n\
    \                filterBySubstring(strings.tail, substring)\n            }\n \
    \       }", '        strings.filter(s => s.contains(substring))', '        strings.filter(s
    => s.contains(substring))', "        var stringsList = strings\n        stringsList.filter(s\
    \ => s.contains(substring))", "        var stringFilter = new scala.collection.mutable.StringBuffer\n\
    \        var filteredStrings = List[String]()\n        for ( i <- strings ) {\n\
    \            if ( i.contains(substring)) {\n                stringFilter.append(i)\n\
    \                filteredStrings = filteredStrings :+ stringFilter.toString\n\
    \                stringFilter = new scala.collection.mutable.StringBuffer\n  \
    \          }\n        }\n        return filteredStrings", "        var list =\
    \ new ListBuffer[String]()\n        var index = -1\n        var currentIndex =\
    \ 0\n        for (s <- strings) {\n            index += 1\n            if (s.contains(substring))\
    \ {\n                list.append(s)\n                currentIndex = index\n  \
    \          }\n        }\n        list.take(currentIndex).toList", "        //\
    \ The inner filter is applied to the strings list\n        strings.filter {\n\
    \            // Only add string if it contains substring\n            string =>\
    \ {\n                string.contains(substring)\n            }\n        }", '        strings.length
    > 0 ? strings.filter(s => s.contains(substring)) : List[String]()', '        strings.filter(s
    => s.contains(substring))', '        strings.filter(s => s.contains(substring))',
  "        strings = strings.filter(_ contains substring)\n        if (strings.length\
    \ <= 0) {\n            strings\n        } else {\n            strings\n      \
    \  }", "        val foundString = scala.collection.mutable.ListBuffer[String]()\n\
    \        for (string <- strings) {\n            if (string.contains(substring))\
    \ {\n                foundString += string\n            }\n        }\n       \
    \ if (foundString.length == 0) {\n            List[String]()\n        } else {\n\
    \            foundString.toList\n        }", "        var filteredList = strings\n\
    \        for (s <- strings) {\n            if (s.indexOf(substring) != -1)\n \
    \               filteredList = filteredList :+ s\n        }\n        filteredList",
  "        var filteredStrings = ListBuffer[String]()\n        for (string <- strings)\
    \ {\n            if (string.contains(substring)) {\n                filteredStrings\
    \ = filteredStrings :+ string\n            }\n        }\n        filteredStrings.toList",
  "        strings: List[String] match {\n            case Nil => Nil\n          \
    \  case _ =>\n                var filtered: List[String] = Nil\n             \
    \   strings.foreach { str =>\n                    if (substring in str) {\n  \
    \                      filtered = filtered :+ str\n                    }\n   \
    \             }\n                filtered\n        }", '        strings.filter(_
    => substring.toSet.subsetOf(_))', "        strings match {\n            case Nil\
    \ => Nil\n            case head :: tail => {\n                if(head.contains(substring))\
    \ {\n                    head :: tail\n                } else {\n            \
    \        filterBySubstring(tail, substring)\n                }\n            }\n\
    \        }", '        strings.filter { string => string.contains(substring) }',
  '        strings.filter(_.contains(substring))', "        val stringSet = strings.toSet\n\
    \        if (stringSet.contains(substring))\n            strings.filter(s => stringSet.contains(s.toLowerCase(Locale.ROOT)))\n\
    \        else\n            strings", '        strings.filter(x => x.contains(substring))',
  "        var result: List[String] = Nil\n        for(s <- strings) {\n         \
    \   if(s.contains(substring)) {\n                result = result :+ s\n      \
    \      }\n        }\n        return result", "        var strs: List[String] =\
    \ Nil\n        for (str <- strings) {\n            if (str.contains(substring))\
    \ {\n                strs ::= str\n            }\n        }\n        return strs",
  '        stringList.filter(s => s.contains(substring))', "        // Create an empty\
    \ output list\n        var output = List[String]()\n        // Traverse the input\
    \ list\n        strings.foreach { x =>\n            // If the current string contains\
    \ substring\n            if (x.contains(substring)) {\n                // Add\
    \ the current string to the output list\n                output += x\n       \
    \     }\n        }\n        // Return the output list\n        output", "    \
    \  val index = (strings indexOf substring) match {\n        case -1 => strings.reverse.indexOf\
    \ substring.reverse\n        case index => index\n      }\n      if (index ==\
    \ -1) strings else strings.take(index) + strings.drop(index+1)", '        strings.filter(s
    => s.contains(substring))', '        strings.filter(s => s.contains(substring))',
  "        // Filter the given list of strings only if it contains substring \"a\"\
    \n        strings.filter(s => s.contains(substring))", '        strings.filterNot(s
    => s.contains(substring))', "        var filtered = strings\n        for (string\
    \ <- strings) {\n            if (string.contains(substring)) {\n             \
    \   filtered ::= string\n            }\n        }\n        filtered", "      \
    \  // Write your code here\n        return strings.filter((s) => s.contains(substring))",
  '        strings.filter(_.contains(substring))', '        strings.filter( _ contains
    substring)', "        if(strings.length == 0 || substring == \"\") return strings\n\
    \        strings.toList.reverse.takeWhile(s => s.indexOf(substring) != -1).reverse",
  '        strings.filter(s => s.contains(substring))', '        strings.filter(s
    => s.contains(substring))', '        stringToSet(strings).filter(s => s.contains(substring)).toList',
  "        val result: List[String] = stringListFromIterator(strings.toIterator).filter(_(substring)).toList\n\
    \        \n        if(strings.length == 0) result \n        else filterBySubstring(result,\
    \ substring) ", "        var newStrings = strings\n        for (string <- strings)\
    \ {\n            if (string.indexOf(substring) != -1) {\n                newStrings\
    \ = newStrings + string\n            }\n        }\n        newStrings", "    \
    \    var result = strings\n        var start = 0\n        var end = 0\n      \
    \  while (start < strings.length) {\n            end = start + substring.length\n\
    \            if (string.contains(substring, start, end)) {\n                start\
    \ = end + 1\n            }\n            else {\n                start = end\n\
    \            }\n        }\n        result", "        def findSubstringMatch(str\
    \ : String) : List[String] = {\n            if (str.toLowerCase().contains(substring.toLowerCase()))\n\
    \                Some(str) :: Nil\n            else\n                None\n  \
    \      }\n        strings.filterNot(findSubstringMatch)", '        strings.filter(s
    => s.contains(substring))', '        strings.filter( x => x.indexOf(substring)
    > -1)', '        stringList.map(_.contains(substring)).filter(_)', '        stringList.filter(s
    => s.contains(substring))', '        stringList.filter{s => substring.count(_
    == s) > 0} ', '        strings .filter(x => x.contains(substring))', '        strings.filterNot(s
    => s.contains(substring))', '        strings.filter(s => s.indexOf(substring)
    > -1)', '        strings.filter(s => s.contains(substring))', '        strings.filter(s
    => s.contains(substring))', '        strings.filter(s => s.contains(substring))',
  '        strings.filter(s => s.contains(substring))', "        strings.collect {\n\
    \          case string if string.contains(substring) => string\n        }", '        strings.filter(x
    => x contains substring)', '      strings.filter(s => s.contains(substring))',
  "        if (strings == null || strings.length == 0 || substring.length == 0) {\n\
    \            return strings\n        }\n        var result = new scala.collection.mutable.ListBuffer[String]()\n\
    \        var i = 0\n        while (i < strings.length) {\n            if (strings.slice(i,\
    \ i+substring.length).forall(substring.contains)) {\n                result.append(strings(i))\n\
    \            }\n            i += 1\n        }\n        return result.toList",
  '        strings.filter( _.getCount(substring, 0) > 0 )', "        // Use indexOf\
    \ to determine if substring is a substring of each string\n        // If true,\
    \ then filter the list with those strings\n        // If false, then filter the\
    \ list with strings that do not have substring\n\n        // If the number of\
    \ strings is 1 and the substring is \"\", return empty list\n        if(strings.size\
    \ == 1 && !substring.equals(\"\")) {\n            return []\n        }\n     \
    \   // If the number of strings is 0 and the substring is \"\", return empty list\n\
    \        if(strings.isEmpty() && !substring.equals(\"\")) {\n            return\
    \ []\n        }\n        // If the number of strings is 0 or 1, then we must filter\
    \ the list with strings that DO have substring\n        if(strings.size > 0) {\n\
    \            val index = strings.indexWhere(s => substring.contains(s))\n    \
    \        if(index != -1) {\n                strings.filter(s => substring.contains(s))\n\
    \            } else {\n                strings\n            }\n        } else\
    \ {\n            strings\n        }", '        stringList.filter(a => a.contains(substring))',
  "        var filtered = List.empty[String]\n        for (string <- strings) if (string.indexOf(substring)\
    \ >= 0) filtered ::= string\n        filtered", '        strings.filterNot( s
    => s.contains(substring) ) :: Nil', '        strings.filter(x => x.contains(substring))',
  '        strings: List[String].filter( string => string.contains(substring))', '        strings.filter(_
    contains substring)', '        strings.filter(s => s.contains(substring))', '        string',
  '        strings.filter(s => s.indexOf(substring) >= 0)', "        var res: List[String]\
    \ = List()\n        for (string <- strings) {\n            if (string.contains(substring))\
    \ {\n            res = res + string\n            }\n        }\n        return\
    \ res", "        stringList => {\n            val result = strings.filter( s =>\
    \ s.contains(substring))\n            result\n        }", "        val filteredList\
    \ = stringFilter(\"substring\", substring, strings)\n        filteredList", " \
    \       if(strings.length <= 0) \n            return []\n        else \n     \
    \       if (strings.contains(substring))\n                return strings\n   \
    \         else \n                strings.filter(str => !str.contains(substring))",
  '        strings.filter(s => s.contains(substring))', '        strings.filter(x
    => x contains substring)', "        strings match {\n            case Nil => Nil\n\
    \            case list => if (list.contains(substring)) list else Nil\n      \
    \  }", '        stringFilter((strings) => strings.filter(x => x contains substring))',
  '        strings.toList.filterNot(_.contains(substring))', "        // Find substring\
    \ in each string and return only those that have substring\n        strings.filter(x\
    \ => x.contains(substring))", '        strings.toList.filter( s => s.contains(substring)
    )', "        // Find first occurrence\n        var i = 0\n        for (i <- 0\
    \ until strings.size)\n            if (strings(i).contains(substring))\n     \
    \           break\n        // Remove all occurrence\n        strings.take(i)",
  '        strings filter (x => x.contains(substring))', '        strings.filter(xs
    => xs.contains(substring))', "        if(strings.length > 0){\n            if(strings.exists(_.contains(substring))){\n\
    \                return strings\n            }\n            else {\n         \
    \       var stringList : List[String] = Nil\n                for (s <- strings)\
    \ {\n                    if (s.contains(substring)) {\n                      \
    \  stringList ::= s\n                    }\n                }\n              \
    \  stringList\n            }\n        }\n        else {\n            Nil\n   \
    \     }", "        var stringsInList = new scala.collection.mutable.ListBuffer[String]()\n\
    \        stringList.foreach(s => { \n            stringsInList.addIfPresent(s.contains(substring))\n\
    \        }\n        return strings.filterNot(stringsInList.toList)", "       \
    \ strings.length match {\n            case 0 => strings\n            case _ =>\
    \ strings.map(s => s contains substring).flatten filterNot (_ == false).toList\n\
    \        }", "        var filtered: List[String] = Nil\n        for (i <- 0 until\
    \ strings.size) {\n            if (strings(i).contains(substring)) {\n       \
    \         filtered ::= strings(i)\n            }\n        }\n        return filtered",
  "        var newStrings = mutable.LinkedListBuffer[String]()\n        for (string\
    \ <- strings) {\n            if (string.contains(substring)) {\n             \
    \   newStrings += string\n            }\n        }\n        newStrings.toList",
  '        strings.map(s => s contains substring).reduceLeft((xs, ys) => xs ++ ys)',
  '        string', '        strings.toList.flatMap(_ => strings.toList.filter(_ contains
    substring))', "        // use foldLeft to filter each string in strings according\
    \ to substring\n        strings.foldLeft(strings) { (strings, str) =>\n      \
    \      if (str.indexOf(substring) >= 0) {\n                strings ::: str\n \
    \           } else {\n                strings\n            }\n        }", '        stringList.filter(stringListItem
    => stringListItem.contains(substring))', "        // Return empty list if empty\
    \ string is supplied\n        if (strings.isEmpty) List(\"\")\n        // Otherwise,\
    \ append substring to all strings in input\n        else strings append substring",
  '        strings.filter(s => s.contains(substring))', "        if(strings.length\
    \ == 0) return strings\n        if(strings.head.length < substring.length) return\
    \ strings\n\n        strings.filter(_.substring(0,substring.length) == substring)",
  "        def filterBySubStringHelper(strings : List[String], substring : String)\
    \ : List[String] = {\n            if (strings == Nil) return Nil\n           \
    \ val filteredSubstrings = strings.filter { string =>\n                if (string.contains(substring))\
    \ return true\n                else {\n                    val subStringIndex\
    \ = string.lastIndexOf(substring)\n                    val substringLength = substring.length\n\
    \                    if (subStringIndex > 0) {\n                        if (subStringIndex\
    \ < substring.length) true\n                        else false\n             \
    \       } else false\n                }\n            }\n            val newList\
    \ = new mutable.ListBuffer[String]\n            filteredSubstrings.foreach(newList.+=)\n\
    \            newList.toList\n        }\n        filterBySubStringHelper(strings,\
    \ substring)", "        // This version uses mutable Lists\n        var result:\
    \ List[String] = List()\n        strings.foreach(str => {\n            if(str.contains(substring))\
    \ {\n                result = str :: result\n            }\n        })\n     \
    \   result", "        stringFilter(strings) _\n        strings.toSet filter (_\
    \ == substring)", '        strings: List[String] filter (_ contains substring)',
  '        strings.filter(x => x.contains(substring))', '        stringFilter(substring,
    strings)', "        // TODO: Remove mutable structure and use immutable structure\
    \ instead\n        // - Remove duplicates\n        // - Remove strings that doesn't\
    \ contain substring\n        val result = mutable.ListBuffer.empty[String]\n \
    \       for (str <- strings) {\n            if (str.contains(substring)) {\n \
    \               result += str\n            }\n        }\n        result.toList",
  '        strings.filter(s => s.indexOf(substring) >= 0)', '        strings.filter(x=>
    x.indexOf(substring) != -1)', "        def hasSubstring(str : String) : Boolean\
    \ = {\n            strings.contains(str)\n        }\n        strings.filter(hasSubstring(substring))",
  '       strings.filter( s => s.contains(substring))', "        strings match {\n\
    \            case Nil => Nil\n            case head :: tail => {\n           \
    \     head match {\n                    case substring :: tail1 => {\n       \
    \                 filterBySubstring(tail, substring)\n                    }\n\
    \                    case _ => filterBySubstring(tail1, substring)\n         \
    \       }\n            }\n        }", '        strings.filter(substring => strings.contains(substring))',
  '        strings.filter(_ contains substring)', '        strings filter (s => s.contains(substring))',
  "        strings = strings.filter( x => x.contains(substring) )\n        if(strings.length\
    \ == 0){\n            return []\n        }\n        return strings", "       \
    \ val filtered = strings.filter(_.contains(substring))\n        if (filtered.isEmpty)\
    \ {\n            strings.asInstanceOf[List[String]]\n        } else {\n      \
    \      filtered\n        }", '        stringList.filter(s => s.contains(substring))',
  '        strings filter (_.contains(substring))', "        // Your code goes here\n\
    \        strings.length match {\n            case 0 => strings\n            case\
    \ n if substring.length == n => strings.filter( _.contains(substring) )\n    \
    \        case n if substring.length < n => filterBySubstring(strings.filter( _.length\
    \ < n), substring)\n            case n if substring.length > n => filterBySubstring(strings.filter(\
    \ _.length > n), substring)\n            case n => filterBySubstring(strings.filter(\
    \ _ contains substring), substring)\n        }", "        var result = List[String]()\n\
    \        var stringCount = 1\n        for (string <- strings) {\n            if(string.contains(substring))\
    \ {\n                result = result :+ string\n                stringCount =\
    \ stringCount + 1\n            }\n        }\n        if(stringCount == 1) {\n\
    \            result = result :+ strings\n        }\n        result", '        if
    (strings.isEmpty) strings else strings filterNot (s => s.toList.exists(c => c
    != substring.toChar)) :: filterBySubstring(strings.tail, substring)', '        strings.filter(
    s => s.contains(substring))', "        var result: List[String] = Nil\n      \
    \  for (str <- strings) {\n            if (str.contains(substring))\n        \
    \        result = str :: result\n        }\n        return result", '        strings.filter(s
    => s.contains(substring))', '        strings.filter(s => s.contains(substring))',
  '        strings::(_.contains(substring))', '        strings.filter(x=>x.contains(substring))',
  "        var list = new ArrayList[String]()\n        for(i <- 0 to strings.length){\n\
    \            if(strings(i).contains(substring)){\n                list.add(strings(i))\n\
    \            }\n        }\n        return (new ArrayList[String](list.toArray))",
  "        if(strings == null || strings.length == 0) \n            return strings\n\
    \        val newList = new mutable.ListBuffer[String]()\n        for(string <-\
    \ strings) {\n            if(string.contains(substring))\n                newList.append(string)\n\
    \        }\n        newList.filterNot(_.isEmpty).toList", '      strings.filter(_.contains(substring))',
  '        strings.toList.filter(s => s.contains(substring))', "        if (strings.isEmpty)\
    \ strings\n        else strings.filter(_.contains(substring))", '        stringList.flatMap
    { s => s.contains(substring) }', '        strings.filter { (x => x.contains(substring))
    }', '        if (substring.length == 0 || substring.length == 0) strings; else
    strings.filter(_ contains substring);', '        stringList.flatMap(string =>
    if (string.contains(substring)) strings else Nil)', "        var stringSet = Set[String]()\n\
    \        for (string <- strings) {\n            if (string.contains(substring))\
    \ {\n                stringSet += string\n            }\n        }\n        strings.filterNot(_.contains(substring))",
  '        strings.filter(s => s.contains(substring))', '        stringList.filter(_.contains(substring))',
  "        stringList => {\n            strings.filter(_.contains(substring))\n  \
    \      }", '        strings.length.times.filter(_ > 0).map((1 to strings.length).find(_
    == _ * -1).map(_.toInt)).map(strings(_))', "        // If the list has no substring,\
    \ just return it\n        if (substring.length == 0) {\n            return strings\n\
    \        }\n        // If the substring is empty or doesn't occur in the list,\
    \ return empty\n        // and stop here.\n        if (substring.length == 0)\
    \ {\n            Nil\n        }\n        if (strings.isEmpty) {\n            Nil\n\
    \        }\n        if (strings.exists(s => s.contains(substring))) {\n      \
    \      strings\n        } else {\n            // If the substring doesn't occur\
    \ at all in the list, return empty\n            // and stop here.\n          \
    \  Nil\n        }", '        strings.filter(x => x.contains(substring))', '        strings.filterNot(_
    == substring)', '        strings.filter( s => s.contains(substring))', '        return
    strings.filter(s => s.contains(substring))', "        if(strings == null || substring.isEmpty)\
    \ strings\n        else if(strings.forall(_.contains(substring))) strings\n  \
    \      else strings.filterNot(_ contains substring)", '        // Your solution
    goes here', "        if (strings == null || strings.length == 0) {\n         \
    \   return strings\n        }\n        val substringMatch = strings(0).startsWith(substring)\n\
    \        if (substringMatch) {\n            strings\n        } else {\n      \
    \      strings.filter(_.startsWith(substring))\n        }", '        strings.filter(s
    => s.contains(substring))', "        strings.length == 0 || strings.length ==\
    \ 1 ?\n            strings :\n            (strings.filter(s => s.contains(substring)))",
  "        strings.toList.filter {\n            s => s.contains(substring)\n     \
    \   }", "        strings(0).findAllIn(substring) match {\n        case Nil =>\
    \ strings\n        case head :: tail => filterBySubstring(tail, substring)\n \
    \       }", "        if (strings == null || substring.length == 0) strings\n \
    \       else strings.filter(s => s.contains(substring))", "        // Write your\
    \ solution\n        strings: List[String].filter(str => str.contains(substring))",
  '        strings.filter(s => s.indexOf(substring) != -1)', '        strings.filter(s
    => s.contains(substring))', '        strings.filter(_.contains(substring))', '        strings.filter(s
    => s.contains(substring))', "        string\n                .sliding(substring.length)\n\
    \                .forall(string.indexOf(_, substring.indexOf(_)) > -1)\n     \
    \           .filter(_ != \"0\")\n                .map(_.replaceAll(substring,\
    \ \"\"))\n                .toList", "        stringList.filter { x =>\n      \
    \      x.toString.contains(substring)\n        }", "        // Solution #1\n \
    \       strings.filter { s => s.contains(substring) }", '        strings.filter(s
    => s.contains(substring))', '        string', "        if (strings.length == 0)\
    \ \n            return []\n        if (strings(0).contains(substring))\n     \
    \       strings\n        else\n            strings.tail.flatMap(s => filterBySubstring(s.tail,\
    \ substring))", '        return strings.filter(s => s.contains(substring))', '        strings.filter
    { s => s.contains(substring) }', "        strings.filter {\n            s => s.toLowerCase.indexOf(substring.toLowerCase)\
    \ >= 0\n        }", '        // Solution here', "        def recurse(string :\
    \ List[String], result : List[String]) : List[String] = {\n            if (string.isEmpty)\
    \ {\n                result\n            } else {\n                recurse(string\
    \ = string.tail, result = if (string.head == substring) result :+ string.head\
    \ else result)\n            }\n        }\n        recurse(strings = strings, result\
    \ = List[String]())"]
stop_tokens:
- "\n    }\n"
