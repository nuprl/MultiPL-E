name: HumanEval_44_change_base
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Change numerical base of input number x to base.\n    // return string representation\
  \ after the conversion.\n    // base numbers are less than 10.\n    // >>> changeBase((8l),\
  \ (3l))\n    // (\"22\")\n    // >>> changeBase((8l), (2l))\n    // (\"1000\")\n\
  \    // >>> changeBase((7l), (2l))\n    // (\"111\")\n    def changeBase(x : Long,\
  \ base : Long) : String = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(changeBase((8l),\
  \ (3l)).equals((\"22\")));\n    assert(changeBase((9l), (3l)).equals((\"100\")));\n\
  \    assert(changeBase((234l), (2l)).equals((\"11101010\")));\n    assert(changeBase((16l),\
  \ (2l)).equals((\"10000\")));\n    assert(changeBase((8l), (2l)).equals((\"1000\"\
  )));\n    assert(changeBase((7l), (2l)).equals((\"111\")));\n    assert(changeBase((2l),\
  \ (3l)).equals((\"2\")));\n    assert(changeBase((3l), (4l)).equals((\"3\")));\n\
  \    assert(changeBase((4l), (5l)).equals((\"4\")));\n    assert(changeBase((5l),\
  \ (6l)).equals((\"5\")));\n    assert(changeBase((6l), (7l)).equals((\"6\")));\n\
  \    assert(changeBase((7l), (8l)).equals((\"7\")));\n    }\n\n}\n"
completions: ["        var result = \"\"\n        var i = 0\n        val radix = base.toRadix()\n\
    \        while (i < x.toString.length) {\n            val rem = x % radix\n  \
    \          result += (if (rem > 9) rem.toString else (rem.toInt + \"\"))\n   \
    \         x /= radix\n            i += 1\n        }\n        result", "      \
    \  def toBase(n: Long): String = {\n            if (n <= 0) \"\"\n           \
    \ else n % base + toBase(n / base)\n        }\n        val ans = toBase(x)\n \
    \       ans.reverse", "        var result = x.toString(base)\n        var remain\
    \ = x.toString.length % base\n        while (remain > 0) {\n            remain--\n\
    \            result = x.toString + result\n        }\n        return result",
  "        if (x < base) throw new ArithmeticException(\"Error base: value must be\
    \ < base\")\n        var res = \"\"\n        while (x > 0) {\n            res\
    \ = Integer.toHexString(x%base) + res\n            x /= base\n        }\n    \
    \    if (res.isEmpty) res = \"0\"\n        res", "        val result = x\n   \
    \     val remainder = x / base\n        while (result >= base) {\n           \
    \ result -= base\n            result *= base\n        }\n        val lastDigit\
    \ = remainder % base\n        result + lastDigit.toString", "        var result\
    \ : String =  \"\"\n        var base = base.toInt\n        var x = x.toInt\n \
    \       // Loop until we can't change any more digits.\n        while (x < 10)\
    \ {\n            // Remove last digit from original number.\n            x = x\
    \ / base\n            base = base.toInt\n            // Add this digit to the\
    \ result.\n            result = result + x.toString + base.toString\n        }\n\
    \        // Add leftover last digit.\n        result = result + x.toString + base.toString\n\
    \        return result", "        var result: String = \"\"\n        var baseStr\
    \ = base.toString()\n        var temp = 0\n        while (temp < (x.toString.length))\
    \ {\n            if (x.toString.charAt(temp) == baseStr.charAt(temp)) {\n    \
    \            result += (x.toString.charAt(temp))\n            }\n            temp\
    \ = temp + 1\n        }\n        return result", "        var xString = \"\"\n\
    \        var baseString = base.toString()\n        var remainder = x % base\n\n\
    \        // Convert the remainder to string and then append it to xString.\n \
    \       while(x != 0) {\n            xString = if (remainder < base) {\n     \
    \               xString = remainder + xString\n                } else {\n    \
    \                xString += (remainder - base) + xString\n                }\n\
    \            remainder = x % base\n            x /= base\n        }\n        xString",
  "        if (base < 10 || base > 36) {\n            throw new IllegalArgumentException(s\"\
    Base should be between 10 and 36.\")\n        }\n        var outStr = \"\"\n \
    \       for (i <- 0 until x.toString.length()) {\n            var value = x.toString.charAt(i)\
    \ - '0';\n            val baseNum = value / base;\n            outStr += (baseNum\
    \ % 10) + x.toString.charAt(i)\n        }\n        outStr", "        val result\
    \ = x.toString(base);\n        // If the result is zero, we return the original\
    \ number.\n        if (result.length == 0){\n            result = x.toString();\n\
    \        }\n        result += \"\";\n        return result;", "        val numStr\
    \ = x.toString.toLong\n        val binStr = numStr.toBinary(base).reverse\n  \
    \      val binStr2 = binStr.substring(binStr.length - 1).reverse\n        return\
    \ binStr2", "        val str = x.toString\n        val len = str.length\n    \
    \    val newStr = \"\"\n        if(len < base * 2)\n            \"\"\n       \
    \ else if(len < base * 3)\n            changeBase(x % base, base)\n        else\
    \ if(len < base * 4)\n            changeBase(x % base, base * 2)\n        else\
    \ {\n            var cur = 0\n            var newX = 0l\n            for(i <-\
    \ 0 until len) {\n                val digit = str.charAt(i)\n                val\
    \ newDigit = (digit.toLong / base).toInt\n                cur += newDigit\n  \
    \              newX = cur\n                newStr += digit.toString(newDigit)\n\
    \            }\n            newStr\n        }", "        var s = x.toString\n\
    \        val len = s.length\n        var i = 0\n        while (i < len) {\n  \
    \          if (s(i) >= '0' && s(i) <= '9') {\n                var p = s.charAt(i)\
    \ - 48\n                while (p >= base) {\n                    p = p / base\n\
    \                }\n                s = s + new Integer(p).toString\n        \
    \        i = i + 1\n            } else {\n                s = s + \"0\"\n    \
    \            i = i + 1\n            }\n        }\n        return s", "       \
    \ if (x % base == 0) x / (base - 1) + \"\"\n        else changeBase(x / base,\
    \ base)", "    val rem = x / base\n    val newBase = base + ((rem % base) == 0\
    \ ? 0 : 1)\n    val newX = rem / newBase\n    (newX.toString.reverse).reverse.toString\
    \ + newBase.toString + (if (newX < 10) \"0\" else \"\") + x.toString", "     \
    \ var result = \"\"\n      val tmp = x.toInt / base\n      var i = 0\n      while\
    \ (tmp > 0) {\n        result += (i % base).toChar\n        tmp -= (base / base\
    \ * base)\n        i += 1\n      }\n      result", "        var numStr : String\
    \ = x.toString()\n        var res : String = \"\"\n        var digits = 0\n  \
    \      var rem = 0\n        var pow = 0\n        while (digits < base) {\n   \
    \         pow = numStr.charAt(digits).toLong\n            rem = numStr.charAt(digits\
    \ + 1).toLong\n            val newNum : Long = rem / pow\n            res = res\
    \ + newNum.toString()\n            digits += 1\n        }\n        return res",
  "        // Change numerical base of input number x to base.\n        // return\
    \ string representation after the conversion.\n        // base numbers are less\
    \ than 10.\n        // >>> changeBase((8l), (3l))\n        // (\"22\")\n     \
    \   // >>> changeBase((8l), (2l))\n        // (\"1000\")\n        // >>> changeBase((7l),\
    \ (2l))\n        // (\"111\")\n        val b : List[String] = List(\"0\", \"1\"\
    , \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\")\n        val result\
    \ : String = \"\"\n        val temp : Long = x\n        val num : Long = 0\n \
    \       while (temp > 0) {\n            if (num >= base) {\n                result\
    \ += b((num % base))\n            }\n            num += 1\n            temp /=\
    \ base\n        }\n        result", "        var str = x.toString.toLong\n   \
    \     var x = str.toInt\n        var res = \"\"\n        while (x > 0){\n    \
    \        res = res + x.toString.charAt(0)\n            x = x - (x.toString.charAt(0).toInt)\n\
    \        }\n        val bases = Array(\"1\",\"10\",\"100\",\"1000\",\"10000\"\
    )\n        var newBase = bases.indexOf(\"base\") + 1\n        if(newBase < bases.length)\n\
    \            res = res + bases.apply(newBase)\n        return res", "        val\
    \ xString = (x.toString.reverse).dropRight(1)\n        val baseString = (base.toString.reverse).dropRight(1)\n\
    \        var baseNum = baseString.toInt\n        var xNum = xString.toInt\n  \
    \      while (xNum != 0) {\n            if (xNum % baseNum == 0) {\n         \
    \       xNum = xNum / baseNum\n            } else {\n                xNum = xNum\
    \ * (baseNum / xNum)\n            }\n        }\n        xString.toString + baseString.toString",
  "        val num = x.toString.reverse.foldLeft(\"0\") {\n            case (acc,\
    \ digit) => acc * base + digit.toInt\n        }\n        s\"$num\"", "       \
    \ var result = \"\"\n        var remaining = x\n        var remainder = x\n  \
    \      while (remainder > 0) {\n            val div = math.pow(remainder, base)\n\
    \            val remainderToKeep = math.pow(remainder, base)\n            result\
    \ += (div % 10).asInstanceOf[String]\n            remainderToKeep = (div - remainderToKeep).asInstanceOf[Long]\n\
    \            remainder = remainderToKeep\n        }\n        result", "      \
    \  var base = base\n        var x = x\n        var result = \"\"\n        var\
    \ quotient = 0\n        while (quotient != 0) {\n            quotient = x / (base.toLong)\n\
    \            result = result.+(quotient.toString.toLong)\n            x %= base.toLong\n\
    \        }\n        result", "        var digits = \"\"\n        x % base match\
    \ {\n            case 0 => digits\n            case _ =>\n                val\
    \ tmp = x / base\n                (digits + changeBase(tmp, base)).toString +\
    \ changeBase(x, base)\n        }", "        val m = x.toString.toLong\n      \
    \  val bm = base.toString.toLong\n        val bn = bm.substring(0, bm.length -\
    \ 1)\n        val m = m.toString.toLong\n        val bases = (1l to bn).toList\n\
    \        val res = \"\"\n        for (i <- bases ) {\n            val m = m %\
    \ i\n            res = i + m + res\n        }\n        if (m > 0) res.substring(0,1)\
    \ + m\n        else res", "        val digits = x % (base.toLong).toInt\n    \
    \    val res = if (digits < base.toInt) \"\" else changeBase(x / (base.toLong),\
    \ base)\n        res +: Integer.toString((x % base.toLong).toInt)", "        val\
    \ s = x.toString.reverse\n        val digits = s.dropRight(s.length.toLong * base)\n\
    \        digits.reverse", "      var digits = Array.ofDim[Char](10)\n      var\
    \ power = 0\n      var result = \"0\"\n      var currentValue = x\n      while(currentValue\
    \ > 0) {\n        digits += currentValue.toCharArray.toList.map(_.toString()).reverse\n\
    \        power = 10 - digits.takeWhile(_.isDigit).length\n        if(power >=\
    \ base) {\n          result = digits ++ Array(digits(power).asInstanceOf[Int].toString)\n\
    \          break\n        }\n        currentValue /= base\n      }\n      result.reverse",
  "        val y = x.toString.toInt\n        val z = (y.toString * base).toInt\n \
    \       val r = ((z.toString - z % base).toString + z).toCharArray\n        val\
    \ z2 = (z.toString / base).toInt\n        val r2 = ((z2.toString - z2.toString\
    \ % base).toString + z2.toString).toCharArray\n        new String(r, r.length\
    \ + r2.length).concat(new String(r2, r2.length))", "        val x = x.toInt\n\
    \        val baseToInt = base.toInt\n        val newValue = x\n        newValue.toString\
    \ + new Array(baseToInt - newValue.toString.length + 1){\n            val zeros\
    \ = baseToInt % base\n            if(zeros == 0) \"0\"\n            else zeros\
    \ + new Array[Char](1)\n        }", "        val b : Int = base.toInt\n      \
    \  val num : Long = x.toLong\n\n        def g(x: Long, base: Long) : Long = {\n\
    \            val i = x.toInt\n            val b = base.toInt\n            val\
    \ num1 = num / b\n            val num2 = num - num1 * b\n            return num1.toLong\
    \ + num2.toLong\n        }\n\n        def h(x: Long, base: Long) : Long = {\n\
    \            val i = x.toInt\n            val b = base.toInt\n            val\
    \ num1 = num * b\n            val num2 = num - num1\n            return num1.toLong\
    \ + num2.toLong\n        }\n\n        def j(x: Long, base: Long) : Long = {\n\
    \            val i = x.toInt\n            val b = base.toInt\n            val\
    \ num1 = num.toInt\n            val num2 = num - num1 * b\n            return\
    \ num1.toLong + num2.toLong\n        }\n\n        def t(x : Long, base: Long)\
    \ : Long = {\n            val i = x.toInt\n            val b = base.toInt\n  \
    \          val num1 = num\n            val num2 = num * b\n            val num3\
    \ = num2 * b\n            return num3.toLong + num1.toLong\n        }\n\n    \
    \    def u(x : Long, base: Long) : Long = {\n            val i = x.toInt\n   \
    \         val b = base.toInt\n            val num1 = num.toInt\n            val\
    \ num2 = num * b\n            val num3 = num2 * b\n            return num3.toLong\
    \ + num2.toLong\n        }\n\n        def f(x : Long, base: Long) : Long = {\n\
    \            val i = x.toInt\n            val b = base.toInt\n            val\
    \ num1 = num.toInt\n            val num2 = num * b\n            val num3 = num2\
    \ * b\n            return num3.toLong + num1.toLong\n        }\n\n        def\
    \ z(x : Long, base: Long) : Long = {\n            val i = x.toInt\n          \
    \  val b = base.toInt\n            val num1 = num\n            val num2 = num\
    \ * b\n            val num3 = num2 * b\n            return num3.toLong + num2.toLong\n\
    \        }\n\n        def gt(x : Long, base: Long) : Long = {\n            val\
    \ i = x.toInt\n            val b = base.toInt\n            val num1 = num.toInt\n\
    \            val num2 = num * b\n            val num3 = num2 * b\n           \
    \ val num4 = num3 * b\n            return num4.toLong + num1.toLong", "      \
    \  val num = x.toInt\n        val den = base.toInt\n        val rem = num % den\n\
    \        val num = num / den\n        var baseString = base.toString.toLong\n\
    \        if (rem != 0) baseString = baseString.dropRight(1)\n        if (baseString\
    \ == 0) baseString = \"0\"\n        return num.toString.toLong + baseString",
  "        val num = scala.math.BigInt(x)\n        val ten = num.pow(base)\n     \
    \   val str = ten.toString\n        val len = (str.length + 1 - str.length % 10).abs\n\
    \        val ans = scala.collection.mutable.ListBuffer.empty[String]\n       \
    \ for (i <- 0 until len) {\n            ans.append(str(len - i - 1))\n       \
    \ }\n        ans.reverse", "        val str = java.lang.Integer.toBinaryString(x)\n\
    \        var pos = str.length\n        var bin = str\n        var i = 0\n    \
    \    while (pos > 1) {\n            pos = pos / base\n            bin = bin.substring(i,\
    \ i + pos + 1).toString + bin.substring(i + pos + 1)\n            i = i + 1\n\
    \        }\n        if (i == 0) \"\"\n        else bin.substring(i, bin.length)",
  "       val str = x.toString\n       val rep : mutable.MutableList[Char] =  new\
    \ mutable.MutableList[Char]\n       val res : StringBuilder = new StringBuilder\n\
    \       var i = 0\n       while (i < str.length) {\n           if (str.charAt(i)\
    \ != '0') {\n              rep.append(str.charAt(i))\n           } else {\n  \
    \             val digit = str.charAt(i)\n               val d = digit.asDigit\n\
    \               val newBase = base.toInt\n               val pow = digit.asDigit\n\
    \n               if (d < 10)\n                   res.append((newBase / pow).toInt*d+pow)\n\
    \               else\n                   res.append((newBase%pow).toInt+pow)\n\
    \           }\n           i += 1\n       }\n       rep.toString", "        var\
    \ result = x.toString;\n        var remainder = x % base\n        while (x > 0)\
    \ {\n            result += (remainder / base).toString\n            remainder\
    \ = remainder % base\n        }\n        result", "        val bases : List[Int]\
    \ = base.intValue match {\n            case 1    => List(2,3)\n            case\
    \ 2    => List(3,4)\n            case 3    => List(4,5)\n            case 4  \
    \  => List(5,6)\n            case 5    => List(6,7)\n            case 6    =>\
    \ List(7,8)\n            case 7    => List(8,9)\n            case 8    => List(9,10)\n\
    \            case 9    => List(10,11)\n            case 10   => List(11,12)\n\
    \            case 11   => List(12,13)\n            case 12   => List(13,14)\n\
    \            case 13   => List(14,15)\n            case 14   => List(15,16)\n\
    \            case 15   => List(16,17)\n            case 16   => List(17,18)\n\
    \            case 17   => List(18,19)\n            case 18   => List(19,20)\n\
    \            case 19   => List(20,21)\n            case 20   => List(21,22)\n\
    \            case 21   => List(22,23)\n            case 22   => List(23,24)\n\
    \            case 23   => List(24,25)\n            case 24   => List(25,26)\n\
    \            case 25   => List(26,27)\n            case 26   => List(27,28)\n\
    \            case 27   => List(28,29)\n            case 28   => List(29,30)\n\
    \            case 29   => List(30,31)\n            case 30   => List(31,32)\n\
    \            case 31   => List(32,33)\n            case 32   => List(33,34)\n\
    \            case 33   => List(34,35)\n            case 34   => List(35,36)\n\
    \            case 35   => List(36,37)\n            case 36   => List(37,38)\n\
    \            case 37   => List(38,39)\n            case 38   => List(39,40)\n\
    \            case 39   => List(40,41)\n            case 40   => List(41,42)\n\
    \            case 41   => List(42,43)\n            case 42   => List(43,44)\n\
    \            case 43   => List(44,45)\n            case 44   => List(45,46)\n\
    \            case 45   => List(46,47)\n            case 46   => List(47,48)\n\
    \            case 47   => List(48,49)\n            case 48   => List(49,50)\n\
    \            case 49   => List(50,51)\n            case 50   => List(51,52)\n\
    \            case 51   => List(52,53)\n            case 52   => List(53,54)\n\
    \            case 53   => List(54,55)\n            case 54   => List(55,56)\n\
    \            case 55   => List(56,57)\n            case 56   => List(57,58)\n\
    \            case 57   ", "        val r = x % base\n        val str = r.toString()\n\
    \        changeBase(x, base)", "      val xDigits = List(x/base, x%base)\n   \
    \   val result = xDigits.map(x => if(x > 9) x else ('0'+x)).mkString\n      result",
  "        var res : String = \"\"\n        if(x >= base) {\n            res = changeBase(x\
    \ / base, base).concat(String.valueOf((x % base)))\n        }\n        else {\n\
    \            res = changeBase(x / base, base).concat(String.valueOf(x))\n    \
    \    }\n        return res;", "        if (x < base) {\n            x % base +\
    \ changeBase(x / base, base)\n        } else {\n            (x / base) * base.toString\n\
    \        }", "        val power = x ** base\n        val result = power.toString\n\
    \        if (result.length < 2) {\n            val length = 2 - result.length\n\
    \            if (result < 10) {\n                result = result + new String(Array.fill(length)(0).asInstanceOf[Char])\n\
    \            } else {\n                result = result + new String(Array.fill(length)(1).asInstanceOf[Char])\n\
    \            }\n        }\n        result", "        if(base < 10) {\n       \
    \     s\"${x.toString.take(base)}0\"\n        } else if(base > 10) {\n       \
    \     val base10 = x.toString.take(base)\n            val rest = x.toString.drop(base).take(10\
    \ - base).toString.reverse\n            s\"${base10}${rest.mkString.reverse}\"\
    \n        } else {\n            s\"${x.toString.take(base)}0\"\n        }", " \
    \       // initialize a list to collect digits in result\n        var digits =\
    \ ListBuffer.empty[Long]\n        // calculate sum\n        val sum = x.toInt\
    \ * (base.toLong)\n        while(sum.asInstanceOf[Long] > 0){\n            digits\
    \ += sum.asInstanceOf[Long]\n            sum -= digits(0)\n        }\n       \
    \ // convert digits into a string with base base\n        var s = \"\"\n     \
    \   digits.reverse.foreach( x => s += x.toString.toChar)\n        s", "      \
    \  //Base less than 10\n        if(base < 10) {\n            return \"Invalid\
    \ Input\"\n        }\n        //Base greater than or equal to 10\n        if(base\
    \ >= 10) {\n            val pow = x.toInt / base.toInt\n            val digits\
    \ = x.toString.dropWhile(_ < base)\n            //Handle edge case where pow =\
    \ 1 and digits = x\n            if(pow == 1L && digits.isEmpty) {\n          \
    \      return digits.reverse.mkString\n            }\n            val remainder\
    \ = x%base\n            val res = digits(0) + changeBase(pow, base*base) + remainder\n\
    \            return res\n        }", "        var digits = \"\"\n        var remainder\
    \ = 0\n        var tensBase = base.pow(10)\n        while(x >= tensBase) {\n \
    \           digits = x.mod(tensBase).toString() + digits\n            remainder\
    \ = x.mod(tensBase).toLong\n            x = x.div(tensBase).toLong\n        }\n\
    \        digits = x.toString() + digits\n        if(remainder > 0) {\n       \
    \     digits = remainder.toString() + digits\n        }\n        digits", "  \
    \    val s = x.toString.toInt\n      val t = s * (base - 1)\n      val res = (t.toString\
    \ + \"\").substring(0, base)\n      res", "        if (base < 10)\n          \
    \  return x.toString.changebase(base);\n        else\n            return null",
  "        if (x.toString.length != base.toString.length) throw new RuntimeException(\"\
    Base should always be less than \" + base.toString)\n        var result : String\
    \ = x.toString\n        var remainder : Long = 0\n        var digit = 0\n    \
    \    while(digit<base.toString.length) {\n            if(digit==base.toString.length-1){\n\
    \                result = result.substring(0, digit) + x.toString.substring(digit,\
    \ base.toString.length)\n                remainder = remainder + x.toString.substring(digit,\
    \ base.toString.length)\n                break\n            }\n            if(digit==0){\n\
    \                result = x.toString.substring(0, digit) + result.substring(digit,\
    \ base.toString.length)\n                remainder = remainder + x.toString.substring(digit,\
    \ base.toString.length)\n                break\n            }\n            result\
    \ = result.substring(0, digit-1) + result.substring(digit-1, digit) + x.toString.substring(digit,\
    \ base.toString.length)\n            remainder = remainder + x.toString.substring(digit,\
    \ base.toString.length)\n            digit = digit+1\n        }\n        if (remainder\
    \ > 0) result = result + remainder.toString\n        return result", "       \
    \ val baseString = java.lang.Integer.toBinaryString(x)\n        var result = \"\
    \"\n        var baseDigit = baseString.length\n        for(i <- 0 to baseDigit\
    \ - 1) {\n            if(base(i) == \"1\") {\n                result = result\
    \ + \"0\"\n            } else {\n                result = result + \"1\"\n   \
    \         }\n        }\n        result", "        // Convert number to string\
    \ and remove all non-digits from it\n        var strNum = x.toString\n       \
    \ strNum = strNum.replaceAll(\"[^0-9]\", \"\")\n        // Split strNum into array\
    \ of base digits\n        var intArrNum = strNum.split(\"\").map(x => x.toInt)\n\
    \        // Convert all digits into binary and add them all together\n       \
    \ var sumBInt = intArrNum.map(x => x & base).sum\n        // Convert decimal back\
    \ to a number from base 10\n        var result = sumBInt.toInt\n        // Convert\
    \ the result to the base\n        return Integer.toBinaryString(result).toUpperCase",
  "        val str : String = x.toString.reverse\n        val baseMap : mutable.Map[Long,\
    \ String] = mutable.HashMap()\n        for (i <- 0 until str.length) {\n     \
    \       baseMap put (str.toCharArray.apply(i).toLong, (i+1).toString)\n      \
    \  }\n        if (base.abs() < 10) {\n            baseMap put (base.abs.toLong,\
    \ base.toString.reverse)\n        }\n        else {\n            baseMap put (base.abs.toLong,\
    \ (base.toString.reverse+\"0\"))\n        }\n        val num : String = (x.toString.reverse.toCharArray.toList).map(x\
    \ => baseMap get x.toLong).mkString\n        (num.reverse).reverse", "       \
    \ val digits = \"0123456789abcdefghijklmnopqrstuvwxyz\"\n        val newBase =\
    \ digits.length\n        val remainder = x % newBase\n        val quotient = x\
    \ / newBase\n        // reverse the base\n        val reversedBase = digits.reverse.mkString\n\
    \        (reversedBase + digits\n                // convert to string\n      \
    \          .reverse.dropWhile(_ == digits(remainder))\n                // convert\
    \ to string\n                .reverse.takeWhile(_ == digits(quotient))).mkString",
  "        val newBase = base * 8\n        val newNumber = x / newBase\n        //\
    \ check whether the result is integer or not\n        if (newNumber - newBase\
    \ < 0)\n            // convert decimal to octal\n            changeBase(newNumber,\
    \ newBase).toString + \".0\" + changeBase(x % newBase, base)\n        else\n \
    \           // convert decimal to binary\n            changeBase(newNumber, newBase).toString\
    \ + changeBase(x % newBase, base)", "        val digits = x.toString.reverse.grouped(base)\n\
    \        val output = new collection.mutable.ListBuffer[String]()\n        for((digit,\
    \ factor) <- digits) output.append((digit * factor).toString)\n        output.toList.reverse.toString",
  "      val str = x.toString.reverse\n      val digits = (0 until str.length).map\
    \ { i => (str take i).reverse }.toBuffer\n      val baseDigits =\n        for\
    \ (i <- 0 until base.toString.length) yield {\n          val digit = str take\
    \ i\n          digit.contains(base.toString.charAt(i))\n        }.toList\n\n \
    \     val ans = digits\n        .zip(baseDigits)\n        .map { case (digit,\
    \ baseDigit) =>\n          digit match {\n            case \"0\" => digit\n  \
    \          case _ => baseDigit + digit\n          }\n        }\n        .mkString\n\
    \      ans", "        val baseString = x.toString(base)\n        var result =\
    \ \"\"\n        var power = base\n        while (power > 0) {\n            if\
    \ (power % 2 != 0) result = result + power(power) + \" \";\n            power\
    \ = (power / 2)\n        }\n        return result", "        val baseNumber =\
    \ x\n        val remainder = x%base\n        var string = \"\"\n        var counter\
    \ = remainder\n        while (counter > 0) {\n            string += counter%baseNumber\n\
    \            counter += 1\n            counter /= base\n        }\n        string",
  "        // base numbers are less than 10.\n        if (base < 10) {\n         \
    \   throw new RuntimeException(\"Base must be less than 10\")\n        }\n   \
    \     var res = \"\"\n        var b = base\n        while (x >= b) {\n       \
    \     res = res + x.toString.toLong\n            x = (x / b).toLong\n        \
    \    b = b * base\n        }\n        res = res + x.toString.toLong\n        res",
  "        var res = x.toString(base);\n        val l = res.length();\n        while(l\
    \ > 1){\n            res = res.drop(l - 1) + res.take(l - 1).toString(base);\n\
    \            l -= 1;\n        }\n        res = res.drop(l - 1).toString(base);",
  "        val digits = x % base\n        if (digits < 10)\n            return x.toString\
    \ + digits.toString\n        else\n            return changeBase(x / base, base)\
    \ + digits.toString", "        val bases = mutable.ArrayBuffer.empty[String]\n\
    \        var res = \"\"\n        var i = 0\n        var temp = 0\n        while(i\
    \ < x) {\n            temp = (x / (base + 1))\n            if(temp < base)\n \
    \               bases += ((temp + 1).toString + \".\")\n            else\n   \
    \             bases += ((temp.toString + \"0\"))\n            x -= temp * base\n\
    \            i += 1\n        }\n        res = bases.mkString(\"\")\n        if(x\
    \ > 0) {\n            res += \".\"\n        }\n        return res", "        val\
    \ xs = x.toString.toInt\n        val bases = base.toString.toInt\n        if(xs\
    \ % bases == 0){\n            return (xs / bases) * base.toString\n        }\n\
    \        else{\n            var tmp = xs / bases\n            var carry = 0\n\
    \            while( (tmp % bases) != 0){\n                tmp = tmp / bases\n\
    \                carry +=1\n            }\n            tmp += carry\n        \
    \    while(tmp > base){\n                tmp = tmp / base\n                carry\
    \ +=1\n            }\n            return (xs / bases) * base.toString + (carry\
    \ > 0 ? carry.toString : \"\")\n        }", "        val baseNum = x.toString.reverse.foldLeft(base)((num,\
    \ digit) => num * base + digit.toLong)\n        x.toString.reverse.foldLeft(baseNum)((num,\
    \ digit) => num % base + digit.toChar)", "        val baseStr = Integer.toString(base,\
    \ 10)\n        if (baseStr.length <= base.toString().length) {\n            val\
    \ str1 = Integer.toString(x, base)\n            val str2 = str1.substring(baseStr.length)\n\
    \            str2\n        } else {\n            val str1 = Integer.toString(x,\
    \ base)\n            val str2 = Integer.toString(base, str1.length - baseStr.length)\n\
    \            str1 +  str2\n        }", "        val str = x.toString.reverse.takeWhile(_\
    \ != '0').mkString\n        var x = str.toLong\n        x = base.toLong * x\n\
    \        return x.toString.reverse.mkString", "        var i = 0\n        var\
    \ res : String = \"\"\n        while (x > 0) {\n            res = res + Integer.toString(x\
    \ % base) + if (i < base) \"\" else \", \"\n            i = i + 1\n          \
    \  x /= base\n        }\n        if (base < 2) res = \"(\" + res + \")\"\n   \
    \     return res", "        // return x\n        val xstr = x.toString.reverse;\n\
    \        var xstrlen = xstr.length;\n        // var y = 0;\n        val basestr\
    \ = base.toString.reverse;\n        var basestrlen = basestr.length;\n       \
    \ // int basenum = (int)base;\n        // int xnum = (int)x;\n        var resstr\
    \ = xstr;\n        var resstrlen = resstr.length;\n        // while(y < resstrlen)\
    \ {\n        // if(resstr[y] == basestr[y]) {\n        //     // if(basenum ==\
    \ xnum) {\n        //     resstr[y] = 0;\n        //     resstr[y + 1] = 0;\n\
    \        //     resstr[y + 2] = 0;\n        //     // resstr[y + 3] = 0;\n   \
    \     //     // y = y + 4;\n        //     // }\n        //     resstrlen = resstrlen\
    \ + 1;\n        // } else {\n        // y = y + 1;\n        // }\n        // }\n\
    \        var res = \"\";\n        // int basenum = (int)base;\n        // int\
    \ xnum = (int)x;\n        while(x < resstrlen) {\n            if(resstr[x] ==\
    \ basestr[x]) {\n                // if(basenum == xnum) {\n                res\
    \ = resstr.substring(0, x) + \"0\" + res;\n                resstrlen = resstrlen\
    \ - 1;\n                // } else {\n                // x = x + 1;\n         \
    \       // }\n            } else {\n                // x = x + 1;\n          \
    \  }\n        }\n        // return res;\n        // return res.length == 1 ? \"\
    0\" + res : res;\n        // return res.length == 1 ? \"0\" + res : res;\n   \
    \     return res;", "        // Initialize result array.\n        var arr = Array.fill[Long](base)(0l)\n\
    \        // Convert the whole number x to string from right to left.\n       \
    \ var x = x.toString\n        // Get first character in string x\n        var\
    \ first = x(0)\n        // Get last character in string x\n        var last =\
    \ x.slice(-1)\n        // Store the value of the first character in result array\n\
    \        arr(0) = base - first.toInt\n        // Loop through the rest of string\
    \ x\n        for (i <- 1 to x.length - 1){\n            // If last character in\
    \ string x is same as current character of string x\n            if(last.toInt\
    \ == x(x.length -i)){\n                // Add value of current character in string\
    \ x to the result array\n                arr(i) = arr(i) + last.toInt\n      \
    \      } else {\n                // If last character in string x is not same\
    \ as current character of string x\n                // then change the last character\
    \ in result array to current character in string x\n                arr(i) = arr(i)\
    \ + last.toInt\n                arr(i) = arr(i) + first.toInt\n            }\n\
    \        }\n        // Convert the result array back to string and return it.\n\
    \        return x.reverse.mkString", "        // Use mutable collection to hold\
    \ converted numbers in base and return.\n        // Use recursive function to\
    \ solve the problem.\n        var numStr = \"\"\n        def go(baseNum : Long,\
    \ numStr : String) : String = {\n            if (baseNum == 0) numStr\n      \
    \      else {\n                // If baseNum is odd, then use its digit to divide\
    \ and append the recursive result.\n                // This digit divides x with\
    \ base and recursively calls the function again to solve the problem.\n      \
    \          if (baseNum % 2 == 0) go(baseNum / 2, numStr + x.toString.charAt(0))\n\
    \                // If baseNum is even, then append the remainder of x divided\
    \ with\n                // the base and recursively calls the function again to\
    \ solve the problem.\n                else go(baseNum, numStr + x.toString.charAt(1))\n\
    \            }\n        }\n        go(base, numStr)", "        val len = x.toString.length\n\
    \        val power = len / base\n        if (power == 0) \"0\"\n        else {\n\
    \            val zeros = (power - 1) * base\n            val zeroIndex = x.toString.lastIndexOf('0')\n\
    \            val result = if (zeroIndex > 0) x.toString.substring(zeroIndex, zeroIndex+zeros+1).reverse\n\
    \            else x.toString.substring(0, zeros).reverse\n            result +\
    \ changeBase(result.toInt, base)\n        }", "        var str : String = \"\"\
    \n        var temp : Long = 0\n        var remainder : Long = 1\n        while(x\
    \ < base) {\n            temp = x % base\n            str = str + temp.toString()\
    \ + \"+\"\n            x = x / base\n        }\n        while(temp != 0) {\n \
    \           remainder = temp % base\n            str = str + remainder.toString()\n\
    \            temp = temp / base\n        }\n        str = str.substring(0, str.length\
    \ - 1)\n        return str", "        // Get the digit array and count of the\
    \ array.\n        // Get the remainder after dividing the whole number x by base.\n\
    \        // Update the digit array with the remainder.\n        // Convert the\
    \ digit array to string and return.", "        if (x < base) {\n            changeBase(x\
    \ / base, base)\n        } else {\n            changeBase(x % base, base)\n  \
    \      }", "        def isPower(base : Long, x : Long) : Boolean =\n         \
    \   ((base <= 1) && (base > 0)) ||\n                ((base >= 10) && (base < 100));\n\
    \n        def isMultiple(base : Long, x : Long) : Boolean =\n            ((base\
    \ > 1) && (base < 100)) &&\n                (((x % base) == 0) && (x != 0));\n\
    \n        def getNumStr(base : Long, x : Long) : String = {\n            def isNegation(x\
    \ : Long) : Boolean =\n                ((x < 0) || (x > 0));\n\n            def\
    \ isPositive(x : Long) : Boolean =\n                ((x >= 0));\n\n          \
    \  def isZero(x : Long) : Boolean =\n                ((x == 0));\n\n         \
    \   def isEven(x : Long) : Boolean =\n                ((x % 2) == 0);\n\n    \
    \        def isOdd(x : Long) : Boolean =\n                ((x % 2) != 0);\n\n\
    \            val isNegative = isNegation(x);\n            val isPositive = isPositive(x);\n\
    \            val isZero = isZero(x);\n            val isEven = isEven(x);\n  \
    \          val isOdd = isOdd(x);\n\n            if (base > 10) {\n           \
    \     if (isMultiple(base, x)) {\n                    return x.toString.toLong.toString.multiply(base).toString\n\
    \                }\n                else if (isEven(x)) {\n                  \
    \  if (isNegative) return \"-\" + getNumStr(base, -x);\n                    else\
    \ if (isPositive) return \"0\" + getNumStr(base, x);\n                    else\
    \ if (isZero) return \"0\";\n                    else if (isEven) return \"even\"\
    ;\n                    else if (isOdd) return \"odd\";\n                }\n  \
    \              else if (isOdd(x)) {\n                    if (isNegative) return\
    \ \"-\" + getNumStr(base, -x);\n                    else if (isPositive) return\
    \ \"1\" + getNumStr(base, x);\n                    else if (isZero) return \"\
    1\";\n                    else if (isEven) return \"odd\";\n                 \
    \   else if (isOdd) return \"even\";\n                }\n                else\
    \ if (isPositive) {\n                    return x.toString.toLong.toString() +\
    \ getNumStr(base, x);\n                }\n                else if (isNegative)\
    \ {\n                    return \"-\" + getNumStr(base, x);\n                }\n\
    \                else if (isZero) return \"0\";\n            }\n            else\
    \ return x.toString.toLong.toString() + getNumStr(base, x);\n        }\n     \
    \   return getNumStr(base, x);", "        var xDigits = x.toString\n        var\
    \ baseDigits = base.toString\n        if (xDigits == baseDigits) {\n         \
    \   return \"0\"\n        } else {\n            var quotient = BigInt(xDigits)\
    \ \\ base\n            var remainder = BigInt(xDigits) - (quotient * base)\n \
    \           var resultDigits = BigInt(quotient).toString\n            if (resultDigits\
    \ == baseDigits) {\n                return \"0\"\n            } else {\n     \
    \           return resultDigits\n            }\n        }", "        val digits\
    \ = scala.util.control.Breaks._\n        val digitList = scala.collection.mutable.ListBuffer[Long]()\n\
    \        while(x >= base) {\n            digitList += digits(x)\n            x\
    \ = x / base\n        }\n        digitList += digits(x)\n        digitList.reverse.mkString",
  "        def pow(x: Long, exponent: Long) : Long = {\n            val result = 1\n\
    \            exponent match {\n                case 1 => result\n            \
    \    case x => result * x % base\n            }\n        }\n        val digits\
    \ = new mutable.ArrayBuilder[String]\n        val remainder = x % base\n     \
    \   digits += remainder.toString.reverse\n        val quotient = x / base\n  \
    \      digits += quotient.toString.reverse\n        digits.result()", "      \
    \  var rep : String = \"\"\n        while(x > 0) {\n            rep = (x.toString\
    \ / base).toString + rep\n            x = x % base\n        }\n        rep", " \
    \       var result = \"\"\n        while(x > 0) {\n            result += java.lang.Integer.toString(x\
    \ / base)\n            x = x % base\n        }\n        return result", "    \
    \    val str = x.toString\n        var res = 0\n        var i = 0\n        while(i\
    \ < str.length) {\n            res = (res * (base.toInt)) + str.charAt(i)\n  \
    \          i += 1\n        }\n        return res.toString", "        var num =\
    \ x\n        var res = \"\"\n        var remainder = num % base\n        while(num\
    \ > base){\n            num /= base\n            res = num % base.toString + res.toString\
    \ + remainder.toString\n            remainder = num % base\n        }\n      \
    \  res += remainder.toString\n        res", "        val num = new Array[Double](base.toInt)\n\
    \        val s = x.toString.toDouble / base.toDouble\n        for (i <- 0 until\
    \ num.length)\n            num(i) = s * i\n        val res = num.map(_.toInt).sum\n\
    \        val res = res * base\n        val str = res.toString.padLeft(base.toInt,\
    \ '0')\n        // return string after conversion\n        val res = str.reverse.dropWhile(_\
    \ == '0').mkString\n        res + \"\"", "        val digits = x.toString.reverse.grouped(base)\n\
    \        val base = digits.reverse\n        val result = \"\"\n        for (i\
    \ <- 0 until digits.length) {\n            result += digits(i).mkString(\"\")\n\
    \        }\n        result", "        var xString = \"\"\n        var base = base.toInt\n\
    \        var xLen = x.toInt\n        var quotient = xLen / base\n        var remainder\
    \ = xLen % base\n        var quotientString = \"\"\n        var remainderString\
    \ = \"\"\n        while (quotient != 0) {\n            quotientString = quotientString\
    \ + quotient.toString(base)\n            quotient = quotient - remainder\n   \
    \         remainder = remainder + base\n        }\n        while (quotient !=\
    \ 0) {\n            remainderString = remainderString + remainder.toString(base)\n\
    \            quotient = quotient - remainder\n            remainder = remainder\
    \ + base\n        }\n        if (remainderString.length < x.length) {\n      \
    \      remainderString = remainderString + remainder.toString(base)\n        }\n\
    \        xString = quotientString + remainderString\n        xString", "     \
    \   var sum = 0\n        while(x != 0) {\n            sum = sum + x % base\n \
    \           x = x / base\n        }\n        val str = sum.toString\n        if(sum\
    \ < base) {\n            str = \"0\" * (base-sum) + str\n        }\n        str",
  "        var str = x.toString.reverse\n        var rev = \"\"\n        for(i <-\
    \ 1 to str.length){\n            rev += str(i) swappedBase(rev(str(i)).toInt,\
    \ base(i))\n        }\n        return rev", "        val power = scala.math.pow(base,\
    \ x.length).toInt\n        var newBase = base\n        var newX = 0\n        while(power\
    \ > 0) {\n            newX = newX * base + (x.toInt / power).toInt\n         \
    \   power = power - 1\n        }\n        if(newX > 0) {\n            newBase\
    \ = newX\n            newX = x.toInt\n        }\n        return newX.toString\
    \ + newBase.toString", "        val str = (x.toString.reverse).takeWhile(char=>base\
    \ < str.length || base < char.toString.length).reverse\n        (str.repeat(base\
    \ - str.length) ++ str) ++ (x.toString ++ \"\")", "        val r = scala.util.matching.Regex(\"\
    ^-?0*\").findFirstIn(x.toString)\n        if(r != null)\n            x.toString\n\
    \        else\n            val temp = scala.math.BigDecimal(x).toString(base)\n\
    \            changeBase(new BigDecimal(temp), base)", "        if (x < base )\
    \ throw new IllegalArgumentException(\"Invalid number\")\n        if (base < 2)\
    \ throw new IllegalArgumentException(\"Invalid base\")\n        if (base == 2){\n\
    \            if (x==0) return \"0\"\n            else if(x is Long && x is Int\
    \ && x >= 10) return(x+\"\")\n            else return x\n        }\n        var\
    \ s = x.toString(base)\n        if(s.length == 0) s = x.toString(2)\n        else\
    \ if(s.length < 2) s = x.toString(1)\n        else s = x.toString(0, s.length)\n\
    \        s", "        val s = x / base\n        val i = s.toInt\n        val base\
    \ = s.toDouble\n        var str = \"\"\n        while (i > 0){\n            str\
    \ += i.toString.charAt(0)\n            i -= 1\n        }\n        str = str.reverse",
  "        var res: String = \"\"\n        // The algorithm works fine for base less\
    \ than 10 and base 10.\n        // It is not suitable for base greater than 10.\n\
    \        // for base greater than 10, the result would be \"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
  "        val str1 = x.toString\n        val str2 = str1.reverse\n        val len\
    \ = str2.length\n        var temp = x\n        var res = \"\"\n        var carry\
    \ = 0L\n        var digit = 0\n        while(true){\n            digit = str2.charAt(len\
    \ - 1 - digit)\n            res = res + digit.asInstanceOf[Int]\n            if\
    \ (temp < base * 10){\n                temp = temp + carry\n                carry\
    \ = 0\n            } else {\n                temp = temp - carry\n           \
    \     carry = 1\n            }\n            if(carry == 0){\n                break\n\
    \            }\n        }\n        res", "        val res = x.toString(base).replace('0','.')\n\
    \        if (res.indexOf('.') == -1) {\n            res +='0'\n        }\n   \
    \     res", "        var result = 0\n        var i = 1\n        while (x > 0){\n\
    \            result += x * base.toLong\n            x = x / base.toLong\n    \
    \        i += 1\n        }\n        result /= i.toString\n        return result.toString()\
    \ + i.toString", "        val numbers = new mutable.ArrayBuffer[Long]()\n    \
    \    val baseString = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n        var base\
    \ = base\n        var x = x.toLong\n        while (x > 0)\n        {\n       \
    \     numbers ++= baseString.zipWithIndex.map { case (digit, i) => if (digit ==\
    \ base) x mod base else 0 }\n            x /= base\n        }\n        (0 until\
    \ numbers.last).map(numbers.drop(_)).takeWhile(_ > 0).map(NumberFormat.getIntegerInstance).mkString",
  "        var x = x.toString.toLong\n        var base = base.toString.toLong\n  \
    \      var result = (x / base).toInt\n        var temp = x % base\n        var\
    \ res = \"\"\n        while (temp != 0) {\n            res = res + temp\n    \
    \        temp = temp / base\n        }\n        return res.reverse.toString",
  "        var base : Int = 0\n        val digits = x%base\n        x /= base\n  \
    \      for (i <- digits to 0 by -1){\n            base *= base\n        }\n  \
    \      val digitString = digits(0).toString + digits\n        digitString", " \
    \       val digits = scala.math.pow(base, x)\n        val digitList = digits.toString.split(\"\
    0\")\n        val result = digitList.take(digitList.length - 1).toString.reverse\
    \ + digitList.last\n        return result", "        val str = x.toString.reverse\n\
    \        var x = 0\n        var n = 0\n        var b = 0\n        val base = base.toString.toInt\n\
    \        var chars = \"\"\n        var ret = \"\"\n        var i = 0\n\n     \
    \   while(i < str.length){\n            x += 1\n            n += x\n         \
    \   while(n < base){\n                x += 1\n                n += x\n       \
    \     }\n            b = x - 1\n            chars += str.charAt(i)\n         \
    \   ret += chars.reverse.charAt(b)\n            chars = \"\"\n            i +=\
    \ 1 \n        }\n        ret += chars.reverse.charAt(0)\n        ret.reverse",
  "        var outStr = \"\"\n        var incr = 1\n        var digits = x.toInt\n\
    \        while (digits > base) {\n            incr *= base\n            digits\
    \ /= base\n        }\n        while (digits > 0) {\n            outStr += ((digits\
    \ % base).toString) + \" * \" + incr\n            digits /= base\n        }\n\
    \        outStr += \" \" + incr\n        return outStr", "        def toBase(x:\
    \ Long, base: Long) = {\n            val n = new BigDecimal(x)\n            val\
    \ t = new BigDecimal(base)\n            n.divide(t, BigDecimal.ROUND_HALF_UP)\n\
    \        }\n\n        if(x < base) {\n            throw new IllegalArgumentException(\"\
    x must be greater than base number!\")\n        }\n        // convert to base\
    \ from base\n        val x = toBase(x, base)\n        // remove any 0s in front\
    \ of base\n        val baseStr = x.toString.filter(_ != '0')\n        // add any\
    \ leading 0s to match base\n        val padded = padToBase(baseStr, base);\n \
    \       // reverse the string and convert to base 10\n        padded.reverse.toInt.toString(base)",
  "        val tmp = x / (base * base)\n        val result = (tmp.toInt + 1) * base\n\
    \        return x.toString", "        var s = x.toString.trim\n        var n =\
    \ s.length\n        var res = 0\n        var i = 0\n        // convert base to\
    \ integer if base is larger than 10.\n        if(base > 10) {\n            s =\
    \ s.toInt\n            base = base - 10\n        }\n        while(i<n) {\n   \
    \         var c = s.charAt(i)\n            if(c=='0') {\n                if(res==0)\
    \ {\n                    res = 10\n                }\n                res = res\
    \ * 10\n                res = res + c\n            } else {\n                res\
    \ = res * base + Character.getNumericValue(c)\n            }\n            i +=\
    \ 1\n        }\n        res.toString()", "      val numberWithBase = x\n     \
    \ val numberBaseWithBase = numberWithBase / base\n      val numberBase = (numberBaseWithBase\
    \ % base).toLong\n      val baseString = (1L to (base-1L)).map(x => base.toString.charAt(x)).mkString(\"\
    \")\n      baseString + numberBase.toString", "        val res = x.toString.reverse\n\
    \        if (res.length < base.pow(2).length) {\n            val rem = base.pow(2).length\
    \ - res.length\n            val rem = rem rem rem rem rem rem rem rem rem rem\
    \ rem rem rem rem rem rem rem rem rem rem rem rem rem rem rem rem rem rem rem\
    \ rem rem rem rem rem rem rem rem rem rem rem rem rem rem rem rem rem rem rem\
    \ rem rem rem rem rem rem rem rem rem rem rem rem rem rem rem rem rem rem rem\
    \ rem rem rem rem rem rem rem rem rem rem rem rem rem rem rem rem rem rem rem\
    \ rem rem rem rem rem rem rem rem rem rem rem rem rem rem rem rem rem rem rem\
    \ rem rem rem rem rem rem rem rem rem rem rem rem rem rem rem rem rem rem rem\
    \ rem rem rem rem rem rem rem rem rem rem rem rem rem rem rem rem rem rem rem\
    \ rem rem rem rem rem rem rem rem rem rem rem rem rem rem rem rem rem rem rem\
    \ rem rem rem rem rem rem rem rem rem rem rem rem rem rem rem rem rem rem rem\
    \ rem rem rem rem rem rem rem rem rem rem rem rem rem rem rem rem rem rem rem\
    \ rem rem rem rem rem rem rem rem rem rem rem rem rem rem rem rem rem rem rem\
    \ rem rem rem rem rem rem rem rem rem rem rem rem rem rem rem rem rem rem rem\
    \ rem rem rem rem rem rem rem rem rem rem rem rem rem rem rem rem rem rem rem\
    \ rem rem rem rem rem rem rem rem rem rem rem rem rem rem rem rem rem rem rem\
    \ rem rem rem rem rem rem rem rem rem rem rem rem rem rem rem rem rem rem rem\
    \ rem rem rem rem rem rem rem rem rem rem rem rem rem rem rem rem rem rem rem\
    \ rem rem rem rem rem rem rem rem rem rem rem rem rem rem rem rem rem rem rem\
    \ rem rem rem rem rem rem rem rem rem rem rem rem rem rem rem rem rem rem rem\
    \ rem rem rem rem rem rem rem rem rem rem rem rem rem rem rem rem rem rem rem\
    \ rem rem rem rem rem rem rem rem rem rem rem rem rem rem rem rem rem rem rem\
    \ rem rem rem rem rem rem rem rem rem rem rem rem rem rem rem rem rem rem rem\
    \ rem rem rem rem rem rem rem rem rem rem rem rem rem rem rem rem rem rem rem\
    \ rem rem rem rem rem rem rem rem rem rem rem rem rem rem rem rem rem rem rem\
    \ rem rem rem rem rem rem rem rem rem rem rem rem rem rem rem rem rem rem rem\
    \ rem rem rem rem rem rem rem rem rem rem rem rem rem rem ", "        // Get decimal\
    \ part of input number x, convert base to base 10, and then add decimal part to\
    \ return string.\n        val x = x.toString.reverse.tail.dropWhile(_ >= '0').drop(1)\n\
    \        (for (i <- 1 to Math.ceil(x.length / base)) yield {\n            val\
    \ y = x.slice(i * base, 0, base).reverse\n            Integer.toString(y.getOrElse(0)\
    \ + y.getOrElse(1), 10)\n        }).reverse.mkString", "        val n = x.toInt\
    \ / base.toInt\n        val p = x.toInt % base.toInt\n        val str = \"\"\n\
    \        while(p > 0) {\n            str += (p % base).toInt\n            p =\
    \ p / base.toInt\n        }\n        while(n > 0) {\n            str += n.toInt\n\
    \            n = n / base.toInt\n        }\n        str", "        val bases =\
    \ (\"1\", \"10\", \"100\", \"1000\", \"10000\", \"100000\", \"1000000\", \"10000000\"\
    , \"100000000\").map(_.toLong)\n        val digits = x.toString.toDouble\n   \
    \     val divisor = bases.reverse.drop(bases.size - base.toInt).foldLeft(digits){(a,\
    \ b) => a / b }\n        (x.toString.toInt * divisor).toString + digits.toString",
  "        val y = x.toString % base\n        if (y == 0) changeBase(x.toInt / base,\
    \ base)\n        else changeBase(x.toInt / base, base) + y + base.toString", " \
    \       def strDigits(x: Long): String = {\n            // Get a string representation\
    \ of digits of x.\n            val str = x.toString.reverse\n            val chars\
    \ = s.chars.toList\n            val digits = chars.filter(_.isDigit)\n       \
    \     // Remove all characters that are not digits.\n            val rest = str.filter(!_\
    \ == '0').reverse\n            val out = rest.mkString(\"\") + digits.mkString(\"\
    \")\n            out\n        }\n        val digits = strDigits(x)\n        //\
    \ Calculate base number of x.\n        val baseNum = digits.toString.map(c =>\
    \ math.pow(base.toInt, c.toString.toInt))\n        // Convert string representation\
    \ of digits to number.\n        val convertedNum = baseNum.sum.toLong\n      \
    \  // Convert x to the new base.\n        val newx = convertedNum * x\n      \
    \  // Convert x to string representation.\n        val digitString = strDigits(newx)\n\
    \        // Convert number back to string representation.\n        val out = digitString.reverse.mkString(\"\
    \")\n        out", "        val y = BigInt(x.toString * (base.toDouble / 10))\n\
    \        val z = x.toString / base.toDouble\n        (z * base.toDouble).toString\
    \ + y.toString", "        val y = x.toString(base)\n        val i = y.indexOf(\"\
    .\")\n        if (i < 0)\n            \"\"\n        else {\n            var result\
    \ = \"\"\n            while (y.length > 0) {\n                if (y(i) == 0 &&\
    \ y(i - 1) != 0)\n                    result += \"0\"\n                else\n\
    \                    result += y(i)\n                y -= 1\n            }\n \
    \           result\n        }", "        val rem = x % base\n        val rem =\
    \ rem + (if (rem < base) 0 else base)\n        x.toString.substring(1) + rem +\
    \ x", "        val r = x % base\n        val r0 = r / base\n        val r1 = r\
    \ % base\n        val s = x\n        val t = base\n        val r = x % base\n\
    \        val r0 = r / base\n        val r1 = r % base\n        val s = x\n   \
    \     val t = base\n        val r = x % base\n        val r0 = r / base\n    \
    \    val r1 = r % base\n        val s = x\n        val t = base\n        val r\
    \ = x % base\n        val r0 = r / base\n        val r1 = r % base\n        val\
    \ s = x\n        val t = base\n        val r = x % base\n        val r0 = r /\
    \ base\n        val r1 = r % base\n        val s = x\n        val t = base\n \
    \       val r = x % base\n        val r0 = r / base\n        val r1 = r % base\n\
    \        val s = x\n        val t = base\n        val r = x % base\n        val\
    \ r0 = r / base\n        val r1 = r % base\n        val s = x\n        val t =\
    \ base\n        val r = x % base\n        val r0 = r / base\n        val r1 =\
    \ r % base\n        val s = x\n        val t = base\n        val r = x % base\n\
    \        val r0 = r / base\n        val r1 = r % base\n        val s = x\n   \
    \     val t = base\n        val r = x % base\n        val r0 = r / base\n    \
    \    val r1 = r % base\n        val s = x\n        val t = base\n        val r\
    \ = x % base\n        val r0 = r / base\n        val r1 = r % base\n        val\
    \ s = x\n        val t = base\n        val r = x % base\n        val r0 = r /\
    \ base\n        val r1 = r % base\n        val s = x\n        val t = base\n \
    \       val r = x % base\n        val r0 = r / base\n        val r1 = r % base\n\
    \        val s = x\n        val t = base\n        val r = x % base\n        val\
    \ r0 = r / base\n        val r1 = r % base\n        val s = x\n        val t =\
    \ base\n        val r = x % base\n        val r0 = r / base\n        val r1 =\
    \ r % base\n        val s = x\n        val t = base\n        val r = x % base\n\
    \        val r0 = r / base\n        val ", "        if (x.toString.length == 1)\
    \ {\n            changeBase(x.toString.toLong, base.toString)\n        }\n   \
    \     else {\n            val sx = x.toString.substring(0, 1)\n            val\
    \ bx = x.toString.substring(1, x.toString.length)\n            if (bx.equals(\"\
    \")) {\n                changeBase(sx, base.toString)\n            }\n       \
    \     else {\n                val sbx = sx + bx\n                val bsbx = bx\
    \ + sbx\n                if (sbx.toString.length == 1) {\n                   \
    \ changeBase(sbx.toString.toLong, base.toString)\n                }\n        \
    \        else {\n                    val x = sbx.toString.substring(0, 1)\n  \
    \                  val bx = sbx.toString.substring(1, sbx.toString.length)\n \
    \                   val sbx = sx + bx\n                    val bsbx = bx + sbx\n\
    \                    if (sbx.toString.length == 1) {\n                       \
    \ changeBase(sbx.toString.toLong, base.toString)\n                    }\n    \
    \                else {\n                        val sx = sbx.toString.substring(0,\
    \ 1)\n                        val bx = sbx.toString.substring(1, sbx.toString.length)\n\
    \                        val sbx = sx + bx\n                        val bsbx =\
    \ bx + sbx\n                        if (sbx.toString.length == 1) {\n        \
    \                    changeBase(sbx.toString.toLong, base.toString)\n        \
    \                }\n                        else {\n                         \
    \   val x = sbx.toString.substring(0, 1)\n                            val bx =\
    \ sbx.toString.substring(1, sbx.toString.length)\n                           \
    \ val sbx = sx + bx\n                            val bsbx = bx + sbx\n       \
    \                     if (sbx.toString.length == 1) {\n                      \
    \          changeBase(sbx.toString.toLong, base.toString)\n                  \
    \          }\n                            else {\n                           \
    \     val x = sbx.toString.substring(0, 1)\n                                val\
    \ bx = sbx.toString.substring(1, sbx.toString.length)\n                      \
    \          val sbx = sx + bx\n                                val bsbx = bx +\
    \ sbx\n                                if (sbx.toString.length == 1) {\n     \
    \                               changeBase(sbx.toString.toLong, base.toString)\n\
    \                                }\n                                else {\n \
    \                                   val x = sbx.toString.substring(0, 1)\n   \
    \                                 val bx = sbx.toString.substring(1, sbx.toString.length)\n\
    \                                    val sbx = sx + bx\n                     \
    \               val bsbx = bx + sbx\n                                    if (sbx.toString.length\
    \ == 1) {\n                                        changeBase(sbx.toString.toLong,\
    \ base.toString)\n                                    }\n                    \
    \                else {\n                                        val x = sbx.toString.substring(0,\
    \ 1)\n                                        val bx = sbx.toString.substring(1,\
    \ sbx.toString.length)\n                                        val sbx = s",
  "        if (x < base) {\n            val r = x / base\n            val f = x -\
    \ r * base\n            changeBase(f, base)\n        } else {\n            val\
    \ r = x % base\n            changeBase(r, base)\n        }", "        if(base<10)\
    \ return x.toString(base)\n        val temp : String = \"\"\n        if(base>0)\
    \ {\n            val digits = x.toString.reverse.map(x => if (x<10) '0' else x).toArray\n\
    \            val baseDigits = digits.slice(1, digits.length)\n            for(i\
    \ <- 0 until base) {\n                temp += digits(i).reverse\n            }\n\
    \        }\n        temp", "        val baseStr = if (base < 10) \"0\" + base.toString\
    \ else base.toString\n        val x = x.toInt\n        val res = baseStr * (Math.pow(base.toLong,\
    \ x)).toLong\n        if (res < Integer.MAX_VALUE)\n            Integer.toString(res)\n\
    \        else\n            Long.toString(res)", "        val m = x.toString.toLong\n\
    \        var s = \"\"\n        for(i <- 1 until m) {\n            val q = math.pow(x,\
    \ base)\n            val x = math.floor(q)\n            val r = math.mod(q, x)\n\
    \            s = s + r.toString\n        }\n        return s", "      val digits\
    \ = new mutable.HashSet[Long]()\n      while (x >= base) digits = digits + x.mod(base).toLong\n\
    \      digits.toList.sorted.map(_.toString).reverse.mkString", "        var str\
    \ : String = \"\"\n        var nstr : String = \"\"\n        var result : String\
    \ = \"\"\n        for(i in x.toString.toInt by base) {\n            var temp :\
    \ Long = x.toString.toLong / Math.pow(base,i);\n            temp = temp * Math.pow(base,i).toInt\n\
    \            nstr = nstr + temp.toString\n        }\n        str = str.dropRight(nstr.length)\n\
    \        return str", "        val baseDigit = base / 10\n        var resultStr\
    \ = \"\"\n        var currentDigit = 0\n        while (x < base) {\n         \
    \   currentDigit = x / base\n            x = x - currentDigit * base\n       \
    \     resultStr = currentDigit + resultStr\n        }\n        return resultStr",
  "        if (base == 10) x match {\n            case 0l => \"\"\n            case\
    \ 1l => \"0\"\n            case _ => {\n                val z = x.toString \n\
    \                val y = z.replaceFirst(\"^0\", \"\").replaceFirst(\"^-\", \"\"\
    )\n                val y = y.padTo(base, \"0\").substring(0, base-1)\n       \
    \         y + z.replaceFirst(\"^-\", \"\")\n            }\n        }\n       \
    \ else if (base < 10) x match {\n            case 0l => \"\"\n            case\
    \ _ => x.toString.replaceFirst(\"^0\", \"\").replaceFirst(\"^-\", \"\")\n    \
    \    }\n        else x match {\n            case 0l => \"\"\n            case\
    \ _ => x.toString.replaceFirst(\"^-\", \"\")\n        }", "        val result\
    \ = x.toString.reverse\n        val digits = result.substring( 0, result.length\
    \ ).toList\n        val baseDigits = digits.map(c => base.toString.indexOf(c))\n\
    \        val newBase = baseDigits.reduce((x, y) => x * base + y)\n        val\
    \ result = digits.map(c=> newBase - base.toString.indexOf(c))\n        result.reverse.mkString",
  "        val xStr = x.toString(10)\n        val yStr = xStr.substring(0, xStr.length\
    \ - base)\n        val y = Long(yStr)\n        y.toString(base)", "        if(x.toString.length\
    \ < base.toString.length) \n            throw new Exception(\"Invalid Base for\
    \ Long\")\n        val baseMap : mutable.Map[Long, String] = mutable.Map[(Long,\
    \ Long), String]().withDefaultValue(\"0\")\n        baseMap.getOrElse(base, (base.toString.reverse))\n\
    \        val baseMap2 : mutable.Map[Long, String] = mutable.Map[(Long, Long),\
    \ String]().withDefaultValue(\"0\")\n        baseMap2.getOrElse(base, (base.toString.reverse))\n\
    \        val sum : Long = 0\n        (x.toString.split(' ').toArray.map(_.toLong)).foreach(x\
    \ => {\n            val result = x.toString.reverse.dropWhile(y => y != '0').reverse.takeWhile(y\
    \ => y != '0').toString.reverse\n            sum =  sum + result.charAt(0)*baseMap.getOrElse(base,\
    \ result.charAt(0))\n        })\n        val result = \"\"\n        if(sum >=\
    \ base.toString.length) \n            result += baseMap2.getOrElse(base, base.toString.reverse)\n\
    \        else\n            result += sum.toString + baseMap2.getOrElse(base, base.toString.reverse)\n\
    \        result", "        var result = \"\"\n        var remainder = x % base\n\
    \        while (remainder > 0) {\n            result = (reminder % base) + result\n\
    \            reminder = (reminder / base).toLong\n        }\n        if (remainder\
    \ > 0)\n            result = (remainder % base) + result\n        return result",
  "        var result : String = \"\"\n        val digits = (BigInt(x) / BigInt(base)).pow(BigInt(base)).abs\n\
    \        var remainder = BigInt(x) % BigInt(base)\n        while(digits > 0) {\n\
    \            result += (BigInt(base).toChar).charAt(remainder)\n            remainder\
    \ = remainder / BigInt(base)\n            digits -= 1\n        }\n        result",
  "        var str = x\n        val temp = str / (base.toDouble)\n        str %= base.toDouble\n\
    \        val temp = temp.toInt\n        val temp = temp.toString.reverse.takeRight(2).reverse\n\
    \        val temp = temp.dropWhile(_ != '.').mkString\n        val temp = temp.replace(\"\
    .\", \"\")\n        return temp", "        if (base < 10)\n            x.toString\n\
    \        else {\n            val str = x.toString.reverse\n            val base\
    \ = if (str.length < base) 0 else base\n            val digits = new Array[String](str.length\
    \ - base)\n            for (i <- 0 until digits.length)\n                digits(i)\
    \ = str.substring(i, i + base)\n            digits.mkString(\"\")\n        }",
  "        val baseString = \"0123456789ABCDEF\"\n        val x = x.toLong\n     \
    \   val base = baseString.toLong\n        val temp = x / (base.toDouble).toLong\n\
    \        val r = temp % base.toLong\n        val result = baseString(r).toString\n\
    \        if (result.length < base.toLong) {\n            result + (if (x > base.toLong)\
    \ \"\" else 0)\n        }\n        else {\n            result\n        }", " \
    \       val s = Math.abs(x).toString.toInt;\n        if (s < base) {\n       \
    \     return x + \"\";\n        }\n        if (s > base) {\n            return\
    \ changeBase(x / base, base) + \"\";\n        }\n        if (s == 0) {\n     \
    \       return x + \"\";\n        }\n        if (s > 0) {\n            return\
    \ changeBase(x % base, base) + \"\";\n        } else {\n            val modRem\
    \ = x % base;\n            return changeBase(modRem, base) + \"\";\n        }",
  "        val xStr : String = x.toString\n        val baseStr : String = base.toString\n\
    \n        if (xStr.length > baseStr.length)\n        { println(xStr);\n      \
    \    println(\"ERROR - String has more digits than base.\");\n          xStr\n\
    \        }\n\n        if (baseStr.length < 1l)\n        { println(xStr);\n   \
    \       println(\"ERROR - Base should be longer than 0.\");\n          xStr\n\
    \        }\n\n        val xStrArray = xStr.toCharArray.map(_.toInt)\n        val\
    \ baseStrArray = baseStr.toCharArray.map(_.toInt)\n\n        var str = \"\"\n\
    \        var power = 0\n        for (i <- 0 until xStrArray.length)\n        {\n\
    \            if (xStrArray(i) > baseStrArray(0))\n            {\n            \
    \    power = 1l\n            }\n            else power *= baseStrArray(0)\n  \
    \          str += \"0\"\n            for (j <- 1 until xStrArray.length)\n   \
    \         {\n                str += Integer.toString((xStrArray(i) % baseStrArray(j)\
    \ + power) % baseStrArray(j))\n            }\n        }\n        str", "     \
    \   val n = x.toString.toInt\n        val b = base.toString.toInt\n        if\
    \ (n >= b) x.toString.toString + changeBase(n, b)\n        else if (n == b) x.toString.toString\
    \ + changeBase(n - b, b)\n        else changeBase(n - b, b) + x.toString.toString\
    \ + changeBase(n, b)", "        if (base > 10) return \"\"\n        val d = base.toLong\n\
    \        val x = x.toLong\n        val b = x.toInt\n        val r = b / d\n  \
    \      val q = r.toDouble\n        val rr = r - q\n        val x = x.toInt\n \
    \       val xx = x + 1\n        var result = 0\n        var pow = 0\n        val\
    \ res = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\".toCharArray\n        while (pow<d){\n\
    \            result = result + res(math.floor(math.pow(xx, pow)))\n          \
    \  pow+=1\n        }\n        result += res(math.floor(xx))\n        val a = xx.toLong\n\
    \        var b = a\n        var i = 0\n        while (i < base){\n           \
    \ b = b.toInt * 10\n            i += 1\n        }\n        val r = b / d\n   \
    \     val q = r.toDouble\n        val rr = r - q\n        val a = xx.toLong\n\
    \        var b = a\n        var i = 1\n        while (i < base){\n           \
    \ b = b.toInt / 10\n            i += 1\n        }\n        val r = b / d\n   \
    \     val q = r.toDouble\n        val rr = r - q\n        val a = xx.toLong\n\
    \        var b = a\n        var i = 1\n        while (i < base){\n           \
    \ b = b.toInt\n            i += 1\n        }\n        val r = b / d\n        val\
    \ q = r.toDouble\n        val rr = r - q\n        val a = xx.toLong\n        var\
    \ b = a\n        var i = 1\n        while (i < base){\n            b = b.toInt\n\
    \            i += 1\n        }\n        val r = b / d\n        val q = r.toDouble\n\
    \        val rr = r - q\n        val a = xx.toLong\n        var b = a\n      \
    \  var i = 1\n        while (i < base){\n            b = b.toInt\n           \
    \ i += 1\n        }\n        val r = b / d\n        val q = r.toDouble\n     \
    \   val rr = r - q\n        val a = xx.toLong\n        var b = a\n        var\
    \ i = 1\n        while (i < base){\n            b = b.toInt\n            i +=\
    \ 1\n        }\n        val r = b / d\n        val q = r.toDouble\n        val\
    \ rr = r - q\n        val a = xx.toLong\n        var b = a\n        var i = 1\n\
    \        while (i < base){\n            b = b.toInt\n            i += 1\n    \
    \    }\n        val r = b / d\n        val q = r.toDouble\n        val rr = r\
    \ - q\n        val a = xx.toLong\n", "        val str = x.toString.toCharArray.toArray.map(c\
    \ => c.toString.toInt * base).toList\n        val n = str.length - 1\n       \
    \ val r = new Array[String](n)\n        var i = 0\n        while (i < n) {\n \
    \           r(i) = str(i + 1).toString\n            i += 1\n        }\n      \
    \  r(n) = str(0).toString\n        r.mkString", "        // base numbers are less\
    \ than 10.\n        if (x < 10) x else changeBase((x/base).toInt*base,base)",
  "        val x = x.toInt\n        val base = base.toInt\n        val res = base.toString.reverse.foldLeft(x)((temp,\
    \ count) => temp * base + count)\n        (base.toString.reverse.mkString, base.toString.reverse.filter(x\
    \ => x != res).mkString)", "        var newBase = base;\n        var lastZero\
    \ = x;\n        var result = \"\";\n        while (lastZero > 0){\n          \
    \  val lastDigit = lastZero % newBase;\n            if (lastDigit == 0){\n   \
    \             lastZero = lastZero / newBase;\n                result += \"0\"\
    ;\n            } else {\n                result += \"\" + lastDigit;\n       \
    \     }\n            newBase = newBase * 10;\n        }\n        if (newBase ==\
    \ base){\n            return result;\n        } else {\n            val remainingDigits\
    \ = (x-lastZero) / newBase;\n            return changeBase(remainingDigits, base)\
    \ + result;\n        }", "        val b = x.toString.reverse.toInt\n        val\
    \ o = b.toInt\n        val n = base.toInt\n        val p = o.toInt\n        val\
    \ q = n.toInt\n        val r = p.toInt\n        val s = r.toInt\n        val t\
    \ = (b * q).toInt\n        if (t > 1) {\n            val h = (t - 1).toInt\n \
    \           val g = (t * base).toInt\n            val y = (h * g).toInt\n    \
    \        val x = y * base\n            val z = x.toString.reverse\n        } else\
    \ {\n            val z = t.toString.reverse\n        }\n        z.toString", " \
    \       var res = \"\"\n        val i = x / base\n        val j = i % base\n \
    \       res = res + j.toString\n        x = x - j * base\n        return changeBase(x,\
    \ base)", "        var numStr : String = x.toString.replaceFirst(\"^0*\", \"\"\
    )\n        var result : String = null\n        val base : Int = math.floor(math.log(base,\
    \ 10))\n        val zeros : Int = math.min(numStr.length, base)\n        for (\
    \ i <- 0 to zeros ) {\n            var pow = math.pow(base,i)\n            var\
    \ mul = math.floor(x / pow)\n            var num = x % pow\n            x = mul\n\
    \            val remainder = num % base\n            numStr += \"\"+remainder\n\
    \        }\n        val numsBeforeBase = numStr.split(\"\").filter(x => x != \"\
    0\")\n        var newNumStr = \"\"\n        for ( i <- 0 to numsBeforeBase.length\
    \ ) {\n            newNumStr += (if (numsBeforeBase(i) != 0) numsBeforeBase(i)\
    \ else 0)\n        }\n        result = newNumStr\n        result", "        val\
    \ temp = x / base\n        var res = x.toString\n        var index = x.length\
    \ - 1\n        while (temp != 0) {\n            res = res + temp.mod(base).toString.reverse\n\
    \            temp /= base\n            index = index - 1\n        }\n        res.reverse",
  "        val convert = x * (base / (10l)) // Multiply the input number by base and\
    \ divide by base (10 divided by base)\n        val result = (convert.toInt)\n\
    \        (result + \"\").toCharArray().map(x => x.toChar).mkString", '        (x
    / (base.toDouble)).toString.reverse', "        val digits = x.toString.toInt\n\
    \        val base10 = digits / base\n        val base2  = digits % base\n    \
    \    val baseRes = base10 + base2\n        val resStr = baseRes.toString\n   \
    \     val res = new Array[Char](resStr.length)\n        for (i<-0 to resStr.length-1)\
    \ {\n            res(i) = resStr(i).toChar\n        }\n        new String(res)",
  "        var numAsStr = x.toString\n        var baseAsStr = base.toString\n    \
    \    while (numAsStr.length >= baseAsStr.length) {\n            val tmp = numAsStr.substring(baseAsStr.length,\
    \ numAsStr.length)\n            numAsStr = numAsStr.substring(0, baseAsStr.length)\
    \ + tmp\n        }\n        numAsStr", "        val digits = List(x)\n       \
    \ val reversedDigits = List(x)\n        while (digits contains 0) digits -= digit(0)\n\
    \        while (digits contains base) digits -= 1\n        while (digits contains\
    \ 0) reversedDigits -= reversedDigit(0)\n        while (digits contains base)\
    \ reversedDigits -= 1\n        var result: String = \"\"\n        for (i <- 0\
    \ to digits.size) {\n            result += (digits(i).asInstanceOf[Int] * base.toInt)\
    \ + reversedDigits(i).asInstanceOf[Int]\n        }\n        result", "       \
    \ val xstr = x.toString\n        val basestr = base.toString\n        var xx =\
    \ Long.parseLong(xstr)\n        var bb = Long.parseLong(basestr)\n        while(xx\
    \ < 0) {\n            xx = xx + Long.parseInt(\"10\") * base\n            bb =\
    \ bb * base\n        }\n        var result = \"\"\n        while(x > 0) {\n  \
    \          result = result + Integer.toString((x%base))\n            x = x/base\n\
    \        }\n        return result + Integer.toString(bb)", "        val str =\
    \ x.toString.reverse;\n        val result = str.reverse take base reverse;\n \
    \       result += str.reverse drop base reverse;\n        result.toString", " \
    \       var result = \"\"\n        if(x.toString.toInt == x)\n        {\n    \
    \        result = x.toString.toInt.toString(base)\n        }\n        else\n \
    \       {\n            var temp = x\n            while(temp.toString.toInt !=\
    \ x)\n            {\n                var a = temp.toString.toInt\n           \
    \     temp = temp / base\n                result = result + a.toString(base)\n\
    \            }\n        }\n        return result ", "        var baseStr = \"\"\
    \n        var i = 0\n        while (i < base - 1) {\n            baseStr = \"\
    0\" + baseStr\n            i = i + 1\n        }\n        while (x < base) {\n\
    \            baseStr = ((x.toString.toLong * base).toInt) + baseStr\n        \
    \    x = x / base\n            i = i + 1\n        }\n        baseStr = (x.toString.toLong\
    \ + baseStr).toString + baseStr\n        baseStr", "        def convertBase(x:\
    \ Long, base: Long): String = {\n            val xs = x.toString.reverse\n   \
    \         def divide(x: Long, base: Long): Long = {\n                if (x.toString.length\
    \ >= base.toString.length) x / (base * base) else x / base\n            }\n  \
    \          def convertBase(x: Long, base: Long, divide: Long): String = {\n  \
    \              val xs = x.toString.reverse\n                val newx = xs.map(x\
    \ => if (x > 0) (x / divide) else (x / divide).toString)\n                StringBuffer(newx.takeWhile(x\
    \ => x != 0)).mkString(\"\")\n            }\n            convertBase(xs, base,\
    \ divide)\n        }\n        convertBase(x, base)", "        val temp = x.toString\
    \ + base.toString\n        val digits = temp.split(\"\").map(_.toInt)\n      \
    \  val baseDigits = digits.dropRight(1)\n        val result = baseDigits.map(x\
    \ => x.toString + base.map(_.toString)(x))\n        val result = result.drop(1).mkString\n\
    \        result", "        val num : String = x.toString // converting from long\
    \ to String\n        val base = num.length // length of String base\n        val\
    \ res = num.toCharArray.map(x => if(x.toInt == base-1) x.toString else x.toString\
    \ + x.toString.toInt)\n        val result = res.mkString(\"\")\n        return\
    \ result;", "        var baseStr = \"\"\n        var n = x\n        while(n >\
    \ base) {\n            n /= base\n            baseStr += x.toString.charAt(n-base).toString\n\
    \        }\n        return baseStr + x.toString.charAt(x-n).toString", "     \
    \   val tmp = x.toString.reverse\n        val digits = tmp.split(\"\")\n     \
    \   val newBase = base.toString.reverse\n        val newDigits = (digits.length\
    \ * base).toString.reverse\n        val newString = (newBase ++ newDigits).reverse\n\
    \        newString", "        if (x < base) x\n        else if (x >= base) x %\
    \ base\n        else\n            if (x % base < base)\n                changeBase(x\
    \ / base, base)\n            else {\n                val result = changeBase(x\
    \ / base, base)\n                val remainder = x - base * result\n         \
    \       result + result.toString + (if (remainder != 0) \"*\" + remainder else\
    \ \"\")\n            }", "        var s = x.toString\n        while(s.length>base){\n\
    \            s=s.substring(0,s.length-base)+s.substring(s.length-base,s.length)\n\
    \        }\n        return s", "        val bin = x.toBinary.length\n        val\
    \ baseBin = base.toBinary.length\n        // Reversing base to convert it into\
    \ numeral system.\n        var reversedBase = reverseBaseToNumber(base)\n    \
    \    // Reversing x to convert it into numeral system.\n        var reversedX\
    \ = x.toBinary().reverse\n        var result = \"\"\n        // converting numbers\
    \ into string format \n        // and reversing it.\n        var reversedResult\
    \ = reversedX.reverse\n        // calculating number of places to left shift \n\
    \        // when converting into base 10 \n        var shift = 0\n        // converting\
    \ base 10 to decimal system\n        for(i <- 0 until bin){\n            val temp\
    \ = reversedResult(i).toInt\n            result += (temp.toString.reverse * baseBin).toChar\n\
    \            shift += baseBin\n        }\n        result.reverse", "        val\
    \ xStr = x.toString(10)\n        val base = base.toString(10)\n        val baseStr\
    \ =\n            if (base.length < baseStr.length) base +\n            else if\
    \ (base.length > baseStr.length) baseStr +\n            else baseStr\n       \
    \ val base = base.toInt\n        val baseStr = baseStr.toInt\n        val baseStr\
    \ = baseStr.dropWhile(_ < 0).dropWhile(_ > 9).mkString(\"\")\n        val n =\
    \ xStr.length - baseStr.length\n        val digit = baseStr.substring(0, n)\n\
    \        val digitStr = baseStr.substring(n - 1)\n        val newBase = xStr.length.toLong\
    \ / digit.length\n        val newBaseStr = baseStr.substring(newBase * digit.length)\n\
    \        val newBaseStr = if (newBaseStr.length == digit.length) \"0\" else newBaseStr\n\
    \        newBaseStr +\n            digitStr +\n            xStr.substring(newBaseStr.length)",
  "        val nums = x toString reverse\n        val digits = nums substringTo 1\
    \ toList\n        val remain = digits reverse\n        val result = (base to 0)\
    \ * (remain map toInt)\n        result takeWhile (x => x != 0) mkString \"\"",
  "        var number = 0\n        var digit = 1\n        var str = \"\"\n       \
    \ while (number < x) {\n            str = str + digit.toString\n            digit\
    \ = digit*base\n            number = number*base\n        }\n        return str",
  "        val y = x.toString.toInt\n        val str = Integer.toString(y)\n     \
    \   if(str.length == base.toString().length)\n            return str\n       \
    \ else\n            return changeBase(Integer.parseInt(str), base)", "       \
    \ if (x < base) {\n            throw new IllegalArgumentException(\"Invalid input:\
    \ Base can't be less than base\");\n        }\n        var str = \"\"\n      \
    \  val digits = x.toString.reverse.grouped(base).toList\n        var remaining\
    \ = base\n        for (digit <- digits) {\n            val digitStr = digit.mkString\n\
    \            val digitCount = digitStr.length\n            var num = 0\n     \
    \       for (c <- digitStr) {\n                val digitValue = getDigitValue(digitCount,\
    \ c)\n                num |= digitValue << remaining\n                remaining\
    \ -= digitValue\n            }\n            str += num.toString.reverse.mkString\n\
    \        }\n        str", "        val len = x.length\n        val bits = len\
    \ - base\n        val result = new Array[String](bits)\n        val b = 0\n  \
    \      val resultArray = Array(\"\")\n        while(x >= base) {\n           \
    \ x /= base\n            b += 1\n            resultArray(b) = x.toString.charAt(0)\n\
    \        }\n        for(i <- 0 until bits) {\n            result(i) = resultArray(i)\
    \ + resultArray(b-bits)\n        }\n        result.mkString(\"\")", "        val\
    \ r = BigInt(x.toInt) / BigInt(base.toInt).toInt\n        val s = r.toString.reverse\n\
    \        (s\"$s${r.toString.takeWhile(x => x <= 9).mkString(\"\")}\")", "    \
    \    val remainder = x % base\n        val quotient = x / base\n        val digitString\
    \ = \"0\" * (base-remainder) + digitString\n        val rem = remainder % base\n\
    \        val quo = quotient / base\n        if(rem == 0 && quo == 0)\n       \
    \     digitString\n        else {\n            changeBase(rem, base)\n       \
    \     digitString + changeBase(quo, base)\n        }", "        val digits = x.toString.length\n\
    \        val tmp = if (digits < base) x else x.divide(base).multiply(base).toInt\n\
    \        val x = tmp.toString.drop(digits)\n        val result = if (digits <\
    \ base) x else x.multiply(base).toString.drop(digits)\n        return result",
  "        if (x < base)\n            throw new IllegalArgumentException(\"Base number\
    \ should be less than the target number\")\n        var result : String = \"\"\
    \n        var i = x\n        val n = math.pow(base, x)\n        while(n > 1) {\n\
    \            result = Integer.toString(i) + result\n            n /= base\n  \
    \          i /= base\n        }\n        result = Integer.toString(i) + result\n\
    \        return result", "        var result = x.toString\n        var quotient\
    \ = x / base\n        if (quotient > 0){\n            while (quotient > 1){\n\
    \                result = quotient.toString + result\n                quotient\
    \ = quotient / base\n            }\n            result = quotient.toString + result\n\
    \        }\n        return result", "        val temp = x.toString.reverse.dropWhile(_.isDigit).reverse\n\
    \        var str = \"\"\n        var i = 0\n        while (i < temp.length) {\n\
    \            if (i % base == 0) {\n                str = str.dropRight(1)\n  \
    \          }\n            str += temp(i)\n            i += 1\n        }\n    \
    \    str", "        if(x == 0) {\n            return \"0\"\n        }\n      \
    \  if(base < 10) {\n            val rem = x % base\n            if(rem == 0) {\n\
    \                return x + changeBase(x / base, base)\n            } else {\n\
    \                return x + changeBase(rem, base) + changeBase(x / base, base)\n\
    \            }\n        }\n        if(base % 2 == 0) {\n            val rem =\
    \ x % base\n            if(rem == 0) {\n                return changeBase((x /\
    \ (base * base)), base) + changeBase((x / (base * base)), base)\n            }\
    \ else {\n                return changeBase(rem, base) + changeBase((x / (base\
    \ * base)), base)\n            }\n        } else {\n            val rem = x %\
    \ base\n            if(rem == 0) {\n                return changeBase((x / base),\
    \ base) + changeBase((x / base), base)\n            } else {\n               \
    \ return changeBase(rem, base) + changeBase((x / base), base)\n            }\n\
    \        }", "        var res = \"\"\n        val n = scala.math.BigInt(x)\n \
    \       val bn = scala.math.BigInt(base)\n        while(n > 0) {\n           \
    \ res = scala.math.BigInt(res) + (n - bn)\n            n = n / bn.toBigInt\n \
    \       }\n        res", "        var temp : String = \"\"\n        var temp1\
    \ : String = \"\"\n        var base = base.pow(10)\n        var result = x.div(base)\n\
    \        var value = x.modf(base)\n        while (value != 0) {\n            temp1\
    \ = value.toString\n            temp = temp + temp1\n            value = value.div(base)\n\
    \        }\n        temp1 = x.toString\n        temp = temp + temp1\n        temp",
  "        val n = (x / (base.pow(2))).toInt\n        val res = x.toString.substring(base.toInt)\n\
    \        if (res.length < base.toInt) res + res.reverse\n        else res", " \
    \     val xMod = x % base\n      if (xMod == 0) return x.toString.toLong.toString\n\
    \      val result = changeBase(xMod + (base/2), base)\n      if (xMod < base)\
    \ result + result.last\n      else result", "        // We are converting to a\
    \ number in base base\n        var str = x.toString\n        if (base < 2)\n \
    \           return str\n        val tempBase = base\n        // Remove the leading\
    \ 1\n        if (str.startsWith(\"1\")) {\n            str = str.substring(1)\n\
    \        }\n        // If the base is greater than or equal to 10, then just convert\
    \ to base\n        if (tempBase >= 10) {\n            while (str.length >= tempBase)\
    \ {\n                str = changeBaseLong(str, tempBase)\n                tempBase\
    \ /= 10\n            }\n        }\n        // Convert from base to base using\
    \ long number representation\n        var result: Long = 0\n        for (i <-\
    \ 0 until str.length.toInt) {\n            result += (10L * str.charAt(i) - '0')\
    \ * tempBase\n            tempBase /= 10\n        }\n        return String.valueOf((result.toLong).toInt)",
  "        var str = x.toString\n        var baseString = base.toString\n        while\
    \ (!(str.length < base.length)) {\n            str = Integer.toString(baseString\
    \ * Integer.parseInt(str), base.toString)\n        }\n        return str", " \
    \       // Initialize result array for length of x\n        var res : Array[String]\
    \ = new Array[String](x.length);\n        \n        // Convert the number to base\
    \ 10\n        val xRes = Integer.parseInt(x.toString, base);\n        \n     \
    \   // Add the converted number to the result array\n        res :+ xRes.toString();\n\
    \        \n        // Return the result array\n        res", "        val str\
    \ = new StringBuilder\n        val res = x.toString % base.toInt\n        while\
    \ (x.toString.length < base.toInt) {\n            str.append(\"0\")\n        }\n\
    \        str.append(res)\n        str.substring(0, base.toInt)", "        val\
    \ digits = x % (base.toLong*base).toLong\n        val base = base.toLong\n   \
    \     var res = \"\"\n        var remainder\n        while(digits > 0) {\n   \
    \         remainder = digits%base\n            res = res + remainder.toString\n\
    \            digits = digits/base\n        }\n        if(res.length == 0)\n  \
    \          res = \"\"\n        res.reverse", "        var s = \"\"\n        var\
    \ tmp = Long.divide(x, base)\n        while(!(tmp == 0l)){\n            s = tmp.toString\
    \ + s\n            tmp = Long.divide(tmp, base)\n        }\n        return s",
  "        var result : String = \"\"\n        for(i <- 1 to base) {\n           \
    \ result += (x % base).toString.toUpperCase\n            x = x / base\n      \
    \  }\n        return result", "        val digit = BigDecimal.divide(x, BigDecimal.ONE,\
    \ base)\n        val result = digit.toString\n        val tail = digit.minus(BigDecimal.ONE)\n\
    \        val reminder = tail.toString.length\n        tail + if (reminder == 0)\
    \ \"0\" else tail.substring(0, reminder - 1)", "        val newNum = x.toInt /\
    \ base.toInt\n        val quotient = x.toInt % base.toInt\n        val num = new\
    \ Number(newNum)\n        val ret = new String(num.digits)\n        val baseDigits\
    \ = ret.toCharArray\n        if (quotient != 0) {\n            baseDigits(quotient.toInt)\
    \ <- '1'\n        }\n        new String(baseDigits)", "        val baseConverted\
    \ : Int = (x).toInt\n        var temp = 0\n        while(baseConverted > 0) {\n\
    \            temp = (baseConverted % base).toInt\n            baseConverted =\
    \ baseConverted.toInt\n        }\n        if(temp == 0) return \"0\"\n       \
    \ else return x.toString + temp.toString", "        var res = x.toString(base)\n\
    \        while (res.length < base)\n            res = \"0\" + res\n        return\
    \ res", "        val digits = x.toString.reverse.grouped(base).map(x => x.reverse).mkString\n\
    \        (digits * base).reverse", "        var res = \"\"\n        var i = x\n\
    \        while (i > 0) {\n            res = res + i%base\n            i = i /\
    \ base\n        }\n        return res", "        if (base <= 0) \"0\";\n     \
    \   else if (x < base) changeBase(x / base, base) + changeBase(x%base, base).toLong.toString\n\
    \        else x.toString", "        val digits = scala.math.pow(base.toDouble,\
    \ x.toDouble)\n        val result = digits.toString.reverse.foldLeft(\"\"){ (result,\
    \ digit) =>\n            val x = result.length\n            var digit = digit.toString.reverse\
    \ + digit\n            if (x < base) digit + digit.drop(base)\n            else\
    \ digit\n        }\n        result", "        val digits = x.toString.reverse.grouped(base.toInt)\n\
    \        val result = new StringBuilder\n        for (d <- digits) {\n       \
    \     result += d.map(digit => digit + base)\n        }\n        return result.toString()",
  "        def toBase(x: Long, base: Long) : Long = {\n            val digits = BigInt(x)\n\
    \            (digits / base).toInt\n        }\n\n        val digits = toBase(x,\
    \ base)\n        val chars = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\".toCharArray\n\
    \        chars(digits).toString() + digits(base).toString", "        val power\
    \ = long2String(base).size\n\n        def calc(x: Long, base: Long, power: Long)\
    \ : Long = {\n            if (x == 0) 1\n            else (calc(x/base,base,power-1).toLong*base).toLong\n\
    \        }\n\n        // If x is greater than power of base, then x is converted\
    \ to a power of base by multiplication.\n        // Example: 10^5 is equal to\
    \ 1000*10*10*10*10*10.\n        val x = calc(x,base,power)\n        // Change\
    \ x to a power of base by multiplication.\n        val res = long2String(power.toDouble/base.toDouble)\n\
    \        x + res.substring(0, res.length-1) + x", "        val num = scala.math.BigInt(x)\n\
    \        val div = scala.math.BigInt(base).divide(num)\n        val result = (div.toInt\
    \ / num).toString + (div % num).toString\n        \n        val baseStr = \"0123456789ABCDEF\"\
    \n        val temp = Integer.parseInt(result)\n        val res = baseStr.charAt(temp\
    \ - 1)\n        \n        res", '        (x / (base.toLong * base)) % base.toString',
  "        if (base == 1) {\n            // 1L \u2192 \"1\"\n            val one =\
    \ x.toInt\n            val ones = (one * 10).toInt\n            val result = ones\
    \ == 1 ? one : ones + \"1\";\n            return(result.toString)\n        } else\
    \ if (base == 10) {\n            // 10L \u2192 \"0\"\n            val ten = x.toInt\n\
    \            val tens = (ten * 10).toInt\n            val result = tens == 0 ?\
    \ ten : tens + \"0\";\n            return(result.toString)\n        } else {\n\
    \            val ten = x / base.toInt\n            val ten =  ten * base.toInt\n\
    \            val result = changeBase(ten, base-1) + changeBase(x % base, base).toChar\n\
    \            return(result.toString)\n        }"]
stop_tokens:
- "\n    }\n"
