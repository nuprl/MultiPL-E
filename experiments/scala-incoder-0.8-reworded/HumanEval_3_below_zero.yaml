name: HumanEval_3_below_zero
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // You're given a list of deposit and withdrawal operations on a bank account\
  \ that starts with\n    // zero balance. Your task is to detect if at any point\
  \ the balance of account fallls below zero, and\n    // at that point function should\
  \ return true. Otherwise it should return false.\n    // >>> belowZero((List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong)))\n    // (false)\n    // >>> belowZero((List[Long](1l.toLong,\
  \ 2l.toLong, -4l.toLong, 5l.toLong)))\n    // (true)\n    def belowZero(operations\
  \ : List[Long]) : Boolean = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(belowZero((List[Long]()))\
  \ == (false));\n    assert(belowZero((List[Long](1l.toLong, 2l.toLong, -3l.toLong,\
  \ 1l.toLong, 2l.toLong, -3l.toLong))) == (false));\n    assert(belowZero((List[Long](1l.toLong,\
  \ 2l.toLong, -4l.toLong, 5l.toLong, 6l.toLong))) == (true));\n    assert(belowZero((List[Long](1l.toLong,\
  \ -1l.toLong, 2l.toLong, -2l.toLong, 5l.toLong, -5l.toLong, 4l.toLong, -4l.toLong)))\
  \ == (false));\n    assert(belowZero((List[Long](1l.toLong, -1l.toLong, 2l.toLong,\
  \ -2l.toLong, 5l.toLong, -5l.toLong, 4l.toLong, -5l.toLong))) == (true));\n    assert(belowZero((List[Long](1l.toLong,\
  \ -2l.toLong, 2l.toLong, -2l.toLong, 5l.toLong, -5l.toLong, 4l.toLong, -4l.toLong)))\
  \ == (true));\n    }\n\n}\n"
completions: ["        val startingBal = operations.foldLeft(0L)((bal, op) => bal\
    \ + op)\n        operations.forall { operation => operation == 0 && startingBal\
    \ < 0 }", "        // Solution 1\n        // The trick is to use tail-recursion.\n\
    \        // Tail-recursion is where you have a function that calls itself. In\
    \ this case, you're calling the function with the remainder of the list as the\
    \ new list.\n        // For example, the first call to the function below with\
    \ an empty list would return the function below with the first element as the\
    \ new list, and so on.\n        // The function below will call the function below\
    \ with the remainder of the list as the new list.\n        def belowZeroTailRecursion(list:\
    \ List[Long], acc : List[Long]) : Boolean = {\n            if (list.isEmpty) {\n\
    \                // base case\n                return acc == Nil\n           \
    \ }\n            // recursive case\n            belowZeroTailRecursion(list.tail,\
    \ acc ++ list(0)) // append the head to the accumulator, and prepend it to the\
    \ new list\n        }\n        belowZeroTailRecursion(operations, Nil)", "   \
    \     val accountBalance = 0\n        val operationList = mutable.ListBuffer.empty[Long]\n\
    \        operations.foreach { operation =>\n            if (operation > 0) {\n\
    \                operationList += operation\n            }\n        }\n      \
    \  val operationCount = operationList.size\n        operationList.foreach { operation\
    \ =>\n            if (operationCount > 0) {\n                accountBalance +=\
    \ operation\n                operationCount -= 1\n            }\n        }\n \
    \       accountBalance < 0", "        var balance = 0L\n        operations.foreach(x\
    \ => balance = balance + x)\n        balance < 0L", "        val maxDeposits =\
    \ operations.max\n        val maxWithdrawals = operations.reduce((x,y) => if (x>y)\
    \ x else y)\n        operations.reduce((x,y) => if (x>y) x else y) < 0", "   \
    \     // First we build a map of (operation, balance) pairs.\n        val operationBalancesMap\
    \ = new mutable.HashMap[Long, Long]()\n        operations.foreach{ case operation\
    \ => \n            val balance = operation.toLong\n            val currentBalance\
    \ = operationBalancesMap.getOrElseUpdate(operation, 0L)\n            operationBalancesMap\
    \ += (operation -> currentBalance + balance)\n        }\n        // Then we find\
    \ operations that never exceed the balance\n        val operationsWithNoBalance\
    \ = operationBalancesMap.filter(_._2 > 0).map(_._1)\n        val operationBalances:\
    \ Seq[(Long, Long)] = operationBalancesMap.filter(_._2 <= 0)\n        operationBalances.exists(ops\
    \ => operations.exists(ops => operationBalancesMap.get(ops) > 0L)) ", "      \
    \  def rec(current : Long, balance : Long) : Boolean = {\n            if (balance\
    \ < 0)\n                return true\n            if (balance == 0) {\n       \
    \         if (current == 0)\n                    return true\n               \
    \ else\n                    return false\n            }\n            rec(current\
    \ + operations(current - 1), balance - operations(current))\n        }\n     \
    \   rec(operations(0), operations.length)", "        val balance = operations\n\
    \                .foldLeft(0l)((acc, operation) =>\n                    if (operation\
    \ < 0) acc - operation else acc + operation)\n        (balance < 0L)", "     \
    \   // Initialize a mutable map of balances to track how many operations per account\
    \ we have.\n        val map = new mutable.HashMap[Long, Long]()\n\n        //\
    \ Loop through all the operations.\n        for (operation <- operations) {\n\
    \            val curr = map.getOrElse(operation, 0L)\n            map.put(operation,\
    \ curr + operation)\n        }\n\n        // If any of the balances fall below\
    \ zero, we know that there were operations.\n        map.values.exists(_ < 0)",
  "        val balance = mutable.ListBuffer.empty[Long]\n        operations.foreach\
    \ { operation =>\n            val balanceAtPoint = if (operation == 0) 0L else\
    \ operation\n            balance += balanceAtPoint\n        }\n        balance.last\
    \ < 0", "        val balances = operations.map(operation => operation - operations.last)\n\
    \        balances reduceLeft (_.fold(true)(_ > 0))", "        def checkBalance\
    \ : Boolean = operations.reduceLeft{\n            case (balance, operation) =>\n\
    \                if (balance < operation) true else false\n        }\n\n     \
    \   checkBalance", "        var balance : Long = 0\n        val operationList\
    \ = operations.reverse\n        operationList.foreach {\n            operation\
    \ =>\n                balance += operation\n            if (balance < 0) {\n \
    \               balance = 0\n            }\n        }\n        balance < 0", " \
    \       var currentBalance = 0l\n        val operation = operations.head\n   \
    \     var hasChanged = false\n        var index = 0\n        for (operationIndex\
    \ <- 0 until operations.size) {\n            currentBalance += operations(operationIndex)\n\
    \            index += 1\n            if ((currentBalance - operations(operationIndex))\
    \ < 0) {\n                hasChanged = true\n                val subList = operations.sublist(index,\
    \ operations.size)\n                val newBalance = currentBalance - operations(operationIndex)\n\
    \                currentBalance = newBalance\n                index = 0\n    \
    \            subList.foreach(operation => currentBalance += operation)\n     \
    \       } else {\n                currentBalance -= operations(operationIndex)\n\
    \            }\n        }\n        currentBalance < 0", "        var balance =\
    \ 0\n        operations foreach {\n            operation =>\n                balance\
    \ += operation\n        }\n        balance < 0", "        val withdrawals = mutable.ArrayBuffer(operations.takeWhile{\
    \ x => x != 0})\n        val deposits = operations.dropWhile(x => x != 0).reverse\n\
    \        val bal = deposits.reduce(0L) -withdrawals.reduce(0L)\n        if(bal\
    \ < 0) true else false", "        val balance = operations.head\n        val operation\
    \ = operations.tail\n        operation match {\n            case Nil => false\n\
    \            case x :: xs => balance < x\n            case _ => belowZero(operation)\n\
    \        }", "        val maxBalance = operations.foldLeft(0L)((max, cur) => math.max(max,\
    \ cur))\n        operations exists { value => value <= maxBalance }", "      \
    \  val result = operations.foldLeft(false) { (acc, operation) =>\n           \
    \ if (acc && operation < 0) {\n                true\n            }\n         \
    \   else {\n                acc\n            }\n        }\n        result", " \
    \       var balance = 0L\n        val intialBalance = operations.foldLeft(balance)(\
    \ (acc,operation) =>\n            acc + operation\n        )\n        if (intialBalance\
    \ < 0)\n            return true\n        val finalBalance = operations.foldRight(balance)((acc,operation)=>{\n\
    \            val balance = acc + operation\n            if (balance < 0)\n   \
    \             false\n            else\n                balance\n        })\n \
    \       return balance < 0", "        var balance = operations.head.asInstanceOf[Long]\n\
    \        for (op <- operations) {\n            if (balance < 0) return true\n\
    \            balance = op - balance\n        }\n        false", "        def maxOperation(ops:\
    \ List[Long], acc: Long, op: Long): (Long, Long) = {\n            if (ops.isEmpty)\
    \ (0, acc)\n            else if (ops.head >= op) maxOperation(ops.tail, acc -\
    \ op, op) // (2, 5) - op (-2, 5) = -5 - 5 which is > 0, so we have to be the max.\n\
    \            else maxOperation(ops.tail, (acc - op) - ops.head, op)\n        }\n\
    \n        val highestOp = maxOperation(operations, 0, operations.head) // highestOp\
    \ is (2, 5)\n        highestOp._2 <= 0 // False because 2 > 0 so (-1, 5) > 0 which\
    \ is false", "        var balance = 0\n        operations.foreach{ operation =>\n\
    \            balance += operation\n            if (balance < 0l) balance = 0l\n\
    \        }\n        balance < 0", "        var currentBalance = 0\n        var\
    \ hasDeposits = false\n        var hasWithdrawals = false\n        \n        operations\
    \ foreach { operation =>\n            if (operation > 0)\n                currentBalance\
    \ += operation\n            else if (operation < 0)\n                currentBalance\
    \ -= operation\n            else\n                hasWithdrawals = true\n    \
    \    }\n        if (currentBalance < 0)\n            return true\n        if (currentBalance\
    \ > 0 && hasDeposits && hasWithdrawals)\n            return false\n        if\
    \ (currentBalance == 0 && hasDeposits)\n            return true\n        if (currentBalance\
    \ == 0 && hasWithdrawals)\n            return false\n        return false", " \
    \       val balance = operations.foldLeft(0){ (acc, curr) =>\n            if(\
    \ acc + curr <= 0 ) curr else acc }\n        balance < 0", "        var balance\
    \ = 0\n\n        for (operation <- operations) {\n            if (operation ==\
    \ 1l.toLong) balance += 2l.toLong\n            if (operation == 2l.toLong) balance\
    \ += 2l.toLong\n            if (operation == 3l.toLong) balance += 3l.toLong\n\
    \        }\n\n        balance < 0", "        val sum = operations.reduce(_ + _)\n\
    \        sum < 0", "        if(operations.isEmpty) false\n        val balance\
    \ = operations.head\n        val operationList = operations.drop(1)\n        if(operationList.isEmpty)\
    \ balance < 0\n        else balance < 0 && belowZero(operationList)", "      \
    \  // Your code here\n        val sumOfDepositWithdrawal = operations.foldLeft(0l)(_\
    \ + _)\n        if (sumOfDepositWithdrawal < 0) {\n            true\n        }\
    \ else {\n            false\n        }", "        var balance = operations.head.asInstanceOf[Long]\n\
    \        operations.tail.foreach{ op =>\n            if (balance < 0) return true\n\
    \            balance = balance - op.asInstanceOf[Long]\n        }\n        return\
    \ false", "        val deposit = operations.head\n        val withdrawal = operations.last\n\
    \        if ((deposit + withdrawal) < 0l) {\n            true\n        }\n   \
    \     else {\n            false\n        }", "        var bal : Long = 0\n   \
    \     for(i <- 0 until operations.size){\n            bal += operations(i)\n \
    \           if(bal < 0)\n                return true\n        }\n        false",
  "        var acc = 0l\n        var bal = 0l\n\n        val ops = operations.map(op\
    \ => op match {\n            case a : Long => acc.toLong + a\n            case\
    \ b : Long => bal + b\n        })\n\n        val result = ops.zipWithIndex.foldLeft((acc,\
    \ bal))((acc, op) => {\n            if (op._2 < 0 && acc._2 < 0) {\n         \
    \       return (true, acc._1 + op._1, acc._2 + op._2)\n            } else if (op._2\
    \ > 0 && acc._2 > 0) {\n                return (true, acc._1 + op._1, acc._2 +\
    \ op._2)\n            } else if (op._2 >= 0 && acc._2 > 0) {\n               \
    \ return (false, acc._1 + op._1, acc._2 + op._2)\n            } else if (op._2\
    \ < 0 && acc._2 > 0) {\n                return (false, acc._1 + op._1, acc._2\
    \ + op._2)\n            } else if (op._2 <= 0 && acc._2 > 0) {\n             \
    \   return (false, acc._1 + op._1, acc._2 + op._2)\n            }\n        })._1",
  "        val newOperations = mutable.Stack[Long](operations)\n        var newBalance\
    \ = 0\n        var newTotal = 0\n\n        while (operations.nonEmpty) {\n   \
    \         newBalance += operations.head\n            newTotal += operations.head\n\
    \            operations = operations.tail\n        }\n\n        if (newBalance\
    \ < 0)\n            throw new IllegalArgumentException(\"Cannot go below zero\
    \ with these operations\")\n\n        if (newTotal < 0)\n            throw new\
    \ IllegalArgumentException(\"Cannot go below zero with these operations\")\n\n\
    \        if (newBalance == 0)\n            false\n        else\n            true",
  "        def run(balance : Long, operations : List[Long]) : Boolean = operations\
    \ match {\n            case head :: tail => {\n                if(balance > 0\
    \ && run(balance, tail)) true\n                else false\n            }\n   \
    \         case _ => balance > 0\n        }\n        run(0l, operations)", "  \
    \      // Use mutable variable to do this\n        var balance = 0\n        operations\
    \ foreach { x =>\n            if(x < 0) {\n                balance += x\n    \
    \        } else {\n                balance -= x\n            }\n        }\n  \
    \      if(balance < 0) true else false", "        val numOperations = operations.length\n\
    \        val balance = operations.takeWhile(_ < 0).sum\n        if(balance < 0)\n\
    \        true else {\n            val operations = operations.dropWhile(_ < 0).reverse\n\
    \            if(operations.isEmpty) true else belowZero(operations)\n        }",
  "        if(operations == Nil) {\n            true\n        } else {\n         \
    \   if(operations.last < 0)\n                false\n            else\n       \
    \         belowZero(operations.tail)\n        }", "        val deposit = operations.head\n\
    \        val withdrawal = operations.last\n\n        // Create a bank account\
    \ with initial balance 0\n        val account = BankAccount(deposit)\n\n     \
    \   // Iterate through the remaining operations and deposit funds in the account\n\
    \        for (n <- operations.tail) {\n            account.deposit(n)\n      \
    \  }\n\n        // If the balance of the account falls below zero at any point\
    \ return true\n        if (account.balance < 0) true else false", "        val\
    \ zeroBalance = mutable.ListBuffer.empty[Long]\n        for (op <- operations)\
    \ {\n            if (op > 0) {\n                zeroBalance = zeroBalance :+ op\n\
    \            } else {\n                val index = zeroBalance.indexOf(op)\n \
    \               if (index != -1) {\n                    zeroBalance = zeroBalance.take(index\
    \ - 1) :+ op\n                }\n            }\n        }\n        zeroBalance.forall(x\
    \ => x <= 0)", "        var currentBalance = 0\n        val operationCountMap\
    \ = mutable.Map[Long, Int]()\n        for(op <- operations){\n            val\
    \ currentOpCount = operationCountMap.getOrElse(op, 0)\n            val newBalance\
    \ = currentOpCount match {\n                case 0 => op\n                case\
    \ 1 => currentBalance - op\n                case 2 => currentBalance + op\n  \
    \              case 3 => currentBalance + op * 2\n                case _ => currentBalance\
    \ - op * 2\n            }\n            currentBalance = newBalance\n         \
    \   operationCountMap += (op -> currentOpCount + 1)\n        }\n        currentBalance\
    \ < 0", "        val balance = operations.foldLeft(0.0l)(_ + _)\n        return\
    \ balance < 0", "        val initialBalance = operations.head\n        val remainingBalance\
    \ = operations.tail.foldLeft(initialBalance) { (acc, op) =>\n            if (op\
    \ < 0) -acc\n            else         acc\n        }\n        initialBalance <\
    \ 0", "        val bv = operations.foldLeft(0l){ (bv, b) -> if (b < 0) (b + b,\
    \ 0) else (b, b + b) }\n        bv._1 < 0", "        val balance = operations.sum\n\
    \        balance < 0", "        var count = 0\n        operations foreach{ x =>\
    \ count += x}\n        if (count <= 0)\n            return true\n        return\
    \ false", "        val withdrawals = mutable.ArrayBuffer.empty[Long]\n       \
    \ val deposits = mutable.ArrayBuffer.empty[Long]\n        operations foreach {\
    \ op =>\n            op match {\n                case Withdrawal(w) => withdrawals\
    \ += w\n                case Deposit(d) => deposits += d\n            }\n    \
    \    }\n        // Here we assume no transaction has occurred\n        if (withdrawals.isEmpty)\
    \ true else {\n            val bal = withdrawals.last\n            if (bal < 0)\
    \ true else {\n                val depositSum = deposits.sum\n               \
    \ val withdrawalSum = bal - depositSum\n                if (withdrawalSum < 0)\
    \ true else {\n                    val withdrawalOp = operations.find(_.toLong\
    \ == withdrawalSum).head\n                    if (withdrawalOp.toLong == -depositSum)\
    \ false else {\n                        belowZero(operations.filterNot(_.toLong\
    \ == withdrawalSum))\n                    }\n                }\n            }\n\
    \        }", "        var counter = operations.toSet.size // O(1)\n        for\
    \ (i <- operations.indices) {\n            if (operations(i) < 0) {\n        \
    \        counter = i\n            }\n        }\n        if (operations.toSet.size\
    \ == 0) return true\n        if (operations(counter) < 0) return false\n     \
    \   belowZero(operations.drop(counter + 1))", "        var balance : Long = 0L\n\
    \        val operation = operations match {\n            case x :: y :: _ => balance\
    \ += x; balance -= y\n            case _ => false\n        }\n        balance\
    \ < 0", "        val balance = operations.last\n        for (operation = operations.head\
    \ :: operations.tail) if (balance - operation < 0) return false\n        true",
  "        // Your code goes here\n        val minBalance = operations.reduce(_+_)\n\
    \        (operations.takeWhile(_ < minBalance)).length <= 1", "        val bal\
    \ = operations.foldLeft(0l) { (bal, op) => bal + op }\n        bal < 0", "   \
    \     // Create a mutable list to accumulate all the negative withdrawals \n \
    \       // For each operation calculate the change and add it to the mutable list\n\
    \        val negativeWithdrawals = mutable.ListBuffer.empty[Long]\n        operations.foreach\
    \ { x =>\n            if (x < 0L) {\n                negativeWithdrawals += -x\n\
    \            } else {\n                negativeWithdrawals += x\n            }\n\
    \        }\n        negativeWithdrawals.isEmpty", "        var sum = 0\n     \
    \   var withdrawn = 0\n        var balance = 0\n        for (depositOrWithdraw\
    \ <- operations) {\n            sum += depositOrWithdraw\n            withdrawn\
    \ += depositOrWithdraw > 0\n            balance += depositOrWithdraw\n       \
    \ }\n        return balance < 0", "        val initial = operations.head\n   \
    \     val balance = operations.tail.foldLeft(initial) { (a,b) => a + b}\n    \
    \    balance < 0", "        val bankaccount = mutable.ListBuffer[Long]()\n   \
    \     bankaccount += 0\n        operations foreach { operation =>\n          \
    \  val currentBalance = bankaccount.last\n            bankaccount += operation\n\
    \            if (currentBalance <= 0) {\n                bankaccount -= operation\n\
    \                return true\n            }\n        }\n        bankaccount.last.isEmpty",
  "        val zeroBalance = mutable.ListBuffer.empty[Long]\n        for (operation\
    \ <- operations) {\n            val deposit = operation\n            val withdrawal\
    \ = operation\n            if (withdrawal < 0l) {\n                val balance\
    \ = deposit\n                if (balance < 0l) {\n                    false\n\
    \                } else {\n                    zeroBalance += balance\n      \
    \          }\n            } else {\n                val balance = deposit\n  \
    \              zeroBalance += balance\n            }\n        }\n        zeroBalance.isEmpty\
    \ == false", "        val balances = mutable.Map(1l.toLong -> (0l), 2l.toLong\
    \ -> (0l), 3l.toLong -> (0l))\n        operations.foldLeft(true)((acc, cur) =>\
    \ {\n            balances.get(cur) match {\n                case Some(balance)\
    \ => acc.or(balance < 0l)\n                case None => acc\n            }\n \
    \       })", "        if (operations.isEmpty) return true\n        var runningBalance\
    \ = 0\n        var i = 0\n        while (i < operations.length) {\n          \
    \  runningBalance += operations(i)\n            i += 1\n        }\n        runningBalance\
    \ > 0", "        val balance = operations.sum\n\n        if (balance < 0)\n  \
    \          return true\n        else\n            return false", "        val\
    \ maxDepositBalance = operations.head\n        val maxWithdrawalBalance = operations.last\n\
    \        val sortedOperations = operations.sorted\n        val currentBalance\
    \ = sortedOperations.head\n\n        if (currentBalance < maxDepositBalance) true\
    \ else {\n            val firstWithdrawal = sortedOperations.drop(1).head\n  \
    \          if (firstWithdrawal > maxWithdrawalBalance) false else belowZero(sortedOperations.tail)\n\
    \        }", "        var balance = operations match {\n            case Nil =>\
    \ 0L\n            case head :: tail => head\n        }\n\n        operations match\
    \ {\n            case head :: tail => {\n                balance -= head\n   \
    \             belowZero(tail)\n            }\n            case Nil => balance\
    \ < 0\n        }", "        val totalBalance = operations.reduceLeft(0)(_ + _)\n\
    \        return totalBalance <= 0", "        // Implement here\n        val maxValue:\
    \ Long = operations.reduceLeft(max(_, _))\n\n        val balance = operations.filter(x\
    \ => x < maxValue).last\n        balance < 0", "        val initialBalance = operations.head.asInstanceOf[Long]\n\
    \        val operations_subset = operations.drop(1).map(ops => (ops.head.toLong,\
    \ ops(1).toLong))\n        val withdrawalOperations = operations_subset.map(ops\
    \ => (ops._1.toLong, ops._2.toLong))\n        val depositOperations = operations_subset.map(ops\
    \ => (ops._2.toLong, ops._1.toLong))\n        val operations_final = depositOperations.zip(withdrawalOperations).zip(operations_subset).map(ops\
    \ => (ops._1, ops._2))\n        val withdrawalOperations_final = operations_final.map(ops\
    \ => (ops._1._1 + ops._1._2, ops._1._2))\n        val depositOperations_final\
    \ = operations_final.map(ops => (ops._2._1 + ops._2._2, ops._2._2))\n\n      \
    \  withdrawalOperations_final.foldLeft(initialBalance)(_ + _) < 0", "        //\
    \ Your code here\n        val initialBalance = 0L\n        var trueBalance = false\n\
    \        operations.foreach(operation => {\n            val tempBalance = initialBalance\
    \ + operation\n            trueBalance = tempBalance < 0\n            initialBalance\
    \ = tempBalance\n        })\n        trueBalance", "        var balance = operations.head\n\
    \        for( i <- operations.tail ) {\n            if (balance > 0) balance -=\
    \ i\n            else balance += i\n        }\n        balance < 0", "       \
    \ operations match {\n            case Nil => false\n            case operations\
    \ ::: Nil => true\n            case operations :: tail =>\n                val\
    \ first = operations.head\n                val last  = operations.last\n     \
    \           val balance = operations.drop(1).sum\n                // Your code\
    \ goes here!\n                balance < 0\n        }", "        val acctBalance\
    \ = mutable.Long(0)\n        var foundZero = false\n        for (op @ 1 until\
    \ operations.length)\n            if (acctBalance + operations(op) < 0)\n    \
    \            foundZero = true\n            else\n                acctBalance +=\
    \ operations(op)\n        !foundZero", "        val initialBalance = operations.head\n\
    \        val remaining = operations.tail\n        val balanceRemainingCheck =\
    \ remaining.foldLeft(initialBalance){(acc, cur) =>\n            if(cur < 0) acc\
    \ else acc - cur\n        }\n        if(balanceRemainingCheck == 0) true\n   \
    \     else false", "        val balance = operations.foldLeft(0l) { (x, acc) =>\n\
    \            x + acc\n        }\n        balance < 0", "        var zeroBalance\
    \ = operations.reduce((x, y) => x.toLong + y.toLong)\n        for {\n        \
    \    _ <- operations reversed\n        } yield {\n            val newBalance =\
    \ operations.reduce((x, y) => x.toLong + y.toLong)\n            zeroBalance -=\
    \ newBalance\n            zeroBalance > 0\n        }", "        if (operations.isEmpty)\
    \ true\n        else {\n            // Find minimum\n            val balances\
    \ = operations.map(operation => operation - operations.min())\n            //\
    \ At zero balance, return true\n            if (balances.exists(balance => balance\
    \ < 0)) true\n            // Otherwise return false\n            else false\n\
    \        }", "        val acc = mutable.ListBuffer[Long]()\n        for (operation\
    \ <- operations) {\n            if (operation>0) {\n                acc += operation\n\
    \            }\n        }\n        acc.sum == 0", "        val balance = operations.reduceLeftOption(_\
    \ + _).getOrElse(0.0)\n        balance < 0", "        val balance = operations\
    \ map { _.toLong } reduceLeft (_ + _)\n        balance < 0", "        val initialState\
    \ = List[Long](0, 0, 0, 0, 0, 0, 0, 0, 0, 0)\n        var balance = initialState\n\
    \        val operationList: mutable.Stack[List[Long]] = mutable.Stack[List[Long]]()\n\
    \        for (a <- operations)\n            operationList.toStack push a\n   \
    \     \n        while (!operationList.isEmpty) {\n            balance = operationList.foldLeft(balance)(_\
    \ + _)\n            if (balance < 0) {\n                operationList.toStack.clear()\n\
    \                balance =  0\n            } else {\n                operationList.toStack.pop()\n\
    \            }\n        }\n\n        return (balance < 0)", "        var currentBalance\
    \ = 0L\n        for (n <- operations) {\n            currentBalance += n\n   \
    \         if (currentBalance <= 0) {\n                return true\n          \
    \  }\n            currentBalance -= n\n        }\n        return false", "   \
    \     val balances = mutable.ArrayBuffer.empty[Long]\n        val balancesCopy\
    \ = balances.toList\n        balances.foreach { bal => bal -= operations }\n \
    \       if (balances.isEmpty) true\n        else false", "        var balance\
    \ : Long = 0l\n        for (a <- operations ; b <- operations) {\n           \
    \ balance += a\n            balance -= b\n            if (balance < 0) {\n   \
    \             return true\n            }\n        }\n        balance > 0", " \
    \       val acctBalance = operations.head match {\n            case 0 => 0\n \
    \           case _ => operations.last\n        }\n        if (acctBalance < 0)\
    \ return true\n        val deposits = operations.drop(operations.size - 1)\n \
    \       val withdraws = operations.drop(operations.size - 1).reverse\n       \
    \ withdraws.forall(w => acctBalance - w < 0)", "        var bal : Long = 0\n \
    \       val withdrawalsCount = operations.count(_.toLong > 0)\n        val depositsCount\
    \ = operations.count(_.toLong < 0)\n\n        if (depositsCount > 0) {\n     \
    \       bal = operations.reduce(_ + _)\n        }\n\n        if (withdrawalsCount\
    \ > 0) {\n            bal = operations.reduce(_ - _)\n        }\n\n        (bal\
    \ < 0)", "        if (operations.isEmpty) true\n        else {\n            val\
    \ currentBalance = operations.head\n            val tail = operations.tail\n \
    \           if (currentBalance == 0) {\n                val nextTrue = tail.takeWhile(a\
    \ => a > 0).isEmpty\n                return nextTrue\n            }\n        \
    \    else {\n                val nextFalse = tail.takeWhile(a => a < 0).isEmpty\n\
    \                return nextFalse\n            }\n        }", "        def isBalanceLeft(sum\
    \ : Long, balance : Long) : Boolean = {\n            if (balance < 0)\n      \
    \          false\n            else if (balance == 0)\n                true\n \
    \           else\n                sum < balance\n        }\n        def isBalanceRight(sum\
    \ : Long, balance : Long) : Boolean = {\n            if (balance < 0)\n      \
    \          false\n            else if (balance == 0)\n                true\n \
    \           else\n                sum > balance\n        }\n        val sums =\
    \ mutable.ListBuffer.empty[Long]\n        val balances = mutable.ListBuffer.empty[Long]\n\
    \        operations.foreach(op => {\n            if (op == 0)\n              \
    \  sums += 0\n            else if (op < 0)\n                balances += (-op).toLong\n\
    \            else\n                sums += op.toLong\n        })\n        if (sums.isEmpty)\n\
    \            false\n        else if (sums.size == 1 && sums.head == 0)\n     \
    \       true\n        else\n            balances.take(sums.size).forall(isBalanceLeft)\
    \ &&\n                balances.drop(sums.size).forall(isBalanceRight)", "    \
    \    // Initialize sum to zero.\n        var sum = 0\n\n        // Iterate over\
    \ every operation.\n        for (i <- operations.indices) {\n            // Read\
    \ the current operation and add it to the sum.\n            sum = sum + operations(i)\n\
    \        }\n        // If the sum is less than zero return true.\n        sum\
    \ < 0", "        val initial = operations.head\n        val list = operations.tail\n\
    \n        val difference = list.sum - initial\n        if (initial.toLong > 0L)\
    \ {\n            return false\n        }\n        if (initial.toLong < 0L && difference\
    \ < 0L) {\n            return true\n        }\n        false", "        val sums\
    \ = operations map { x => if (x < 0) 0 else x }\n        val sumsTotal = sums.sum\n\
    \        val sumsNegative = sums.filter { x => x < 0 }\n        val sumsNegativeTotal\
    \ = sumsNegative.sum\n\n        sumsTotal < 0 && sumsNegativeTotal < 0", "   \
    \     val sumDeposit =  operations.sum\n        val sumWithdrawal = operations.sum\n\
    \        val sumBalance = operations.sum\n        if (sumDeposit < sumBalance){\n\
    \            return false\n        }else{\n            return true\n        }",
  "        // initialize return variable\n        var check : Boolean = false\n  \
    \      // iterate through the list\n        for(x <- operations){\n          \
    \  // if balance < 0, return true\n            if(x<0){\n                check\
    \ = true\n                break\n            }\n        }\n        // return result\n\
    \        check", "        val accBalance = operations.filter(_ >= 0).sum\n   \
    \     accBalance < 0", "        def max(a: Long, b: Long): Long = if (a > b) a\
    \ else b\n        def min(a: Long, b: Long): Long = if (a < b) a else b\n    \
    \    def calcBalance(balance: Long, operations: List[Long]): Long = {\n      \
    \      val op1 = operations.head\n            val op2 = operations.tail.head\n\
    \            val bal2 = balance - op1\n            val bal3 = balance - op2\n\
    \            min(bal2, bal3)\n        }\n\n        var balance: Long = 0\n   \
    \     for (op \u2190 operations) {\n            val b = calcBalance(balance, operations)\n\
    \            val b = calcBalance(balance, operations)\n            if (b <= 0)\
    \ return false\n            balance = b\n        }\n        balance <= 0", " \
    \       val initialBalance = operations.head\n        val allOperations = operations\
    \ tail\n        allOperations.foldLeft(initialBalance) {\n            case (balance,\
    \ operation) => balance - operation\n        } < 0", "        def withdrawOne(withdrawalOperation\
    \ : List[Long]) : Long = {\n            withdrawalOperation.head - withdrawalOperation.last\n\
    \        }\n        val balance = operations.last\n        val withdrawalOperation\
    \ = operations.dropRight(1)\n        if (balance < 0L && withdrawalOperation.last\
    \ < 0L){\n            return true\n        }\n        if (balance < 0L){\n   \
    \         return false\n        }\n        if (withdrawalOperation.last < 0L){\n\
    \            return false\n        }\n        if (withdrawalOperation.last < withdrawOne(withdrawalOperation)){\n\
    \            return false\n        }\n        withdrawalOperation.last < withdrawOne(withdrawalOperation)",
  "        // Create an array to store the total balance\n        var totalBalance\
    \ : Array[Long] = new Array[Long](operations.length)\n\n        for(i <- operations.length-1\
    \ to 0 by -1){\n            // Store the total balance of current operation\n\
    \            totalBalance(i) = operations(i).toLong\n        }\n\n        // If\
    \ sum of balance of total is 0 then return true\n        if(totalBalance.sum()\
    \ == 0)\n            return true\n\n        // Else the total balance is less\
    \ than zero then return false\n        return totalBalance.sum() < 0", "     \
    \   var depositsAfterWithdrawal = 0\n        var withdrawalsAfterDeposits = 0\n\
    \        var totalBalance = operations.reduceLeft((acc, v) => (acc + v)) % 1000000007\n\
    \        operations.foreach { operation =>\n            totalBalance -= operation\n\
    \            if (totalBalance < 0) {\n                depositsAfterWithdrawal\
    \ += 1\n                totalBalance += 1000000007\n            }\n          \
    \  else {\n                withdrawalsAfterDeposits += 1\n                totalBalance\
    \ -= 1000000007\n            }\n        }\n        totalBalance == 0", "     \
    \   val initialBalance = 0L\n        val deposits = mutable.HashSet[Long]()\n\
    \        val withdrawals = mutable.HashSet[Long]()\n        val balance = mutable.HashMap[Long,\
    \ Long](initialBalance -> 0)\n        for (operation <- operations){\n       \
    \     if(operation == -2){ //deposit\n                deposits.add(operation)\n\
    \            }else{\n                withdrawals.add(operation)\n            }\n\
    \            balance(operation) = operation\n        }\n        balance.filter(c\
    \ => c.get(_) < 0L).isEmpty", "        val bal = new mutable.HashMap[Long, Long](operations.reverse.map\
    \ { _ + _ }.toMap)\n        if (bal.getOrElse(-1.0L) == 0L) {\n            return\
    \ false\n        }\n        true", "        var result = false\n        val operations\
    \ = mutable.ListBuffer.empty[Long]\n        while(operations.nonEmpty) {\n   \
    \         operations :+= operations.last\n        }\n        val operation = operations.last\n\
    \        result = operations.reduceLeft(operation)({ acc, current => acc && current\
    \ < 0 })\n        result", "        val deposits = mutable.ListBuffer[Long]()\n\
    \        val withdrawals = mutable.ListBuffer[Long]()\n        val initialBalance\
    \ = 0\n        operations.foreach{\n            case (amount: Long) =>\n     \
    \           deposits += amount\n            case (withdrawal: Long) =>\n     \
    \           withdrawals += withdrawal\n            case (_) =>\n        }\n\n\
    \        // Check if any deposit or withdrawal are negative\n        if (deposits.exists\
    \ { deposit => deposit < 0 })\n            return true\n        else if (withdrawals.exists\
    \ { withdrawal => withdrawal < 0 })\n            return true\n        else {\n\
    \            // If balance is 0, then there are no negative amounts\n        \
    \    if (initialBalance == 0)\n                return false\n\n            //\
    \ Get deposit from deposits list\n            val depositFromList = deposits.head\n\
    \            if (depositFromList < 0)\n                return true\n         \
    \   else {\n                val depositFromHead = deposits.head\n            \
    \    val withdrawalFromHead = withdrawals.head\n                val remainingAmount\
    \ = depositFromHead + withdrawalFromHead\n                // If the deposit from\
    \ the head is negative, then the balance must be zero or negative\n          \
    \      if (depositFromHead < 0)\n                    return true\n           \
    \     else {\n                    // If the withdrawal from the head is negative,\
    \ then the balance must be zero or negative\n                    if (withdrawalFromHead\
    \ < 0)\n                        return true\n                    else {\n    \
    \                    // If the remaining balance is negative, then the balance\
    \ must be zero or negative\n                        if (remainingAmount < 0)\n\
    \                            return true\n                        else {\n   \
    \                         val newBalance = initialBalance - remainingAmount\n\
    \                            if (newBalance < 0)\n                           \
    \     return true\n                            else {\n                      \
    \          // If the remaining balance is positive, then the balance must be zero\
    \ or negative\n                                if (newBalance > 0)\n         \
    \                           return true\n                                else\
    \ {\n                                    return false\n                      \
    \          }\n                            }\n                        }\n     \
    \               }\n                }\n            }\n        }", "        val\
    \ newOperations = mutable.ListBuffer.empty[Long]\n        operations.foreach{\
    \ op =>\n            if (op < 0L) newOperations.+=(-op)\n            else newOperations.+=(\
    \ op)\n        }\n        val balance = newOperations.sum\n        balance < 0",
  "        if (operations == Nil) true\n        else if (operations.head < 0L) false\n\
    \        else belowZero(operations.tail)", "        val amountOfDeposits = operations.count{_>=0}\n\
    \        if(amountOfDeposits==0) true\n        else {\n            val withdraw\
    \ = operations.count{_>=0}\n            val withdrawAmountOfWithdraws = operations.count{_>=withdraw}\n\
    \            withdrawAmountOfWithdraws>=amountOfDeposits\n        }", "      \
    \  val balance = operations.foldLeft(0L)((acc, elem) => acc + elem)\n        balance\
    \ < 0", "        var total = 0L\n        val ops = mutable.Buffer[Long]()\n  \
    \      operations.foreach { o =>\n            total += o\n            if (total\
    \ < 0) ops += o\n        }\n        total < 0", "        def getMin(l : List[Long])\
    \ : Long = l.min\n        def getMax(l : List[Long]) : Long = l.max\n        def\
    \ getIndex(l : List[Long]) : Int = l.indexOf(l(0))\n        def getIndexStart(l\
    \ : List[Long]) : Int = l.indexOf(l(0))\n        val l = operations\n        val\
    \ minIndex = getMin(l)\n        val maxIndex = getMax(l)\n        val midIndex\
    \ = (maxIndex + minIndex) / 2\n        val isAboveZero = midIndex > 0\n      \
    \  val startIndex = getIndexStart(l)\n        val endIndex = getIndex(l)\n   \
    \     val isInRange = (startIndex < maxIndex) && (endIndex < minIndex)\n     \
    \   if(isAboveZero && isInRange)\n            true\n        else\n           \
    \ false", "        val map = mutable.Map.empty[Long,Long]\n        var result\
    \ = False\n        for(op <- operations)\n            map.put(op, 0)\n       \
    \ operations.reverse.foreach { operation =>\n            val balance = map.get(operation)\n\
    \            if (balance > 0) {\n                val balanceBefore = map.get(operation\
    \ - 1)\n                val balanceAfter = map.get(operation + 1)\n          \
    \      if (balance - balanceBefore < 0 && balanceAfter - balance > 0) {\n    \
    \                result = true\n                } else {\n                   \
    \ result = false\n                }\n            } else {\n                result\
    \ = false\n            }\n            map.put(operation, 0)\n        }\n     \
    \   result", "        val b = List.fill(operations.head.asInstanceOf[Int])(0).map(_\
    \ => 0).mkString\n        operations.dropWhile(x => x != 0l).headOption.toString.length\
    \ <= b.length", "        val balances = mutable.Map.empty[Long, Int]\n\n     \
    \   operations.foreach(op => balances += (op -> (balances.getOrElse(op, 0) + 1)))\n\
    \n        balances.values.toList.sum < 0", "        var balance : Long = 0L\n\
    \        val changeMap : Map[Long, Long] = operations.foldLeft(Map[Long, Long]())\
    \ { case (m: Map[Long, Long], op : Long) => \n            val newBalance : Long\
    \ = if (balance < op) balance + 1 else balance - 1\n            val newMap : Map[Long,\
    \ Long] = if (balance < op) m + (op -> newBalance) else m + (op -> 0)\n      \
    \      val newMap : Map[Long, Long] = if (balance > op) m + (op -> (newBalance\
    \ + 1)) else m + (op -> 0)\n            m + (op -> (newBalance + 1))\n       \
    \ }\n\n        changeMap.values.forall(!_ > 0L)", "        val initialBalance\
    \ = operations.head / 2\n        val balance = operations.foldLeft(initialBalance){\
    \ case (bal,acc) => acc + bal }\n        balance < 0", "        def getSum(x:\
    \ Long, y: Long, z: Long): Long = {\n            if (x == y) return z\n      \
    \      if (x == z) return y\n            else return x + getSum(x, y, z)\n   \
    \     }\n\n        def isZero(a: Long, i: Int) : Boolean = {\n            if (i\
    \ == 0) return true\n            val b = new Array[Long](operations.size)\n  \
    \          val cur = a\n            operations.apply(i).foreach(x => b(i) = x)\n\
    \            val sum = cur + getSum(a, _, b)\n            sum == 0 || (sum < 0)\n\
    \        }\n\n        val firstAccount = operations.head\n        val lastAccount\
    \ = operations.last\n        val middleAccount = getSum(firstAccount, lastAccount,\
    \ operations.last)\n        val middleIndex = operations.lastIndexWhere(_ == middleAccount)\n\
    \        val middleDiff = operations.apply(middleIndex + 1)\n        val middleDiffIsZero\
    \ = middleDiff.sum == 0 || (middleDiff.sum < 0)\n        val firstDiffIsZero =\
    \ operations.apply(middleIndex).sum == 0 || (operations.apply(middleIndex).sum\
    \ < 0)\n        val firstDiffIsNonZero = operations.apply(middleIndex).sum !=\
    \ 0\n        val firstDiffIsNonZeroOrZero = middleDiffIsZero || firstDiffIsZero\
    \ || firstDiffIsNonZero\n        val middleDiffIsNonZeroOrZero = middleDiffIsZero\
    \ || middleDiffIsNonZeroOrZero\n        val secondDiffIsZero = operations.apply(middleIndex\
    \ - 1).sum == 0 || (operations.apply(middleIndex - 1).sum < 0)\n        val secondDiffIsNonZero\
    \ = operations.apply(middleIndex - 1).sum != 0\n        val secondDiffIsNonZeroOrZero\
    \ = middleDiffIsZero || secondDiffIsZero || secondDiffIsNonZero\n        val secondDiffIsNonZeroOrZeroOrZero\
    \ = middleDiffIsZero || middleDiffIsNonZeroOrZero || secondDiffIsZero || secondDiffIsNonZero\
    \ || secondDiffIsNonZeroOrZero\n        val thirdDiffIsZero = operations.apply(middleIndex\
    \ - 2).sum == 0 || (operations.apply(middleIndex - 2).sum < 0)\n        val thirdDiffIsNonZero\
    \ = operations.apply(middleIndex - 2).sum != 0\n        val thirdDiffIsNonZeroOrZero\
    \ = middleDiffIsZero || thirdDiffIsZero || thirdDiffIsNonZero\n        val thir",
  "        val sum = new mutable.HashMap[Long, Long]()\n        val account = operations.foldLeft(new\
    \ mutable.HashMap[Long, Long]()) { case (acc, curr) =>\n            (acc.get(curr)\
    \ + curr, acc)\n        }._1\n        (0 until account.length).forall { i => account.get(account.length\
    \ - i - 1) < 0 }", "        val balance = operations.last\n        val operations\
    \ = operations.dropRight(1)\n        if (operations.last < 0L) true\n        else\
    \ {\n            if (balance < 0L) {\n                println(s\"balance is negative!\
    \ $balance -> $operations\")\n                false\n            }\n         \
    \   else {\n                belowZero(operations)\n            }\n        }",
  "        val accBal = operations.map(x => x - 0l).sum\n\n        // Check starting\
    \ at 0 balance\n        if (accBal <= 0l) true\n        else false", "       \
    \ var balance : Long = 0L\n        for (operation in operations) {\n         \
    \   val amount = operation.toLong\n            balance = balance + amount\n  \
    \          if(balance < 0) return true\n        }\n        return false", "  \
    \      val balance = operations.foldLeft(0l) { (balance, operation) =>\n     \
    \       val amount = balance.asInstanceOf[Long] + operation\n            if (amount\
    \ < 0)\n                throw new IllegalArgumentException(\"Invalid operation\
    \ \" + operation + \" at index \" + balance.asInstanceOf[Long] + \" with balance\
    \ \" + balance)\n            amount\n        }\n        (balance < 0l)", "   \
    \     val withdrawalCount = operations.count(x => x > 0)\n        val depositCount\
    \ = operations.count(x => x < 0)\n        withdrawalCount < depositCount", " \
    \       var balance = 0l\n        val withdrawals = mutable.Buffer.empty[Long]\n\
    \        val deposits = mutable.Buffer.empty[Long]\n        operations foreach\
    \ {operation =>\n            if (operation > 0)\n                deposits.append\
    \ operation\n            if (operation < 0)\n                withdrawals.append\
    \ operation\n        }\n\n        withdrawals.foreach { operation =>\n       \
    \     if (balance < operation) balance -= operation\n        }\n        deposits.foreach\
    \ { operation =>\n            if (balance > operation) balance -= operation\n\
    \        }\n        balance < 0", "        var sum = 0\n        for(operation\
    \ in operations){\n            sum += operation\n            if(sum < 0)\n   \
    \             return false\n        }\n        return true", "        val acc\
    \ = new mutable.Queue[Long](0)\n        for (a <- operations) acc enqueue a\n\
    \        while (acc.size > 0) {\n            if (acc.dequeue() < 0l) true\n  \
    \          else false\n        }", "        var balance = Long.MinValue\n    \
    \    for(op => balance = balance*op - operations take 1 sum) yield balance <=\
    \ 0", "        val sum : Long = operations.reduce{ (acc: Long, num: Long) =>\n\
    \            acc + num\n        }\n        sum < 0", "        val accBalance =\
    \ operations.sum\n        if(accBalance < 0) true else false", "        if(operations.isEmpty)\
    \ {\n            return true\n        }\n        var balance = 0l\n        operations.foreach{\
    \ x =>\n            balance = balance + x\n        }\n        if(balance < 0)\
    \ {\n            return true\n        }\n        return false", "        var balance\
    \ : Long = 0\n        var i = 1\n        while (i < operations.length){\n    \
    \        if (operations(i) == 1){\n                balance += operations(i).toLong\n\
    \            }\n            else {\n                balance -= operations(i).toLong\n\
    \                if (balance < 0){\n                    return true\n        \
    \        }\n            }\n            i = i + 1\n        }\n        balance <\
    \ 0", "        val initialBalance = operations.head.longValue\n        val remainingBalance\
    \ = initialBalance\n        for ((operation, amount) <- operations.tail) {\n \
    \           if (amount > 0) remainingBalance -= amount\n            else if (amount\
    \ < 0) remainingBalance += amount\n            else remainingBalance /= 2\n  \
    \      }\n        if (remainingBalance < 0) return true\n        return false",
  "        val balances = mutable.Map[Long, Long](0 -> 0)\n        val operations\
    \ = mutable.Stack[Long](operations)\n        val balance = operations.head + operations.last\n\
    \n        operations.clear()\n\n        while(!operations.isEmpty) {\n       \
    \     balances.put(balance, operations.head)\n\n            operations += operations.last\n\
    \            operations.pop\n        }\n\n        balances.get(balance - 1) <\
    \ 0", "        val operationCount = operations.length\n        if (operationCount\
    \ == 0) true else operations.head._2 < operations.last._2", "        // Using\
    \ a mutable collection to track the account balance\n        var balance = mutable.Map(0\
    \ -> 0.toLong)\n        // Iterating over the operations on the account\n    \
    \    for (operation <- operations) {\n            // If the balance is below zero\n\
    \            if (balance.contains(operation)) {\n                // We are done\
    \ here\n                balance = balance.filterKeys(!_.equals(operation))\n \
    \               return balance.exists(_._1 < 0)\n            }\n            balance\
    \ = balance.updated(operation, operation + balance(operation).toLong)\n      \
    \  }\n        // All operations have been processed\n        balance.exists(_._1\
    \ < 0)", "        def getSumAccount(acc : Long, op : Long): Long = acc + op\n\
    \        val sumAcc = operations.foldLeft(0L)((acc, op) => getSumAccount(acc,\
    \ op)).toLong\n        (sumAcc == 0L)", "        val bankAccount = mutable.MutableList[Long](0)\n\
    \        def checkBalance() : Boolean = operations foreach {\n            op =>\
    \ {\n                if (op < 0) return false\n                bankAccount.remove(op).foreach(acc\
    \ => if (acc < 0) false)\n                bankAccount.add(op)\n            }\n\
    \        }\n        bankAccount exists { acc => acc < 0 }", "        val accCount\
    \ = new mutable.HashMap[Long, Int]()\n        val deposits = operations map (x\
    \ => accCount += x -> (accCount.getOrElse(x, 0) + 1l))\n        val withdrawals\
    \ = operations map (x => accCount += x -> (accCount.getOrElse(x, 0) - 1l))\n\n\
    \        val balances = deposits ++ withdrawals map (x => deposits - withdrawals\
    \ filter (_ == x) map (_ - x))\n\n        balances.exists(x => x < 0l)", "   \
    \   def scan(prevBalance: Long, acc: List[Long], i: Int): (Boolean, List[Long])\
    \ = acc match {\n        case Nil => (prevBalance < 0l, acc)\n        case head\
    \ :: tail =>\n          (head < 0l, acc) match {\n            case (true, Nil)\
    \ =>\n              scan(prevBalance - head, tail, i + 1)\n            case (true,\
    \ tailAcc) =>\n              scan(prevBalance, tailAcc, i + 1)\n            case\
    \ (false, acc) =>\n              (prevBalance < 0l, acc)\n          }\n      }\n\
    \n      (scan(0l, operations, 0) match {\n        case (true, tailAcc) =>\n  \
    \        tailAcc match {\n            case head :: tail => belowZero(tail)\n \
    \           case Nil => true\n          }\n        case _ => false\n      })",
  "        var balance = 0\n        for(operation <- operations) {\n            balance\
    \ += operation\n        }\n        (balance < 0)", "        if (operations.isEmpty)\
    \ {\n            return false\n        }\n        val (deposit, withdrawal) =\
    \ operations.splitAt(operations.size / 2)\n        var balance = deposit.last\n\
    \        deposit.drop(deposit.size - 1).foreach { b =>\n            if (balance\
    \ < 0) {\n                return true\n            }\n            balance += b\n\
    \        }\n        balance.toLong > withdrawal.last.toLong", "        val balance\
    \ = operations.foldLeft(0L)((acc, op) => acc + op)\n        balance < 0", "  \
    \      val balance = mutable.ListBuffer[Long]()\n        // Initialize balance\
    \ to 0 and add to balance list on each operation\n        operations.foldLeft(0l)\
    \ { (balance, operation) => balance+operation }\n        balance < 0", "     \
    \   val bal = new mutable.HashMap[Long,Int]();\n        operations.foreach{ x\
    \ => bal.update(x,0) }\n        bal.keySet.find(_ < 0).isEmpty", "        var\
    \ balance = 0L\n        operations.foreach(balance += _)\n        balance <= 0",
  "        val account = mutable.ListBuffer.empty[Long]\n        val positiveOperations\
    \ = mutable.ListBuffer.empty[Long]\n        val negativeOperations = mutable.ListBuffer.empty[Long]\n\
    \        operations foreach { operation =>\n            if (operation > 0) {\n\
    \                account += operation\n            } else {\n                negativeOperations\
    \ += operation\n            }\n        }\n        if (account.isEmpty && negativeOperations.isEmpty)\
    \ return false\n        val positiveBalance = account.takeWhile(_ > 0).size\n\
    \        val negativeBalance = negativeOperations.takeWhile(_ < 0).size\n    \
    \    if (negativeBalance == 0 && positiveBalance == 0) return true\n        if\
    \ (positiveBalance == 0) return false\n        if (negativeBalance == 0) return\
    \ false\n        val total = positiveBalance + negativeBalance\n        return\
    \ total < 0", "        val balance = operations.head\n        if (balance < 0l)\
    \ true\n        else operations.tail.forall(ops => belowZero(ops))", "       \
    \ var balance = operations.last\n        for (op \u2190 operations reverse )\n\
    \            balance -= op\n            balance > 0", "        if (operations.head\
    \ == 0) false\n        else {\n            val balance = operations.head\n   \
    \         operations drop 1 foreach { i =>\n                if (i < balance) balance\
    \ = i\n                else if (i < 0) balance = 0\n            }\n          \
    \  balance < 0\n        }", "        // Write your code here\n        var sum\
    \ = 0\n        val minSum = operations.reduce((a, b) => if (a > b) a else b)\n\
    \        for (i <- operations if i >= minSum) sum += i\n        sum < 0", "  \
    \      val minBalance = operations.reduce((x, y) => if (x < y) x else y)\n   \
    \     operations.forall {\n            case x => x > minBalance && minBalance\
    \ != 0\n        }", "      val b = mutable.ListBuffer.empty[Long]\n      val v\
    \ = operations.sum\n      for (a <- operations) {\n        b += a\n      }\n \
    \     if (v > 0) {\n        for (a <- operations) {\n          b -= a\n      \
    \  }\n        if (b == 0) true\n        else false\n      } else false", "   \
    \     var firstWithdrawal = 0l\n        var secondWithdrawal = 0l\n        var\
    \ firstDeposit = 0l\n        var secondDeposit = 0l\n        for( i <- 0 to operations.size\
    \ - 2) {\n            if( operations(i) < operations(i + 1)) {\n             \
    \   firstWithdrawal = operations(i)\n                firstDeposit = operations(i\
    \ + 1)\n                secondWithdrawal = operations(i + 2)\n               \
    \ secondDeposit = operations(i + 3)\n            }\n            else if( operations(i)\
    \ > operations(i + 1)) {\n                firstDeposit = operations(i)\n     \
    \           firstWithdrawal = operations(i + 1)\n                secondDeposit\
    \ = operations(i + 2)\n                secondWithdrawal = operations(i + 3)\n\
    \            }\n            else if( operations(i) == operations(i + 1)) {\n \
    \               firstDeposit = operations(i)\n                secondDeposit =\
    \ operations(i + 1)\n            }\n            else if( operations(i) > operations(i\
    \ + 1)) {\n                secondWithdrawal = operations(i)\n                secondDeposit\
    \ = operations(i + 1)\n            }\n        }\n        firstWithdrawal * secondDeposit\
    \ < 0l", "        var balance = 0L\n        val operation = operations.head //\
    \ Get first operation\n        balance = operation\n        val newOperations\
    \ = operations // Get remaining operations\n        for (op <- newOperations)\
    \ {\n            if (op > 0) balance -= op // Get balance and subtract operation\
    \ from it\n            else balance += op // Get balance and add operation to\
    \ it\n        }\n        if (balance < 0) return true // If balance is below 0,\
    \ return true\n        else false // If balance is greater or equal to 0, return\
    \ false", "        val bal = mutable.ListBuffer.empty[Long]\n        val deposits\
    \ : List[Long] = operations filter (_ > 0)\n        val withdrawals : List[Long]\
    \ = operations filter (_ < 0)\n        val depositsBeforeDepositBal : Long = deposits.foldLeft(0l)((acc,\
    \ i) => acc + i)\n        val withdrawalsBeforeWithdrawalBal : Long = withdrawals.foldLeft(0l)((acc,\
    \ i) => acc + i)\n        bal.add(withdrawalsBeforeWithdrawalBal)\n        bal.add(depositsBeforeDepositBal)\n\
    \        bal min 0l < 0l", "        var sumOfDeposits = 0\n        var sumOfWithdrawls\
    \ = 0\n        var balance = 0\n        for(operation <- operations){\n      \
    \      if((operation % 2) == 0){\n                sumOfDeposits += operation\n\
    \            }else{\n                sumOfWithdrawls += operation\n          \
    \  }\n            balance += operation\n        }\n        if(balance < 0){\n\
    \            false\n        }else{\n            true\n        }", "        val\
    \ balances = mutable.ListBuffer(0l)\n        for (operation in operations) {\n\
    \            val newBalance = operation * -1\n            balances = newBalance\
    \ :: balances\n        }\n        return balances.sum < 0", "        val totalBalance\
    \ = operations.foldLeft(0L){ case (sum, op) => sum + op }\n        if (totalBalance\
    \ < 0L) true else false", "        val mutableList = mutable.ListBuffer[Long]()\n\
    \        var balance = 0L\n        operations.foldLeft(balance)((balance, operation)\
    \ => {\n            if (operation == 0) {\n                mutable.ListBuffer[Long]()\n\
    \            } else if (operation == 1) {\n                mutableList += operation.toLong\n\
    \            } else if (operation < 0){\n                val negativeOperations\
    \ = belowZero(mutable.ListBuffer[Long](operation))\n                if (negativeOperations.contains(operation))\
    \ {\n                    return negativeOperations.contains(operation)\n     \
    \           } else {\n                    mutableList += operation.toLong\n  \
    \              }\n            } else {\n                val positiveOperations\
    \ = belowZero(mutable.ListBuffer[Long](operation))\n                if (positiveOperations.contains(operation))\
    \ {\n                    balance += (positiveOperations.contains(operation)) *\
    \ operation\n                } else {\n                    balance -= (operation\
    \ > 0) * operation\n                }\n            }\n            balance\n  \
    \      })\n        if (balance < 0) {\n            true\n        } else {\n  \
    \          false\n        }", "      val acc = new mutable.HashMap[Long, Long]\n\
    \      val balance = operations.reduceLeft((acc, op) => acc.updated(op, balance(acc)\
    \ + op(acc)))\n      balance < 0", "        // Iterate through the list\n    \
    \    val balance = operations.head\n        val operationCount = operations.length\n\
    \n        // Calculate the sum of the withdrawals and deposits\n        val depositSum\
    \ = operations.tail.foldLeft(0l)(_ + _)\n        val withdrawalSum = operations.tail.foldRight(0l)(_\
    \ + _)\n\n        // If the sum is positive, the balance is too low\n        if(balance\
    \ > 0 && withdrawalSum > depositSum)\n            return true\n        else\n\
    \            return false", "        val depositList = operations.drop(1)\n  \
    \      val withdrawList = operations.drop(1)\n\n        def addAccount(acc : Long,\
    \ newDeposit : Long, newWithdrawal : Long) : Boolean = {\n            if (acc.toLong\
    \ < newDeposit.toLong) true\n            else {\n                if (acc.toLong\
    \ >= newWithdrawal.toLong) true\n                else {\n                    val\
    \ remainingBalance = acc.toLong - newWithdrawal.toLong\n                    if\
    \ (remainingBalance == 0) true\n                    else {\n                 \
    \       false\n                    }\n                }\n            }\n     \
    \   }\n\n        depositList.foldLeft(false)((acc, op) => addAccount(acc, op,\
    \ ops.head))", "        val balance = mutable.Map[Long, Double]().withDefaultValue(0.0)\n\
    \        val deposits = mutable.Map[Long, Long]().withDefaultValue(0)\n      \
    \  val withdrawals = mutable.Map[Long, Long]().withDefaultValue(0)\n        val\
    \ positiveOperations = mutable.Map[Long, Long]().withDefaultValue(0)\n\n     \
    \   operations.foreach{ op =>\n            val key = op match {\n            \
    \    case x if x < 0 => -x + 1\n                case _ => x\n            }\n \
    \           val amount = op match {\n                case x if x > 0 => -1\n \
    \               case x if x < 0 => x + 1\n                case _ => 0\n      \
    \      }\n            val oldBalance = balance(key)\n            val oldDeposits\
    \ = deposits(key)\n            val oldWithdrawals = withdrawals(key)\n       \
    \     val oldPositiveOperations = positiveOperations(key)\n            balance(key)\
    \ = oldBalance - amount\n            deposits(key) = oldDeposits + amount\n  \
    \          withdrawals(key) = oldWithdrawals - amount\n            positiveOperations(key)\
    \ = oldPositiveOperations + amount\n        }\n        if (balance.exists(_ <\
    \ 0.0))\n            true\n        else\n            false", "        val balance\
    \ = operations.foldLeft(0l) { case (acc, _) => (acc acc > 0) }\n        if (balance\
    \ == false) true else false", "        val balence = operations.last\n       \
    \ if (balence < 0) return true\n        if (balence == 0) return true\n      \
    \  val firstOperation = operations.head\n        val op1 = operations.drop(1)\n\
    \        if (firstOperation > balence) belowZero(op1) else belowZero(ops)", " \
    \       val balance = operations.reduce((a, b) => a + b)\n        balance < 0",
  "        val operation = operations.tail\n        val balance = operations.head\n\
    \        if(balance < 0) return false\n        else { operations :- operation\
    \ ; true }", "        val balance = mutable.MutableList(0) // initial list is\
    \ always empty\n        for (n <- operations) {\n            balance = n + balance\n\
    \        }\n        if (balance.last < 0l) {\n            true\n        } else\
    \ {\n            false\n        }", "        val deposits = operations filter\
    \ (_ % 2 == 0)\n        val withdrawals = operations filter (_ % 2 == 1)\n   \
    \     if (deposits.isEmpty) {\n            if (withdrawals.isEmpty)\n        \
    \        false\n            else\n                true\n        } else\n     \
    \       false", "      val balance = operations.sum\n\n      if (balance < 0)\n\
    \        false\n      else\n        true", "        val firstOperation: Long =\
    \ operations.head\n        val firstOperationWithBalance : Long = operations.drop(1).head\n\
    \        val firstOperation >= 0l\n\n        if(firstOperationWithBalance < 0l)\
    \ {\n            false\n        } else {\n            val lastOperation: Long\
    \ = operations.last\n            val lastOperationWithBalance : Long = operations.dropRight(1).last\n\
    \            val lastOperation >= 0l\n            val firstOperationWithBalanceAfterOperation\
    \ = firstOperationWithBalance + lastOperation\n            val lastOperationWithBalanceAfterOperation\
    \ = lastOperationWithBalance + firstOperation\n            if(firstOperationWithBalanceAfterOperation\
    \ < 0l) {\n                false\n            } else {\n                if(lastOperationWithBalanceAfterOperation\
    \ < 0l) {\n                    false\n                } else {\n             \
    \       true\n                }\n            }\n        }", "        if (operations.isEmpty)\n\
    \            return true\n        val balance = operations.head\n        // Your\
    \ code goes here\n        if (balance < 0)\n            return false\n       \
    \ else\n            belowZero(operations.tail)", "        val initialBalance =\
    \ operations.foldLeft(0l) {_ + _}\n        val balance = operations.foldLeft(initialBalance)\
    \ {_ + _}\n        balance < 0", "        var balance = 0L\n        for(op <-\
    \ operations){\n            if(balance < 0) return true\n            balance =\
    \ balance + op\n        }\n        false", "        val numWithdrawals = operations.filter(x\
    \ => x < 0).length\n        val numDeposits = operations.filter(x => x > 0).length\n\
    \        return numWithdrawals == 0 && numDeposits == 0", "        var balance\
    \ = 0\n        var max = 0\n\n        val operation = operations.head\n      \
    \  if (operation > max) {\n            max = 0\n        }\n        val current\
    \ = operations.tail.last\n\n        operations.drop(1).foreach {\n           \
    \ operation => {\n                val withdrawal = operation - current\n     \
    \           if (withdrawal < 0l) {\n                    max = operation\n    \
    \            }\n                val deposit = current + operation\n          \
    \      balance = if (balance < 0l) {\n                    balance\n          \
    \      } else {\n                    balance + withdrawal\n                }\n\
    \                current = deposit\n            }\n        }\n\n        balance\
    \ < 0l", "        val accum = mutable.ArrayBuffer[Long]()\n        var balance\
    \ = 0\n\n        for (i <- operations) {\n            if (i > balance)\n     \
    \           accum += i\n            if (i < balance)\n                accum +=\
    \ i\n        }\n        balance.toLong < 0", "        if (operations.isEmpty)\
    \ true\n        else if (operations.head < 0) false\n        else belowZero(operations.tail)",
  "        val accBalance = mutable.Map(\n            operations zip (0 until operations.length)\n\
    \        )\n        operations.reverse foreach { operation => accBalance(operation)\
    \ = accBalance(operation) - 1 }\n        accBalance.exists { case (operation,\
    \ amount) =>\n            amount < 0\n        }", "        if (operations.isEmpty)\
    \ false\n        else {\n            val currentBalance = operations.head\n  \
    \          val operation = operations.drop(1)\n\n            if (operations.isEmpty)\
    \ true\n            else belowZero(operation) && operations.head < currentBalance\n\
    \        }", "        val startingBalance = 0\n        val operationList = mutable.ListBuffer[Long]()\n\
    \        for (op <- operations) {\n            val balance = startingBalance -\
    \ op\n            if (balance < 0l)\n                operationList += op\n   \
    \         startingBalance = balance // update starting balance with current balance\n\
    \        }\n        operationList.size <= 0 // if list is empty return false",
  "        val balance = operations.foldLeft(0l.toLong){(acc, op) =>\n           \
    \ if (acc < op.toLong) acc\n            else (acc - op.toLong)\n        }\n  \
    \      balance < 0", "        val deposits = operations.drop(operations.length-1)\n\
    \        val withdrawals = operations.take(operations.length-1)\n        if (deposits.sum\
    \ == 0 && withdrawals.sum == 0) {\n            true\n        } else if (deposits.sum\
    \ < 0 && withdrawals.sum >= 0) {\n            true\n        } else {\n       \
    \     false\n        }", "        val mutableBag = mutable.ArrayBuffer.empty[Long]\n\
    \        var withdrawals = false\n        for (op <- operations) {\n         \
    \   if (op > 0) {\n                withdrawals = true\n            } else {\n\
    \                mutableBag += op\n            }\n        }\n\n        if (!withdrawals)\
    \ false\n        else {\n            var sum = 0.0\n            var i = 0\n  \
    \          while (i < mutableBag.length) {\n                sum += mutableBag(i)\n\
    \                i += 1\n            }\n            sum < 0\n        }", "   \
    \     val balances = mutable.Queue[Long]()\n        balances.push(operations.last)\n\
    \        balances.foreach{x => \n            if (x < 0) balances.enqueue(operations.last)\n\
    \            else         balances.push(x)\n        }\n        balances.toList\
    \ match {\n            case Nil => false\n            case xs  => true\n     \
    \   }", '        if (operations == Nil) true else operations.head < 0 ', "   \
    \     val account = mutable.ListBuffer.empty[Long]\n        operations foreach\
    \ { operation => account.append(operation) }\n        var runningBalance = account.head\n\
    \        account.remove(0)\n        runningBalance < 0", "        val deposits\
    \ = operations.filter(_ >= 0)\n        val withdrawals = operations.filter(_ <\
    \ 0)\n        val emptyDeposits = deposits.filter(_ == 0)\n        val emptyWithdrawals\
    \ = withdrawals.filter(_ == 0)\n        deposits.forall(deposit => withdrawals.contains(deposit))\
    \ || withdrawals.forall(deposit => deposits.contains(deposit))", "        var\
    \ balance : Long = 0\n        for(a <- operations)\n            balance += a\n\
    \        balance < 0", "        val balance = operations.foldLeft(0L)((a, b) =>\
    \ a + b).toInt\n        balance < 0", "        val totalDeposit = operations.sum\n\
    \        val totalWithdrawal = operations.map(_.toLong).sum\n        totalDeposit\
    \ < 0 ||\n        totalWithdrawal < 0", "        // For each operation, we start\
    \ by adding it to the current balance.\n        // If we do exceed the current\
    \ balance, we'll return false.\n        // If all our operations are below zero,\
    \ then we return true\n        var currentBalance = 0\n        operations.foreach{\
    \ operation =>\n            currentBalance += operation\n            if (currentBalance\
    \ > 0) return false\n        }\n        return true", "        var balance : Long\
    \ = 0\n\n        val deposits : List[Long] = operations filterNot { operation\
    \ => operation < 0l }\n        val withdrawals : List[Long] = operations filterNot\
    \ { operation => operation >= 0l }\n\n        // Now calculate deposits and withdrawals\
    \ balances\n        deposits.foreach { deposit =>\n            balance += deposit\n\
    \        }\n        withdrawals.foreach { withdrawal =>\n            balance -=\
    \ withdrawal\n        }\n\n        if(balance < 0L) return true\n        else\
    \ return false", "        val deposits = operations.filter(n => n < 0l)\n    \
    \    val withdrawals = operations.filter(n => n > 0l)\n        deposits.foldLeft(0l)\
    \ { (total, current) => total - current }.isLess(0l)\n        withdrawals.foldLeft(0l)\
    \ { (total, current) => total + current }.isLess(0l)", "        val initialBalance\
    \ : Long = 0\n        var isChanged : Boolean = true\n        val operationList\
    \ : mutable.LinkedList[Long] = new mutable.LinkedList(operations)\n        while\
    \ (!operationList.isEmpty) {\n            val currentOperation : Long = operationList.head\n\
    \            operationList.removeHead()\n            if (currentOperation < 0)\n\
    \                isChanged = false\n            if (initialBalance - currentOperation\
    \ < 0)\n                return true\n            initialBalance -= currentOperation\n\
    \        }\n        return isChanged", "        val sums = operations.map(_.toLong).scanLeft(0L)(_\
    \ + _)\n        val differences = sums.filter(_ < 0)\n        val belowZero =\
    \ differences.isEmpty\n        if (belowZero)\n            println(\"Not below\
    \ zero\")\n        else\n            println(\"Below zero\")", "        val balance\
    \ = mutable.Map[Long, Long](1l.toLong -> (0l))\n        operations foreach {\n\
    \            operation =>\n                balance += operation.toLong -> (balance\
    \ - operation).toLong\n        }\n        balance.values.exists { b => b < 0 }",
  "        var sum : Long = 0\n        var lastWithdrawal = 0\n        var lastDeposit\
    \ = 0\n        for(operation in operations) {\n            sum += operation\n\
    \            if(!operation.isDefined) {\n                if(sum < 0) {\n     \
    \               lastWithdrawal += sum\n                    sum = 0\n         \
    \       } else if(sum > 0) {\n                    lastDeposit += sum\n       \
    \             sum = 0\n                }\n            }\n        }\n        return\
    \ lastWithdrawal < 0 || lastDeposit < 0", "        val balance = operations.head\n\
    \        val operation = operations.tail.head\n        operation match {\n   \
    \         case `with`(amount) => balance < amount\n            case `deposit`(amount)\
    \ => balance < amount\n            case `withdraw`(amount) => balance < amount\n\
    \            case `with`(_) => balance < 0\n            case `deposit`(_) => balance\
    \ < 0\n            case `withdraw`(_) => balance < 0\n            case _ => false\n\
    \        }", "        if (operations.isEmpty) true\n        else operations.head\
    \ > operations.last", "        val initialBalance = operations.head\n        val\
    \ currentBalance = initialBalance\n        val hasDeposits = false\n        val\
    \ hasWithdraws = false\n        var nextOps = operations\n        // Iterate until\
    \ we have withdrawals or no more deposits\n        while (nextOps.length > 0 &&\
    \ !hasDeposits && !hasWithdraws) {\n            if (currentBalance < 0) {\n  \
    \              hasWithdraws = true\n                nextOps = nextOps.tail\n \
    \           } else {\n                hasDeposits = true\n                nextOps\
    \ = nextOps.tail\n            }\n        }\n        // If we have no deposits\
    \ and no withdrawals then the balance is zero\n        return !hasDeposits &&\
    \ !hasWithdraws", "        var balance = operations.head\n        val operations\
    \ = operations.tail\n        while(operations != null) {\n            if(operations.head.toLong\
    \ > balance.toLong) {\n                balance = operations.head.toLong\n    \
    \        }\n            operations = operations.tail\n        }\n        balance\
    \ < 0", "        val balances = operations collect { case x: (Long, Long) => x\
    \ }\n        val deposits = balances.filter(x => x._2 > 0).length\n        val\
    \ withdrawals = balances.filter(x => x._2 < 0).length\n        deposits == withdrawals",
  "        // Iterate over the list until you encounter an operation with positive\
    \ balance that decreases\n        // from positive value to negative value.\n\
    \        // Return false if any such operation was found.\n        var result\
    \ = false\n        var lastWithdrawal = 0\n        var lastDeposit = 0\n     \
    \   for ( x <- operations ) {\n            if ( lastWithdrawal == 0 ) {\n    \
    \            // We just encountered the first withdrawal. Since balance is zero,\
    \ we can return true now\n                result = true\n            }\n     \
    \       if ( lastDeposit == 0 ) {\n                // The first deposit doesn't\
    \ mean anything since balance is zero. We can ignore it for now\n            \
    \    continue\n            }\n            else if ( x > 0) {\n               \
    \ // If current operation is positive, it means that balance has increased since\
    \ the last deposit\n                // Therefore, we can ignore this operation\
    \ for the first deposit, and continue with the last\n                // withdrawal\n\
    \                continue\n            }\n            else {\n               \
    \ // If current operation is negative, it means that balance has decreased since\
    \ the last withdrawal\n                // Therefore, we can ignore this operation\
    \ for the last withdrawal and continue with the last\n                // deposit\n\
    \                continue\n            }\n        }\n        return result", " \
    \       val balance = operations.last\n        if (operations.head != balance)\
    \ false\n        else operations.dropRight(1).reduce(_ + _) < 0", "        val\
    \ withdrawals = mutable.ListBuffer[Long]()\n        val deposits = mutable.ListBuffer[Long]()\n\
    \        operations.foreach { operation =>\n            val currentValue = operation\
    \ % 1\n            if (currentValue == 0) {\n                withdrawals += operation\n\
    \            } else if (currentValue < 0) {\n                deposits += operation\n\
    \            }\n        }\n        withdrawals.isEmpty() && deposits.isEmpty"]
stop_tokens:
- "\n    }\n"
