name: HumanEval_48_is_palindrome
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Checks if given string is a palindrome\n    // >>> isPalindrome((\"\"))\n\
  \    // (true)\n    // >>> isPalindrome((\"aba\"))\n    // (true)\n    // >>> isPalindrome((\"\
  aaaaa\"))\n    // (true)\n    // >>> isPalindrome((\"zbcd\"))\n    // (false)\n\
  \    def isPalindrome(text : String) : Boolean = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(isPalindrome((\"\"\
  )) == (true));\n    assert(isPalindrome((\"aba\")) == (true));\n    assert(isPalindrome((\"\
  aaaaa\")) == (true));\n    assert(isPalindrome((\"zbcd\")) == (false));\n    assert(isPalindrome((\"\
  xywyx\")) == (true));\n    assert(isPalindrome((\"xywyz\")) == (false));\n    assert(isPalindrome((\"\
  xywzx\")) == (false));\n    }\n\n}\n"
completions: ["        var isPalindrome = false\n        val index = 0\n        var\
    \ lengthOfText = text.length\n        if (lengthOfText <= 1)\n            isPalindrome\
    \ = true\n        else {\n            for (i <- 0 until lengthOfText / 2) //left\
    \ and right index of string\n                if (text.charAt(i) != text.charAt(lengthOfText\
    \ - 1 - i))\n                    isPalindrome = false\n            index += lengthOfText\
    \ / 2\n            lengthOfText = index\n        }\n        isPalindrome", " \
    \       // Convert text into char list\n        val textChars = text.toCharArray\n\
    \n        // Use recursion\n        def isPalindromeHelper(i : Int, acc : Boolean)\
    \ : Boolean = if(i >= textChars.length) acc else isPalindromeHelper(i + 1, (textChars(i)\
    \ == textChars(i-1) && isPalindromeHelper(i + 1, true))) \n\n        isPalindromeHelper(0,\
    \ true)", "        val str = new StringBuffer(text.reverse)\n        val isPalindrome\
    \ = str == text\n        if (isPalindrome) {\n            println(\"Yes, it is\
    \ a palindrome!\")\n        } else {\n            println(\"No, it is not a palindrome!\"\
    )\n        }\n        return isPalindrome", "        val arr = new StringBuilder(text)\n\
    \        val reversed = Array.reverse(text.toCharArray())\n        for (i<-0 until\
    \ arr.length)\n            if (arr(i) != reversed(i))\n                return\
    \ false\n        return true", "        // Your code here\n        def isPalindromeHelper(text\
    \ : String): Boolean = {\n            if(text.length <= 1) text.length == 1\n\
    \            else {\n                text.length match {\n                   \
    \ case x if x == 0 => true\n                    case x if x == 1 => true\n   \
    \                 case x if x > 1 => text.length % 2 != 0 && (text.length == \
    \ x / 2) || isPalindromeHelper(text.tail)\n                    case x if x ==\
    \ 0 || x == 1 => true\n                    _ => false\n                }\n   \
    \         }\n        }\n        \n        \n        val len = text.length\n  \
    \      val str = new StringBuilder()\n        for( i <- 0 until len ){\n     \
    \       str.append(text(i))\n        }\n        if(isPalindromeHelper(str.toString())){\n\
    \            true\n        }\n        else{\n            false\n        }", " \
    \       for (x <- text.charAt(0)..text.charAt(text.length-1)) {\n            if\
    \ (text.charAt(x) != text.charAt(text.length-x)) {\n                return false\n\
    \            }\n        }\n        return true", "        var rem = text\n   \
    \     var len = text.length\n        var isPal = true;\n        while(len > 0){\n\
    \            if(rem != rem.reverse){\n                isPal = false;\n       \
    \         break;\n            }\n            val mid = len / 2\n            val\
    \ left = rem.substring(0,mid)\n            val right = rem.substring(mid,len)\n\
    \            rem = left.reverse+right\n            len = len - 1\n        }\n\
    \        return isPal;", "        val reverseText = text.chars.reverse.mkString\n\
    \        text.equals(reverseText)", "        val start = text.slice(0, text.length/2).reverse\n\
    \        val end = text.slice(text.length/2, text.length).reverse\n        return\
    \ start == end", "        var left = 0\n        var right = 0\n        for (char\
    \ <- text.toCharArray) {\n            if (char != 'a' && char != 'z')\n      \
    \      { left = left + 1 }\n            else\n            { right = right + 1\
    \ }\n        }\n        if (left < right)\n        { return true }\n        else\
    \ if (left > right)\n        { return false }\n        else\n        { return\
    \ isPalindrome(text.subString(left, right)) }", "        var i = text.length >>\
    \ 1\n        while (i >= 0) {\n            if (text.charAt(i) != text.charAt(text.length\
    \ - 1 - i)) {\n                return false\n            }\n            i -= 1\n\
    \        }\n        return true", "        var i = 0\n        var j = text.length\
    \ - 1\n\n        while (i<j) {\n            if (text.charAt(i) != text.charAt(j))\
    \ {\n                return false\n            }\n            i += 1\n       \
    \     j -= 1\n        }\n        return true", "        val text = text.trim\n\
    \        if (text.length == 0) return true\n        if (text.length == 1) return\
    \ text == text.head\n        // Get last character in reverse order\n        val\
    \ textLastChar = text.reverse.charAt(text.length - 1)\n        if (text == textLastChar)\
    \ return true\n        // Compare middle characters with reversed ones\n     \
    \   val text = text.substring(0, text.length / 2)\n        val textLastChar =\
    \ text.reverse.charAt(text.length - 1)\n        val middleChars = text.zip(textLastChar)\n\
    \        val isPalindrome = middleChars.forall(c => c._1 == c._2)\n        return\
    \ isPalindrome", "        val newText = text.reverse\n        return text == newText",
  "        val rev = text.reverse // reverse the string\n        return text == rev",
  "        val reversedText = reverse(text)\n        reversedText == text", "    \
    \    val l = text.length\n        if (l <= 1)\n            return true\n     \
    \   var i = 0\n        var j = l - 1\n        while (i < j) {\n            if\
    \ (text.charAt(i) != text.charAt(j)) {\n                return false\n       \
    \     }\n            i += 1\n            j -= 1\n        }\n        return true",
  "        var low = 0\n        var high = text.length - 1\n        var isPalindrome\
    \ = true\n        while(low < high) {\n            if(text.charAt(low) != text.charAt(high))\
    \ {\n                isPalindrome = false\n                break\n           \
    \ }\n            low += 1\n            high -= 1\n        }\n        low", " \
    \       val textLen = text.length\n        val len = textLen / 2\n        var\
    \ i = 0\n        var j = len - 1\n        var result = true\n\n        while (i\
    \ < textLen && j >= 0) {\n            if (text.charAt(i) != text.charAt(j)) {\n\
    \                result = false\n            }\n            i += 1\n         \
    \   j -= 1\n        }\n\n        result", "        val l = text.length\n     \
    \   if (l == 0 || l == 1) true\n        else if (text.charAt(0) == text.charAt(l-1))\
    \ isPalindrome(text.substring(1, l-1))\n        else false", "        // reverse\
    \ the string and check equal lengths\n        val reversed = new StringBuilder()\n\
    \        for (x <- text) {\n            reversed.append(x)\n        }\n      \
    \  return text.length == reversed.length && text == reversed.toString", "    \
    \    val chars = text.toCharArray\n        val start = math.max(0,chars.length/2\
    \ - 1)\n        val end = chars.length/2 + 1\n        val leftChars = chars.subarray(start,\
    \ end)\n        val rightChars = chars.reverse.subarray(start, end)\n        if\
    \ (leftChars == rightChars) true\n        else false", "        val result = text.foldRight(true)((prev:\
    \ Boolean, current: Char) =>\n            prev && current == current.reverse\n\
    \        )\n        result", "       val reverseString = reverseString(text)\n\
    \       if (text == reverseString) true\n       else false", "        // Write\
    \ your code here\n        var reversed = \"\"\n        var temp = \"\"\n     \
    \   for(char <- text)\n        {\n            reversed = reversed + char\n   \
    \     }\n        for(char <- reversed)\n        {\n            temp = char + temp\n\
    \        }\n        reversed = temp\n        reversed.equals(text)", "       \
    \ // Convert text to lower case\n        val lowText = text.foldLeft(text.head.toLowerCase())((text,\
    \ character) => character + text)\n        val reversed = lowText.reverse\n\n\
    \        // Compare chars to chars in reversed string\n        reversed.forall(c\
    \ => lowText.charAt(0) == c) ", "        val reversed = text.zipWithIndex.map{\
    \ case (value, index) => index -> value }.toMap\n        val isPalindrome = text.tail\
    \ == text.head && reversed.forall(k => k._1 == k._2)\n        isPalindrome", " \
    \       val textArray = text.split(\"\")\n        val textLength = textArray.length\n\
    \        val revText = textArray.tail.reverse\n\n        var isPalindrome = true\n\
    \        for (i <- 0 to textLength-1){\n            if(textArray(i) != revText(i)){\n\
    \                isPalindrome = false\n                break\n            }\n\
    \        }\n        return isPalindrome", "        // Create a String from text\
    \ (no need for chars method)\n        // then reverse it\n        var reversed\
    \ = text.init.reverse\n        // Return true if original text is equal to reversed\n\
    \        // or if original text is equal to reverse + original text\n        //\
    \ return true if original text is equal to reverse + original text\n        if\
    \ (text == reversed) {\n            return true\n        }\n        if (text ==\
    \ reversed + text)\n            return true\n        else\n            return\
    \ false", "        val reverseText = text.reverse\n        text == reverseText",
  "        var i = 0\n        var j = text.length\n        var temp = text.charAt(i)\n\
    \        while(j > i) {\n            if(text.charAt(i) != text.charAt(j)) {\n\
    \                return false\n            }\n            i += 1\n           \
    \ j -= 1\n        }\n        return true", "        val sb = mutable.StringBuilder()\n\
    \        for (c <- text) sb.append(c).append(' ')\n        sb.toString().reverse\
    \ == sb.toString()", "        val reverse = new StringBuilder(text.reverse).reverse\n\
    \        if (text == reverse) true\n        else false", "        if(text.size\
    \ == 0 || text.size > 2)\n            return true\n        if(text.length == 1)\n\
    \            return text(0) == text(text.length - 1)\n        \n        val strs\
    \ = text.split(\"\\\\s+\").map(_.toLowerCase)\n        val reverseStrs = strs.reverse\n\
    \        val firstLetters = reverseStrs.takeWhile(_.length == 1)\n        if(firstLetters.isEmpty)\n\
    \            return true\n        \n        // For each letter in the given string,\
    \ check if it's in the palindrome \n        // or not by comparing it with the\
    \ reverse of the same letter.\n        // If it is, return the boolean.\n    \
    \    // If not, return the boolean that checks if it has a suffix of 1 or 2 \n\
    \        // letters.\n        strs.map{s =>\n            val reverseS = s.reverse\n\
    \            if(s == reverseS)\n                true\n            else\n     \
    \           (reverseS.length == 1 || reverseS.length == 2 && reverseS.contains(s(s.length\
    \ - 1)))\n        }.sum\n", "        // Create a list with all the characters\
    \ in the string\n        val chars = ListBuffer[Char]()\n        for(i <- 0 until\
    \ text.length) chars += text.charAt(i)\n        \n        // Create another list\
    \ with all the characters except the first\n        val charsAfterFirst = ListBuffer[Char]()\n\
    \        for(i <- 1 until text.length) {\n            charsAfterFirst += text.charAt(i)\n\
    \        }\n        \n        // Test the lists\n        charsAfterFirst.zip(chars).forall\
    \ { case (c, c2) =>\n            if (c == c2) true else false\n        }", " \
    \       var reverse : String = \"\"\n        for(i <- text.indices){\n       \
    \     reverse = reverse + text.charAt(i)\n        }\n        text == reverse",
  "        if (text.length == 0) return true\n        val a = text.substring(1)\n\
    \        val b = text.substring(0, text.length - 1)\n        return a != b &&\
    \ a != a && b != b", "        var result = true\n        for (char <- text) {\n\
    \            if (char.equals('a') || char.equals('z')) {\n                result\
    \ = false\n                break\n            }\n            if (char.equals('A')\
    \ || char.equals('Z')) {\n                result = false\n                break\n\
    \            }\n        }\n        result", "        var i = 0\n        var j\
    \ = 0\n        var len = (text.length) / 2\n        var flag = false\n\n     \
    \   var x = text.substring(i, j)\n\n        while (i < len) {\n            if\
    \ (x.equals(text.substring(0, len - i))) {\n                flag = true\n    \
    \            break\n            }\n            i += 1\n        }\n\n        if\
    \ (flag) {\n            return true\n        } else {\n            return false\n\
    \        }", "      val reversed = new StringBuilder\n      for (x <- text) {\n\
    \        if (reversed.length() > 1) reversed.append(\" \")\n        reversed.append(x)\n\
    \      }\n      reversed.toString().equals(text)", "        var start = 0\n  \
    \      var end = text.length() - 1\n        while (start < end) {\n          \
    \  if (text.charAt(start) != text.charAt(end)) {\n                return false\n\
    \            }\n            start += 1\n            end -= 1\n        }\n    \
    \    return true", "        // Convert to lower case and remove whitespace\n \
    \       text = text.toLowerCase().replaceAll(\"\\\\s\",\"\")\n\n        // Split\
    \ string into words\n        val words = text.split(\"\\\\W+\")\n\n        //\
    \ Set up and compare string lengths\n        var length : Int = 0\n        var\
    \ word = \"\"\n        val checkWord = List(\"a\",\"b\",\"c\",\"d\",\"e\",\"f\"\
    ,\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\",\"q\",\"r\",\"s\"\
    ,\"t\",\"u\",\"v\",\"w\",\"x\",\"y\",\"z\")\n        val checkLength = (words.length/2).toInt\n\
    \        for (i<- 0 until checkLength) {\n            if (words.length%2 != 0)\
    \ {\n                length = checkLength - i \n            } else {\n       \
    \         length = i - 1\n            }\n            word = (words(length+1))\n\
    \            for (j <- 0 until length) {\n                if (word.charAt(j) !=\
    \ checkWord.charAt(length-j)) {\n                    return false\n          \
    \      }\n            }\n        }\n        true", "        if(text == \"\" ||\
    \ (text.length % 2 != 0) || text.charAt(0) != text.charAt(text.length - 1).toLowerCase())\n\
    \            return false\n        var i : Int = 0\n        var left : Int = text.length\
    \ / 2\n        var right : Int = text.length / 2\n        while(left < right)\
    \ {\n            if(text.charAt(left) != text.charAt(right))\n               \
    \ return false\n            left = left + 1;\n            right = right - 1;\n\
    \        }\n        return true", "        val len = text.length\n        if(len\
    \ == 0) return true\n        var middleIndex = len / 2\n        val middle = text.substring(middleIndex).reverse\n\
    \        return text == middle", "        val textArray = text.split(\" \").toArray\n\
    \        val length = textArray.length\n\n        if (length <= 0) return true\n\
    \n        val start = textArray(length - 1)\n        val end = textArray(0)\n\n\
    \        if (start == end) return true\n\n        return text.substring(start.length).startsWith(text.substring(start.length).reverse)",
  "        if(text.length <= 1)\n            true\n        else\n            if(text.head\
    \ != text.last)\n                false\n            else\n                if(text.head\
    \ == text.last)\n                    isPalindrome(text.tail)\n               \
    \ else\n                    isPalindrome(text.tail) ", "        if(text.length\
    \ < 1)\n            return true\n        var isPalInd = false\n        for(i<-0\
    \ until text.length-1)\n            if(text.charAt(i) != text.charAt(text.length-i-1))\n\
    \                isPalInd = false\n        if(isPalInd)\n            return true\n\
    \        else\n            return false", "        var chars = text.chars\n  \
    \      var charsReversed = text.chars.reverse\n        var result = true\n   \
    \     for(i <- 0 until chars.length) {\n            if(chars(i) != charsReversed(i))\n\
    \                result = false\n        }\n        result", "      var i = 0\n\
    \      var j = text.length-1\n      while(i < j){\n        if (text(i) != text(j))\
    \ {\n          return false\n        }\n        i += 1\n        j -= 1\n     \
    \ }\n      return true", "        if (text.length < 1) {\n            return true\n\
    \        }\n        val array = text.chars.toList\n        var i = 0\n       \
    \ var j = (text.length / 2)\n        while (i <= j) {\n            if (array(i)\
    \ != array(j)) {\n                return false\n            }\n            i +=\
    \ 1\n            j -= 1\n        }\n        return true", "        // Using regex\
    \ to find if the string is a palindrome\n        // >>> str.replaceAll(\"\"\"\
    [^\\w]\"\"\", \"\").replaceAll(\"\"\"\\w\"\"\", \"\")\n        // \"abc\"\n  \
    \      // >>> str.replaceAll(\"\"\"[^\\w]\"\"\", \"\").replaceAll(\"\"\"\\w\"\"\
    \", \"\")\n        // \"abc\"\n        // >>> str.replaceAll(\"\"\"[^\\w]\"\"\"\
    , \"\").replaceAll(\"\"\"\\w\"\"\", \"\")\n        // \"abc\"\n        // >>>\
    \ str.replaceAll(\"\"\"[^\\w]\"\"\", \"\").replaceAll(\"\"\"\\w\"\"\", \"\")\n\
    \        // \"abc\"\n        // >>> str.replaceAll(\"\"\"[^\\w]\"\"\", \"\").replaceAll(\"\
    \"\"\\w\"\"\", \"\")\n        // \"abc\"\n        // >>> str.replaceAll(\"\"\"\
    [^\\w]\"\"\", \"\").replaceAll(\"\"\"\\w\"\"\", \"\")\n        // \"abc\"\n  \
    \      // >>> str.replaceAll(\"\"\"[^\\w]\"\"\", \"\").replaceAll(\"\"\"\\w\"\"\
    \", \"\")\n        // \"abc\"\n        // >>> str.replaceAll(\"\"\"[^\\w]\"\"\"\
    , \"\").replaceAll(\"\"\"\\w\"\"\", \"\")\n        // \"abc\"\n        // >>>\
    \ str.replaceAll(\"\"\"[^\\w]\"\"\", \"\").replaceAll(\"\"\"\\w\"\"\", \"\")\n\
    \        // \"abc\"\n        // >>> str.replaceAll(\"\"\"[^\\w]\"\"\", \"\").replaceAll(\"\
    \"\"\\w\"\"\", \"\")\n        // \"abc\"\n        // >>> str.replaceAll(\"\"\"\
    [^\\w]\"\"\", \"\").replaceAll(\"\"\"\\w\"\"\", \"\")\n        // \"abc\"\n  \
    \      // >>> str.replaceAll(\"\"\"[^\\w]\"\"\", \"\").replaceAll(\"\"\"\\w\"\"\
    \", \"\")\n        // \"abc\"\n        // >>> str.replaceAll(\"\"\"[^\\w]\"\"\"\
    , \"\").replaceAll(\"\"\"\\w\"\"\", \"\")\n        // \"abc\"\n        // >>>\
    \ str.replaceAll(\"\"\"[^\\w]\"\"\", \"\").replaceAll(\"\"\"\\w\"\"\", \"\")\n\
    \        // \"abc\"\n        // >>> str.replaceAll(\"\"\"[^\\w]\"\"\", \"\").replaceAll(\"\
    \"\"\\w\"\"\", \"\")\n        // \"abc\"\n        // >>> str.replaceAll(\"\"\"\
    [^\\w]\"\"\", \"\").replaceAll(\"\"\"\\w\"\"\", \"\")\n        // \"abc\"\n  \
    \      val regex = \"\"\"(?x)^[a-z]*$\"\"\".r\n        val matcher = regex.findFirstIn(text)\n\
    \        if (matcher.isEmpty)\n          true\n        else\n          !matcher.isPrefixOf(regex(regex(text).reverseIterator.dropWhile(_\
    \ == ' ').reverse))", "        val strChars = text.toCharArray\n        val revChars\
    \ = strChars.reverse\n\n        // Check that reversed string equals original\
    \ string\n        val isPalindrome = revChars.toString == text\n        isPalindrome",
  '        text.zip(text.reverse).forall((_ == _))', "        val words = text.split(\"\
    \\\\W+\").toList // Split into words\n        val reversedWords = words.reverse.mkString\
    \ // Reverse words\n        if (words.equals(reversedWords)) true else false",
  "        if (text.length < 2) return true\n        var start = text.length / 2\n\
    \        var end = (text.length / 2) - 1 \n        var reversedText = reverse(text)\n\
    \        if (reversedText == text) return true\n        return false", "     \
    \   text.length % 2 == 0\n        if (text.length == 0) return true\n        var\
    \ i = 0\n        var j = (text.length / 2)\n        var done = false\n       \
    \ while (i < text.length && j < text.length) {\n            if (text(i) != text(j))\
    \ {\n                done = false\n            }\n            i += 1\n       \
    \     j += 1\n        }\n        done", "        val list = text.split(' ').toList\n\
    \        val revlist = reverse(list)\n        revlist.forall(x => x == text)",
  "        if(text.length == 0) true\n        else {\n            val charArray =\
    \ text.toCharArray()\n            val array = new Array[Char](text.length)\n \
    \           val start = 0\n            val end = text.length - 1\n           \
    \ var i = 0\n            var j = 0\n            var done = false\n           \
    \ while(j < end) {\n                array(i) = charArray(j)\n                i\
    \ = i + 1\n                j = j + 1\n            }\n            var temp = array\n\
    \            i = 0\n            j = 0\n            while(i < end) {\n        \
    \        if(temp(i) != array(j)) done = true\n                i = i + 1\n    \
    \            j = j + 1\n            }\n            if(done) true\n           \
    \ else false\n        }", "        val sB = new StringBuilder\n        for (x\
    \ <- text) {\n            sB += x\n        }\n        sB.reverse\n        text\
    \ == sB.toString", "        if(text.size == 0) return true\n        if(text.size\
    \ < 2) return false\n        val middle = math.floor((text.length + 1) / 2)\n\
    \        val leftText = text.take(middle)\n        val rightText = text.drop(middle)\n\
    \        return isPalindrome(leftText) && isPalindrome(rightText) && leftText\
    \ != rightText", "        if(text.length == 0)\n            return true\n    \
    \    var reverse = new StringBuilder(text)\n        reverse.reverse()\n      \
    \  return text == reverse.toString()", "        if (text.length < 2) return true\n\
    \        val charArray = text.toCharArray\n        var revStr = \"\"\n       \
    \ for (i <- 0 to charArray.length / 2 - 1) {\n            val tmp = charArray(i)\n\
    \            charArray(i) = charArray(charArray.length - i - 1)\n            charArray(charArray.length\
    \ - i - 1) = tmp\n            val revChar = charArray(i)\n            revStr +=\
    \ revChar\n        }\n        return revStr == text", "        var i = 0\n   \
    \     var j = 0\n        var isPalendrome = true\n\n        while (i <= (text.length\
    \ / 2))\n            i += 1\n\n        while (j >= (text.length / 2))\n      \
    \      j -= 1\n\n        if (i != j && (text(i) == text(j))) {\n            isPalendrome\
    \ = false\n        }\n\n        return isPalendrome", "        val reverse = new\
    \ mutable.Stack[Char]()\n        for(char <- text.toCharArray) {\n           \
    \ reverse += char\n        }\n        if(text == reverse.reverse) {\n        \
    \    return true\n        } else {\n            return false\n        }", "  \
    \      if(text == null) return false\n        val text = text.chars.toList\n \
    \       val half = text.length/2\n        var i = 0\n        var j = half - 1\n\
    \        while(i <= half && j <= half) {\n            if(text(i) != text(j)) {\n\
    \                return false\n            }\n            i += 1\n           \
    \ j -= 1\n        }\n        if(i <= half) {\n            for((i <- text.indices)\
    \ yield {\n                val p = text(i)\n                text(i) = text(j)\n\
    \                text(j) = p\n            })\n        }\n        true", "    \
    \    val reversed = new mutable.MutableStringBuilder\n        for ((index, char)\
    \ <- text.zipWithIndex) {\n            reversed.append(char)\n        }\n    \
    \    reversed == text.reverse", "        val start = 0\n        val end = text.length\n\
    \        while (start < end) {\n            if (text.charAt(start) != text.charAt(end))\
    \ {\n                return false\n            }\n            start = start +\
    \ 1\n            end = end - 1\n        }\n        true", "        val length\
    \ = text.length\n        if(length == 0)\n            return true\n\n        val\
    \ first = text.charAt(0)\n        val last = text.charAt(length-1)\n        return\
    \ last == first", '        text == text.tail.reverse', "        val sx = text.mkString\n\
    \        var isPalindrome = true\n        var i = sx.length - 1;\n        var\
    \ j = 0;\n        while (i >= 0 && j >= 0) {\n            if (sx(i) != sx(j))\
    \ {\n                isPalindrome = false\n                break\n           \
    \ }\n            i -= 1\n            j -= 1\n        }\n        isPalindrome",
  "        val arr = text.characters\n        if (arr.length < 2) true\n        else\
    \ if (arr.head == arr.last) true\n        else false", "        var str = new\
    \ StringBuffer()\n        str.append(text)\n        var reversed = new StringBuffer()\n\
    \        for( c <- str ) {\n            reversed.append(c.reverse)\n        }\n\
    \        return str == reversed", "        var result : Boolean = true\n     \
    \   var i : Int = text.length - 1\n        var j : Int = text.length - 1\n   \
    \     while (i >= 0) {\n            while (j < i) {\n                if (text.charAt(i)\
    \ != text.charAt(j)) {\n                    result = false\n                 \
    \   break\n                }\n                j -= 1\n            }\n        \
    \    i -= 1\n        }\n        return result", "        var result = (text ==\
    \ text.reverse);\n        for(i <- 0 until text.length / 2) if (!text(i) == text(i\
    \ + 1)) result = false;\n        result;", "        for (i <- 0 until text.length/2)\
    \ {\n            if (text.charAt(i) != text.charAt(text.length-i-1))\n       \
    \         return false\n        }\n        return true", "        if (text.length\
    \ < 1) return true\n        val sb = mutable.StringBuilder(text)\n        var\
    \ i = 0\n        var j = text.length - 1\n        while(i < j){\n            if\
    \ (text(i) != text(j)) return false\n            i += 1\n            j -= 1\n\
    \        }\n        return true", "        val revString = new String(text.reverse)\n\
    \        val textLength = text.length\n        var palindrome = true\n       \
    \ var start = 0\n        while (start < textLength && palindrome) {\n        \
    \    if (revString(start) != text(textLength - start - 1)) {\n               \
    \ palindrome = false\n            }\n            start += 1\n        }\n     \
    \   if (start == textLength) {\n            palindrome\n        } else {\n   \
    \         false\n        }", "        val textArray = text.split('')\n       \
    \ val reversed = textArray.reverse\n        if(reversed.toString.equals(text.toString))\
    \ true\n        else false", "        if(text == \"\")\n            return true\n\
    \        else if(text.length <= 1)\n            return true\n        else if(text.charAt(0)\
    \ == text.charAt(text.length - 1))\n            return isPalindrome(text.substring(1,\
    \ text.length))\n        else\n            return false", "        if(text ==\
    \ null || text.isEmpty) true\n        else {\n            var index = 0 \n   \
    \         var reverseIndex = 0\n            for(i <- 0 until text.length / 2)\n\
    \                if(text.charAt(i) != text.charAt(text.length-i-1)) false\n  \
    \              else {\n                    index = reverseIndex\n            \
    \        reverseIndex = reverseIndex + 1\n                }\n            if(index\
    \ != reverseIndex) false\n            else true\n        }", "        val length\
    \ = text.length()\n        if(length < 2)\n            return true\n        val\
    \ left = text.subSequence(0, length / 2).reverse\n        val right = text.subSequence(length\
    \ / 2, length)\n        if(left == right)\n            return true\n        else\n\
    \            return false", "      val strArray = text.split('')\n      var reverseText\
    \ = \"\"\n      var index = 0\n      while(index < strArray.length){\n       \
    \ reverseText += strArray(index).toChar.toString\n        index += 1\n      }\n\
    \      (reverseText == text) && (strArray.length == text.length)", "        if\
    \ (text.length < 2)\n            return true\n        var i = 0\n        var j\
    \ = text.length - 1\n        while (i < j) {\n            if (text(i) != text(j))\n\
    \                return false\n            i += 1\n            j -= 1\n      \
    \  }\n        return true", "        val words = text.toLowerCase.trim.split(\"\
    \ \").toList\n        val reversed = words.reverse\n        val length = (reversed.length\
    \ - 1).toString\n        var counter = 0\n        for(i <- 0 to (text.length()\
    \ - 1)) {\n            if (reversed(i).equals(text.charAt(i))) {\n           \
    \     counter += 1\n            } else {\n                break\n            }\n\
    \        }\n        if(counter == (text.length() - 1)) {\n            true\n \
    \       } else {\n            false\n        }", "        val charSeq = text.toCharArray\n\
    \        val reversed = new Array[Char](charSeq.length)\n        for( i <- 0 until\
    \ charSeq.length)\n            reversed(i) = charSeq(text.length - i)\n      \
    \  charSeq == reversed", "        val textArray = text.splitAt(text.length-1)\n\
    \        textArray == textArray.map(_.toLowerCase).reverse", "        // remove\
    \ all whitespace and ignore first and last character\n        val textWithoutWhiteSpace\
    \ = text.replaceAll(\"\\\\s*\", \"\").reverse.replaceFirst(\"a\", \"\")\n    \
    \    // if text is empty or contains only whitespace return true\n        if (textWithoutWhiteSpace.isEmpty)\
    \ {\n            return true\n        }\n        // else check for equality\n\
    \        else {\n            if (text == textWithoutWhiteSpace) {\n          \
    \      return true\n            }\n            else {\n                return\
    \ false\n            }\n        }", "        if (text == text.reverse) true\n\
    \        else false", "        if (text.length == 0) return true\n        var\
    \ start : Int = 1\n        var end : Int = text.length\n        while (start <\
    \ end) {\n            var strCut = text.substring(start, end)\n            var\
    \ reverseCut = strCut.reverse\n            if (reverseCut.equalsIgnoreCase(strCut))\
    \ {\n                return true\n            }\n            end -= 1\n      \
    \  }\n        return false", "        def reverse(str: String) : String = {\n\
    \            val reverseString = StringBuffer(str)\n            reverseString.reverse\n\
    \        }\n        val chars = text.toCharArray\n        val length = chars.length\n\
    \        var i = 0\n        var j = length\n        while (i <= j) {\n       \
    \     val currentChar = chars(i)\n            val nextChar = chars(j)\n      \
    \      if (currentChar != nextChar) {\n                return false\n        \
    \    }\n            i += 1\n            j += 1\n        }\n        return true",
  "        val length : Int = text.length\n        var start : Int = length / 2\n\
    \        while (start >= 0) {\n            if (text.charAt(start) != text.charAt(start\
    \ + 1)) {\n                return false\n            }\n            start -= 1\n\
    \        }\n        true", "        val strLen = text.length\n        val revStrLen\
    \ = strLen / 2\n        var revText = \"\"\n        var revTextIndex = 0\n\n \
    \       for (i <- 0 until strLen) {\n            revText = revText + text.charAt(i)\n\
    \            val temp = revText.charAt(revTextIndex).toInt\n            if (temp\
    \ != 0) {\n                revTextIndex += 1\n                if (temp == text.charAt(revTextIndex).toInt)\n\
    \                    continue\n            }\n            revTextIndex -= 1\n\
    \            if (i == revTextIndex)\n                return true\n        }\n\n\
    \        return false", "        val reversed = new StringBuilder(text).reverse.toString\n\
    \        text.equals(reversed)", "        if(text.length == 0)\n            true\n\
    \        else if(text.length == 1)\n            text.toCharArray.mkString.toLowerCase\
    \ == text.toCharArray.mkString.toLowerCase\n        else\n            val l =\
    \ text.toCharArray.mkString.toLowerCase // lowercase letters\n            val\
    \ r = text.toCharArray.mkString.toLowerCase // reverse\n            val m = l.lastIndex(r)\
    \ // find index where to cut\n            if (m != -1 && l == r(m.size))\n   \
    \             true\n            else\n                false", "        val chars\
    \ = text.filter(ch => ch >= 'a' && ch <= 'z').map(ch => ch.toInt).toList\n   \
    \     val start = chars.takeRight(chars.length / 2).length\n        val end =\
    \ chars.length / 2 - chars.takeLeft(chars.length / 2).length\n        chars.takeRight(end)\
    \ == chars.reverse.takeLeft(end)", "        val array = ArrayBuffer(text)\n  \
    \      val reverse = reverseString(array)\n        reverse == text", "       \
    \ var chars = text.toList\n        chars.reverse\n        chars.equals(text.reverse)",
  "        var reverseText = reverseString(text)\n        text == reverseText", " \
    \       val len = text.length\n        for((i1 to len) <- 0 until len)\n     \
    \       if(!text.charAt(i1) == text.charAt(len-i1))\n                return false\n\
    \        return true", "        def reverseChar(c: String) : String = {\n    \
    \        val temp = c\n            val str = new StringBuilder(temp)\n       \
    \     str.reverse\n        }\n        // Returns true if text is palindrome\n\
    \        if (text == null || text.length <= 1) {\n            return true\n  \
    \      }\n\n        // Removes first and last characters\n        var middle =\
    \ text.length / 2\n        if (text.length % 2 != 0) {\n            middle = middle\
    \ - 1\n        }\n        text = text.drop(middle).take(middle)\n\n        //\
    \ Compares the original text with palindrome text\n        var res = text.equals(reverseChar(text))\n\
    \        return res", "        // create reverse list from the original list\n\
    \        val reverseText = mutable.ListBuffer(text.reverse)\n        // if original\
    \ and reverse list are the same, return true\n        if (text.equals(reverseText.mkString))\
    \ {\n            return true\n        }\n        // if original and reverse list\
    \ are not the same, return false\n        return false", '       text.charAt(0)
    == text.charAt(text.length-1)', "        if (text.length <= 1) {\n           \
    \ return true\n        }\n        val charArray = text.toCharArray\n        val\
    \ reversedArray = Array.ofDim[Char](text.length)\n        reversedArray.indices.foreach(x\
    \ => {\n            reversedArray(x) := charArray(x)\n        })\n        if (charArray\
    \ == reversedArray) {\n            return true\n        }\n        return false",
  "        var lastChar = \"\"\n        var chars = text.toCharArray\n        var\
    \ result = true\n        for(i <- chars.length - 1 downto 0 by -1){\n        \
    \    chars(i) = lastChar\n            lastChar = chars(i)\n            if (chars(i)\
    \ != lastChar){\n                result = false\n                break\n     \
    \       }\n        }\n        result", "        if(text.length < 1) {\n      \
    \      return true\n        }\n        var left = 0\n        var right = text.length\
    \ - 1\n        while(left < right) {\n            if(text.charAt(left) != text.charAt(right))\
    \ {\n                return false\n            }\n            left += 1\n    \
    \        right -= 1\n        }\n        return true", '        return text.forall(Character.toLowerCase
    <= _.toUpperCase && Character.toUpperCase <= _.toLowerCase)', "        var reversed\
    \ = new StringBuilder\n        for (i <- text.indices) {\n            val c =\
    \ text(i)\n            val reverse = reversed.reverse\n            if (c == reverse)\
    \ true else {\n                reversed.append(c)\n                reversed.append('\
    \ ')\n            }\n        }\n        return false", "        if(text.length\
    \ == 0) return true\n        if(text.length == 1) return text(0) == text(text.length-1)\n\
    \        var left = text.substring(0, text.length-1)\n        var right = text.substring(text.length-1,\
    \ text.length)\n        if(left.isEmpty) left = right\n        else if(right.isEmpty)\
    \ right = left\n        else {\n            while(left.length != right.length)\
    \ left += right.charAt(0)\n            while(left.length != left.length || left.charAt(0)\
    \ == left.charAt(left.length-1)) left += right.charAt(0)\n        }\n        return\
    \ left == right", "        if (text == \"\" || (text.length ==1 && text.head ==\
    \ text.tail))\n            true\n        else\n        {\n            var sb =\
    \ text.iterator\n            var temp = \"\"\n            var isPal = false;\n\
    \            while ( !sb().hasNext && sb.hasNext )\n            {\n          \
    \      if ( sb.head != sb.tail )\n                    temp =  sb.head;\n     \
    \           else\n                    temp =  sb.next();\n                if(\
    \ temp == temp.toUpperCase() )\n                    isPal = true;\n          \
    \  }\n            return isPal;\n        }", "        val revText = reverseString(text)\n\
    \        if(text == revText)\n            return true\n        else\n        \
    \    return false", "        if (text == null || text.length <= 0)\n         \
    \   return true\n        var i : Int = 0\n        var j : Int = text.length -\
    \ 1\n        while (i >= 0 && j >=0) {\n            if (text(i) != text(j)) {\n\
    \                return false\n            }\n            i -= 1\n           \
    \ j -= 1\n        }\n        return true", "        // Initialize variable\n \
    \       val strLen = text.length\n        // Initialize iterator\n        var\
    \ i : Int = 0\n        val arrayOfChar = text.characters\n        val arrayOfReversedChar\
    \ = arrayOfChar.reverse\n        // Run while loop\n        while (i < strLen)\
    \ {\n            if (arrayOfChar(i) != arrayOfReversedChar(i)) {\n           \
    \     return false\n            }\n            i += 1\n        }\n        true",
  "        // Your code goes here\n        if(text.length < 2){\n            return\
    \ true\n        }\n        var i = text.length - 1\n        while(i >= 0 && i\
    \ < text.length/2){\n            if(text.charAt(i) != text.charAt(text.length-i-1)){\n\
    \                return false\n            }\n            i -= 1\n        }\n\
    \        return true", "        if(text.length == 0){\n            true\n    \
    \    }\n        else {\n            val leftToRight = reverseString(text(0))\n\
    \            val rightToLeft = reverseString(text.tail)\n            if(leftToRight\
    \ == rightToLeft){\n                true\n            }\n            else {\n\
    \                false\n            }\n        }", "        val list = mutable.ListBuffer.empty[Char]\n\
    \        for(c1 <- text.toCharArray) list += c1\n        val len = list.size\n\
    \        if(len == 0 || len == 1) true\n        else {\n            val revList\
    \ = list.init\n            val mid = len / 2\n            for(i <- 0 until len-1)\
    \ if(list.updated(i, revList(i)) != revList(i)) false else true\n        }", " \
    \       val tempCharArray = text.toCharArray\n        val rev = text.chars.reverse\n\
    \        if (rev.last == rev.head) {\n            true\n        } else {\n   \
    \         false\n        }", "        val newText = text.split(\"\").reverse.mkString(\"\
    \")\n        text == newText", "        val str = new StringBuilder(text).reverse\n\
    \        text.equals(str)", "        if(text.size < 2)\n            return true\n\
    \        val startIndex = text.length / 2\n        val endIndex = text.length\
    \ - 1\n        if(text.charAt(startIndex) != text.charAt(endIndex))\n        \
    \    return false\n        while(startIndex >= 0 && endIndex >= 0) {\n       \
    \     if(text.charAt(startIndex) != text.charAt(endIndex))\n                return\
    \ false\n            startIndex -= 1\n            endIndex -= 1\n        }\n \
    \       true", "        var chars: List[Char] = text.toList\n        var leftPos\
    \ = 0\n        var rightPos = chars.length - 1\n        var isPalindrome = true\n\
    \n        while (leftPos < rightPos) {\n            if (chars(leftPos) != chars(rightPos))\
    \ {\n                isPalindrome = false\n            }\n            leftPos\
    \ += 1\n            rightPos -= 1\n        }\n\n        return isPalindrome",
  "        val chars = text.toCharArray\n        var i = 0\n        var j = chars.length-1\n\
    \n        while (i < j) {\n            if (chars(i) != chars(j)) {\n         \
    \       return false\n            }\n            i += 1\n            j -= 1\n\
    \        }\n        return true", "        val reversed = new StringBuilder(text).reverse\n\
    \        text == reversed", '        text.chars.toList == text.chars.reverse.toList',
  "        var left = 0\n        var right = text.length - 1\n        while (left\
    \ < right) {\n            if (text(left) != text(right)) {\n                return\
    \ false\n            }\n            left += 1\n            right -= 1\n      \
    \  }\n        return true", "        val textArray = text.split(\"\").toArray\n\
    \        val reversedArray = reverse(textArray)\n        val resultArray = reversedArray.mkString(\"\
    \")\n        return resultArray == text", "        val reversed = text.map(x =>\
    \ Character(x).reverse.asInstanceOf[Char]).mkString\n        reversed == text",
  "        val length = text.length\n        for(i <- 0 until length / 2) {\n    \
    \        val a = text.charAt(i)\n            val b = text.charAt(length - i -\
    \ 1)\n            if(a != b)\n                return false\n        }\n      \
    \  return true", "        if(text.length == 1) return true\n        if(text.length\
    \ == 0) return false\n        val middle = text.length/2\n        for( i <- text.indices\
    \  ) if(text(i) != text(middle)) return false\n        return true", "       \
    \ val chars = text.takeWhile(char.IsLetter).reverse\n        chars.sameElements(text)",
  "        val revText = new StringBuilder(text.reverse).reverse.toString\n      \
    \  revText == text || (text.length < revText.length)", "        // Create two\
    \ iterators from the text and store them in reverse\n        val it = text.iterator\n\
    \        val it2 = text.iterator.reverse\n\n        // Check each character in\
    \ text and text2 and compare them\n        while (it.hasNext && it2.hasNext) {\n\
    \            // If they are different, the strings are not palindrome\n      \
    \      if (it.next != it2.next) {\n                return false\n            }\n\
    \        }\n        // At this point, it2 and it are equal\n        return true",
  "        var buffer = new StringBuilder()\n        var i = 0\n        var j = text.length\
    \ - 1\n\n        while (i < j) {\n            if (text(i) == text(j)) {\n    \
    \            i += 1\n                j -= 1\n            } else if (text(i) >\
    \ text(j)) {\n                buffer.append(text(i))\n                i += 1\n\
    \            } else {\n                buffer.append(text(j))\n              \
    \  j -= 1\n            }\n        }\n        return text.length == buffer.length\
    \ && !buffer.toString().equals(text.toString())", "        var i = 0\n       \
    \ var j = text.length - 1\n        while (i <= j){\n            if (text(i) !=\
    \ text(j)){\n                return false\n            }\n            i += 1\n\
    \            j -= 1\n        }\n        return true", "        val lenText = text.length\n\
    \        if (lenText <= 1) true\n        else {\n            var left = lenText\
    \ / 2\n            var right = lenText / 2\n            var i = 0\n          \
    \  var j = lenText - 1\n            while (i < j) {\n                if (text.charAt(i)\
    \ != text.charAt(j))\n                    return false\n                else {\n\
    \                    i += 1\n                    j -= 1\n                }\n \
    \           }\n            if (left < right) true\n            else false\n  \
    \      }", "        // TODO: Write code here\n        val s = text.substring(1)\n\
    \        if(s.length == 0 || s.length == 1){\n            return true\n      \
    \  }\n        val p = s.length/2\n        if(text.charAt(p) != text.charAt(s.length-1)){\n\
    \            return false\n        }\n        val left = text.substring(0, p)\n\
    \        val right = text.substring(s.length)\n        return isPalindrome(left)\
    \ && isPalindrome(right)", "        val reversedText = new StringBuilder\n   \
    \     reversedText.append (text.reverse)\n        reversedText.toString.equals\
    \ (text)", "        val reversedText = text.substring((text.length-1), (text.length)).reverse\n\
    \        text.equals(reversedText)", "        // Palindrome is same if string\
    \ is in reverse order and same is no\n        // spaces before and after the string\n\
    \        val text = text.trim\n        val revText = text.reverse\n        text.equals(revText)",
  "        if (text.length == 0) return true\n        var i = text.length / 2 - 1\n\
    \        var j = text.length / 2\n        val reversed = new StringBuilder(text).reverse\n\
    \        return reversed == text", "        var result = false\n        for (char\
    \ <- text) {\n            if (text != text.reverse) {\n                result\
    \ = false\n                break\n            }\n        }\n        result", " \
    \       // We need to reverse text and compare with original\n        val original\
    \ = text.mkString\n        val reversed = text.reverse\n        original === reversed",
  '        text.head == text.last', "        if(text.length==0) return true\n    \
    \    var start = text.length()/2\n        var end = text.length()-1\n        while\
    \ (start > end){\n            if(text.charAt(start-1) != text.charAt(end)) return\
    \ false\n            start -= 1\n            end -= 1\n        }\n        return\
    \ true", "        val leftIndex = 0\n        val rightIndex = text.length - 1\n\
    \        while (leftIndex < rightIndex) {\n            if (text(leftIndex) !=\
    \ text(rightIndex)) {\n                return false\n            }\n         \
    \   leftIndex += 1\n            rightIndex -= 1\n        }\n        true", " \
    \       val reversed = text.foldLeft(\"\"){(a,b) => (b+a)}.reverse\n        text.equals(reversed)",
  "        if (text.size == 0) return true\n        val reverseText = reverse(text)\n\
    \        val reversedTextLength = (reverseText + text.substring(0, text.length-1))\
    \ length\n        if (reversedTextLength == text.length) return true\n       \
    \ else return false", "        var i = 0\n        val reverse = reverseString(text)\n\
    \        reverse == text", "        if (text == null || text.isEmpty || text.length\
    \ < 2) {\n            return true\n        }\n        val firstChar = text.charAt(0)\n\
    \        val lastChar = text.charAt(text.length - 1)\n        val reverse = lastChar\
    \ + firstChar\n        return reverse(text) == text", "        // Store the reversed\
    \ string\n        var reversedText = text.reverse\n        \n        // Check\
    \ if given string is a palindrome\n        if (reversedText eq text) {\n     \
    \       return true\n        }\n        \n        // Store the palindrome checks\n\
    \        var palindrome = true\n        \n        // Checks until half the length\
    \ of the given string\n        for( i <- 0 until text.length / 2) {\n        \
    \    // If the character at index 'i' is not equal the character at index 'i-i'\
    \ then it is not a palindrome\n            if (reversedText.charAt(i) ne reversedText.charAt(i\
    \ - i)) {\n                palindrome = false\n            }\n        }\n    \
    \    \n        return palindrome", "        val length = text.length\n       \
    \ if(length < 2) true\n        else {\n            val leftHalf = text.slice(0,\
    \ length/2)\n            val rightHalf = text.slice(length/2, length)\n\n    \
    \        val middleHalf = text.slice((length/2)..length)\n            val middleHalfReverse\
    \ = text.slice((length/2)..length, reverse)\n\n            leftHalf == rightHalf\
    \ && middleHalf == middleHalfReverse\n        }", "        text.split(' ').length\
    \ == text.length", "        val s = text.mkString.toLowerCase.trim\n        s\
    \ = s.reverse.equalsIgnoreCase(s)\n        s", "        var str1 : (String, String)\
    \ = (\"\", \"\")\n        var str2 : (String, String) = (\"\", \"\")\n       \
    \ for (i <- 0 until text.length) {\n            str1 = (str1 :+ (text.charAt(i)),\
    \ text.charAt(i))\n            str2 = (str2 :+ (text.charAt(i)), text.charAt(i))\n\
    \        }\n        val str3 = str1.reverse == str2\n        return str3", " \
    \       val length = text.length\n        if(length == 0)\n            return\
    \ true\n        if(length == 1)\n            return text == text.head\n      \
    \  val firstChar = text.head\n        val lastChar = text.last\n        if(firstChar\
    \ != lastChar)\n            return false\n        val middleIndex = text.length\
    \ / 2\n        var firstHalf = text.slice(0, middleIndex)\n        var lastHalf\
    \ = text.slice(middleIndex + 1, text.length)\n        if(firstHalf == lastHalf)\n\
    \            return true\n        else\n            return isPalindrome(firstHalf)\
    \ && isPalindrome(lastHalf)", "        var index : Int = 0\n        var end :\
    \ Int = text.length\n        while (index<end) {\n            if (text.charAt(index)\
    \ != text.charAt(end)) {\n                return false\n            }\n      \
    \      index++\n            end--\n        }\n        return true", "        val\
    \ charSet = text.filter(x => x != '-')\n        val charArray = charSet.toArray\n\
    \        var i = 0\n        var j = 0\n        while (j < charArray.length - 1)\
    \ {\n            if (charArray(i) != charArray(j)) {\n                return false\n\
    \            }\n            i += 1\n            j += 1\n        }\n        return\
    \ true", "        // Check if text is empty\n        if(text.isEmpty) true\n \
    \       else if(text.length == 1) true\n        else {\n            // Keep track\
    \ of current character and previous character\n            var currentChar = text.head\n\
    \            var prevChar = text.head\n            var isPalend = true\n\n   \
    \         for(i <- text.tail until text.length) {\n                if(prevChar\
    \ != currentChar) {\n                    isPalend = false\n                  \
    \  break\n                }\n                prevChar = currentChar\n        \
    \        currentChar = text.apply(i)\n            }\n\n            isPalindrome\
    \ = isPalindrome && isPalindrome(text.tail)\n        }\n        return isPalindrome",
  '        text.charAt(0) == text.charAt(text.length-1) && text.groupBy { x => x }
    forall { x => (x._1 == x._2) } && text.groupBy { x => x } forall { x => (x._2
    != x._1) }', "        val charArray = text.toCharArray\n        var isPalindrome\
    \ = true\n\n        var charIndex = 0\n        var reverseIndex = 0\n        for\
    \ (i <- 0 until charArray.length - 1) {\n            if (charArray(i) != charArray(reverseIndex))\
    \ {\n                isPalindrome = false\n                break\n           \
    \ }\n            charIndex += 1\n            reverseIndex += 1\n        }\n  \
    \      return isPalindrome", "        var firstIndex : int = 0\n        var lastIndex\
    \ : int = text.length - 1\n        var isPalindrome : Boolean = true\n       \
    \ while (firstIndex < lastIndex) {\n            if (text.charAt(firstIndex) !=\
    \ text.charAt(lastIndex)) {\n                isPalindrome = false\n          \
    \      break\n            }\n            firstIndex += 1\n            lastIndex\
    \ -= 1\n        }\n        return isPalindrome", "        val characterCount =\
    \ text.length\n        val palindromes = mutable.ListBuffer[String]()\n      \
    \  var index = 0\n        while (index < characterCount) {\n            val newIndex\
    \ = (index + characterCount - 1).toInt\n            val char = text.charAt(index)\n\
    \            if (char != text.charAt(newIndex)) {\n                palindromes\
    \ += text\n            }\n            index = newIndex\n        }\n        palindromes.isEmpty",
  "        var isPalindrome = true\n        for (i <- 0 until text.length / 2)\n \
    \           if(!isPalindrome && text.charAt(i) != text.charAt(text.length - i\
    \ - 1))\n                isPalindrome = false\n        \n        return isPalindrome",
  "        val arr = text.split\n        val rev = arr.last.reverse\n        arr ==\
    \ rev", "      var strLength = text.length\n      var middle = strLength / 2\n\
    \      var result = true\n      while(strLength > 0) {\n        if(text.charAt(middle)\
    \ != text.charAt(strLength - middle - 1)) {\n          result = false\n      \
    \  }\n        strLength = strLength - 1\n        middle = strLength / 2\n    \
    \  }\n      result", "        // Using mutable collection\n        var result\
    \ = new mutable.ListBuffer[String]()\n\n        for(i <- text.length-1 to 0 by\
    \ -1){\n            result += text.charAt(i)\n        }\n        \n        //\
    \ if strings are equal, they are palindrome\n        if(result == text.reverse){\n\
    \            return true\n        }\n\n        // if strings are not equal, they\
    \ are not palindrome\n        return false", "        var i = 0\n        var j\
    \ = text.length - 1\n        var reversed = \"\"\n        while (i < j) {\n  \
    \          if (text.charAt(i) != text.charAt(j)) {\n                reversed =\
    \ reversed + text.charAt(i)\n                i = i + -1\n                j = j\
    \ - -1\n            }\n            i = i + 1\n            j = j - 1\n        }\n\
    \        return text == reversed", "        val len = text.length\n        if\
    \ (len == 0) return true\n        var rev : String = \"\"\n        var i = 0\n\
    \        while(i < len)\n        {\n            val ch = text.charAt(i-1)\n  \
    \          rev = rev + ch\n            i += 1\n        }\n        val revlen =\
    \ rev.length\n        if (len != revlen) return false\n        for(i = 0 to len-1)\n\
    \        {\n            if (text.charAt(i) != rev.charAt(i)) return false\n  \
    \      }\n        return true", "        var charArray = text.toCharArray.sorted\n\
    \        var reverseCharArray = charArray.sortBy(_).reverse\n        var result\
    \ = (charArray == reverseCharArray)\n        return result", "        var isPalindrome\
    \ = true // Set this to false so we don't have to check more than once\n     \
    \   val buffer = new StringBuilder\n        var current = 0 // Start of current\
    \ character\n\n        // If we're at a boundary, move to next one\n        while\
    \ (current < text.length && current > -1) {\n            buffer.append(text(current))\n\
    \            current = (current + 1) // Move to next character\n        }\n  \
    \      val reversed = buffer.reverse()\n        if (text == reversed) {\n    \
    \        isPalindrome = true // If they're equal, they're palindromes\n      \
    \  }\n        else {\n            isPalindrome = false\n        }\n        return\
    \ isPalindrome", "        val textAsList = text.split('')\n        var reversedText\
    \ : List[Char] = Nil\n        for (i <- 0 until textAsList.length / 2) {\n   \
    \         reversedText ::= textAsList(i)\n        }\n        reversedText ::=\
    \ textAsList.last\n        var charsAsList = Nil\n        for (c <- reversedText)\
    \ {\n            charsAsList ::= c\n        }\n        charsAsList == text", " \
    \       var temp = text\n        if (text == \"\") {\n            return true\n\
    \        }\n        val array = text.split(\"\").toArray\n        val reversed\
    \ = Array.reverse(array)\n        if (reversed.toSeq == array) {\n           \
    \ return true\n        }\n        return false", "        val chars = text.chars\n\
    \        var i = 0\n        var j = chars.length - 1\n        var reversed = false\n\
    \        while (i < j) {\n            if (chars(i) != chars(j)) {\n          \
    \      reversed = !reversed\n            }\n            i += 1\n            j\
    \ -= 1\n        }\n        reversed", '        text == reverse(text).reverse',
  "        // TODO: Implement this function\n        val array = text.chars.toList\n\
    \        val start = 0\n        val end = array.length - 1 \n        while(start\
    \ < end) {\n            if(array.getOrElse(start, \"\") != array.getOrElse(end,\
    \ \"\")) {\n                return false\n            }\n            start = start\
    \ + 1\n            end = end - 1\n        }\n        return true", "        var\
    \ i = 0\n        var j = text.length-1\n        while (i <= j) {\n           \
    \ if (text.charAt(i) != text.charAt(j)) {\n                return false\n    \
    \        }\n            i += 1\n            j -= 1\n        }\n        return\
    \ true", "        if (text.length < 1) return true\n        var front = 0\n  \
    \      var back = text.length - 1\n        while (front < back) {\n          \
    \  if (text.charAt(front) != text.charAt(back)) {\n                return false\n\
    \            }\n            front = front + 1\n            back = back - 1\n \
    \       }\n        return true", "        val buffer = new StringBuilder()\n \
    \       val buffer = new StringBuilder()\n        for (i <- 0 until text.length)\n\
    \            buffer.append(text(i))\n        val lastIndex = buffer.length - 1\n\
    \        val firstIndex = buffer.indexOf('a') + 1\n        if (firstIndex > lastIndex)\
    \ false\n        else {\n            val bufferSubset = new StringBuilder(buffer(firstIndex))\n\
    \            while (bufferSubset.length() < (lastIndex - firstIndex))\n      \
    \          bufferSubset.append(buffer.charAt(firstIndex))\n            bufferSubset\
    \ == buffer(lastIndex)\n        }", "        val startIndex = text.lastIndexOf('a')\n\
    \        val endIndex = text.lastIndexOf('z')\n        if(startIndex < 0 || endIndex\
    \ < 0 || startIndex > endIndex)\n            return false\n        val subText\
    \ = text.substring(startIndex+1, endIndex)\n        val reverseSubText = subText.reverse\n\
    \        if(subText != reverseSubText)\n            return false\n        val\
    \ lastIndex = text.lastIndexOf('a')\n        val firstIndex = text.indexOf('z')\n\
    \        if(firstIndex < 0 || lastIndex < 0 || firstIndex > lastIndex)\n     \
    \       return false\n        val subTextIndex = text.substring(firstIndex+1,\
    \ lastIndex+1)\n        val reverseSubTextIndex = subTextIndex.reverse\n     \
    \   if(subTextIndex != reverseSubTextIndex)\n            return false\n      \
    \  true", "        if (text == \"\") return true\n        val reversedText = reverseString(text)\n\
    \        if (reversedText != text) return false\n        return isPalindrome(text)",
  "        var textArray = text.toCharArray\n        var rev = textArray.mkString\n\
    \        var revArray = rev.toCharArray\n\n        if (revArray.length == textArray.length)\
    \ {\n            for (i <- 0 until revArray.length-1)\n                if (textArray(i)\
    \ != revArray(i)) {\n                    return false\n                }\n   \
    \         return true\n        }\n        return false", "        var reverseText\
    \ = text.reverse\n        reverseText.length == text.length && text == reverseText",
  "        if(text.length < 2) return true\n        val len = text.length\n      \
    \  val start = len/2\n        val middle = len/2 - 1\n        var flag = false\n\
    \        for(x<-start until len){\n            if(text(x) != text(middle)) {\n\
    \                flag = false\n            }\n        }\n        return flag",
  "        val reverseText = reverseString(text)\n        if (text == reverseText)\
    \ {\n            return true\n        }\n        else {\n            return false\n\
    \        }", "        val text = text.foldLeft(true)((result, c) => result &&\
    \ c.toString.reverse == c.toString)\n        text", "        if (text.length <=\
    \ 1) {\n            return true\n        }\n        var i : Int = 0\n        var\
    \ j = text.length - 1\n        while (i >= 0 && j <= 0){\n            if (text.charAt(i)\
    \ != text.charAt(j)) {\n                return false\n            }\n        \
    \    i = i - 1\n            j = j - 1\n        }\n        if (i >= 0) {\n    \
    \        return true\n        }\n        return false", "        val lenText =\
    \ text.length\n        var low = 0\n        var high = lenText - 1\n\n       \
    \ while (low < high) {\n            if (text(low) !=text(high)) {\n          \
    \      return false\n            }\n            low += 1\n            high -=\
    \ 1\n        }\n        return true", "        var reverseText = \"\"\n      \
    \  var index = 0\n        while (index < text.length) {\n            reverseText\
    \ = reverseText + text.charAt(index).toChar\n            index = index + 1\n \
    \       }\n        return text.equals(reverseText)", "        def leftmostCharIndex(text\
    \ : String) : Int = {\n            var index = 0\n            while(index <= text.length-1)\
    \ {\n                if(text.charAt(index) != text.charAt(text.length-1)){\n \
    \                   return index\n                }\n                index = index\
    \ + 1\n            }\n            index = text.length - 1\n            return\
    \ index\n        }\n\n        def rightmostCharIndex(text : String) : Int = {\n\
    \            var index = text.length - 1\n            while(index >= 0) {\n  \
    \              if(text.charAt(index) != text.charAt(0)){\n                   \
    \ return index\n                }\n                index = index - 1\n       \
    \     }\n            index = 0\n            return index\n        }\n\n      \
    \  val len = text.length\n        if(text.length == 0){\n            return true\n\
    \        }\n        val leftmost = leftmostCharIndex(text)\n        val rightmost\
    \ = rightmostCharIndex(text)\n\n        if(leftmost > rightmost){\n          \
    \  val temp = text\n            text = text.substring(0,rightmost)\n         \
    \   text = text + temp.substring(leftmost)\n        }\n\n        val str1 =  text.charAt(0).toString.toInt\n\
    \        val str2 = text.charAt(text.length-1).toString.toInt\n        if(str1\
    \ == str2){\n            val middleIndex = leftmost + 1\n            for(i <-\
    \ leftmost until rightmost){\n                text = text + text.charAt(i)\n \
    \           }\n        }\n        text = text.toString.toInt\n        return text\
    \ == text.Reverse", "        val re = java.util.regex.Pattern.compile(\"^(.)\\\
    \\1$\").matcher(text)\n        val s = \"\"\n        var i = 0\n        var j\
    \ = text.length - 1 // length() returns length in chars\n        val rev = java.util.regex.Pattern.compile(\"\
    (.)\\\\1$\").matcher(text)\n        re.reset(text)\n        val rs = re.find(0)\n\
    \        while (rs.find()) {\n            s += rs.group()\n        }\n       \
    \ rev.reset(s)\n        val rt = rev.refind(0)\n        while (rt.find()) {\n\
    \            if (i < j) {\n                if (s.charAt(i) != s.charAt(j)) {\n\
    \                    return false\n                } else {\n                \
    \    i += 1\n                    j -= 1\n                }\n            }\n  \
    \      }\n        return true", "        val chars = text.toCharArray\n      \
    \  var i = 0\n        var j = chars.length - 1\n        while (i < j) {\n    \
    \        if (chars(i) != chars(j)) {\n                return false\n         \
    \   }\n            i += 1\n            j -= 1\n        }\n        true", "   \
    \     // Create an empty list to store characters of given string and reverse\
    \ it\n        var newText = new mutable.ListBuffer[String]()\n        for(i <-\
    \ text.length to 0 by -1){\n            newText += text(i)\n        }\n      \
    \  // Check if list is equal to reverse of original string\n        newText.reverse.sameElements(text)",
  "        // Write your code here\n        val reverse = text.reverse\n        reverse\
    \ == text", "        val charArray = text.toCharArray\n        var reverse = charArray.clone()\n\
    \        charArray.clone.reverse\n        charArray.reverse\n        var result\
    \ = true\n        var i = 0\n        var lastIndex = charArray.lastIndex\n   \
    \     var j = 0\n        while (i < charArray.length - 1 && j < charArray.length\
    \ - 1) {\n            if (charArray(i) != charArray(j)) {\n                result\
    \ = false\n                break\n            } else {\n                i += 1\n\
    \                j += 1\n            }\n        }\n        result", "        val\
    \ str = text.mkString\n        val reverse = str.split(\"\").reverse.mkString\n\
    \        reverse == str", "        if (text.length <= 1)\n            return true\n\
    \        val reverse = new StringBuilder(text).reverse()\n        return (text\
    \ == reverse)", "        val length = text.length\n        val stringArray = text.split(\"\
    \").toList\n        var isPalindrome = true\n        for(i <- 0 until stringArray.length\
    \ -1 ) {\n            if(!stringArray(i).equals(stringArray(i+1))) {\n       \
    \         isPalindrome = false\n                break\n            }\n       \
    \ }\n        isPalindrome", "        if (text == null || text.length < 1) return\
    \ true\n        var reversed = text.reverse\n        var i = 0\n        var j\
    \ = 0\n        while (i < text.length && j < reversed.length) {\n            if\
    \ (text(j) != reversed(i)) {\n                return false\n            }\n  \
    \          i += 1\n            j += 1\n        }\n        return true", "    \
    \    if (text.length <= 1)\n            return true\n        val reverseString\
    \ = reverseString2(text)\n        return text == reverseString", "        val\
    \ textLength = text.length\n        if (textLength <= 1)\n            return true\n\
    \        var left = 0\n        var right = textLength - 1\n        while (left\
    \ < right) {\n            if (text.charAt(left) != text.charAt(right))\n     \
    \           return false\n            left += 1\n            right -= 1\n    \
    \    }\n        return true", "        if (text.size == 0 || text.size() == 1)\
    \ {\n            return true\n        }\n\n        var left = text.substring(0,\
    \ text.length / 2)\n        var right = text.substring(text.length / 2, text.length)\n\
    \n        while (!isPalindromeHelper(left, right)) {\n            right = right.substring(0,\
    \ right.length - 1)\n        }\n\n        return true"]
stop_tokens:
- "\n    }\n"
