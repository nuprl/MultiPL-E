name: HumanEval_24_largest_divisor
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // For a given number n, find the largest number that divides n evenly, smaller\
  \ than n\n    // >>> largestDivisor((15l))\n    // (5l)\n    def largestDivisor(n\
  \ : Long) : Long = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(largestDivisor((3l))\
  \ == (1l));\n    assert(largestDivisor((7l)) == (1l));\n    assert(largestDivisor((10l))\
  \ == (5l));\n    assert(largestDivisor((100l)) == (50l));\n    assert(largestDivisor((49l))\
  \ == (7l));\n    }\n\n}\n"
completions: ["        val res = List((n/2l) until n)\n        for (d <- res)\n  \
    \          if (n % d == 0)\n                return d\n        return 0", "   \
    \     var largest = 0\n        var divisor = 1\n        while (divisor * divisor\
    \ <= n) {\n            if (n % divisor == 0) {\n                largest = divisor\n\
    \            }\n            divisor *= 2\n        }\n        if (divisor > n)\
    \ {\n            largest = divisor\n        }\n        largest", "        val\
    \ divisors = mutable.HashSet[Long]()\n        for (d <- 1l to n) divisors ++=\
    \ (d-1)/d \n        divisors.toList.sort{-_._1}.last", "        val ns: Seq[Long]\
    \ = for {\n            i <- 0 until n by 2\n        } yield i \n        val max:\
    \ Long = 0\n        ns.foreach { n =>\n            if(n % 2 == 0) max = math.max(max,\
    \ n) \n        }\n        max", "        var divisible : Long = 0L\n        var\
    \ number : Long = 0L\n        for (i <- 1 to n) number += i\n        for (i <-\
    \ 1 to number) divisible += i / number\n        divisible", "        // Find the\
    \ smallest divisor of n\n        // >>> smallestDivisor((3l))\n        // (1l)\n\
    \        def smallestDivisor(n : Long) : Long = {\n            // Find all factors\
    \ of n and store them in an Array\n            val factors: Array[Long] = Array()\n\
    \            for (f <- 1 to n) {\n                if (n % f == 0) {\n        \
    \            factors = factors :+ f\n                }\n            }\n      \
    \      val largest: Long = factors.max\n            // If the largest factor\n\
    \            if (largest == n) largest\n            else smallestDivisor(largest)\n\
    \        }\n\n        // Find the smallest divisor of n\n        // >>> smallestDivisor((3l))\n\
    \        // (1l)\n        smallestDivisor(n)", "        var ans = n\n        val\
    \ dn = div(n, 2L)\n        if (dn != 0) {\n            ans = dn\n            n\
    \ -= dn\n        }\n        val dn2 = div(n, 3L)\n        if (dn2 != 0) {\n  \
    \          ans = dn\n            n -= dn\n        }\n        val dn3 = div(n,\
    \ 5L)\n        if (dn3 != 0) {\n            ans = dn\n            n -= dn\n  \
    \      }\n        val dn4 = div(n, 7L)\n        if (dn4 != 0) {\n            ans\
    \ = dn\n            n -= dn\n        }\n        val dn5 = div(n, 11L)\n      \
    \  if (dn5 != 0) {\n            ans = dn\n            n -= dn\n        }\n   \
    \     val dn7 = div(n, 13L)\n        if (dn7 != 0) {\n            ans = dn\n \
    \           n -= dn\n        }\n        val dn11 = div(n, 17L)\n        if (dn11\
    \ != 0) {\n            ans = dn\n            n -= dn\n        }\n        val dn13\
    \ = div(n, 19L)\n        if (dn13 != 0) {\n            ans = dn\n            n\
    \ -= dn\n        }\n        val dn17 = div(n, 23L)\n        if (dn17 != 0) {\n\
    \            ans = dn\n            n -= dn\n        }\n        val dn19 = div(n,\
    \ 29L)\n        if (dn19 != 0) {\n            ans = dn\n            n -= dn\n\
    \        }\n        val dn23 = div(n, 31L)\n        if (dn23 != 0) {\n       \
    \     ans = dn\n            n -= dn\n        }\n        val dn29 = div(n, 35L)\n\
    \        if (dn29 != 0) {\n            ans = dn\n            n -= dn\n       \
    \ }\n        val dn31 = div(n, 37L)\n        if (dn31 != 0) {\n            ans\
    \ = dn\n            n -= dn\n        }\n        val dn35 = div(n, 41L)\n     \
    \   if (dn35 != 0) {\n            ans = dn\n            n -= dn\n        }\n \
    \       val dn37 = div(n, 45L)\n        if (dn37 != 0) {\n            ans = dn\n\
    \            n -= dn\n        }\n        val dn41 = div(n, 47L)\n        if (dn41\
    \ != 0) {\n            ans = dn\n            n -= dn\n        }\n        val dn45\
    \ = div(n, 49L)\n        if (dn45 != 0) {\n            ans = dn\n            n\
    \ -= dn\n        }\n        val dn47 = div(n, 51L)\n        if (dn47 != 0) {\n\
    \            ans = dn\n            n -= dn\n        }\n        val dn49 = div(n,\
    \ 53L)\n", "        var maxDivisor = 0\n        var currentDivisor = 0\n     \
    \   var currentNumber = 0\n\n        // For all numbers, we can check if they\
    \ are evenly divisble or not by\n        // checking if they divides evenly to\
    \ n\n        for (currentNumber = n downTo 1 by -1) {\n            currentDivisor\
    \ = 1\n            // If n is evenly divisble by current number, check if it divides\
    \ evenly to currentDivisor\n            while (currentNumber % currentDivisor\
    \ == 0) {\n                currentDivisor += 1\n            }\n\n            //\
    \ For current number, check if it is larger than maxDivisor\n            if (currentDivisor\
    \ > maxDivisor) {\n                maxDivisor = currentDivisor\n            }\n\
    \        }\n        return maxDivisor", "        val divisors = List(1l, 2l, 3l,\
    \ 4l, 5l, 6l, 7l, 8l, 9l, 10l, 11l, 12l, 13l, 14l, 15l)\n        var maxDivisor\
    \ = 0L\n        divisors.foreach{div =>\n            val num = (n/div).toInt\n\
    \            if (num > maxDivisor) maxDivisor = num\n        }\n        return\
    \ maxDivisor", "        val d = mutable.Set[Long]()\n        for(i <- 0 until\
    \ n) if(n % i == 0) d += i\n        val lv = d.foldLeft(0l)((m,i) => if { m >\
    \ i } m else i)\n        if(lv < n) largestDivisor(lv) else lv", "        val\
    \ d = new scala.collection.mutable.HashMap[Long, Long]()\n        for (i <- 2\
    \ to Math.sqrt(n)) {\n            if (n%i == 0) {\n                val d = i\n\
    \                if (d.exists(_ > n)) d = -1\n                d.foreach { v =>\
    \ d.remove(v) }\n                if (d.isEmpty) d.foreach { v => d.put(v, v) }\n\
    \                else d.foreach { v => d.put(v, v) }\n            }\n        }\n\
    \        d max n match {\n            case None => -1\n            case Some(d)\
    \ => d\n        }", "        val nums = mutable.Set[Long]()\n        var currentNum\
    \ : Long = 1\n        while(currentNum <= n){\n            if(n % currentNum ==\
    \ 0){\n                nums += currentNum\n            }\n            currentNum\
    \ += 1\n        }\n        \n        var result = nums.max\n        if(result\
    \ > n){\n            result = n\n        }\n        result", "        if (n ==\
    \ 1) 1\n        else {\n            val divisors = mutable.Set[Long]()\n     \
    \       // Find all numbers that divide n evenly and are less than n\n       \
    \     for (i <- n.divideAndRemainder until n) divisors += i\n            // Get\
    \ the largest of those\n            divisors.max\n        }", "        var maxDiv\
    \ = n\n        while(n % maxDiv != 0){\n            maxDiv += 1\n        }\n \
    \       maxDiv", "        val divisors = mutable.ArrayBuffer.empty[Long]\n   \
    \     for( i <- 2l to n by 2l) {\n            if( n % i == 0)\n              \
    \  divisors += i\n        }\n        divisors.max", "        // Sieve of Eratosthenes\
    \ - Finds all primes less than or equal to n\n        // https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\n\
    \        val primes = Vector.fill(Long.MaxValue){2}\n        primes(0) = 1\n \
    \       primes(1) = 1\n\n        for(i <- 2 to n-1)\n            if(!primes(i)){\n\
    \                primes(2*i+1) = primes(i)+1\n                primes(2*i+2) =\
    \ primes(i)+2\n            }\n\n        val maxDivisors = mutable.ArrayBuffer[Long]()\n\
    \n        // Filter out all numbers that are not divisible by 2 and not smaller\
    \ than n\n        for(n <- primes.filter(_<n) ){\n            for(i <- 1 to n/2){\n\
    \                if(primes(n) != 2 && (n/i) % primes(n) == 0)\n              \
    \      maxDivisors += n\n            }\n        }\n        \n        // Return\
    \ the largest divisor\n        maxDivisors.max", "        val l = n.toLong\n \
    \       val divisor = scala.collection.mutable.LinkedHashSet()\n        for (i\
    \ <- 0 until l) {\n            val num = (i*l).floorDiv(n)\n            divisor.add(num)\n\
    \        }\n        divisor.toSeq.sorted.last", "        val nums = Vector.fill(n/2+1).map(_*2-1).toSeq\n\
    \        for (i <- 0 until nums.lastIndex) {\n            if (nums(i) % n == 0)\
    \ return nums(i)\n        }\n        -1l", "        val l = (n to 1)\n       \
    \     .map(n => (n to n)\n                .filter { d => n%d == 0 }\n        \
    \        .maxBy(_.toLong)\n                .get)\n            .max\n        l",
  "        val ds = new mutable.ListBuffer[Long]()\n        for (d <- 0 until n) \n\
    \            if ((n % d) == 0) ds += d\n        ds.max", "        val factors\
    \ = Vector.newBuilder[Int]\n        for(d <- 1 to n) factors += (n / d)\n    \
    \    factors.result.getOrElse(0)", "        val result = mutable.ListBuffer[Long]()\n\
    \        val div = 1 to n.toInt\n        var maxDiv = -1l\n        for (d <- div)\
    \ {\n            val r = n % d\n            if (r == 0) {\n                result\
    \ += d\n                if (d > maxDiv) maxDiv = d\n            }\n        }\n\
    \        result.foldLeft(0l) { (m, v) => if (v > m) v else m }", "        var\
    \ largestDiv = 1\n        for (i<- 1 to n) {\n            val div = i%largestDiv\n\
    \            if (div == 0) largestDiv = div\n            else largestDiv = div\n\
    \        }\n        return largestDiv", "        val numbers = List.range(1, n).map(x\
    \ => x / 2l)\n        var maxDiv = numbers.max\n\n        numbers foreach { x\
    \ =>\n            if (x / maxDiv > n) maxDiv = x\n        }\n        return maxDiv",
  "        val r = n.reciprocal()\n        val r = r.toDouble\n        val v = r.toLong\n\
    \        val a = r.toInt\n\n        for(i <- 0 until a){\n            val q =\
    \ v / i \n            if(q.isEven && q.isWholeNumber){\n                return\
    \ q.toLong\n            }\n        }\n\n        0", "        // Find the greatest\
    \ divisor less than n\n        var largestDivisor = 0\n        for(d <- 0 until\
    \ Int\n            if(n % d == 0){\n                largestDivisor = d\n     \
    \       }\n        }\n        // Return largest divisor that is smaller than n\n\
    \        if(largestDivisor == 0){\n            largestDivisor = 1\n        }\n\
    \        largestDivisor", "        var max: Long = n\n        var maxCount: Int\
    \ = 0\n        var maxCountDiv: Int = 0\n        while (n % 2 == 0) {\n      \
    \      n /= 2\n            maxCountDiv += 2\n        }\n        while (n != 1)\
    \ {\n            n -= 1\n            maxCountDiv += 1\n            while (n %\
    \ 2 == 0) {\n                n /= 2\n                maxCountDiv += 2\n      \
    \      }\n        }\n        if (maxCountDiv > maxCount) {\n            max =\
    \ maxCountDiv\n        }\n        maxCountDiv = 0\n        while (n != 1) {\n\
    \            n -= 1\n            maxCountDiv += 1\n            while (n % 2 ==\
    \ 0) {\n                n /= 2\n                maxCountDiv += 2\n           \
    \ }\n        }\n        if (maxCountDiv == maxCount) {\n            max = maxCountDiv\n\
    \        }\n        maxCountDiv = 0\n        while (n % 2 == 0) {\n          \
    \  n /= 2\n            maxCountDiv += 2\n        }\n        if (maxCountDiv ==\
    \ maxCount) {\n            max = maxCountDiv\n        }\n        maxCountDiv =\
    \ 0\n        while (n % 2 == 0) {\n            n /= 2\n            maxCountDiv\
    \ += 2\n        }\n        if (maxCountDiv == maxCount) {\n            max = maxCountDiv\n\
    \        }\n        maxCountDiv = 0\n        while (n % 2 == 0) {\n          \
    \  n /= 2\n            maxCountDiv += 2\n        }\n        if (maxCountDiv ==\
    \ maxCount) {\n            max = maxCountDiv\n        }\n        maxCountDiv =\
    \ 0\n        while (n % 2 == 0) {\n            n /= 2\n            maxCountDiv\
    \ += 2\n        }\n        if (maxCountDiv == maxCount) {\n            max = maxCountDiv\n\
    \        }\n        maxCountDiv = 0\n        while (n % 2 == 0) {\n          \
    \  n /= 2\n            maxCountDiv += 2\n        }\n        if (maxCountDiv ==\
    \ maxCount) {\n            max = maxCountDiv\n        }\n        maxCountDiv =\
    \ 0\n        while (n % 2 == 0) {\n            n /= 2\n            maxCountDiv\
    \ += 2\n        }\n        if (maxCountDiv == maxCount) {\n            max = maxCountDiv\n\
    \        }\n        maxCountDiv = 0\n        while (n % 2 == 0) {\n          \
    \  n /= 2\n            maxCountDiv += 2\n        }\n        if (maxCountDiv ==\
    \ maxCount) {\n            max = maxCountDiv\n        }\n        maxCountDiv =\
    \ 0\n        while (n % 2 == 0) {\n            n /= 2\n            maxCountDiv\
    \ += 2\n        }\n        if (maxCountDiv == maxCount) {\n            max = maxCountDiv\n\
    \        }\n        maxCountDiv = 0\n        while (n % 2 == 0) {\n          \
    \  n /= 2\n            maxCountDiv += 2\n        }\n        if (maxCountDiv ==\
    \ maxCount) {\n            max = maxCountDiv\n        }\n", "        val divisors\
    \ = mutable.LinkedHashMap[Long, Int]()\n        for {\n            i <- 0 to n\n\
    \        } divisors += i -> divisors.getOrElse(i, 0) + 1\n        var max = 0\n\
    \        for (i <- divisors.keys) if (divisors(i) > max) max = divisors(i)\n \
    \       divisors.maxBy(_._2)._1", "        val factors = mutable.HashSet[Long]()\n\
    \        for (i <- 1 to n) factors += (n / i)\n        factors.max", "       \
    \ val max = scala.math.max(scala.math.div(n, 2), scala.math.div(n, 4))\n     \
    \   if (max == 0) {\n            n // no divisors possible\n        } else {\n\
    \            largestDivisor(max)\n        }", "        val nums = mutable.ListBuffer.empty[Long]\n\
    \        val d = 1l\n        while (d <= n) {\n            if (n % d == 0l) {\n\
    \                nums.append(d)\n            }\n            d = d + 1l\n     \
    \   }\n        nums.max", "        def largestDivisorHelper(n : Long, maxDiv :\
    \ Long) : Long = {\n            if (n == 1L) {\n                if (maxDiv > 1L)\n\
    \                    maxDiv\n                else\n                    0L\n  \
    \          } else if (n >= 2L) {\n                maxDiv = largestDivisorHelper(n\
    \ / 2L, maxDiv)\n                largestDivisorHelper(n / 2L, maxDiv)\n      \
    \      } else {\n                maxDiv\n            }\n        }\n        largestDivisorHelper(n,\
    \ 0L)", "        var largest = 0\n        var current = n\n        while(current\
    \ > 0){\n            if(current % 2 == 0) current /= 2\n            else largest\
    \ = max(largest, current)\n        }\n        largest", "        val result =\
    \ mutable.MutableList[Long]()\n        for (d <- 2 until n) if (n % d == 0) {\
    \ result += d }\n        if (result.isEmpty) {\n            // if all divisors\
    \ are even or smaller than n, then n is even\n            n / 2\n        } else\
    \ {\n            if (result.head % 2 == 0) {\n                result.head / 2\n\
    \            } else {\n                result.head / result.last\n           \
    \ }\n        }", "        val listOfDivisors = n.toInt :: List.empty\n       \
    \ var largestDivisor = 0L\n\n        for (i <- listOfDivisors) {\n           \
    \ if (n % i == 0L && i > largestDivisor) {\n                largestDivisor = i\n\
    \            }\n        }\n\n        largestDivisor", "        val divisors =\
    \ (1 to n) map (n / _)\n        val max_divisor = divisors.max\n        max_divisor\
    \ * max_divisor", "        val divisors = mutable.ArrayBuffer.empty[Long]\n  \
    \      for (nDiv <- (n to 1 by -1); nDiv > 1; nDiv = nDiv / 2)\n            divisors\
    \ += nDiv\n            divisors.toArray", "        var maxDiv = 0\n        var\
    \ divisor = 0\n        // Find all divisors until n is greater than maxDivisor\
    \ \n        while ( divisor*divisor <= n ) {\n            divisor = divisor*divisor\
    \ + n\n            if ( divisor*divisor > n ) {\n                maxDiv = divisor\n\
    \            }\n        }\n        if ( divisor < n ) {\n            // If no\
    \ divisors less than n found\n            maxDiv = n - 1\n        }\n        if\
    \ ( maxDiv*maxDiv > n ) {\n            // If n is not prime, return the greatest\
    \ divisor less than n\n            maxDiv = n - 1\n        }\n        maxDiv",
  "        require(n > 0)\n        var largest_divisor = 0l\n        var divisor_count\
    \ = 0l\n        var largest_divisor_count = 0\n        while (divisor_count <\
    \ n) {\n            divisor_count = divisors_of(n, n)\n            largest_divisor_count\
    \ = largest_divisors_of(divisor_count)\n            if (largest_divisor_count\
    \ == divisor_count) {\n                largest_divisor = divisor_count\n     \
    \       } else if (largest_divisor_count > divisor_count) {\n                largest_divisor\
    \ = largest_divisor_count\n            }\n        }\n        largest_divisor",
  "        var maxNum = n + 1;\n        var largestDivisor = n + 1;\n        var maxDiv\
    \ = 1\n        while(maxDiv < largestDivisor) {\n            val curDivisor =\
    \ maxDiv\n            val curNum = maxNum / curDivisor\n            if (curNum\
    \ % 2 == 0) {\n                maxNum = curNum\n            } else {\n       \
    \         largestDivisor = curDivisor\n                maxDiv = curDivisor\n \
    \           }\n        }\n        maxNum", "        val divistions = mutable.ArrayBuffer.empty[Long]\n\
    \        var i = 0\n        while (i < n) {\n            divistions += i\n   \
    \         i += 1\n        }\n        divistions.max", "        val numbers = mutable.ListBuffer[Long]()\n\
    \        val rem = n\n        val r = BigInt(n)\n        while (BigInt(rem) !=\
    \ 0) {\n            if (rem % r == 0) {\n                numbers += r\n      \
    \      }\n            r = r / 2\n        }\n        numbers.last", "        val\
    \ nums = mutable.LinkedHashSet[Long]()\n        while (n != 0) {\n           \
    \ val d = n % 10\n            if (d == 0) {\n                nums += n\n     \
    \       } else {\n                nums += d * 10\n            }\n            n\
    \ /= 10\n        }\n        nums.lastOption.getOrElse(0)", "        val d = mutable.HashSet[Long]()\n\
    \        for (i <- 2 to (math.sqrt(n).toInt)) {\n            if (n % i == 0) {\n\
    \                d += i\n            }\n        }\n        val max = d.toSeq.max\n\
    \        if (max >= n) max else n", "        var biggest = 1l\n        var divisor\
    \ : Long = 1l\n        var remainder : Long = 1l\n        for(divisor <- 2l*(n\
    \ + 1) to (2l*n + 2l)) remainder <- n%divisor\n        if(remainder < n) biggest\
    \ = divisor\n        else largestDivisor(biggest)", "        val divi = List[Long]()\n\
    \        var maxDiv = n\n        while (maxDiv != 0) {\n            if (maxDiv\
    \ % 2 == 0) {\n                if (maxDiv / 2 > divi.length) {\n             \
    \       divi = divi :+ maxDiv / 2\n                }\n            }\n        \
    \    maxDiv = maxDiv / 2\n        }\n        divi.max", "        // Initialize\
    \ a maximum divisor and number that are currently divisable\n        var maxDivisor\
    \ = 0\n        var maxDivisorNum = 0\n        var currentDivisor = 0\n       \
    \ var currentDivisorNum = 0\n        for(i <- 0 until n) {\n            // Check\
    \ to see if there are any divisors left that aren't divisible by i\n         \
    \   for(j <- 0 until n) {\n                if (i % j == 0)\n                 \
    \   break\n                else\n                    currentDivisorNum += 1\n\
    \            }\n            // If there aren't any divisors that aren't divisible\
    \ by i that are less than i, then\n            // this is a divisor that is greater\
    \ than i\n            if (currentDivisorNum > maxDivisorNum)\n               \
    \ maxDivisorNum = currentDivisorNum\n            // If i isn't divisible by any\
    \ divisors greater than i, then it is a divisor that is greater than i\n     \
    \       else\n                currentDivisorNum = 0\n        }\n        // Return\
    \ the largest divisor that is less than n\n        return maxDivisorNum", "  \
    \    val a = n.toInt\n      val max = a\n      val b = n.toLong\n      val l =\
    \ (n - 1) >>> 1\n      while (b > 0) {\n        if (b % 2 == 0) {\n          val\
    \ t = b / 2\n          if (t >= max && t != l) {\n            max = t\n      \
    \    }\n        }\n        b /= 2\n      }\n      max", "        // Find the smallest\
    \ divisor which is greater than n\n        var smallestDivisor = n - 1\n     \
    \   var largestDivisor = n - 1\n        while (smallestDivisor % 2 == 0) {\n \
    \           smallestDivisor /= 2\n            largestDivisor /= 2\n        }\n\
    \        while (smallestDivisor % 3 == 0) {\n            smallestDivisor /= 3\n\
    \            largestDivisor /= 3\n        }\n        while (smallestDivisor %\
    \ 4 == 0) {\n            smallestDivisor /= 4\n            largestDivisor /= 4\n\
    \        }\n        while (smallestDivisor % 5 == 0) {\n            smallestDivisor\
    \ /= 5\n            largestDivisor /= 5\n        }\n        while (smallestDivisor\
    \ % 6 == 0) {\n            smallestDivisor /= 6\n            largestDivisor /=\
    \ 6\n        }\n        while (smallestDivisor % 7 == 0) {\n            smallestDivisor\
    \ /= 7\n            largestDivisor /= 7\n        }\n        while (smallestDivisor\
    \ % 8 == 0) {\n            smallestDivisor /= 8\n            largestDivisor /=\
    \ 8\n        }\n        while (smallestDivisor % 9 == 0) {\n            smallestDivisor\
    \ /= 9\n            largestDivisor /= 9\n        }\n        while (smallestDivisor\
    \ % 10 == 0) {\n            smallestDivisor /= 10\n            largestDivisor\
    \ /= 10\n        }\n        while (smallestDivisor % 11 == 0) {\n            smallestDivisor\
    \ /= 11\n            largestDivisor /= 11\n        }\n        while (smallestDivisor\
    \ % 12 == 0) {\n            smallestDivisor /= 12\n            largestDivisor\
    \ /= 12\n        }\n        while (smallestDivisor % 13 == 0) {\n            smallestDivisor\
    \ /= 13\n            largestDivisor /= 13\n        }\n        while (smallestDivisor\
    \ % 14 == 0) {\n            smallestDivisor /= 14\n            largestDivisor\
    \ /= 14\n        }\n        while (smallestDivisor % 15 == 0) {\n            smallestDivisor\
    \ /= 15\n            largestDivisor /= 15\n        }\n        while (smallestDivisor\
    \ % 16 == 0) {\n            smallestDivisor /= 16\n            largestDivisor\
    \ /= 16\n        }\n        while (smallestDivisor % 17 == 0) {\n            smallestDivisor\
    \ /= 17\n            largestDivisor /= 17\n        }\n        while (smallestDivis",
  "        val divisors = Set()\n        val factors = Set()\n        val lowLimit\
    \ = 0\n        var largest = 1l\n\n        // The idea is to start from the highest\
    \ divisor and keep dividing it until the factor\n        // is smaller than n\n\
    \        while (divisors.size < factors.size) {\n            divisor = divisors.head\n\
    \            divisors = divisors ++= factor.div(divisor)\n            factors\
    \ = factors ++= factor.filter(x => divisors.contains(x))\n            if (factors.size\
    \ < divisors.size)\n                divisors.clear\n            val factorOfCurrent\
    \ = divisors.head\n            val divisorOfCurrent = (divisors.size / factorOfCurrent).toLong\
    \ * factorOfCurrent\n            if (n % divisorOfCurrent > divisor)\n       \
    \         largest = divisorOfCurrent\n        }\n        largest", "        //\
    \ Set up an Array to store our divisors\n        var divisors = Array[Long](0)\n\
    \        // If n has no divisor then return n\n        if (n % 2 == 0) {\n   \
    \         return n\n        }\n        // Start at 2 to the power of (n-1)\n \
    \       for (i <- 2 to n-1) {\n            // Check if the number is evenly divisible\
    \ by i\n            if (n % i == 0) {\n                // If it is, add it to\
    \ the list of divisors\n                divisors = divisors :+ i\n           \
    \     // If it isn't, then this number is greater than any divisor we've found,\
    \ so remove it from the list of divisors\n            }\n        }\n        //\
    \ Return our result\n        divisors.max", "        val divisors = mutable.HashMap.empty[Long,Long]\n\
    \        for (i <- 1 to n) {\n            val currentDivisor = i / n\n       \
    \     if (divisors.contains(currentDivisor))\n                divisors(currentDivisor)\
    \ = divisors(currentDivisor) + 1\n            else\n                divisors(currentDivisor)\
    \ = currentDivisor\n        }\n        var max = 0\n        divisors.foreach{case(k,v)\
    \ =>\n            if (v > max)\n                max = v\n        }\n        divisors.foreach{case(k,v)\
    \ =>\n            if (max > 0)\n                divisors(k) = max\n        }\n\
    \        divisors.maxBy(_._1) // return maxDivisor, maxDivisor >= n", "      \
    \  if (n < 1) \n            throw new Exception(\"ERROR: number must be positive\"\
    )\n        var max = n\n        var candidate = max\n        var lowDivisor =\
    \ 0\n        while (lowDivisor < max) {\n            var lowDivisor = candidate\n\
    \            var lowDivisor2 = lowDivisor * lowDivisor\n            val lowDivisor3\
    \ = lowDivisor2 * lowDivisor2\n            val lowDivisor4 = lowDivisor3 * lowDivisor3\n\
    \            val lowDivisor5 = lowDivisor4 * lowDivisor4\n            val lowDivisor6\
    \ = lowDivisor5 * lowDivisor5\n            if (lowDivisor6 == candidate) {\n \
    \               lowDivisor = lowDivisor2\n                lowDivisor3 = lowDivisor2\
    \ * lowDivisor2\n                lowDivisor4 = lowDivisor3 * lowDivisor3\n   \
    \             lowDivisor5 = lowDivisor4 * lowDivisor4\n                lowDivisor6\
    \ = lowDivisor5 * lowDivisor5\n            } else {\n                candidate\
    \ = lowDivisor6\n            }\n            if (lowDivisor == max) {\n       \
    \         lowDivisor = lowDivisor2\n                lowDivisor3 = lowDivisor2\
    \ * lowDivisor2\n                lowDivisor4 = lowDivisor3 * lowDivisor3\n   \
    \             lowDivisor5 = lowDivisor4 * lowDivisor4\n                lowDivisor6\
    \ = lowDivisor5 * lowDivisor5\n                candidate = lowDivisor6\n     \
    \       }\n            max = lowDivisor\n        }\n        candidate", "    \
    \    var biggestDivisor = 0l\n        var biggestDivisorDivisor = 0l\n       \
    \ var biggestDivisorLastRemainder = 0l\n        var lastRemainder = 0l\n     \
    \   var firstDivisor = 2l\n        var lastDivisor = 2l\n        var nextDivisor\
    \ = 2l\n        var isDivisorEven = true\n        var nTimesDivisor = 0l\n   \
    \     var nDivisors = 0l\n        var nDivisorsDivisor = 0l\n        var nDivisorsLastRemainder\
    \ = 0l\n        while (n > 0) {\n            nDivisors += 1\n            if (isDivisorEven)\
    \ {\n                nextDivisor = firstDivisor\n            } else {\n      \
    \          nextDivisor = lastDivisor\n            }\n            isDivisorEven\
    \ = !isDivisorEven\n            if (isDivisorEven) {\n                nDivisorsDivisor\
    \ += 1\n                while (n >= nextDivisor) {\n                    nTimesDivisor\
    \ += 1\n                    if (n % nextDivisor == 0l) {\n                   \
    \     biggestDivisor = nextDivisor\n                        nDivisorsLastRemainder\
    \ = 0l\n                        lastRemainder = n\n                        break\n\
    \                    } else {\n                        lastRemainder = n / nextDivisor\n\
    \                        nDivisorsLastRemainder += 1\n                    }\n\
    \                    nextDivisor = (nextDivisor + 1l) % (lastDivisor - 1l)\n \
    \               }\n            } else {\n                nDivisorsDivisor += 1\n\
    \                while (n >= nextDivisor) {\n                    nTimesDivisor\
    \ += 1\n                    if (n % nextDivisor == 0l) {\n                   \
    \     biggestDivisor = nextDivisor\n                        nDivisorsLastRemainder\
    \ = 0l\n                        lastRemainder = n\n                        break\n\
    \                    } else {\n                        lastRemainder = n / nextDivisor\n\
    \                        nDivisorsLastRemainder += 1\n                    }\n\
    \                    nextDivisor = (nextDivisor + 1l) % (lastDivisor - 1l)\n \
    \               }\n            }\n        }\n        return biggestDivisor", " \
    \       val divisors = mutable.HashMap[Long,Long]();\n        for (i <- 1L to\
    \ n){\n            val divisor = math.gcd(i,n);\n            if (divisors.contains(divisor))\
    \ {\n                divisors(divisor) = divisors(divisor) + i\n            }\
    \ else {\n                divisors += (divisor -> (i.toLong*divisor))\n      \
    \      }\n        }\n        divisors.maxBy(_._2)._1", "        var maxDivisor\
    \ = 0\n        val divisor : Set[Long] = Set()\n        for (a <- 1l to n) divisor.add\
    \ (2 * a)\n        divisor.toList.sortWith( (a,b) => b - a ).last", "        val\
    \ l = (2l*n).toInt / 2l\n        if (l % 2 == 0) l\n        else largestDivisor(l)",
  "        val n = n % 2\n        var result : Long = 0\n        var i = 1\n     \
    \   while(i <= n/2) {\n            if(n % i == 0) {\n                result =\
    \ Math.max(result, i); \n            }\n            i += 1\n        }\n      \
    \  result", "        // Use a mutable Set to track the largest divisor seen\n\
    \        val divSet = mutable.HashSet[Long]()\n        // Use a mutable Map to\
    \ track the highest divisor seen seen so far\n        val maxDiv = mutable.Map[Long,Long]()\n\
    \n        // Loop until n divides evenly by any number between 1 and n / 2\n \
    \       while ((n%2 != 0) && (divSet.size < n)){\n            // Keep track of\
    \ largest divisor seen so far\n            if (divSet.size == 0){\n          \
    \      maxDiv.put(n, 2l)\n            }\n            else {\n                if\
    \ (maxDiv.get(n) > maxDiv.get(divSet.min())){\n                    maxDiv.put(n,\
    \ divSet.min())\n                }\n            }\n            // If this number\
    \ is evenly divided by any number between 1 and n / 2, add it to divSet\n    \
    \        val nextDiv = n%2\n            if (divSet.contains(nextDiv)){\n     \
    \           divSet += nextDiv\n            }\n            n = n/2\n        }\n\
    \        if (divSet.size == 0){\n            return 1l\n        }\n        else\
    \ {\n            return maxDiv.get(n).asInstanceOf[Long]\n        }", "      \
    \  val divisors = mutable.Set[Long]()\n        var curDivisor = 1\n        for\
    \ (div <- divisors.iterator ; div <= n ; div = div * curDivisor) {\n         \
    \   if (div == n) curDivisor += 1\n            divisors += div\n        }\n  \
    \      divisors.reverse.max", "        var maxDiv = 2l\n        while(n > 1l){\n\
    \            if (n % maxDiv == 0) return maxDiv\n            maxDiv += 1l\n  \
    \      }\n        return maxDiv", "        val dive = mutable.HashMap[Long, Long]()\n\
    \        for (divisor <- 1 to n by 2) {\n            if (n % divisor == 0) dive.put(divisor,\
    \ divisor)\n        }\n        dive.foldLeft(1l){ case ((acc, divisor), (v, _))\
    \ =>\n            if (acc == 0) v\n            else if (v > acc) v\n         \
    \   else acc\n        }", "        var largest = n / 2\n        var numDivisors\
    \ = 0\n        while ((n%largest) != 0) {\n            largest += 1\n        \
    \    numDivisors += 1\n        }\n        largest", "        var largestDiv =\
    \ n\n        val divisors = Vector.fill( (2l+1) - largestDiv.toInt){\n       \
    \     n / math.pow (2l,scala.math.ceil(scala.math.log2(n)))\n        }\n     \
    \   val maxDiv = divisors.max\n        if (maxDiv < largestDiv) largestDiv = maxDiv\n\
    \        largestDiv", "        val divisors = collection.mutable.ListBuffer[Long]()\n\
    \        for (d <- 1l to n by 2) {\n            if (n % d == 0) divisors += d\n\
    \        }\n        if (divisors.size > 1) divisors.max\n        else 0", "  \
    \      val result = mutable.ArrayBuffer.empty[Long]\n        val divisors = mutable.ArrayBuffer.empty[Long]\n\
    \        for (d <- 2 to math.sqrt(n) by -1) {\n            if (n%d == 0) {\n \
    \               if (divisors.length == 0 || divisors.last < d) divisors += d\n\
    \            } else {\n                divisors += d\n            }\n        }\n\
    \        if (divisors.length == 0) result += n\n        else {\n            val\
    \ largest = divisors.max\n            divisors -= largest\n            if (divisors.isEmpty)\
    \ result += (largest / divisors.last)\n            else result += largest\n  \
    \      }\n        result reduce { (x, y) => (if (x < y) x else y) }", "      \
    \  val factors = mutable.Map[Long, Int]()\n        for {\n            i <- 2 to\
    \ (n/2) if n % i == 0\n        } factors += i -> factors(i) + 1\n        val max\
    \ = factors.filter(_._2 > n).maxBy(_._1)\n        if (max != 0) {\n          \
    \  largestDivisor(max)\n        } else {\n            n\n        }", "       \
    \ var divi : Long = 1\n        var divisor : Long = n \n        while (divisor\
    \ != 0) {\n            divisor = n / divisor \n            divi = divisor\n  \
    \      }\n        return divi", "        // Set a variable to hold all divisors\n\
    \        var divisors = scala.collection.mutable.Set[Long]()\n        // Test\
    \ all numbers up to and including n\n        for(i <- 0 until (n + 1)) {\n   \
    \         // If the number divides evenly, add to our divisors set\n         \
    \   if((n / i) % 2 == 0){\n                divisors += i\n            }\n    \
    \    }\n        // If our divisors set is not empty, reverse the order of the\
    \ set\n        if(!divisors.isEmpty) {\n            divisors.toSeq.reverse\n \
    \       }\n        else {\n            0\n        }", "        val nums = mutable.ArrayBuffer.empty[Long]\n\
    \        var largeDivisor = 0L\n        for(d <- 1L until n) {\n            val\
    \ testDivisor = n/d\n            if(testDivisor % 2 == 0 && testDivisor > largeDivisor)\n\
    \                largeDivisor = testDivisor\n            nums += d\n        }\n\
    \        val largest = nums.max\n        println(s\"largest divisor = $largeDivisor\"\
    )\n        largest", "        def f(n: Long, n2: Long) : Long = {\n          \
    \  if (n == 0) n2\n            else f(n - 2, n2)\n        }\n        f(n, 0, n)",
  "        var largestDivisor = 0l\n        for(d <- 2 to n by 2){\n            if(n\
    \ % d == 0){\n                largestDivisor = d\n                n = n / d\n\
    \                break\n            }\n        }\n        largestDivisor", " \
    \       var largest = Long.MaxValue\n        var divisor = Long.MaxValue\n   \
    \     for (i <- 0 until n){\n            if (n % i == 0){\n                if\
    \ (i > divisor) {\n                    divisor = i\n                }\n      \
    \      }\n            if (largest < divisor){\n                largest = divisor\n\
    \            }\n        }\n        divisor", "        var max = 1L\n        var\
    \ currentDivisor = 1L\n        var currentMax = 1L\n        var currentNum = n\n\
    \n        while (currentNum > 0) {\n            if (currentDivisor / n > currentMax\
    \ ) {\n                currentMax = currentDivisor\n                currentNum\
    \ = currentNum - currentMax\n            } else {\n                currentDivisor\
    \ = currentDivisor + currentMax\n                currentMax = 1L\n           \
    \ }\n        }\n        return currentMax", "        val map = mutable.Map.empty[Long,\
    \ Long]\n        var biggestDivisor = 0\n        for (i <- 0 until n) {\n    \
    \        if (map.contains(i / 2l)) {\n                biggestDivisor = Math.max(biggestDivisor,\
    \ map(i/2))\n            } else {\n                map.put(i/2, i)\n         \
    \   }\n        }\n        biggestDivisor", "        val largestDivisors = mutable.HashMap[Long,\
    \ Long]()\n        var candidate = 0\n\n        while (candidate <= n){\n    \
    \        if (n % candidate == 0){\n                largestDivisors += (candicate\
    \ -> n)\n            }\n            candidate += 1\n        }\n        val largest\
    \ = largestDivisors.sortBy(_._2).last._1\n        largest", "        var max =\
    \ 1l\n        var factor = 1\n        while (n < max) {\n            n /= factor\n\
    \            max += 1\n        }\n        n", "        val factors = mutable.Set[Long]()\n\
    \        for(i <- 2 to n by 2){\n            val div = n/i\n            factors\
    \ += div\n            if(div <= n){\n                factors += div\n        \
    \    }\n        }\n        factors.max", "        var largestDivisor = 0l\n  \
    \      var nextDivisor = 0l\n\n        while(n > nextDivisor) {\n            nextDivisor\
    \ += 1l\n        }\n\n        largestDivisor = nextDivisor", "        val arr\
    \ = Array.fill(n)(1l).map(_.toLong)\n        var div : Long = 1l\n        var\
    \ cur : Long = 0l\n        while(cur < n) {\n            val a = arr.takeWhile(!_%div).last\n\
    \            val b = arr.dropWhile(!_%div).takeWhile(!_%div).last\n          \
    \  if(b%a == 0) div = b\n            else cur += 1\n        }\n        div", " \
    \       val factors = mutable.ListBuffer[Long]()\n        for (a <- 1 to n) {\n\
    \            val factorOfN = if (n % a == 0) a else n % a\n            if (factorOfN\
    \ == 0) {\n                factors += a\n            }\n        }\n        factors.max",
  "        var largestDivisor = 1l\n        for (div: Long <- 2l to sqrt(n)) {\n \
    \           if (n % div == 0) {\n                if (div > largestDivisor) {\n\
    \                    largestDivisor = div\n                }\n            }\n\
    \        }\n        largestDivisor", "        var max = 1\n        var lastDividend\
    \ = 1\n        val numbers = mutable.ArrayBuffer(n)\n        while (numbers.size\
    \ > 0) {\n            val currentDivisor = numbers.last.div(lastDividend)\n  \
    \          val nextNumber = lastDividend.multiply(nextDivisor)\n            val\
    \ nextDivisor = numbers.last.minus(lastDividend)\n            max = nextNumber\n\
    \            lastDividend = currentDivisor\n            numbers = numbers :+ nextNumber\n\
    \        }\n        max", "        var maxDiv = n\n        while(maxDiv > 0) {\n\
    \            maxDiv /= 2\n            if(n % maxDiv == 0) {\n                maxDiv\
    \ = Long.MaxValue\n                break\n            }\n        }\n        maxDiv",
  "        val largest = mutable.Set[Long]()\n        val divisor : Long = n / 2\n\
    \        while (!largest.contains(divisor)) {\n            if (n % divisor ==\
    \ 0) {\n                largest = largest.union(divisor)\n            }\n    \
    \        divisor = divisor / 2\n        }\n        divisor", "        var max\
    \ = 0l\n        for(d <- 1 to n)\n            if( n % d == 0) {\n            \
    \    max = d\n                break\n            }\n        if(max > n) max else\
    \ n", "        val divised = n / 2\n        var maxDivisor = 0\n        for(i\
    \ <- 1 to (Math.pow(2, n) - 1)){\n            if(n % i == 0 && divised % i ==\
    \ 0){\n                maxDivisor = Math.max(maxDivisor, i)\n            }\n \
    \       }\n        maxDivisor", "        val largest_divisor_set = scala.collection.mutable.Set[Long]()\n\
    \        var max_divisor = 0\n        var max_divisor_candidate = math.MaxLong\n\
    \        var current_divisor = 0\n        var divisor\n        while (true){\n\
    \            divisor = n\n            while (divisor % 2 == 0 && divisor > 0){\n\
    \                divisor = divisor / 2\n            }\n            if(divisor\
    \ > 0){\n                largest_divisor_set += divisor\n                if(divisor\
    \ > max_divisor_candidate){\n                    max_divisor_candidate = divisor\n\
    \                    max_divisor = divisor\n                }\n              \
    \  if(largest_divisor_set.contains(divisor)){\n                    break\n   \
    \             }\n            }\n            divisor = n * 10\n            while\
    \ (divisor % 2 == 0 && divisor > 0){\n                divisor = divisor / 2\n\
    \            }\n            if(divisor > 0){\n                largest_divisor_set\
    \ += divisor\n                if(divisor > max_divisor_candidate){\n         \
    \           max_divisor_candidate = divisor\n                    max_divisor =\
    \ divisor\n                }\n                if(largest_divisor_set.contains(divisor)){\n\
    \                    break\n                }\n            }\n            divisor\
    \ = n * 100\n            while (divisor % 2 == 0 && divisor > 0){\n          \
    \      divisor = divisor / 2\n            }\n            if(divisor > 0){\n  \
    \              largest_divisor_set += divisor\n                if(divisor > max_divisor_candidate){\n\
    \                    max_divisor_candidate = divisor\n                    max_divisor\
    \ = divisor\n                }\n                if(largest_divisor_set.contains(divisor)){\n\
    \                    break\n                }\n            }\n            divisor\
    \ = n * 1000\n            while (divisor % 2 == 0 && divisor > 0){\n         \
    \       divisor = divisor / 2\n            }\n            if(divisor > 0){\n \
    \               largest_divisor_set += divisor\n                if(divisor > max_divisor_candidate){\n\
    \                    max_divisor_candidate = divisor\n                    max_divisor\
    \ = divisor\n                }\n                if(largest_divisor_set.contains(divisor)){\n\
    \                    break\n                }\n            }\n            divisor\
    \ = n * 10000\n            while (divisor % 2 == 0 && divisor > 0){\n        \
    \        divisor = divisor / 2\n            }\n            if(divisor > 0){\n\
    \                largest_divisor_set += divisor\n                if(divisor >\
    \ max_divisor_candidate){\n                    max_divisor_candidate = divisor\n\
    \                    max_divisor = divisor\n                }\n              \
    \  if(largest_divisor_set.contains(divisor)){\n                    break\n   \
    \             }\n            }\n            divisor = n * 100000\n           \
    \ while (divisor % 2 == 0 && divisor > 0){\n                divisor = divisor\
    \ / 2\n            }\n            if(divisor > 0)", "        // Initialize max\
    \ as 1, and min as n, to allow a solution to be found even when n = 1\n      \
    \  var max = 1, min = n\n        // Keep looping until max and min are different\n\
    \        while {\n            max += min / max\n            if (max > min) min\
    \ = max\n            else return max\n        }", "        var largestDivisor\
    \ = Long.MaxValue\n        var nDivisor = 0\n        for (i <- 2 to n) {\n   \
    \         if (n % i == 0) {\n                nDivisor += 1\n                if\
    \ (nDivisor > largestDivisor) {\n                    largestDivisor = nDivisor\n\
    \                }\n            }\n        }\n        nDivisor += 1\n        largestDivisor",
  "        val a = Array.ofDim[Long](100) // TODO: make this a param\n        var\
    \ maxDiv = n\n        var maxRem: Long = 1l\n        var curRem: Long = 1l\n \
    \       var curDiv = 1l\n        while(true) {\n            if(maxDiv <= 0) {\n\
    \                maxDiv = maxDiv * 2l\n                maxRem = (maxDiv/maxRem)*n\n\
    \                maxDiv += 1l\n                maxRem -= 1l\n            }\n \
    \           val rem = (maxDiv/maxRem)*n\n            val div = maxDiv/maxRem\n\
    \            if(a contains div) {\n                // found a divisor\n      \
    \          if(maxDiv%curRem == 0) {\n                    return maxDiv\n     \
    \           }\n                // found a larger divisor\n                if(maxDiv%curDiv\
    \ == 0) {\n                    maxDiv = (maxDiv/div)*(2*curRem)\n            \
    \        maxRem = (maxDiv/maxRem)*n\n                    maxDiv += 1l\n      \
    \              maxRem -= 1l\n                }\n            }\n            if(rem\
    \ == 0) {\n                curDiv += 1l\n                curRem = rem\n      \
    \      } else {\n                curRem = rem\n            }\n        }", "  \
    \      val divisors = mutable.HashMap[Long, Boolean]()\n        // find largest\
    \ divisor of n\n        for(divisor <- 1 to n by 1){\n            if(n % divisor\
    \ == 0) {\n                divisors.put(divisor, true)\n            }\n      \
    \  }\n        // find first divisor\n        val largestDivisor = divisors.iterator.filter(x\
    \ => x.get._2).maxBy(x => x._1).get._1\n        if(largestDivisor > n) largestDivisor\n\
    \        else largestDivisor - 1", "        val map = scala.collection.mutable.HashMap.empty[Long,\
    \ Int]\n        for(i <- 0 until n)\n            map(i % n) = map(i % n) + 1\n\
    \n        val max = 0l\n        for(i <- 0 until n)\n            if(map(i % n)\
    \ > max)\n                max = map(i % n)\n        max - 1", "        val list\
    \ = mutable.ArrayBuffer.empty[Long]\n        for (i <- 2 to n) \n            if\
    \ (n % i == 0)\n                list += i\n        list.lastOption", "       \
    \ var largest = BigInt(n)\n        var largestDivisor = 1L\n        var remainder:\
    \ Long = 0\n\n        // Search until largest divisor found\n        while (remainder\
    \ != 0) {\n            val nextDivisor = remainder % largestDivisor\n        \
    \    remainder = nextDivisor // remove from remainder\n            largestDivisor\
    \ = nextDivisor // update largestDivisor\n            largest = largest % nextDivisor\
    \ // update largest\n        }\n        largestDivisor", "        var max = 1\n\
    \        for (i <- 2 until n) {\n            if (n % i == 0) {\n             \
    \   if (max > i) {\n                    max = i\n                }\n         \
    \   }\n        }\n        max", "        val res = new mutable.HashMap[Long, Long]\n\
    \        for (x <- 2 to n) if (n % x == 0) res += (x, n/x) \n        res.maxBy(_._2)._1",
  "        val div = List(0 until n).map { i => (n%i, i) }\n        val max = div.toList.maxBy(_._1)._1\n\
    \        max = div.toList.find(_._1 == max)._2", "        val maxDivisors = scala.collection.mutable.ArrayBuffer[Long]()\n\
    \        val maxDivisor = math.max(n.toLong)\n        def divisors(n1 : Long)\
    \ : Unit = {\n            val numDivisor = n1.toLong / maxDivisor\n          \
    \  if (numDivisor == n1) maxDivisors += numDivisor\n            else if (numDivisor\
    \ > n1) divisors(numDivisor)\n            else maxDivisors += numDivisor\n   \
    \     }\n        divisors(n)\n        if (maxDivisors.isEmpty) maxDivisors.head\
    \ else maxDivisors.max", "        // This array tracks the divisors that we have\
    \ seen\n        // We will use this array to find the largest divisor < n\n  \
    \      var divisors = Array[Long]()\n        // Find the largest divisor < n that\
    \ divides n evenly\n        // If we find one, we return it\n        var maxDiv\
    \ : Long = n.toInt\n        for (i <- 0 until maxDiv) {\n            // If this\
    \ divisor divides n evenly, we set our flag to true\n            if (n % i ==\
    \ 0) {\n                divisors = divisors :+ i\n            }\n            //\
    \ If this divisor does not divide n evenly, we set our flag to false\n       \
    \     else {\n                divisors = divisors :- i\n            }\n      \
    \  }\n        // If we have seen all of the divisors, we return the largest one\
    \ found\n        if (divisors.forall(x => x == 0)) {\n            return maxDiv\n\
    \        }\n        // If we haven't seen all of the divisors yet and there are\
    \ any divisors left, return that\n        else if (divisors.forall(x => x > 0)\
    \ && (divisors.nonEmpty > 0)) {\n            return divisors.max\n        }\n\
    \        // If we haven't seen all of the divisors yet and there are no divisors\
    \ left, return -1\n        else if (divisors.forall(x => x < 0)) {\n         \
    \   return -1\n        }\n        else {\n            return -1\n        }", " \
    \       val dividers = mutable.HashMap[Long, Long]()\n        val divisors = mutable.ArrayBuffer.empty[Long]\n\
    \        n to 1 by -1 foreach { n =>\n            n to 1 by -1 foreach { d =>\n\
    \                if (n / d == 0) {\n                    divisors += d\n      \
    \          }\n                if (dividers.contains(n / d)) {\n              \
    \      val max = (n / d).toLong\n                    val current = (n / d).toLong\n\
    \                    if (current > dividers.values(key)) {\n                 \
    \       dividers.put(d, max)\n                    }\n                }\n     \
    \       }\n        }\n        divisors.reverse.find(max(_, 0l)).map(_ / n).reduce(_\
    \ + _)", "        for (d <- 1 to n by 2) {\n            if (n % d == 0) {\n  \
    \              if (d > n / d) d) else n)\n                break\n            }\n\
    \        }", "        val largestDivisors = (0 to n/2).map(n => (n, n/n)).toSet\n\
    \        largestDivisors.foldLeft(1l) {\n            case (acc, x) =>\n      \
    \          if (acc.forall(n => x._2 < n))\n                    acc\n         \
    \       else\n                    acc.max { case (m, t) => t._2 * (m-1l) }\n \
    \       }", "        val biggestNumber = Long.MaxValue - 1\n        val divisorsEvenlyDividedByBiggestNumber\
    \ = new mutable.Array[Long](n)\n\n        for ( i <- 0 until n ) {\n         \
    \   val numberDividedByBiggestNumber = n % biggestNumber\n            divisorsEvenlyDividedByBiggestNumber(i)\
    \ = numberDividedByBiggestNumber\n            biggestNumber = numberDividedByBiggestNumber\n\
    \        }\n        largest(divisorsEvenlyDividedByBiggestNumber)", "        var\
    \ max = 0L\n        var current = 0L\n        var sum = 0L\n        val array\
    \ = mutable.ArrayBuffer.empty[Long]\n        for(i <- 1 to n){\n            val\
    \ j = i % 2\n            current += i\n            if(j == 0){\n             \
    \   array.add(current)\n            }else{\n                if(current > max){\n\
    \                    max = current\n                }\n                current\
    \ = 0\n            }\n        }\n        array.max", "        val primes = List(2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29)\n        val candidates = primes.takeWhile(_\
    \ < n).toList\n        val largest = 0l\n        candidates.foreach(n => {\n \
    \           if ((n % _ == 0) && (largest.compareTo(_) <= 0)) {\n             \
    \   largest = n\n            }\n        })\n        largest", "        val factors\
    \ = mutable.Set[Long]()\n        for(d <- 1l to n) {\n            val d = n /\
    \ d\n            if(d % 2 == 0) {\n                factors.add(d)\n          \
    \  }\n        }\n        factors.max", "        val divisors = mutable.Set[Long]()\n\
    \        while (n > 0) {\n            divisors.add(n)\n            val newN =\
    \ n//n // Divide n by every number from 1 to n except 1\n            if (newN\
    \ == 1) divisors.remove(newN) // If we divide 1 by every number from 1 to n, that\
    \ number is itself a divisor, so remove the divisor\n            n = newN\n  \
    \      }\n        // If we never added a divisor above n, n is divisible by every\
    \ number from 1 to n except 1\n        // If n is evenly divisible by every number\
    \ from 1 to n except 1, n is divisible by 2\n        // If n is evenly divisible\
    \ by every number from 1 to n except 1, n is divisible by 3\n        // ... and\
    \ so on\n        divisors.maxBy(divisors.isEmpty(_) ? 1 : (x => math.floor(n/x)))",
  "        var maxDivisor = 1\n        var maxNumber = 0\n        var current = n\n\
    \        while(current != 0) {\n            var divisor = math.floor_divide(current,2)\n\
    \            if(divisor > maxDivisor) {\n                maxDivisor = divisor\n\
    \                maxNumber = current\n            }\n            current = math.floor_divide(current,2)\n\
    \        }\n        maxNumber", "        var largest = 0\n        for (nn <- 1\
    \ to n by 2) {\n            if (n % nn == 0)\n                if (nn > largest)\n\
    \                    largest = nn\n        }\n        largest", "        val divisors\
    \ = mutable.ArrayBuffer.empty[Long]\n        for(d <- 1 to n-1) divisors += n-1l\n\
    \        divisors.maxBy(d => n/d).asInstanceOf[Long]", "        val d = Array[Long](3l,\
    \ 5l, 7l, 9l).sorted\n        val r = n/d.last\n        if(r == 0) d.last\n  \
    \      else d.find(x => n % x == 0)", "        var result = -1\n        var maxDiv\
    \ = n\n        while (maxDiv % 2 == 0) {\n            maxDiv = maxDiv / 2\n  \
    \      }\n        while (maxDiv % 3 == 0) {\n            if (result < maxDiv)\
    \ result = maxDiv\n            maxDiv = maxDiv / 3\n        }\n        result",
  "        val divs = mutable.Set[Long]()\n        var x = n\n        while(x > 0)\
    \ {\n            x % 2 == 0 && divs += x\n            x /= 2\n        }\n    \
    \    divs.max", "        val largestDivisors = mutable.ArrayBuffer.empty[Long]\n\
    \        val divisors = mutable.ArrayBuffer.empty[Long]\n        divisors.clear()\n\
    \        var divisor = 1\n\n        // while divisors contains n\n        while\
    \ (divisors.contains(n)) {\n            divisor = 1\n            // while divisor\
    \ < n\n            while (divisor < n) {\n                // if n divides evenly\
    \ into divisor add divisor to divisor array\n                if (n / divisor ==\
    \ 0) {\n                    divisors += divisor\n                    // reset\
    \ the divisor for next loop iteration\n                    divisor = 1\n     \
    \           } else {\n                    // else add divisor to divisors array\n\
    \                    divisors += divisor\n                }\n                divisor\
    \ += 1\n            }\n            divisors.clear()\n        }\n        if (divisors.contains(n))\
    \ {\n            divisors += n\n        }\n        divisors.max", "        var\
    \ largest = BigInt(n) \n        while(!largest.equals(BigInt(n))) {\n        \
    \    val newDivisor = largest.divideToIntegralValue()\n            if( newDivisor.compareTo(n)\
    \ == -1 ) {\n                largest = newDivisor \n            } else if (newDivisor.compareTo(n)\
    \ == 1 ) {\n                largest = newDivisor \n            } else {\n    \
    \            largest = BigInt(n) \n            }\n        }\n        largest",
  "        val rem = n/2l\n        val rem2 = (rem*rem)/2l\n        val rem3 = (rem2*rem2)/2l\n\
    \        if(rem % 2 == 0) rem else rem3", "        // Find factors for n, sort\
    \ descending order\n        var factors = factoring(n)\n        var factors =\
    \ factors.toList.sortBy(-_.length)\n        var largestFactor = factors.head\n\
    \        // Find the largest factor larger than n\n        val isLarge = n / largestFactor\
    \ > n\n        if (isLarge) largestFactor else -1", "        // Using a mutable\
    \ Map will allow us to store all of the divisors in ascending order\n        val\
    \ divisors = mutable.Map[Long, Boolean]()\n        divisors += (0l -> true)\n\
    \        for(i<- 1 to n-1) {\n            if (i%2 == 0){\n                if (divisors.contains((i/2)))\
    \ {\n                    divisors((i/2)) = false\n                }\n        \
    \        else {\n                    divisors((i/2)) = true\n                }\n\
    \            }\n        }\n        divisors.maxBy(_._1)._1", "        val factorsOfN\
    \ = factors(n)\n        if(factorsOfN.length == 1) n\n        else largestDivisor(factorsOfN.removeAt(factorsOfN.length\
    \ - 1))", "        var largest = 0\n        for(i <- 2 to n/2){\n            if((n\
    \ modulo i) == 0) largest = i\n        }\n        largest", "        var res =\
    \ n // to store the result\n        var n = n // to store the original n\n   \
    \     for(i <- 1 to (2l*n)) { // 2 is the smallest divisor of n\n            if(n\
    \ % i == 0) {\n                // if i divides n, then n must be smaller than\
    \ n\n                res = i\n                n = n / i\n            }\n     \
    \   }\n        res", "        val numDivisors = n.toInt/2 // integer division\n\
    \        // create a list of all divisors of a number\n        val divisors =\
    \ for(i <- 1 to numDivisors) yield n / i\n        // find the maximum number\n\
    \        divisors.max", "        var max = 0\n        var current = n\n\n    \
    \    while (current != 0) {\n            if (current%2 == 0) {\n             \
    \   max = Math.max(max, current)\n            }\n            current = current\
    \ / 2\n        }\n\n        return max", "        var largest = 0\n        for\
    \ (x <- 1 to n) {\n            if (n % x == 0) {\n                largest = x\
    \ :: largest\n            }\n        }\n        largest", "        val l = n.toInt;\n\
    \        var ans = Long.MinValue;\n        var l = l;\n        while (l<=1) {\n\
    \            if (n%l == 0) ans = l;\n            l = l+1;\n        }\n       \
    \ ans;", "        // use n-1 as the test parameter\n        for (i<- 0 until n-1){\n\
    \            // if the i^th bit in n is set to 1\n            if(n & (1L << i)\
    \ == (1L << i)) {\n                // then we could divide by (i+1)\n        \
    \        if(n == (1L << i)) {\n                    return (1L << i)\n        \
    \        }\n                else {\n                    // we could divide by\
    \ (n-1)\n                    if(n == (1L << (i-1))) {\n                      \
    \  return (1L << (i-1))\n                    }\n                    else {\n \
    \                       // we could divide by (n-2)\n                        if(n\
    \ == (1L << (i-2))) {\n                            return (1L << (i-2))\n    \
    \                    }\n                        else {\n                     \
    \       // we could divide by (n-3)\n                            if(n == (1L <<\
    \ (i-3))) {\n                                return (1L << (i-3))\n          \
    \                  }\n                            else {\n                   \
    \             // we could not divide by n\n                                return\
    \ -1\n                            }\n                        }\n             \
    \       }\n                }\n            }\n        }\n        // if we got here,\
    \ then we could not divide by any number\n        return -1", "        val l =\
    \ math.BigInt(n)\n        val m = scala.math.BigInt(2)\n        var div = 1\n\
    \        var divMax = n\n\n        for(i <- l until n) {\n            if(i % m\
    \ == 0) {\n                divMax /= m\n                div += 1\n           \
    \     m += divMax\n            }\n        }\n        return divMax", "       \
    \ var remainder = 0\n        var maxDivisor = 0\n        // Divide n evenly, keep\
    \ track of largest divisor\n        for (d <- 1 until n) {\n            if (n\
    \ % d == 0) {\n                remainder += 1\n                if (maxDivisor\
    \ < d) {\n                    maxDivisor = d\n                }\n            }\n\
    \        }\n        // No more divisors exist, return remainder\n        if (remainder\
    \ == 0) {\n            return remainder\n        }\n        // If maxDivisor is\
    \ not 1, then subtract 1 from maxDivisor and try again\n        if (maxDivisor\
    \ != 1) {\n            maxDivisor -= 1\n            return largestDivisor(n).min(maxDivisor)\n\
    \        } else {\n            return n\n        }", "        val divisors = mutable.Set[Long]()\n\
    \        var max = 1\n\n        // Find the largest divisor that's not less than\
    \ n\n        while (max < n) {\n            val divisor = max * max % n\n    \
    \        if (divisors.contains(divisor)) {\n                break\n          \
    \  }\n            divisors += divisor\n            max += 1\n        }\n\n   \
    \     if (divisors.isEmpty) {\n            return n\n        } else {\n      \
    \      return divisors.min\n        }", "        val x = new mutable.Queue[Long](n.toLong)\n\
    \        while(!x.isEmpty){\n            val y = x.dequeue\n            val factors\
    \ = new mutable.Queue[Long]()\n            for(i<-x.iterator){\n             \
    \   if(i % y != 0)\n                    factors += i\n            }\n        \
    \    while(!factors.isEmpty){\n                if(factors.dequeue % y == 0)\n\
    \                    x.enqueue(factors.dequeue)\n                else\n      \
    \              factors += factors.dequeue\n            }\n        }\n        x.dequeue",
  "        var largest = BigInt(0)\n        val arr = mutable.ArrayBuffer.empty[Long]\n\
    \        \n        for(x <- 1 to n){\n            \n            if(BigInt(x) %\
    \ BigInt(2) == 0){\n                \n                largest = BigInt(x) > largest\n\
    \                arr += x\n                \n                if(BigInt(x) > n){\n\
    \                    largest = true\n                    break\n             \
    \   }\n            }\n        }\n        \n        if(arr.isEmpty){\n        \
    \    largest = BigInt(n)\n        }\n        \n        if(largest == BigInt(0)){\n\
    \            largest = BigInt(1)\n        }\n        \n        largest", "   \
    \     val evenDivisors = n\n            .filter(_ % 2 == 0)\n            .map(n\
    \ => (n, n))\n            .groupBy(_._2)\n            .mapValues(_.map(_._1))\n\
    \            .filter(_._2.size == 1)\n            .map(_._2.head)\n          \
    \  .toList\n        if (evenDivisors.isEmpty) n\n        else largestDivisor(largestDivisor(evenDivisors.head))",
  "        val divi = (n / 2l)\n        val ls = new mutable.ListBuffer[(Long, Long)]()\n\
    \        while (divi != 0l) {\n            val rem = divi % 2l\n            if\
    \ (rem == 0l) {\n                ls.append((divi, 1l))\n            } else if\
    \ (rem > 0l) {\n                ls.append((divi, rem))\n            }\n      \
    \      divi = divi / 2l\n        }\n        ls.maxBy(_._1)._1", "        val maxDivisor\
    \ = if (n % 2 == 0) 1l else 2l\n        val divisors = scala.collection.mutable.ArrayBuffer.empty[Long]\n\
    \        for (divisor <- 1 to maxDivisor) {\n            if (n % divisor == 0l)\
    \ {\n                divisors += divisor\n            }\n        }\n        if\
    \ (divisors.isEmpty) n\n        else largestDivisor(divisors.max)", "        var\
    \ largestDivisor = 0\n        for (i <- 1 to n) {\n            val div = i / n\n\
    \            if (n % div == 0)\n                largestDivisor = div\n       \
    \ }\n        largestDivisor", "        // Sieve of Eratosthenes - finding all\
    \ the divisors of a number\n        var l = new mutable.HashSet[Long]()\n    \
    \    var k = n\n        while (k > 0) {\n            l.add(k)\n            k =\
    \ (k - 1) / 2\n        }\n        var max = 0l\n        var divisor = 0l\n   \
    \     for (divisor <- l) {\n            if (n % divisor = 0l) {\n            \
    \    max = divisor\n            }\n        }\n        return max", "        var\
    \ biggestDivisor = 0L\n        for (divisor <- 1L until n by 2) {\n          \
    \  if (n / divisor == BigInt(n)) {\n                biggestDivisor = divisor\n\
    \            }\n        }\n        return biggestDivisor", "        if (n < 2l)\
    \ n\n        else largestDivisor(n / 2l) * largestDivisor(n % 2l)", "        val\
    \ divisors = mutable.HashSet[Long]()\n        var largest = 0l\n        var divisor\
    \ = 0l\n        while (divisors.size < n){\n            divisor += 1l\n      \
    \      while (divisors.contains(divisor)){\n                divisor += 1l\n  \
    \          }\n            divisors += divisor\n            if (divisor > largest){\n\
    \                largest = divisor\n            }\n        }\n        largest",
  "        var d = 1\n        var maxDivisor = 0L\n        var maxDivisorDivisor =\
    \ 0L\n        var maxDivisorDivisor2 = 0L\n        for (d <- n to 2 by -1) {\n\
    \            val d = math.abs(n / d)\n            if (d % 2 == 0) {\n        \
    \        if (d > maxDivisor) {\n                    maxDivisor = d \n        \
    \            maxDivisorDivisor = d \n                    maxDivisorDivisor2 =\
    \ d \n                }\n            } else if (d % 2 != 0) {\n              \
    \  if (d < maxDivisorDivisor) {\n                    maxDivisorDivisor = d \n\
    \                    maxDivisorDivisor2 = d \n                }\n            }\n\
    \        }\n        if (maxDivisor != 0L && maxDivisor > maxDivisorDivisor2) {\n\
    \            maxDivisor\n        } else {\n            maxDivisorDivisor2\n  \
    \      }", "        val remainder = new mutable.ListBuffer[Long]()\n        //\
    \ divide n by 2 until remainder is 0\n        for (nDivisor <- 0 until n; nDivisor\
    \ <- nDivisor until n / nDivisor) {\n            if (nDivisor % 2 == 0) {\n  \
    \              remainder += nDivisor\n            }\n        }\n        // The\
    \ max value of remaining divisors\n        val maxValue = remainder.max\n    \
    \    // The greatest divisor <= n\n        val maxDivisor = remainder.find { case\
    \ nDivisor => nDivisor <= n }\n        // Return the greatest divisor <= n\n \
    \       maxDivisor match {\n            case Some(divisor) => divisor\n      \
    \      case None =>\n                println(\"divisor not found\")\n        \
    \        0\n        }", "        val n = BigInt(n)\n        val maxDivisor = BigInt(2)\n\
    \        for(divisor <- 2 until BigInt(4l) by 2 until 4l){\n            if(n %\
    \ divisor==0){\n                if(divisor>maxDivisor)\n                    maxDivisor\
    \ = divisor\n            }\n        }\n        maxDivisor", "        def factorial\
    \ (n : Long) : Long = {\n            if (n == 0 || n == 1) {\n               \
    \ return 1\n            } else {\n                return n * factorial(n - 1)\n\
    \            }\n        }\n\n        // We start from n-1 to avoid zero division\n\
    \        // n is supposed to be odd, so we start with n-1\n        var maxDivisor\
    \ = 1\n        var divisor = n\n        val maxDivisorSoFar = 0\n        // We\
    \ keep dividing till the result is smaller than the previous one\n        while\
    \ (divisor > 1) {\n            // This line can be written as: divisor = divisor\
    \ / maxDivisor\n            // divisor = divisor / maxDivisor\n            //\
    \ divisor = divisor / maxDivisor\n            // divisor = divisor / maxDivisor\n\
    \            divisor = divisor / maxDivisor\n            maxDivisor = maxDivisor.min(divisor)\n\
    \            // maxDivisor = maxDivisor.max((divisor,maxDivisor))\n          \
    \  maxDivisorSoFar += maxDivisor - 1\n        }\n        maxDivisorSoFar", " \
    \       def checkEvenDivisors(n: Long): Set[Long] = {\n            var set = new\
    \ mutable.HashSet[Long]()\n            for (d <- 2 to sqrt(n)) {\n           \
    \     if (n % d == 0) {\n                    set += d\n                    if\
    \ (set.size == 2) set -= 2\n                }\n            }\n            set.filter(_\
    \ > 0).size\n        }\n        var largestDivisor = -1\n        for (d <- 2 to\
    \ n) {\n            if (checkEvenDivisors(d) > largestDivisor) {\n           \
    \     largestDivisor = d\n            }\n        }\n        largestDivisor", " \
    \       val max = n.toLong\n        // loop through all numbers up to the largest\
    \ number we encounter\n        var largestDivisor = 0\n        var i = max\n \
    \       while (i > 0) {\n            // find the largest divisor for i -- if i\
    \ is even, then no divisor, so the greatest divisor is 1\n            if (i %\
    \ 2 == 0) {\n                largestDivisor = 1\n            } else {\n      \
    \          val divisor = i / 2\n                // see if i is a divisor of any\
    \ previously found divisor\n                val lastDivisor = largestDivisor\n\
    \                if (divisor == 1) {\n                    // i is a divisor of\
    \ a previously found divisor, so set largestDivisor to 1 and break out of the\
    \ loop\n                    largestDivisor = 1\n                    break\n  \
    \              } else {\n                    // i is a divisor of a previously\
    \ found divisor, so check to see if it's the greatest divisor so far\n       \
    \             if (lastDivisor > divisor) {\n                        largestDivisor\
    \ = divisor\n                    }\n                }\n            }\n       \
    \     // move i back 1 to the right\n            i -= 1\n        }\n        largestDivisor",
  "        val divisors = Set[Long]()\n        var largest = 0l\n        for(i <-\
    \ 2l until (n/2l)) {\n            if(n % i == 0) {\n                divisors +=\
    \ i\n                if(divisors.size == n) largest = i\n            }\n     \
    \   }\n        largest", "        var largestDivisor = 0L\n        var factor\
    \ = 1L\n        while(factor < n) {\n            factor *= 2L\n            if(factor\
    \ > n) factor -= n\n            if(n % factor == 0) largestDivisor = factor\n\
    \        }\n        largestDivisor", "        var largestDivisor = 0\n       \
    \ var curr = n\n\n        // Keep iterating while there are divisors left to find\n\
    \        while (curr != 1l && curr != 0l) {\n            // Check each of the\
    \ divisors up to current value\n            for (divisor <- 2 until curr) {\n\
    \                // If divisor divides current value, then current is the largest\
    \ divisor\n                if (n % divisor == 0) {\n                    largestDivisor\
    \ = divisor\n                    break\n                }\n            }\n   \
    \         curr = curr / 2\n        }\n\n        // If the remainder of current\
    \ value is also 1, then the number must be evenly divisible\n        if (curr\
    \ == 1l) {\n            largestDivisor = n\n        }\n\n        largestDivisor",
  "        var max = 0l\n        n /: Seq(n) {\n            if(_ % 2 == 0) max = _\n\
    \            else _ / 2\n        }\n        max", "        var result : Long =\
    \ 1l\n        var minDivisor = 2l\n        var maxDivisor = n\n        while (maxDivisor\
    \ / minDivisor > 1l) {\n            result = minDivisor\n            minDivisor\
    \ = (minDivisor + 1l).ceil\n            maxDivisor = (maxDivisor - 1l).floor\n\
    \        }\n        result", "        val r = new mutable.ListBuffer[Long]()\n\
    \        var c = n\n        while (c > 0) {\n            if (c % 2 == 0)\n   \
    \             r ++= c\n            c /= 2\n        }\n        return r.max", " \
    \       var maxDiv = 0L\n        var curDiv = n\n        while (curDiv > 0L) {\n\
    \            if (curDiv mod 2 == 0L) {\n                if (curDiv > maxDiv) {\n\
    \                    maxDiv = curDiv\n                }\n            }\n     \
    \       val newDiv = curDiv div 2\n            if (newDiv > maxDiv) {\n      \
    \          maxDiv = newDiv\n            }\n            curDiv = newDiv\n     \
    \   }\n        maxDiv", "      var d = 0\n      var d = 1\n      var divisor =\
    \ 0l\n      divisor = 2\n      while(divisor < n && d < divisor) {\n        if\
    \ (n % divisor == 0) {\n          d = divisor\n          divisor = divisor + 1\n\
    \        }\n        else {\n          divisor = divisor + 1\n        }\n     \
    \ }\n      d", "        def isDivisor(n: Long) : Boolean = {\n            if(n\
    \ % 2 == 0) true\n            else if(n % 3 == 0) true\n            else false\n\
    \        }\n        val divisors = for (i <- 1 to n) yield isDivisor(i)\n    \
    \    return divisors.max", "        val primes = Vector.fill(100){2}\n       \
    \ var largestDivisor = 0\n        var largestDivisorCount = 0\n        var currentDivisor\
    \ = 2\n        var currentDivisorCount = 0\n\n        primes(0) = 1\n        primes(1)\
    \ = 2\n        // The first prime factor of 15 is 3\n        while(primes.contains(currentDivisor))\
    \ {\n            currentDivisorCount = primes(currentDivisor)\n            while(currentDivisorCount\
    \ > largestDivisorCount && currentDivisor < n) {\n                currentDivisor\
    \ = currentDivisor + 1\n                currentDivisorCount = primes(currentDivisor)\n\
    \            }\n            if(currentDivisorCount > largestDivisorCount) {\n\
    \                largestDivisorCount = currentDivisorCount\n                largestDivisor\
    \ = currentDivisor\n            }\n            currentDivisorCount = primes(currentDivisor)\n\
    \        }\n        largestDivisor", "        if (n <= 0) throw new RuntimeException(\"\
    Division by zero!\")\n        var maxDivisor = 1\n        var maxDividend = n\n\
    \n        while(maxDividend != 0) {\n            if (maxDividend % 2 == 0) maxDividend\
    \ = maxDividend / 2\n            else maxDividend = maxDividend / 2 + 1\n    \
    \        maxDivisor = maxDivisor + 1\n        }\n\n        return maxDivisor",
  "        require(n % 2 == 0)\n        var largest_divisor = 0\n        val largest_divisor2\
    \ = 1l\n        var i = 2l\n        while(i <= n) {\n            if((n % i) ==\
    \ 0) {\n                if(largest_divisor > i) {\n                    largest_divisor2\
    \ = i\n                }\n                largest_divisor = i\n            }\n\
    \            i += 1\n        }\n        largest_divisor2", "        val largestDivisors\
    \ = mutable.Set[Long]()\n        var number: Long = n;\n        while (number\
    \ > 1) {\n            if (number % 2 == 0) {\n                largestDivisors\
    \ += number\n            }\n            number /= 2\n        }\n        if (largestDivisors.isEmpty)\
    \ {\n            1\n        } else {\n            largestDivisors.min\n      \
    \  }", "        val a = 1 to n by 2\n        a.max", "        def isDivisor(n\
    \ : Long, max : Long) : Boolean = {\n            if (max == 0)\n             \
    \   return false\n            if (n % max == 0)\n                return true\n\
    \            else return isDivisor(n, (max - 1l))\n        }\n        val maxDivisor\
    \ = math.floor(n/2)\n        if (isDivisor(n, maxDivisor))\n            maxDivisor\n\
    \        else\n            largestDivisor(maxDivisor + 1l)", "        var maxDivisor\
    \ = 0\n        val nums = mutable.ArrayBuffer[Long]()\n        for (i <- 0 until\
    \ n){\n            if (i % 2 == 0) {\n                nums += i\n            }\n\
    \        }\n        nums.sortWith((a,b) => a > b)\n        for (i <- 0 until nums.size)\
    \ {\n            val currentDivisor = nums(i)\n            if (currentDivisor\
    \ % 2 == 0){\n                maxDivisor = max(maxDivisor, currentDivisor)\n \
    \           }\n        }\n        if (maxDivisor == 0) {\n            return 0\n\
    \        } else {\n            return maxDivisor\n        }", "        val divisors\
    \ = Set[Long]()\n        // Start with n, and add each divisor to divisors\n \
    \       var i = 0\n        while (i <= n){\n            if (n % i == 0){\n   \
    \             divisors.add(i)\n            }\n            i += 1\n        }\n\
    \        // Iterate over divisors, and find the largest one\n        var maxDivisor\
    \ = divisors.iterator.next()\n        for (divisor <- divisors){\n           \
    \ if (divisor > maxDivisor){\n                maxDivisor = divisor\n         \
    \   }\n        }\n        // Return the largest divisor\n        maxDivisor",
  "        val divisors = mutable.HashMap[(Long, Long), Long]()\n        for (i <-\
    \ 2 to n)\n            if (n % i == 0)\n                divisors += ((i, n / i))\n\
    \        else {\n            val highest = divisors.values.max\n            val\
    \ divisor = divisors.remove(highest)\n            (divisor._1 + divisor._2, divisor._2)\n\
    \        }", "        val divi = mutable.HashSet.empty[Long]\n        var maxDivisor\
    \ = 0\n        while(n > 1) {\n            divi.add(n)\n            n /= 2\n \
    \       }\n        divi.foreach { n =>\n            if(n % 2 == 0) {\n       \
    \         maxDivisor = n\n            }\n        }\n        maxDivisor", "   \
    \     var largestDivisor = 0l\n        var i = 2\n        while (i < n) {\n  \
    \          if (n % i == 0) {\n                largestDivisor = i\n           \
    \     i = i + 1\n            }\n            else {\n                i = i + 1\n\
    \            }\n        }\n        largestDivisor", "        // Sort numbers smaller\
    \ than n\n        // Sort numbers smaller than n\n        val bigNs = collection.mutable.ListBuffer[Long]()\n\
    \        for(i <- 1 to n){\n            if(i%2 == 0) bigNs += i\n        }\n \
    \       bigNs.sortWith((x,y) => x<y)\n\n        var max = BigInt(0)\n        var\
    \ maxDivisor = -1\n        for(i<-0 to bigNs.length-1){\n            if(bigNs(i)\
    \ % n == 0) max = max(bigNs(i)) // If the number is not divisible by n, add it\
    \ to the list\n            else if(bigNs(i) > max){\n                // If we\
    \ are adding bigNs(i) to a number already bigger than max, then add it to a new\
    \ list bigger than max\n                max = bigNs(i)\n                maxDivisor\
    \ = i\n            }\n        }\n        bigNs.drop(maxDivisor).max", "      \
    \  val l = n.toInt\n        var largest = 0l\n        var i = 1\n        while(l--\
    \ > 0) if((l & 1) == 0) largest = i; i += 1\n        largest", "        val arr\
    \ = ArrayBuffer(2, 3)\n        var num = 1\n        while(n >= num) {\n      \
    \      if(n % num == 0) {\n                arr += num\n            }\n       \
    \     num += 1\n        }\n        (arr.toSeq.max)", "        // If n is even,\
    \ n / 2 is even, \n        // and (n-1)/2 isn't, then return n/2\n        if (n\
    \ <= 1) return n\n        // If n is odd then n / 2 isn't, and (n-1)/2 isn't,\
    \ then return (n-1)/2\n        if (n % 2 == 1) return largestDivisor(n / 2)\n\
    \        // If n is even and n-1/2 is even, \n        // and (n-1)/2 isn't, then\
    \ return (n-1)/2\n        if (n % 2 == 0 && largestDivisor(n - 1) / 2%2 == 0)\
    \ return largestDivisor(n - 1) / 2\n        // If n is odd and (n-1)/2 is odd,\
    \ \n        // and n-1/2 isn't, then return n-1/2\n        if (n % 2 == 1 && largestDivisor(n\
    \ - 1) / 2 != 0) return largestDivisor(n - 1) / 2", "        val maxDivisor =\
    \ n + 1 //the largest divisor is n plus 1\n        val divisors = mutable.HashSet[Long]()\n\
    \        for (i = 1 to maxDivisor) {\n            if (n % i == 0) {\n        \
    \        divisors.add(i)\n            }\n        }\n        divisors.toList.max.toLong",
  "        val largest_divisor = n.toInt\n        (1 until n) collect {\n        \
    \  case i if i % largest_divisor == 0 => largest_divisor\n        }.max", "  \
    \      val ans = n / 2\n        while (ans.toString.length < n.toString.length)\
    \ {\n            ans = ans * 2\n        }\n        if (ans.toString.length ==\
    \ n.toString.length) {\n            return ans\n        }\n        return largestDivisor(ans)",
  "        var biggestDivisor = 0l\n        val r = new mutable.ArrayBuffer[Long]()\n\
    \        while ( biggestDivisor < n ) {\n            if( n % biggestDivisor !=\
    \ 0l ) {\n                biggestDivisor = biggestDivisor + 1\n              \
    \  r += biggestDivisor\n            }\n        }\n        var largest = 0l\n \
    \       for( d <- r ) if( d > n ) largest = d\n        largest", "        val\
    \ l = new mutable.LinkedList[Long]\n        val r : mutable.LinkedList[Long] =\
    \ new mutable.LinkedList[Long]\n        for (x <- 1l to n)\n        {\n      \
    \      if (x % 2 == 0)\n            {\n                l.add(x)\n            }\n\
    \            else\n            {\n                if (x % l.head == 0)\n     \
    \           {\n                    l.add(x)\n                }\n             \
    \   else\n                {\n                    r.addLast(x)\n              \
    \  }\n            }\n        }\n        l.tail.foreach(x => x % l.head == 0 &&\
    \ l.addLast(x))\n        r.head", "        // This algorithm runs in O(n)\n  \
    \      var maxDivisor = 0l\n        for(i <- 0 until n){\n            var divider\
    \ = 0l\n            while(i % divider != 0){\n                divider += 1\n \
    \           }\n            if(divider > maxDivisor){\n                maxDivisor\
    \ = divider\n            }\n        }\n        maxDivisor", "        val result\
    \ = 1l\n        var divisor : Long = 1l\n        while (divisor * divisor < n)\
    \ {\n            divisor = divisor * 2l\n        }\n        n / divisor", "  \
    \      val divs = mutable.Set[Long]()\n        while (n > 1) {\n            n\
    \ / 2\n            divs += n\n        }\n        divs.max", "        val divisors\
    \ = mutable.Set[Long]()\n        for (d <- 2l until Math.max(n,2l*n)\n       \
    \      if (n % d == 0)\n             divisors += d)\n        divisors.max", " \
    \       val l = new mutable.HashMap[Long, Long]()\n        val rev = n.toReverse.iterator\n\
    \n        while (rev.hasNext) {\n            val (d, q) = rev.next\n         \
    \   if (l.contains(q)) {\n                l.remove(q)\n            }\n       \
    \     l += q -> d * q\n        }\n\n        val maxKey = l.toList.sortBy(_._1).reverse.head._1\n\
    \        val maxValue = l.toList.sortBy(_._1).reverse.head._2\n\n        rev.last",
  "        val numOfDivisors = n.toLong / 2\n        val maxDivisor = (n / 2).toInt\n\
    \        var largestDivisor = Long.MaxValue\n\n        for (i <- 0 until numOfDivisors)\
    \ {\n            val nextDivisor = maxDivisor / i\n            if (nextDivisor\
    \ % 2 == 0) {\n                largestDivisor = nextDivisor\n            }\n \
    \       }\n\n        largestDivisor", "        var max: Long = 0l\n        var\
    \ divisor: Long = 1l\n        while ((n /= divisor) > 1l) {\n            if (divisor\
    \ > max)\n                max = divisor\n            divisor = divisor + 1l\n\
    \        }\n        max", "        val list = List((n/2l),(n/3l),(n/4l),(n/5l),(n/6l),(n/7l))\n\
    \        val max = list.reduceLeft((x, y) => if (y*y<=n) x else y)\n        if\
    \ (max%2l==0) max/2l else max/3l", "        val counter = mutable.HashSet[Long]()\n\
    \        var max = 1L\n        for(i <- 1L until (n/2L)) {\n            if (n\
    \ % i == 0L) {\n                max = i\n            }\n            counter.add(i)\n\
    \        }\n        counter.max", "        if (n == 0) n\n        else {\n   \
    \         if (n %% 2 == 0) largestDivisor(n/2) + 1\n            else largestDivisor(n/2)\n\
    \        }", "        val maxDivisor = n.toInt\n        val numDivisors = mutable.ListBuffer.empty[Long]\n\
    \n        for(i <- 1 to n/maxDivisor)\n            if(n % i == 0)\n          \
    \      numDivisors += i\n\n        if(numDivisors.isEmpty)\n            0\n  \
    \      else\n            numDivisors.max", "        var max = 2\n        var maxDiv\
    \ = 2\n        for(i <- 2 to (Math.sqrt(n).toInt).toInt){\n            if(n %\
    \ i == 0){\n                for(d <- 2 to (Math.sqrt(i).toInt).toInt){\n     \
    \               if(i % d == 0){\n                        if(maxDiv <= d){\n  \
    \                          max = i\n                            maxDiv = d\n \
    \                       }\n                        break\n                   \
    \ }\n                }\n            }\n        }\n        if(max == 1){\n    \
    \        return n\n        }\n        return max // or max / maxDiv", "      \
    \  // Base Case:\n        if (n <= 1) return n\n\n        // Case 1: if n is evenly\
    \ divisible by 2, return that number\n        if (n % 2 == 0) return n\n\n   \
    \     // Case 2: if n is evenly divisible by 3, return that number\n        if\
    \ (n % 3 == 0) return n\n\n        // Case 3: If n is evenly divisible by 4, 5,\
    \ 6, 8, 10, 12, 14, 15, return n\n        if (n % 4 == 0 || n % 5 == 0 || n %\
    \ 6 == 0 || n % 8 == 0 || n % 10 == 0 || n % 12 == 0 || n % 14 == 0 || n % 15\
    \ == 0) return n\n\n        // Case 4: If n is evenly divisible by 15, return\
    \ that number\n        if (n % 15 == 0) return n\n\n        // If n is not divisible\
    \ by any of the above numbers, recurse for the next number in the sequence\n \
    \       largestDivisor(n/2) + largestDivisor(n/3) + largestDivisor(n/4) + largestDivisor(n/5)\
    \ + largestDivisor(n/6) + largestDivisor(n/8) + largestDivisor(n/10) + largestDivisor(n/12)\
    \ + largestDivisor(n/14) + largestDivisor(n/15)", "        val divisors = ListBuffer(2l);\
    \ var divisor = 0l\n        while (divisor < n) {\n            if (n % divisor\
    \ == 0) divisors += divisor\n            divisor += 1l\n        }\n        divisors.max",
  "        val divisors = mutable.ListBuffer[Long]()\n        var max = n\n      \
    \  for(i <- 1 to (math.max(n/2, 1L))) {\n            if(n % i == 0) {\n      \
    \          divisors += i\n                n /= i\n            }\n        }\n \
    \       if(n != 1) { divisors += n; max = 1L}\n        divisors.toList.max.toLong",
  "        if(n < 2)\n            1\n        else if(n % 2 == 0)\n            n\n\
    \        else\n            largestDivisor(n / 2)", "        val s = n.toString.toInt\n\
    \        var largestDivisor = 0\n        val count = mutable.ArrayBuffer.empty[Long]\n\
    \        for ( i <- 0 until s) {\n            if (n % i == 0) {\n            \
    \    largestDivisor = i\n                count += i\n            }\n        }\n\
    \        largestDivisor * count.max", "      require(n > 0, \"n must be positive\"\
    )\n      val l = scala.math.abs(n).toInt\n      var maxDiv = 1\n      while (maxDiv\
    \ < l) {\n        maxDiv = (maxDiv * 2) if (n%maxDiv == 0)\n      }\n      maxDiv",
  "        val divisors = scala.collection.mutable.ListBuffer[Long]()\n        var\
    \ remainder = n\n        var candidate = n\n        while(candidate != 0) {\n\
    \            divisors ::= candidate\n            remainder -= candidate\n    \
    \        if (remainder >= 0) {\n                candidate += 1\n            }\n\
    \        }\n        if (divisors.isEmpty) {\n            remainder\n        }\
    \ else {\n            divisors.max\n        }", "        val maxDivisor = (1l)\
    \ * (1l); // this value will not divide n\n        val maxFactor = max { n / i\
    \ } \n        // Loop through the factors\n        for (i <- 1 to maxFactor) {\n\
    \            if (n % i == 0) {\n                maxDivisor = i // found a factor\n\
    \            }\n        }\n        return maxDivisor // return the largest value\
    \ found", "        var max = n\n        while (max > 1) {\n            max -=\
    \ 1\n            if (isDivisor(n, max)) {\n                return max\n      \
    \      }\n        }\n        return max", "        val m = mutable.HashMap[Long,\
    \ Int]()\n        val q = mutable.Queue[Long]()\n        val r = mutable.ArrayBuffer.empty[Long]\n\
    \        val m = mutable.HashMap[Long, Int]()\n        var d = 1l\n        while(n\
    \ != 0l) {\n            m += (d -> (m get d)).getOrElse(d, 1l)\n            d\
    \ = (d + 2l) / 2l\n            r +=+ d\n            n -= 1l\n        }\n     \
    \   while(!r.isEmpty) {\n            q += (r.dequeue).toLong\n            m +=\
    \ (q dequeue).toLong -> (m get (q dequeue)).getOrElse(q.dequeue, 1l) + 1l\n  \
    \      }\n        m values.max", "        val nums = mutable.ArrayBuffer.empty[Long]\n\
    \        for (i <- 2 to n) nums += i\n        nums.find(num => n % num == 0) ==\
    \ None", "        val s = scala.math.BigInt(n)\n        val divs = mutable.Set.empty[Long]\n\
    \        while(s.isEven) {\n            divs += scala.math.min(s, n) //smallest\
    \ number that divides evenly is at least itself\n            s %= scala.math.min(s,\
    \ n) //next number is the least factor\n        }\n        divs.lastOption.get",
  "        // Use a mutable Map to store the result\n        val map = new mutable.HashMap[Long,\
    \ Long]()\n        for (i <- 2 to n/2){\n            val div = n/i\n         \
    \   if (map.contains(div)) {\n                map.update(div, map.get(div) + 1)\n\
    \            }\n            else {\n                map.put(div, 1)\n        \
    \    }\n        }\n        map.values.max"]
stop_tokens:
- "\n    }\n"
