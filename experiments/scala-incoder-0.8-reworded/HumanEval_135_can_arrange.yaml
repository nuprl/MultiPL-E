name: HumanEval_135_can_arrange
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Create a function which returns the largest index of an element which\n\
  \    // is not greater than or equal to the element immediately preceding it. If\n\
  \    // no such element exists then return -1. The given list will not contain\n\
  \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
  \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long]) :\
  \ Long = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(canArrange((List[Long](1l.toLong,\
  \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong,\
  \ 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
  \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong, 10l.toLong)))\
  \ == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong, 5l.toLong,\
  \ 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]())) == (-1l));\n\
  \    }\n\n}\n"
completions: ["        var largest = 0L\n        var maxIndex = -1\n        var index\
    \ = 0\n        for(i <- arr.indices)\n            if(arr(i) != arr(index))\n \
    \               largest = arr(i)\n                maxIndex = i\n            index++\n\
    \        if(maxIndex == -1)\n            largest = -1\n        return largest",
  "        var largest = -1L\n        var largestIndex = 0\n        var currIndex\
    \ = arr.length\n        while (largest == -1) {\n            largest = -1L\n \
    \           largestIndex = -1L\n            for (i <- currIndex to arr.length)\
    \ {\n                if (arr(i) > largest) {\n                    largest = arr(i)\n\
    \                    largestIndex = i\n                }\n            }\n    \
    \        currIndex -= 1\n        }\n        largestIndex", "      val result =\
    \ arr.foldLeft(-1)(lst => lst.indexOf(lst.head) + 1)\n      if(result == -1) {\n\
    \        result\n      } else {\n        val maxIndex = arr.indexWhere(e => e\
    \ <= result)\n        if (maxIndex == -1)\n          -1\n        else\n      \
    \    maxIndex\n      }", "        val arr = arr.toList\n        var maxIndex =\
    \ 0\n        arr.foreach { element =>\n            if(element > maxIndex){\n \
    \               maxIndex = element\n            }\n        }\n        if(maxIndex\
    \ == 0){\n            return -1\n        }else{\n            return maxIndex\n\
    \        }", "        var maxIndex : Long = -1\n        var maxElem : Long = -1\n\
    \        var i : Long = 0\n        var prev : Long = -1\n        var cur : Long\
    \ = 0\n        arr.foreach { elem =>\n            if (elem > maxElem) {\n    \
    \            maxElem = elem\n                maxIndex = i\n            }\n   \
    \         if (elem > prev) {\n                prev = elem\n                cur\
    \ = i\n            }\n            i += 1\n        }\n        if (maxElem < 0)\n\
    \            maxIndex\n        else\n            maxIndex - 1", '        arr.foldLeft[Long](-1,
    -1)((prev, cur)=> if (cur < prev) -1 else cur)', '        arr.find(x => x <= arr(0)).getOrElse(-1l)',
  "        var largestIndex = 0l\n        var largestIndexCount = 0\n        var currentIndex\
    \ = -1\n        arr.foreach((index) => \n            if (index > currentIndex)\
    \ { \n                largestIndex = index\n                largestIndexCount\
    \ = 1\n            } else { \n                if (index == currentIndex) { \n\
    \                    largestIndexCount += 1\n                } \n            }\n\
    \        )\n        if (largestIndexCount > arr.length - 1) { \n            largestIndex\
    \ = -1l \n        }\n        largestIndex", "        // Create an empty set for\
    \ keeping track of which values are already seen\n        val seen = collection.mutable.HashSet[Long]()\n\
    \        arr.zipWithIndex.foreach { case (v, i) =>\n            // If we've seen\
    \ the element before, we're done\n            if (seen.contains(v)) {\n      \
    \          if (i == 0) -1 else arr.length\n            } else {\n            \
    \    // If we've not seen the element before, add to the set\n               \
    \ seen += v\n            }\n        }", "        var max : Long = -1\n       \
    \ arr.foreach{ x =>\n            if(x >  max) {\n                max = x\n   \
    \         }\n        }\n        if (max < 0) {\n            max = -1\n       \
    \ }\n        max", "        val res = arr.last\n        for (i <- 0 until arr.length)\
    \ {\n            if (arr(i) > res)\n                return res\n        }\n  \
    \      -1", "        val arr = arr.sortWith(_ <= _)\n        val maxIndex = arr.lastOption.orElse(-1)\n\
    \        if(maxIndex == -1) return -1\n        if(maxIndex > arr.lastIndex) canArrange(arr.drop(maxIndex\
    \ - arr.lastIndex))\n        else maxIndex", "        val res = arr.foldLeft(-1){\n\
    \            (max, cur) => max match {\n                case -1 => cur\n     \
    \           case x if x > cur => x\n                case x => cur\n          \
    \  }\n        }\n        res", "        val sortedList = arr.sorted\n        for\
    \ (i <- 0 until arr.length) {\n            if (sortedList(arr.length - i) < arr(i))\
    \ {\n                return arr(i) + 1\n            }\n        }\n        return\
    \ -1", "        var i = 0\n        var maxIndex = 0\n        while (i < arr.length)\
    \ {\n            if (arr(i) <= arr(i + 1)) {\n                maxIndex = i\n \
    \           } else {\n                i += 1\n            }\n        }\n     \
    \   if (maxIndex == 0) {\n            -1\n        } else {\n            maxIndex\n\
    \        }", '      arr.zipWithIndex.max{ case(a, b) => a <= b }._1 + 1', "  \
    \    val m = new scala.collection.mutable.PriorityQueue[Long]\n      val p = 0l\n\
    \      for(i <- arr.indices) {\n        if(i != p) {\n          m.enqueue(arr(i))\n\
    \          p = i\n        }\n      }\n      val lastIndex = m.lastOption.getOrElse(-1l)\n\
    \      lastIndex", "        var max = -1l\n        var idx = -1l\n        for\
    \ (i <- arr.indices) {\n            if (max < arr(i)) {\n                max =\
    \ arr(i)\n                idx = i\n            }\n        }\n        idx", " \
    \       if (arr.isEmpty) {\n            return -1\n        }\n        var index\
    \ = 0\n        var largest = 0\n        var prev = arr(index)\n        while (index\
    \ < arr.length) {\n            if (arr(index) >= prev) {\n                largest\
    \ = index\n            }\n            prev = arr(index)\n            index +=\
    \ 1\n        }\n        if (largest == 0) {\n            largest = -1\n      \
    \  }\n        return largest", "        val maxIndex = arr.toList.max\n      \
    \  var index = -1\n        var prevMaxIndex = -1\n        for ( i <- 0 until arr.length\
    \ ) {\n            if (arr(i) > maxIndex) {\n                index = i\n     \
    \           prevMaxIndex = maxIndex\n            }\n        }\n        if (index\
    \ == -1) {\n            prevMaxIndex\n        } else {\n            index\n  \
    \      }", '      arr.reverse.dropWhile(_ >= arr.get).lastOption.getOrElse(-1)',
  '        arr.zipWithIndex.maxBy(_._1)', "        var max = -1l\n        var maxIndex\
    \ = 0\n        var maxElem = arr(0)\n        for (i <- 1 until arr.length) {\n\
    \            if (maxElem <= arr(i)) {\n                maxElem = arr(i)\n    \
    \            maxIndex = i\n            }\n        }\n        maxIndex", "    \
    \    var maxIndex = -1\n        var currentIndex = 0\n        var max = arr(0)\n\
    \        // Traverse the list starting from the second element.\n        for (x\
    \ <- arr.tail) {\n            if (x > max) {\n                // Found an element\
    \ greater than the current max.\n                // Update maxIndex and max and\
    \ current index.\n                if (currentIndex >= maxIndex) {\n          \
    \          // The current index must be greater than the previous index.\n   \
    \                 maxIndex = currentIndex\n                    max = x\n     \
    \           }\n            } else if (x == max) {\n                // Found the\
    \ max element. No other element is greater than it.\n                // Update\
    \ the maxIndex and max.\n                maxIndex = currentIndex + 1\n       \
    \         max = x\n            }\n            currentIndex += 1\n        }\n \
    \       max", "        var maxIndex = -1L\n        var lastIndex = -1L\n     \
    \   for (i<- arr.indices) {\n            if (arr(i) > arr(lastIndex)) {\n    \
    \            maxIndex = i + 1\n            } else if (arr(i) == arr(lastIndex))\
    \ {\n                lastIndex = i\n            }\n        }\n        maxIndex",
  "        // Code here\n        var largest = -1\n        var maxIndex = -1\n   \
    \     for ( i <- arr.length - 1 ){\n            if( arr(i) > arr(i+1) ){\n   \
    \             largest = i\n                maxIndex = i\n            }\n     \
    \   }\n        if( largest < -1 ){ largest = maxIndex}\n        return largest",
  "        val a = arr.sort\n        var b = a.head\n        var c = -1l\n       \
    \ for(i <- 1 until a.length) {\n            val d = a(i)\n            if(d <=\
    \ b) {\n                c = i\n                break\n            }\n        \
    \    else if(d == b) {\n                b = d\n            }\n        }\n    \
    \    c", "        val pairs = arr.groupBy(_.toLong)\n        pairs.map(_._2.map(arr(_))).max\
    \ match {\n            case Some(pair) => pair(0)\n            case None => -1\n\
    \        }", "        var maxIndex = -1l\n        var maxValue = -1l\n       \
    \ for(i <- 0 until arr.length) {\n            var value : Long = arr(i)\n    \
    \        if (value > maxValue) {\n                maxValue = value\n         \
    \       maxIndex = i\n            }\n        }\n        return maxIndex", "  \
    \      val res = arr.takeWhile(x => x >= arr(arr.length-1))\n        res.lastOption.getOrElse(-1)",
  "        var i = -1\n        var n = arr.size\n        var max = -99999999999999999l.toLong\n\
    \        while(i < n) {\n          max = Math.max(max, arr(i))\n          if (arr(i)\
    \ <= max)\n            i += 1\n          else\n            i -= 1\n        }\n\
    \        max - 1", "        val largestIndex = -1\n        val largestValue =\
    \ arr(0)\n\n        for (i <- arr.indices) {\n            if (arr(i) < largestValue)\
    \ {\n                largestValue = arr(i)\n                largestIndex = i\n\
    \            }\n        }\n\n        largestIndex", "        // Your code here\n\
    \        val maxIndex = arr(arr.length-1)\n        val maxIndex = arr.indexOfMax(elem\
    \ => elem < maxIndex)\n        if(maxIndex == -1) -1\n        else arr.indexOf(maxIndex)",
  "        var maxIndex = -1\n        var maxVal = -1\n        for (i <- 0 until arr.length)\
    \ {\n            if (arr(i) > maxVal) {\n                maxVal = arr(i)\n   \
    \             maxIndex = i\n            }\n        }\n        return maxIndex",
  "        val maxIndex = arr.zipWithIndex.maxBy(_._1)._2\n        arr.lastIndexWhere(_\
    \ < maxIndex)", "        if (arr.isEmpty) -1\n        else {\n            val\
    \ m = arr.head\n            val l = arr.tail.sortBy(x => x - m).last\n       \
    \     val i = arr.indexWhere(x => x != l && x > l) + 1\n            if (i < 0)\
    \ -1\n            else i\n        }", "        // Code goes here\n        val\
    \ m = new mutable.HashMap[Long, Int]()\n        for(x <- arr){\n            if(m.containsKey(x))\n\
    \                m.put(x, m.get(x) + 1)\n            else\n                m.put(x,\
    \ 1)\n        }\n        var result = -1\n        for(x <- m.keys){\n        \
    \    if(m.get(x) > 1)\n                result = x\n        }\n        result",
  "        val a = arr.toList\n        val sorted = a.sortBy(x => x) // sort by value\n\
    \        val start = -1\n        for (i<- 0 until sorted.length)\n           \
    \ if (sorted[i-1] < sorted[i])\n                start = i\n        val largest\
    \ = sorted.lastOption\n        largest.getOrElse(-1l) // -1 if no such element\
    \ exists", "        val n = arr.size\n        var maxIndex : Long = -1L\n    \
    \    var currentIndex : Long = 0\n        while (currentIndex < n) {\n       \
    \     if (arr[currentIndex] < arr[currentIndex - 1]) {\n                // The\
    \ current element is less than the previous one.\n                // So current\
    \ element is larger than previous one\n                // and current index is\
    \ the index to which we have to shift to\n                // find next element\
    \ greater than or equal to the current one.\n                maxIndex = currentIndex\n\
    \            } else {\n                // The current element is greater than\
    \ the previous one\n                // So current element is the last element\n\
    \                // We are done with traversing the list.\n                currentIndex\
    \ = maxIndex\n                break\n            }\n            currentIndex +=\
    \ 1\n        }\n        maxIndex", "        if (arr.isEmpty) -1\n        else\
    \ arr.takeWhile(_ < arr.last).max", "        var maxIndex = 0L\n        for (i<-arr)\
    \ {\n            if (i >= arr(maxIndex)) {\n                maxIndex = i\n   \
    \         }\n        }\n        if (maxIndex == 0L) {\n            maxIndex =\
    \ -1L\n        }\n        maxIndex", "        var index = -1\n        var maxIndex\
    \ = -1\n        for ( i <- 0 until arr.length ) {\n            if ( i == 0 ) {\n\
    \                if ( arr(i) <= arr(i+1) )\n                    index = i\n  \
    \          }\n            else {\n                if ( arr(i) <= arr(i-1) )\n\
    \                    index = i\n            }\n            if ( index > -1 ) {\n\
    \                if ( arr(i) > arr(maxIndex) )\n                    maxIndex =\
    \ index\n            }\n        }\n        return maxIndex", "        val result\
    \ = arr.foldLeft[Long](-1l) { (result, el) => if (el >= result) el else result\
    \ }\n        if (result > -1l) result else -1l", "        // Only return -1 if\
    \ there are no elements or no duplicates\n        if(arr.isEmpty){\n         \
    \   return -1\n        }\n        val map = new collection.mutable.HashMap[(Long,\
    \ Long), Int]()\n        // Build the map of numbers and their indexes for O(n)\
    \ time complexity\n        var i = 0\n        for(num <- arr){\n            val\
    \ oldIndex = map.getOrElse((num, i), 1)\n            i += 1\n            val newIndex\
    \ = oldIndex + 1\n            map.put((num, newIndex), oldIndex)\n        }\n\
    \        // Iterate through the map and find the element which has a lower index\n\
    \        var maxIndex = -1\n        for((num, index) <- map.toList){\n       \
    \     if(index < maxIndex){\n                // Found a higher value so return\
    \ the current index\n                maxIndex = index\n            }\n       \
    \ }\n        return maxIndex", "        val res = arr.foldLeft((-1l, -1)) { (acc,\
    \ elem)\n               (if (elem > acc._1) (elem, acc._2) else (acc._1, elem))\n\
    \           }\n        res._1", "        var maxIndex = -1L\n        var index\
    \ = -1L\n        for (x <- arr) {\n            index += 1\n            if (maxIndex\
    \ < x) {\n                maxIndex = index\n            }\n            if (x !=\
    \ arr(index-1)) {\n                maxIndex = -1L\n                index = -1L\n\
    \            }\n        }\n        if (maxIndex == -1L) {\n            return\
    \ -1L\n        }\n        return maxIndex", "        var max = -1L\n        var\
    \ maxIndex = 0\n\n        for (i <- 0 until arr.length) {\n            if (arr(i)\
    \ > max) {\n                max = arr(i)\n                maxIndex = i\n     \
    \       }\n        }\n        maxIndex", "        var maxIndex = 0\n        for\
    \ (i <- arr.indices) {\n            if (arr(i) < arr(i + 1)) {\n             \
    \   maxIndex = i\n            }\n        }\n        if (maxIndex == arr.size -\
    \ 1) {\n            -1\n        } else {\n            maxIndex\n        }", " \
    \       val arr = arr.sortBy(_.toLong).reverse\n        val i = arr.toList\n \
    \       val j = i.toList\n        var max = 0L\n        var ans = -1L\n      \
    \  while (j < i.length) {\n            val last = i(j)\n            if (j != 0\
    \ && (last <= j)) {\n                if (last > j + 1) {\n                   \
    \ max = j\n                }\n                j += 2\n            } else {\n \
    \               max += 1\n                j -= 1\n            }\n            if\
    \ (ans == -1) {\n                ans = max\n            } else {\n           \
    \     if (max > ans) {\n                    ans = max\n                }\n   \
    \         }\n        }\n        ans", "        // O(N^2) -- use a mutable list\
    \ to avoid duplicates\n        val m = mutable.ListBuffer[Long]()\n        var\
    \ maxIndex = -1\n        for (i <- 0 until arr.length) {\n            if (i !=\
    \ 0 && arr(i) > arr(i-1)) {\n                m.clear()\n                m += arr(i)\n\
    \                m.sortWith(_ < _)\n                maxIndex += m.last\n     \
    \       } else {\n                maxIndex += 1\n            }\n        }\n  \
    \      maxIndex", '        arr.foldRight(-1l)((acc, cur) => if (acc >= cur) acc
    else cur)', "        var largest = arr.head\n        for (x <- arr) {\n      \
    \      if (x < largest + 1) {\n                largest = x\n            }\n  \
    \      }\n        largest", "        var i = 0\n        arr.foreach{ x =>\n  \
    \          if (x > arr(i)) i = i + 1\n        }\n        if (arr.length == i+1)\
    \ -1 else i", "        // Write your code here\n        var maxIndex = -1\n  \
    \      var minIndex = -1\n\n        val numOfElements = arr.length\n        val\
    \ numOfValuesBefore = arr.takeWhile(_ <= 0).length\n        for (i <- 0 until\
    \ numOfElements) {\n            if (arr(i) <= 0) {\n                maxIndex =\
    \ i\n            } else {\n                val index = i - numOfValuesBefore\n\
    \                if (maxIndex < 0 || index < maxIndex) {\n                   \
    \ maxIndex = index\n                }\n                val indexAfter = index\
    \ + 1\n                if (indexAfter < numOfElements && arr(indexAfter) > 0)\
    \ {\n                    minIndex = indexAfter\n                }\n          \
    \  }\n        }\n        if (maxIndex < 0 || maxIndex < minIndex) {\n        \
    \    return -1\n        }\n        return maxIndex", "        var maxIdx = 0\n\
    \        var maxVal = -1L\n        for(i <- 0 until arr.length) {\n          \
    \  if (arr(i) < arr(i + 1)) {\n                if (maxVal < arr(i)) {\n      \
    \              maxIdx = i\n                    maxVal = arr(i)\n             \
    \   }\n            }\n        }\n        if (maxIdx < 0) maxIdx = -1\n       \
    \ return maxIdx", "        val l1 = arr.lastOption\n        l1.map { x => if(x\
    \ >= arr.last) -1 else arr.lastIndexOf(x) + 1 }.getOrElse(-1l)", "        var\
    \ index = 0\n        var max = 0\n        for (i <- arr.indices) {\n         \
    \   if (arr(i) > arr(index)) {\n                max = i\n            } else {\n\
    \                if (i == 0) {\n                    index = i\n              \
    \  } else {\n                    if (arr(i) < arr(index)) {\n                \
    \        index = i\n                    }\n                }\n            }\n\
    \        }\n        index", "        var maxElem : Long = arr.head\n        var\
    \ currentIndex = 0\n\n        for (elem <- arr) {\n            val index = currentIndex\n\
    \n            while (currentIndex >= currentIndex && elem >= arr[currentIndex])\
    \ {\n                currentIndex += 1\n            }\n\n            maxElem =\
    \ elem if (currentIndex == index)\n        }\n\n        if (maxElem == arr.head)\
    \ -1 else maxElem", "        val n = arr.size\n        val max = -999999999l\n\
    \        var index = 0l\n        var maxIndex = 0l\n\n        for ((x, _) <- arr.zipWithIndex\
    \ if x < max) {\n            if (index >= maxIndex) {\n                maxIndex\
    \ = index\n                max = x\n            }\n            index = x + 1\n\
    \        }\n        -1l", "        var largest = -1 // Initialize largest index\
    \ to -1\n        var largestIndex = 0 // Initialize largest index to -1\n    \
    \    arr.foreach(\n            i => {\n                if(i<=largest)\n      \
    \              largestIndex = arr.indexOf(i)\n                else\n         \
    \           largest = i\n            }\n        )\n        largestIndex", "  \
    \      val pair = arr.foldLeft((Long.MaxValue, -1)){case ((a,b), c) =>\n     \
    \       if (a >= c) (a,b) else (b,a)\n        }\n        pair._2", "        if(arr.isEmpty)\
    \ -1\n        else if(arr.tail.forall(a => a <= arr.head)) arr.size - 1\n    \
    \    else -1", "        // Sort ascending\n        arr.sortWith(_ < _)\n     \
    \   val max = arr(0)\n        val res = -1L\n        for(i <- 1 to arr.length)\
    \ {\n            if (arr(i) <= max)\n                max = arr(i)\n          \
    \  else {\n                res = i\n                break\n            }\n   \
    \     }\n        res", "        var largest = -1\n        var curr = -1\n    \
    \    arr.zipWithIndex.foreach{\n            case (v, i) => {\n               \
    \ if (v > largest && i != curr ) {\n                    largest = v\n        \
    \            curr = i\n                }\n            }\n        }\n        if\
    \ (largest < 0) {\n            largest = -1\n        }\n        return largest",
  "        var highest = 0\n        for (x <- arr) {\n            if (x > arr(highest))\
    \ highest = x;\n        }\n        if (highest < 0) return -1\n        return\
    \ highest", "        val ans = arr.foldLeft[Long](-1l) {\n            (i, e) =>\
    \ if (e > i) return e else i\n        }\n        ans.toLong", "        var largest\
    \ = -1\n        var index = 0\n        for (e <- arr) {\n            if (largest\
    \ < 0 && e >= arr(index)) {\n                largest = index\n            } else\
    \ {\n                index++\n            }\n        }\n        return largest",
  "        val m = arr.indexOf(0)\n        if(m == arr.length - 1) -1\n        else\
    \ {\n            val left = arr span (_ < m(0))\n            val right = arr span\
    \ (_ < m)\n            if(left.length > 0) canArrange(left) else if (right.length\
    \ > 0) canArrange(right) else -1\n        }", "        var i = arr.length-1\n\
    \        var candidate = 0\n        while (i >= 0 && candidate == 0) {\n     \
    \       if (arr(i) <= arr(i-1)) {\n                candidate = i\n           \
    \ }\n            i -= 1\n        }\n        if (candidate == 0) {\n          \
    \  return -1\n        }\n        return candidate", "        if (arr.isEmpty)\
    \ {\n            -1\n        }\n        var maxIndex = -1\n        var i = 0\n\
    \        var j = arr.length - 1\n        while (i < j) {\n            if (arr(i)\
    \ <= arr(j)) {\n                i += 1\n            }\n            else {\n  \
    \              j -= 1\n            }\n            if (maxIndex < 0 || maxIndex\
    \ >= arr(i)) {\n                maxIndex = arr(i)\n            }\n        }\n\
    \        maxIndex", "        val res = arr.foldLeft[(Long, Long), Long](-1, -1)((e,\
    \ i) =>\n            if (e <= i)\n                (i, e)\n            else\n \
    \               (e, -1)\n        )\n        if (res._2 >= 0)\n            res._1\n\
    \        else\n            -1", "        var max = 0l\n        var i = 0l\n  \
    \      for (ele <- arr) {\n            if (i >= max) {\n                if (ele\
    \ >= arr(i - 1)) max = i\n            }\n            i += 1\n        }\n     \
    \   if (max == -1l) {\n            return -1l\n        }\n        return max",
  "        var maxIndex = 0\n        var maxVal = arr(0)\n\n        for (i<- 0 until\
    \ arr.length) {\n            if (arr(i) > maxVal) {\n                maxVal =\
    \ arr(i)\n                maxIndex = i\n            }\n        }\n\n        if\
    \ (maxIndex == arr.length-1) {\n            -1\n        } else {\n           \
    \ maxIndex\n        }", "        // Your code goes here\n        val maxValue\
    \ = arr.last\n        val maxIndex = 0\n        for(i <- 0 until arr.length) {\n\
    \            val value = arr(i)\n            if(value > maxValue) {\n        \
    \        maxIndex = i\n                maxValue = value\n            }\n     \
    \   }\n        if(maxIndex > 0) {\n            maxIndex\n        } else {\n  \
    \          -1\n        }", "        var max = -1L\n        var maxIndex = -1L\n\
    \        for (x <- arr) {\n            if (x > max) {\n                max = x\n\
    \                maxIndex = arr.indexOf(x)\n            }\n        }\n       \
    \ maxIndex", "        if(arr.isEmpty) -1\n        else {\n            // Find\
    \ the largest number that is not greater than arr(0)\n            var largest\
    \ = -1\n            for(i <- 0 until arr.length) {\n                if(largest\
    \ < arr(i) && arr(i) >= arr(i-1)) largest = i\n            }\n            largest\n\
    \        }", "        var maxIndex = -1l\n        for (elem <- arr) {\n      \
    \      if(elem <= arr(maxIndex)) {\n                maxIndex = -1\n          \
    \  } else {\n                maxIndex += 1\n            }\n        }\n       \
    \ maxIndex", "        var max = -1L\n        var max = -1L\n        val max =\
    \ -1\n        val arr = arr.toSeq\n        arr match {\n            case Nil =>\
    \ -1\n            case head :: tail => {\n                if (head <= tail.head)\
    \ {\n                    max = head\n                } else {\n              \
    \      max = tail.head\n                }\n            }\n        }\n        max",
  "        var largest = -1l\n        var maxIndex = -1\n        for (i <- 0 until\
    \ arr.size) {\n            if (largest < arr(i)) {\n                largest =\
    \ arr(i)\n                maxIndex = i\n            }\n        }\n        if (maxIndex\
    \ > 0) {\n            largest\n        } else {\n            -1\n        }", '        arr.lastIndexWhere(_
    > arr.headOption)', "        val res = arr.foldLeft((0l, -1l)) { (a,b) => if (b\
    \ > a._2) (a, b) else (b,a) }\n        res._1 ", "        arr.zipWithIndex.max{\
    \ case (el, i) =>\n            el >= arr(i - 1)\n        }._2", "        val a\
    \ = arr.reverseIterator\n        var maxIndex : Long = -1l\n        var i : Long\
    \ = 0\n        a.foreach{ elem =>\n            if(elem < arr.head) {\n       \
    \         i = elem\n            }\n            else {\n                maxIndex\
    \ = i\n                i = 0\n            }\n        }\n        if(maxIndex >=\
    \ arr.head) {\n            -1\n        }\n        else {\n            maxIndex\n\
    \        }", "        val l = arr sortBy {_.toLong } reverse take 1\n        if\
    \ (l.isEmpty || l.head == l.last) {\n            -1\n        } else {\n      \
    \      arr.indexOf(l(l.reverse dropRight 1) )\n        }", "        val sortedList\
    \ = arr.sorted\n        for (i <- 0 until sortedList.length) \n            if(sortedList(i)\
    \ >= sortedList(i-1)) \n                return i\n        return -1", "      \
    \  val m = arr.head\n        var index = 0\n        arr.foreach { x =>\n     \
    \       if (x < m) index = x\n            else m = m\n        }\n        if (index\
    \ == arr.length) return -1\n        else index", "        var maxIndex = 0\n \
    \       var maxVal = -1\n        var found = false\n        for (i <- 0 until\
    \ arr.length) {\n            if(found) {\n                break\n            }\n\
    \            val newVal = arr(i)\n            if (newVal <= maxVal) {\n      \
    \          maxIndex = i\n                maxVal = newVal\n                found\
    \ = true\n            }\n        }\n        if(found == false)\n            return\
    \ -1\n        else\n            return maxIndex", "        var maxIndex = 0\n\
    \        var maxVal = arr(0) // the largest element\n\n        for (i<-1 to arr.length-1)\
    \ {\n            if (arr(i) > maxVal) {\n                maxIndex = i\n      \
    \          maxVal = arr(i)\n            }\n        }\n        if (maxIndex >=\
    \ 0) maxIndex\n        else -1", "        val l = new mutable.LinkedList[Long]()\n\
    \        var index = 0\n        arr.foreach(i => {\n            if (l.contains(i))\
    \ return\n            index += 1\n            l.add(i)\n        })\n        return\
    \ index", "        var max = -1L\n        var current = 0L\n\n        for (elem\
    \ <- arr.toArray.reverse.iterator) {\n            if (current <= elem) {\n   \
    \             max = current\n            } else {\n                current = elem\
    \ - 1\n            }\n        }\n\n        max", "        var index = -1l\n  \
    \      var max = 0\n        var currentValue = 0\n        var currentIndex = 0\n\
    \        arr.foreach(x => {\n            if (x> max && x > currentValue) {\n \
    \               currentValue = x\n                currentIndex = index\n     \
    \       } else if (x != currentValue) {\n                index = currentIndex\n\
    \                max = currentValue\n                currentValue = 0\n      \
    \      }\n        })\n        return currentIndex", "        val max = arr.iterator\n\
    \        val result = -1l\n        val currIndex = -1\n        for (i <- 0 to\
    \ arr.length - 1) {\n            if(arr(i) > arr(i-1)) {\n                val\
    \ tmpMax = max\n                max = i\n                currIndex = i\n     \
    \       }\n        }\n        max = tmpMax\n        if(max == -1l && arr.size\
    \ == 1) max = 0\n        result", "        var maxIndex: Long = -1\n        var\
    \ max: Long = 0\n        for (i <- 0 until arr.length) {\n            if (arr(i)\
    \ > max)\n                max = arr(i)\n            if (arr(i) == max)\n     \
    \           maxIndex = i\n        }\n        maxIndex", '        arr.zipWithIndex.maxBy(_._1)._2',
  "        val sorted = arr.sortWith(_ <= _)\n        val leftmost = sorted.head\n\
    \        var maxIndex = 0\n\n        for (i <- sorted.reverse.indices) {\n   \
    \         if (sorted[i] > leftmost) {\n                maxIndex = i + 1\n    \
    \            break\n            }\n        }\n        if (maxIndex == 0)\n   \
    \         return -1\n        else\n            return maxIndex", "        // Your\
    \ code goes here\n        arr.foldRight(-1, 0)((acc, i) => {\n            val\
    \ leftIndex = acc - 1\n            if (i >= arr[leftIndex]) {\n              \
    \  leftIndex\n            } else {\n                -1\n            }\n      \
    \  })", '      arr.reverse.dropWhile(_ <= arr.head).reverse.indexOf(0l) - 1',
  "        var max = -1\n        var i = 1\n        while (i < arr.length) {\n   \
    \         if ((arr(i) < arr(i-1)) && (arr(i) != max))\n                max = arr(i)\n\
    \            i += 1\n        }\n        max", "        val minElem = arr.min\n\
    \        val max = arr.max\n        val indexMap = arr.zipWithIndex.toMap\n  \
    \      val newIndexMap : Map[Long, Long] = indexMap.map{case (k, v) => k -> v\
    \ + 1}\n        val res : Long = indexMap(minElem)\n        if (indexMap.contains(max))\
    \ -1 else res", '        arr.zipWithIndex.maxBy(_._1)._2', "      var max = -1l\n\
    \      var index = 0l\n      for(i <- arr.indices) {\n        if(arr(i) > arr(index\
    \ + 1))\n          index = i\n      }\n      max = index\n      return max", " \
    \       arr.headOption match {\n            case None => -1\n            case\
    \ Some(head) =>\n                val prevIndex = arr.lastIndexWhere(x => x > head)\
    \ match {\n                    case None => -1\n                    case Some(prevIndex)\
    \ => prevIndex + 1\n                }\n                if (prevIndex == -1)\n\
    \                    -1\n                else\n                    prevIndex\n\
    \        }", "        val max = arr.last\n        val index = arr.indexWhere(i\
    \ => i <= max)\n        if (index == arr.length)\n            -1\n        else\n\
    \            arr.lift(index).max", "        arr.foldLeft(arr.head)( (max, x) =>\
    \ {\n            if (max <= x) return x\n            else return max\n       \
    \ })", "        var maxIndex = -1l\n        var maxNumber = Long.MinValue\n  \
    \      var previousNumber = Long.MinValue\n        arr.foreach((x) => {\n    \
    \        if( x != previousNumber ){\n                maxIndex = maxIndex + 1\n\
    \                maxNumber = x\n            }\n            previousNumber = x\n\
    \        })\n        if( maxNumber == Long.MinValue ){\n            maxIndex =\
    \ -1\n        }\n        return maxIndex", "        var maxIndex = 0\n       \
    \ arr.foreach { x => if (x > maxIndex) maxIndex = x }\n        maxIndex", "  \
    \      var maxIndex = -1l\n        var maxVal = -1L\n        var i = 0\n     \
    \   for (x <- arr) {\n            if (maxVal == -1L) {\n                maxVal\
    \ = x\n                maxIndex = 0\n            } else if (maxVal < x) {\n  \
    \              maxVal = x\n                maxIndex = 0\n            } else if\
    \ (maxVal == x) {\n                maxIndex = i + 1\n            }\n         \
    \   i += 1\n        }\n        if (maxIndex < 0) {\n            return -1L\n \
    \       }\n        return maxIndex", "      val a = arr.sorted\n      var maxIndex\
    \ = -1\n      var curIndex = 0\n      for(i <- 0 until a.length) {\n        if(a(i)\
    \ < a(i + 1))\n          curIndex += 1\n        else\n          if(curIndex >\
    \ maxIndex) {\n            maxIndex = curIndex\n          }\n          curIndex\
    \ = 0\n      }\n      if(maxIndex < arr.length) {\n        return maxIndex\n \
    \     }\n      else\n        return -1", "        val max = arr.max\n        if(max\
    \ > 0)\n            for (i <- arr.indices) yield {\n                if((i > 0)\
    \ && (arr(i) == arr(i - 1)))\n                    arr(i)\n                else\n\
    \                    -1\n            }.toList.max\n        else\n            -1",
  "        // Write your function here\n        val map = arr.foldLeft(Map.empty[Long,\
    \ Int]) { case (acc, x) =>\n            if (acc.isEmpty) acc + (x -> 1)\n    \
    \        else {\n                val found = acc.find(_._2 > x)\n            \
    \    if (found == None) acc + (x -> 1)\n                else if (found._2 > x)\
    \ acc + (x -> found._2 + 1)\n                else acc\n            }\n       \
    \ }\n        val max = map.maxBy(_._2)._1.toLong\n        if (map.contains(max))\
    \ max else -1", "        var i = 1\n        var maxIndex = 0\n        while (i\
    \ < arr.length) {\n            if (arr(i) <= arr(i - 1) && arr(i) != -1) {\n \
    \               maxIndex = i\n            }\n            i += 1\n        }\n \
    \       return maxIndex", "        def getIndex(e, i : Int) : Int = {\n      \
    \      if (i < arr.length && e > arr(i)) i else -1\n        }\n        val maxIndex\
    \ = -1\n        var currIndex = 0\n        while(currIndex < arr.length && currIndex\
    \ != maxIndex) {\n            maxIndex = getIndex(arr(currIndex), currIndex)\n\
    \            currIndex++\n        }\n        maxIndex", "        var maxIndex\
    \ = 0\n        for (_ <- 0 until arr.length - 1){\n            if (arr(maxIndex)\
    \ <= arr(maxIndex + 1)){\n                maxIndex = maxIndex + 1\n          \
    \  }\n            else {\n                break\n            }\n        }\n  \
    \      if (maxIndex != 0){\n            return maxIndex\n        }\n        else\
    \ {\n            return -1\n        }", "      val maxIndex: Long = arr.length-1\n\
    \      arr.toSeq.tail.zipWithIndex.find(_._2 > _._1).get._1 + 1", "        val\
    \ indexedList = arr.zipWithIndex\n        val firstElement = indexedList.head\n\
    \        val secondElement = indexedList.tail.head\n        val thirdElement =\
    \ indexedList.tail.tail.head\n        // First element is not greater than or\
    \ equal to the second\n        if (firstElement < secondElement) secondElement\n\
    \        // Second element is not greater than or equal to the third\n       \
    \ else if (secondElement < thirdElement) thirdElement\n        // All elements\
    \ are equal\n        else -1", "      val maxIndex = arr.indexWhere(x => x < arr.takeRight(1).head);\n\
    \      maxIndex == -1L ? -1L : maxIndex", "        if (arr.isEmpty) -1\n     \
    \   else {\n            var max = -1L\n            var max = -1L\n           \
    \ arr.foreach {\n                case i => if (i < max) max = i else max = -1L\n\
    \            }\n            max\n        }", '        arr.zip(arr.drop(1)).maxBy(_._1)',
  "        // Create a list of all unique elements (i.e. unique pairs with the\n \
    \       // first element distinct). We use a HashSet which eliminates duplicate\n\
    \        // elements.\n        val unqiues = HashSet(arr)\n        if (unqiues.isEmpty)\
    \ return -1\n        val max = arr.lastOption\n        if (max.isEmpty) return\
    \ -1\n        unqiues.find(elem => elem._1 > max._1) match {\n            case\
    \ Some(lastEl) => lastEl\n            case None => -1\n        }", "        val\
    \ sortedList = arr.toList.sortBy(x => x).reverse\n\n        var largestIndex =\
    \ -1\n        var nextLargestIndex = -1\n\n        val n = sortedList.size\n\n\
    \        if(n > 0) {\n            largestIndex = sortedList.head - sortedList(n\
    \ - 1)\n\n            nextLargestIndex = sortedList.head\n\n            if(largestIndex\
    \ > nextLargestIndex) {\n                nextLargestIndex = largestIndex - 1\n\
    \            }\n        }\n\n        nextLargestIndex", "        var largest =\
    \ -1\n        arr.drop(1).foreach(x => if (x >= largest) largest = x)\n      \
    \  largest", "        var result = -1\n        var nextHighIndex = 0\n       \
    \ var currentIndex = 0\n        for (elem <- arr) {\n            if (elem >= arr[currentIndex])\
    \ {\n                nextHighIndex = currentIndex\n            }\n           \
    \ currentIndex += 1\n            if (currentIndex == arr.length) {\n         \
    \       currentIndex = 0\n            }\n        }\n        if (nextHighIndex\
    \ == -1) {\n            return result\n        } else {\n            return nextHighIndex\n\
    \        }", "        val len = arr.length\n        val arrMap = arr.map( (a)\
    \ => a -> 1) // Create a map of original elements and their occurrences\n    \
    \    val maxMapKey = arr.last\n        val maxMapValue = arrMap(maxMapKey)\n \
    \       for (i <- 0 until len-1){\n            if (arrMap(i+maxMapKey) > maxMapValue){\n\
    \                maxMapKey = i\n                maxMapValue = arrMap(i+maxMapKey)\n\
    \            }\n        }\n        maxMapKey", "        var max = 0\n        var\
    \ index = 0\n        for(i <- arr.indices) {\n            val elem = arr(i)\n\
    \            if(elem > arr(index)) {\n                max = i\n            }\n\
    \            index += 1\n        }\n        if(max == 0) {\n            return\
    \ -1\n        }\n        return max", '        arr.zipWithIndex.maxBy(_._1)._2',
  "        var maxIndex = 0l\n        arr.foreach { i =>\n            if (i > maxIndex)\
    \ {\n                maxIndex = i\n            }\n        }\n        if (maxIndex\
    \ < arr.lastOption.getOrElse(-1l)) {\n            return -1\n        } else {\n\
    \            return maxIndex\n        }", "        val maxIndex = arr.length -\
    \ 1\n        var maxElem = arr(maxIndex)\n        var index = 0\n        while\
    \ (maxElem > arr(index)) {\n            index = index + 1\n        }\n       \
    \ if (index == maxIndex) {\n            -1\n        } else {\n            maxIndex\
    \ = index\n        }", "        val m = arr.head\n        var maxIndex = -1l\n\
    \        for (i<-1 to arr.length - 1) {\n            val n = arr(i)\n        \
    \    if (n > m)\n                maxIndex = i\n            else if (n == m)\n\
    \                continue\n            else\n                maxIndex = -1l\n\
    \        }\n        maxIndex", "        var i = 0\n        var maxIndex = -1\n\
    \        val list = arr.sorted\n        for (i <- 0 until list.size) {\n     \
    \       if (list(i) > list(i + 1)) {\n                maxIndex = i\n         \
    \   }\n        }\n        if (maxIndex < 0) maxIndex = -1\n        maxIndex",
  "        var lastI = 0\n        var canArrangeIndex = -1\n        for (i <- 0 until\
    \ arr.length) {\n            if (arr(i) <= arr(i-1)) lastI = i\n            else\
    \ canArrangeIndex = i\n        }\n        if(canArrangeIndex < 0) canArrangeIndex\
    \ = -1\n        lastI", "        val sortedList = arr.sorted\n        var highestIndex\
    \ = 0\n        var currentIndex = 0\n        for (elem <- sortedList) {\n    \
    \        if (currentIndex == 0) {\n                if (elem < sortedList(sortedList.lastIndex))\
    \ {\n                    currentIndex = arr.lastIndex\n                }\n   \
    \         } else if (elem > sortedList(currentIndex - 1)) {\n                currentIndex\
    \ = currentIndex - 1\n            }\n            highestIndex = if (elem > highestIndex)\
    \ elem else highestIndex\n        }\n        if (highestIndex >= arr.last) {\n\
    \            highestIndex\n        } else {\n            -1l\n        }", "  \
    \      var max = 0\n        var maxIndex = 0\n        var i = 1\n        var j\
    \ = 0\n        // Get max value\n        max = arr.foldLeft(0L)((a, b) => a >\
    \ b ? a : b)\n        while (i < arr.length) {\n            // Get value before\
    \ current max value\n            var value = arr(i)\n            // Check if the\
    \ value is greater than max and smaller than max minus current value\n       \
    \     if (value > max && value < max - value) {\n                max = value\n\
    \                maxIndex = i\n                j = 1\n            }\n        \
    \    // Increment j\n            if (value < max) {\n                j++\n   \
    \         }\n            // Increment i\n            i += 1\n            // Check\
    \ if j is greater than max and if so set max\n            if (j > max && value\
    \ != 0) {\n                max = value\n                maxIndex = i\n       \
    \     }\n        }\n        return maxIndex", "        // Add all elements of\
    \ the list to an array (call it a)\n        val a: Array[Long] = arr.toArray\n\
    \        // Sort the array in descending order\n        val sorted = a.sortWith(_\
    \ < _)\n        // Find the first element which is not greater or equal to the\
    \ previous\n        // element. If there is no such element then return -1\n \
    \       if (sorted.head < sorted.last) sorted.last else -1", "        if (arr.isEmpty)\
    \ -1\n        else arr.lastIndexWhere(x => x <= arr.last)", "        if(arr.isEmpty)\
    \ return -1\n        val l = arr.head\n        var cur = 0l\n        for(x <-\
    \ arr.tail) {\n            if(x>l && cur==-1) cur = x\n        }\n        if(cur==-1)\
    \ return -1\n        arr(arr.indexOf(l)+1)", "        val a = arr.foldLeft(List.empty[Long](0l))\
    \ { (a, ele) =>\n            if (a.contains(ele)) {\n                a\n     \
    \       } else {\n                a :+ ele\n            }\n        }\n       \
    \ val b = a :+ arr.last\n        if (b.last.compare(b.init) < 0) -1\n        else\
    \ {\n            b.last\n        }", "        var max = -1l\n        var i = -1\n\
    \n        for (i <- 0 until arr.size) {\n            if (arr(i) > arr(i + 1))\n\
    \                max = arr(i)\n        }\n\n        if (max < 0l)\n          \
    \  max = -1l\n\n        max", "        val maxIndex = 0\n        arr.head match\
    \ {\n            case x if (x < arr.last) => -1\n            case x if (x > arr.last)\
    \ => maxIndex\n            case x => arr.indexOf(x)\n        }", "        val\
    \ l: List[Int] = arr.toList\n        val r: scala.collection.mutable.ListBuffer[Int]\
    \ = new ListBuffer()\n        var current = 0\n        var index = 0\n       \
    \ var max = 0\n        for (i <- 0 until l.length) {\n            if (l(i) <=\
    \ current) {\n                // If current is greater than or equal to l(i) then\
    \ decrement current\n                current = current - 1\n            } else\
    \ {\n                // If current is less than or equal to l(i) then append current\
    \ to r\n                index += 1\n                r += current\n           \
    \     current = l(i)\n            }\n\n            if (index == r.length) max\
    \ += current\n        }\n        if (max > arr.size) max else -1", "        if\
    \ (arr.isEmpty) return -1\n        var maxIndex = 0\n        var prev = 0\n  \
    \      for (i <- 0 until arr.size) {\n            if (arr(i) < arr(prev)) {\n\
    \                maxIndex = i + 1\n                prev = i\n            }\n \
    \       }\n        if (maxIndex < arr.size - 1) maxIndex + 1\n        else -1",
  "        var maxVal = -1\n        val l = new ListBuffer[Long]()\n        for (x\
    \ <- arr) {\n            if (x < arr(l(l.length - 1)))\n                maxVal\
    \ = l(l.length - 1)\n            l.append(x)\n        }\n        maxVal", "  \
    \      val l1 = arr.head\n        val l2 = arr.last\n        val l3 = arr.drop(1).dropRight(1)\n\
    \        if (l2 < l3 || l2 < l1) return -1\n        if (l3 < l2 || l3 < l1) return\
    \ -1\n        arr.indexOf(l2)", "        val l = arr.length\n        val h = arr.toList.drop(1).max\n\
    \        val r = arr.toList.drop(1).min\n        val max = arr.max\n        if\
    \ (l!=0)\n        {\n            if (l>=h)\n                -1\n            else\n\
    \            {\n                if (r>max)\n                    -1\n         \
    \       else\n                    r\n            }\n        }\n        else\n\
    \        {\n            if (l>=max)\n                -1\n            else\n  \
    \          {\n                if (r>max)\n                    -1\n           \
    \     else\n                    r\n            }\n        }", "        // Write\
    \ your code here\n        var maxIndex = -1\n        var currentIndex = 0\n  \
    \      arr.foreach( i => {\n            if(i <= arr(currentIndex)) maxIndex =\
    \ currentIndex\n            currentIndex += 1\n        })\n        maxIndex",
  "        var i = 0\n        arr.foreach(i => {\n            if (i > 0) return i\n\
    \        })\n        return -1", "        var largest = arr.head\n        var\
    \ largestIndex = 0\n        var smallest = arr.head\n        var smallestIndex\
    \ = 0\n        for( x <- arr.tail) {\n            if( x < smallest) {\n      \
    \          smallestIndex = arr.indexOf(x)\n                smallest = x\n    \
    \        }\n            else if( x > largest) {\n                largestIndex\
    \ = arr.indexOf(x)\n                largest = x\n            }\n        }\n  \
    \      if(smallest == arr.head && largestIndex == 0) {\n            -1\n     \
    \   }\n        else if(largest == arr.head && largestIndex == 1) {\n         \
    \   -1\n        }\n        else if(smallest == arr.head && largestIndex == -1)\
    \ {\n            -1\n        }\n        else if(smallest == arr.head && largestIndex\
    \ == arr.size-1) {\n            -1\n        }\n        else if(smallest == arr.head\
    \ && largestIndex == arr.size-2) {\n            -1\n        }\n        else {\n\
    \            largestIndex\n        }", "        val len = arr.size\n        var\
    \ index = 0\n        var largest = 0L\n\n        for(i <- 0 until len) {\n   \
    \         index = i\n            largest = max(index, largest)\n        }\n\n\
    \        if(largest == -1l) -1l\n        else if(arr.contains(largest)) -1\n \
    \       else {\n            val lastIndex = arr.lastIndexWhere(elem => elem >\
    \ largest)\n            arr.find(elem => elem < lastIndex && elem > largest).map(elem\
    \ => index).getOrElse(-1)\n        }", "        val max = arr.last\n        for\
    \ (i <- 0 until arr.length) {\n            if(arr(i) > max) {\n              \
    \  return -1\n            }\n        }\n        return max", "        if (arr.isEmpty)\
    \ -1\n        else {\n            val maxIndex = arr.toList.maxIndex(l => { l\
    \ >= arr(0); l })\n            if (maxIndex == -1) -1 else maxIndex\n        }",
  "        var index : Long = -1l\n        var prev : Long = -1l\n        for (i <-\
    \ 0 until arr.length) {\n            if (arr(i) > arr(prev)) {\n             \
    \   index = i\n            }\n            prev = i\n        }\n        return\
    \ index", "        if (arr.isEmpty) -1\n        else {\n            var maxIndex\
    \ = 0\n            var currentValue = arr.get(0)\n\n            for (index <-\
    \ 1 until arr.size) {\n                if (arr(index) < currentValue) {\n    \
    \                maxIndex = index\n                    currentValue = arr(index)\n\
    \                }\n            }\n\n            maxIndex\n        }", "     \
    \   val r = arr.scanLeft(-1)((r,v) =>\n            if(v >= r) r else v\n     \
    \   )\n        r.getOrElse(-1)", "        var biggest = 0\n        var index =\
    \ 1\n        for(i <- 0 until arr.length) {\n            if(arr(i) >= arr(biggest))\
    \ {\n                biggest = i\n            } else {\n                index\
    \ += 1\n            }\n        }\n        if(index == arr.length) {\n        \
    \    return -1\n        }\n        return biggest", "        // First we check\
    \ to see if any elements are greater than or equal to the\n        // element\
    \ immediately preceding the current element. If so return the\n        // index\
    \ of the last element which is greater than or equal to the current\n        //\
    \ element.\n        var bigger : Long = -1\n        var i : Long = arr.length\n\
    \        while ( i >= 0 ) {\n            if (arr(i) >= arr(i-1)) bigger = i\n\
    \            else i--\n        }\n        // If we did not find any larger elements\
    \ then return -1\n        if (bigger == -1) return -1\n        // If we did find\
    \ an element that is greater than or equal to the previous\n        // element\
    \ then return the last index of the element that is greater than\n        // or\
    \ equal to the previous element.\n        bigger", "        val l = arr.length\n\
    \        arr.foldLeft(-1)((maxIndex, currentValue, currentIndex) => {\n      \
    \      if ((currentIndex < 0) && (currentValue <= arr(maxIndex))) maxIndex else\
    \ currentIndex\n        })", '        // Solution here', "        val maxIndex\
    \ = arr.lastIndexWhere(elem => elem >= arr.last)\n        if(maxIndex == -1) -1\n\
    \        else maxIndex", "        var maxIndex = -1L\n        val indexSet = mutable.Set[Long]()\n\
    \        for(i <- 0 until arr.length - 1){\n            if(arr(i) <= arr(i+1)){\n\
    \                maxIndex = i +1\n            } else {\n                indexSet\
    \ += arr(i)\n            }\n        }\n        if(indexSet.size == 0){\n     \
    \       -1\n        } else {\n            maxIndex\n        }", "        var max\
    \ = -1L\n        var maxIndex = 0L\n        var currentMax = 0L\n        var i\
    \ = 1L\n        while(i <= arr.length) {\n            if(arr(i) > max) {\n   \
    \             max = arr(i)\n                maxIndex = i\n                currentMax\
    \ = max\n            } else {\n                if(arr(i) <= currentMax) {\n  \
    \                  currentMax = arr(i)\n                }\n            }\n   \
    \         i += 1\n        }\n        return maxIndex", "        val m = arr.head\n\
    \        var maxVal = 0\n        var maxIndex = -1\n        for (i <- arr diff\
    \ arr) {\n            if (i <= m) {\n                maxVal = i\n            \
    \    maxIndex = i\n            }\n        }\n        maxIndex", "        var maxi\
    \ = -1L\n        var maxElem = arr(0)\n        for (elem <- arr.drop(1)) {\n \
    \           if (elem <= maxElem) {\n                maxElem = elem\n         \
    \       maxi = arr.indexOfMax\n            }\n        }\n        maxi", "    \
    \    val max = arr(0l)\n        var index = -1l\n        for (x <- arr)\n    \
    \        if (x >= max)\n                index = x\n            else\n        \
    \        max = x\n        index", "        val low = arr(arr.head._ - 1)\n   \
    \     arr.indexWhere(_ < low)", "        var maxI = -1l\n        var prev = -1l\n\
    \        val arr2 = arr.toList\n        arr2.sortWith(_ < _)\n        for (i <-\
    \ 0 until arr2.length) {\n            if (arr2(i) > (prev+1)) {\n            \
    \    maxI = i\n            }\n            prev = arr2(i)\n        }\n        return\
    \ maxI", "        var result : Long = -1\n        var index : Long = -1\n    \
    \    val size = arr.size\n        if (size == 0) return -1\n        for (i <-\
    \ 0 until size - 1) {\n            if (index < 0 || arr(i) < arr(index)) {\n \
    \               result = i\n                index = i\n            }\n       \
    \ }\n        return result", "        val l = arr.length\n        val maxIndex\
    \ = -1L\n        var currentIndex = 0\n\n        // Go through the array and find\
    \ if element will be greater than or equal to the\n        // previous one. If\
    \ yes, update maxIndex with current index\n        while (currentIndex < l) {\n\
    \            if (arr(currentIndex) > arr(currentIndex - 1)) {\n              \
    \  maxIndex = currentIndex\n            }\n            currentIndex += 1\n   \
    \     }\n\n        // If maxIndex is less than or equal to -1, means no such element\
    \ exists, so return -1\n        if (maxIndex <= -1L) {\n            -1L\n    \
    \    } else {\n            maxIndex\n        }", "        if (arr.isEmpty)\n \
    \           return -1\n        var lastIndex = arr.head\n        var index = 1\n\
    \        while (index < arr.length) {\n            if (arr(index) >= lastIndex)\
    \ {\n                lastIndex = arr(index)\n            } else {\n          \
    \      index += 1 // move to next element\n            }\n        }\n        return\
    \ lastIndex", "        // Initialize a counter and store its initial value\n \
    \       var counter : Long = 0\n\n        // Iterate through the list and compare\
    \ each element to the element before\n        // it. If a value greater than or\
    \ equal to the previous element is found\n        // then increment the counter.\n\
    \        // This approach is O(n). No matter what approach we use, this will run\n\
    \        // in O(n).\n        for (elem <- arr) {\n            if (arr(counter)\
    \ <= elem) {\n                counter += 1\n            }\n            else {\n\
    \                // The element is not greater than or equal to the element before\n\
    \                // it, so return counter.\n                return counter\n \
    \           }\n        }\n        // If the array has one element, then it equals\
    \ the previous element.\n        return counter", "        var maxIndex : Long\
    \ = -1l\n        for (i <- 0 until arr.length) {\n            if (arr(i) > arr(i-1))\
    \ {\n                maxIndex = i\n            } else if (arr(i) < arr(i-1)) {\n\
    \                val tmp = arr(i)\n                arr(i) = arr(i-1)\n       \
    \         arr(i-1) = tmp\n            }\n        }\n        if (maxIndex < 0)\n\
    \            -1\n        else\n            maxIndex", "        val maxIndex =\
    \ arr.indices.max\n        if (arr.exists(_ >= arr(maxIndex-1)))\n           \
    \ -1\n        else\n            maxIndex", "        val n = arr.size\n       \
    \ val max = arr.last\n        var j = 1\n        var pos = 0\n        var k =\
    \ n - 1\n        while (pos < n) {\n            if (max < arr(pos + 1)) {\n  \
    \              pos = k\n                j = 1\n                max += 1\n    \
    \        }\n            j += 1\n            pos += 1\n        }\n        if (j\
    \ == 1) -1\n        else {\n            if (pos > 1) max(pos - 1, j - 1, j - 2)\n\
    \            else\n                max(j - 1)\n        }", "        // Your code\
    \ here\n        var maxIdx = 0\n        var maxVal = arr(0)\n        for (idx\
    \ <- arr.indices) {\n            if (arr(idx) < maxVal) {\n                maxIdx\
    \ = idx\n            } else {\n                maxVal = arr(idx)\n           \
    \ }\n        }\n        maxIdx", "        var i = 0\n        var max = -1\n  \
    \      arr.foreach( x => if(x > max) max = x ) \n        i += 1\n        while(\
    \ i < arr.length && max >= arr(i)) {\n            max = arr(i)\n            i\
    \ += 1\n        }\n        if(max < arr(0)) -1\n        else max", "        var\
    \ maxIndex = -1\n        var maxValue = arr(0).toLong\n        var index = 0\n\
    \        arr.foreach {x =>\n            if (x > 0l) {\n                if (maxIndex\
    \ == -1) {\n                    maxIndex = index\n                    maxValue\
    \ = x\n                } else {\n                    if (x > maxValue) {\n   \
    \                     maxIndex = index\n                        maxValue = x\n\
    \                    }\n                }\n            }\n            index +=\
    \ 1\n        }\n        if (maxIndex == -1) {\n            return -1\n       \
    \ } else {\n            return maxIndex\n        }", "        if (arr.isEmpty)\
    \ return -1\n\n        var maxIdx = -1\n        var currIdx = -1\n\n        for\
    \ (i <- 0 until arr.size) {\n            currIdx = i\n\n            if (arr(i)\
    \ < arr[currIdx]) maxIdx = currIdx\n            if (arr(i) > arr[currIdx]) break\n\
    \n        }\n\n        maxIdx", "        val i = arr.length\n        arr.foldLeft(-1){case\
    \ (i, x) => if (x > arr(i-1)) return i-1 else i}", "        val m = arr.head\n\
    \        var n = arr.tail.length\n        var max = 0\n        while( n >= 1 )\
    \ {\n            if ( arr(n-1) > m ) max = n\n            n--\n        }\n   \
    \     if ( max == -1 ) -1\n        else max", "        if (arr.isEmpty) -1\n \
    \       else {\n            val i = arr.indexOf(0)\n            if (i > -1) arr.indexOf(i)\
    \ else -1\n        }", "        // Your code goes here!\n        val maxIndex\
    \ = arr.length - 1\n        var index = maxIndex\n        while (!arr.exists(_\
    \ > arr(index))) {\n            index += 1\n        }\n        index", "     \
    \   // Store the largest seen index so far by adding 1 to it\n        var largestSeen\
    \ = -1\n\n        // Iterate through the list once\n        var i = 0\n      \
    \  while (i < arr.length) {\n            // If this index is greater than or equal\
    \ to what we've seen\n            // so far, that means we have seen it before,\
    \ and this is\n            // the biggestSeen, so increment it and return\n  \
    \          if (arr(i) < largestSeen) largestSeen = i + 1\n            // If we\
    \ have seen the entire list, we can't have seen any greater\n            else\
    \ return -1\n            i += 1\n        }\n        largestSeen", "        var\
    \ maxIndex : Long = -1\n        var maxNum : Long = -1\n        var max : Long\
    \ = -1\n        for(i <- arr.iterator){\n            if(maxNum < 0){\n       \
    \         maxNum = i\n                maxIndex = i\n            }\n          \
    \  if(max < 0){\n                max = i\n            }\n            else if(max\
    \ > i){\n                maxIndex = maxNum\n                maxNum = i\n     \
    \       }\n        }\n        if(maxNum == -1){\n            -1\n        }else{\n\
    \            maxIndex\n        }", "        val sortedArr = arr.toList.sort\n\
    \        val res = -1\n        var i = 1\n        var lastElement = -1\n     \
    \   while (i < sortedArr.length) {\n            if (sortedArr(i) <= sortedArr(lastElement))\
    \ {\n                lastElement = i\n            } else {\n                res\
    \ = i\n            }\n            i += 1\n        }\n        res", "        var\
    \ ans = -1\n        for (i <- 0 until arr.length) {\n            if (arr.apply(i)\
    \ >= arr.apply(i+1)) {\n                ans = arr.apply(i+1)\n            }\n\
    \        }\n        if (ans == -1) {\n            ans\n        } else {\n    \
    \        -1\n        }", "        // Your code here\n        if (arr.isEmpty)\
    \ -1\n        else arr.maxIndex { \n        case i if (i > 0) => arr.slice(0,\
    \ i).foldLeft(-1)(_ max _)\n        case _ => -1\n        }", "        if(arr.isEmpty)\
    \ -1\n        else {\n            val largest = arr.last\n            val index\
    \ = arr.indexWhere(elem => elem < largest)\n            if(index > -1) index else\
    \ -1\n        }", "        var max : Long = -1\n        var i : Long = 0\n   \
    \     while (i < arr.length) {\n            if (arr(i) <= arr(i-1)) max = arr(i)\n\
    \            else i += 1\n        }\n        max", "        val size = arr.size\n\
    \        var maxIdx : Long = -1\n        for ( i <- 0 until size ) {\n       \
    \     if ( arr(i) < arr(maxIdx) ) {\n                maxIdx = i\n            }\n\
    \        }\n        if ( maxIdx == -1 ) {\n            -1\n        } else {\n\
    \            maxIdx\n        }", "        var maxIndex : Long = -1\n        var\
    \ currentIndex : Long = -1\n        arr.foreach { x =>\n            currentIndex\
    \ = currentIndex + 1\n            if (x < arr(currentIndex)) {\n             \
    \   if (maxIndex < currentIndex) {\n                    maxIndex = currentIndex\n\
    \                }\n            }\n        }\n        maxIndex", "        arr.map(i\
    \ => (arr.indexOf(i)).max ) match {\n            case -1 => -1\n            case\
    \ x => x\n        }", "        var maxIndex = -1L\n        var currentMax = 0L\n\
    \        var prevMax = 0L\n        var current = 1\n        var index = 0\n  \
    \      for (elem <- arr) {\n            index += 1\n            if (elem > currentMax)\
    \ {\n                currentMax = elem\n                maxIndex = index\n   \
    \         } else if (elem == currentMax) {\n                if (elem < prevMax)\
    \ {\n                    maxIndex = index\n                }\n            }\n\
    \            current = elem\n            prevMax = currentMax\n        }\n   \
    \     if (maxIndex == -1L) return -1\n        maxIndex", '        arr.zipWithIndex.maxBy(_._1)._1',
  "        var max = -1l\n        var maxIndex = 0\n        for(index <- 0 until arr.size){\n\
    \            if( arr(index) < arr(maxIndex) ) max = arr(index)\n            if(\
    \ arr(index) == arr(maxIndex) && arr(index) < arr(index-1)) maxIndex = index\n\
    \        }\n        if(max == -1) return -1\n        else max", "        var largest\
    \ = arr.head\n        var index = arr.head\n\n        for( x <- arr.tail if x\
    \ < largest ) largest = x\n        largest", "        var max = -1l\n        for(\
    \ i <- arr.indices) {\n            if ( max < arr(i)) {\n                max =\
    \ arr(i)\n            }\n        }\n        max", "        var max = -1l\n   \
    \     var index = -1\n        arr.foreach { elem =>\n            if (elem > max)\
    \ {\n                max = elem\n                index = arr.indexOf(elem)\n \
    \           }\n        }\n        if (max == -1l) {\n            index = -1\n\
    \        }\n        index", "        var largest = -1l\n        var curIndex =\
    \ 0\n        for (i <- 0 until arr.length-1) {\n            if (arr(i) <= arr(i+1))\
    \ {\n                largest = i\n            }\n            if (largest == -1)\
    \ {\n                largest = i\n            }\n        }\n        if (largest\
    \ != -1) {\n            val newIndex: Int = arr.lastIndexWhere(x => x <= arr(largest))\n\
    \            largest = arr.apply(newIndex)\n        }\n        largest", "   \
    \     if (arr.isEmpty) -1\n        else {\n            val minIndex = (arr.indexWhere\
    \ { i => i <= arr(0) }) match {\n                case Some(i) => i\n         \
    \       case None => -1\n            }\n            val maxIndex = (arr.indexWhere\
    \ { i => i <= arr(arr.size - 1) }) match {\n                case Some(i) => i\n\
    \                case None => -1\n            }\n            if (minIndex < maxIndex)\
    \ {\n                maxIndex\n            } else {\n                -1\n    \
    \        }\n        }", "        if (arr.isEmpty) -1\n        else {\n       \
    \     var maxIndex = 0\n            var maxValue = arr(0)\n            for(i <-\
    \ 0 until arr.length)\n            {\n                if(arr(i) >= maxValue) {\n\
    \                    maxIndex = i\n                    maxValue = arr(i)\n   \
    \             }\n            }\n            maxIndex\n        }", "        //\
    \ Write your code here\n        val l = arr.head\n        var i = 0\n        while(i\
    \ < arr.length) {\n            if(arr(i) <= l) {\n                i += 1\n   \
    \         } else {\n                break\n            }\n        }\n        if(arr.length\
    \ == i) {\n            return -1\n        }\n        return i", "        var maxIndex\
    \ = 0\n        var maxValue = arr(0)\n\n        for (i <- arr.indices) {\n   \
    \         if (arr(i) > maxValue) {\n                maxValue = arr(i)\n      \
    \          maxIndex = i\n            }\n        }\n        return maxIndex"]
stop_tokens:
- "\n    }\n"
