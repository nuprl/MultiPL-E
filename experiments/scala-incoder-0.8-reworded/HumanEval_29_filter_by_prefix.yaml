name: HumanEval_29_filter_by_prefix
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Filter an input list of strings only for ones that start with a given prefix.\n\
  \    // >>> filterByPrefix((List[String]()), (\"a\"))\n    // (List[String]())\n\
  \    // >>> filterByPrefix((List[String](\"abc\", \"bcd\", \"cde\", \"array\")),\
  \ (\"a\"))\n    // (List[String](\"abc\", \"array\"))\n    def filterByPrefix(strings\
  \ : List[String], prefix : String) : List[String] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(filterByPrefix((List[String]()),\
  \ (\"john\")).equals((List[String]())));\n    assert(filterByPrefix((List[String](\"\
  xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\")), (\"xxx\")).equals((List[String](\"\
  xxx\", \"xxxAAA\", \"xxx\"))));\n    }\n\n}\n"
completions: ['        return strings.filter(str => str.startsWith(prefix))', "  \
    \      val prefixedStrings = strings.map { s => if (s.startsWith(prefix)) s else\
    \ s\"$prefix$s\" }\n        strings.length != prefixedStrings.length ||\n    \
    \        prefixedStrings.distinct", '        strings.get(prefix :: Nil)', "  \
    \      var newList = strings;\n        for(i <- 0 until newList.size) {\n    \
    \        if(newList(i).startsWith(prefix)) {\n                newList = newList.filter(_\
    \ != newList(i))\n            }\n        }\n        newList", "      require(strings.nonEmpty)\n\
    \      require(prefix.nonEmpty)\n      strings.filter(s => s.startsWith(prefix))",
  '        strings.filter( s => s.startsWith(prefix) )', '        strings.filter(s
    => s.startsWith(prefix))', "        // filter the strings\n        strings.filter(s\
    \ => s.startsWith(prefix))", "        strings.flatMap { string =>\n          \
    \  if (string.startsWith(prefix)) List(string)\n            else List()\n    \
    \    }", '        strings: List[String].filter(s => s.startsWith(prefix))', '        strings
    .filter(s => s.startsWith(prefix))', '        strings.filter(_ startsWith prefix)',
  '        strings.filter(_ startsWith prefix)', "        if (strings.length == 0)\
    \ {\n            strings\n        } else {\n            strings.filter(x => x.startsWith(prefix))\n\
    \        }", "        var result = ListBuffer.empty[String]\n        strings.foreach(s\
    \ => if(s.startsWith(prefix)) result :+= s)\n        result.toList", "       \
    \ val result = new mutable.ListBuffer[String]()\n        for (x <- strings) {\n\
    \            if (x.startsWith(prefix)) {\n                result += x\n      \
    \      }\n        }\n        return result.toList", "        val prefixWithIndex\
    \ = strings.map(s => s + prefix).zipWithIndex\n        val prefixIndex = strings.zipWithIndex.filter(p\
    \ => p._1.startsWith(prefix))\n        val prefixWithIndexForPrefix = prefixIndex.map(p\
    \ => p._2)\n        val filtered = prefixWithIndexForPrefix.zip(prefixWithIndexForPrefix.tail).filter(x\
    \ => x._2._1.startsWith(prefix))\n        filtered.map(_._1).reverse", "     \
    \   if (prefix != \"\") strings.filter(_ startsWith prefix)\n        else strings",
  '        strings.filterNot(_ == prefix)', "        if (prefix != null && strings\
    \ == null) {\n            return Nil\n        }\n        strings.filter { s =>\
    \ s.startsWith(prefix) }", '        strings.filter(_.startsWith(prefix))', " \
    \       // Filter an input list of strings only for ones that start with a given\
    \ prefix.\n        strings.filter(_ startsWith prefix)", '        strings.filter(s
    => s.startsWith(prefix))', '        stringList.filter(s => s.startsWith(prefix))',
  "        if (strings == Nil) return Nil\n        if (strings.length <= 1) return\
    \ strings\n        if (prefix.length != strings(0).length) return strings\n  \
    \      \n        strings.filter { x => x.startsWith(prefix) }", '        strings.filter(_
    startsWith(prefix))', "        strings.length match {\n            case 0 => strings\n\
    \            case 1 => if (strings(0).startsWith(prefix)) {strings}\n        \
    \    else {strings(0)}\n            case _ => strings.filter(str => str.startsWith(prefix))\n\
    \        }", '        stringList.filter(_.startsWith(prefix)).map(_.toUpperCase)',
  "        if (prefix == \"\") {\n            strings\n        } else {\n        \
    \    strings.filter{ str =>\n                str.startsWith(prefix)\n        \
    \    }\n        }", "        def hasPrefix(s : String) : Boolean = s.startsWith(prefix)\n\
    \n        def findPrefix(s : String) : List[String] = if (hasPrefix(s))\n    \
    \            s.drop(prefix.length)\n            else\n                s\n    \
    \    stringList.filter { s => findPrefix(s) }", '        strings: List[String].filter(
    x => x.startsWith(prefix))', '        strings if strings.head == prefix else strings',
  "        var result = new ListBuffer[String]\n        for(s <- strings) if(s.startsWith(prefix))\
    \ result += s\n        result.toList", '        strings.filter(elem => elem.startsWith(prefix))',
  '        strings.filter(str => str.startsWith(prefix))', '        strings.filter(s
    => s.startsWith(prefix))', "        var strings = strings\n        var prefix2\
    \ = prefix\n        // Remove the prefix from the list of strings\n        prefix2\
    \ =\n            if (prefix.length == 0) prefix\n            else {\n        \
    \        if (prefix2.length == 0) \"\"\n                else if (prefix2.charAt(0)\
    \ == prefix) prefix2.substring(1)\n                else \"\"\n            }\n\
    \        var filtered = List[String]()\n        for (string <- strings) {\n  \
    \          var string2 = string\n            var prefix3 = prefix2\n         \
    \   prefix3 =\n                if (prefix3.length == 0) \"\"\n               \
    \ else if (prefix3.charAt(prefix3.length-1) == prefix) prefix3.substring(0, prefix3.length-1)\n\
    \                else \"\"\n            if (prefix3.equals(prefix2)) {\n     \
    \           filtered = filtered :+ string\n            }\n        }\n        return\
    \ filtered", '        strings.filter(s => s.startsWith(prefix))', '        strings.filter{
    s => s.startsWith(prefix) }', "        var filteredStrings = strings\n       \
    \ var prefixIndex = strings.lastIndexOf(prefix);\n        while(prefixIndex >\
    \ -1) {\n            filteredStrings = filteredStrings.dropRight(1)\n        \
    \    prefixIndex = strings.lastIndexOf(prefix, prefixIndex + 1);\n        }\n\
    \        filteredStrings", "        string\n            ::\n            strings.filter{\
    \ s => s.startsWith(prefix) }", '        strings.filter(s => s.startsWith(prefix))',
  "        // Iterate through the strings and append the ones that match the\n   \
    \     // prefix to the result.\n        strings.filter(s => s.startsWith(prefix))",
  '        strings: List[String].filter( s => s.startsWith(prefix))', "        strings\
    \ match {\n            case Nil => Nil\n            case a :: rest => a startsWith\
    \ prefix match {\n                case true => filterByPrefix(rest, prefix)\n\
    \                case false => a::Nil\n            }\n        }", "        //\
    \ Complete the body of the function\n        var filteredList = List[String]()\n\
    \        var index = 0\n        for (string <- strings) {\n            if (string.startsWith(prefix))\
    \ {\n                filteredList ::= string\n                index += 1\n   \
    \         }\n        }\n        if (index < filteredList.length) {\n         \
    \   filterByPrefix(filteredList, prefix)\n        } else {\n            filteredList\n\
    \        }", '        strings.filter(s => s.startsWith(prefix))', "        def\
    \ helper(current : List[String], prefix : String) : List[String] = {\n       \
    \     current match {\n                case Nil => Nil\n                case xs\
    \ => xs match {\n                    case \"a\" :: rest => helper(rest, prefix)\n\
    \                    case \"b\" :: rest => helper(rest, prefix)\n            \
    \        case \"c\" :: rest => helper(rest, prefix)\n                    case\
    \ \"d\" :: rest => helper(rest, prefix)\n                    case \"e\" :: rest\
    \ => helper(rest, prefix)\n                    case \"f\" :: rest => helper(rest,\
    \ prefix)\n                    case \"g\" :: rest => helper(rest, prefix)\n  \
    \                  case \"h\" :: rest => helper(rest, prefix)\n              \
    \      case \"i\" :: rest => helper(rest, prefix)\n                    case \"\
    j\" :: rest => helper(rest, prefix)\n                    case \"k\" :: rest =>\
    \ helper(rest, prefix)\n                    case \"l\" :: rest => helper(rest,\
    \ prefix)\n                    case \"m\" :: rest => helper(rest, prefix)\n  \
    \                  case \"n\" :: rest => helper(rest, prefix)\n              \
    \      case \"o\" :: rest => helper(rest, prefix)\n                    case \"\
    p\" :: rest => helper(rest, prefix)\n                    case \"q\" :: rest =>\
    \ helper(rest, prefix)\n                    case \"r\" :: rest => helper(rest,\
    \ prefix)\n                    case \"s\" :: rest => helper(rest, prefix)\n  \
    \                  case \"t\" :: rest => helper(rest, prefix)\n              \
    \      case \"u\" :: rest => helper(rest, prefix)\n                    case \"\
    v\" :: rest => helper(rest, prefix)\n                    case \"w\" :: rest =>\
    \ helper(rest, prefix)\n                    case \"x\" :: rest => helper(rest,\
    \ prefix)\n                    case \"y\" :: rest => helper(rest, prefix)\n  \
    \                  case \"z\" :: rest => helper(rest, prefix)\n              \
    \      case \"\" :: rest => helper(rest, prefix)\n                    case _ =>\
    \ Nil\n                }\n            }\n        }\n        return helper(strings,\
    \ prefix)", '        strings.filterNot(s => s.startsWith(prefix))', '        strings.filter(_.startsWith(prefix))',
  '        strings.filterNot(s => s.startsWith(prefix))', "        strings.length\
    \ == 0 || strings(0).startsWith(prefix) match {\n            case true => strings\n\
    \            case false => strings.tail\n        }", "        strings.collect\
    \ {\n            case str if (str.startsWith(prefix)) => str\n        }", '       strings.filter(s
    => s.startsWith(prefix))', '        strings.filter(_ startsWith prefix)', "  \
    \      var result: List[String] = Nil\n        // For every string in the list\
    \ check if it starts with the prefix.\n        for (string <- strings) {\n   \
    \         if(string.startsWith(prefix)) {\n                // If the string starts\
    \ with the prefix, add it to the result list.\n                result = string\
    \ :: result\n            }\n        }\n        return result", '        strings
    filter { s => s.startsWith(prefix) }', "        var prefixed = strings;\n    \
    \    for ( i <- prefixed.length; prefixed(i) != prefix) {\n            prefixed\
    \ = prefixed.take(i-1)\n        }\n        return prefixed;", '        strings.filter(s
    => s.startsWith(prefix))', '        strings.filter(s => s.startsWith(prefix))',
  "        // Use an immutable HashSet, which will allow for O(1) contains.\n    \
    \    var ret = new mutable.HashSet[String]()\n        var i = 0\n        // If\
    \ we're at the end of our input list, we're done.\n        while(i < strings.length)\
    \ {\n            if(strings.lift(i).startsWith(prefix)) {\n                ret.add(strings.lift(i))\n\
    \            }\n            i += 1\n        }\n        ret.toList", '        strings.filter(x
    => x.startsWith(prefix))', "        strings: List[String] match {\n          \
    \  case head :: tail if (head.startsWith(prefix)) => head :: filterByPrefix(tail,\
    \ prefix)\n            case _ => strings\n        }", "        if (strings ==\
    \ null || strings.length == 0 || prefix == null || prefix.length == 0) {\n   \
    \         return Nil\n        }\n\n        val startsWith = strings.headOption.filter(_.startsWith(prefix))\n\
    \        val prefixSize = prefix.length\n\n        // Find the starting position\
    \ of each of the matching strings. \n        var start = startsWith.indexWhere(_.startsWith(prefix))\n\
    \        val result = startsWith.takeWhile(_ => start != startsWith.length)\n\n\
    \        // If no matching prefix was found, then the entire input list is returned.\n\
    \        if (start == startsWith.length) {\n            strings; \n        } else\
    \ {\n            result.map { s =>\n                val rest = strings.drop(start)\n\
    \                if (rest.lastOption.exists(_.startsWith(prefix))) {\n       \
    \             s; \n                } else {\n                    s\"$prefix $s\"\
    \n                }\n            }\n        }", "        // Write your solution\
    \ here\n        if (strings == null || prefix == null) {\n            List[String]()\n\
    \        } else if (strings == null || prefix == null) {\n            List[String]()\n\
    \        } else if (strings.isEmpty) {\n            List[String]()\n        }\
    \ else if (prefix.isEmpty) {\n            strings\n        } else {\n        \
    \    strings.filter(prefix contains _)\n        }", '        strings.filter(s
    => s.startsWith(prefix))', '      strings.filter(x => x.startsWith(prefix))',
  "        // Use a mutable.HashMap to keep track of already seen prefixes.\n    \
    \    val prefixes = mutable.HashMap[String, List[String]]()\n        // The results\
    \ are accumulated in the `result` list.\n        val result: List[String] = Nil\n\
    \        strings.foreach(x => {\n            if(x.startsWith(prefix)){\n     \
    \           if(prefixes.contains(prefix)){\n                    // The key was\
    \ already seen, append the existing list to the new list.\n                  \
    \  result += prefixes.get(prefix).asInstanceOf[List[String]]\n               \
    \ }\n                // The key was not seen before, create a new list with the\
    \ current value.\n                result += Nil\n                // Store the\
    \ value in the map.\n                prefixes += prefix -> Nil\n            }\
    \ else {\n                // The key is not prefixed with the prefix, so append\
    \ the current value to the\n                // existing list that corresponds\
    \ to the key.\n                result += prefixes.get(prefix).asInstanceOf[List[String]]\n\
    \                // Store the value in the map.\n                prefixes += prefix\
    \ -> Nil\n            }\n        })\n        return result", '        strings
    filter (_.startsWith(prefix))', "        strings = strings.filter((string) =>\
    \ string.startsWith(prefix))\n        strings", "        if (strings.length ==\
    \ 0) strings::Nil\n        else strings.takeWhile((string : String) => string.startsWith(prefix))::filterByPrefix(strings.dropWhile((string\
    \ : String) => string.startsWith(prefix)), prefix)", '        strings.filter{
    s => s.startsWith(prefix) }', '        strings (_ startsWith prefix)', '        strings.filter(x=>x.startsWith(prefix))',
  "        val newStrings = mutable.ArrayBuffer.empty[String]\n        strings forEach\
    \ {s =>\n            if(s.startsWith(prefix)) {\n                newStrings +=\
    \ s\n            }\n        }\n        newStrings.toList", '        return strings.filter(_
    startsWith prefix)', '        stringList.filter(string=>string.startsWith(prefix))',
  '        strings.filter(_ startsWith(prefix))', '        strings: List[String].filter(_.startsWith(prefix))',
  '        (strings filter (x => x.startsWith(prefix)) toList) ', '        strings.filter(s
    => s.startsWith(prefix))', '        strings.filter( _.startsWith(prefix))', " \
    \       def match(strings : List[String], prefix : String) : List[String] = {\n\
    \            strings in prefix match {\n                case true => strings\n\
    \                case _ => strings.filter(s => s.startsWith(prefix))\n       \
    \     }\n        }\n        match(strings, prefix)", "        strings = strings.filter(s\
    \ => s.startsWith(prefix))\n        if (strings.isEmpty) strings else strings.head",
  '        strings.filter (s => s.startsWith(prefix))', "        // Create a mutable\
    \ list of strings\n        val stringList = new mutable.MutableList[String](strings)\n\
    \        // Filter the strings by removing the ones that don't start with the\
    \ prefix\n        val result = stringList.filter(s => s.startsWith(prefix))\n\
    \        // Return the list of strings\n        result", "        var stringsToKeep\
    \ = mutable.ListBuffer.empty[String]\n        strings.foreach(s => {\n       \
    \     if (s.startsWith(prefix)) {\n                stringsToKeep += s\n      \
    \      }\n        })\n        stringsToKeep.toList", "        // This code will\
    \ filter the input list based on the prefix.\n        // We need to store the\
    \ results of this filter in a list.\n        // A list is initialized using the\
    \ `new List` function.\n        // >>> val result = new ListBuffer[String]()\n\
    \        // >>> val prefix = \"a\"\n        // >>> filterByPrefix((List[String](\"\
    abc\", \"bcd\", \"cde\", \"array\")), prefix)\n        // (List[String](\"abc\"\
    , \"array\"))\n        strings.filter(x => x.startsWith(prefix))", "        if\
    \ (strings.length == 0) strings\n        else if (strings.length == 1) strings\
    \ else strings.head :: filterByPrefix(strings.tail, prefix)", '        string',
  "        var result: List[String] = Nil\n        for ( x <- strings ) if ( x.startsWith(prefix)\
    \ ) result :+= x\n        result", "        val prefix = prefix.toLowerCase\n\
    \        strings = strings.filter(s => s.startsWith(prefix))\n        return strings",
  "        // Your code here\n        return strings", "        val newStrings: List[String]\
    \ = strings.filterNot(_.startsWith(prefix))\n        newStrings", "        val\
    \ prefixes = strings.map(_.charAt(0).toInt)\n        strings.filter(s => prefixes.contains(s.charAt(0).toInt))",
  "        val prefixes = mutable.HashSet[String]()\n        for (str <- strings)\
    \ {\n            if (prefixes.contains(str.substring(0,prefix.length))) {\n  \
    \              prefixes += str.substring(0,prefix.length).toCharArray\n      \
    \      }\n        }\n        for (str <- strings) {\n            if (prefixes.contains(str.substring(0,prefix.length)))\
    \ {\n                yield str\n            }\n        }", "        // O(n log\
    \ n)\n        // Filter the list by iterating once over the list for each prefix\n\
    \        // O(n^2)\n        // List is first sorted before filtering\n       \
    \ // O(n log n)\n        strings = strings.sortBy(s => s.indexOfPrefix(prefix))\n\
    \        // O(n)\n        var result = List[String]()\n        for (str <- strings)\
    \ {\n            if (str.startsWith(prefix))\n                result ::: str\n\
    \        }\n        result", "        if (strings.length == 0)\n            strings\n\
    \        else if (strings.head.startsWith(prefix))\n            strings\n    \
    \    else\n            strings.filter(_ => _.startsWith(prefix))", "        var\
    \ matchedStrings = List.empty[String]\n        for ( i <- strings.indices)\n \
    \           if ( strings(i).startsWith(prefix) )\n                matchedStrings\
    \ = matchedStrings :+ strings(i)\n        return matchedStrings", "        if\
    \ (strings == null || strings.isEmpty)\n            return strings\n        if\
    \ (prefix.length > strings.get(0).length)\n            return strings\n\n    \
    \    strings.filter(s => s.startsWith(prefix))", '       strings.filter(s => s.startsWith(prefix))',
  "        // Only keep strings that start with prefix\n        def keepString(str\
    \ : String) : Boolean = str.startsWith(prefix)\n        // Filter only valid strings\n\
    \        def keepStrings(strs : List[String]) : List[String] = strs.filter(keepString)\n\
    \        // Filter valid strings from input list\n        def filterByPrefix(strings\
    \ : List[String], prefix : String) : List[String] = strings.filter(keepStrings)\n\
    \        filterByPrefix(strings, prefix)", "        (strings) match {\n      \
    \      case Nil => Nil\n            case head :: tail => if (head.startsWith(prefix))\
    \ head :: filterByPrefix(tail, prefix)\n            else filterByPrefix(tail,\
    \ prefix)\n        }", "        var result: List[String] = List()\n        strings.foreach(string\
    \ => {\n            if(string.startsWith(prefix)) {\n                result =\
    \ result :+ string\n            }\n        })\n        result", "        var filteredStrings\
    \ = strings\n        var filteredPrefix = prefix\n        var filteredStringsIndex\
    \ = 0\n        var filteredPrefixIndex = 0\n        while (filteredStringsIndex\
    \ < filteredStrings.length) {\n            if (filteredStrings(filteredStringsIndex).startsWith(filteredPrefix))\
    \ {\n                filteredStringsIndex += 1\n            } else {\n       \
    \         filteredStringsIndex += 1\n                filteredPrefixIndex += 1\n\
    \            }\n        }\n        filteredStrings", '        strings.filter(x
    => x.startsWith(prefix))', '        strings.filter(_.startsWith(prefix))', '        string',
  "        if (strings.isEmpty)\n            return strings\n        if (strings.head\
    \ != prefix)\n            return strings\n        else\n            return filterByPrefix(strings.tail,\
    \ prefix)", "        strings: List[String] match {\n            case Nil => Nil\n\
    \            case _ => {\n                var filteredStrings = List[String]()\n\
    \                strings.foreach(s => {\n                    if (s.startsWith(prefix))\
    \ {\n                        filteredStrings += s\n                    }\n   \
    \             })\n                filteredStrings\n            }\n        }",
  "        // Solution 1: use a filter with a regex to exclude prefix strings\n  \
    \      strings.filterNot(s => s.startsWith(prefix))\n        // Solution 2: use\
    \ a filter with a regex\n        //strings.filterNot(s => s.matches(prefix + \"\
    $\"))", "        if(strings.isEmpty) {\n            strings\n        }\n     \
    \   else {\n            strings.filter(_ startsWith prefix)\n        }", "   \
    \     def prefixMatcher(prefix : String) : String => Boolean = {\n           \
    \ (str : String) => str.startsWith(prefix)\n        }\n        strings.filterNot(prefixMatcher(prefix))",
  "        var result = strings;\n        result.foreach { s =>\n            if (s.startsWith(prefix))\
    \ {\n                result = result filter { x => x != s }\n            }\n \
    \       }\n        result", "        strings: List[String] match {\n         \
    \   case Nil => Nil\n            case _ => strings.filter(_ startsWith prefix)\n\
    \        }", '        strings.filter((s => s.startsWith(prefix)))', "        var\
    \ result = strings\n        for (string <- strings) {\n            if (string.startsWith(prefix))\
    \ {\n                result = result :: strings.filter(x => x != string)\n   \
    \         }\n        }\n        result", '        strings.filter(s => s.startsWith(prefix))',
  "        val result = stringListBuffer[String]()\n        for(elem <- strings) {\n\
    \            if(!elem.startsWith(prefix)) {\n                result += elem\n\
    \            }\n        }\n        result.toList", '        strings.filter(s =>
    s.startsWith(prefix))', "        strings.length <= 0 || strings.head != prefix\n\
    \            ? Nil\n            : strings.tail.takeWhile(_.startsWith(prefix)).toList",
  "        // Filter the input list of strings only for ones that start with a given\
    \ prefix.\n        strings.filter(_.startsWith(prefix))", "        // The 'prefix'\
    \ argument can be omitted in the call to the function 'filter'.\n        if (prefix\
    \ == \"\") {\n          strings\n        } else {\n            strings.filter(s\
    \ => s.startsWith(prefix))\n        }", "        strings.filter{\n           \
    \ string: String => {\n                if (string.startsWith(prefix)) {\n    \
    \                true\n                } else {\n                    false\n \
    \               }\n            }\n        }", "        strings.filter { s => \n\
    \            s.startsWith(prefix) \n        }", "        strings = strings filter\
    \ (s => s.startsWith(prefix))\n        strings", "        strings.length > 0 match\
    \ {\n            case true => {\n                prefix match {\n            \
    \        case _ if prefix.length == 1 => {\n                        strings.filter(_.startsWith(prefix))\n\
    \                    }\n                    case _ => {\n                    \
    \    val prefix1 = prefix.substring(0, prefix.length - 1)\n                  \
    \      strings.filter(_.startsWith(prefix1))\n                    }\n        \
    \        }\n            }\n            case false => strings\n        }", '        strings.filter(_
    startsWith prefix)', '        strings.filter { s => s.startsWith(prefix) }', " \
    \       if (strings.isEmpty) return strings\n        strings.find(s => s.startsWith(prefix))",
  '        stringList.filter(s => s.startsWith(prefix))', '        strings.filter(
    _.startsWith(prefix) )', '        strings: List[String].filter {_.startsWith(prefix)}',
  '        stringList.filter(_.startsWith(prefix))', "        val filtered = strings.filter(_.startsWith(prefix))\n\
    \        strings.filterNot(_.startsWith(prefix))", "        var returnList: List[String]\
    \ = List()\n        for (x <- strings) {\n            val prefix = x.substring(0,prefix.length)\n\
    \            if (prefix == prefix) {\n                returnList ::= x\n     \
    \       }\n        }\n        returnList", "        strings = strings.filter((string\
    \ : String) => {\n            (string.length >= prefix.length) && (string.substring(0,\
    \ prefix.length) == prefix)\n        })\n        strings", "        if (strings\
    \ == null || prefix.length == 0) {\n            strings\n        } else {\n  \
    \          strings.filter(_.startsWith(prefix))\n        }", "        if(strings.length\
    \ == 0) strings\n        else if(strings(0) != prefix) strings\n        else {\n\
    \            val stringList = new mutable.ArrayBuffer[String]()\n            stringList+=strings\n\
    \            val prefixList = new mutable.ArrayBuffer[String]()\n            prefixList+=prefix\n\
    \            for(i <-stringList.length-1 to 0 by -1){\n                if(stringList(i).substring(0,\
    \ prefix.length) == prefix){\n                    stringList.remove(i)\n     \
    \               prefixList.remove(i)\n                }\n            }\n     \
    \       stringList.toList\n        }", "        var result : List[String] = List[String]()\n\
    \        strings.foreach { s => if (s.startsWith(prefix)) result += s }\n    \
    \    result", "        if (strings.isEmpty) {\n            strings.headOption\n\
    \        } else {\n            val prefix = prefix.toLowerCase\n            strings.filter{\
    \ s =>\n                s.startsWith(prefix)\n            }\n        }", "   \
    \     if (strings.length == 0) strings\n        else if (strings(0) == prefix)\
    \ strings.drop(1)\n        else filterByPrefix(strings.dropRight(1), prefix)",
  '        strings.filter(_ startsWith prefix)', "        strings: List[String] match\
    \ {\n            case Nil => Nil\n            case x :: Nil =>\n             \
    \   x startsWith prefix match {\n                    case true => Nil\n      \
    \              case _ => x :: Nil\n                }\n            case x :: y\
    \ =>\n                x startsWith prefix match {\n                    case true\
    \ => y filter (s => s startsWith prefix)\n                    case _ => y filter\
    \ (s => s startsWith prefix) :: x\n                }\n        }", '        stringList.filter(s
    => s.startsWith(prefix))', "        val prefixedList = strings.map(s => (s.startsWith(prefix)))\
    \ \n        val uniques = prefixedList.map(a => a.toSet).distinct\n        return\
    \ uniques.toList", '        strings.filter( s => s.startsWith(prefix) )', "  \
    \      var newStrings = mutable.MutableList[String]()\n        for (string <-\
    \ strings) {\n            if (string.startsWith(prefix)) {\n                newStrings\
    \ += string\n            }\n        }\n        newStrings.toList", "        if(strings.isEmpty)\
    \ {\n            return strings\n        }\n        if(strings.head == prefix)\
    \ {\n            strings.head :: filterByPrefix(strings.tail, prefix)\n      \
    \  }\n        else {\n            filterByPrefix(strings.tail, prefix)\n     \
    \   }", "        stringList.filter {\n            strings.contains(_)\n      \
    \  }", '        stringList.filter(_.startsWith(prefix)).filter(s => s !="").mkString',
  "        strings.filter {\n            _.startsWith(prefix)\n        }", "     \
    \   var filtered = new mutable.ListBuffer[String]()\n        for (i<- 0 to strings.length\
    \ - 1) {\n            if (strings(i).startsWith(prefix))\n                filtered\
    \ += strings(i)\n        }\n        filtered.toList", "        strings.collect\
    \ {\n            case s if (s.startsWith(prefix)) => s\n        }", "        strings\
    \ = strings filter { s => s.startsWith(prefix) }\n        strings", '        stringList.filter(x
    => x.startsWith(prefix))', "        var filtered: List[String] = Nil\n       \
    \ for (str <- strings) {\n            if (str.startsWith(prefix)) {\n        \
    \        filtered = filtered :+ str\n            }\n        }\n        return\
    \ filtered", '        strings.filter( string => string.startsWith(prefix) )',
  "        // For each string in the list, take every substring that starts with prefix,\n\
    \        // and put them in a new list, called 'result'.\n        var result =\
    \ List[String]()\n        strings.foreach(str => \n            // Add the first\
    \ part of the string to the list\n            if(str.startsWith(prefix)) { result\
    \ += str }\n            // For each substring after the first, check if it starts\
    \ with prefix\n            else {\n                var prefix = str.substring(0,prefix.length).toLowerCase\n\
    \                // If it does, add it to the result list\n                if(str.substring(prefix.length,str.length).startsWith(prefix))\
    \ { result += str }\n            }\n        )\n        result", "        if (strings.length\
    \ <= 0) return strings\n        if (strings(0) != prefix) return strings\n   \
    \     val result : List[String] = strings(1).toList.filterNot(strings.contains(_))\n\
    \        filterByPrefix(result,prefix)", "        strings(0) must startsWith prefix\n\
    \        strings(strings.size-1) must endsWith prefix\n        strings.slice(1,strings.size-1)",
  '        stringList.filter(stringList.headOption.startsWith(prefix))', "       \
    \ def check(i: Int, prefixedStrings : List[String], strings : List[String]) :\
    \ List[String] = {\n            if (i >= strings.length)\n                return\
    \ prefixedStrings\n            val string = strings(i)\n            if (string.startsWith(prefix))\n\
    \                check(i+1, prefixedStrings :+ string, strings)\n            else\n\
    \                check(i+1, prefixedStrings, strings)\n        }\n        check(0,Nil,strings)",
  "        // Create a list to hold the filtered results.\n        val filteredResults\
    \ = ListBuffer[String]()\n\n        // Iterate over all strings and add them to\
    \ the result list if they start with prefix.\n        strings.foreach(x => {\n\
    \            if (x.startsWith(prefix)) {\n                filteredResults += x\n\
    \            }\n        })\n\n        // Return the filtered result list.\n  \
    \      filteredResults.toList", '        stringList.filter(s => s.startsWith(prefix))',
  "        val newStrings = strings.filter (_ .startsWith (prefix))\n        newStrings",
  "        strings: for (s <- strings) yield {\n            val prefixAndRest = prefix\
    \ +: s\n            if ((prefixAndRest.length == prefix) && (prefixAndRest.head\
    \ == prefix))\n                s\n        }", "        if (strings.length == 0)\n\
    \            return strings\n        if (strings.length == 1)\n            return\
    \ strings\n        var result: List[String] = Nil\n        val currentPrefix:\
    \ String = strings.head\n        if (currentPrefix.length == prefix.length)\n\
    \            result = strings.filter(s => s.startsWith(prefix))\n        else\n\
    \            result = strings.filter(s => s.startsWith(prefix))\n        filterByPrefix(result,\
    \ prefix)", '        strings.toSet filter (x => x.startsWith(prefix)).toList',
  "        strings = strings.filter(s => s.startsWith(prefix))\n        strings.length\
    \ == 0 ?\n            strings\n            : strings", '        strings.filter
    { i => i.startsWith(prefix) }', "        var newStrings = strings\n        var\
    \ newPrefix = prefix\n        // Loop and remove matching prefix\n        while\
    \ (newPrefix == newStrings.head) {\n            newStrings = newStrings.tail\n\
    \        }\n        // Return filtered list\n        newStrings", '        stringFilter
    { s => s.startsWith(prefix) }', '        stringList.flatMap( _.startsWith(prefix)
    ).filter(!_.isEmpty)', "      var ret: List[String] = Nil\n      for ((s, i) <-\
    \ strings.zipWithIndex if s.startsWith(prefix)) {\n        ret = s :: ret\n  \
    \    }\n      ret", "        if(strings.isEmpty) {\n            return strings\n\
    \        }\n        if(strings.head == prefix) {\n            filterByPrefix(strings.tail,\
    \ prefix)\n        }\n        else {\n            strings\n        }", "     \
    \   // Filter out all strings that don't start with the prefix.\n        strings.filter(string\
    \ => string.startsWith(prefix))", "        // For every string in the list, if\
    \ its prefix matches with our prefix parameter,\n        // add it to the output\
    \ list.\n        strings.filter(x => x.startsWith(prefix))", "        val prefixes\
    \ = mutable.Set[String]()\n        strings.foreach(s => prefixes += s.prefix(prefix))\n\
    \        strings.filter(s => prefixes contains s.prefix(prefix))", "        if\
    \ (strings == Nil)\n            return Nil\n        else if (strings.isEmpty)\n\
    \            return strings\n        else {\n            var result: List[String]\
    \ = Nil\n            strings.head :: filterByPrefix(strings.tail, prefix)\n  \
    \      }", "        strings.filter {\n            str =>\n                if (str.startsWith(prefix))\n\
    \                    str\n        }", '        // Your code goes here.', '        strings.filter(_.startsWith(prefix))',
  "        // filter function\n        def filterFunction(element : String) : Boolean\
    \ = {\n            // return true if the element's prefix matches the prefix\n\
    \            // of the prefix list passed to the filterByPrefix function\n   \
    \         element.startsWith(prefix)\n        }\n        // filter the strings\
    \ and keep only the elements that pass the filter\n        // function\n     \
    \   strings.filter(filterFunction)", '        strings.filter((s: String) => s.startsWith(prefix))',
  "        strings.length <= 0 || strings(0) startsWith prefix\n            ? strings\n\
    \            : filterByPrefix(strings.tail, prefix)", '        strings.filter(_(0)
    startsWith prefix)', '        string', "        var result = new ListBuffer[String]()\n\
    \        for ( x <- strings ) {\n            if ( x.startsWith(prefix) ) {\n \
    \               result += x\n            }\n        }\n        return result.toList",
  '        strings.get.filter(_ startsWith prefix)', '        strings.filter(s =>
    s.startsWith(prefix))', '        strings.filter(_.startsWith(prefix))', "    \
    \    val result: mutable.Buffer[String] = mutable.Buffer[String]()\n        for\
    \ (string <- strings) {\n            if (string.startsWith(prefix)) {\n      \
    \          result += string\n            }\n        }\n        result.toList",
  "        // Write your code here.\n        var stringFilters = strings.filter(_\
    \ => _.startsWith(prefix))\n        val filtered = mutable.Set.empty[String]\n\
    \        for (item <- stringFilters)\n            filtered += item\n        return\
    \ filtered.toList", '        strings.flatMap(s => if(s.startsWith(prefix)) Some(s)
    else None)', '        string', "        var result : List[String] = Nil\n    \
    \    var index = 0\n        while (index < strings.size) {\n            if (strings.apply(index).startsWith(prefix))\
    \ {\n                result = result ::: List(strings.apply(index))\n        \
    \    }\n            index = index + 1\n        }\n        result", "        var\
    \ result = strings\n        var prefixes = Set[String]()\n        prefixes +=\
    \ prefix\n        var filtered = result.filter(_.startsWith(prefix))\n       \
    \ var remainingPrefixes = prefixes.toList\n        while (filtered.nonEmpty &&\
    \ remainingPrefixes.nonEmpty) {\n            filtered = filtered.filter(_ => !remainingPrefixes.contains(_.substring(1)))\n\
    \            remainingPrefixes = remainingPrefixes.filter(_ => !prefixes.contains(_.substring(1)))\n\
    \        }\n        return filtered", "        // use contains to check whether\
    \ a String starts with a given prefix\n        // contains in scala is a method\
    \ on String and checks whether a given string starts with a given prefix\n   \
    \     if(strings.exists(s => s.startsWith(prefix))){\n            return strings\
    \ // return a list of strings starts with given prefix\n        }else{\n     \
    \       return Nil\n        }", "        strings = strings match {\n         \
    \   case Nil => Nil\n            case h::t if h.startsWith(prefix) => h::t\n \
    \           case _ => strings\n        }"]
stop_tokens:
- "\n    }\n"
