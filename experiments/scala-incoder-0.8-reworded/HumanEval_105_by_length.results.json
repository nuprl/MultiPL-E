{
  "language": "scala",
  "name": "HumanEval_105_by_length",
  "results": [
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        val result = new mutable.MutableList[String]()\n        val len = arr.length\n        val nums = arr.toList\n        var index = 0\n\n        while (index != len) {\n            val low = nums(index)\n            val high = nums(index + 1)\n            if (low < 10 && high >= 10) {\n                result.add(\"One\")\n            } else if (low < 100 && high >= 100) {\n                result.add(\"Two\")\n            } else if (low < 1000 && high >= 1000) {\n                result.add(\"Three\")\n            } else if (low < 10000 && high >= 10000) {\n                result.add(\"Four\")\n            } else if (low < 100000 && high >= 100000) {\n                result.add(\"Five\")\n            } else if (low < 1000000 && high >= 1000000) {\n                result.add(\"Six\")\n            } else if (low < 10000000 && high >= 10000000) {\n                result.add(\"Seven\")\n            } else if (low < 100000000 && high >= 100000000) {\n                result.add(\"Eight\")\n            } else if (low < 1000000000 && high >= 1000000000) {\n                result.add(\"Nine\")\n            }\n            index += 1\n        }\n        if (result.isEmpty) {\n            result.add(\"One\")\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpunb8sgav.scala:17:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = \u001b[33mnew\u001b[0m mutable.MutableList[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010420
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        val n = arr.size\n        if (n != 0)\n            arr.flatMap { i =>\n                if (i >= 1 && i <= 9) {\n                    val s = 10 - i\n                    arr(n - s)\n                } else {\n                    Array.fill(9)(0)\n                }\n            }.map { i =>\n                if (i <= 9) {\n                    val v = (1 to 9).map(i => (1 to 9).map(j => 0).mkString(\"\") +\n                        (i.toString + \" \" + Integer.toHexString(i).padTo(2, \"0\") + \"-\" + Integer.toHexString(j).padTo(2, \"0\")))\n                    v(0)\n                } else \"Nine\"\n            }.flatten.distinct\n        else List()\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp42q23axh.scala:22:24 --------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m                    arr(n - s)\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        Found:    Long\n\u001b[31m   |\u001b[0m                        Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp42q23axh.scala:29:109 -----------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m                        (i.toString + \u001b[31m\" \"\u001b[0m + Integer.toHexString(i).padTo(\u001b[31m2\u001b[0m, \u001b[31m\"0\"\u001b[0m) + \u001b[31m\"-\"\u001b[0m + Integer.toHexString(j).padTo(\u001b[31m2\u001b[0m, \u001b[31m\"0\"\u001b[0m)))\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                                             ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                            Not found: j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660010424
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        var result: List[String] = List()\n        val ones = arr.filter(x => x >= 1).toList\n        val tens = arr.filter(x => x >= 10).toList\n        val teens = arr.filter(x => x >= 100).toList\n        var sum = 0\n        for(i<-1 to ones.length) {\n            sum = sum + ones(i)\n            val index = tens.indexWhere(_ >= sum).toInt\n            if (index != -1) {\n                val indexTwo = teens.indexWhere(_ >= sum).toInt\n                if (indexTwo != -1) result = result :+ teens(indexTwo)\n                else result = result :+ tens(index)\n            } else result = result :+ tens(i)\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpr2pu91mq.scala:23:18 --------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m            sum = sum + ones(i)\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  Found:    Long\n\u001b[31m   |\u001b[0m                  Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpr2pu91mq.scala:27:60 --------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m                \u001b[33mif\u001b[0m (indexTwo != -\u001b[31m1\u001b[0m) result = result :+ teens(indexTwo)\n\u001b[31m\u001b[31m   |\u001b[0m                                                       ^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                                       Found:    Long\n\u001b[31m   |\u001b[0m                                                       Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpr2pu91mq.scala:28:44 --------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m                \u001b[33melse\u001b[0m result = result :+ tens(index)\n\u001b[31m\u001b[31m   |\u001b[0m                                        ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                        Found:    Long\n\u001b[31m   |\u001b[0m                                        Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpr2pu91mq.scala:29:42 --------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m            } \u001b[33melse\u001b[0m result = result :+ tens(i)\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                      Found:    Long\n\u001b[31m   |\u001b[0m                                      Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "stdout": "",
      "timestamp": 1660010425
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        val m = arr.map {i => if(i < 9) i else i.toString }\n        val s = m.toSet.toList\n        m.reverse foreach { i =>\n            val n = s.head\n            s remove n\n            m add n\n        }\n        m toList\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpct_kuqqh.scala:24:16 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        m toList\n\u001b[31m\u001b[31m   |\u001b[0m                ^\u001b[0m\n\u001b[31m   |\u001b[0m                expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpct_kuqqh.scala:21:14 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m            s remove n\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue remove is not a member of List[Matchable] - did you mean s.reduce?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpct_kuqqh.scala:22:14 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            m add n\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue add is not a member of List[Matchable], but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.seq AsJavaList\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversionsToJava.seq AsJavaList\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.collection asJava\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversionsToJava.collection asJava\n\u001b[31m   |\u001b[0m\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660010425
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        // Put the numbers in a tree\n        val tree = arr.foldLeft(new TreeMap[Long, String]()) { case (t, v) =>\n            val last = if (t.size == 0) \"One\" else \"One\"\n            val newTree = t + (v -> (last + v))\n            newTree\n        }\n\n        // Sort the tree using their length as key\n        val result = for {\n            (key, value) <- tree.lastOption\n        } yield value\n\n        // Reverse the sorted list\n        val reverseResult = for {\n            value <- result\n        } yield value.reverse\n\n        // Replace the digits in the list with the values from the dictionary\n        val replaced = reverseResult.map { s =>\n            val split = s.toString.toList.tail\n            split.map {\n                case s if s <= \"9\" && s >= \"1\" => s\"${(s\"One$s\").asInstanceOf[Char]}\"\n                case s if s <= \"9\" && s >= \"4\" => s\"${(s\"Four$s\").asInstanceOf[Char]}\"\n                case s if s <= \"9\" && s >= \"7\" => s\"${(s\"Seven$s\").asInstanceOf[Char]}\"\n                case s if s <= \"9\" && s >= \"8\" => s\"${(s\"Eight$s\").asInstanceOf[Char]}\"\n                case s if s <= \"9\" && s >= \"2\" => s\"${(s\"Two$s\").asInstanceOf[Char]}\"\n                case s if s <= \"9\" && s >= \"5\" => s\"${(s\"Five$s\").asInstanceOf[Char]}\"\n                case s if s <= \"9\" && s >= \"6\" => s\"${(s\"Six$s\").asInstanceOf[Char]}\"\n                case s if s <= \"9\" && s >= \"3\" => s\"${(s\"Three$s\").asInstanceOf[Char]}\"\n                case s if s <= \"9\" && s >= \"0\" => s\"${(s\"Zero$s\").asInstanceOf[Char]}\"\n                case s => \"Unknown digit\"\n            }.mkString(\"\")\n        }\n\n        // Return only the strings which are not empty\n        replaced.filter(_.nonEmpty).mkString(\", \")\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E134] Type Error: /tmp/tmp5d1896hl.scala:38:28 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m                \u001b[33mcase\u001b[0m s \u001b[33mif\u001b[0m s <= \u001b[31m\"9\"\u001b[0m && s >= \u001b[31m\"1\"\u001b[0m => \u001b[31ms\"\u001b[0m${(\u001b[31ms\"One\u001b[0m$s\u001b[31m\"\u001b[0m).asInstanceOf[Char]}\u001b[31m\"\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^\u001b[0m\n\u001b[31m   |\u001b[0mNone of the overloaded alternatives of \u001b[33mmethod\u001b[0m \u001b[35m<=\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mChar\u001b[0m with types\n\u001b[31m   |\u001b[0m (x: Double): Boolean\n\u001b[31m   |\u001b[0m (x: Float): Boolean\n\u001b[31m   |\u001b[0m (x: Long): Boolean\n\u001b[31m   |\u001b[0m (x: Int): Boolean\n\u001b[31m   |\u001b[0m (x: Char): Boolean\n\u001b[31m   |\u001b[0m (x: Short): Boolean\n\u001b[31m   |\u001b[0m (x: Byte): Boolean\n\u001b[31m   |\u001b[0mmatch arguments ((\u001b[32m\"9\"\u001b[0m : String))\n\u001b[31m\u001b[31m-- [E134] Type Error: /tmp/tmp5d1896hl.scala:39:28 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m                \u001b[33mcase\u001b[0m s \u001b[33mif\u001b[0m s <= \u001b[31m\"9\"\u001b[0m && s >= \u001b[31m\"4\"\u001b[0m => \u001b[31ms\"\u001b[0m${(\u001b[31ms\"Four\u001b[0m$s\u001b[31m\"\u001b[0m).asInstanceOf[Char]}\u001b[31m\"\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^\u001b[0m\n\u001b[31m   |\u001b[0mNone of the overloaded alternatives of \u001b[33mmethod\u001b[0m \u001b[35m<=\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mChar\u001b[0m with types\n\u001b[31m   |\u001b[0m (x: Double): Boolean\n\u001b[31m   |\u001b[0m (x: Float): Boolean\n\u001b[31m   |\u001b[0m (x: Long): Boolean\n\u001b[31m   |\u001b[0m (x: Int): Boolean\n\u001b[31m   |\u001b[0m (x: Char): Boolean\n\u001b[31m   |\u001b[0m (x: Short): Boolean\n\u001b[31m   |\u001b[0m (x: Byte): Boolean\n\u001b[31m   |\u001b[0mmatch arguments ((\u001b[32m\"9\"\u001b[0m : String))\n\u001b[31m\u001b[31m-- [E134] Type Error: /tmp/tmp5d1896hl.scala:40:28 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m                \u001b[33mcase\u001b[0m s \u001b[33mif\u001b[0m s <= \u001b[31m\"9\"\u001b[0m && s >= \u001b[31m\"7\"\u001b[0m => \u001b[31ms\"\u001b[0m${(\u001b[31ms\"Seven\u001b[0m$s\u001b[31m\"\u001b[0m).asInstanceOf[Char]}\u001b[31m\"\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^\u001b[0m\n\u001b[31m   |\u001b[0mNone of the overloaded alternatives of \u001b[33mmethod\u001b[0m \u001b[35m<=\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mChar\u001b[0m with types\n\u001b[31m   |\u001b[0m (x: Double): Boolean\n\u001b[31m   |\u001b[0m (x: Float): Boolean\n\u001b[31m   |\u001b[0m (x: Long): Boolean\n\u001b[31m   |\u001b[0m (x: Int): Boo",
      "stdout": "",
      "timestamp": 1660010425
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        if (arr.isEmpty) {\n            return List()\n        }\n        val first = arr.head\n        val last = arr.last\n        val start = 1 until first\n        val end = 9 until last\n        val numbers = arr.drop(first).takeWhile(_.isDefined).drop(first)\n        val strings = numbers.map(n => reverse(digit(n)) match {\n            case Some(s) => s\n            case None => n\n        }).getOrElse(numbers).reverse\n        strings: List[String]\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpt7qtz34w.scala:22:28 --------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstart\u001b[0m = \u001b[31m1\u001b[0m until first\n\u001b[31m\u001b[31m   |\u001b[0m                            ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                            Found:    (first : Long)\n\u001b[31m   |\u001b[0m                            Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpt7qtz34w.scala:23:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mend\u001b[0m = \u001b[31m9\u001b[0m until last\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (last : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpt7qtz34w.scala:24:31 --------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumbers\u001b[0m = arr.drop(first).takeWhile(_.isDefined).drop(first)\n\u001b[31m\u001b[31m   |\u001b[0m                               ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                               Found:    (first : Long)\n\u001b[31m   |\u001b[0m                               Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpt7qtz34w.scala:24:50 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumbers\u001b[0m = arr.drop(first).takeWhile(_.isDefined).drop(first)\n\u001b[31m\u001b[31m   |\u001b[0m                                                ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 value isDefined is not a member of Long\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpt7qtz34w.scala:24:66 --------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumbers\u001b[0m = arr.drop(first).takeWhile(_.isDefined).drop(first)\n\u001b[31m\u001b[31m   |\u001b[0m                                                                  ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         ",
      "stdout": "",
      "timestamp": 1660010425
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        var str = \"\"\n        val list = arr.toList\n        var count = 0\n        for(i <- list) {\n            count = count + 1\n            if(i < 9 && count > 3) {\n                str = str + \"One\"\n                count = 0\n            } else if (i < 99 && count > 3) {\n                str = str + \"Two\"\n                count = 0\n            } else if (i < 999 && count > 3) {\n                str = str + \"Three\"\n                count = 0\n            } else if (i < 9999 && count > 3) {\n                str = str + \"Four\"\n                count = 0\n            } else if (i < 99999 && count > 3) {\n                str = str + \"Five\"\n                count = 0\n            } else if (i < 999999 && count > 3) {\n                str = str + \"Six\"\n                count = 0\n            } else if (i < 9999999 && count > 3) {\n                str = str + \"Seven\"\n                count = 0\n            } else if (i < 999999999 && count > 3) {\n                str = str + \"Eight\"\n                count = 0\n            } else if (i < 99999999999 && count > 3) {\n                str = str + \"Nine\"\n                count = 0\n            } else if (i < 1000000000) {\n                str = str + \"Zero\"\n                count = 0\n            }\n        }\n        str\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmp38v3azwl.scala:46:27 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m46 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (i < \u001b[31m99999999999\u001b[0m && count > \u001b[31m3\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                           ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                           number too large\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp38v3azwl.scala:54:8 ---------------------\u001b[0m\u001b[0m\n\u001b[31m54 |\u001b[0m        str\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Found:    (str : String)\n\u001b[31m   |\u001b[0m        Required: List[String]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660010422
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        def findAndReplace(arr : List[Long], min : Long, max : Long) : List[Long] = {\n            val list = arr.toList\n            val result = list.reverse.filter(num => num >= min && num <= max)\n            result match {\n                case Nil => Nil\n                case x :: Nil => x\n                case x :: xs => findAndReplace(xs, min, max)\n            }\n        }\n        val newArr = findAndReplace(arr, 1l, 9l).toList\n        newArr.reverse.map { x => if (x < 10) \"One\" else if (x < 20) \"Two\" else if (x < 30) \"Three\" else if (x < 40) \"Four\" else if (x < 50) \"Five\" else if (x < 60) \"Six\" else if (x < 70) \"Seven\" else if (x < 80) \"Eight\" else if (x < 90) \"Nine\" else x }\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmptxj3wq6v.scala:22:33 --------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m                \u001b[33mcase\u001b[0m x :: Nil => x\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Found:    (x : Long)\n\u001b[31m   |\u001b[0m                                 Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmptxj3wq6v.scala:27:250 -------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        newArr.reverse.map { \u001b[36mx\u001b[0m => \u001b[33mif\u001b[0m (x < \u001b[31m10\u001b[0m) \u001b[31m\"One\"\u001b[0m \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (x < \u001b[31m20\u001b[0m) \u001b[31m\"Two\"\u001b[0m \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (x < \u001b[31m30\u001b[0m) \u001b[31m\"Three\"\u001b[0m \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (x < \u001b[31m40\u001b[0m) \u001b[31m\"Four\"\u001b[0m \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (x < \u001b[31m50\u001b[0m) \u001b[31m\"Five\"\u001b[0m \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (x < \u001b[31m60\u001b[0m) \u001b[31m\"Six\"\u001b[0m \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (x < \u001b[31m70\u001b[0m) \u001b[31m\"Seven\"\u001b[0m \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (x < \u001b[31m80\u001b[0m) \u001b[31m\"Eight\"\u001b[0m \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (x < \u001b[31m90\u001b[0m) \u001b[31m\"Nine\"\u001b[0m \u001b[33melse\u001b[0m x }\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                                                                                                                                                                                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                    Found:    (x : Long)\n\u001b[31m   |\u001b[0m                                                    Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660010423
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        if (arr.isEmpty) return Nil\n        val n = arr.takeWhile(n => n % 10 == 0).length\n        val x = arr.takeWhile(n => n % 10 != 0)\n        val z = arr.filterNot(_ % 10 == 0).sortBy(_ % 10)\n        val res = for{\n            i <- 0 to 9 - n\n        } yield {\n            if (i == 0) \"One\"\n            else if (i == 1) \"Two\"\n            else if (i == 2) \"Three\"\n            else if (i == 3) \"Four\"\n            else if (i == 4) \"Five\"\n            else if (i == 5) \"Six\"\n            else if (i == 6) \"Seven\"\n            else if (i == 7) \"Eight\"\n            else if (i == 8) \"Nine\"\n            else x.last.toString.replaceFirst(\"([a-z])\",\n                                 {case c => i.toString + c.toUpperCase})\n        }\n        res::z.flatten\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E081] Type Error: /tmp/tmpjbxb6u7f.scala:34:34 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m                                 {\u001b[33mcase\u001b[0m c => i.toString + c.toUpperCase})\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m   Missing parameter type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m   I could not infer the type of the parameter x$1 of expanded function:\n\u001b[31m   |\u001b[0m   x$1 => \n\u001b[31m   |\u001b[0m     x$1\u001b[33m match \u001b[0m\n\u001b[31m   |\u001b[0m       {\n\u001b[31m   |\u001b[0m         \u001b[33mcase \u001b[0mc => \n\u001b[31m   |\u001b[0m           i.toString + c.toUpperCase\n\u001b[31m   |\u001b[0m       }.\n\u001b[31m\u001b[31m-- Error: /tmp/tmpjbxb6u7f.scala:36:22 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m        res::z.flatten\n\u001b[31m\u001b[31m   |\u001b[0m                      ^\u001b[0m\n\u001b[31m   |\u001b[0mno given instance of type Long => IterableOnce[B] was found for parameter toIterableOnce of \u001b[33mmethod\u001b[0m \u001b[35mflatten\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mStrictOptimizedIterableOps\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mwhere:    B is a type variable\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660010424
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        arr.filter(_ < 10 && _ > 1).sortWith(_ < _).reverse.map(i => s\"${i % 10 + 1}\").filter(_.matches(\"[123][0-9]\")).toList\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E086] Syntax Error: /tmp/tmpke0gotp7.scala:17:19 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        arr.filter(_ < \u001b[31m10\u001b[0m && _ > \u001b[31m1\u001b[0m).sortWith(_ < _).reverse.map(\u001b[36mi\u001b[0m => \u001b[31ms\"\u001b[0m${i % \u001b[31m10\u001b[0m + \u001b[31m1\u001b[0m}\u001b[31m\"\u001b[0m).filter(_.matches(\u001b[31m\"[123][0-9]\"\u001b[0m)).toList\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Wrong number of parameters, expected: 1\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010419
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        if(arr.length == 0)\n            return List()\n        val numbers = arr.filter(x => x >= 1l && x <= 9l).toList\n        val one = Map(1l -> \"One\", 2l -> \"Two\", 3l -> \"Three\", 4l -> \"Four\", 5l -> \"Five\", 6l -> \"Six\", 7l -> \"Seven\", 8l -> \"Eight\", 9l -> \"Nine\")\n        val result = mutable.ListBuffer.empty[String]\n        for(x<-numbers ){\n            if(x % 10 > 0)\n            result += one(x%10)\n        }\n        result.reverse\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmptur0zxz5.scala:21:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.ListBuffer.empty[\u001b[35mString\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010420
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        if (arr.isEmpty) List()\n        else {\n            val arr = arr.sortWith(_ < _)\n            val reverseArr = arr.reverse\n            var i = 0\n            var narr : List[String] = List()\n            while (i < reverseArr.length) {\n                narr :+= reverseArr(i).toString.replace(\"One\", \"1\").replace(\"Two\", \"2\").replace(\"Three\", \"3\").replace(\"Four\", \"4\").replace(\"Five\", \"5\").replace(\"Six\", \"6\").replace(\"Seven\", \"7\").replace(\"Eight\", \"8\").replace(\"Nine\", \"9\")\n                i += 1\n            }\n            narr\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpxp0az68m.scala:19:22 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = arr.sortWith(_ < _)\n\u001b[31m\u001b[31m   |\u001b[0m                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                      Recursive \u001b[33mvalue\u001b[0m \u001b[35marr\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010421
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        val numbers = arr.map(_.toString).filter(_.nonEmpty)\n        var strs = List[String]()\n        for (n <- numbers) {\n            val m = n.toInt\n            val tens = n % 10\n            var units = tens / 10\n            var digit = n % 10\n            strs ++= if (digits < 0 || digits > 9) {\n                strs.filterNot(_ == n)\n            } else {\n                List(One, Two, Three, Four, Five, Six, Seven, Eight, Nine, digit)\n            }\n        }\n        strs.reverse\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmp0zzna8di.scala:24:21 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m            strs ++= \u001b[33mif\u001b[0m (digits < \u001b[31m0\u001b[0m || digits > \u001b[31m9\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^\u001b[0m\n\u001b[31m   |\u001b[0m                     expression expected but \u001b[31mif\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp0zzna8di.scala:21:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mtens\u001b[0m = n % \u001b[31m10\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue % is not a member of String, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mThe following import might make progress towards fixing the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.Integral.Implicits.infixIntegralOps\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp0zzna8di.scala:23:26 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m            \u001b[33mvar\u001b[0m \u001b[36mdigit\u001b[0m = n % \u001b[31m10\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue % is not a member of String, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mThe following import might make progress towards fixing the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.Integral.Implicits.infixIntegralOps\n\u001b[31m   |\u001b[0m\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660010424
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n      arr.filter(_ >= 1 && _ <= 9).map(_.toString).reverse.map(s => s if s.length <= 9 else s.padToLength(9))\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpzdy38phc.scala:17:70 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m      arr.filter(_ >= \u001b[31m1\u001b[0m && _ <= \u001b[31m9\u001b[0m).map(_.toString).reverse.map(\u001b[36ms\u001b[0m => s \u001b[33mif\u001b[0m s.length <= \u001b[31m9\u001b[0m \u001b[33melse\u001b[0m s.padToLength(\u001b[31m9\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                                                                      ^^\u001b[0m\n\u001b[31m   |\u001b[0m                                            ')' expected, but 'if' found\n\u001b[31m\u001b[31m-- [E086] Syntax Error: /tmp/tmpzdy38phc.scala:17:17 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m      arr.filter(_ >= \u001b[31m1\u001b[0m && _ <= \u001b[31m9\u001b[0m).map(_.toString).reverse.map(\u001b[36ms\u001b[0m => s \u001b[33mif\u001b[0m s.length <= \u001b[31m9\u001b[0m \u001b[33melse\u001b[0m s.padToLength(\u001b[31m9\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                 Wrong number of parameters, expected: 1\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660010419
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n      if (arr.isEmpty) {\n        List()\n      } else {\n        val l = arr.toList\n        val len = l.size\n        val maxLen = 9\n        val arr = l.filter((x: Long) => x <= maxLen).toList\n        val reverse = l.filter((x: Long) => x > maxLen).toList.reverse\n        val revLen = reverse.size\n        val revMap = collection.mutable.Map[String, Long]()\n        for (i <- 0 until len) {\n          val num = arr(i)\n          if (revMap.get(num.toString.reverse) == null) {\n            revMap += (num.toString.reverse -> num.toLong)\n          } else {\n            val rev_num = revMap.get(num.toString.reverse)\n            if (rev_num.toLong < num.toLong) {\n              revMap += (num.toString.reverse -> num.toLong)\n            }\n          }\n        }\n        reverse.filter((x: Long) => x <= revLen).toList.map((x: Long) => revMap.get(x.toString)).toList\n      }\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpeax48ceh.scala:23:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = l.filter((\u001b[36mx\u001b[0m: \u001b[35mLong\u001b[0m) => x <= maxLen).toList\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Recursive \u001b[33mvalue\u001b[0m \u001b[35ml\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpeax48ceh.scala:33:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m            \u001b[33mif\u001b[0m (rev_num.toLong < num.toLong) {\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue toLong is not a member of Option[Long], but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might make progress towards fixing the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.Fractional.Implicits.infixFractionalOps\n\u001b[31m   |\u001b[0m  import math.Integral.Implicits.infixIntegralOps\n\u001b[31m   |\u001b[0m  import math.Numeric.Implicits.infixNumericOps\n\u001b[31m   |\u001b[0m\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660010425
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        val ans = arr.filter(x => x >= 1 && x <= 9).toList.sortWith((x, y) => x - y)\n        if (ans.isEmpty) List[String]() else ans.reverse.map(num => \"Nine\".toUpperCase() +: num.toString.toUpperCase).filter(_.nonEmpty)\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp1t41lnk2.scala:17:78 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mans\u001b[0m = arr.filter(\u001b[36mx\u001b[0m => x >= \u001b[31m1\u001b[0m && x <= \u001b[31m9\u001b[0m).toList.sortWith((\u001b[36mx\u001b[0m, \u001b[36my\u001b[0m) => x - y)\n\u001b[31m\u001b[31m   |\u001b[0m                                                                              ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                                       Found:    Long\n\u001b[31m   |\u001b[0m                                                       Required: Boolean\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp1t41lnk2.scala:18:124 -------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mif\u001b[0m (ans.isEmpty) List[\u001b[35mString\u001b[0m]() \u001b[33melse\u001b[0m ans.reverse.map(\u001b[36mnum\u001b[0m => \u001b[31m\"Nine\"\u001b[0m.toUpperCase() +: num.toString.toUpperCase).filter(_.nonEmpty)\n\u001b[31m\u001b[31m   |\u001b[0m                                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                   Found:    List[IndexedSeq[Matchable]]\n\u001b[31m   |\u001b[0m                                   Required: List[String]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660010424
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        val r = arr.reverse\n        val rev = r.reverse\n        val rev2 = rev.reverse\n        val rev3 = rev2.reverse.reverse.reverse\n        val rev4 = rev3.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpupg5t6ez.scala:22:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[String]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010422
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        val n = arr.length\n        var i = 0\n        var res : List[String] = Nil\n        while (i < n) {\n            if (arr(i).toInt == (1 until 9).indexOf(i.toInt)) {\n                res = res.reverse :: Nil\n            } else {\n                res = res.reverse :: (byDigit(arr(i).toInt)) :: Nil\n            }\n            i += 1\n        }\n        res\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpjybdowd8.scala:22:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m                res = res.reverse :: Nil\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      Found:    \u001b[1m\u001b[31mList\u001b[0m\u001b[1m\u001b[31m[\u001b[0mString\u001b[1m\u001b[31m]\u001b[0m\n\u001b[31m   |\u001b[0m                      Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpjybdowd8.scala:24:38 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m                res = res.reverse :: (byDigit(arr(i).toInt)) :: Nil\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                      Not found: byDigit\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpjybdowd8.scala:24:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m                res = res.reverse :: (byDigit(arr(i).toInt)) :: Nil\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      Found:    \u001b[1m\u001b[31mList\u001b[0m\u001b[1m\u001b[31m[\u001b[0mString\u001b[1m\u001b[31m]\u001b[0m\n\u001b[31m   |\u001b[0m                      Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660010424
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        if (arr.isEmpty) List()\n        else if (arr.head < 0l || arr.last > 9l) List()\n        else {\n            val list = arr.sorted\n            val length = list.last\n            val first  = list.init\n            val last   = list.tail\n            val reverse = ListBuffer[String]()\n\n            var cur = 0\n            var digit = 0\n\n            // reverse the list.\n            for ((i, x) <- list.view.zipWithIndex) {\n                if (x == digit) {\n                    cur = i\n                    digit = x\n                }\n                else if (x <= cur) reverse.append(digit.toString)\n                else if (x > cur) {\n                    reverse.append(s\"${digit.toString}${x.toString.charAt(0).toLowerCase}\")\n                    cur = x\n                    digit = x\n                }\n            }\n\n            val list = ListBuffer[String]()\n\n            // reverse and append the results.\n            while (first != last) {\n                list += reverse.toString\n                first = first.next\n            }\n\n            list += reverse.toString\n\n            // replace each digit with its corresponding name from \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"\n            val map = Map(0 -> \"One\",\n                          1 -> \"Two\",\n                          2 -> \"Three\",\n                          3 -> \"Four\",\n                          4 -> \"Five\",\n                          5 -> \"Six\",\n                          6 -> \"Seven\",\n                          7 -> \"Eight\",\n                          8 -> \"Nine\")\n\n            val result = list.map(x => x -> map(x.charAt(0).toInt))\n\n            result.filter(x => x(0).isDigit).map(x => s\"${x._1}${x._2.charAt(0).toLowerCase}\")\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpfojwbcyw.scala:43:16 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m43 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mlist\u001b[0m = ListBuffer[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mlist is already defined as \u001b[33mvalue\u001b[0m \u001b[35mlist\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpfojwbcyw.scala:32:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m                    cur = i\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (i : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpfojwbcyw.scala:37:77 ------------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m                    reverse.append(\u001b[31ms\"\u001b[0m${digit.toString}${x.toString.charAt(\u001b[31m0\u001b[0m).toLowerCase}\u001b[31m\"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                               value toLowerCase is not a member of Char\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpfojwbcyw.scala:47:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m47 |\u001b[0m                list += reverse.toString\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m          value += is not a member of List[Long] - did you mean list.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpfojwbcyw.scala:48:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m48 |\u001b[0m                first = first.next\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m     value next is not a member of List[Long] - did you mean first.head?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpfojwbcyw.scala:51:17 ------------------------\u001b[0m\u001b[0m\n\u001b[31m51 |\u001b[0m            list += reverse.toString\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m          valu",
      "stdout": "",
      "timestamp": 1660010426
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        val arr = arr.sortBy(_.toString.length)\n        val map = scala.collection.mutable.Map[String, Long]()\n        arr.foreach { x =>\n            val digit = x\n            map.put(digit.toString, (map.getOrElse(digit.toString.toInt, 0L) + 1))\n        }\n        val result: List[String] = arr.filter(x => map.contains(x.toString)).map {\n            x =>\n                val digit = x\n                val count = map.getOrElse(digit.toString.toInt, 0L)\n                map(digit) + count.toString\n        }.reverse\n        result match {\n            case head :: tail => result :: tail\n            case Nil => List()\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpabyncmxj.scala:17:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = arr.sortBy(_.toString.length)\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Recursive \u001b[33mvalue\u001b[0m \u001b[35marr\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpabyncmxj.scala:30:33 --------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m            \u001b[33mcase\u001b[0m head :: tail => result :: tail\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Found:    (result : List[String])\n\u001b[31m   |\u001b[0m                                 Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660010424
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        val newList = new mutable.ListBuffer[String]()\n        for(i <- arr.indices)\n        { \n            if(arr(i) < 1L || arr(i) > 9L)\n            {\n                println(\"wrong input\")\n                return new mutable.ListBuffer[String]()\n            }\n            if(newList.size != 0) {\n                if(newList.head == \"\") {\n                    newList.head +=  s\"${arr(i).asInstanceOf[Long]}\"\n                }\n                else \n                    newList +=  s\"${arr(i).asInstanceOf[Long]}\"\n            }\n            else {\n                if(arr(i).asInstanceOf[Long] <= 9) {\n                    newList += s\"${arr(i).asInstanceOf[Long]}\"\n                }\n            }\n        }\n        if(newList.size != 0) {\n            newList.reverse.map( x => if(x.asInstanceOf[Long] <= 9)\n                x else x.toString.replaceFirst(\"\\\\d\",\n                    s\"${One.name}\"))\n        }\n        else {\n            new mutable.ListBuffer[String]()\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmprbcy5pp2.scala:17:26 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnewList\u001b[0m = \u001b[33mnew\u001b[0m mutable.ListBuffer[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmprbcy5pp2.scala:23:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m                \u001b[33mreturn\u001b[0m \u001b[33mnew\u001b[0m mutable.ListBuffer[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                           ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                           Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmprbcy5pp2.scala:44:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m44 |\u001b[0m            \u001b[33mnew\u001b[0m mutable.ListBuffer[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660010419
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        val list = arr.sortBy(_ * 10).reverse\n        val ones = list.filter(_ <= 9).toList\n        val tens = list.filter(_ <= 99).toList\n        val hundreds = list.filter(_ <= 999).toList\n        val thousands = list.filter(_ <= 9999).toList\n        if (ones.isEmpty && tens.isEmpty && hundreds.isEmpty && thousands.isEmpty)\n            List()\n        else if (ones.isEmpty)\n            ones\n        else if (tens.isEmpty)\n            tens\n        else if (hundreds.isEmpty)\n            hundreds\n        else if (thousands.isEmpty)\n            thousands\n        else if (ones.isEmpty)\n            ones\n        else if (tens.isEmpty)\n            tens\n        else if (hundreds.isEmpty)\n            hundreds\n        else if (thousands.isEmpty)\n            thousands\n        else if (ones.isEmpty)\n            ones\n        else\n            List(list.filter(_ <= 9).toList.reverse.mkString(\"One\"), list.filter(_ <= 99).toList.reverse.mkString(\"Two\"),\n                    list.filter(_ <= 999).toList.reverse.mkString(\"Three\"), list.filter(_ <= 9999).toList.reverse.mkString(\"Four\"),\n                    list.filter(_ <= 9999).toList.reverse.mkString(\"Five\"), list.filter(_ <= 9999).toList.reverse.mkString(\"Six\"),\n                    list.filter(_ <= 9999).toList.reverse.mkString(\"Seven\"), list.filter(_ <= 9999).toList.reverse.mkString(\"Eight\"),\n                    list.filter(_ <= 9999).toList.reverse.mkString(\"Nine\"), list.filter(_ <= 9999).toList.reverse.mkString(\"Ten\"))\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpd7_vqchx.scala:25:12 --------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m            ones\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            Found:    (ones : List[Long])\n\u001b[31m   |\u001b[0m            Required: List[String]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpd7_vqchx.scala:27:12 --------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m            tens\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            Found:    (tens : List[Long])\n\u001b[31m   |\u001b[0m            Required: List[String]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpd7_vqchx.scala:29:12 --------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m            hundreds\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            Found:    (hundreds : List[Long])\n\u001b[31m   |\u001b[0m            Required: List[String]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpd7_vqchx.scala:31:12 --------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m            thousands\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            Found:    (thousands : List[Long])\n\u001b[31m   |\u001b[0m            Required: List[String]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpd7_vqchx.scala:33:12 --------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m            ones\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            Found:    (ones : List[Long])\n\u001b[31m   |\u001b[0m            Required: List[String]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpd7_vqchx.scala:35:12 --------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m            tens\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            Found:    (tens : List[Long])\n\u001b[3",
      "stdout": "",
      "timestamp": 1660010425
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        val ones = arr.filter(x => x >= 1l && x <= 9l)\n        val tens = arr.filter(x => x >= 10l && x <= 19l)\n        val teens = arr.filter(x => x >= 20l && x <= 99l)\n        val tenths = arr.filter(x => x >= 100l && x <= 999l)\n        val hundreds = arr.filter(x => x >= 1000l)\n        val thousands = arr.filter(x => x >= 100000l)\n        val millions = arr.filter(x => x >= 1000000l)\n        val billions = arr.filter(x => x >= 10000000l)\n        val milliards = arr.filter(x => x >= 1000000000l)\n        val tenthousands = arr.filter(x => x >= 10000000000l)\n        val billionards = arr.filter(x => x >= 10000000000000l)\n        val hundredths = arr.filter(x => x >= 100000000000000l)\n        val tenmilliards = arr.filter(x => x >= 1000000000000000l)\n        val onehundredths = arr.filter(x => x >= 10000000000000000l)\n        val onemilliards = arr.filter(x => x >= 100000000000000000l)\n        val tenthousandths = arr.filter(x => x >= 1000000000000000000l)\n        val billionthousandths = arr.filter(x => x >= 10000000000000000000l)\n        val hundredmillionths = arr.filter(x => x >= 100000000000000000000l)\n        val onebillionths = arr.filter(x => x >= 1000000000000000000000l)\n        val onemillionths = arr.filter(x => x >= 10000000000000000000000l)\n        val tenmillionths = arr.filter(x => x >= 100000000000000000000000l)\n        val onebillionthousandths = arr.filter(x => x >= 1000000000000000000000000l)\n        val onebillionmillionths = arr.filter(x => x >= 10000000000000000000000000l)\n        val onebillionmillionthousandths = arr.filter(x => x >= 100000000000000000000000000l)\n        val tenbillionthousandths = arr.filter(x => x >= 1000000000000000000000000000l)\n        val onebillionmillionthousandthousandths = arr.filter(x => x >= 10000000000000000000000000000l)\n        val onebillionmillionthousandthousandthousandths = arr.filter(x => x >= 100000000000000000000000000000l)\n        val onebillionmillionthousandthousandthousandthousandths = arr.filter(x => x >= 1000000000000000000000000000000l)\n        val onebillionmillionthousandthousandthous\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmpx0_l3kuc.scala:33:54 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbillionthousandths\u001b[0m = arr.filter(\u001b[36mx\u001b[0m => x >= \u001b[31m10000000000000000000l\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                      number too large\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpx0_l3kuc.scala:34:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhundredmillionths\u001b[0m = arr.filter(\u001b[36mx\u001b[0m => x >= \u001b[31m100000000000000000000l\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m^^^\u001b[0m\n\u001b[31m   |\u001b[0m')' expected, but 'end of statement' found\n\u001b[31m\u001b[31m-- Error: /tmp/tmpx0_l3kuc.scala:34:53 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhundredmillionths\u001b[0m = arr.filter(\u001b[36mx\u001b[0m => x >= \u001b[31m100000000000000000000l\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                     number too large\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpx0_l3kuc.scala:35:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36monebillionths\u001b[0m = arr.filter(\u001b[36mx\u001b[0m => x >= \u001b[31m1000000000000000000000l\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m^^^\u001b[0m\n\u001b[31m   |\u001b[0m')' expected, but 'end of statement' found\n\u001b[31m\u001b[31m-- Error: /tmp/tmpx0_l3kuc.scala:35:49 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36monebillionths\u001b[0m = arr.filter(\u001b[36mx\u001b[0m => x >= \u001b[31m1000000000000000000000l\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                                 ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                 number too large\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpx0_l3kuc.scala:36:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36monemillionths\u001b[0m = arr.filter(\u001b[36mx\u001b[0m => x >= \u001b[31m10000000000000000000000l\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m^^^\u001b[0m\n\u001b[31m   |\u001b[0m')' expected, but 'end of sta",
      "stdout": "",
      "timestamp": 1660010425
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        arr.sorted match {\n            case Nil => Nil\n            case _   if arr.head < 10l || arr.head > 99l => Nil\n            case x :: y => List(\n                if (x > 9l || x < 1l) \"\"\n                else if (x == 99l || x == 99l) {\n                    \"Nine\"\n                } else {\n                    val num = x.toString.toInt\n                    val ind = num.toString.indexOf(\".\")\n                    val ten = (num - num.toString.substring(0, ind)).toString.toInt\n                    val unit = (ten == 0) || (num - ten) % (num / 10).toString.toInt\n                    val tens = (num - ten * 10).toString.toInt\n                    val digit = num - num.toString.substring(ind, num.length).toString.toInt\n                    val digits = (num - digit * 10).toString.toInt\n                    val hundreds = (num - tens * 100).toString.toInt\n                    val digitnames = (\n                        List(\n                            \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\",\n                            \"Eight\", \"Nine\"\n                        )\n                    )\n                    val hundrednames = (\n                        List(\n                            \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\",\n                            \"Eight\", \"Nine\"\n                        )\n                    )\n\n                    val hundredname = (\n                        (hundreds >= 0) && // check for negative\n                        (hundreds < 100 && hundrednames.length <= hundreds) // check for valid number size\n                            ? hundrednames[hundreds]\n                            : \"\"\n                    )\n                    val tenname = (\n                        (tens >= 0) && // check for negative\n                        (tens < 10 && tennames.length <= tens) // check for valid number size\n                            ? tennames[tens]\n                            : \"\"\n                    )\n                    val unitname = (\n                        (unit >= 0) && // check for negative\n                        (unit < 10 && unitnames.length <= unit) // check for valid number size\n                            ? unitnames[unit]\n                            : \"\"\n                    )\n                    val digitname = (\n                        (digit >= 0) && // check for negative\n                        (digit < 10 && digitnames.length <= digit) // check for valid number size\n                            ? digitnames[digit]\n                            : \"\"\n                    )\n                    val tennames = (\n                        (tens >= 0) && // check for negative\n                        (tens < 10 && tennames.length <= tens) // check for valid number size\n                            ? tennames[tens]\n                            : \"\"\n                    )\n                    val unitnames = (\n                        (unit >= 0) && // check for \n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmp3_t5seia.scala:77:38 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m77 |\u001b[0m                        (unit >= \u001b[31m0\u001b[0m) && \u001b[34m// check for \u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                                      expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp3_t5seia.scala:79:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m79 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36mmain\u001b[0m(\u001b[36margs\u001b[0m: \u001b[35mArray\u001b[0m[\u001b[35mString\u001b[0m]) = {\n\u001b[31m\u001b[31m   |\u001b[0m    ^^^\u001b[0m\n\u001b[31m   |\u001b[0m    ')' expected, but 'def' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp3_t5seia.scala:88:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m88 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E134] Type Error: /tmp/tmp3_t5seia.scala:27:35 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m                    \u001b[33mval\u001b[0m \u001b[36mten\u001b[0m = (num - num.toString.substring(\u001b[31m0\u001b[0m, ind)).toString.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                               ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m None of the overloaded alternatives of \u001b[33mmethod\u001b[0m \u001b[35m-\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mInt\u001b[0m with types\n\u001b[31m   |\u001b[0m  (x: Double): Double\n\u001b[31m   |\u001b[0m  (x: Float): Float\n\u001b[31m   |\u001b[0m  (x: Long): Long\n\u001b[31m   |\u001b[0m  (x: Int): Int\n\u001b[31m   |\u001b[0m  (x: Char): Int\n\u001b[31m   |\u001b[0m  (x: Short): Int\n\u001b[31m   |\u001b[0m  (x: Byte): Int\n\u001b[31m   |\u001b[0m match arguments (String)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp3_t5seia.scala:30:70 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m                    \u001b[33mval\u001b[0m \u001b[36mdigit\u001b[0m = num - num.toString.substring(ind, num.length).toString.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                                                                  ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                     value length is not a member of Int\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp3_t5seia.scala:67:28 ------------------------\u001b[0m\u001b[0m\n\u001b[",
      "stdout": "",
      "timestamp": 1660010432
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        val result = arr\n            .map(_.toString)\n            .map(name => if(name.charAt(0) == '1') \"One\" else if(name.charAt(0) == '2') \"Two\" else if(name.charAt(0) == '3') \"Three\" else if(name.charAt(0) == '4') \"Four\" else if(name.charAt(0) == '5') \"Five\" else if(name.charAt(0) == '6') \"Six\" else if(name.charAt(0) == '7') \"Seven\" else if(name.charAt(0) == '8') \"Eight\" else if(name.charAt(0) == '9') \"Nine\" else name)\n            .sortWith(_.length > 0)\n            .reverse\n            .map(_.charAt(0).toString)\n        arr match {\n            case Nil => result\n            case _ => result\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E086] Syntax Error: /tmp/tmp2kvd6uz5.scala:20:22 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m            .sortWith(_.length > \u001b[31m0\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      Wrong number of parameters, expected: 2\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010429
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        def sortAndRev(x: Long) : List[Long] = {\n            val s = x.toString\n            val digits = Vector.range(1,9).map(x => if (x < 0) \"One\" else \"Two\" else if (x < 10) else \"Three\" else if (x < 20) else \"Four\" else if (x < 30) else \"Five\" else if (x < 40) else \"Six\" else if (x < 50) else \"Seven\" else if (x < 60) else \"Eight\" else if (x < 70) else \"Nine\")\n            val result = digits.zip(s).filter(x => x != 0)\n            sortAndRev(result)\n        }\n        arr.foldLeft(List[Long]())((acc, x) => sortAndRev(acc :+ x))\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp81mvo24x.scala:19:80 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mdigits\u001b[0m = Vector.range(\u001b[31m1\u001b[0m,\u001b[31m9\u001b[0m).map(\u001b[36mx\u001b[0m => \u001b[33mif\u001b[0m (x < \u001b[31m0\u001b[0m) \u001b[31m\"One\"\u001b[0m \u001b[33melse\u001b[0m \u001b[31m\"Two\"\u001b[0m \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (x < \u001b[31m10\u001b[0m) \u001b[33melse\u001b[0m \u001b[31m\"Three\"\u001b[0m \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (x < \u001b[31m20\u001b[0m) \u001b[33melse\u001b[0m \u001b[31m\"Four\"\u001b[0m \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (x < \u001b[31m30\u001b[0m) \u001b[33melse\u001b[0m \u001b[31m\"Five\"\u001b[0m \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (x < \u001b[31m40\u001b[0m) \u001b[33melse\u001b[0m \u001b[31m\"Six\"\u001b[0m \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (x < \u001b[31m50\u001b[0m) \u001b[33melse\u001b[0m \u001b[31m\"Seven\"\u001b[0m \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (x < \u001b[31m60\u001b[0m) \u001b[33melse\u001b[0m \u001b[31m\"Eight\"\u001b[0m \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (x < \u001b[31m70\u001b[0m) \u001b[33melse\u001b[0m \u001b[31m\"Nine\"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                          ')' expected, but 'else' found\n\u001b[31m\u001b[31m-- Error: /tmp/tmp81mvo24x.scala:20:51 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = digits.zip(s).filter(\u001b[36mx\u001b[0m => x != \u001b[31m0\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                                   ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m Values of types (String, Char) and Int cannot be compared with == or !=\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp81mvo24x.scala:21:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m            sortAndRev(result)\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (result : Vector[(String, Char)])\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp81mvo24x.scala:23:58 --------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        arr.foldLeft(List[\u001b[35mLong\u001b[0m]())((\u001b[36macc\u001b[0m, \u001b[36mx\u001b[0m) => sortAndRev(acc :+ x))\n\u001b[31m\u001b[31m   |\u001b[0m                                       ",
      "stdout": "",
      "timestamp": 1660010433
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        def digit = arr(0).toString.toInt\n        def digits = arr\n        def lastDigit = arr(arr.length - 1).toString.toInt\n        def swapDigit = (digit, digits) => {\n            val newDigits = digits(0 until digits.length).map(_ - digit).toList.sortWith(_ < _)\n            val newDigit = if (newDigits.isEmpty) 0 else newDigits(0)\n            (digit, newDigits)\n        }\n        def replaceDigit = (digit, digits) => {\n            val newDigits = digits(0 until digits.length).map((_ - digit).toString.toInt)\n            val newDigit = if (newDigits.isEmpty) 0 else newDigits(0)\n            (newDigit, newDigits)\n        }\n        def swapAll = (digits, digit) => {\n            val newDigits = digits(0 until digits.length).map(swapDigit)\n            val newDigit = if (newDigits.isEmpty) 0 else newDigits(0)\n            (newDigit, newDigits)\n        }\n        val list = arr.toList\n        if (list.isEmpty) {\n            return Nil\n        }\n        if (list.last.asInstanceOf[Long] == -1) {\n            val newDigit = list.last.toString.toInt\n            val newDigits = list.tail.map((_ - newDigit).toString.toInt)\n            return newDigits.reverse.map(replaceDigit).reverse\n        }\n        if (list.last.asInstanceOf[Long] == 9) {\n            val newDigit = list.last.toString.toInt\n            val newDigits = list.tail.map((_ - newDigit).toString.toInt)\n            return newDigits.reverse.map(swapAll).reverse\n        }\n        val newDigit = list.last.toString.toInt\n        val newDigits = list.tail.map((_ - newDigit).toString.toInt)\n        return newDigits.reverse.map(swapAll).reverse\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E081] Type Error: /tmp/tmpnyh3m597.scala:20:25 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mdef\u001b[0m \u001b[36mswapDigit\u001b[0m = (\u001b[36mdigit\u001b[0m, \u001b[36mdigits\u001b[0m) => {\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      Missing parameter type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m                      I could not infer the type of the parameter digit.\n\u001b[31m\u001b[31m-- [E081] Type Error: /tmp/tmpnyh3m597.scala:20:32 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mdef\u001b[0m \u001b[36mswapDigit\u001b[0m = (\u001b[36mdigit\u001b[0m, \u001b[36mdigits\u001b[0m) => {\n\u001b[31m\u001b[31m   |\u001b[0m                                ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Missing parameter type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m                     I could not infer the type of the parameter digits.\n\u001b[31m\u001b[31m-- [E081] Type Error: /tmp/tmpnyh3m597.scala:25:28 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mdef\u001b[0m \u001b[36mreplaceDigit\u001b[0m = (\u001b[36mdigit\u001b[0m, \u001b[36mdigits\u001b[0m) => {\n\u001b[31m\u001b[31m   |\u001b[0m                            ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      Missing parameter type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m                      I could not infer the type of the parameter digit.\n\u001b[31m\u001b[31m-- [E081] Type Error: /tmp/tmpnyh3m597.scala:25:35 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mdef\u001b[0m \u001b[36mreplaceDigit\u001b[0m = (\u001b[36mdigit\u001b[0m, \u001b[36mdigits\u001b[0m) => {\n\u001b[31m\u001b[31m   |\u001b[0m                                   ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Missing parameter type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m                     I could not infer the type of the parameter digits.\n\u001b[31m\u001b[31m-- [E081] Type Error: /tmp/tmpnyh3m597.scala:30:23 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mdef\u001b[0m \u001b[36mswapAll\u001b[0m = (\u001b[36mdigits\u001b[0m, \u001b[36mdigit\u001b[0m) => {\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Missing parameter type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m                     I could not infer the type of the parameter digits.\n\u001b[31m\u001b",
      "stdout": "",
      "timestamp": 1660010435
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        arr match {\n          case Nil => List()\n          case x :: xs => byLength(reverse(xs) ++ byLength(filterByLength(x.toInt, (0 until 9).toList)))\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp479j1e_8.scala:19:35 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m          \u001b[33mcase\u001b[0m x :: xs => byLength(reverse(xs) ++ byLength(filterByLength(x.toInt, (\u001b[31m0\u001b[0m until \u001b[31m9\u001b[0m).toList)))\n\u001b[31m\u001b[31m   |\u001b[0m                                   ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                   Not found: reverse\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010428
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        val result = arr.map(i => {\n            val digit = if (i < 10L) i else 10L - i\n            s\"${if (digit < 10) digit.toString else \"One\"}${if (digit < 10) digit.toString else \"Two\"}${if (digit < 10) digit.toString else \"Three\"}${if (digit < 10) digit.toString else \"Four\"}${if (digit < 10) digit.toString else \"Five\"}${if (digit < 10) digit.toString else \"Six\"}${if (digit < 10) digit.toString else \"Seven\"}${if (digit < 10) digit.toString else \"Eight\"}${if (digit < 10) digit.toString else \"Nine\"}\" })\n        val reversed = result.sortWith(_.length <=> _.length)\n        reversed.map(i => i.replaceAll(\"^(?=.)\", \"Zero\").replaceAll(\"(?<=.)$\", \"\"))\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmphq7_apu5.scala:20:48 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mreversed\u001b[0m = result.sortWith(_.length <=> _.length)\n\u001b[31m\u001b[31m   |\u001b[0m                                       ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                 value <=> is not a member of Int - did you mean Int.<=?\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010434
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        var newList: List[String] = Nil\n\n        val ones = arr filter (x => x < 1l || x > 9l) map (\"One\")\n        val twos = arr filter (x => x >= 1l && x < 10l) map (\"Two\")\n        val threes = arr filter (x => x >= 10l && x < 20l) map (\"Three\")\n        val fours = arr filter (x => x >= 20l && x < 30l) map (\"Four\")\n        val fives = arr filter (x => x >= 30l && x < 40l) map (\"Five\")\n        val sixes = arr filter (x => x >= 40l && x < 50l) map (\"Six\")\n        val sevens = arr filter (x => x >= 50l && x < 60l) map (\"Seven\")\n        val eights = arr filter (x => x >= 60l && x < 70l) map (\"Eight\")\n        val nines = arr filter (x => x >= 70l && x < 80l) map (\"Nine\")\n        val tens = arr filter (x => x >= 80l) map (\"Ten\")\n\n        newList = newList ++ ones ++ twos ++ threes ++ fours ++ fives ++ sixes ++ sevens ++ eights ++ nines ++ tens\n        return newList.reverse\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpfdrk6a3g.scala:19:59 --------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mones\u001b[0m = arr filter (\u001b[36mx\u001b[0m => x < \u001b[31m1l\u001b[0m || x > \u001b[31m9l\u001b[0m) map (\u001b[31m\"One\"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                                           ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                              Found:    (\u001b[32m\"One\"\u001b[0m : String)\n\u001b[31m   |\u001b[0m                                              Required: Long => Any\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpfdrk6a3g.scala:20:61 --------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mtwos\u001b[0m = arr filter (\u001b[36mx\u001b[0m => x >= \u001b[31m1l\u001b[0m && x < \u001b[31m10l\u001b[0m) map (\u001b[31m\"Two\"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                                             ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                              Found:    (\u001b[32m\"Two\"\u001b[0m : String)\n\u001b[31m   |\u001b[0m                                              Required: Long => Any\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpfdrk6a3g.scala:21:64 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mthrees\u001b[0m = arr filter (\u001b[36mx\u001b[0m => x >= \u001b[31m10l\u001b[0m && x < \u001b[31m20l\u001b[0m) map (\u001b[31m\"Three\"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                                                ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                            Found:    (\u001b[32m\"Three\"\u001b[0m : String)\n\u001b[31m   |\u001b[0m                                            Required: Long => Any\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpfdrk6a3g.scala:22:63 --------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mfours\u001b[0m = arr filter (\u001b[36mx\u001b[0m => x >= \u001b[31m20l\u001b[0m && x < \u001b[31m30l\u001b[0m) map (\u001b[31m\"Four\"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                            ",
      "stdout": "",
      "timestamp": 1660010438
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        val list = arr.toList\n        if(list.nonEmpty) {\n            val len = list.map(_.toString.length).sum.toInt\n            val maxLen = list.map(_.toString.length).max.toInt\n            val rem = len - maxLen\n            val strArr = list.map(x => getChar(x).toString + (\"00\" + x.toString).substr(rem, rem))\n            val reversed = strArr.reverse\n            reversed.map(x => x.replaceAll(\"\\\\D\",\"\"))\n        }\n        else List()\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp5psbjaqg.scala:22:39 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mstrArr\u001b[0m = list.map(\u001b[36mx\u001b[0m => getChar(x).toString + (\u001b[31m\"00\"\u001b[0m + x.toString).substr(rem, rem))\n\u001b[31m\u001b[31m   |\u001b[0m                                       ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                       Not found: getChar\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp5psbjaqg.scala:24:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m            reversed.map(\u001b[36mx\u001b[0m => x.replaceAll(\u001b[31m\"\\\\D\"\u001b[0m,\u001b[31m\"\"\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                             value replaceAll is not a member of Nothing\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660010434
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        val newArray = arr.filter(_ < 10l.toLong).toList\n        val result = arr.sortBy(_.toInt).reverse\n\n        // Add each digit as name to the list\n        for (i <- 0 until result.size) {\n            if (result(i) >= 10l.toLong && result(i) < 100l.toLong) {\n                result(i) = result(i).toString.replaceAll(\"\\\\D\", \"\")\n                newArray.insert(i, result(i).replaceAll(\"(?<=\\\\D)(?=[1-9]$)\", \"One\"))\n            }\n            if (result(i) >= 100l.toLong && result(i) < 1000l.toLong) {\n                result(i) = result(i).toString.replaceAll(\"\\\\D\", \"\")\n                newArray.insert(i, result(i).replaceAll(\"(?<=\\\\D)(?=[1-9]\\\\d$)\", \"Two\"))\n            }\n            if (result(i) >= 1000l.toLong && result(i) < 10000l.toLong) {\n                result(i) = result(i).toString.replaceAll(\"\\\\D\", \"\")\n                newArray.insert(i, result(i).replaceAll(\"(?<=\\\\D)(?=[1-9]\\\\d\\\\d)$\", \"Three\"))\n            }\n            if (result(i) >= 10000l.toLong && result(i) < 100000l.toLong) {\n                result(i) = result(i).toString.replaceAll(\"\\\\D\", \"\")\n                newArray.insert(i, result(i).replaceAll(\"(?<=\\\\D)(?=[1-9]\\\\d\\\\d)\\\\d$\", \"Four\"))\n            }\n            if (result(i) >= 100000l.toLong && result(i) < 1000000l.toLong) {\n                result(i) = result(i).toString.replaceAll(\"\\\\D\", \"\")\n                newArray.insert(i, result(i).replaceAll(\"(?<=\\\\D)(?=[1-9]\\\\d\\\\d)\\\\d\\\\d$\", \"Five\"))\n            }\n            if (result(i) >= 1000000l.toLong && result(i) < 10000000l.toLong) {\n                result(i) = result(i).toString.replaceAll(\"\\\\D\", \"\")\n                newArray.insert(i, result(i).replaceAll(\"(?<=\\\\D)(?=[1-9]\\\\d\\\\d)\\\\d\\\\d\\\\d$\", \"Six\"))\n            }\n            if (result(i) >= 10000000l.toLong && result(i) < 100000000l.toLong) {\n                result(i) = result(i).toString.replaceAll(\"\\\\D\", \"\")\n                newArray.insert(i, result(i).replaceAll(\"(?<=\\\\D)(?=[1-9]\\\\d\\\\d)\\\\d\\\\d\\\\d\", \"Seven\"))\n            }\n            if (result(i) >= 100000000l.toLong && result(i) < 1000000000l.toLong) {\n                result(i) = result(i).toString.replaceAll\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpfsyzhibk.scala:62:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m62 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpfsyzhibk.scala:23:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m                result(i) = result(i).toString.replaceAll(\u001b[31m\"\\\\D\"\u001b[0m, \u001b[31m\"\"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue update is not a member of List[Long] - did you mean result.updated?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpfsyzhibk.scala:24:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m                newArray.insert(i, result(i).replaceAll(\u001b[31m\"(?<=\\\\D)(?=[1-9]$)\"\u001b[0m, \u001b[31m\"One\"\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue insert is not a member of List[Long] - did you mean newArray.init?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpfsyzhibk.scala:24:45 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m                newArray.insert(i, result(i).replaceAll(\u001b[31m\"(?<=\\\\D)(?=[1-9]$)\"\u001b[0m, \u001b[31m\"One\"\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                                   ^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                value replaceAll is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpfsyzhibk.scala:27:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m                result(i) = result(i).toString.replaceAll(\u001b[31m\"\\\\D\"\u001b[0m, \u001b[31m\"\"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue update is not a member of List[Long] - did you mean result.updated?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpfsyzhibk.scala:28:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m                newArray.insert(i, result(i).replaceAll(\u001b[31m\"(?<=\\\\D)(?=[1-9]\\\\d$)\"\u001b[0m, \u001b[31m\"Two\"\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue insert is not a member of List[Long] - did you mean newArray.init?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpfsyzhibk.scala:28:45 ------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m ",
      "stdout": "",
      "timestamp": 1660010439
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        val byIndex : mutable.Map[Int, String] = mutable.Map()\n        for (i <- 0 until arr.length) {\n            if (arr(i) <= 9) {\n                byIndex ++= (i.toString.toLong -> \"One\")\n            } else if (arr(i) > 9) {\n                byIndex ++= (i.toString.toLong -> \"Five\")\n            } else if (arr(i) >= 1 && arr(i) <= 9) {\n                byIndex ++= (i.toString.toLong -> \"Two\")\n            } else if (arr(i) >= 10 && arr(i) <= 19) {\n                byIndex ++= (i.toString.toLong -> \"Three\")\n            } else if (arr(i) >= 20 && arr(i) <= 99) {\n                byIndex ++= (i.toString.toLong -> \"Four\")\n            } else if (arr(i) >= 100 && arr(i) <= 999) {\n                byIndex ++= (i.toString.toLong -> \"Six\")\n            } else if (arr(i) >= 1000 && arr(i) <= 9999) {\n                byIndex ++= (i.toString.toLong -> \"Seven\")\n            } else if (arr(i) >= 10000 && arr(i) <= 99999) {\n                byIndex ++= (i.toString.toLong -> \"Eight\")\n            } else if (arr(i) >= 1000000 && arr(i) <= 999999999) {\n                byIndex ++= (i.toString.toLong -> \"Nine\")\n            } else {\n                byIndex ++= (i.toString.toLong -> \"Zero\")\n            }\n        }\n        arr.map(i => byIndex(i))\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpw1gq2ij1.scala:17:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbyIndex\u001b[0m : mutable.Map[\u001b[35mInt\u001b[0m, \u001b[35mString\u001b[0m] = mutable.Map()\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpw1gq2ij1.scala:17:49 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbyIndex\u001b[0m : mutable.Map[\u001b[35mInt\u001b[0m, \u001b[35mString\u001b[0m] = mutable.Map()\n\u001b[31m\u001b[31m   |\u001b[0m                                                 ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                                 Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660010433
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        if (arr.isEmpty) List()\n        else arr.sortWith(_ < _) // Sort list ascending\n                 .reverse            // Reverse the list\n                 .map { x =>      // Map the sorted list into string array\n                     if (x < 10) Array(One, Two, Three, Four, Five, Six, Seven, Eight, Nine).drop(10 - x).take(1).mkString(\"\")\n                     else if (x <= 99) Array(One, Two, Three, Four, Five, Six).drop(10 - x).take(2).mkString(\"\")\n                     else Array(One, Two, Three, Four, Five, Six).drop(10 - x).take(3).mkString(\"\")\n                 }\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpmpbhqw50.scala:21:39 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m                     \u001b[33mif\u001b[0m (x < \u001b[31m10\u001b[0m) Array(One, Two, Three, Four, Five, Six, Seven, Eight, Nine).drop(\u001b[31m10\u001b[0m - x).take(\u001b[31m1\u001b[0m).mkString(\u001b[31m\"\"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                       ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                       Not found: One\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpmpbhqw50.scala:21:44 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m                     \u001b[33mif\u001b[0m (x < \u001b[31m10\u001b[0m) Array(One, Two, Three, Four, Five, Six, Seven, Eight, Nine).drop(\u001b[31m10\u001b[0m - x).take(\u001b[31m1\u001b[0m).mkString(\u001b[31m\"\"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                            ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                            Not found: Two\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpmpbhqw50.scala:21:49 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m                     \u001b[33mif\u001b[0m (x < \u001b[31m10\u001b[0m) Array(One, Two, Three, Four, Five, Six, Seven, Eight, Nine).drop(\u001b[31m10\u001b[0m - x).take(\u001b[31m1\u001b[0m).mkString(\u001b[31m\"\"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                                 ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                                 Not found: Three\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpmpbhqw50.scala:21:56 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m                     \u001b[33mif\u001b[0m (x < \u001b[31m10\u001b[0m) Array(One, Two, Three, Four, Five, Six, Seven, Eight, Nine).drop(\u001b[31m10\u001b[0m - x).take(\u001b[31m1\u001b[0m).mkString(\u001b[31m\"\"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                                        ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                                        Not found: Four\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation ava",
      "stdout": "",
      "timestamp": 1660010431
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        arr.sortWith((x,y) => x < y) match {\n            case Nil => Nil\n            case head :: tail =>\n                val len = head.asInstanceOf[Long]\n                val reversed = tail.map { n =>\n                    if (n < 10) {\n                        n.toString\n                    } else if (n < 100) {\n                        val r = n/10\n                        val l = n % 10\n                        \"${r}${l.toString}\"\n                    } else if (n < 1000) {\n                        val r = n/100\n                        val l = n % 100\n                        \"${r}${l.toString}\"\n                    } else if (n < 10000) {\n                        val r = n/1000\n                        val l = n % 1000\n                        \"${r}${l.toString}\"\n                    } else {\n                        val r = n/10000\n                        val l = n % 10000\n                        \"${r}${l.toString}\"\n                    }\n                }.reverse\n\n                val result = reversed.map{n => byLength(n)}\n                result match {\n                    case Nil => result\n                    case head :: rest => head :: rest\n                }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp2sxz78bk.scala:43:56 --------------------\u001b[0m\u001b[0m\n\u001b[31m43 |\u001b[0m                \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = reversed.map{\u001b[36mn\u001b[0m => byLength(n)}\n\u001b[31m\u001b[31m   |\u001b[0m                                                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                  Found:    (n : String)\n\u001b[31m   |\u001b[0m                                                  Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp2sxz78bk.scala:45:32 --------------------\u001b[0m\u001b[0m\n\u001b[31m45 |\u001b[0m                    \u001b[33mcase\u001b[0m Nil => result\n\u001b[31m\u001b[31m   |\u001b[0m                                ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                Found:    \u001b[1m\u001b[31m(\u001b[0m\u001b[1m\u001b[31mresult\u001b[0m\u001b[1m\u001b[31m \u001b[0m\u001b[1m\u001b[31m:\u001b[0m\u001b[1m\u001b[31m \u001b[0mList[\u001b[1m\u001b[31mList\u001b[0m\u001b[1m\u001b[31m[\u001b[0mString\u001b[1m\u001b[31m]\u001b[0m]\u001b[1m\u001b[31m)\u001b[0m\n\u001b[31m   |\u001b[0m                                Required: List[String]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp2sxz78bk.scala:46:41 --------------------\u001b[0m\u001b[0m\n\u001b[31m46 |\u001b[0m                    \u001b[33mcase\u001b[0m head :: rest => head :: rest\n\u001b[31m\u001b[31m   |\u001b[0m                                         ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                         Found:    List[\u001b[1m\u001b[31mList\u001b[0m\u001b[1m\u001b[31m[\u001b[0mString\u001b[1m\u001b[31m]\u001b[0m]\n\u001b[31m   |\u001b[0m                                         Required: List[String]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660010438
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        var output = List.empty[String]\n        arr.foreach( x => {\n            var temp = \"\"\n            while(x>0){\n              temp += getDigit(x%10)\n              x = x/10\n            }\n            output += getName(temp.reverse)\n        })\n        output\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpjpj_ore9.scala:21:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m              temp += getDigit(x%\u001b[31m10\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value += is not a member of String - did you mean String.!=?\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpjpj_ore9.scala:21:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m              temp += getDigit(x%\u001b[31m10\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      Not found: getDigit\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmpjpj_ore9.scala:22:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m              x = x/\u001b[31m10\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              Reassignment to val x\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpjpj_ore9.scala:24:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m            output += getName(temp.reverse)\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue += is not a member of List[String] - did you mean List[String].!=?\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpjpj_ore9.scala:24:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m            output += getName(temp.reverse)\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      Not found: getName\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n5 errors found\n",
      "stdout": "",
      "timestamp": 1660010436
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        if (arr.isEmpty) List()\n        else {\n            val starts = arr.takeWhile(i => i <= 9)\n            val ends = arr.drop(starts.size)\n            val list = new scala.collection.mutable.ListBuffer[String]()\n            var i = 0\n            while (i < starts.size && i < ends.size) {\n                if (starts(i) == ends(i)) {\n                    list += List(starts(i).toString() + \"One\")\n                    i += 1\n                } else {\n                    list += List(starts(i).toString() + \"Two\")\n                    i += 1\n                }\n            }\n            if (i < starts.size) list += List(starts(i).toString() + \"One\")\n            if (i < ends.size) list += List(ends(i).toString() + \"One\")\n            list.toList\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp4ws8a43d.scala:25:32 --------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m                    list += List(starts(i).toString() + \u001b[31m\"One\"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                            Found:    \u001b[1m\u001b[31mList\u001b[0m\u001b[1m\u001b[31m[\u001b[0mString\u001b[1m\u001b[31m]\u001b[0m\n\u001b[31m   |\u001b[0m                            Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp4ws8a43d.scala:28:32 --------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m                    list += List(starts(i).toString() + \u001b[31m\"Two\"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                            Found:    \u001b[1m\u001b[31mList\u001b[0m\u001b[1m\u001b[31m[\u001b[0mString\u001b[1m\u001b[31m]\u001b[0m\n\u001b[31m   |\u001b[0m                            Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp4ws8a43d.scala:32:45 --------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m            \u001b[33mif\u001b[0m (i < starts.size) list += List(starts(i).toString() + \u001b[31m\"One\"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                         Found:    \u001b[1m\u001b[31mList\u001b[0m\u001b[1m\u001b[31m[\u001b[0mString\u001b[1m\u001b[31m]\u001b[0m\n\u001b[31m   |\u001b[0m                                         Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp4ws8a43d.scala:33:43 --------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m            \u001b[33mif\u001b[0m (i < ends.size) list += List(ends(i).toString() + \u001b[31m\"One\"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                       Found:    \u001b[1m\u001b[31mList\u001b[0m\u001b[1m\u001b[31m[\u001b[0mString\u001b[1m\u001b[31m]\u001b[0m\n\u001b[31m   |\u001b[0m          ",
      "stdout": "",
      "timestamp": 1660010438
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        arr.filter(i => i >= 1l && i <= 9l).sortWith((a, b) => b - a).reverse.map(i => \n            val num = i.toString.toInt\n            val name = if (num == 1) \"One\" else if (num == 2) \"Two\" else if (num == 3) \"Three\" else if (num == 4) \n                \"Four\" else if (num == 5) \"Five\" else if (num == 6) \"Six\" else if (num == 7) \"Seven\" else if (num == 8)\n                \"Eight\" else \"Nine\"\n            s\"$name\"\n        )\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp1lllmc3z.scala:17:63 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        arr.filter(\u001b[36mi\u001b[0m => i >= \u001b[31m1l\u001b[0m && i <= \u001b[31m9l\u001b[0m).sortWith((\u001b[36ma\u001b[0m, \u001b[36mb\u001b[0m) => b - a).reverse.map(\u001b[36mi\u001b[0m => \n\u001b[31m\u001b[31m   |\u001b[0m                                                               ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                                       Found:    Long\n\u001b[31m   |\u001b[0m                                                       Required: Boolean\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010437
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        val result = arr filter { x => x > 0 && x < 9 } map { x => getNumber(x) }\n        result.sorted.reverse foreach { x => x.toString.replaceFirst(\"0\", \"One\").replaceFirst(\"1\", \"Two\").replaceFirst(\"2\", \"Three\")\n                                    .replaceFirst(\"3\", \"Four\").replaceFirst(\"4\", \"Five\").replaceFirst(\"5\", \"Six\")\n                                    .replaceFirst(\"6\", \"Seven\").replaceFirst(\"7\", \"Eight\").replaceFirst(\"8\", \"Nine\") }\n        if (arr.isEmpty) {\n            result.foreach(println)\n        } else {\n            result.foreach(println)\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp1siuwsdc.scala:17:67 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = arr filter { \u001b[36mx\u001b[0m => x > \u001b[31m0\u001b[0m && x < \u001b[31m9\u001b[0m } map { \u001b[36mx\u001b[0m => getNumber(x) }\n\u001b[31m\u001b[31m   |\u001b[0m                                                                   ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                                    Not found: getNumber\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- Error: /tmp/tmp1siuwsdc.scala:18:21 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        result.sorted.reverse foreach { \u001b[36mx\u001b[0m => x.toString.replaceFirst(\u001b[31m\"0\"\u001b[0m, \u001b[31m\"One\"\u001b[0m).replaceFirst(\u001b[31m\"1\"\u001b[0m, \u001b[31m\"Two\"\u001b[0m).replaceFirst(\u001b[31m\"2\"\u001b[0m, \u001b[31m\"Three\"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                     ^\u001b[0m\n\u001b[31m   |\u001b[0mambiguous given instances: both \u001b[33mobject\u001b[0m \u001b[35mByte\u001b[0m in \u001b[33mobject\u001b[0m \u001b[35mOrdering\u001b[0m and \u001b[33mobject\u001b[0m \u001b[35mChar\u001b[0m in \u001b[33mobject\u001b[0m \u001b[35mOrdering\u001b[0m match type Ordering[B] of parameter ord of \u001b[33mmethod\u001b[0m \u001b[35msorted\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mStrictOptimizedSeqOps\u001b[0m\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660010434
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        // Get the digits in reverse order\n        val digits = arr.foldLeft(List.empty[String]){\n            case (res, num) => res ++ List.fill(9 - num.length + 1)(s\"$num\")\n        }\n        // Replace the digits by their name\n        val result = digits.map((i) => List(\n            List(1l, \"One\"),\n            List(2l, \"Two\"),\n            List(3l, \"Three\"),\n            List(4l, \"Four\"),\n            List(5l, \"Five\"),\n            List(6l, \"Six\"),\n            List(7l, \"Seven\"),\n            List(8l, \"Eight\"),\n            List(9l, \"Nine\")\n        )(i.toString).mkString(\", \")).reverse.flatten\n        result.size == arr.size match {\n            case true => result\n            case false => throw new IllegalArgumentException(s\"The list has strange numbers: ${arr.map{_.toString}.mkString(\", \")}\")\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpnxbj68x3.scala:19:56 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m            \u001b[33mcase\u001b[0m (res, num) => res ++ List.fill(\u001b[31m9\u001b[0m - num.length + \u001b[31m1\u001b[0m)(\u001b[31ms\"\u001b[0m$num\u001b[31m\"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                                    ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                    value length is not a member of Long\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpnxbj68x3.scala:32:10 --------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        )(i.toString).mkString(\u001b[31m\", \"\u001b[0m)).reverse.flatten\n\u001b[31m\u001b[31m   |\u001b[0m          ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m          Found:    String\n\u001b[31m   |\u001b[0m          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpnxbj68x3.scala:34:25 --------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m            \u001b[33mcase\u001b[0m \u001b[31mtrue\u001b[0m => result\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Found:    (result : List[Char])\n\u001b[31m   |\u001b[0m                         Required: List[String]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660010438
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        if(arr.isEmpty) List() else arr.groupBy(x => (x - 1).toInt).mapValues(_.map(_.toString).reverse).map(s => (s.dropWhile(c => !(c.isDigit)) match {case x if (x == \"\") \"\" else byLength(s)})) \n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpftnj97u6.scala:17:173 --------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        \u001b[33mif\u001b[0m(arr.isEmpty) List() \u001b[33melse\u001b[0m arr.groupBy(\u001b[36mx\u001b[0m => (x - \u001b[31m1\u001b[0m).toInt).mapValues(_.map(_.toString).reverse).map(\u001b[36ms\u001b[0m => (s.dropWhile(\u001b[36mc\u001b[0m => !(c.isDigit)) \u001b[33mmatch\u001b[0m {\u001b[33mcase\u001b[0m x \u001b[33mif\u001b[0m (x == \u001b[31m\"\"\u001b[0m) \u001b[31m\"\"\u001b[0m \u001b[33melse\u001b[0m byLength(s)})) \n\u001b[31m\u001b[31m   |\u001b[0m                                                                                                                                                                             ^\u001b[0m\n\u001b[31m   |\u001b[0m                                 '=>' expected, but string literal found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpftnj97u6.scala:17:117 -----------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        \u001b[33mif\u001b[0m(arr.isEmpty) List() \u001b[33melse\u001b[0m arr.groupBy(\u001b[36mx\u001b[0m => (x - \u001b[31m1\u001b[0m).toInt).mapValues(_.map(_.toString).reverse).map(\u001b[36ms\u001b[0m => (s.dropWhile(\u001b[36mc\u001b[0m => !(c.isDigit)) \u001b[33mmatch\u001b[0m {\u001b[33mcase\u001b[0m x \u001b[33mif\u001b[0m (x == \u001b[31m\"\"\u001b[0m) \u001b[31m\"\"\u001b[0m \u001b[33melse\u001b[0m byLength(s)})) \n\u001b[31m\u001b[31m   |\u001b[0m                                                                                                                   ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  value dropWhile is not a member of (Int, List[String])\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660010437
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        val l = arr.length\n        val d = (1 to 9).filter(_ <= l).map(x => x + \"One\")\n        val r = (1 to 9).filter(_ >= l).map(x => x + \"Two\")\n        val f = (1 to 9).filter(_ > l).map(x => x + \"Three\")\n        val n = (1 to 9).filter(_ < l).map(x => x + \"Four\")\n        val o = (1 to 9).filter(_ == l).map(x => x + \"Five\")\n        val s = (1 to 9).filter(_ != l).map(x => x + \"Six\")\n        val e = (1 to 9).filter(_ > l).map(x => x + \"Seven\")\n        val n = (1 to 9).filter(_ < l).map(x => x + \"Eight\")\n        val i = (1 to 9).filter(_ == l).map(x => x + \"Nine\")\n        if (arr.isEmpty) List()\n        else (d ++ r ++ f ++ n ++ o ++ s ++ e ++ i ++ arr.reverse).toList\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpa8gwyr_3.scala:25:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mn\u001b[0m = (\u001b[31m1\u001b[0m to \u001b[31m9\u001b[0m).filter(_ < l).map(\u001b[36mx\u001b[0m => x + \u001b[31m\"Eight\"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mn is already defined as \u001b[33mvalue\u001b[0m \u001b[35mn\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpa8gwyr_3.scala:28:67 --------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        \u001b[33melse\u001b[0m (d ++ r ++ f ++ n ++ o ++ s ++ e ++ i ++ arr.reverse).toList\n\u001b[31m\u001b[31m   |\u001b[0m             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m             Found:    List[Matchable]\n\u001b[31m   |\u001b[0m             Required: List[String]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660010438
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        var rev = arr.toList.reverse\n        for (i <- 0 until rev.length until 9) {\n            val d = rev(i).toString.toInt\n            rev = rev filter (_ != d)\n            rev(d) = s\"${ One.asInstanceOf[AnyRef] }\"\n        }\n        rev.reverse.foreach(println)\n        rev\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp229boqb0.scala:18:37 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until rev.length until \u001b[31m9\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        value until is not a member of Range - did you mean Range.unzip?\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp229boqb0.scala:24:8 ---------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        rev\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Found:    (rev : List[Long])\n\u001b[31m   |\u001b[0m        Required: List[String]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660010438
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        if(arr.isEmpty) {\n            return Nil\n        }\n        if(arr.length == 1) {\n            val i = arr(0)\n            if(i != 1l) {\n                return Nil\n            }\n            val name = List(One, Two, Three, Four, Five, Six, Seven, Eight, Nine)\n            return name.map(name => name(i)).toList\n        }\n        val len = arr(0)\n        val min = arr(1).min(len)\n        val max = arr(1).max(len)\n        val min = Array(1l, 2l, 3l, 4l, 5l, 6l, 7l, 8l, 9l)\n        val max = Array(9l, 8l, 7l, 6l, 5l, 4l, 3l, 2l, 1l)\n        val minName = Array(One, Two, Three, Four, Five, Six, Seven, Eight, Nine)\n        val maxName = Array(Nine, Eight, Seven, Six, Five, Four, Three, Two, One)\n        val minLen = min.map(name => name.toLong).toList\n        val maxLen = max.map(name => name.toLong).toList\n        if(minLen.nonEmpty) {\n            if(minLen.contains(len)) {\n                return Nil\n            }\n            else {\n                val temp = minName.zipWithIndex.filter(_._1 == len)\n                if(temp.isEmpty) {\n                    val maxName = maxName.dropWhile(_._1 != len)\n                    if(maxName.isEmpty) {\n                        return Nil\n                    }\n                    else {\n                        return maxName.map(name => name.toLong).toList\n                    }\n                }\n                else {\n                    val index = temp.map(x => x._2).toList(0)\n                    return minName.map(name => name.toLong).toList.update(index, maxName.toList)\n                }\n            }\n        }\n        else {\n            if(maxLen.nonEmpty) {\n                if(maxLen.contains(len)) {\n                    return Nil\n                }\n                else {\n                    val temp = maxName.zipWithIndex.filter(_._1 == len)\n                    if(temp.isEmpty) {\n                        val minName = minName.dropWhile(_._1 != len)\n                        if(minName.isEmpty) {\n                            return Nil\n                        }\n                        else {\n                            return minName.map(name => name.toLong).toList\n                        }\n                    }\n                    else {\n                        val index = temp.map(x => x._2).toList(0)\n                        return maxName.map(name => name.toLong).toList.update(index, minName.toList)\n                    }\n                }\n            }\n            else {\n                val temp = minName.dropWhile(_._1 != len).zip\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpqsiedxf3.scala:92:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m92 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpqsiedxf3.scala:31:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmin\u001b[0m = Array(\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmin is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmin\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpqsiedxf3.scala:32:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmax\u001b[0m = Array(\u001b[31m9l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m6l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m1l\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmax is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmax\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpqsiedxf3.scala:25:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mname\u001b[0m = List(One, Two, Three, Four, Five, Six, Seven, Eight, Nine)\n\u001b[31m\u001b[31m   |\u001b[0m                            ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                            Not found: One\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpqsiedxf3.scala:25:33 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mname\u001b[0m = List(One, Two, Three, Four, Five, Six, Seven, Eight, Nine)\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Not found: Two\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation avail",
      "stdout": "",
      "timestamp": 1660010439
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        var strArray = new mutable.ListBuffer[String]()\n        if (arr.nonEmpty) {\n            // sort from largest to smallest then reverse the list.\n            val sorted = arr.sortBy(l => (l % 10).abs).reverse\n            sorted foreach { l =>\n                val digit = l % 10\n                strArray.append(s\"${digit}${names.find(f => f.toInt == digit).map(\"One\").getOrElse(\"\")}\")\n            }\n            strArray.toList\n        } else {\n            strArray\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpd3pei875.scala:17:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mstrArray\u001b[0m = \u001b[33mnew\u001b[0m mutable.ListBuffer[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                           ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                           Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010435
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        if (arr.isEmpty) Nil\n        else if (arr.size > 9) arr.reverse.map(x => (x % 10 -> x.toString)).toList\n        else arr.reverse.map(x => (x % 10 -> \"One\")).toList\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp8185tghj.scala:18:76 --------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (arr.size > \u001b[31m9\u001b[0m) arr.reverse.map(x => (x % \u001b[31m10\u001b[0m -> x.toString)).toList\n\u001b[31m\u001b[31m   |\u001b[0m                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                               Found:    List[\u001b[1m\u001b[31m(\u001b[0m\u001b[1m\u001b[31mLong\u001b[0m\u001b[1m\u001b[31m,\u001b[0m\u001b[1m\u001b[31m \u001b[0mString\u001b[1m\u001b[31m)\u001b[0m]\n\u001b[31m   |\u001b[0m                               Required: List[String]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp8185tghj.scala:19:53 --------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33melse\u001b[0m arr.reverse.map(x => (x % \u001b[31m10\u001b[0m -> \u001b[31m\"One\"\u001b[0m)).toList\n\u001b[31m\u001b[31m   |\u001b[0m             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m             Found:    List[\u001b[1m\u001b[31m(\u001b[0m\u001b[1m\u001b[31mLong\u001b[0m\u001b[1m\u001b[31m,\u001b[0m\u001b[1m\u001b[31m \u001b[0mString\u001b[1m\u001b[31m)\u001b[0m]\n\u001b[31m   |\u001b[0m             Required: List[String]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660010440
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        val rev = arr.sortWith(_.toLong < _.toLong)\n        rev.reverse.foreach { i =>\n            val str = i.toString.replaceAll(\"0\",\"One\").replaceAll(\"1\",\"Two\").replaceAll(\"2\",\"Three\").replaceAll(\"3\",\"Four\")\n            val str = str.replaceAll(\"4\",\"Five\").replaceAll(\"5\",\"Six\").replaceAll(\"6\",\"Seven\").replaceAll(\"7\",\"Eight\").replaceAll(\"8\",\"Nine\")\n            str\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp5ld6e57c.scala:20:16 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mstr\u001b[0m = str.replaceAll(\u001b[31m\"4\"\u001b[0m,\u001b[31m\"Five\"\u001b[0m).replaceAll(\u001b[31m\"5\"\u001b[0m,\u001b[31m\"Six\"\u001b[0m).replaceAll(\u001b[31m\"6\"\u001b[0m,\u001b[31m\"Seven\"\u001b[0m).replaceAll(\u001b[31m\"7\"\u001b[0m,\u001b[31m\"Eight\"\u001b[0m).replaceAll(\u001b[31m\"8\"\u001b[0m,\u001b[31m\"Nine\"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mstr is already defined as \u001b[33mvalue\u001b[0m \u001b[35mstr\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010438
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n      val map = List(\n        (1l.toLong, \"One\"),\n        (2l.toLong, \"Two\"),\n        (3l.toLong, \"Three\"),\n        (4l.toLong, \"Four\"),\n        (5l.toLong, \"Five\"),\n        (6l.toLong, \"Six\"),\n        (7l.toLong, \"Seven\"),\n        (8l.toLong, \"Eight\"),\n        (9l.toLong, \"Nine\")\n      )\n      arr.foldLeft(map.head){\n        case ((acc, curr), v) => acc.map{\n          case ((_, v1), v2) => acc.map{\n            case ((v3, v3l), v4) => if((v3l.toInt == v.toInt) && (v3 == v4)) v2 else v3\n          }\n        }.head\n      }.map{\n        case ((v, _), v1) => map.find(_._1 == v).map(_._2).toString.reverse\n      }.flatten\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpzydlca_x.scala:29:37 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m        \u001b[33mcase\u001b[0m ((acc, curr), v) => acc.map{\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 value map is not a member of Long\n\u001b[31m\u001b[31m-- [E081] Type Error: /tmp/tmpzydlca_x.scala:35:8 ------------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m        \u001b[33mcase\u001b[0m ((v, _), v1) => map.find(_._1 == v).map(_._2).toString.reverse\n\u001b[31m\u001b[31m   |\u001b[0m        ^\u001b[0m\n\u001b[31m   |\u001b[0mMissing parameter type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mI could not infer the type of the parameter x$1 of expanded function:\n\u001b[31m   |\u001b[0mx$1 => \n\u001b[31m   |\u001b[0m  x$1\u001b[33m match \u001b[0m\n\u001b[31m   |\u001b[0m    {\n\u001b[31m   |\u001b[0m      \u001b[33mcase \u001b[0m((v, _), v1) => \n\u001b[31m   |\u001b[0m        map.find(_$1 => _$1._1 == v).map(_$2 => _$2._2).toString.reverse\n\u001b[31m   |\u001b[0m    }.\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpzydlca_x.scala:35:46 ------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m        \u001b[33mcase\u001b[0m ((v, _), v1) => map.find(_._1 == v).map(_._2).toString.reverse\n\u001b[31m\u001b[31m   |\u001b[0m                                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                                              Not found: v\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660010442
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        val m = arr.head\n        val n = arr.tail\n        if (m.toLong < 1 || m.toLong > 9) return List()\n        if (n.isEmpty) return List()\n        if (n.head.asInstanceOf[Int].isNaN) return List()\n        if (n.last.asInstanceOf[Int].isNaN) return List()\n        var i = n.size\n        val res = ListBuffer[String]()\n        while(i > 0) {\n            val d = n.head\n            d match {\n                case x if x.asInstanceOf[Int] == x => d match {\n                    case 1l if d > 9 => res.reverse()\n                    case _ => res.append((9 - d).asInstanceOf[String])\n                }\n                case _ => res.reverse().append((9 - d).asInstanceOf[String])\n            }\n            i -= 1\n        }\n        if (res.isEmpty) return List()\n        res.reverse().mkString(\"\")\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmprl7hsvfu.scala:21:37 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mif\u001b[0m (n.head.asInstanceOf[\u001b[35mInt\u001b[0m].isNaN) \u001b[33mreturn\u001b[0m List()\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Int.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          double2Double(n.head.asInstanceOf[\u001b[35mInt\u001b[0m])\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmprl7hsvfu.scala:22:37 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mif\u001b[0m (n.last.asInstanceOf[\u001b[35mInt\u001b[0m].isNaN) \u001b[33mreturn\u001b[0m List()\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Int.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          double2Double(n.last.asInstanceOf[\u001b[35mInt\u001b[0m])\n\u001b[31m\u001b[31m-- Error: /tmp/tmprl7hsvfu.scala:29:51 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m                    \u001b[33mcase\u001b[0m \u001b[31m1l\u001b[0m \u001b[33mif\u001b[0m d > \u001b[31m9\u001b[0m => res.reverse()\n\u001b[31m\u001b[31m   |\u001b[0m                                        ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmissing argument for parameter i of \u001b[33mmethod\u001b[0m \u001b[35mapply\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mListBuffer\u001b[0m: (i: Int): String\n\u001b[31m\u001b[31m-- Error: /tmp/tmprl7hsvfu.scala:32:37 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m                \u001b[33mcase\u001b[0m _ => res.reverse().append((\u001b[31m9\u001b[0m - d).asInstanceOf[String])\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmissing argument for parameter i of \u001b[33mmethod\u001b[0m \u001b[35mapply\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mListBuffer\u001b[0m: (i: Int): String\n\u001b[31m\u001b[31m-- Error: /tmp/tmprl7hsvfu.scala:37:19 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m        res.reverse().mkString(\u001b[31m\"\"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmissing argument for parameter i of \u001b[",
      "stdout": "",
      "timestamp": 1660010442
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        if (arr.isEmpty) List()\n        else (arr map { x => if(x < 1 || x > 9) return \"One\"; if(x <= 9 && x >= 1) \"Ten\"; if(x <= 9 && x >= 10) \"Twenty\" else \"One\" }).toList.reverse\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmppsiqr55k.scala:18:55 --------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33melse\u001b[0m (arr map { x => \u001b[33mif\u001b[0m(x < \u001b[31m1\u001b[0m || x > \u001b[31m9\u001b[0m) \u001b[33mreturn\u001b[0m \u001b[31m\"One\"\u001b[0m; \u001b[33mif\u001b[0m(x <= \u001b[31m9\u001b[0m && x >= \u001b[31m1\u001b[0m) \u001b[31m\"Ten\"\u001b[0m; \u001b[33mif\u001b[0m(x <= \u001b[31m9\u001b[0m && x >= \u001b[31m10\u001b[0m) \u001b[31m\"Twenty\"\u001b[0m \u001b[33melse\u001b[0m \u001b[31m\"One\"\u001b[0m }).toList.reverse\n\u001b[31m\u001b[31m   |\u001b[0m                                                       ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                              Found:    (\u001b[32m\"One\"\u001b[0m : String)\n\u001b[31m   |\u001b[0m                                              Required: List[String]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[33m\u001b[33m-- [E129] Potential Issue Warning: /tmp/tmppsiqr55k.scala:18:83 ----------------\u001b[0m\u001b[0m\n\u001b[33m18 |\u001b[0m        \u001b[33melse\u001b[0m (arr map { x => \u001b[33mif\u001b[0m(x < \u001b[31m1\u001b[0m || x > \u001b[31m9\u001b[0m) \u001b[33mreturn\u001b[0m \u001b[31m\"One\"\u001b[0m; \u001b[33mif\u001b[0m(x <= \u001b[31m9\u001b[0m && x >= \u001b[31m1\u001b[0m) \u001b[31m\"Ten\"\u001b[0m; \u001b[33mif\u001b[0m(x <= \u001b[31m9\u001b[0m && x >= \u001b[31m10\u001b[0m) \u001b[31m\"Twenty\"\u001b[0m \u001b[33melse\u001b[0m \u001b[31m\"One\"\u001b[0m }).toList.reverse\n\u001b[33m\u001b[33m   |\u001b[0m                                                                                   ^^^^^\u001b[0m\n\u001b[33m   |\u001b[0mA pure expression does nothing in statement position; you may be omitting necessary parentheses\n\u001b[33m   |\u001b[0m\n\u001b[33m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 warning found\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010444
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        val list = arr.sortWith(_.compareTo(_) < 0).map(_.toString.replaceFirst(\"^0\", One).replaceFirst(\"^1\", Two).replaceFirst(\"^2\", Three).replaceFirst(\"^3\", Four).replaceFirst(\"^4\", Five).replaceFirst(\"^5\", Six).replaceFirst(\"^6\", Seven).replaceFirst(\"^7\", Eight).replaceFirst(\"^8\", Nine))\n        list.isEmpty match {\n            case true => List()\n            case false => list\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpsey2fjk9.scala:17:86 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mlist\u001b[0m = arr.sortWith(_.compareTo(_) < \u001b[31m0\u001b[0m).map(_.toString.replaceFirst(\u001b[31m\"^0\"\u001b[0m, One).replaceFirst(\u001b[31m\"^1\"\u001b[0m, Two).replaceFirst(\u001b[31m\"^2\"\u001b[0m, Three).replaceFirst(\u001b[31m\"^3\"\u001b[0m, Four).replaceFirst(\u001b[31m\"^4\"\u001b[0m, Five).replaceFirst(\u001b[31m\"^5\"\u001b[0m, Six).replaceFirst(\u001b[31m\"^6\"\u001b[0m, Seven).replaceFirst(\u001b[31m\"^7\"\u001b[0m, Eight).replaceFirst(\u001b[31m\"^8\"\u001b[0m, Nine))\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                      ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                                          Not found: One\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpsey2fjk9.scala:17:110 -----------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mlist\u001b[0m = arr.sortWith(_.compareTo(_) < \u001b[31m0\u001b[0m).map(_.toString.replaceFirst(\u001b[31m\"^0\"\u001b[0m, One).replaceFirst(\u001b[31m\"^1\"\u001b[0m, Two).replaceFirst(\u001b[31m\"^2\"\u001b[0m, Three).replaceFirst(\u001b[31m\"^3\"\u001b[0m, Four).replaceFirst(\u001b[31m\"^4\"\u001b[0m, Five).replaceFirst(\u001b[31m\"^5\"\u001b[0m, Six).replaceFirst(\u001b[31m\"^6\"\u001b[0m, Seven).replaceFirst(\u001b[31m\"^7\"\u001b[0m, Eight).replaceFirst(\u001b[31m\"^8\"\u001b[0m, Nine))\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                                              ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                                          Not found: Two\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpsey2fjk9.scala:17:134 -----------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mlist\u001b[0m = arr.sortWith(_.compareTo(_) < \u001b[31m0\u001b[0m).map(_.toString.replaceFirst(\u001b[31m\"^0\"\u001b[0m, One).replaceFirst(\u001b[31m\"^1\"\u001b[0m, Two).replaceFirst(\u001b[31m\"^2\"\u001b[0m, Three).replaceFirst(\u001b[31m\"^3\"\u001b[0m, Four).replaceFirst(\u001b[31m\"^4\"\u001b[0m, Five).replaceFirst(\u001b[31m\"^5\"\u001b[0m, Six).replaceFirst(\u001b[31m",
      "stdout": "",
      "timestamp": 1660010442
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        arr match {\n            case Nil => Nil\n            case x :: Nil => List(x % 10 match {\n                case 0 => \"Zero\"\n                case 1 => \"One\"\n                case 2 => \"Two\"\n                case 3 => \"Three\"\n                case 4 => \"Four\"\n                case 5 => \"Five\"\n                case 6 => \"Six\"\n                case 7 => \"Seven\"\n                case 8 => \"Eight\"\n                case 9 => \"Nine\"\n                case x => s\"$x\"\n            })\n            case x :: y :: z :: Nil => val z = byLength(z)\n                                val y = byLength(y)\n                                val x = byLength(x)\n                                val z = x :+ y\n                                List(z.length match {\n                                    case 0 => \"Zero\"\n                                    case 1 => \"One\"\n                                    case 2 => \"Two\"\n                                    case 3 => \"Three\"\n                                    case 4 => \"Four\"\n                                    case 5 => \"Five\"\n                                    case 6 => \"Six\"\n                                    case 7 => \"Seven\"\n                                    case 8 => \"Eight\"\n                                    case 9 => \"Nine\"\n                                    case _ => s\"${z.head}\"\n                                })\n            case x :: y :: z :: _ => val z = byLength(z)\n                                    val y = byLength(y)\n                                    val x = byLength(x)\n                                    val z = x :+ y\n                                    val z = z.map(x => x.toString.replace(\"0\", \"Zero\").replace(\"1\", \"One\").replace(\"2\", \"Two\").replace(\"3\", \"Three\").replace(\"4\", \"Four\").replace(\"5\", \"Five\").replace(\"6\", \"Six\").replace(\"7\", \"Seven\").replace(\"8\", \"Eight\").replace(\"9\", \"Nine\"))\n                                    val z = z.map(x => x.replace(\"0\", \"Zero\").replace(\"1\", \"One\").replace(\"2\", \"Two\").replace(\"3\", \"Three\").replace(\"4\", \"Four\").replace(\"5\", \"Five\").replace(\"6\", \"Six\").replace(\"7\", \"Seven\").replace(\"8\", \"Eight\").replace(\"9\", \"Nine\"))\n                                    z.map(x => x.replace(\"0\", \"Zero\").replace(\"1\", \"One\").replace(\"2\", \"Two\").replace(\"3\", \"Three\").replace(\"4\", \"Four\").replace(\"5\", \"Five\").replace(\"6\", \"Six\").replace(\"7\", \"Seven\").replace(\"8\", \"Eight\").replace(\"9\", \"Nine\"))\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpeze35orc.scala:35:36 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m                                \u001b[33mval\u001b[0m \u001b[36mz\u001b[0m = x :+ y\n\u001b[31m\u001b[31m   |\u001b[0m                                ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mz is already defined as \u001b[33mvalue\u001b[0m \u001b[35mz\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpeze35orc.scala:32:56 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m            \u001b[33mcase\u001b[0m x :: y :: z :: Nil => \u001b[33mval\u001b[0m z = byLength(z)\n\u001b[31m\u001b[31m   |\u001b[0m                                                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                                            Recursive \u001b[33mvalue\u001b[0m \u001b[35mz\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpeze35orc.scala:33:49 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m                                \u001b[33mval\u001b[0m \u001b[36my\u001b[0m = byLength(y)\n\u001b[31m\u001b[31m   |\u001b[0m                                                 ^\u001b[0m\n\u001b[31m   |\u001b[0m                                            Recursive \u001b[33mvalue\u001b[0m \u001b[35my\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpeze35orc.scala:34:49 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m                                \u001b[33mval\u001b[0m \u001b[36mx\u001b[0m = byLength(x)\n\u001b[31m\u001b[31m   |\u001b[0m                                                 ^\u001b[0m\n\u001b[31m   |\u001b[0m                                            Recursive \u001b[33mvalue\u001b[0m \u001b[35mx\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpeze35orc.scala:52:40 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m52 |\u001b[0m                                    \u001b[33mval\u001b[0m \u001b[36mz\u001b[0m = x :+ y\n\u001b[31m\u001b[31m   |\u001b[0m                                    ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0",
      "stdout": "",
      "timestamp": 1660010442
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        val list = arr.toList.sortWith((x, y) => x <= y)\n        val reversed = list.reverse\n        val result = reversed.map(_.toString).filter(_ != \" \").map(x => if (x equals \"One\") \"One\" else if (x equals \"Two\") \"Two\" else if (x equals \"Three\") \"Three\" else if (x equals \"Four\") \"Four\" else if (x equals \"Five\") \"Five\" else if (x equals \"Six\") \"Six\" else if (x equals \"Seven\") \"Seven\" else if (x equals \"Eight\") \"Eight\" else if (x equals \"Nine\") \"Nine\" else x)\n        list.filter(_ != \" \").toList.sortWith((x, y) => x <= y)\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmpa3mv2_pq.scala:20:20 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        list.filter(_ != \u001b[31m\" \"\u001b[0m).toList.sortWith((\u001b[36mx\u001b[0m, \u001b[36my\u001b[0m) => x <= y)\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Values of types Long and String cannot be compared with == or !=\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010445
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        val ls = arr.map { i => \n            if(i <= 9 && i >= 1) \"One\"\n            else if(i <= 9 && i >= 2) \"Two\"\n            else if(i <= 9 && i >= 3) \"Three\"\n            else if(i <= 9 && i >= 4) \"Four\"\n            else if(i <= 9 && i >= 5) \"Five\"\n            else if(i <= 9 && i >= 6) \"Six\"\n            else if(i <= 9 && i >= 7) \"Seven\"\n            else if(i <= 9 && i >= 8) \"Eight\"\n            else if(i <= 9 && i >= 9) \"Nine\"\n            else \"\"\n        }\n        arr.reverse.map(_.reverse.map(_.replaceAll(\"[^0-9]\", \"\"))).map(_.mkString).filter(_ != \"\").mkString(\",\")\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpqyup5n7_.scala:29:26 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m        arr.reverse.map(_.reverse.map(_.replaceAll(\u001b[31m\"[^0-9]\"\u001b[0m, \u001b[31m\"\"\u001b[0m))).map(_.mkString).filter(_ != \u001b[31m\"\"\u001b[0m).mkString(\u001b[31m\",\"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        value reverse is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpqyup5n7_.scala:29:73 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m        arr.reverse.map(_.reverse.map(_.replaceAll(\u001b[31m\"[^0-9]\"\u001b[0m, \u001b[31m\"\"\u001b[0m))).map(_.mkString).filter(_ != \u001b[31m\"\"\u001b[0m).mkString(\u001b[31m\",\"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                                                       ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue mkString is not a member of Nothing, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import Option.option2Iterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip2.lazyZip2ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip3.lazyZip3ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip4.lazyZip4ToIterable\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.list asScalaBuffer\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.properties AsScalaMap\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.enumeration AsScalaIterator\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.iterator asScala\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.map AsScalaConcurrentMap\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.set asScala\n\u001b[31m   |\u001b[0m\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660010449
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        // 1. Sort the list by length (descending)\n        val len = arr.map( x => x.toString.length ).sortWith((x,y) => x._2 > y._2)\n        val res = new mutable.ListBuffer[String]()\n        // 2. Add \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"\n        for (i <- 0 until len.size) {\n            if (len(i) < 9) {\n                res.add(\"One\")\n            }\n            if (len(i) < 9) {\n                res.add(\"Two\")\n            }\n            if (len(i) < 9) {\n                res.add(\"Three\")\n            }\n            if (len(i) < 9) {\n                res.add(\"Four\")\n            }\n            if (len(i) < 9) {\n                res.add(\"Five\")\n            }\n            if (len(i) < 9) {\n                res.add(\"Six\")\n            }\n            if (len(i) < 9) {\n                res.add(\"Seven\")\n            }\n            if (len(i) < 9) {\n                res.add(\"Eight\")\n            }\n            if (len(i) < 9) {\n                res.add(\"Nine\")\n            }\n        }\n        res.reverse.map( x => (x % 10) + 1 ).map( x => x.toString ).filterNot( _.isEmpty ).map( x => x++ )\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmp0k2nzm14.scala:50:105 --------------------------\u001b[0m\u001b[0m\n\u001b[31m50 |\u001b[0m        res.reverse.map( \u001b[36mx\u001b[0m => (x % \u001b[31m10\u001b[0m) + \u001b[31m1\u001b[0m ).map( \u001b[36mx\u001b[0m => x.toString ).filterNot( _.isEmpty ).map( \u001b[36mx\u001b[0m => x++ )\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                                       expression expected but \u001b[31m')'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp0k2nzm14.scala:18:72 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mlen\u001b[0m = arr.map( \u001b[36mx\u001b[0m => x.toString.length ).sortWith((\u001b[36mx\u001b[0m,\u001b[36my\u001b[0m) => x._2 > y._2)\n\u001b[31m\u001b[31m   |\u001b[0m                                                                      ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                         value _2 is not a member of Int\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp0k2nzm14.scala:19:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mres\u001b[0m = \u001b[33mnew\u001b[0m mutable.ListBuffer[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660010447
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        if (arr.isEmpty) Nil\n        else arr\n            .sortWith(_ < _) // sort descending\n            .reverse\n            .map { _.toString.toInt } // reverse again to get ascending\n            .filter(_ >= 1) && (_ < 9) // filter out numbers from 1 to 9\n            .map { name(_) } // map again to get the names, return Nil if the input list is empty\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpsj2tfpvb.scala:22:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33melse\u001b[0m arr\n\u001b[31m19 |\u001b[0m            .sortWith(_ < _) \u001b[34m// sort descending\u001b[0m\n\u001b[31m20 |\u001b[0m            .reverse\n\u001b[31m21 |\u001b[0m            .map { _.toString.toInt } \u001b[34m// reverse again to get ascending\u001b[0m\n\u001b[31m22 |\u001b[0m            .filter(_ >= \u001b[31m1\u001b[0m) && (_ < \u001b[31m9\u001b[0m) \u001b[34m// filter out numbers from 1 to 9\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m             ^\u001b[0m\n\u001b[31m   |\u001b[0m             value && is not a member of List[Int]\n\u001b[31m\u001b[31m-- [E081] Type Error: /tmp/tmpsj2tfpvb.scala:22:32 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            .filter(_ >= \u001b[31m1\u001b[0m) && (_ < \u001b[31m9\u001b[0m) \u001b[34m// filter out numbers from 1 to 9\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                                ^\u001b[0m\n\u001b[31m   |\u001b[0m   Missing parameter type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m   I could not infer the type of the parameter _$5 of expanded function:\n\u001b[31m   |\u001b[0m   _$5 => _$5 < 9.\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660010446
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        if(arr.isEmpty) List() else arr.sortWith(_.toLong <= 9).reverse.map{x => x % 10 + \"One\" :+ x % 10 + \"Two\" :+ x % 10 + \"Three\" :+ x % 10 + \"Four\" :+ x % 10 + \"Five\" :+ x % 10 + \"Six\" :+ x % 10 + \"Seven\" :+ x % 10 + \"Eight\" :+ x % 10 + \"Nine\"}\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E086] Syntax Error: /tmp/tmpaapglf3s.scala:17:49 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        \u001b[33mif\u001b[0m(arr.isEmpty) List() \u001b[33melse\u001b[0m arr.sortWith(_.toLong <= \u001b[31m9\u001b[0m).reverse.map{\u001b[36mx\u001b[0m => x % \u001b[31m10\u001b[0m + \u001b[31m\"One\"\u001b[0m :+ x % \u001b[31m10\u001b[0m + \u001b[31m\"Two\"\u001b[0m :+ x % \u001b[31m10\u001b[0m + \u001b[31m\"Three\"\u001b[0m :+ x % \u001b[31m10\u001b[0m + \u001b[31m\"Four\"\u001b[0m :+ x % \u001b[31m10\u001b[0m + \u001b[31m\"Five\"\u001b[0m :+ x % \u001b[31m10\u001b[0m + \u001b[31m\"Six\"\u001b[0m :+ x % \u001b[31m10\u001b[0m + \u001b[31m\"Seven\"\u001b[0m :+ x % \u001b[31m10\u001b[0m + \u001b[31m\"Eight\"\u001b[0m :+ x % \u001b[31m10\u001b[0m + \u001b[31m\"Nine\"\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m                                                 ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Wrong number of parameters, expected: 2\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpaapglf3s.scala:17:81 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        \u001b[33mif\u001b[0m(arr.isEmpty) List() \u001b[33melse\u001b[0m arr.sortWith(_.toLong <= \u001b[31m9\u001b[0m).reverse.map{\u001b[36mx\u001b[0m => x % \u001b[31m10\u001b[0m + \u001b[31m\"One\"\u001b[0m :+ x % \u001b[31m10\u001b[0m + \u001b[31m\"Two\"\u001b[0m :+ x % \u001b[31m10\u001b[0m + \u001b[31m\"Three\"\u001b[0m :+ x % \u001b[31m10\u001b[0m + \u001b[31m\"Four\"\u001b[0m :+ x % \u001b[31m10\u001b[0m + \u001b[31m\"Five\"\u001b[0m :+ x % \u001b[31m10\u001b[0m + \u001b[31m\"Six\"\u001b[0m :+ x % \u001b[31m10\u001b[0m + \u001b[31m\"Seven\"\u001b[0m :+ x % \u001b[31m10\u001b[0m + \u001b[31m\"Eight\"\u001b[0m :+ x % \u001b[31m10\u001b[0m + \u001b[31m\"Nine\"\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                         Found:    IndexedSeq[Matchable]\n\u001b[31m   |\u001b[0m                                         Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660010447
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n      if (arr.isEmpty) List()\n      else {\n        val firstNum = arr.head\n        val lastNum = arr.last\n        val firstNumNum = arr.size / 10\n        val firstNumDigit = firstNum.asDigit.toString\n        val firstNumNumAsInt = firstNumNum.toInt\n        val lastNumNumAsInt = lastNumNum.toInt\n        val firstNumNumAsInt = firstNumNumAsInt + 10\n        val firstNumDigitAsInt = firstNumDigit.asDigit.toInt\n        val lastNumNumAsInt = lastNumNumAsInt - 10\n        val lastNumDigitAsInt = lastNumDigit.asDigit.toInt\n        val lastNumDigit = lastNum.asDigit.toString\n        var lastNumNum = lastNum.toInt\n        var lastNumDigit = lastNumDigit.toString\n        var arrStr = \"\"\n        var lastNumNumAsInt = lastNumNumAsInt + 10\n        var lastNumDigitAsInt = lastNumDigitAsInt - 10\n        var lastNumDigitAsInt = lastNumDigit.asDigit.toInt\n        var lastNumDigit = lastNum.asDigit.toString\n        var num = 1\n        while (firstNumNumAsInt <= 9) {\n          if (lastNumNumAsInt >= lastNumNumAsInt - 10) {\n            arr.drop(lastNumNumAsInt - firstNumNumAsInt)\n            arr.sortWith(_ < _)\n            arr.take(lastNumNumAsInt - firstNumNumAsInt)\n            arrStr += lastNumDigit\n            firstNumNumAsInt = firstNumNumAsInt + 10\n            lastNumNumAsInt = lastNumNumAsInt - 10\n            lastNumDigitAsInt = lastNumDigitAsInt + 10\n            lastNumDigitAsInt = lastNumDigit.asDigit.toInt\n            lastNumDigit = lastNum.asDigit.toString\n          } else {\n            arrStr += lastNumDigit\n            lastNumNumAsInt = lastNumNumAsInt + 10\n            lastNumDigitAsInt = lastNumDigitAsInt - 10\n            lastNumDigitAsInt = lastNumDigit.asDigit.toInt\n            lastNumDigit = lastNum.asDigit.toString\n          }\n          num += 1\n        }\n        arrStr\n      }\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpo548mn4v.scala:25:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mfirstNumNumAsInt\u001b[0m = firstNumNumAsInt + \u001b[31m10\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mfirstNumNumAsInt is already defined as \u001b[33mvalue\u001b[0m \u001b[35mfirstNumNumAsInt\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpo548mn4v.scala:27:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mlastNumNumAsInt\u001b[0m = lastNumNumAsInt - \u001b[31m10\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mlastNumNumAsInt is already defined as \u001b[33mvalue\u001b[0m \u001b[35mlastNumNumAsInt\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpo548mn4v.scala:31:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mlastNumDigit\u001b[0m = lastNumDigit.toString\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mlastNumDigit is already defined as \u001b[33mvalue\u001b[0m \u001b[35mlastNumDigit\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpo548mn4v.scala:33:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mlastNumNumAsInt\u001b[0m = lastNumNumAsInt + \u001b[31m10\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mlastNumNumAsInt is already defined as \u001b[33mvalue\u001b[0m \u001b[35mlastNumNumAsInt\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpo548mn4v.scala:34:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mlastNumDigitAsInt\u001b[0m = lastNumDigi",
      "stdout": "",
      "timestamp": 1660010450
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        def toName(n: Long): String = n match {\n            case 1 => \"One\"\n            case 2 => \"Two\"\n            case 3 => \"Three\"\n            case 4 => \"Four\"\n            case 5 => \"Five\"\n            case 6 => \"Six\"\n            case 7 => \"Seven\"\n            case 8 => \"Eight\"\n            case 9 => \"Nine\"\n            case x => throw new IllegalArgumentException(s\"Unexpected number $x in list: ${arr.get}\")\n        }\n        def getDigit(n: Long): Int = {\n            n match {\n                case 1 => 0\n                case 2 => 1\n                case 3 => 2\n                case 4 => 3\n                case 5 => 4\n                case 6 => 5\n                case 7 => 6\n                case 8 => 7\n                case 9 => 8\n                case x => throw new IllegalArgumentException(s\"Unexpected number $x in list: ${arr.get}\")\n            }\n        }\n        arr.foreach { n =>\n            val digit = getDigit(n)\n            if (digit < 1 || digit > 9) {\n                return\n            }\n            val name = toName(n)\n            if (arr.nonEmpty) {\n                arr(digit).reverse\n            }\n            else {\n                throw new IllegalArgumentException(s\"Unexpected empty list: ${arr.get}\")\n            }\n            arr(digit) = name\n        }\n        arr.filter(_ != \"Nine\").toList\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmplusbn6bp.scala:27:95 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m            \u001b[33mcase\u001b[0m x => \u001b[33mthrow\u001b[0m \u001b[33mnew\u001b[0m IllegalArgumentException(\u001b[31ms\"Unexpected number \u001b[0m$x\u001b[31m in list: \u001b[0m${arr.get}\u001b[31m\"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                           ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m         value get is not a member of List[Long] - did you mean arr.seq?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmplusbn6bp.scala:40:99 ------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m                \u001b[33mcase\u001b[0m x => \u001b[33mthrow\u001b[0m \u001b[33mnew\u001b[0m IllegalArgumentException(\u001b[31ms\"Unexpected number \u001b[0m$x\u001b[31m in list: \u001b[0m${arr.get}\u001b[31m\"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                               ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue get is not a member of List[Long], but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.seq AsJavaList\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversionsToJava.seq AsJavaList\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmplusbn6bp.scala:46:16 --------------------\u001b[0m\u001b[0m\n\u001b[31m46 |\u001b[0m                \u001b[33mreturn\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Found:    Unit\n\u001b[31m   |\u001b[0m                Required: List[String]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmplusbn6bp.scala:50:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m50 |\u001b[0m                arr(digit).reverse\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                value reverse is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmplusbn6bp.scala:53:82 ------------------------\u001b[0m\u001b[0m\n\u001b[31m53 |\u001b[0m                \u001b[33mthrow\u001b[0m \u001b[33mnew\u001b[0m \u001b[35m",
      "stdout": "",
      "timestamp": 1660010450
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        val result = arr.foldLeft(List[Long]()) { (list: List[Long], value: Long) =>\n            val lower = math.max(0, value)\n            val upper = math.min(10, value)\n            if (value % 10 <= 9) {\n                val digit = value % 10\n                list match {\n                    case Nil => list.update(list.size, digit.toString)\n                    case _ => list :+ digit\n                }\n            } else if (value < 10) {\n                list match {\n                    case Nil => list :+ value.toString\n                    case _ => list :+ value.toString\n                }\n            } else {\n                list match {\n                    case Nil => list.update(list.size, value.toString)\n                    case _ => list :+ value.toString\n                }\n            }\n        }\n        val reverse = result.reverse\n        reverse.foldLeft(List[String]()) { (list: List[String], value: Long) =>\n            val digit = math.max(0, value)\n            val name = digit < 10 match {\n                case true => \"One\"\n                case false => \"Two\"\n            }\n            list match {\n                case Nil => list :+ name\n                case _ => list :+ name\n            }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpmkqay9jp.scala:23:37 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m                    \u001b[33mcase\u001b[0m Nil => list.update(list.size, digit.toString)\n\u001b[31m\u001b[31m   |\u001b[0m                                ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m value update is not a member of List[Long] - did you mean list.updated?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpmkqay9jp.scala:33:37 ------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m                    \u001b[33mcase\u001b[0m Nil => list.update(list.size, value.toString)\n\u001b[31m\u001b[31m   |\u001b[0m                                ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m value update is not a member of List[Long] - did you mean list.updated?\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpmkqay9jp.scala:39:43 --------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m        reverse.foldLeft(List[\u001b[35mString\u001b[0m]()) { (\u001b[36mlist\u001b[0m: \u001b[35mList\u001b[0m[\u001b[35mString\u001b[0m], \u001b[36mvalue\u001b[0m: \u001b[35mLong\u001b[0m) =>\n\u001b[31m\u001b[31m   |\u001b[0m                                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                     Found:    (List[String], \u001b[1m\u001b[31mLong\u001b[0m) => List[String]\n\u001b[31m   |\u001b[0m                     Required: (List[String], \u001b[1m\u001b[32mMatchable\u001b[0m) => List[String]\n\u001b[31m40 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mdigit\u001b[0m = math.max(\u001b[31m0\u001b[0m, value)\n\u001b[31m41 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mname\u001b[0m = digit < \u001b[31m10\u001b[0m \u001b[33mmatch\u001b[0m {\n\u001b[31m42 |\u001b[0m                \u001b[33mcase\u001b[0m \u001b[31mtrue\u001b[0m => \u001b[31m\"One\"\u001b[0m\n\u001b[31m43 |\u001b[0m                \u001b[33mcase\u001b[0m \u001b[31mfalse\u001b[0m => \u001b[31m\"Two\"\u001b[0m\n\u001b[31m44 |\u001b[0m            }\n\u001b[31m45 |\u001b[0m            list \u001b[33mmatch\u001b[0m {\n\u001b[31m46 |\u001b[0m                \u001b[33mcase\u001b[0m Nil => list :+ name\n\u001b[31m47 |\u001b[0m                \u001b[33mcase\u001b[0m _ => list :+ name\n\u001b[31m48 |\u001b[0m            }\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660010451
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        // Convert this list of Long into list of String.\n        // Here convert into String of length equal to length of Long.\n        val longString = arr.map(_.toString).map(_.length).map(s => s match { \n            case 1 => \"One\"\n            case 2 => \"Two\"\n            case 3 => \"Three\"\n            case 4 => \"Four\"\n            case 5 => \"Five\"\n            case 6 => \"Six\"\n            case 7 => \"Seven\"\n            case 8 => \"Eight\"\n            case 9 => \"Nine\"\n            case _ => \"\"\n        }).reduceLeft(_ + _)\n\n        // Sort the list by their lengths.\n        val sorted = longString.sortWith(_.length > _.length)\n\n        // Reverse the list.\n        val reversed = sorted.reverse\n\n        // Replace the digit by its corresponding digit name.\n        // For example \"One\" becomes 0, \"Two\" becomes 1, and so on.\n        val replaced = reversed.map(c => replace(c, arr.indexOf(c))).reverse\n\n        // Return final list.\n        replaced\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpjeoflv0f.scala:33:43 ------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36msorted\u001b[0m = longString.sortWith(_.length > _.length)\n\u001b[31m\u001b[31m   |\u001b[0m                                         ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                    value length is not a member of Char\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpjeoflv0f.scala:40:41 ------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mreplaced\u001b[0m = reversed.map(\u001b[36mc\u001b[0m => replace(c, arr.indexOf(c))).reverse\n\u001b[31m\u001b[31m   |\u001b[0m                                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                         Not found: replace\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660010449
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        if(arr.isEmpty) List() \n        else arr match {\n            case List(1..9) => (9 to 1 map (x => arr.reverse.head.toString(x))) ++ arr.reverse.tail\n            case _ => List(\"One\")\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp9mie0jgw.scala:19:23 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m            \u001b[33mcase\u001b[0m List(\u001b[31m1\u001b[0m.\u001b[31m.9\u001b[0m) => (\u001b[31m9\u001b[0m to \u001b[31m1\u001b[0m map (x => arr.reverse.head.toString(x))) ++ arr.reverse.tail\n\u001b[31m\u001b[31m   |\u001b[0m                       ^\u001b[0m\n\u001b[31m   |\u001b[0m                       ')' expected, but '.' found\n\u001b[31m\u001b[31m-- Error: /tmp/tmp9mie0jgw.scala:19:75 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m            \u001b[33mcase\u001b[0m List(\u001b[31m1\u001b[0m.\u001b[31m.9\u001b[0m) => (\u001b[31m9\u001b[0m to \u001b[31m1\u001b[0m map (x => arr.reverse.head.toString(x))) ++ arr.reverse.tail\n\u001b[31m\u001b[31m   |\u001b[0m                                                                           ^\u001b[0m\n\u001b[31m   |\u001b[0m         too many arguments for \u001b[33mmethod\u001b[0m \u001b[35mtoString\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mAny\u001b[0m: (): String\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660010447
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        val res = arr.filter(_ > 9).reverse.map(_ % 10 to One) ++\n            arr.filter(_ >= 9).map(_ % 10 to \"Ten\")\n        arr.forall(!_.toString.isDigit) match {\n            case true => res :+ res\n            case false => res\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp8mzp0hxu.scala:17:58 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mres\u001b[0m = arr.filter(_ > \u001b[31m9\u001b[0m).reverse.map(_ % \u001b[31m10\u001b[0m to One) ++\n\u001b[31m\u001b[31m   |\u001b[0m                                                          ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                                          Not found: One\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp8mzp0hxu.scala:18:45 --------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m            arr.filter(_ >= \u001b[31m9\u001b[0m).map(_ % \u001b[31m10\u001b[0m to \u001b[31m\"Ten\"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                             ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                             Found:    (\u001b[32m\"Ten\"\u001b[0m : String)\n\u001b[31m   |\u001b[0m                                             Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp8mzp0hxu.scala:19:31 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        arr.forall(!_.toString.isDigit) \u001b[33mmatch\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    value isDigit is not a member of String\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp8mzp0hxu.scala:20:25 --------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m            \u001b[33mcase\u001b[0m \u001b[31mtrue\u001b[0m => res :+ res\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m             Found:    List[\n\u001b[31m   |\u001b[0m               scala.collection.immutable.AbstractSeq[Long | \n\u001b[31m   |\u001b[0m                 scala.collection.immutable.NumericRange.Inclusive[Long]\n\u001b[31m   |\u001b[0m               ]\n\u001b[31m   |\u001b[0m             ]\n\u001b[31m   |\u001b[0m             Required: List[String]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp8mzp0hxu.scala:21:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m            \u001b[33mcas",
      "stdout": "",
      "timestamp": 1660010450
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        val n = arr.size\n        if (n==0) return Nil\n        val list = arr.reverse\n        val ones = list.filter(x => x==1l)\n        val tens = list.filter(x => x==10l)\n        val hundreds = list.filter(x => x==100l)\n        val thousands = list.filter(x => x==1000l)\n        val list = hundreds.reverse\n        val list = list ++ tens.reverse\n        val list = list ++ ones.reverse\n        val list = list ++ thousands.reverse\n        list.toList.map(x => byLength(x).getOrElse(\"Not a number\"))\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp5292vzut.scala:24:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mlist\u001b[0m = hundreds.reverse\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mlist is already defined as \u001b[33mvalue\u001b[0m \u001b[35mlist\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp5292vzut.scala:25:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mlist\u001b[0m = list ++ tens.reverse\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mlist is already defined as \u001b[33mvalue\u001b[0m \u001b[35mlist\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp5292vzut.scala:26:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mlist\u001b[0m = list ++ ones.reverse\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mlist is already defined as \u001b[33mvalue\u001b[0m \u001b[35mlist\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp5292vzut.scala:27:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mlist\u001b[0m = list ++ thousands.reverse\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mlist is already defined as \u001b[33mvalue\u001b[0m \u001b[35mlist\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp5292vzut.scala:28:38 --------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        list.toList.map(\u001b[36mx\u001b[0m => byLength(x).getOrElse(\u001b[31m\"Not a number\"\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                                      Found:    (x : Long)\n\u001b[31m   |\u001b[0m                         ",
      "stdout": "",
      "timestamp": 1660010449
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        def helper(arr : List[Long], result : mutable.Buffer[String], tmp : Int) : Unit = {\n            if (arr.nonEmpty) {\n                val l = arr.head\n                val tmp1 = arr.tail\n                val tmp2 = tmp + l\n                val tmp3 = tmp2.toString.reverse\n                val tmp4 = tmp3.toString.replaceAll(\"0\", \"One\")\n                val tmp5 = tmp4.replaceAll(\"1\", \"Two\")\n                val tmp6 = tmp5.replaceAll(\"2\", \"Three\")\n                val tmp7 = tmp6.replaceAll(\"3\", \"Four\")\n                val tmp8 = tmp7.replaceAll(\"4\", \"Five\")\n                val tmp9 = tmp8.replaceAll(\"5\", \"Six\")\n                val tmp10 = tmp9.replaceAll(\"6\", \"Seven\")\n                val tmp11 = tmp10.replaceAll(\"7\", \"Eight\")\n                val tmp12 = tmp11.replaceAll(\"8\", \"Nine\")\n                val tmp13 = tmp12.map(i => (i, i))\n                val tmp14 = tmp13.toSeq\n                result += tmp14\n                helper(tmp2, result, tmp)\n            }\n        }\n        val result = mutable.Buffer[String]()\n        helper(arr, result, 0)\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpgfz968jm.scala:17:46 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        \u001b[33mdef\u001b[0m \u001b[36mhelper\u001b[0m(\u001b[36marr\u001b[0m : \u001b[35mList\u001b[0m[\u001b[35mLong\u001b[0m], \u001b[36mresult\u001b[0m : mutable.Buffer[\u001b[35mString\u001b[0m], \u001b[36mtmp\u001b[0m : \u001b[35mInt\u001b[0m) : \u001b[35mUnit\u001b[0m = {\n\u001b[31m\u001b[31m   |\u001b[0m                                              ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                              Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpgfz968jm.scala:35:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m                helper(tmp2, result, tmp)\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (tmp2 : Long)\n\u001b[31m   |\u001b[0m                       Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpgfz968jm.scala:38:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.Buffer[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660010449
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        if (arr.isEmpty)\n            return Nil\n        if (arr.headOption.getOrElse(0L).toString.toInt == 1)\n            byLengthRev(arr.tail)\n        else {\n            // sort the list with ascending order and reverse it so the least number comes first\n            val arr = arr.sorted\n            val strs = byLengthRev(arr)\n            val arr = arr.toList\n            // convert each string to its corresponding string\n            strs.foldLeft(\"\")(\n                (str,cur) => str+s\"$cur\"\n            )\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmph0wbnykx.scala:20:12 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m            byLengthRev(arr.tail)\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            Not found: byLengthRev\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmph0wbnykx.scala:25:16 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = arr.toList\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0marr is already defined as \u001b[33mvalue\u001b[0m \u001b[35marr\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmph0wbnykx.scala:23:22 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = arr.sorted\n\u001b[31m\u001b[31m   |\u001b[0m                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                      Recursive \u001b[33mvalue\u001b[0m \u001b[35marr\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmph0wbnykx.scala:24:23 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mstrs\u001b[0m = byLengthRev(arr)\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Not found: byLengthRev\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "stdout": "",
      "timestamp": 1660010447
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        val res = new mutable.ListBuffer[String]()\n        for(i <- 0 until arr.length) {\n            val temp = arr(i)\n            if(temp >= 1l && temp <= 9l) {\n                val temp = arr.apply(i)\n                res.insert(temp.toString).reverse.foreach(x => res.insert(x))\n            } else {\n                res.insert(\"\")\n            }\n        }\n        val l = res.iterator.toList\n        if(l.isEmpty) res.clear\n        else res.toList\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpllly49yi.scala:17:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mres\u001b[0m = \u001b[33mnew\u001b[0m mutable.ListBuffer[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010447
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        if (arr.isEmpty) Nil\n        else if (arr.head < 1l.toLong || arr.head > 9l.toLong) Nil\n        else {\n            val arr = arr.filter(_.toString >= \"1\" && _.toString <= \"9\")\n            val rev = arr.map(_.toString).reverse\n            val output = rev.map(x => if (arr.contains(x)) x else \"One\")\n            Nil if (output.isEmpty) output else output.toList\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmpopaelb0t.scala:23:16 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m            Nil \u001b[33mif\u001b[0m (output.isEmpty) output \u001b[33melse\u001b[0m output.toList\n\u001b[31m\u001b[31m   |\u001b[0m                ^^\u001b[0m\n\u001b[31m   |\u001b[0m                end of statement expected but 'if' found\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpopaelb0t.scala:20:22 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = arr.filter(_.toString >= \u001b[31m\"1\"\u001b[0m && _.toString <= \u001b[31m\"9\"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                      Recursive \u001b[33mvalue\u001b[0m \u001b[35marr\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660010447
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        // initialize map\n        val map = new mutable.HashMap[Long, String]()\n        // populate map\n        for (i <- arr.iterator) {\n            if ((i >=1 && i <= 9)) {\n                map.put(i, (i.toString -> \"One\").getOrElse(\"Unknown\"))\n            }\n        }\n        // reverse map\n        val reverseMap = map.toSeq.reverse.map(v => v._2)\n        // get all keys\n        val keys = reverseMap.map(_.toString).toSet\n        // get all values\n        val values = reverseMap.toSeq.map(_.toString)\n        // filter out all keys\n        if (map.size == 0) {\n            keys.toList\n        } else {\n            // filter out all values\n            if (reverseMap.size == 0) {\n                values.toList\n            } else {\n                val filtered = keys.filterNot(k => values.contains(k))\n                // replace each value by its corresponding name in \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"\n                filtered.toList\n            }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpo3nc_rfy.scala:18:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmap\u001b[0m = \u001b[33mnew\u001b[0m mutable.HashMap[\u001b[35mLong\u001b[0m, \u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010447
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        var arr = arr.toList\n        val len = arr.length\n        val m = Math.sqrt(len)\n        val newList = for (i <- 0 until len) yield {\n            var res = \"\"\n            var n = 0\n            var j = 0\n            while (j < 9) {\n                if (arr(i).toLong <= m.toLong * (j + 1) && arr(i).toLong >= m.toLong * (j)) {\n                    n += 1\n                }\n                j += 1\n            }\n            var digit = m.toLong * i\n            if (n == 1) {\n                res = \"One\"\n            } else if (n == 2) {\n                res = \"Two\"\n            } else if (n == 3) {\n                res = \"Three\"\n            } else if (n == 4) {\n                res = \"Four\"\n            } else if (n == 5) {\n                res = \"Five\"\n            } else if (n == 6) {\n                res = \"Six\"\n            } else if (n == 7) {\n                res = \"Seven\"\n            } else if (n == 8) {\n                res = \"Eight\"\n            } else if (n == 9) {\n                res = \"Nine\"\n            }\n            val x = arr(i).toString.toInt\n            val y = digit.toString.toInt\n            val z = x.pow(10).minus(y)\n            val s = z.toString.reverse\n            val f = s.charAt(0)\n            val g = f.toUpperCase\n            val t = s.substring(1)\n            val n = f.toInt + (10 - y.toInt) + g + t\n            if (n == arr(i)) {\n                res\n            } else {\n                res\n            }\n        }\n        arr.clear()\n        arr += newList\n        newList\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp1fwx90jo.scala:17:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36marr\u001b[0m = arr.toList\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Recursive \u001b[33mvariable\u001b[0m \u001b[35marr\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp1fwx90jo.scala:57:16 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m57 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mn\u001b[0m = f.toInt + (\u001b[31m10\u001b[0m - y.toInt) + g + t\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mn is already defined as \u001b[33mvariable\u001b[0m \u001b[35mn\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp1fwx90jo.scala:66:8 ---------------------\u001b[0m\u001b[0m\n\u001b[31m66 |\u001b[0m        newList\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Found:    (newList : IndexedSeq[String])\n\u001b[31m   |\u001b[0m        Required: List[String]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660010450
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        var list = arr.toSeq.sorted\n        var str = \"\"\n        var i = 0\n        while(i < list.size) {\n            if(list(i) < 1 || list(i) > 9) {\n                str = \"\"\n                break\n            }\n            str = str + (list(i) + \"-\" + Array(list(i)).map( name => (name.toLowerCase() + \"s\")).mkString(\"\"))\n            i += 1\n        }\n        if(!arr.isEmpty) {\n            str += \"-\"\n        }\n        list.map(name => (name.toLowerCase() + \"s\")).mkString(\",\")\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpdtrzac47.scala:23:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m                break\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: break\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpdtrzac47.scala:25:75 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m            str = str + (list(i) + \u001b[31m\"-\"\u001b[0m + Array(list(i)).map( \u001b[36mname\u001b[0m => (name.toLowerCase() + \u001b[31m\"s\"\u001b[0m)).mkString(\u001b[31m\"\"\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                                                                      ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                               value toLowerCase is not a member of Long\n\u001b[31m\u001b[31m-- Error: /tmp/tmpdtrzac47.scala:25:96 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m            str = str + (list(i) + \u001b[31m\"-\"\u001b[0m + Array(list(i)).map( \u001b[36mname\u001b[0m => (name.toLowerCase() + \u001b[31m\"s\"\u001b[0m)).mkString(\u001b[31m\"\"\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                                ^\u001b[0m\n\u001b[31m   |\u001b[0m                                          No ClassTag available for B\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m                                          where:    B is a type variable\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpdtrzac47.scala:31:31 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        list.map(\u001b[36mname\u001b[0m => (name.toLowerCase() + \u001b[31m\"s\"\u001b[0m)).mkString(\u001b[31m\",\"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          value toLowerCase is not a member of Long\n4 errors found\n",
      "stdout": "",
      "timestamp": 1660010455
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        val arrList = arr.toList\n        val reversed = arrList.sortBy(_.toInt)\n        reversed.reverse.map(i => if (i.toInt == 9) \"Nine\" else if (i.toInt == 8) \"Eight\" else if (i.toInt == 7) \"Seven\" else if (i.toInt == 6) \"Six\" else if (i.toInt == 5) \"Five\" else if (i.toInt == 4) \"Four\" else if (i.toInt == 3) \"Three\" else if (i.toInt == 2) \"Two\" else if (i.toInt == 1) \"One\" else \"Not \" + i.toString.replaceFirst(\"\\\\D+\", \"\")) + \" is greater than eight\"\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpvtc5m_hm.scala:19:350 -----------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        reversed.reverse.map(\u001b[36mi\u001b[0m => \u001b[33mif\u001b[0m (i.toInt == \u001b[31m9\u001b[0m) \u001b[31m\"Nine\"\u001b[0m \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (i.toInt == \u001b[31m8\u001b[0m) \u001b[31m\"Eight\"\u001b[0m \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (i.toInt == \u001b[31m7\u001b[0m) \u001b[31m\"Seven\"\u001b[0m \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (i.toInt == \u001b[31m6\u001b[0m) \u001b[31m\"Six\"\u001b[0m \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (i.toInt == \u001b[31m5\u001b[0m) \u001b[31m\"Five\"\u001b[0m \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (i.toInt == \u001b[31m4\u001b[0m) \u001b[31m\"Four\"\u001b[0m \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (i.toInt == \u001b[31m3\u001b[0m) \u001b[31m\"Three\"\u001b[0m \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (i.toInt == \u001b[31m2\u001b[0m) \u001b[31m\"Two\"\u001b[0m \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (i.toInt == \u001b[31m1\u001b[0m) \u001b[31m\"One\"\u001b[0m \u001b[33melse\u001b[0m \u001b[31m\"Not \"\u001b[0m + i.toString.replaceFirst(\u001b[31m\"\\\\D+\"\u001b[0m, \u001b[31m\"\"\u001b[0m)) + \u001b[31m\" is greater than eight\"\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue + is not a member of List[String], but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might make progress towards fixing the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.Fractional.Implicits.infixFractionalOps\n\u001b[31m   |\u001b[0m  import math.Integral.Implicits.infixIntegralOps\n\u001b[31m   |\u001b[0m  import math.Numeric.Implicits.infixNumericOps\n\u001b[31m   |\u001b[0m\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010456
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        var ans = Nil\n        var str = \"\"\n        for(i <- arr){\n            str = str + i.toString\n            if(i.toString.length == 3){\n                if(i mod 10 == 0){\n                    if(ans.isEmpty){\n                        ans = Nil\n                    }\n                    ans = ans :+ str.reverse.mkString\n                    str = \"\"\n                }\n            }else if(i.toString.length == 4){\n                if(i mod 10 == 0){\n                    if(ans.isEmpty){\n                        ans = Nil\n                    }\n                    ans = ans :+ str.reverse.mkString\n                    str = \"\"\n                }\n            }else if(i.toString.length == 5){\n                if(i mod 10 == 0){\n                    if(ans.isEmpty){\n                        ans = Nil\n                    }\n                    ans = ans :+ str.reverse.mkString\n                    str = \"\"\n                }\n            }else if(i.toString.length == 6){\n                if(i mod 10 == 0){\n                    if(ans.isEmpty){\n                        ans = Nil\n                    }\n                    ans = ans :+ str.reverse.mkString\n                    str = \"\"\n                }\n            }else if(i.toString.length == 7){\n                if(i mod 10 == 0){\n                    if(ans.isEmpty){\n                        ans = Nil\n                    }\n                    ans = ans :+ str.reverse.mkString\n                    str = \"\"\n                }\n            }else if(i.toString.length == 8){\n                if(i mod 10 == 0){\n                    if(ans.isEmpty){\n                        ans = Nil\n                    }\n                    ans = ans :+ str.reverse.mkString\n                    str = \"\"\n                }\n            }else if(i.toString.length == 9){\n                if(i mod 10 == 0){\n                    if(ans.isEmpty){\n                        ans = Nil\n                    }\n                    ans = ans :+ str.reverse.mkString\n                    str = \"\"\n                }\n            }\n        }\n        if(ans.isEmpty){\n            ans = Nil\n        }\n        ans\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp990a61va.scala:22:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m                \u001b[33mif\u001b[0m(i mod \u001b[31m10\u001b[0m == \u001b[31m0\u001b[0m){\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue mod is not a member of Long, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mThe following import might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.BigInt.long2bigInt\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp990a61va.scala:26:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m                    ans = ans :+ str.reverse.mkString\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    List[String]\n\u001b[31m   |\u001b[0m                          Required: scala.collection.immutable.Nil.type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp990a61va.scala:30:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m                \u001b[33mif\u001b[0m(i mod \u001b[31m10\u001b[0m == \u001b[31m0\u001b[0m){\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue mod is not a member of Long, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mThe following import might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.BigInt.long2bigInt\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp990a61va.scala:34:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m                    ans = ans :+ str.reverse.mkString\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    List[String]\n\u001b[31m   |\u001b[0m                          Required: scala.collection.immutable.Nil.type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp990a61va.scala:38:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m                \u001b[33mif\u001b[0m(i mod \u001b[31m10\u001b[0m == \u001b",
      "stdout": "",
      "timestamp": 1660010458
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        require(arr.forall(n => n.isDefined))\n        val nums = arr.sortBy(_.toString.length)\n        val revNums = nums.reverse\n        val reverseNums = revNums.map( x => (1L toString x) ) \n        val revNumStrs = reverseNums.map( x => revNums.filter( y => y % x == 0 ).map( y => y / x ).map( y => (10L toString y) ) )\n        revNumStrs.flatten.distinct\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpp6jequmo.scala:17:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        require(arr.forall(\u001b[36mn\u001b[0m => n.isDefined))\n\u001b[31m\u001b[31m   |\u001b[0m                                ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                value isDefined is not a member of Long\n\u001b[31m\u001b[31m-- Error: /tmp/tmpp6jequmo.scala:20:57 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mreverseNums\u001b[0m = revNums.map( \u001b[36mx\u001b[0m => (\u001b[31m1L\u001b[0m toString x) ) \n\u001b[31m\u001b[31m   |\u001b[0m                                                         ^\u001b[0m\n\u001b[31m   |\u001b[0m         too many arguments for \u001b[33mmethod\u001b[0m \u001b[35mtoString\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mAny\u001b[0m: (): String\n\u001b[31m\u001b[31m-- [E134] Type Error: /tmp/tmpp6jequmo.scala:21:70 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mrevNumStrs\u001b[0m = reverseNums.map( \u001b[36mx\u001b[0m => revNums.filter( \u001b[36my\u001b[0m => y % x == \u001b[31m0\u001b[0m ).map( \u001b[36my\u001b[0m => y / x ).map( \u001b[36my\u001b[0m => (\u001b[31m10L\u001b[0m toString y) ) )\n\u001b[31m\u001b[31m   |\u001b[0m                                                                    ^^^\u001b[0m\n\u001b[31m   |\u001b[0mNone of the overloaded alternatives of \u001b[33mmethod\u001b[0m \u001b[35m%\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mLong\u001b[0m with types\n\u001b[31m   |\u001b[0m (x: Double): Double\n\u001b[31m   |\u001b[0m (x: Float): Float\n\u001b[31m   |\u001b[0m (x: Long): Long\n\u001b[31m   |\u001b[0m (x: Int): Long\n\u001b[31m   |\u001b[0m (x: Char): Long\n\u001b[31m   |\u001b[0m (x: Short): Long\n\u001b[31m   |\u001b[0m (x: Byte): Long\n\u001b[31m   |\u001b[0mmatch arguments ((x : String))\n\u001b[31m\u001b[31m-- [E134] Type Error: /tmp/tmpp6jequmo.scala:21:93 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mrevNumStrs\u001b[0m = reverseNums.map( \u001b[36mx\u001b[0m => revNums.filter( \u001b[36my\u001b[0m => y % x == \u001b[31m0\u001b[0m ).map( \u001b[36my\u001b[0m => y / x ).map( \u001b[36my\u001b[0m => (\u001b[31m10L\u001b[0m toString y) ) )\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                           ^^^\u001b[0m\n\u001b[31m   |\u001b[0mNone of the overloaded alternatives of \u001b[33mmethod\u001b[0m \u001b[35m/\u001b[0m in \u001b[33mclass\u001b[0",
      "stdout": "",
      "timestamp": 1660010455
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        val ints = arr.filter(_ >= 1 && _ < 10)\n        val strings = ints.map(i => if (i < 10) {\"One\"} else (if (i <= 20) {\"Two\"} else (if (i <= 30) {\"Three\"} else (if (i <= 40) {\"Four\"} else (if (i <= 50) {\"Five\"} else (if (i <= 60) {\"Six\"} else (if (i <= 70) {\"Seven\"} else (if (i <= 80) {\"Eight\"} else (if (i <= 90) {\"Nine\"} else \"Invalid\"))))))))\n        val strings = strings + strings.reverse\n        strings\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp4hmswf6_.scala:19:8 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstrings\u001b[0m = strings + strings.reverse\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^\u001b[0m\n\u001b[31m   |\u001b[0m        ')' expected, but 'val' found\n\u001b[31m\u001b[31m-- [E086] Syntax Error: /tmp/tmp4hmswf6_.scala:17:30 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mints\u001b[0m = arr.filter(_ >= \u001b[31m1\u001b[0m && _ < \u001b[31m10\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              Wrong number of parameters, expected: 1\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp4hmswf6_.scala:21:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[String]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660010456
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        var result = Array[String]()\n        var i = 0\n        var j = 0\n        var temp = 0\n        for (item <- arr) {\n            if (item < 9l) {\n                i = item\n                temp = 1\n            }\n            else {\n                j += item\n                temp = 2\n            }\n            while (j < 9) {\n                result += Array(One, Two, Three, Four, Five, Six,\n                    Seven, Eight, Nine)\n                j += 1\n            }\n            while (temp != 0) {\n                result += Array(One, Two, Three, Four, Five, Six,\n                    Seven, Eight, Nine)\n                temp -= 1\n            }\n        }\n        if (result.length == 0) {\n            Array[String]()\n        }\n        else {\n            Array[String](result.reverse.toList)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpwxu12uij.scala:23:20 --------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m                i = item\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Found:    (item : Long)\n\u001b[31m   |\u001b[0m                    Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpwxu12uij.scala:27:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m                j += item\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                value += is not a member of Int - did you mean Int.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpwxu12uij.scala:31:23 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m                result += Array(One, Two, Three, Four, Five, Six,\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue += is not a member of Array[String] - did you mean Array[String].!=?\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpwxu12uij.scala:31:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m                result += Array(One, Two, Three, Four, Five, Six,\n\u001b[31m\u001b[31m   |\u001b[0m                                ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                Not found: One\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpwxu12uij.scala:31:37 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m                result += Array(One, Two, Three, Four, Five, Six,\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                     Not found: Two\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpwxu12uij.scala:31:42 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m                result += Array(One, Two, Three, Four, Five, Six,\n\u001b[31m\u001b[31m   |\u001b[0m                                          ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                          Not found: T",
      "stdout": "",
      "timestamp": 1660010460
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        arr.filter(_ > 0 && _ < 10).sortWith(_.toLong compareTo 1).reverse map {\n            _.toString.replaceAll(\"0\".r.toString, \"One\")\n                    .replaceAll(\"1\".r.toString, \"Two\")\n                    .replaceAll(\"2\".r.toString, \"Three\")\n                    .replaceAll(\"3\".r.toString, \"Four\")\n                    .replaceAll(\"4\".r.toString, \"Five\")\n                    .replaceAll(\"5\".r.toString, \"Six\")\n                    .replaceAll(\"6\".r.toString, \"Seven\")\n                    .replaceAll(\"7\".r.toString, \"Eight\")\n                    .replaceAll(\"8\".r.toString, \"Nine\")\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E086] Syntax Error: /tmp/tmph0hwhr5r.scala:17:19 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        arr.filter(_ > \u001b[31m0\u001b[0m && _ < \u001b[31m10\u001b[0m).sortWith(_.toLong compareTo \u001b[31m1\u001b[0m).reverse map {\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Wrong number of parameters, expected: 1\n\u001b[31m\u001b[31m-- [E086] Syntax Error: /tmp/tmph0hwhr5r.scala:17:45 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        arr.filter(_ > \u001b[31m0\u001b[0m && _ < \u001b[31m10\u001b[0m).sortWith(_.toLong compareTo \u001b[31m1\u001b[0m).reverse map {\n\u001b[31m\u001b[31m   |\u001b[0m                                             ^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Wrong number of parameters, expected: 2\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660010456
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        def isBetween(i : Int, max : Long) : Boolean = {\n            if (i >= 1 && i <= 9) true\n            else max < 0\n        }\n        val max = (arr min 9).max toLong +1\n        val result = arr.filter( i => isBetween(i, max) )\n        val reverse = result.reverse\n        reverse.map {\n            i => String.valueOf(i).replaceAll(\"(\\\\d+)\", (i) => \"One\" + i.toString.toInt)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp5e4dxobr.scala:21:27 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmax\u001b[0m = (arr min \u001b[31m9\u001b[0m).max toLong +\u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                           Found:    (\u001b[31m9\u001b[0m : Int)\n\u001b[31m   |\u001b[0m                           Required: Ordering[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp5e4dxobr.scala:22:48 --------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = arr.filter( \u001b[36mi\u001b[0m => isBetween(i, max) )\n\u001b[31m\u001b[31m   |\u001b[0m                                                ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                Found:    (i : Long)\n\u001b[31m   |\u001b[0m                                                Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E081] Type Error: /tmp/tmp5e4dxobr.scala:25:57 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m            \u001b[36mi\u001b[0m => String.valueOf(i).replaceAll(\u001b[31m\"(\\\\d+)\"\u001b[0m, (\u001b[36mi\u001b[0m) => \u001b[31m\"One\"\u001b[0m + i.toString.toInt)\n\u001b[31m\u001b[31m   |\u001b[0m                                                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Missing parameter type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m                          I could not infer the type of the parameter i.\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660010460
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        val lengths = arr.map(x => x.toString.length)\n        if(lengths.isEmpty) {\n            return Nil\n        }\n        val maxLength = lengths.max\n        val reverseList = arr.map(x => if(x < 1l.toLong && x > 9l.toLong) x else x%10l.toLong).reverse\n        var nameList = List[String]()\n        var i = 0\n        while(i < reverseList.length) {\n            var j = 0\n            while(j < maxLength) {\n                nameList ::= reverseList.apply(j+i)\n                j++\n            }\n            i += 1\n        }\n        nameList.filterNot(_.isEmpty)\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmp984u_2ln.scala:29:19 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m                j++\n\u001b[31m\u001b[31m   |\u001b[0m                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                   expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp984u_2ln.scala:28:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m                nameList ::= reverseList.apply(j+i)\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue ::= is not a member of List[String] - did you mean List[String].::?\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660010458
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        arr.sortWith((l,r) => l.compareTo(r) <= 0)\n                .reverse\n                .map {\n                    x => val name = x.toString.replaceAll(\"\\\\D\", \"\");\n                            if (name == null) \"One\" else name\n                    }\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpxiwhunz6.scala:25)\n\tat Problem.main(tmpxiwhunz6.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660010460
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        arr.toList.sortWith(\n            (l1,l2)=> if(l1 < 9 && l2 < 9) l1-l2 < 0 else l2-l1 < 0 ).reverse.map(\n            v => String.valueOf(v).replaceAll(\"\\\\D\", \"\")).filter(\n            v => v == \"One\" || v == \"Two\" || v == \"Three\" || v == \"Four\" || v == \"Five\" || v == \"Six\" || v == \"Seven\" || v == \"Eight\" || v == \"Nine\")\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpkjmmb454.scala:23)\n\tat Problem.main(tmpkjmmb454.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660010461
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        if(arr.length == 0) return Nil\n        val len = arr.length\n        val mid = Math.floor(len/2)\n        val left = arr(0 to mid)\n        val right = arr(mid to len)\n        val result = left.sortBy(_.toString.length).reverse.map { i => \n            if(i <= 9) s\"${i}\" else s\"${Character.toUpperCase(Character.digit(i, 10))}\" \n        }.toList\n        right.reverse.map { i => if(i <= 9) s\"${i}\" else s\"${Character.toUpperCase(Character.digit(i, 10))}\" }.toList ++\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpbamfcqeo.scala:20:28 --------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mleft\u001b[0m = arr(\u001b[31m0\u001b[0m to mid)\n\u001b[31m\u001b[31m   |\u001b[0m                            ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                            Found:    (mid : Double)\n\u001b[31m   |\u001b[0m                            Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpbamfcqeo.scala:21:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mright\u001b[0m = arr(mid to len)\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue to is not a member of Double, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mThe following import might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.BigDecimal.double2bigDecimal\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpbamfcqeo.scala:22:26 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = left.sortBy(_.toString.length).reverse.map { \u001b[36mi\u001b[0m => \n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     value sortBy is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpbamfcqeo.scala:25:14 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        right.reverse.map { \u001b[36mi\u001b[0m => \u001b[33mif\u001b[0m(i <= \u001b[31m9\u001b[0m) \u001b[31ms\"\u001b[0m${i}\u001b[31m\"\u001b[0m \u001b[33melse\u001b[0m \u001b[31ms\"\u001b[0m${Character.toUpperCase(Character.digit(i, \u001b[31m10\u001b[0m))}\u001b[31m\"\u001b[0m }.toList ++\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        value reverse is not a member of Long\n4 errors found\n",
      "stdout": "",
      "timestamp": 1660010460
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        val list = arr.toList\n        val ones = list.filter(x => x < 10).toList\n        val tens = list.filter(x => (x % 10) == 0).toList\n        val tensSortedOnes = tens.sortBy(x => x).reverse\n        val tensSortedTens = tensSortedOnes.map(x => (x % 10) + 10).toList\n        val twos = list.filter(x => (x % 10) == 10).toList\n        val onesSortedTwos = ones.sortBy(x => x).reverse\n        val tensSortedTwos = tensSortedOnes.map(x => (x % 10) + 10).toList\n        val threes = list.filter(x => (x % 10) == 20).toList\n        val onesSortedThrees = ones.sortBy(x => x).reverse\n        val tensSortedThrees = tensSortedOnes.map(x => (x % 10) + 10).toList\n        val fours = list.filter(x => (x % 10) == 30).toList\n        val onesSortedFours = ones.sortBy(x => x).reverse\n        val tensSortedFours = tensSortedOnes.map(x => (x % 10) + 10).toList\n        val fives = list.filter(x => (x % 10) == 40).toList\n        val onesSortedFives = ones.sortBy(x => x).reverse\n        val tensSortedFives = tensSortedOnes.map(x => (x % 10) + 10).toList\n        val sixes = list.filter(x => (x % 10) == 50).toList\n        val onesSortedSixes = ones.sortBy(x => x).reverse\n        val tensSortedSixes = tensSortedOnes.map(x => (x % 10) + 10).toList\n        val sevens = list.filter(x => (x % 10) == 60).toList\n        val onesSortedSevens = ones.sortBy(x => x).reverse\n        val tensSortedSevens = tensSortedOnes.map(x => (x % 10) + 10).toList\n        val eights = list.filter(x => (x % 10) == 70).toList\n        val onesSortedEights = ones.sortBy(x => x).reverse\n        val tensSortedEights = tensSortedOnes.map(x => (x % 10) + 10).toList\n        val nines = list.filter(x => (x % 10) == 80).toList\n        val onesSortedNines = ones.sortBy(x => x).reverse\n        val tensSortedNines = tensSortedOnes.map(x \n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp2m9puwa6.scala:46:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m46 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    ')' expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp2m9puwa6.scala:45:49 ------------------------\u001b[0m\u001b[0m\n\u001b[31m45 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mtensSortedNines\u001b[0m = tensSortedOnes.map(x \n\u001b[31m\u001b[31m   |\u001b[0m                                                 ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                 Not found: x\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp2m9puwa6.scala:46:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m46 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[String]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660010460
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        if (arr.isEmpty) {\n            return Nil\n        }\n        val longList = arr.toList.sortBy(l => (l % 10).compareTo((l / 10)))\n        val reversedList = longList.reverse\n        val oneList = List(1l, 2l, 3l, 4l, 5l, 6l, 7l, 8l, 9l)\n        val nineList = List(9l, 8l, 7l, 6l, 5l, 4l, 3l, 2l, 1l)\n        val reversedLongList = longList.reverse\n        val oneLongList = List(1l, 2l, 3l, 4l, 5l, 6l, 7l, 8l, 9l)\n        val nineLongList = List(9l, 8l, 7l, 6l, 5l, 4l, 3l, 2l, 1l)\n        // remove duplicates and sort from highest to lowest\n        val withoutDuplicates = reversedLongList.distinct\n        val oneWithoutDuplicates = oneLongList.distinct\n        val nineWithoutDuplicates = nineLongList.distinct\n        val oneList = List(1l, 2l, 3l, 4l, 5l, 6l, 7l, 8l, 9l)\n        val nineList = List(9l, 8l, 7l, 6l, 5l, 4l, 3l, 2l, 1l)\n        val withoutDuplicatesAndSort = withoutDuplicates.sort\n        val oneWithoutDuplicatesAndSort = oneWithoutDuplicates.sort\n        val nineWithoutDuplicatesAndSort = nineWithoutDuplicates.sort\n        // swap the integers between 1 and 9 with the corresponding names\n        val newList = reversedList.map(i => if (withoutDuplicatesAndSort.contains(i)) {\n            oneWithoutDuplicatesAndSort.indexOf(i)\n        }\n        else if (nineWithoutDuplicatesAndSort.contains(i)) {\n            nineWithoutDuplicatesAndSort.indexOf(i)\n        }\n        else {\n            withoutDuplicatesAndSort.indexOf(i)\n        })\n        // swap the numbers between 0 and 9 with the corresponding names\n        newList.map(i => if (withoutDuplicatesAndSort.contains(i)) {\n            withoutDuplicatesAndSort.indexOf(i)\n        }\n        else if (nineWithoutDuplicatesAndSort.contains(i)) {\n            nineWithoutDuplicatesAndSort.indexOf(i)\n        }\n        else {\n            withoutDuplicatesAndSort.indexOf(i)\n        })\n        newList\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmptugoe85d.scala:31:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36moneList\u001b[0m = List(\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0moneList is already defined as \u001b[33mvalue\u001b[0m \u001b[35moneList\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmptugoe85d.scala:32:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnineList\u001b[0m = List(\u001b[31m9l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m6l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m1l\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnineList is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnineList\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmptugoe85d.scala:33:57 ------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mwithoutDuplicatesAndSort\u001b[0m = withoutDuplicates.sort\n\u001b[31m\u001b[31m   |\u001b[0m                                       ^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue sort is not a member of List[Long] - did you mean withoutDuplicates.sortBy?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmptugoe85d.scala:34:63 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36moneWithoutDuplicatesAndSort\u001b[0m = oneWithoutDuplicates.sort\n\u001b[31m\u001b[31m   |\u001b[0m                                          ^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue sort is not a member of List[Long], but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.seq AsJavaList\n\u001b[31m",
      "stdout": "",
      "timestamp": 1660010461
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        val arr = arr.toArray\n        if (arr.length < 1) return List()\n        val len = arr.length\n        val l = arr.max\n        var i = 0\n        val map = mutable.Map[Int, String]()\n        val list = mutable.ListBuffer[String]()\n        while (i < len) {\n            val cur = arr(i)\n            val key = cur.toInt\n            val value = map.getOrElse(key, \"\")\n            list.+=(value)\n            i +=1\n            map.update(key, value+(i-1)) // map will update its values\n        }\n        val reversed = list.sortBy(_.length)\n        val result = reversed.reverse\n        list.foreach { x => map.update(x.toInt, x) }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpsn7j1q3i.scala:17:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = arr.toArray\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Recursive \u001b[33mvalue\u001b[0m \u001b[35marr\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpsn7j1q3i.scala:22:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmap\u001b[0m = mutable.Map[\u001b[35mInt\u001b[0m, \u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpsn7j1q3i.scala:23:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mlist\u001b[0m = mutable.ListBuffer[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660010458
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        val arr = arr.sortBy(x => x)\n        val length = arr.length\n        val list = arr.zipWithIndex\n        val strs = ListBuffer[String]()\n        val lastNumber = arr.last\n        // Handle the empty case\n        if(arr.isEmpty) strs.toList\n\n        // Handle the case where last number in the list is greater than length of list\n        if(lastNumber > length) strs.toList\n\n        // Iterate over list of numbers and add them into string\n        else {\n            for((n,i) <- list) {\n                if(n >= 1 && n <= 9) strs += list.reverse.take(i+1).toString.replaceAll(n.toString.toUpperCase, \"Nine\")\n                else if(n > length) strs.toList\n                else {\n                    strs.toList\n                }\n            }\n        }\n\n        // Return string with reversed numbers and names\n        strs.toList\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpdsiuqjlf.scala:17:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = arr.sortBy(\u001b[36mx\u001b[0m => x)\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Recursive \u001b[33mvalue\u001b[0m \u001b[35marr\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010457
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        val len = arr.length\n        val rslt = new ArrayList[String](len * 10)\n        var i = 0\n        var num = 0\n        for (a <- arr) {\n            while (num < 10) {\n                rslt(i) = if (num == 0) \"One\" else if (num == 1) \"Two\" else if (num == 2) \"Three\" else if (num == 3) \"Four\" else if (num == 4) \"Five\" else if (num == 5) \"Six\" else if (num == 6) \"Seven\" else if (num == 7) \"Eight\" else if (num == 8) \"Nine\" else \"Zero\"\n                i += 1\n                num = (num * 10 + a.toInt) % 10\n            }\n        }\n        return rslt.toList\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm5rrfeiq.scala:18:23 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mrslt\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mArrayList\u001b[0m[\u001b[35mString\u001b[0m](len * \u001b[31m10\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Not found: type ArrayList\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010458
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        arr.map(x => (if (x < 1l && x != -1l) x else x).map(x => x % 10).map((_ + Array(\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\")(_ % 10))): _*).flatten.toList\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E031] Syntax Error: /tmp/tmpr3wze0qd.scala:17:171 --------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        arr.map(\u001b[36mx\u001b[0m => (\u001b[33mif\u001b[0m (x < \u001b[31m1l\u001b[0m && x != -\u001b[31m1l\u001b[0m) x \u001b[33melse\u001b[0m x).map(\u001b[36mx\u001b[0m => x % \u001b[31m10\u001b[0m).map((_ + Array(\u001b[31m\"One\"\u001b[0m, \u001b[31m\"Two\"\u001b[0m, \u001b[31m\"Three\"\u001b[0m, \u001b[31m\"Four\"\u001b[0m, \u001b[31m\"Five\"\u001b[0m, \u001b[31m\"Six\"\u001b[0m, \u001b[31m\"Seven\"\u001b[0m, \u001b[31m\"Eight\"\u001b[0m, \u001b[31m\"Nine\"\u001b[0m)(_ % \u001b[31m10\u001b[0m))): \u001b[35m_*\u001b[0m).flatten.toList\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                                                                                                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                                    * can be used only for last argument\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpr3wze0qd.scala:17:56 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        arr.map(\u001b[36mx\u001b[0m => (\u001b[33mif\u001b[0m (x < \u001b[31m1l\u001b[0m && x != -\u001b[31m1l\u001b[0m) x \u001b[33melse\u001b[0m x).map(\u001b[36mx\u001b[0m => x % \u001b[31m10\u001b[0m).map((_ + Array(\u001b[31m\"One\"\u001b[0m, \u001b[31m\"Two\"\u001b[0m, \u001b[31m\"Three\"\u001b[0m, \u001b[31m\"Four\"\u001b[0m, \u001b[31m\"Five\"\u001b[0m, \u001b[31m\"Six\"\u001b[0m, \u001b[31m\"Seven\"\u001b[0m, \u001b[31m\"Eight\"\u001b[0m, \u001b[31m\"Nine\"\u001b[0m)(_ % \u001b[31m10\u001b[0m))): \u001b[35m_*\u001b[0m).flatten.toList\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     value map is not a member of Long\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660010461
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        val nameMap : Map[Long, String] = Map(1l -> \"One\", 2l -> \"Two\", 3l -> \"Three\", 4l -> \"Four\", 5l -> \"Five\", 6l -> \"Six\", 7l -> \"Seven\", 8l -> \"Eight\", 9l -> \"Nine\")\n        val ns = arr.map(i => (i / 10l, i mod 10l)).sortBy(_._1).reverse\n        val ret = ns.map{ case (l, r) => nameMap.getOrElse(l, l + \"?\")}\n        if (ret.isEmpty) Nil\n        else ret\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp7wmqegu6.scala:18:42 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mns\u001b[0m = arr.map(\u001b[36mi\u001b[0m => (i / \u001b[31m10l\u001b[0m, i mod \u001b[31m10l\u001b[0m)).sortBy(_._1).reverse\n\u001b[31m\u001b[31m   |\u001b[0m                                        ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue mod is not a member of Long, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mThe following import might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.BigInt.long2bigInt\n\u001b[31m   |\u001b[0m\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010462
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        if (arr.isEmpty) List()\n        else if (arr.head.abs < 9) arr.map(x => \"One\" toString x toLong).reverse\n        else if (arr.head.abs < 19) arr.map(x => \"Two\" toString x toLong).reverse\n        else if (arr.head.abs < 29) arr.map(x => \"Three\" toString x toLong).reverse\n        else if (arr.head.abs < 39) arr.map(x => \"Four\" toString x toLong).reverse\n        else if (arr.head.abs < 49) arr.map(x => \"Five\" toString x toLong).reverse\n        else if (arr.head.abs < 59) arr.map(x => \"Six\" toString x toLong).reverse\n        else if (arr.head.abs < 69) arr.map(x => \"Seven\" toString x toLong).reverse\n        else if (arr.head.abs < 89) arr.map(x => \"Eight\" toString x toLong).reverse\n        else if (arr.head.abs < 99) arr.map(x => \"Nine\" toString x toLong).reverse\n        else arr.map(x => \"Nine\" toString x toLong).reverse.map(x => (x toString arr))\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpubz50g3j.scala:18:71 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (arr.head.abs < \u001b[31m9\u001b[0m) arr.map(x => \u001b[31m\"One\"\u001b[0m toString x toLong).reverse\n\u001b[31m\u001b[31m   |\u001b[0m                                                                       ^\u001b[0m\n\u001b[31m   |\u001b[0m                                       expression expected but \u001b[31m')'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpubz50g3j.scala:19:72 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (arr.head.abs < \u001b[31m19\u001b[0m) arr.map(x => \u001b[31m\"Two\"\u001b[0m toString x toLong).reverse\n\u001b[31m\u001b[31m   |\u001b[0m                                                                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                                       expression expected but \u001b[31m')'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpubz50g3j.scala:20:74 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (arr.head.abs < \u001b[31m29\u001b[0m) arr.map(x => \u001b[31m\"Three\"\u001b[0m toString x toLong).reverse\n\u001b[31m\u001b[31m   |\u001b[0m                                                                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                                       expression expected but \u001b[31m')'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpubz50g3j.scala:21:73 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (arr.head.abs < \u001b[31m39\u001b[0m) arr.map(x => \u001b[31m\"Four\"\u001b[0m toString x toLong).reverse\n\u001b[31m\u001b[31m   |\u001b[0m                                                                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                                       expression expected but \u001b[31m')'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[3",
      "stdout": "",
      "timestamp": 1660010460
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        if (arr.isEmpty) List(\"\")\n        else if(arr.headOption match {\n            case Some(x) => arr.filter(_ > 1).toList map {x => byDigit(x) + \" \" ++ byDigit(x-1) }\n            case None => arr\n        }) else None\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpya8kb23e.scala:21:11 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        }) \u001b[33melse\u001b[0m None\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           'then' expected, but 'else' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpya8kb23e.scala:19:63 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m            \u001b[33mcase\u001b[0m Some(x) => arr.filter(_ > \u001b[31m1\u001b[0m).toList map {x => byDigit(x) + \u001b[31m\" \"\u001b[0m ++ byDigit(x-\u001b[31m1\u001b[0m) }\n\u001b[31m\u001b[31m   |\u001b[0m                                                               ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                                      Not found: byDigit\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpya8kb23e.scala:20:25 --------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m            \u001b[33mcase\u001b[0m None => arr\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Found:    (arr : List[Long])\n\u001b[31m   |\u001b[0m                         Required: Boolean\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[33m\u001b[33m-- [E129] Potential Issue Warning: /tmp/tmpya8kb23e.scala:22:4 -----------------\u001b[0m\u001b[0m\n\u001b[33m21 |\u001b[0m        }) \u001b[33melse\u001b[0m None\n\u001b[33m22 |\u001b[0m    }\n\u001b[33m\u001b[33m   |\u001b[0m                    ^\u001b[0m\n\u001b[33m   |\u001b[0mA pure expression does nothing in statement position; you may be omitting necessary parentheses\n\u001b[33m   |\u001b[0m\n\u001b[33m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 warning found\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660010462
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        var index = 0\n        var str = \"\"\n        while (index < arr.size) {\n            if (arr(index) > 9) {\n                str += \"nine\"\n                arr(index) = 9\n            } else {\n                str += \"One\"\n            }\n            index += 1\n        }\n        arr.reverse\n        for (i <- arr) {\n            str = str.replaceAll(\"([a-zA-Z])\", i match {\n                case x if \"nine\".equals(x) => (i + 9).toChar\n                case x if \"One\".equals(x) => (i + 10).toChar\n                case x if \"Two\".equals(x) => (i + 10).toChar\n                case x if \"Three\".equals(x) => (i + 10).toChar\n                case x if \"Four\".equals(x) => (i + 10).toChar\n                case x if \"Five\".equals(x) => (i + 10).toChar\n                case x if \"Six\".equals(x) => (i + 10).toChar\n                case x if \"Seven\".equals(x) => (i + 10).toChar\n                case x if \"Eight\".equals(x) => (i + 10).toChar\n                case x if \"Nine\".equals(x) => (i + 10).toChar\n                case x => throw new IllegalArgumentException(s\"Unexpected value: $x\")\n            })\n        }\n        arr.toList map {i => str match {\n            case \"nine\" => String.valueOf(i + 9)\n            case \"One\" => String.valueOf(i + 10)\n            case \"Two\" => String.valueOf(i + 10)\n            case \"Three\" => String.valueOf(i + 10)\n            case \"Four\" => String.valueOf(i + 10)\n            case \"Five\" => String.valueOf(i + 10)\n            case \"Six\" => String.valueOf(i + 10)\n            case \"Seven\" => String.valueOf(i + 10)\n            case \"Eight\" => String.valueOf(i + 10)\n            case \"Nine\" => String.valueOf(i + 10)\n            case x => throw new IllegalArgumentException(s\"Unexpected value: $x\")\n        }}\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp3bu2ea5x.scala:22:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m                arr(index) = \u001b[31m9\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^\u001b[0m\n\u001b[31m   |\u001b[0m  value update is not a member of List[Long] - did you mean arr.updated?\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp3bu2ea5x.scala:31:54 --------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m                \u001b[33mcase\u001b[0m x \u001b[33mif\u001b[0m \u001b[31m\"nine\"\u001b[0m.equals(x) => (i + \u001b[31m9\u001b[0m).toChar\n\u001b[31m\u001b[31m   |\u001b[0m                                              ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                              Found:    Char\n\u001b[31m   |\u001b[0m                                              Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp3bu2ea5x.scala:32:54 --------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m                \u001b[33mcase\u001b[0m x \u001b[33mif\u001b[0m \u001b[31m\"One\"\u001b[0m.equals(x) => (i + \u001b[31m10\u001b[0m).toChar\n\u001b[31m\u001b[31m   |\u001b[0m                                             ^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                             Found:    Char\n\u001b[31m   |\u001b[0m                                             Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp3bu2ea5x.scala:33:54 --------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m                \u001b[33mcase\u001b[0m x \u001b[33mif\u001b[0m \u001b[31m\"Two\"\u001b[0m.equals(x) => (i + \u001b[31m10\u001b[0m).toChar\n\u001b[31m\u001b[31m   |\u001b[0m                                             ^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                             Found:    Char\n\u001b[31m   |\u001b[0m                                             Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp3bu2ea5x.scala:34:56 --------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m                \u001b[33mcase\u001b[0m x \u001b[33mif\u001b[0m \u001b[31m\"Three\"\u001b[0m.equals(x)",
      "stdout": "",
      "timestamp": 1660010464
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        var output = List(\"\")\n        val listLength = arr.length\n        if(listLength < 1 || listLength > 9) {\n            return output\n        }\n\n        var reverseOutput = List(\"\")\n        var numberSet = Set[Long]()\n        val listLength = arr.length\n        for(i <- 0 until listLength) {\n            if(arr(i).isDefined) {\n                numberSet.add(arr(i).get)\n                reverseOutput += numberSet.toList.reverse.map{s => s\"${s}\".toLowerCase()}\n                numberSet = Set[Long]()\n            }\n        }\n        return output ++ reverseOutput\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp1t_8514s.scala:25:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mlistLength\u001b[0m = arr.length\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mlistLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mlistLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp1t_8514s.scala:27:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m            \u001b[33mif\u001b[0m(arr(i).isDefined) {\n\u001b[31m\u001b[31m   |\u001b[0m               ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m               value isDefined is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp1t_8514s.scala:28:37 ------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m                numberSet.add(arr(i).get)\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              value get is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp1t_8514s.scala:29:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m                reverseOutput += numberSet.toList.reverse.map{\u001b[36ms\u001b[0m => \u001b[31ms\"\u001b[0m${s}\u001b[31m\"\u001b[0m.toLowerCase()}\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue += is not a member of List[String] - did you mean List[String].!=?\n4 errors found\n",
      "stdout": "",
      "timestamp": 1660010465
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        val result = arr.groupBy(_.toInt).toList\n        val length = arr.size\n        val lastKey = result.lastOption.flatMap(_.lastOption)\n        if (result.nonEmpty && length < 9) {\n            result.reverse.foreach { r =>\n                if (r.toInt % 10 > 9) {\n                    val newKey = r.toInt.toString + lastKey.getOrElse(\"One\")\n                    result.add(newKey, r.toInt)\n                } else {\n                    result.add(lastKey.getOrElse(\"One\"), r.toInt)\n                }\n            }\n        }\n        if (length == 0) {\n            result\n        }\n        else if (length < 9) {\n            result.reverse.map { r =>\n                if (r.toInt % 10 > 9) {\n                    r.toInt.toString + lastKey.getOrElse(\"One\")\n                } else {\n                    lastKey.getOrElse(\"One\")\n                }\n            }\n        }\n        else {\n            result.reverse.map { r =>\n                if (r.toInt % 10 > 9) {\n                    r.toInt.toString + lastKey.getOrElse(\"One\")\n                } else {\n                    lastKey.getOrElse(\"One\")\n                }\n            }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp897dn7gu.scala:19:50 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mlastKey\u001b[0m = result.lastOption.flatMap(_.lastOption)\n\u001b[31m\u001b[31m   |\u001b[0m                                                ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   value lastOption is not a member of (Int, List[Long])\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp897dn7gu.scala:22:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m                \u001b[33mif\u001b[0m (r.toInt % \u001b[31m10\u001b[0m > \u001b[31m9\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue toInt is not a member of (Int, List[Long]), but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might make progress towards fixing the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.Fractional.Implicits.infixFractionalOps\n\u001b[31m   |\u001b[0m  import math.Integral.Implicits.infixIntegralOps\n\u001b[31m   |\u001b[0m  import math.Numeric.Implicits.infixNumericOps\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp897dn7gu.scala:23:35 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m                    \u001b[33mval\u001b[0m \u001b[36mnewKey\u001b[0m = r.toInt.toString + lastKey.getOrElse(\u001b[31m\"One\"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue toInt is not a member of (Int, List[Long]), but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might make progress towards fixing the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.Fractional.Implicits.infixFractionalOps\n\u001b[31m   |\u001b[0m  import math.Integral.Implicits.infixIntegralOps\n\u001b[31m   |\u001b[0m  import math.Numeric.Implicits.infixNumericOps\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp897dn7gu.scala:24:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m                    result.add(newKey, r.toInt)\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue add is not a member of List[(Int, List[Long])], but could be made avail",
      "stdout": "",
      "timestamp": 1660010471
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        if(arr.isEmpty) {\n            return Nil\n        }\n\n        var str = arr.sorted.map(\"One\".toChar).reverse + arr.sorted.map(\"Two\".toChar).reverse\n        var i = 0\n        while (i < str.size) {\n            str = str.replaceAll(str.substring(i, i + 1).toString.toLower,\n                (str.substring(i, i + 1).toString.toLower).replace(str.substring(i, i + 1).toString.toUpper, \"Zero\"))\n            i += 1\n        }\n        return str.sorted\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp2b9gsslo.scala:21:39 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mstr\u001b[0m = arr.sorted.map(\u001b[31m\"One\"\u001b[0m.toChar).reverse + arr.sorted.map(\u001b[31m\"Two\"\u001b[0m.toChar).reverse\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 value toChar is not a member of String\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp2b9gsslo.scala:21:78 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mstr\u001b[0m = arr.sorted.map(\u001b[31m\"One\"\u001b[0m.toChar).reverse + arr.sorted.map(\u001b[31m\"Two\"\u001b[0m.toChar).reverse\n\u001b[31m\u001b[31m   |\u001b[0m                                                                        ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                  value toChar is not a member of String\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660010468
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        if (arr.isEmpty) List()\n        else {\n            var result: List[String] = Nil\n            val len = arr.length\n            var currLength = 0\n            var currNum: Long = arr(0)\n            var firstDigit: String = null\n            for(i <- 1 to len) {\n                if(currLength == i) {\n                    currNum = arr(i)\n                    if (firstDigit == null) {\n                        firstDigit = s\"${currNum.toString}\"\n                    } else if (currNum > 9) {\n                        val tmp = firstDigit\n                        firstDigit = s\"${currNum.toString}\"\n                        currNum = tmp\n                    } else {\n                        firstDigit = s\"${firstDigit}_${currNum.toString}\"\n                    }\n                } else if(currNum < 9) {\n                    if (firstDigit == null) {\n                        firstDigit = s\"${currNum.toString}\"\n                    } else if (currNum > 9) {\n                        val tmp = firstDigit\n                        firstDigit = s\"${currNum.toString}\"\n                        currNum = tmp\n                    } else {\n                        firstDigit = s\"${firstDigit}_${currNum.toString}\"\n                    }\n                }\n                result = (currNum :: result.reverse).reverse\n                currLength = i + 1\n                currNum = arr(i)\n            }\n            result\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp7_8ymitx.scala:32:34 --------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m                        currNum = tmp\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Found:    (tmp : String)\n\u001b[31m   |\u001b[0m                                  Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp7_8ymitx.scala:42:34 --------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m                        currNum = tmp\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Found:    (tmp : String)\n\u001b[31m   |\u001b[0m                                  Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp7_8ymitx.scala:47:53 --------------------\u001b[0m\u001b[0m\n\u001b[31m47 |\u001b[0m                result = (currNum :: result.reverse).reverse\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Found:    List[Matchable]\n\u001b[31m   |\u001b[0m                         Required: List[String]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660010469
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        if (arr.isEmpty) {\n            return Nil\n        }\n        val sorted = arr.sortBy(l => l.toString.length)\n        val reversed = sorted.reverse\n        val result = reversed.map(x=> x.toString.replaceAll(\"\\\\D\", \"\"))\n        result.isEmpty\n            ? (Nil)\n            : (result.reverse.map { x => getCharForValue(x) }.toList)\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E103] Syntax Error: /tmp/tmpei8annh3.scala:25:36 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m            : (result.reverse.map { x => getCharForValue(x) }.toList)\n\u001b[31m\u001b[31m   |\u001b[0m                                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                                    Illegal start of declaration\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpei8annh3.scala:25:61 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m            : (result.reverse.map { x => getCharForValue(x) }.toList)\n\u001b[31m\u001b[31m   |\u001b[0m                                                             ^\u001b[0m\n\u001b[31m   |\u001b[0m                                             ')' expected, but '.' found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpei8annh3.scala:25:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m            : (result.reverse.map { x => getCharForValue(x) }.toList)\n\u001b[31m\u001b[31m   |\u001b[0m               ^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m               type map is not a member of List[String]\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpei8annh3.scala:24:12 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        result.isEmpty\n\u001b[31m24 |\u001b[0m            ? (Nil)\n\u001b[31m\u001b[31m   |\u001b[0m        ^\u001b[0m\n\u001b[31m   |\u001b[0m        value ? is not a member of Boolean.\n\u001b[31m   |\u001b[0m        Note that `?` is treated as an infix operator in Scala 3.\n\u001b[31m   |\u001b[0m        If you do not want that, insert a `;` or empty line in front\n\u001b[31m   |\u001b[0m        or drop any spaces behind the operator.\n4 errors found\n",
      "stdout": "",
      "timestamp": 1660010468
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        val longs = arr.filter(_ <= 9).toList\n        longs match {\n            case x :: x :: Nil => byLength(x.map(i => if (i >= 1 && i <= 9) name(i) else i.toString))\n            case x :: Nil => Nil\n            case _ => longs.reverse match {\n                case x2 :: x2 :: x2 :: _ => x2.map(i => if (i >= 1 && i <= 9) name(i) else i.toString)\n                case _ => Nil\n            }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E005] Naming Error: /tmp/tmp5t4imazv.scala:19:22 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m            \u001b[33mcase\u001b[0m x :: x :: Nil => byLength(x.map(i => \u001b[33mif\u001b[0m (i >= \u001b[31m1\u001b[0m && i <= \u001b[31m9\u001b[0m) name(i) \u001b[33melse\u001b[0m i.toString))\n\u001b[31m\u001b[31m   |\u001b[0m                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                      duplicate pattern variable: x\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp5t4imazv.scala:19:45 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m            \u001b[33mcase\u001b[0m x :: x :: Nil => byLength(x.map(i => \u001b[33mif\u001b[0m (i >= \u001b[31m1\u001b[0m && i <= \u001b[31m9\u001b[0m) name(i) \u001b[33melse\u001b[0m i.toString))\n\u001b[31m\u001b[31m   |\u001b[0m                                           ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                       value map is not a member of Long\n\u001b[31m\u001b[31m-- [E005] Naming Error: /tmp/tmp5t4imazv.scala:22:27 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m                \u001b[33mcase\u001b[0m x2 :: x2 :: x2 :: _ => x2.map(i => \u001b[33mif\u001b[0m (i >= \u001b[31m1\u001b[0m && i <= \u001b[31m9\u001b[0m) name(i) \u001b[33melse\u001b[0m i.toString)\n\u001b[31m\u001b[31m   |\u001b[0m                           ^^\u001b[0m\n\u001b[31m   |\u001b[0m                           duplicate pattern variable: x2\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E005] Naming Error: /tmp/tmp5t4imazv.scala:22:33 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m                \u001b[33mcase\u001b[0m x2 :: x2 :: x2 :: _ => x2.map(i => \u001b[33mif\u001b[0m (i >= \u001b[31m1\u001b[0m && i <= \u001b[31m9\u001b[0m) name(i) \u001b[33melse\u001b[0m i.toString)\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 duplicate pattern variable: x2\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp5t4imazv.scala:22:47 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m                \u001b[33mcase\u001b[0m x2 :: x2 :: x2 :: _ => x2.map(i => \u001b[33mif\u001b[0m (i >= \u001b[31m1\u001b[0m && i <= \u001b[31m9",
      "stdout": "",
      "timestamp": 1660010469
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        val m = arr.foldLeft(Map[String,Long]())((m,i) => {\n            val name = if(i<10) => \"One\"\n            else if(i<100) => \"Two\"\n            else if(i<1000) => \"Three\"\n            else if(i<10000) => \"Four\"\n            else if(i<100000) => \"Five\"\n            else if(i<1000000) => \"Six\"\n            else if(i<10000000) => \"Seven\"\n            else if(i<100000000) => \"Eight\"\n            else if(i<1000000000) => \"Nine\"\n            else if(i<10000000000) => \"Ten\"\n            else if(i<100000000000) => \"Eleven\"\n            else if(i<1000000000000) => \"Twelve\"\n            else if(i<10000000000000) => \"Thirteen\"\n            else if(i<100000000000000) => \"Fourteen\"\n            else if(i<1000000000000000) => \"Fifteen\"\n            else if(i<10000000000000000) => \"Sixteen\"\n            else if(i<100000000000000000) => \"Seventeen\"\n            else if(i<100000000000000000) => \"Eighteen\"\n            else if(i<1000000000000000000) => \"Nineteen\"\n            else if(i==0) \"Zero\"\n            else if(i==1) \"One\"\n            else if(i==-1) \"MinusOne\"\n            else if(i==55) \"Five\"\n            else if(i==-1L) \"MinusOne\"\n            else if(i==0L) \"Zero\"\n            else if(i==1L) \"One\"\n            else if(i==55L) \"Five\"\n            else if(i==-1L) m.add(\"MinusOne\")\n            else if(i==0L) m.add(\"Zero\")\n            else if(i==1L) m.add(\"One\")\n            else if(i==55L) m.add(\"Five\")\n            else {\n                if (i<100000000000000L) m.add(\"Twelve\")\n                else if (i<1000000000000000L) m.add(\"Thirteen\")\n                else if (i<10000000000000000L) m.add(\"Fourteen\")\n                else if (i<100000000000000000L) m.add(\"Fifteen\")\n                else if (i<1000000000000000000L) m.add(\"Sixteen\")\n                else m.add(\"Seventeen\")\n            }\n            val n = m.getOrElse(\"MinusOne\", 0L)\n            val x = m.getOrElse(\"Zero\", 0L)\n            val y = m.getOrElse(\"One\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp4wyd2mqc.scala:18:32 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mname\u001b[0m = \u001b[33mif\u001b[0m(i<\u001b[31m10\u001b[0m) => \u001b[31m\"One\"\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                                ^^\u001b[0m\n\u001b[31m   |\u001b[0m                                'then' expected, but '=>' found\n\u001b[31m\u001b[31m-- Error: /tmp/tmp4wyd2mqc.scala:59:32 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m59 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36my\u001b[0m = m.getOrElse(\"One\n\u001b[31m\u001b[31m   |\u001b[0m                                ^\u001b[0m\n\u001b[31m   |\u001b[0m                                unclosed string literal\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp4wyd2mqc.scala:61:34 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m61 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36mmain\u001b[0m(\u001b[36margs\u001b[0m: \u001b[35mArray\u001b[0m[\u001b[35mString\u001b[0m]) = {\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  ')' expected, but '=' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp4wyd2mqc.scala:70:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m70 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- Error: /tmp/tmp4wyd2mqc.scala:61:13 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m61 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36mmain\u001b[0m(\u001b[36margs\u001b[0m: \u001b[35mArray\u001b[0m[\u001b[35mString\u001b[0m]) = {\n\u001b[31m\u001b[31m   |\u001b[0m             ^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m         too many arguments for \u001b[33mconstructor\u001b[0m \u001b[35mmain\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mmain\u001b[0m: (): main\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp4wyd2mqc.scala:69:1 ---------------------\u001b[0m\u001b[0m\n\u001b[31m69 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m ^\u001b[0m\n\u001b[31m   |\u001b[0m Found:    Unit\n\u001b[31m   |\u001b[0m Required: List[String]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[33m\u001b[33m-- [E129] Potential Issue Warning: /tmp/tmp4wyd2mqc.scala:58:0 -----------------\u001b[0m\u001b[0m\n\u001b[33m56 |\u001b[0m            }\n\u001b[33m57 |\u001b[0m            \u001b[33mval\u001b[0m n = m.getOrElse(\u001b[31m\"MinusOne\"\u001b[0m, \u001b[31m0L\u001b[0m)\n\u001b[33m\u001b[33m   |\u001b[0m             ^\u001b[0m\n\u001b[",
      "stdout": "",
      "timestamp": 1660010470
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        if (arr.isEmpty) Nil\n        else arr.sortWith(_ < _ && _ > -1).map(_ / 10).reverse.map { z => oneToName(z.toInt) }.toList\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E086] Syntax Error: /tmp/tmprps1izxk.scala:18:26 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33melse\u001b[0m arr.sortWith(_ < _ && _ > -\u001b[31m1\u001b[0m).map(_ / \u001b[31m10\u001b[0m).reverse.map { z => oneToName(z.toInt) }.toList\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          Wrong number of parameters, expected: 2\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmprps1izxk.scala:18:74 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33melse\u001b[0m arr.sortWith(_ < _ && _ > -\u001b[31m1\u001b[0m).map(_ / \u001b[31m10\u001b[0m).reverse.map { z => oneToName(z.toInt) }.toList\n\u001b[31m\u001b[31m   |\u001b[0m                                                                          ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                                    Not found: oneToName\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660010467
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        var result: List[String] = Nil\n        var result2: List[Long] = arr\n        if (arr.isEmpty) arr\n        else if (arr.forall(_.toString.length >= 1 && _.toString.length <= 9)) {\n            result2 = arr.map(_ => if (_.toString.length >= 1 && _.toString.length <= 9) (\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\")\n            else Nil)\n        }\n        else {\n            val temp = arr\n            val list1 = temp.filter(_.toString.length >= 1 && _.toString.length <= 9).toList\n            val list2 = temp.filter(_.toString.length >=  10 && _.toString.length <= 19).toList\n            val list3 = temp.filter(_.toString.length >=  20 && _.toString.length <= 29).toList\n            val list4 = temp.filter(_.toString.length >=  30 && _.toString.length <= 39).toList\n            val list5 = temp.filter(_.toString.length >=  40 && _.toString.length <= 49).toList\n            val list6 = temp.filter(_.toString.length >=  50 && _.toString.length <= 59).toList\n            val list7 = temp.filter(_.toString.length >=  60 && _.toString.length <= 69).toList\n            val list8 = temp.filter(_.toString.length >=  70 && _.toString.length <= 89).toList\n            val list9 = temp.filter(_.toString.length >=  90 && _.toString.length >= 10).toList\n            val list10 = temp.filter(_.toString.length >= 100).toList\n\n            result2 = list1 ++ list2 ++ list3 ++ list4 ++ list5 ++ list6 ++ list7 ++ list8 ++ list9 ++ list10\n        }\n        result = result2.reverse.map((_.foldLeft[String](\"\")(_ + _))).filter(_ != \"One\").filter(_ != \"Two\").filter(_ != \"Three\").filter(_ != \"Four\").filter(_ != \"Five\").filter(_ != \"Six\").filter(_ != \"Seven\").filter(_ != \"Eight\").filter(_ != \"Nine\").filter(_ != \"Zero\")\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E086] Syntax Error: /tmp/tmpx6a1xp5a.scala:20:28 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (arr.forall(_.toString.length >= \u001b[31m1\u001b[0m && _.toString.length <= \u001b[31m9\u001b[0m)) {\n\u001b[31m\u001b[31m   |\u001b[0m                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                            Wrong number of parameters, expected: 1\n\u001b[31m\u001b[31m-- [E081] Type Error: /tmp/tmpx6a1xp5a.scala:21:39 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m            result2 = arr.map(_ => \u001b[33mif\u001b[0m (_.toString.length >= \u001b[31m1\u001b[0m && _.toString.length <= \u001b[31m9\u001b[0m) (\u001b[31m\"One\"\u001b[0m, \u001b[31m\"Two\"\u001b[0m, \u001b[31m\"Three\"\u001b[0m, \u001b[31m\"Four\"\u001b[0m, \u001b[31m\"Five\"\u001b[0m, \u001b[31m\"Six\"\u001b[0m, \u001b[31m\"Seven\"\u001b[0m, \u001b[31m\"Eight\"\u001b[0m, \u001b[31m\"Nine\"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                       ^\u001b[0m\n\u001b[31m   |\u001b[0m   Missing parameter type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m   I could not infer the type of the parameter _$4 of expanded function:\n\u001b[31m   |\u001b[0m   (_$4, _$5) => _$4.toString.length >= 1 && _$5.toString.length <= 9.\n\u001b[31m\u001b[31m-- [E081] Type Error: /tmp/tmpx6a1xp5a.scala:21:65 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m            result2 = arr.map(_ => \u001b[33mif\u001b[0m (_.toString.length >= \u001b[31m1\u001b[0m && _.toString.length <= \u001b[31m9\u001b[0m) (\u001b[31m\"One\"\u001b[0m, \u001b[31m\"Two\"\u001b[0m, \u001b[31m\"Three\"\u001b[0m, \u001b[31m\"Four\"\u001b[0m, \u001b[31m\"Five\"\u001b[0m, \u001b[31m\"Six\"\u001b[0m, \u001b[31m\"Seven\"\u001b[0m, \u001b[31m\"Eight\"\u001b[0m, \u001b[31m\"Nine\"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                                                 ^\u001b[0m\n\u001b[31m   |\u001b[0m   Missing parameter type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m   I could not infer the type of the parameter _$5 of expanded function:\n\u001b[31m   |\u001b[0m   (_$4, _$5) => _$4.toString.length >= 1 && _$5.toString.length <= 9.\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpx6a1xp5a.scala:21:89 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m            result2 = arr.map(_ => \u001b[33mif\u001b[0m (_.toString.length >= \u001b[31m1\u001b[0m && _.toString.length <= \u001b[31m9\u001b[0m) (\u001b[31m\"One\"\u001b[0m, \u001b[31m\"Two\"\u001b[0m, \u001b[31m\"Three\"\u001b[0m",
      "stdout": "",
      "timestamp": 1660010472
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        def byOneToNine(arr: List[Long]) : List[Long] = arr.filter(x => x >= 1 && x <= 9).toList.reverse\n        def byTenToTwenty(arr: List[Long]) : List[Long] = arr.filter(x => x >= 10 && x <= 20).toList.reverse\n        def byTwentyToThirty(arr: List[Long]) : List[Long] = arr.filter(x => x >= 20 && x <= 30).toList.reverse\n        def byThirtyToForty(arr: List[Long]) : List[Long] = arr.filter(x => x >= 30 && x <= 40).toList.reverse\n        def byFortyToFifty(arr: List[Long]) : List[Long] = arr.filter(x => x >= 40 && x <= 50).toList.reverse\n        def byFiftyToSixty(arr: List[Long]) : List[Long] = arr.filter(x => x >= 50 && x <= 60).toList.reverse\n        def bySixtyToSeventy(arr: List[Long]) : List[Long] = arr.filter(x => x >= 60 && x <= 70).toList.reverse\n        def bySeventyToEighty(arr: List[Long]) : List[Long] = arr.filter(x => x >= 70 && x <= 80).toList.reverse\n        def byEightyToNinety(arr: List[Long]) : List[Long] = arr.filter(x => x >= 80 && x <= 90).toList.reverse\n        def byNinetyToOne(arr: List[Long]) : List[Long] = arr.filter(x => x >= 90).toList.reverse\n        \n        if(arr.isEmpty) {\n            return Nil\n        }\n        else if((arr match {\n            case List(x) => x\n            case x => throw x\n        }).length != arr.size) {\n            return Nil\n        }\n        else if(!arr.contains(0)) {\n            return byOneToNine(arr)\n        }\n        else {\n            return byOneToNine(arr)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmprzhz5hkf.scala:33:28 --------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m            \u001b[33mcase\u001b[0m x => \u001b[33mthrow\u001b[0m x\n\u001b[31m\u001b[31m   |\u001b[0m                            ^\u001b[0m\n\u001b[31m   |\u001b[0m                            Found:    (x : List[Long])\n\u001b[31m   |\u001b[0m                            Required: Throwable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmprzhz5hkf.scala:38:30 --------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m            \u001b[33mreturn\u001b[0m byOneToNine(arr)\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Found:    List[\u001b[1m\u001b[31mLong\u001b[0m]\n\u001b[31m   |\u001b[0m                   Required: List[\u001b[1m\u001b[32mString\u001b[0m]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmprzhz5hkf.scala:41:30 --------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m            \u001b[33mreturn\u001b[0m byOneToNine(arr)\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Found:    List[\u001b[1m\u001b[31mLong\u001b[0m]\n\u001b[31m   |\u001b[0m                   Required: List[\u001b[1m\u001b[32mString\u001b[0m]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660010472
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        var reversed = arr.filter(_ >= 0).toList.reverse\n        var result: mutable.Buffer[String] = new mutable.ArrayBuffer[String]()\n        var next = \"\"\n        while (true) {\n            if (reversed.isEmpty) {\n                if (result == null || result.isEmpty) {\n                    result.clear()\n                } else {\n                    result.clear()\n                }\n                result.add(\"Empty\")\n                return result.toList\n            }\n            if (reversed.size == 1) {\n                next = reversed.head\n                reversed.clear()\n                result.add(next.toString)\n                continue\n            }\n            var i = 0\n            while (i < reversed.size) {\n                if (i + 1 == reversed.size && reversed(i) != reversed.head) {\n                    next = reversed(i)\n                    reversed.clear()\n                    result.add(next.toString)\n                    break\n                }\n                if (reversed(i) < reversed.head) {\n                    next = reversed(i)\n                    reversed.clear()\n                    result.add(next.toString)\n                    break\n                }\n                i = i + 1\n            }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpp4qpmln6.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mresult\u001b[0m: mutable.Buffer[\u001b[35mString\u001b[0m] = \u001b[33mnew\u001b[0m mutable.ArrayBuffer[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpp4qpmln6.scala:18:49 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mresult\u001b[0m: mutable.Buffer[\u001b[35mString\u001b[0m] = \u001b[33mnew\u001b[0m mutable.ArrayBuffer[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                                                 ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                                 Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpp4qpmln6.scala:31:32 --------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m                next = reversed.head\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    Long\n\u001b[31m   |\u001b[0m                       Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpp4qpmln6.scala:32:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m                reversed.clear()\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue clear is not a member of List[Long], but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.seq AsJavaList\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversionsToJava.seq AsJavaList\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.collection asJava\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversionsToJava.collection asJava\n\u001b[31m   |\u001b[0m\n\u001b[3",
      "stdout": "",
      "timestamp": 1660010473
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        val list = arr.filter(_ < 10).sorted\n        if (list.nonEmpty) {\n            val result = list.reverse.map(x => if (x < 10) \"One\" else if (x < 20) \"Two\" else if (x < 30) \"Three\" else if (x < 40) \"Four\" else if (x < 50) \"Five\" else if (x < 60) \"Six\" else if (x < 70) \"Seven\" else if (x < 80) \"Eight\" else \"Nine\").mkString(\",\")\n            val result = result.split(\",\")\n            val result = result.map(_.replaceAll(\"\\\\D\", \"\")).map(x => if (x == \"One\") \"One\" else if (x == \"Two\") \"Two\" else if (x == \"Three\") \"Three\" else if (x == \"Four\") \"Four\" else if (x == \"Five\") \"Five\" else if (x == \"Six\") \"Six\" else if (x == \"Seven\") \"Seven\" else if (x == \"Eight\") \"Eight\" else \"Nine\").mkString(\",\")\n            result\n        } else {\n            List()\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp32yjr5b8.scala:20:16 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = result.split(\u001b[31m\",\"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mresult is already defined as \u001b[33mvalue\u001b[0m \u001b[35mresult\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp32yjr5b8.scala:21:16 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = result.map(_.replaceAll(\u001b[31m\"\\\\D\"\u001b[0m, \u001b[31m\"\"\u001b[0m)).map(\u001b[36mx\u001b[0m => \u001b[33mif\u001b[0m (x == \u001b[31m\"One\"\u001b[0m) \u001b[31m\"One\"\u001b[0m \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (x == \u001b[31m\"Two\"\u001b[0m) \u001b[31m\"Two\"\u001b[0m \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (x == \u001b[31m\"Three\"\u001b[0m) \u001b[31m\"Three\"\u001b[0m \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (x == \u001b[31m\"Four\"\u001b[0m) \u001b[31m\"Four\"\u001b[0m \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (x == \u001b[31m\"Five\"\u001b[0m) \u001b[31m\"Five\"\u001b[0m \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (x == \u001b[31m\"Six\"\u001b[0m) \u001b[31m\"Six\"\u001b[0m \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (x == \u001b[31m\"Seven\"\u001b[0m) \u001b[31m\"Seven\"\u001b[0m \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (x == \u001b[31m\"Eight\"\u001b[0m) \u001b[31m\"Eight\"\u001b[0m \u001b[33melse\u001b[0m \u001b[31m\"Nine\"\u001b[0m).mkString(\u001b[31m\",\"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mresult is already defined as \u001b[33mvalue\u001b[0m \u001b[35mresult\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp32yjr5b8.scala:22:12 --------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            result\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            Found:    (result : String)\n\u001b[31m   |\u001b[0m            Required: List[String]\n\u001b[31m   |\u001b[0m",
      "stdout": "",
      "timestamp": 1660010472
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        def helper(arr: List[Long], out: List[String]) : List[String] = {\n            arr match {\n                case List() =>\n                    if (out.length == 0) {\n                        out\n                    } else {\n                        out :+ \"\"\n                    }\n                case x :: xs =>\n                    if (x < 1 || x > 9) {\n                        helper(xs, out)\n                    } else {\n                        val y = math.ceil(x / 10.toDouble).toInt\n                        if (y % 2 == 0) {\n                            helper(xs, out)\n                        } else {\n                            out :+ \"One\"\n                        }\n                    }\n            }\n        }\n        helper(arr, List[String]())\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpkjvtefy0.scala:41)\n\tat Problem.main(tmpkjvtefy0.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660010474
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        if(arr.isEmpty) return List()\n        val ones = arr.filter(_ <= 9).map(_.toString).filterNot(_.isEmpty).sorted\n        val tens = arr.filter(_ > 9).map(_.toString).filterNot(_.isEmpty).reverse\n        val tensAndOnes = tens.concat(ones)\n        val nines = arr.filter(_ <= 9).map(_.toString).filterNot(_.isEmpty).sorted\n        val onesAndTens = ones.concat(tens)\n        val onesAndNines = ones.concat(nines)\n        val nameMap: Map[Long, String] = Map(\n            1l -> \"One\",\n            2l -> \"Two\",\n            3l -> \"Three\",\n            4l -> \"Four\",\n            5l -> \"Five\",\n            6l -> \"Six\",\n            7l -> \"Seven\",\n            8l -> \"Eight\",\n            9l -> \"Nine\"\n        )\n        tensAndOnes.map(v => nameMap(v)).reverse.map(v => nameMap(v))\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpzeomwm1v.scala:35:37 --------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m        tensAndOnes.map(\u001b[36mv\u001b[0m => nameMap(v)).reverse.map(\u001b[36mv\u001b[0m => nameMap(v))\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                                     Found:    (v : String)\n\u001b[31m   |\u001b[0m                                     Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpzeomwm1v.scala:35:66 --------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m        tensAndOnes.map(\u001b[36mv\u001b[0m => nameMap(v)).reverse.map(\u001b[36mv\u001b[0m => nameMap(v))\n\u001b[31m\u001b[31m   |\u001b[0m                                                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                  Found:    (v : String)\n\u001b[31m   |\u001b[0m                                                  Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660010473
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        if(arr.nonEmpty) {\n            var list = arr.toList.sortWith( (l, r) => (l<r) ? (r<l) : l<r)\n            var reverse = list.reverse\n            val newList = reverse.map(i => (\n                {\n                    val result = i match {\n                        case 1    => \"One\"\n                        case 2    => \"Two\"\n                        case 3    => \"Three\"\n                        case 4    => \"Four\"\n                        case 5    => \"Five\"\n                        case 6    => \"Six\"\n                        case 7    => \"Seven\"\n                        case 8    => \"Eight\"\n                        case 9    => \"Nine\"\n                        case _    => \"None\"\n                    }\n                    result\n                }\n            )).toList\n            newList\n        } else {\n            List()\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpcj8rq_j3.scala:18:71 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m            \u001b[33mvar\u001b[0m \u001b[36mlist\u001b[0m = arr.toList.sortWith( (\u001b[36ml\u001b[0m, \u001b[36mr\u001b[0m) => (l<r) ? (r<l) : \u001b[35ml<r\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                                                       ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                       Not found: type <\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpcj8rq_j3.scala:18:60 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m            \u001b[33mvar\u001b[0m \u001b[36mlist\u001b[0m = arr.toList.sortWith( (\u001b[36ml\u001b[0m, \u001b[36mr\u001b[0m) => (l<r) ? (r<l) : \u001b[35ml<r\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                                      ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                      value ? is not a member of Boolean\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660010472
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        val digits = arr.zipWithIndex.sortBy(_._1).reverse\n        val zeroes = Array.fill(digits.size)(0)\n        val result = digits.map(i => zeroes ++ Array(name(i), name(i+9)))\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp11bfemsw.scala:19:53 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = digits.map(\u001b[36mi\u001b[0m => zeroes ++ Array(name(i), name(i+\u001b[31m9\u001b[0m)))\n\u001b[31m\u001b[31m   |\u001b[0m                                                     ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                                     Not found: name\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp11bfemsw.scala:19:62 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = digits.map(\u001b[36mi\u001b[0m => zeroes ++ Array(name(i), name(i+\u001b[31m9\u001b[0m)))\n\u001b[31m\u001b[31m   |\u001b[0m                                                              ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                                         Not found: name\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp11bfemsw.scala:19:68 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = digits.map(\u001b[36mi\u001b[0m => zeroes ++ Array(name(i), name(i+\u001b[31m9\u001b[0m)))\n\u001b[31m\u001b[31m   |\u001b[0m                                                                   ^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue + is not a member of (Long, Int), but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might make progress towards fixing the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.Fractional.Implicits.infixFractionalOps\n\u001b[31m   |\u001b[0m  import math.Integral.Implicits.infixIntegralOps\n\u001b[31m   |\u001b[0m  import math.Numeric.Implicits.infixNumericOps\n\u001b[31m   |\u001b[0m\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660010474
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        arr\n            .map { n =>\n                val digit = n % 10\n                val name = if (digit < 1) \"One\" else if (digit < 2) \"Two\" else if (digit < 3) \"Three\" else if (digit < 4) \"Four\" else if (digit < 5) \"Five\" else if (digit < 6) \"Six\" else if (digit < 7) \"Seven\" else if (digit < 8) \"Eight\" else \"Nine\"\n                s\"$name\"\n            }\n            .toList\n            .reverse\n            .toList\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmppci_hgth.scala:28)\n\tat Problem.main(tmppci_hgth.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660010474
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        if (arr.isEmpty) List()\n        val reversed = arr.map(x => if (x >= 9) \"\" else (x+48).asInstanceOf[String])\n        val reversedList = new collection.mutable.ListBuffer[String]()\n        reversed.foreach(x => reversedList += getString(x))\n        reversedList.reverse.map(x => getString(x)).mkString(\"\")\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpq8xp248f.scala:20:46 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        reversed.foreach(\u001b[36mx\u001b[0m => reversedList += getString(x))\n\u001b[31m\u001b[31m   |\u001b[0m                                              ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                              Not found: getString\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpq8xp248f.scala:21:38 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        reversedList.reverse.map(\u001b[36mx\u001b[0m => getString(x)).mkString(\u001b[31m\"\"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                      Not found: getString\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660010471
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n      if (arr.nonEmpty) {\n        arr.sortWith(_.compareTo(1l) < 0)\n        arr.reverse.map(_ => Array.fill(9)(1).toString)\n      }\n      else\n        List()\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E086] Syntax Error: /tmp/tmpejefajrm.scala:18:21 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        arr.sortWith(_.compareTo(\u001b[31m1l\u001b[0m) < \u001b[31m0\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Wrong number of parameters, expected: 2\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010471
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        if (arr.isEmpty || arr.exists(_ < 1 || _ > 9)) {\n            return Nil\n        }\n        val m = arr.max\n        val s = arr.min\n        val a = Array.ofDim[Int](10)\n        for (i<- s until (s + m)) a(i) = i.toString\n        val r = arr.map(i => a(i).toLowerCase)\n        val l = r.mkString(\"\")\n        if (l == \"nineteen\") {\n            return Nil\n        }\n        val c = l.length()\n        for (i<- 0 until (c / 2)) {\n            r(i) = r(c - i - 1)\n        }\n        val f = r.mkString(\"\")\n        val d = f.replace(d => if (d == \"one\") \"One\" else if (d == \"two\") \"Two\" else if (d == \"three\") \"Three\" else if (d == \"four\") \"Four\" else if (d == \"five\") \"Five\" else if (d == \"six\") \"Six\" else if (d == \"seven\") \"Seven\" else if (d == \"eight\") \"Eight\" else if (d == \"nine\") \"Nine\" else d, \"\")\n        d.toLowerCase :: byLength(arr)\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E086] Syntax Error: /tmp/tmpl_15zxty.scala:17:38 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        \u001b[33mif\u001b[0m (arr.isEmpty || arr.exists(_ < \u001b[31m1\u001b[0m || _ > \u001b[31m9\u001b[0m)) {\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Wrong number of parameters, expected: 1\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpl_15zxty.scala:23:36 --------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mfor\u001b[0m (i<- s until (s + m)) a(i) = i.toString\n\u001b[31m\u001b[31m   |\u001b[0m                                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                                    Found:    (i : Long)\n\u001b[31m   |\u001b[0m                                    Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpl_15zxty.scala:23:41 --------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mfor\u001b[0m (i<- s until (s + m)) a(i) = i.toString\n\u001b[31m\u001b[31m   |\u001b[0m                                         ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                         Found:    String\n\u001b[31m   |\u001b[0m                                         Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpl_15zxty.scala:24:31 --------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mr\u001b[0m = arr.map(\u001b[36mi\u001b[0m => a(i).toLowerCase)\n\u001b[31m\u001b[31m   |\u001b[0m                               ^\u001b[0m\n\u001b[31m   |\u001b[0m                               Found:    (i : Long)\n\u001b[31m   |\u001b[0m                               Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpl_15zxty.scala:31:12 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m            r(i) = r(c - i - \u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m            ^\u001b[0m\n\u001b[31m   |\u001b[0m value update is not a member of List[Nothing] - did you mean r.updated?\n\u001b[31m\u001b[31m-- [E134] Type Error: /tmp",
      "stdout": "",
      "timestamp": 1660010474
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        if (arr.isEmpty) return List()\n        val n = arr.head\n        def makeName(i : Long, arr : List[Long]) : String = {\n            val index = (arr.indexOf (i) match {\n                case -1 => -1\n                case index if index < arr.length - 1 => index\n            }).toInt\n            arr(index).toString\n        }\n        val map0 = scala.collection.mutable.Map[String, String]()\n        map0(\"0\") += \"Zero\"\n        map0(\"1\") += \"One\"\n        map0(\"2\") += \"Two\"\n        map0(\"3\") += \"Three\"\n        map0(\"4\") += \"Four\"\n        map0(\"5\") += \"Five\"\n        map0(\"6\") += \"Six\"\n        map0(\"7\") += \"Seven\"\n        map0(\"8\") += \"Eight\"\n        map0(\"9\") += \"Nine\"\n        val list = arr\n            .tail\n            .filter(_ >= 0l && _ <= 9l)\n            .sortWith((x, y) => x < y)\n            .reverse\n            .map(x => makeName(x.toInt, list))\n        list.toList\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E086] Syntax Error: /tmp/tmp3a_agfpr.scala:39:20 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m            .filter(_ >= \u001b[31m0l\u001b[0m && _ <= \u001b[31m9l\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Wrong number of parameters, expected: 1\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp3a_agfpr.scala:42:40 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m            .map(x => makeName(x.toInt, list))\n\u001b[31m\u001b[31m   |\u001b[0m                                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                                        Recursive \u001b[33mvalue\u001b[0m \u001b[35mlist\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660010473
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        val res = arr.filterNot(_ < 1l.toLong)\n        val revRes = res.reverse\n        revRes.map(_ => byLengthList(res, revRes))\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp0pi7pzqr.scala:19:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        revRes.map(_ => byLengthList(res, revRes))\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        Not found: byLengthList\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010472
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        arr.filter(i => i <= 9 && i >= 1).reverse.map(i => (arr(i) - 48).asInstanceOf[String]).toList\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpqirqtubd.scala:17:64 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        arr.filter(\u001b[36mi\u001b[0m => i <= \u001b[31m9\u001b[0m && i >= \u001b[31m1\u001b[0m).reverse.map(\u001b[36mi\u001b[0m => (arr(i) - \u001b[31m48\u001b[0m).asInstanceOf[\u001b[35mString\u001b[0m]).toList\n\u001b[31m\u001b[31m   |\u001b[0m                                                                ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                    Found:    (i : Long)\n\u001b[31m   |\u001b[0m                                                    Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010476
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        val list = arr.toList\n        if (list.isEmpty)\n          List.empty\n        else {\n          val first = list.head\n          val rest = list.drop(1)\n          val lastDigit = rest match {\n            case head :: tail => tail.last\n            case _ => 0\n          }\n          val digitNames = List(1l, 2l, 3l, 4l, 5l, 6l, 7l, 8l, 9l)\n          val firstDigit = digitNames.find(_.toInt == first).toOption\n          val firstName = (firstDigit.isEmpty) match {\n            case None => \"One\"\n            case Some(firstDigit) =>\n              val firstNames = List(\n                  \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"\n                )\n              firstNames(firstDigit.toInt)\n          }\n          val result = rest.reverse\n            .map(d => if (d == lastDigit) firstName else digitNames(d))\n            .mkString(\"\")\n          List(firstName + result)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpo8oe2vsn.scala:28:61 ------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m          \u001b[33mval\u001b[0m \u001b[36mfirstDigit\u001b[0m = digitNames.find(_.toInt == first).toOption\n\u001b[31m\u001b[31m   |\u001b[0m                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          value toOption is not a member of Option[Long]\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpo8oe2vsn.scala:38:68 --------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m            .map(d => \u001b[33mif\u001b[0m (d == lastDigit) firstName \u001b[33melse\u001b[0m digitNames(d))\n\u001b[31m\u001b[31m   |\u001b[0m                                                                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                    Found:    (d : Long)\n\u001b[31m   |\u001b[0m                                                    Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660010478
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        val ones = arr.filter(i => i <= 9).toList\n        val fives = arr.filter(i => i <= 19).toList\n        val teens = arr.filter(i => i <= 29).toList\n        val nines = arr.filter(i => i <= 39).toList\n        val twenty = arr.filter(i => i <= 49).toList\n        val hundred = arr.filter(i => i <= 59).toList\n        val thousand = arr.filter(i => i <= 999).toList\n        val zero = arr.filter(i => i < 1).toList\n        if (ones.isEmpty) List()\n        else if (fives.isEmpty) List()\n        else if (teens.isEmpty) List()\n        else if (nines.isEmpty) List()\n        else if (twenty.isEmpty) List()\n        else if (hundred.isEmpty) List()\n        else if (thousand.isEmpty) List()\n        else if (zero.isEmpty) List()\n        else {\n            val onesString = ones\n                .map(i => if (i < 10) \"One\" else (if (i < 100) \"Two\" else \"Three\"))\n                .reverse\n                .toList\n            val fivesString = fives\n                .map(i => if (i < 10) \"Five\" else (if (i < 100) \"Four\" else \"Three\"))\n                .reverse\n                .toList\n            val teensString = teens\n                .map(i => if (i < 10) \"Seven\" else (if (i < 100) \"Six\" else \"Five\"))\n                .reverse\n                .toList\n            val ninesString = nines\n                .map(i => if (i < 10) \"Eight\" else (if (i < 100) \"Nine\" else \"Four\"))\n                .reverse\n                .toList\n            val twentyString = twenty\n                .map(i => if (i < 10) \"Ten\" else (if (i < 100) \"Eleven\" else \"Twelve\"))\n                .reverse\n                .toList\n            val hundredString = hundred\n                .map(i => if (i < 10) \"One\" else (if (i < 100) \"Two\" else \"Three\"))\n                .reverse\n                .toList\n            val thousandString = thousand\n                .map(i => if (i < 10) \"One\" else (if (i < 100) \"Two\" else \"Three\"))\n                .reverse\n                .toList\n            val zeroString = zero\n                .map(i => if (i < 10) \"Zero\" else (if (i < 100) \"One\" else \"Two\"))\n                .reverse\n                .toList\n\n            val result = onesString.concat(fivesString).concat(teensString).concat(ninesString).concat(twentyString).concat(hundredString\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp_2ldg_e6.scala:68:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m68 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    ')' expected, but '}' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp_2ldg_e6.scala:78:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m78 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp_2ldg_e6.scala:77:1 ---------------------\u001b[0m\u001b[0m\n\u001b[31m77 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m ^\u001b[0m\n\u001b[31m   |\u001b[0m Found:    Unit\n\u001b[31m   |\u001b[0m Required: List[String]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[33m\u001b[33m-- Warning: /tmp/tmp_2ldg_e6.scala:69:4 ----------------------------------------\u001b[0m\u001b[0m\n\u001b[33m69 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36mmain\u001b[0m(\u001b[36margs\u001b[0m: \u001b[35mArray\u001b[0m[\u001b[35mString\u001b[0m]) = {\n\u001b[33m\u001b[33m   |\u001b[0m    ^\u001b[0m\n\u001b[33m   |\u001b[0m    Line is indented too far to the left, or a `}` is missing\n1 warning found\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660010479
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        // Only one number is in the list.\n        if (arr.size == 1) {\n            List(arr(0).asInstanceOf[Int])\n        } else {\n            // Sort by length, then reverse the order.\n            arr.sortWith(_ < _).reverse\n            // For each number in the list, replace it with the value from the map.\n            val map = new mutable.HashMap[Int, String]()\n            map += (1 -> \"One\")\n            map += (2 -> \"Two\")\n            map += (3 -> \"Three\")\n            map += (4 -> \"Four\")\n            map += (5 -> \"Five\")\n            map += (6 -> \"Six\")\n            map += (7 -> \"Seven\")\n            map += (8 -> \"Eight\")\n            map += (9 -> \"Nine\")\n            arr.map(x => map.getOrElse(x, \"Unknown number: \" + x))\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpv0qzbc36.scala:19:36 --------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m            List(arr(\u001b[31m0\u001b[0m).asInstanceOf[\u001b[35mInt\u001b[0m])\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                 Found:    Int\n\u001b[31m   |\u001b[0m                 Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpv0qzbc36.scala:24:26 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mmap\u001b[0m = \u001b[33mnew\u001b[0m mutable.HashMap[\u001b[35mInt\u001b[0m, \u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660010480
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        val ones = arr.filter(_ <= 9).toList\n        val tens = arr.filter(_ >= 1 && _ <= 9).toList\n        val ones_reverse = reverse(ones)\n        val tens_reverse = reverse(tens)\n        ones_reverse ++ tens_reverse.map(_.toString)\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E086] Syntax Error: /tmp/tmp_fdccwco.scala:18:30 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mtens\u001b[0m = arr.filter(_ >= \u001b[31m1\u001b[0m && _ <= \u001b[31m9\u001b[0m).toList\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              Wrong number of parameters, expected: 1\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp_fdccwco.scala:19:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mones_reverse\u001b[0m = reverse(ones)\n\u001b[31m\u001b[31m   |\u001b[0m                           ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                           Not found: reverse\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp_fdccwco.scala:20:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mtens_reverse\u001b[0m = reverse(tens)\n\u001b[31m\u001b[31m   |\u001b[0m                           ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                           Not found: reverse\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660010476
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        if (arr.isEmpty)\n            List()\n        else if (arr.head > 9 || arr.last < 1)\n            List()\n        else {\n            // We use a mutable collection to solve this problem with a more functional approach.\n            var result = mutable.ArrayBuffer.empty[String]\n            var digit = arr.head\n            var low = 1\n            var high = 9\n            var index = high / 10\n\n            // while loop to compare all digits to find the first one out of order\n            while (digit < 1 || digit > 9) {\n                // remove the first digit from both digits and result and shift other digits to its place\n                digit = digit.toInt\n                index = index - 1\n                if (index < 0) index = 0\n                var current = digit.toInt\n                digit = digit.toInt\n                result.clear()\n\n                // Add the digits into the result string\n                if (current <= low) {\n                    if (current <= digit) result.add(\"One\")\n                    if (current > digit) result.add(\"One\")\n                }\n                else if (current >= high) {\n                    if (current > digit) result.add(\"One\")\n                    if (current >= low) result.add(\"One\")\n                }\n                else if (current > low) {\n                    if (current > digit) result.add(\"Two\")\n                    if (current <= digit) result.add(\"Two\")\n                }\n                else if (current < high) {\n                    if (current < digit) result.add(\"Two\")\n                    if (current >= low) result.add(\"Two\")\n                }\n                else {\n                    if (current <= digit) result.add(\"Three\")\n                    if (current > digit) result.add(\"Three\")\n                    if (current < digit) result.add(\"Three\")\n                }\n            }\n\n            // Reverse the result of the algorithm\n            result = result.reverse\n\n            // Replace all digits with their names from the digits table\n            if (result.nonEmpty) {\n                var length = result.size\n                var i = 1\n                while (i <= length) {\n                    if (i > 1) {\n                        result(i) = (i % 10) + \"-\" + result(i)\n                    }\n                    i = i + 1\n                }\n            }\n\n            result.toList\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpmq_12q06.scala:23:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m            \u001b[33mvar\u001b[0m \u001b[36mresult\u001b[0m = mutable.ArrayBuffer.empty[\u001b[35mString\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010477
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        val result = arr.sortWith((x, y) => x > y) match {\n            case x :: y => x.reverse.map(z => {\n                val digit = math.floor(z / 10)\n                val name = z % 10\n                if (digit > 9) s\"${digit - 9}${name}\" else s\"${digit}${name}\"\n            })\n            case x => Nil\n        }\n        result.reverse.map(s => s + \"One\" :: s).flatten\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpio_tsiek.scala:18:29 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m            \u001b[33mcase\u001b[0m x :: y => x.reverse.map(z => {\n\u001b[31m\u001b[31m   |\u001b[0m                           ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                           value reverse is not a member of Long\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010481
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        if (arr.isEmpty) List()\n        if (arr.head < 2L) List(\"One\")\n        else if (arr.head < 4L) List(\"Two\")\n        else if (arr.head < 6L) List(\"Three\")\n        else if (arr.head < 8L) List(\"Four\")\n        else if (arr.head < 10L) List(\"Five\")\n        else if (arr.head < 12L) List(\"Six\")\n        else if (arr.head < 14L) List(\"Seven\")\n        else if (arr.head < 16L) List(\"Eight\")\n        else if (arr.head < 18L) List(\"Nine\")\n        else byLength(arr.tail)\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpktiqmdkp.scala:30)\n\tat Problem.main(tmpktiqmdkp.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660010484
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        val len = arr.length\n        var newArr : List[String] = Nil\n\n        for (x <- arr) {\n            if (x > 9 || x < 1) {\n                newArr = newArr ++ List(\"\")\n            } else {\n                var str = x.toString.toInt\n                if (str >= 1 && str <= 9) {\n                    str = str - 10\n                }\n                newArr = newArr ++ List(String.valueOf(str))\n            }\n        }\n        if (newArr.length == len) {\n            newArr\n        } else {\n            for (x <- newArr) {\n                if (x == \"10\") {\n                    newArr = newArr ++ List(\"\")\n                } else {\n                    newArr = newArr ++ List(String.valueOf(x))\n                }\n            }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp9u3nei3i.scala:34:12 --------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m            \u001b[33mfor\u001b[0m (x <- newArr) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^\u001b[0m\n\u001b[31m   |\u001b[0m            Found:    Unit\n\u001b[31m   |\u001b[0m            Required: List[String]\n\u001b[31m35 |\u001b[0m                \u001b[33mif\u001b[0m (x == \u001b[31m\"10\"\u001b[0m) {\n\u001b[31m36 |\u001b[0m                    newArr = newArr ++ List(\u001b[31m\"\"\u001b[0m)\n\u001b[31m37 |\u001b[0m                } \u001b[33melse\u001b[0m {\n\u001b[31m38 |\u001b[0m                    newArr = newArr ++ List(String.valueOf(x))\n\u001b[31m39 |\u001b[0m                }\n\u001b[31m40 |\u001b[0m            }\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010482
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        if (arr.isEmpty) Nil\n        else arr.foldLeft((List[String]())) { (acc, num) =>\n            if (num >= 1L && num <= 9L) List(\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\")(math.abs(num.toInt))\n            else if (num == 1L) List(\"One\")\n            else Nil\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmppy44narc.scala:19:116 -------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m            \u001b[33mif\u001b[0m (num >= \u001b[31m1L\u001b[0m && num <= \u001b[31m9L\u001b[0m) List(\u001b[31m\"One\"\u001b[0m, \u001b[31m\"Two\"\u001b[0m, \u001b[31m\"Three\"\u001b[0m, \u001b[31m\"Four\"\u001b[0m, \u001b[31m\"Five\"\u001b[0m, \u001b[31m\"Six\"\u001b[0m, \u001b[31m\"Seven\"\u001b[0m, \u001b[31m\"Eight\"\u001b[0m, \u001b[31m\"Nine\"\u001b[0m)(math.abs(num.toInt))\n\u001b[31m\u001b[31m   |\u001b[0m                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                        Found:    String\n\u001b[31m   |\u001b[0m                                        Required: \u001b[1m\u001b[32mList\u001b[0m\u001b[1m\u001b[32m[\u001b[0mString\u001b[1m\u001b[32m]\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010483
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        var res = arr.map(n => (n%10).toString + \"-\" + Array(\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\").get(n/10).toString).sorted.reverse\n\n        var res : List[String] = arr.map{ n => {\n            var s = n % 10\n            var index = s.toInt\n            s += \"-\" + Array(\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\").get(n/10).toString\n            res = res.filter(_ != s)\n            res\n        }\n        }.filter(_.toString.startsWith(\"One\"))\n\n        res.map(x => x.dropRight(1).drop(1).map(_ + \" \"))\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpa_5xjw88.scala:19:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mres\u001b[0m : \u001b[35mList\u001b[0m[\u001b[35mString\u001b[0m] = arr.map{ \u001b[36mn\u001b[0m => {\n\u001b[31m\u001b[31m   |\u001b[0m        ^\u001b[0m\n\u001b[31m   |\u001b[0mres is already defined as \u001b[33mvariable\u001b[0m \u001b[35mres\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m20 |\u001b[0m            \u001b[33mvar\u001b[0m \u001b[36ms\u001b[0m = n % \u001b[31m10\u001b[0m\n\u001b[31m21 |\u001b[0m            \u001b[33mvar\u001b[0m \u001b[36mindex\u001b[0m = s.toInt\n\u001b[31m22 |\u001b[0m            s += \u001b[31m\"-\"\u001b[0m + Array(\u001b[31m\"One\"\u001b[0m, \u001b[31m\"Two\"\u001b[0m, \u001b[31m\"Three\"\u001b[0m, \u001b[31m\"Four\"\u001b[0m, \u001b[31m\"Five\"\u001b[0m, \u001b[31m\"Six\"\u001b[0m, \u001b[31m\"Seven\"\u001b[0m, \u001b[31m\"Eight\"\u001b[0m, \u001b[31m\"Nine\"\u001b[0m).get(n/\u001b[31m10\u001b[0m).toString\n\u001b[31m23 |\u001b[0m            res = res.filter(_ != s)\n\u001b[31m24 |\u001b[0m            res\n\u001b[31m25 |\u001b[0m        }\n\u001b[31m26 |\u001b[0m        }.filter(_.toString.startsWith(\u001b[31m\"One\"\u001b[0m))\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpa_5xjw88.scala:17:133 -----------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mres\u001b[0m = arr.map(\u001b[36mn\u001b[0m => (n%\u001b[31m10\u001b[0m).toString + \u001b[31m\"-\"\u001b[0m + Array(\u001b[31m\"One\"\u001b[0m, \u001b[31m\"Two\"\u001b[0m, \u001b[31m\"Three\"\u001b[0m, \u001b[31m\"Four\"\u001b[0m, \u001b[31m\"Five\"\u001b[0m, \u001b[31m\"Six\"\u001b[0m, \u001b[31m\"Seven\"\u001b[0m, \u001b[31m\"Eight\"\u001b[0m, \u001b[31m\"Nine\"\u001b[0m).get(n/\u001b[31m10\u001b[0m).toString).sorted.reverse\n\u001b[31m\u001b[31m   |\u001b[0m                                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              value get is not a member of Array[String]\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpa_5xjw88.scala:28:48 --------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        res.map(\u001b[36mx\u001b[0m => x.dropRight(\u001b[31m1\u001b[0m).drop(\u001b[31m1\u001b[0m).map(_ + \u001b[31m\" \"\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                                                ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                                Found:    Char => \u001b[1m\u001b[31mString\u001b[0m\n\u001b[31m   |\u001b[0m                                 ",
      "stdout": "",
      "timestamp": 1660010484
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        val list = arr.toList\n        val digitMap = Map(1 -> \"One\", 2 -> \"Two\", 3 -> \"Three\", 4 -> \"Four\", 5 -> \"Five\", 6 -> \"Six\", 7 -> \"Seven\", 8 -> \"Eight\", 9 -> \"Nine\")\n        val newList = mutable.List.empty[String]\n        for (i <- 0 until list.size) {\n            if (i <= 9) {\n                newList += digitMap(list(i))\n            } else if (i < 10) {\n                newList += digitMap(list(i) + 10)\n            }\n        }\n        if (newList.isEmpty) list\n        else list.reverse.map(s => digitMap(s).toString).reverse + newList\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp6h5a0kov.scala:19:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnewList\u001b[0m = mutable.List.empty[\u001b[35mString\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp6h5a0kov.scala:27:29 --------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mif\u001b[0m (newList.isEmpty) list\n\u001b[31m\u001b[31m   |\u001b[0m                             ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                             Found:    (list : List[Long])\n\u001b[31m   |\u001b[0m                             Required: List[String]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp6h5a0kov.scala:28:44 --------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        \u001b[33melse\u001b[0m list.reverse.map(s => digitMap(s).toString).reverse + newList\n\u001b[31m\u001b[31m   |\u001b[0m                                            ^\u001b[0m\n\u001b[31m   |\u001b[0m                                            Found:    (s : Long)\n\u001b[31m   |\u001b[0m                                            Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660010484
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        val str = arr.filter(n => n > 0 && n < 9).toList.sortBy(n => n)\n        str.reverse.map(_.toString).filterNot(_.equals(\"One\")).map(_.toString).toList\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpe3nvsrk9.scala:21)\n\tat Problem.main(tmpe3nvsrk9.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660010486
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        val ones = arr.filter(_ > 0).map(i => s\"${i.toInt}\").sorted\n        val tens = arr.filter(_ >= 10).map(i => s\"${i.toInt/10}\").sorted\n        val hundreds = arr.filter(_ >= 100).map(i => s\"${i.toInt/100}\").sorted\n        val thousands = arr.filter(_ >= 1000).map(i => s\"${i.toInt/1000}\").sorted\n\n        val onesNames = ones\n        val tensNames = tens\n        val hundredsNames = hundreds\n        val thousandsNames = thousands\n\n        if (ones.length == 0 || tens.length == 0 || hundreds.length == 0 || thousands.length == 0) {\n            List()\n        } else if (ones.length + tens.length + hundreds.length + thousands.length == arr.length) {\n            onesNames ++ tensNames ++ hundredsNames ++ thousandsNames\n        } else {\n            onesNames ++ tensNames ++ hundredsNames ++ thousandsNames ++ arr.drop(onesNames.size + tensNames.size + hundredsNames.size + thousandsNames.size)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp31_xgsyx.scala:32:81 --------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m            onesNames ++ tensNames ++ hundredsNames ++ thousandsNames ++ arr.drop(onesNames.size + tensNames.size + hundredsNames.size + thousandsNames.size)\n\u001b[31m\u001b[31m   |\u001b[0m                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                          Found:    List[Long]\n\u001b[31m   |\u001b[0m                                          Required: IterableOnce[String]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010484
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        val result = arr\n            .map(x => if(x < 1 && x > 9) x else \"\" + x.toString)\n            .map(x => if(x.matches(\".*[1-9].*\"))\n                x.replaceFirst(\"[1-9]\",\n                    (for (x <- \"One\" until \"Nine\") yield x.toUpperCase))\n            else x\n            )\n            .sorted\n            .map(x => if (x.matches(\".*[1-9].*\")) {\n                if (x.isDigit) {\n                    val i = x.toInt - '0'\n                    if (i >= 0 && i <= 9)\n                        x.toUpperCase + i.toString\n                    else\n                        x.toUpperCase\n                }\n                else x\n            }\n            else x\n            )\n            .reverse\n            .mkString(\",\")\n        if (arr.isEmpty) \"\" else result\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpq3fn9wp8.scala:19:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m            .map(x => \u001b[33mif\u001b[0m(x.matches(\u001b[31m\".*[1-9].*\"\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         value matches is not a member of Matchable\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpq3fn9wp8.scala:20:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m                x.replaceFirst(\u001b[31m\"[1-9]\"\u001b[0m,\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                value replaceFirst is not a member of Matchable\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpq3fn9wp8.scala:21:37 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m                    (\u001b[33mfor\u001b[0m (x <- \u001b[31m\"One\"\u001b[0m until \u001b[31m\"Nine\"\u001b[0m) \u001b[33myield\u001b[0m x.toUpperCase))\n\u001b[31m\u001b[31m   |\u001b[0m                               ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                               value until is not a member of String\n\u001b[31m\u001b[31m-- Error: /tmp/tmpq3fn9wp8.scala:24:19 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m            .sorted\n\u001b[31m\u001b[31m   |\u001b[0m                   ^\u001b[0m\n\u001b[31m   |\u001b[0mNo implicit Ordering defined for B\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mwhere:    B is a type variable with constraint >: Matchable\n\u001b[31m   |\u001b[0m..\n\u001b[31m   |\u001b[0mI found:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m    scala.math.Ordering.ordered[\u001b[35mB\u001b[0m](\n\u001b[31m   |\u001b[0m      /* missing */summon[scala.math.Ordering.AsComparable[B]]\n\u001b[31m   |\u001b[0m    )\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mBut no implicit values were found that match type scala.math.Ordering.AsComparable[B].\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpq3fn9wp8.scala:39:25 --------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m        \u001b[33mif\u001b[0m (arr.isEmpty) \u001b[31m\"\"\u001b[0m \u001b[33melse\u001b[0m result\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Found:    (\u001b[32m\"\"\u001b[0m : String)\n\u001b[31m   |\u001b[0m                         Required: List[String]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-exp",
      "stdout": "",
      "timestamp": 1660010485
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        if (!arr.isEmpty) {\n            val list = arr.filter(_ < 10).sortWith(_ < _).reverse\n            val num : Int = 0\n            val reverse = list.map(_ - num)\n            val result : List[String] = reverse match {\n                case Nil => Nil\n                case x :: tail => List(x.toString)\n            }\n            return result\n        }\n        return Nil\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpk91opojw.scala:30)\n\tat Problem.main(tmpk91opojw.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660010485
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        val one  = new Array[String](10)\n        val two  = new Array[String](10)\n        val three = new Array[String](10)\n        val four  = new Array[String](10)\n        val five  = new Array[String](10)\n        val six  = new Array[String](10)\n        val seven = new Array[String](10)\n        val eight = new Array[String](10)\n        val nine = new Array[String](10)\n        for (i <- 0 to arr.length -1){\n            val length = arr(i)\n            if(length >=1 && length <=9){\n                val digit = (length-1).toInt\n                one(digit) = One(digit)\n                two(digit) = Two(digit)\n                three(digit) = Three(digit)\n                four(digit) = Four(digit)\n                five(digit) = Five(digit)\n                six(digit) = Six(digit)\n                seven(digit) = Seven(digit)\n                eight(digit) = Eight(digit)\n                nine(digit) = Nine(digit)\n            }\n        }\n        val result = new Array[String](arr.length)\n        for (i <- 0 to arr.length -1){\n            val length = arr(i)\n            if(length >=1 && length <=9){\n                result(i) = digits(length-1) + one(i)\n            }\n        }\n        if(arr.length == 0){\n            result(0) = \"\"\n        }\n        else if(arr.length == 1){\n            result(0) = one(0)\n        }\n        else if(arr.length == 2){\n            result(0) = two(0)\n            result(1) = one(0)\n        }\n        else if(arr.length == 3){\n            result(0) = two(0)\n            result(1) = one(0)\n            result(2) = three(0)\n        }\n        else if(arr.length == 4){\n            result(0) = two(0)\n            result(1) = one(0)\n            result(2) = three(0)\n            result(3) = four(0)\n        }\n        else if(arr.length == 5){\n            result(0) = two(0)\n            result(1) = one(0)\n            result(2) = three(0)\n            result(3) = four(0)\n            result(4) = five(0)\n        }\n        else if(arr.length == 6){\n            result(0) = two(0)\n            result(1) = one(0)\n            result(2) = three(0)\n            result(3) = four(0)\n            result(4) = five(0)\n            result(5) = six(0)\n        }\n        else if(arr.length == 7){\n            result(0) = two(0)\n            result(1) = one(0)\n            result(2) = three(0)\n            result\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpwnihc1ls.scala:99:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m99 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpwnihc1ls.scala:30:29 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m                one(digit) = One(digit)\n\u001b[31m\u001b[31m   |\u001b[0m                             ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                             Not found: One\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpwnihc1ls.scala:31:29 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m                two(digit) = Two(digit)\n\u001b[31m\u001b[31m   |\u001b[0m                             ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                             Not found: Two\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpwnihc1ls.scala:32:31 ------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m                three(digit) = Three(digit)\n\u001b[31m\u001b[31m   |\u001b[0m                               ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                               Not found: Three\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpwnihc1ls.scala:33:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m                four(digit) = Four(digit)\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              Not found: Four\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpwnihc1ls.scala:34:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m                five(digit) = Five(digit)\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              Not found: Five\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpwnihc1ls.scala:35:29 --------------------",
      "stdout": "",
      "timestamp": 1660010486
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        arr match {\n            case Nil => Nil\n            case head :: tail => {\n                val newHead = head.multiply(new Long(10)).toInt\n                val newTail = tail.reverse.filter(d => d > 0 && d < 10).toList.sortWith(_ < _)\n                val result = new StringBuilder\n                result.append(byLength(newHead))\n                result.append(byLength(newTail))\n                result.toString\n            }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp8spxfl1q.scala:20:35 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m                \u001b[33mval\u001b[0m \u001b[36mnewHead\u001b[0m = head.multiply(\u001b[33mnew\u001b[0m \u001b[35mLong\u001b[0m(\u001b[31m10\u001b[0m)).toInt\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              value multiply is not a member of Long\n\u001b[31m\u001b[31m-- Error: /tmp/tmp8spxfl1q.scala:20:53 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m                \u001b[33mval\u001b[0m \u001b[36mnewHead\u001b[0m = head.multiply(\u001b[33mnew\u001b[0m \u001b[35mLong\u001b[0m(\u001b[31m10\u001b[0m)).toInt\n\u001b[31m\u001b[31m   |\u001b[0m                                                     ^^\u001b[0m\n\u001b[31m   |\u001b[0m         too many arguments for \u001b[33mconstructor\u001b[0m \u001b[35mLong\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mLong\u001b[0m: (): Long\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp8spxfl1q.scala:25:16 --------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m                result.toString\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Found:    String\n\u001b[31m   |\u001b[0m                Required: \u001b[1m\u001b[32mList\u001b[0m\u001b[1m\u001b[32m[\u001b[0mString\u001b[1m\u001b[32m]\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660010485
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n      val r = arr.filter(_ >= 1l.toLong && _ <= 9l.toLong).toList\n      val sorted = r.sortBy(_.toInt)\n      val reversed = sorted.reverse\n      val list = mutable.ListBuffer[String]()\n      var i = 0\n      var str = \"\"\n      while(i < reversed.size) {\n        str +=  reversed(i).asInstanceOf[Long].toString\n        list += str\n        i += 1\n      }\n      if(reversed.size == 0) {\n        return List()\n      }\n      list.toList\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E086] Syntax Error: /tmp/tmpigll2dfr.scala:17:25 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m      \u001b[33mval\u001b[0m \u001b[36mr\u001b[0m = arr.filter(_ >= \u001b[31m1l\u001b[0m.toLong && _ <= \u001b[31m9l\u001b[0m.toLong).toList\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Wrong number of parameters, expected: 1\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpigll2dfr.scala:20:17 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m      \u001b[33mval\u001b[0m \u001b[36mlist\u001b[0m = mutable.ListBuffer[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                 Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660010482
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n      val mapOneToNine = Map(\"Zero\" -> \"Zero\", \"One\" -> \"One\", \"Two\" -> \"Two\", \"Three\" -> \"Three\", \"Four\" -> \"Four\", \"Five\" -> \"Five\", \"Six\" -> \"Six\", \"Seven\" -> \"Seven\", \"Eight\" -> \"Eight\", \"Nine\" -> \"Nine\")\n      val mapOneToNineReverse = mapOneToNine.reverse\n      val arr = arr.filter(x => x >= 1l && x <= 9l) \n      val mapLongToName = arr.map(x => if (x < 10l) mapOneToNineReverse(x) else mapOneToNine(x))\n      arr match {\n        case Nil => Nil\n        case head :: tail => head + \" \" + byLength(tail)\n      }\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpm6o4a6hc.scala:18:45 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m      \u001b[33mval\u001b[0m \u001b[36mmapOneToNineReverse\u001b[0m = mapOneToNine.reverse\n\u001b[31m\u001b[31m   |\u001b[0m                                ^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue reverse is not a member of scala.collection.mutable.Map[String, String], but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mThe following import might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.Ordering.ordered\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpm6o4a6hc.scala:19:16 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m      \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = arr.filter(\u001b[36mx\u001b[0m => x >= \u001b[31m1l\u001b[0m && x <= \u001b[31m9l\u001b[0m) \n\u001b[31m\u001b[31m   |\u001b[0m                ^\u001b[0m\n\u001b[31m   |\u001b[0m                Recursive \u001b[33mvalue\u001b[0m \u001b[35marr\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm6o4a6hc.scala:23:29 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mcase\u001b[0m head :: tail => head + \u001b[31m\" \"\u001b[0m + byLength(tail)\n\u001b[31m\u001b[31m   |\u001b[0m                             ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                             Not found: head\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660010485
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        val sortedList = arr.sortWith(_ < _)\n        val reverseList = sortedList.reverse\n        val intList = reverseList.map(i => i.toString.toInt)\n        val zeroIndex = intList.length - 1\n        val reversedList = intList.reverse.map((zeroIndex, i) => i -> \"One\")\n        reversedList.foldLeft(List[String]())((x, y) => x ++ y)\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E086] Syntax Error: /tmp/tmp5kj363xb.scala:21:62 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mreversedList\u001b[0m = intList.reverse.map((\u001b[36mzeroIndex\u001b[0m, \u001b[36mi\u001b[0m) => i -> \u001b[31m\"One\"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Wrong number of parameters, expected: 1\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010483
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        if(arr.isEmpty) List()\n        if(arr.head.compareTo(1)==0) byLength(arr.reverse).map(str=>{\n            val l = str.split(\"\\\\D+\")\n            if(l.length==1 && l.head==\"One\") \"One\"\n            else if(l.length==1 && l.head==\"Two\") \"Two\"\n            else if(l.length==1 && l.head==\"Three\") \"Three\"\n            else if(l.length==1 && l.head==\"Four\") \"Four\"\n            else if(l.length==1 && l.head==\"Five\") \"Five\"\n            else if(l.length==1 && l.head==\"Six\") \"Six\"\n            else if(l.length==1 && l.head==\"Seven\") \"Seven\"\n            else if(l.length==1 && l.head==\"Eight\") \"Eight\"\n            else if(l.length==1 && l.head==\"Nine\") \"Nine\"\n            else \"\"\n        }).reverse\n        else byLength(arr.reverse).map(str=>{\n            val l = str.split(\"\\\\D+\")\n            if(l.length==1 && l.head==\"One\") \"One\"\n            else if(l.length==1 && l.head==\"Two\") \"Two\"\n            else if(l.length==1 && l.head==\"Three\") \"Three\"\n            else if(l.length==1 && l.head==\"Four\") \"Four\"\n            else if(l.length==1 && l.head==\"Five\") \"Five\"\n            else if(l.length==1 && l.head==\"Six\") \"Six\"\n            else if(l.length==1 && l.head==\"Seven\") \"Seven\"\n            else if(l.length==1 && l.head==\"Eight\") \"Eight\"\n            else if(l.length==1 && l.head==\"Nine\") \"Nine\"\n            else \"\"\n        }).reverse\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "Exception in thread \"main\" java.lang.StackOverflowError\n\tat Problem$.byLength(tmpdi6j924h.scala:18)\n\tat Problem$.byLength(tmpdi6j924h.scala:31)\n\tat Problem$.byLength(tmpdi6j924h.scala:31)\n\tat Problem$.byLength(tmpdi6j924h.scala:31)\n\tat Problem$.byLength(tmpdi6j924h.scala:31)\n\tat Problem$.byLength(tmpdi6j924h.scala:31)\n\tat Problem$.byLength(tmpdi6j924h.scala:31)\n\tat Problem$.byLength(tmpdi6j924h.scala:31)\n\tat Problem$.byLength(tmpdi6j924h.scala:31)\n\tat Problem$.byLength(tmpdi6j924h.scala:31)\n\tat Problem$.byLength(tmpdi6j924h.scala:31)\n\tat Problem$.byLength(tmpdi6j924h.scala:31)\n\tat Problem$.byLength(tmpdi6j924h.scala:31)\n\tat Problem$.byLength(tmpdi6j924h.scala:31)\n\tat Problem$.byLength(tmpdi6j924h.scala:31)\n\tat Problem$.byLength(tmpdi6j924h.scala:31)\n\tat Problem$.byLength(tmpdi6j924h.scala:31)\n\tat Problem$.byLength(tmpdi6j924h.scala:31)\n\tat Problem$.byLength(tmpdi6j924h.scala:31)\n\tat Problem$.byLength(tmpdi6j924h.scala:31)\n\tat Problem$.byLength(tmpdi6j924h.scala:31)\n\tat Problem$.byLength(tmpdi6j924h.scala:31)\n\tat Problem$.byLength(tmpdi6j924h.scala:31)\n\tat Problem$.byLength(tmpdi6j924h.scala:31)\n\tat Problem$.byLength(tmpdi6j924h.scala:31)\n\tat Problem$.byLength(tmpdi6j924h.scala:31)\n\tat Problem$.byLength(tmpdi6j924h.scala:31)\n\tat Problem$.byLength(tmpdi6j924h.scala:31)\n\tat Problem$.byLength(tmpdi6j924h.scala:31)\n\tat Problem$.byLength(tmpdi6j924h.scala:31)\n\tat Problem$.byLength(tmpdi6j924h.scala:31)\n\tat Problem$.byLength(tmpdi6j924h.scala:31)\n\tat Problem$.byLength(tmpdi6j924h.scala:31)\n\tat Problem$.byLength(tmpdi6j924h.scala:31)\n\tat Problem$.byLength(tmpdi6j924h.scala:31)\n\tat Problem$.byLength(tmpdi6j924h.scala:31)\n\tat Problem$.byLength(tmpdi6j924h.scala:31)\n\tat Problem$.byLength(tmpdi6j924h.scala:31)\n\tat Problem$.byLength(tmpdi6j924h.scala:31)\n\tat Problem$.byLength(tmpdi6j924h.scala:31)\n\tat Problem$.byLength(tmpdi6j924h.scala:31)\n\tat Problem$.byLength(tmpdi6j924h.scala:31)\n\tat Problem$.byLength(tmpdi6j924h.scala:31)\n\tat Problem$.byLength(tmpdi6j924h.scala:31)\n\tat Problem$.byLength(tmpdi6j924h.scala:31)\n\tat Problem$",
      "stdout": "",
      "timestamp": 1660010488
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        val a = arr.filter(_ < 1l).filter(_ > 9l)\n        val b = a.reverse\n        val c = b.map(_ - 10l)\n        if (c.isEmpty) List()\n        else c.map(_.toString)\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpxqh3gwpu.scala:24)\n\tat Problem.main(tmpxqh3gwpu.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660010487
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        if (arr.isEmpty) List()\n        else {\n            // reverse the list\n            val revArr = arr.reverse\n            // transform the list\n            val strArr = revArr.map { v =>\n                if (v >= 1 && v <= 9) s\"$v\" else \"Other\"\n            }\n            // add the digits from 1 to 9 at the beginning\n            val numStr = strArr.filter(_ != \"Other\").init.filter(_ != \"Other\").init.mkString(\" \")\n            // replace every digit by its name from 1 to 9\n            val result = numStr.map { v => s\"One $v\" }.filter(_ != \"Other\")\n            result :+ numStr.filter(_ == \"Other\").map { v => s\"Other $v\" }.filter(_ != \"Other\").headOption\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmpllvazq4x.scala:29:36 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m            result :+ numStr.filter(_ == \u001b[31m\"Other\"\u001b[0m).map { \u001b[36mv\u001b[0m => \u001b[31ms\"Other \u001b[0m$v\u001b[31m\"\u001b[0m }.filter(_ != \u001b[31m\"Other\"\u001b[0m).headOption\n\u001b[31m\u001b[31m   |\u001b[0m                                    ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Values of types Char and String cannot be compared with == or !=\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010487
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        val l = arr.length\n        val reversed = arr.map(v => if (v >= 1 && v < 9) v.toString else \"\").mkString(\"\")\n        val numbers = reversed.split(\"\\\\W+\".toRegex).map(_.toInt).filter(_ >= 1 && _ < 10)\n        val names = new collection.mutable.HashMap[Int, String]\n        names.put(1, \"One\")\n        names.put(2, \"Two\")\n        names.put(3, \"Three\")\n        names.put(4, \"Four\")\n        names.put(5, \"Five\")\n        names.put(6, \"Six\")\n        names.put(7, \"Seven\")\n        names.put(8, \"Eight\")\n        names.put(9, \"Nine\")\n        numbers.map(v => names.get(v)).toList\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp8e3otzpj.scala:19:44 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumbers\u001b[0m = reversed.split(\u001b[31m\"\\\\W+\"\u001b[0m.toRegex).map(_.toInt).filter(_ >= \u001b[31m1\u001b[0m && _ < \u001b[31m10\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 value toRegex is not a member of String\n\u001b[31m\u001b[31m-- [E086] Syntax Error: /tmp/tmp8e3otzpj.scala:19:73 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumbers\u001b[0m = reversed.split(\u001b[31m\"\\\\W+\"\u001b[0m.toRegex).map(_.toInt).filter(_ >= \u001b[31m1\u001b[0m && _ < \u001b[31m10\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                                                         ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Wrong number of parameters, expected: 1\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp8e3otzpj.scala:30:39 --------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        numbers.map(\u001b[36mv\u001b[0m => names.get(v)).toList\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Found:    List[\u001b[1m\u001b[31mOption\u001b[0m\u001b[1m\u001b[31m[\u001b[0mString\u001b[1m\u001b[31m]\u001b[0m]\n\u001b[31m   |\u001b[0m        Required: List[String]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660010488
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        val strs = arr.map(_.toString).filter(_.isDigit).sortWith(_ < _).reverse\n        val map = new collection.mutable.Map[String, String](\n            \"1\"=\"One\",\n            \"2\"=\"Two\",\n            \"3\"=\"Three\",\n            \"4\"=\"Four\",\n            \"5\"=\"Five\",\n            \"6\"=\"Six\",\n            \"7\"=\"Seven\",\n            \"8\"=\"Eight\",\n            \"9\"=\"Nine\",\n            \"0\"=\"Zero\"\n        ).withDefaultValue(\"None\")\n        strs.map(s => map.getOrElse(s, s))\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp1f4lfz8c.scala:19:15 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m            \u001b[31m\"1\"\u001b[0m=\u001b[31m\"One\"\u001b[0m,\n\u001b[31m\u001b[31m   |\u001b[0m               ^\u001b[0m\n\u001b[31m   |\u001b[0m               ')' expected, but '=' found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp1f4lfz8c.scala:17:48 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstrs\u001b[0m = arr.map(_.toString).filter(_.isDigit).sortWith(_ < _).reverse\n\u001b[31m\u001b[31m   |\u001b[0m                                              ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 value isDigit is not a member of String\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660010488
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        if (arr.isEmpty) Nil\n        else arr.map(x => if (x < 9) x.toString else s\"$x\").sorted.reverse.map(x => if (x % 10 == 0) x else s\"$x\").filterNot(_.equals(\"One\")) :: Nil\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpcu25fuw9.scala:18:90 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33melse\u001b[0m arr.map(x => \u001b[33mif\u001b[0m (x < \u001b[31m9\u001b[0m) x.toString \u001b[33melse\u001b[0m \u001b[31ms\"\u001b[0m$x\u001b[31m\"\u001b[0m).sorted.reverse.map(x => \u001b[33mif\u001b[0m (x % \u001b[31m10\u001b[0m == \u001b[31m0\u001b[0m) x \u001b[33melse\u001b[0m \u001b[31ms\"\u001b[0m$x\u001b[31m\"\u001b[0m).filterNot(_.equals(\u001b[31m\"One\"\u001b[0m)) :: Nil\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                        ^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue % is not a member of String, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mThe following import might make progress towards fixing the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.Integral.Implicits.infixIntegralOps\n\u001b[31m   |\u001b[0m\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010492
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n      val list = arr.toList\n      val one = 0\n      val two = 1\n      val three = 2\n      val four = 3\n      val five = 4\n      val six = 5\n      val seven = 6\n      val eight = 7\n      val nine = 8\n\n      if (list.nonEmpty) {\n          val twoLast = list.last + 2\n          val lastDigit = list.last / 10\n          val lastTwoDigit = list.last / 10\n          val lastThreeDigit = list.last / 10\n          val lastFourDigit = list.last / 10\n          val lastFiveDigit = list.last / 10\n          val lastSixDigit = list.last / 10\n          val lastSevenDigit = list.last / 10\n          val lastEightDigit = list.last / 10\n          val lastNineDigit = list.last / 10\n          val lastTwelveDigit = list.last / 10\n\n          if (lastTwoDigit < 2 && twoLast < 9 && lastDigit < 9 && lastFourDigit < 9 && lastThreeDigit < 9 && lastFiveDigit < 9 && lastSixDigit < 9 && lastSevenDigit < 9 && lastEightDigit < 9 && lastNineDigit < 9 && lastTwelveDigit < 9) {\n            val twoList = list.slice(1, list.size)\n            val twoDigit = twoList.last + 2\n            val twoLastTwoDigit = twoList.last / 10\n            val twoLastThreeDigit = twoList.last / 10\n            val twoLastFourDigit = twoList.last / 10\n            val twoLastFiveDigit = twoList.last / 10\n            val twoLastSixDigit = twoList.last / 10\n            val twoLastSevenDigit = twoList.last / 10\n            val twoLastEightDigit = twoList.last / 10\n            val twoLastNineDigit = twoList.last / 10\n            val twoLastTwelveDigit = twoList.last / 10\n\n            if (twoLastTwoDigit < 2 && twoLast < 9 && lastDigit < 9 && lastFourDigit < 9 && lastThreeDigit < 9 && lastFiveDigit < 9 && lastSixDigit < 9 && lastSevenDigit < 9 && lastEightDigit < 9 && lastNineDigit < 9 && lastTwelveDigit < 9) {\n              val lastList = list.slice(0, list.size)\n              val lastDigit\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpvm1l5vwz.scala:57:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m57 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpvm1l5vwz.scala:67:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m67 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[33m\u001b[33m-- Warning: /tmp/tmpvm1l5vwz.scala:58:4 ----------------------------------------\u001b[0m\u001b[0m\n\u001b[33m58 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36mmain\u001b[0m(\u001b[36margs\u001b[0m: \u001b[35mArray\u001b[0m[\u001b[35mString\u001b[0m]) = {\n\u001b[33m\u001b[33m   |\u001b[0m    ^\u001b[0m\n\u001b[33m   |\u001b[0m    Line is indented too far to the left, or a `}` is missing\n1 warning found\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660010489
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        def byTwo(l : List[Long], result : List[String]) : List[String] = {\n            l match {\n                case x::xs => byTwo(xs, result + byOne(x).toString)\n                case Nil => result\n            }\n        }\n        def byOne(l: List[Long]) : List[String] = {\n            l match {\n                case 1 => List(\"One\")\n                case 2 => List(\"Two\")\n                case 3 => List(\"Three\")\n                case 4 => List(\"Four\")\n                case 5 => List(\"Five\")\n                case 6 => List(\"Six\")\n                case 7 => List(\"Seven\")\n                case 8 => List(\"Eight\")\n                case 9 => List(\"Nine\")\n                case _ => List(\"?\")\n            }\n        }\n        arr match {\n            case Nil => Nil\n            case x :: xs => byTwo(arr, Nil)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpnqwnqkhv.scala:19:47 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m                \u001b[33mcase\u001b[0m x::xs => byTwo(xs, result + byOne(x).toString)\n\u001b[31m\u001b[31m   |\u001b[0m                                        ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue + is not a member of List[String], but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might make progress towards fixing the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.Fractional.Implicits.infixFractionalOps\n\u001b[31m   |\u001b[0m  import math.Integral.Implicits.infixIntegralOps\n\u001b[31m   |\u001b[0m  import math.Numeric.Implicits.infixNumericOps\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpnqwnqkhv.scala:19:55 --------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m                \u001b[33mcase\u001b[0m x::xs => byTwo(xs, result + byOne(x).toString)\n\u001b[31m\u001b[31m   |\u001b[0m                                                       ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                    Found:    (x : Long)\n\u001b[31m   |\u001b[0m                                                    Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- Error: /tmp/tmpnqwnqkhv.scala:25:21 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m                \u001b[33mcase\u001b[0m \u001b[31m1\u001b[0m => List(\u001b[31m\"One\"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Values of types Int and List[Long] cannot be compared with == or !=\n\u001b[31m\u001b[31m-- Error: /tmp/tmpnqwnqkhv.scala:26:21 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m                \u001b[33mcase\u001b[0m \u001b[31m2\u001b[0m => List(\u001b[31m\"Two\"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Values of types Int and List[Long] cannot be compared with == or !=\n\u001b[31m\u001b[31m-- Error: /tmp/tmpnqwnqkhv.scala:27:21 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m                \u001b[33mcase\u001b[0m \u001b[31m3\u001b[0m => List(\u001b[31m\"Three\"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                  ",
      "stdout": "",
      "timestamp": 1660010495
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        val length = arr.size\n        val newArr = new mutable.MutableList[String]()\n        if(length == 0)\n            List()\n        else if(length == 1)\n            newArr += One\n        else if(length == 2)\n            newArr += Two\n        else if(length == 3)\n            newArr += Three\n        else if(length == 4)\n            newArr += Four\n        else if(length == 5)\n            newArr += Five\n        else if(length == 6)\n            newArr += Six\n        else if(length == 7)\n            newArr += Seven\n        else if(length == 8)\n            newArr += Eight\n        else if(length == 9)\n            newArr += Nine\n        else \n            newArr += One\n        arr.sortWith((x,y)=>x.toLong <= y.toLong)\n        arr.reverse\n        arr.map(i => newArr(i.toInt).toString)\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpdgwxq0i3.scala:18:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnewArr\u001b[0m = \u001b[33mnew\u001b[0m mutable.MutableList[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010489
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n      arr\n        .flatMap(_.toString.length)\n        .zip(Seq(\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"))\n        .toList\n        .map(f => f._1 + \"-\" + (f._2 match {\n          case \"\" => \"none\"\n          case _ => f._1.toString\n        }))\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpgac5a82p.scala:18:17 --------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        .flatMap(_.toString.length)\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                 Found:    Int\n\u001b[31m   |\u001b[0m                 Required: IterableOnce[Any]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpgac5a82p.scala:21:23 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        .map(f => f._1 + \u001b[31m\"-\"\u001b[0m + (f._2 \u001b[33mmatch\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue + is not a member of Nothing, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import Byte.byte2double\n\u001b[31m   |\u001b[0m  import Byte.byte2float\n\u001b[31m   |\u001b[0m  import Byte.byte2int\n\u001b[31m   |\u001b[0m  import Byte.byte2long\n\u001b[31m   |\u001b[0m  import Byte.byte2short\n\u001b[31m   |\u001b[0m  import Char.char2double\n\u001b[31m   |\u001b[0m  import Char.char2float\n\u001b[31m   |\u001b[0m  import Char.char2int\n\u001b[31m   |\u001b[0m  import Char.char2long\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.properties AsScalaMap\n\u001b[31m   |\u001b[0m\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660010496
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        val res = arr.filter( i => i % 10 == 0 ).sorted\n        val one = \"One\"\n        val two = \"Two\"\n        val three = \"Three\"\n        val four = \"Four\"\n        val five = \"Five\"\n        val six = \"Six\"\n        val seven = \"Seven\"\n        val eight = \"Eight\"\n        val nine = \"Nine\"\n        val output = res.map{ x => if (x < 10) {\n            x\n        } else  {\n            val l = if (x < 100) {\n                x\n            } else {\n                if (x < 1000) {\n                    x / 100\n                } else {\n                    if (x < 10000) {\n                        x / 1000\n                    } else {\n                        if (x < 100000) {\n                            x / 10000\n                        } else {\n                            if (x < 1000000) {\n                                x / 100000\n                            } else {\n                                x / 1000000\n                            }\n                        }\n                    }\n                }\n            }\n            val r = if (l < 10) {\n                one\n            } else  {\n                if (l < 100) {\n                    two\n                } else {\n                    if (l < 1000) {\n                        three\n                    } else {\n                        if (l < 10000) {\n                            four\n                        } else {\n                            if (l < 100000) {\n                                five\n                            } else {\n                                if (l < 1000000) {\n                                    six\n                                } else {\n                                    seven\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            val c = if (r < 10) {\n                one\n            } else  {\n                if (r < 100) {\n                    two\n                } else {\n                    if (r < 1000) {\n                        three\n                    } else {\n                        if (r < 10000) {\n                            four\n                        } else {\n                            if (r < 100000) {\n                                five\n                            } else {\n                                if (r < 1000000) {\n                                    six\n                                } else {\n                                    seven\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            val m = if (c < 10) {\n                one\n            } else  {\n                if (c < 100) {\n                    two\n                } else {\n                    if (c < 1000) {\n                        three\n                    } else {\n                        if (c < 10000) {\n                            four\n                        } else {\n                            if (c < 100000) {\n                                five\n                            } else {\n                                if (c < 1000000) {\n                                    six\n                                } else {\n                                    seven\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            if (m < 10) {\n                one\n            } else  {\n                if (m < 100) {\n                    two\n                } else {\n                    if (m < 1000) {\n                        three\n                    } else {\n                        if (m < 10000) {\n                            four\n                        } else {\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpd1pa59pq.scala:148:0 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m148 |\u001b[0m\n\u001b[31m\u001b[31m    |\u001b[0m^\u001b[0m\n\u001b[31m    |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpd1pa59pq.scala:76:28 --------------------\u001b[0m\u001b[0m\n\u001b[31m76 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mc\u001b[0m = \u001b[33mif\u001b[0m (r < \u001b[31m10\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                            ^^\u001b[0m\n\u001b[31m   |\u001b[0m                            Found:    (\u001b[31m10\u001b[0m : Int)\n\u001b[31m   |\u001b[0m                            Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpd1pa59pq.scala:79:24 --------------------\u001b[0m\u001b[0m\n\u001b[31m79 |\u001b[0m                \u001b[33mif\u001b[0m (r < \u001b[31m100\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        Found:    (\u001b[31m100\u001b[0m : Int)\n\u001b[31m   |\u001b[0m                        Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpd1pa59pq.scala:82:28 --------------------\u001b[0m\u001b[0m\n\u001b[31m82 |\u001b[0m                    \u001b[33mif\u001b[0m (r < \u001b[31m1000\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                            ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                            Found:    (\u001b[31m1000\u001b[0m : Int)\n\u001b[31m   |\u001b[0m                            Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpd1pa59pq.scala:85:32 --------------------\u001b[0m\u001b[0m\n\u001b[31m85 |\u001b[0m                        \u001b[33mif\u001b[0m (r < \u001b[31m10000\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                Found:    (\u001b[31m10000\u001b[0m : Int)\n\u001b[31m   |\u001b[0m                                Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpd1pa59pq.scala:88:36 --------------------\u001b[0m\u001b",
      "stdout": "",
      "timestamp": 1660010497
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        if(arr.isEmpty) List()\n        if(arr.map(_.toString.toInt).sum() == 0) List()\n        val result = mutable.ArrayBuffer.empty[String]\n        val maps = arr.groupBy(_.toString.toInt)\n        for((key, values) <- maps) {\n            var strings = values.toList.sortBy(_._1).reverse.map(_._2).toList\n            strings match {\n                case Nil => ()\n                case head :: tail => if(head.compareTo(1l) > 0) strings = tail ++ List(head.asInstanceOf[String])\n                                else strings = tail.filterNot(_.toString.toInt == head.toString.toInt)\n            }\n            result.addAll(strings)\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmphpbnbsyk.scala:18:40 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mif\u001b[0m(arr.map(_.toString.toInt).sum() == \u001b[31m0\u001b[0m) List()\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmissing argument for parameter num of \u001b[33mmethod\u001b[0m \u001b[35msum\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mIterableOnceOps\u001b[0m: (\u001b[33mimplicit \u001b[0mnum: Numeric[B]): B\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmphpbnbsyk.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.ArrayBuffer.empty[\u001b[35mString\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmphpbnbsyk.scala:22:49 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            \u001b[33mvar\u001b[0m \u001b[36mstrings\u001b[0m = values.toList.sortBy(_._1).reverse.map(_._2).toList\n\u001b[31m\u001b[31m   |\u001b[0m                                               ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                        value _1 is not a member of Long\n\u001b[31m\u001b[31m-- Error: /tmp/tmphpbnbsyk.scala:22:52 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            \u001b[33mvar\u001b[0m \u001b[36mstrings\u001b[0m = values.toList.sortBy(_._1).reverse.map(_._2).toList\n\u001b[31m\u001b[31m   |\u001b[0m                                                    ^\u001b[0m\n\u001b[31m   |\u001b[0mambiguous given instances: both \u001b[33mobject\u001b[0m \u001b[35mByte\u001b[0m in \u001b[33mobject\u001b[0m \u001b[35mOrdering\u001b[0m and \u001b[33mobject\u001b[0m \u001b[35mChar\u001b[0m in \u001b[33mobject\u001b[0m \u001b[35mOrdering\u001b[0m match type Ordering[B] of parameter ord of \u001b[33mmethod\u001b[0m \u001b[35msortBy\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mSeqOps\u001b[0m\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmphpbnbsyk.scala:25:40 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m                \u001b[33mcase\u001b[0m head :: tail => \u001b[33mif\u001b[0m(head.compareTo(\u001b[31m1l\u001b[0m) > \u001b[31m0\u001b[0m) strings = tail ++ List(head.asInstanceOf[String])\n\u001b[31m\u001b[31m   |\u001b[0m                        ",
      "stdout": "",
      "timestamp": 1660010494
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        if (arr.isEmpty) List()\n        else if(arr.head < 9) {\n            val reversedList = arr.reverse\n            val digits = reversedList.filter(x => x >= 1 && x <= 9).toList\n            val names =\n                if(digits.isEmpty) List(\"\")\n                else {\n                    val numString = reversedList.mkString\n                    val numArray = numString.split(\"\").toList.map(_.toLong)\n                    names.map { name =>\n                        val index = numArray.indexWhere(x => x == x)\n                        val digit = digits.toSeq(index)\n                        s\"${digit.head}${name}${digit.tail}\"\n                    }\n                }\n            names.reverse\n        }\n        else byLength(arr.tail)\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpigl6rlyf.scala:26:20 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m                    names.map { \u001b[36mname\u001b[0m =>\n\u001b[31m\u001b[31m   |\u001b[0m                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                    Recursive \u001b[33mvalue\u001b[0m \u001b[35mnames\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010492
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n      val ones = arr.filter(i => i >= 1 && i <= 9)\n      val tens = arr.filter(i => i >= 10 && i <= 99)\n      val hundreds = arr.filter(i => i >= 100 && i <= 999)\n      if (arr.nonEmpty) {\n        val firstDigit = arr.head\n        val lastDigit = arr.last\n        val reversedArr = arr.reverse\n        val tensAndHundredsArr = reversedArr.filter(_ >= 10 && _ <= 99)\n        val tensAndHundredsReversed = reversedArr.filter(_ >= 100 && _ <= 999)\n        val tensAndHundredsReversedString = tensAndHundredsArr.map(i => i / 10 + i.toString + \" \" + ones(i.toInt - 10)).getOrElse(\"\")\n        val tensAndHundredsReversedStringFirst = tensAndHundredsReversedString.substring(0, 1)\n        val tensAndHundredsReversedStringSecond = tensAndHundredsReversedString.substring(1, 2)\n        val tensAndHundredsReversedStringFirstLast = tensAndHundredsReversedString.substring(firstDigit, lastDigit + 1)\n        val tensAndHundredsReversedStringLastFirst = tensAndHundredsReversedString.substring(0, lastDigit + 1)\n        val tensAndHundredsReversedStringLastFirstLast = tensAndHundredsReversedString.substring(lastDigit + 1, firstDigit)\n        val tensAndHundredsReversedStringLastFirstLastString = tensAndHundredsReversedString.substring(lastDigit + 1, firstDigit + 1)\n        val tensAndHundredsReversedStringLastFirstLastStringFirstLast = tensAndHundredsReversedString.substring(lastDigit + 2, firstDigit + 2)\n        val tensAndHundredsReversedStringFirstLastStringFirstLast = tensAndHundredsReversedString.substring(firstDigit + 2, lastDigit + 2)\n        val tensAndHundredsReversedStringFirstLastStringFirstLastStringFirstLast = tensAndHundredsReversedString.substring(firstDigit + 3, lastDigit + 3)\n        val tensAndHundredsReversedStringFirstLastStringFirstLastStringFirstLastStringFirstLast = tensAndHundredsReversedString.substring(firstDigit + 4, lastDigit + 4)\n        val tensAndH\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpn1ghm2f0.scala:38:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpn1ghm2f0.scala:48:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m48 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E086] Syntax Error: /tmp/tmpn1ghm2f0.scala:24:52 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mtensAndHundredsArr\u001b[0m = reversedArr.filter(_ >= \u001b[31m10\u001b[0m && _ <= \u001b[31m99\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                                    ^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Wrong number of parameters, expected: 1\n\u001b[31m\u001b[31m-- [E086] Syntax Error: /tmp/tmpn1ghm2f0.scala:25:57 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mtensAndHundredsReversed\u001b[0m = reversedArr.filter(_ >= \u001b[31m100\u001b[0m && _ <= \u001b[31m999\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                                         ^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Wrong number of parameters, expected: 1\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpn1ghm2f0.scala:26:120 -----------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mtensAndHundredsReversedString\u001b[0m = tensAndHundredsArr.map(\u001b[36mi\u001b[0m => i / \u001b[31m10\u001b[0m + i.toString + \u001b[31m\" \"\u001b[0m + ones(i.toInt - \u001b[31m10\u001b[0m)).getOrElse(\u001b[31m\"\"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         value getOrElse is not a member of List[String]\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpn1ghm2f0.scala:47:1 ---------------------\u001b[0m\u001b[0m\n\u001b[31m47 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m ^\u001b[0m\n\u001b[31m   |\u001b[0m Found:    Unit\n\u001b[31m   |\u001b[0m Required: List[String]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[33m\u001b[33m-- Warning: /tmp/",
      "stdout": "",
      "timestamp": 1660010497
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        arr.filter(x => x % 10 == 0).map(d => if(d == 0) \"Zero\" else d)\n            .map(d => if(d == 1) \"One\" else d + \"s\")\n            .reduceLeft(List.empty[String]).reverse.map(x => if(x.head.isDigit()) s\"${x.head.toString} ${x.tail}\" else x)\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp_mxbkc5m.scala:18:46 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m            .map(d => \u001b[33mif\u001b[0m(d == \u001b[31m1\u001b[0m) \u001b[31m\"One\"\u001b[0m \u001b[33melse\u001b[0m d + \u001b[31m\"s\"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                            ^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue + is not a member of Matchable, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might make progress towards fixing the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.Fractional.Implicits.infixFractionalOps\n\u001b[31m   |\u001b[0m  import math.Integral.Implicits.infixIntegralOps\n\u001b[31m   |\u001b[0m  import math.Numeric.Implicits.infixNumericOps\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp_mxbkc5m.scala:19:34 --------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m            .reduceLeft(List.empty[String]).reverse.map(x => \u001b[33mif\u001b[0m(x.head.isDigit()) \u001b[31ms\"\u001b[0m${x.head.toString}\u001b[31m \u001b[0m${x.tail}\u001b[31m\"\u001b[0m \u001b[33melse\u001b[0m x)\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        Found:    List[String]\n\u001b[31m   |\u001b[0m                        Required: (String, String) => String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp_mxbkc5m.scala:19:66 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m            .reduceLeft(List.empty[String]).reverse.map(x => \u001b[33mif\u001b[0m(x.head.isDigit()) \u001b[31ms\"\u001b[0m${x.head.toString}\u001b[31m \u001b[0m${x.tail}\u001b[31m\"\u001b[0m \u001b[33melse\u001b[0m x)\n\u001b[31m\u001b[31m   |\u001b[0m                                                                ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                      value head is not a member of Char\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp_mxbkc5m.scala:19:88 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m            .reduceLeft(List.empty[String]).reverse.map(x => \u001b[33mif\u001b[0m(x.head.isDigit()) \u001b[31ms\"\u001b[0m${x.head.toString}\u001b[31m \u001b[0m${x.tail}\u001b[31m\"\u001b[0m \u001b[33melse\u001b[0m x)\n\u001b[31m\u001b[31m   |\u001b[0m                     ",
      "stdout": "",
      "timestamp": 1660010498
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        var list: List[String] = Nil\n        arr.reverse.foreach(x => {\n            list = if (x < 10) {\n                list ::: List(\"\" + x)\n            } else list ::: List(\"\" + x % 10 + \"-\" + x % 100 + \"-\" + x % 1000)\n        })\n        if (list.isEmpty) Nil else list.map(_.swap.toUpper)\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpb9i72oiu.scala:23:46 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mif\u001b[0m (list.isEmpty) Nil \u001b[33melse\u001b[0m list.map(_.swap.toUpper)\n\u001b[31m\u001b[31m   |\u001b[0m                                            ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m          value swap is not a member of String - did you mean _$1.strip?\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010495
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        val mapOneToNine = mutable.Map[Long, String](1l.toLong -> \"One\", 2l.toLong -> \"Two\", 3l.toLong -> \"Three\", 4l.toLong -> \"Four\", 5l.toLong -> \"Five\", 6l.toLong -> \"Six\", 7l.toLong -> \"Seven\", 8l.toLong -> \"Eight\", 9l.toLong -> \"Nine\")\n        var newList: List[String] = ListBuffer[String]()\n        var index = 0\n        for(item <- arr){\n            if(item < 10l.toLong){\n                newList += mapOneToNine(item)\n            }\n            else {\n                if(item < 100l.toLong){\n                    newList += mapOneToNine(item.toInt / 10l.toLong) + \" \" + mapOneToNine(item.toInt % 10l.toLong)\n                }\n                else {\n                    newList += mapOneToNine(item.toInt / 100l.toLong) + \" hundred\" + mapOneToNine(item.toInt % 100l.toLong)\n                }\n            }\n        }\n        return newList.sortWith(_ < _).reverse\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpt1rolfpy.scala:17:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmapOneToNine\u001b[0m = mutable.Map[\u001b[35mLong\u001b[0m, \u001b[35mString\u001b[0m](\u001b[31m1l\u001b[0m.toLong -> \u001b[31m\"One\"\u001b[0m, \u001b[31m2l\u001b[0m.toLong -> \u001b[31m\"Two\"\u001b[0m, \u001b[31m3l\u001b[0m.toLong -> \u001b[31m\"Three\"\u001b[0m, \u001b[31m4l\u001b[0m.toLong -> \u001b[31m\"Four\"\u001b[0m, \u001b[31m5l\u001b[0m.toLong -> \u001b[31m\"Five\"\u001b[0m, \u001b[31m6l\u001b[0m.toLong -> \u001b[31m\"Six\"\u001b[0m, \u001b[31m7l\u001b[0m.toLong -> \u001b[31m\"Seven\"\u001b[0m, \u001b[31m8l\u001b[0m.toLong -> \u001b[31m\"Eight\"\u001b[0m, \u001b[31m9l\u001b[0m.toLong -> \u001b[31m\"Nine\"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                           ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                           Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpt1rolfpy.scala:18:54 --------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mnewList\u001b[0m: \u001b[35mList\u001b[0m[\u001b[35mString\u001b[0m] = ListBuffer[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                                    ^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Found:    scala.collection.mutable.ListBuffer[String]\n\u001b[31m   |\u001b[0m                   Required: List[String]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpt1rolfpy.scala:22:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m                newList += mapOneToNine(item)\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue += is not a member of List[String] - did you mean List[String].!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpt1rolfpy.scala:26:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m                    newList += mapOneToNine(item.toInt / \u001b[31m10l\u001b[0m.toLong) + \u001b[31m\" \"\u001b[0m + mapOneToNine(item.toInt % \u001b[31m10l\u001b[0m.toLong)\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue += is not a member of List[String] - did you mean List[String].!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpt1rolfpy.scala:29:28 ------------------",
      "stdout": "",
      "timestamp": 1660010499
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        val longs = arr.filter(_ > 0l)\n        longs.foldLeft(new mutable.ListBuffer[String]()){ (result, long) =>\n            val length = long.toString.length\n            val name = if (length < 2) \"One\" else if (length < 3) \"Two\" else \"Three\"\n            result.append(name)\n        }.toList\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp4wmua3ax.scala:18:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        longs.foldLeft(\u001b[33mnew\u001b[0m mutable.ListBuffer[\u001b[35mString\u001b[0m]()){ (\u001b[36mresult\u001b[0m, \u001b[36mlong\u001b[0m) =>\n\u001b[31m\u001b[31m   |\u001b[0m                           ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                           Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp4wmua3ax.scala:21:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m            result.append(name)\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value append is not a member of Any\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660010496
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        val n = arr.length\n        val l = arr.last\n        var list = arr.toList\n        var index = n / 10\n        var digit = n % 10\n        val nameList = new mutable.ListBuffer[String]()\n        val one = 1\n        val ten = 10\n        val oneoneone = one*one*one\n        while (index > 0) {\n            if (index >= 10) {\n                if (digit == 0) {\n                    digit = l % 10\n                    if (digit > 0) {\n                        list = list(index - 10).reverse\n                    }\n                    index = 0\n                } else if (digit > 0) {\n                    digit = l % 10\n                    if (digit == 0) {\n                        digit = l % 10\n                        if (digit > 0) {\n                            list = list(index - 10).reverse\n                        }\n                        index = 0\n                    } else {\n                        list = list(index - 10).reverse\n                    }\n                } else {\n                    list = list(index - 10).reverse\n                }\n            } else {\n                list = list(index - 10).reverse\n                index = 0\n            }\n        }\n        if (list == Nil) {\n            return Nil\n        } else if (list == List()) {\n            return List()\n        } else {\n            var i = 0\n            var j = 0\n            var k = 0\n            var result = Nil\n            while (j < n) {\n                if (j >= 10 && j < n / 10) {\n                    i += 1\n                    k = 0\n                } else if (j >= 10 && j > n / 10) {\n                    result :=  Nil\n                    break\n                } else {\n                    for (k <- 0 until list.length - 1) {\n                        if (list(i).equals(list(j))) {\n                            list = list(i) :: list(j)\n                            i = 1\n                            j -= 1\n                            k = 0\n                            break\n                        } else {\n                            k += 1\n                        }\n                    }\n                    j += 1\n                }\n            }\n            for (l <- 0 until list.length - 1) {\n                result :=  result ::  List(name(list(i))) :: List(name(list(j)))\n                i += 1\n                j += 1\n            }\n            return result\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpq93fme49.scala:22:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnameList\u001b[0m = \u001b[33mnew\u001b[0m mutable.ListBuffer[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                           ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                           Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpq93fme49.scala:29:28 --------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m                    digit = l % \u001b[31m10\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                            ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                            Found:    Long\n\u001b[31m   |\u001b[0m                            Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpq93fme49.scala:31:48 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m                        list = list(index - \u001b[31m10\u001b[0m).reverse\n\u001b[31m\u001b[31m   |\u001b[0m                               ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                               value reverse is not a member of Long\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpq93fme49.scala:35:28 --------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m                    digit = l % \u001b[31m10\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                            ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                            Found:    Long\n\u001b[31m   |\u001b[0m                            Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpq93fme49.scala:37:32 --------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m                        digit = l % \u001b[31m10\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                                ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                Found:    Long\n\u001b[31m   |\u001b[0m                                Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpq93fme",
      "stdout": "",
      "timestamp": 1660010500
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        // Using a mutable list to keep track of the names and lengths.\n        val names = new mutable.LinkedHashMap[Long, String]()\n        val lengths = new mutable.HashMap[Long, Int]()\n\n        // Iterate through the array and count the lengths of each number.\n        arr.foreach{ num =>\n            if (!lengths.contains(num))\n                lengths(num) = num.toString.length\n            else\n                lengths(num) = lengths(num) + 1\n        }\n\n        // Sort the lengths in descending order.\n        val sortedLens = lengths.toSeq.sortBy(_._2).reverse\n\n        // If the length of the list is 0, return an empty list:\n        if (sortedLens.isEmpty)\n            return List()\n\n        // Otherwise, for each length in the sorted list, get the name\n        // by looking at the first element of the sorted list that has\n        // the same length.\n        sortedLens.map{ case (len, name) =>\n            if (len == sortedLens.head)\n                names.put(len, name)\n        }\n\n        // Sort the names in descending order.\n        val sortedNames = names.toSeq.sortBy(_._2).reverse\n\n        // Now, for each name, get the first number from the sorted list\n        // and add it to a result\n        sortedNames.map{ name =>\n            val num = sortedLens.find(_._2 == name).head\n            List(name, num.toString)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpb__3mvfa.scala:18:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnames\u001b[0m = \u001b[33mnew\u001b[0m mutable.LinkedHashMap[\u001b[35mLong\u001b[0m, \u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpb__3mvfa.scala:19:26 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mlengths\u001b[0m = \u001b[33mnew\u001b[0m mutable.HashMap[\u001b[35mLong\u001b[0m, \u001b[35mInt\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660010493
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        arr.sortWith(compare(arr.head)).reverse\n        arr.filterNot(_ < 1 || _ > 9).toList.map(name => name.toString)\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpiam34raa.scala:17:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        arr.sortWith(compare(arr.head)).reverse\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: compare\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E086] Syntax Error: /tmp/tmpiam34raa.scala:18:22 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        arr.filterNot(_ < \u001b[31m1\u001b[0m || _ > \u001b[31m9\u001b[0m).toList.map(\u001b[36mname\u001b[0m => name.toString)\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      Wrong number of parameters, expected: 1\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660010493
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        val newArr : List[String] = Nil\n        val sortedArray = arr.sortWith(_ < _)\n        var firstElement = sortedArray(sortedArray.length-1)\n        val lastElement = sortedArray(sortedArray.length)\n        val arrayLength = lastElement-firstElement+1\n        val result = (for (i <- 0 to arrayLength)\n            yield\n                if (firstElement+i <= lastElement) sortedArray(firstElement+i-1).toString + \" \" + byLength((lastElement-firstElement-1).toLong+listOf(List(sortedArray(firstElement+i).asInstanceOf[Long]))) else byLength((lastElement-firstElement-1).toLong+listOf(List(sortedArray(firstElement+i).asInstanceOf[Long]-1l.toLong))))\n        newArr ++ result\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp_qi1xlht.scala:22:37 --------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = (\u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m to arrayLength)\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                     Found:    (arrayLength : Long)\n\u001b[31m   |\u001b[0m                                     Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp_qi1xlht.scala:24:63 --------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m                \u001b[33mif\u001b[0m (firstElement+i <= lastElement) sortedArray(firstElement+i-\u001b[31m1\u001b[0m).toString + \u001b[31m\" \"\u001b[0m + byLength((lastElement-firstElement-\u001b[31m1\u001b[0m).toLong+listOf(List(sortedArray(firstElement+i).asInstanceOf[\u001b[35mLong\u001b[0m]))) \u001b[33melse\u001b[0m byLength((lastElement-firstElement-\u001b[31m1\u001b[0m).toLong+listOf(List(sortedArray(firstElement+i).asInstanceOf[\u001b[35mLong\u001b[0m]-\u001b[31m1l\u001b[0m.toLong))))\n\u001b[31m\u001b[31m   |\u001b[0m                                                               ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                                          Found:    Long\n\u001b[31m   |\u001b[0m                                                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp_qi1xlht.scala:24:143 -----------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m                \u001b[33mif\u001b[0m (firstElement+i <= lastElement) sortedArray(firstElement+i-\u001b[31m1\u001b[0m).toString + \u001b[31m\" \"\u001b[0m + byLength((lastElement-firstElement-\u001b[31m1\u001b[0m).toLong+listOf(List(sortedArray(firstElement+i).asInstanceOf[\u001b[35mLong\u001b[0m]))) \u001b[33melse\u001b[0m byLength((lastElement-firstElement-\u001b[31m1\u001b[0m).toLong+listOf(List(sortedArray(firstElement+i).asInstanceOf[\u001b[35mLong\u001b[0m]-\u001b[31m1l\u001b[0m.toLong))))\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                                                             ",
      "stdout": "",
      "timestamp": 1660010500
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        // First, make sure we have some list\n        if (arr.isEmpty) List()\n        else {\n            // Second, find the length of the list\n            val n = arr.length\n            // Third, reverse the list\n            arr.reverse\n            // Fourth, convert each digit to its corresponding name\n            val result = arr.map(i => i % 10 + \"-\" + OneToNine.lookup(i.toString.toInt))\n            // Fifth, remove any empty strings from the result\n            val newResult = result.filter(_.nonEmpty)\n            // Sixth, return the result as a list\n            newResult.toList\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpa5gekaso.scala:25:53 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = arr.map(\u001b[36mi\u001b[0m => i % \u001b[31m10\u001b[0m + \u001b[31m\"-\"\u001b[0m + OneToNine.lookup(i.toString.toInt))\n\u001b[31m\u001b[31m   |\u001b[0m                                                     ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                                    Not found: OneToNine\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010496
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        // Find the length of the numbers between 1 and 9 inclusive\n        val len : Int = 0\n        arr.foreach( elem => len += elem.toString.length )\n        // Create the list of names for the integers\n        var arrStr : List[String] = Nil\n        for( i <- 1 to 9 )\n            arrStr = arrStr::List.fill(len)(\"One\")(i)\n        // Reverse the list\n        arrStr = arrStr.reverse\n        // Replace the integer by its name\n        arrStr.foreach(elem => arr map { x => if (x == elem) x else x.toString } )\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp4v1vyeik.scala:19:33 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        arr.foreach( \u001b[36melem\u001b[0m => len += elem.toString.length )\n\u001b[31m\u001b[31m   |\u001b[0m                             ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  value += is not a member of Int - did you mean len.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp4v1vyeik.scala:23:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m            arrStr = arrStr::List.fill(len)(\u001b[31m\"One\"\u001b[0m)(i)\n\u001b[31m\u001b[31m   |\u001b[0m                           ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                           value :: is not a member of String\n\u001b[31m\u001b[31m-- Error: /tmp/tmp4v1vyeik.scala:27:50 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        arrStr.foreach(\u001b[36melem\u001b[0m => arr map { \u001b[36mx\u001b[0m => \u001b[33mif\u001b[0m (x == elem) x \u001b[33melse\u001b[0m x.toString } )\n\u001b[31m\u001b[31m   |\u001b[0m                                                  ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Values of types Long and String cannot be compared with == or !=\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660010500
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        val ones = List(\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\")\n        val tens = List(\"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\")\n        val digits = List(1, 2, 3, 4, 5, 6, 7, 8, 9)\n        var reversed = arr.tail.reverse.map(_.toInt)\n        reversed.foreach {\n            case i if i >= 1 && i <= 9 && digits.contains(i) => reversed.remove(i)\n            case _ =>\n        }\n        reversed.foreach(i => reversed.remove(i))\n        val reversedList = reversed.map(i => if (i < 10) (ones(i-1)) else (tens(i-10))).toList\n        val result = reversedList.map(i => if (i < 10) i else digits(i-1)).mkString(\",\")\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpu7nh701q.scala:22:73 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            \u001b[33mcase\u001b[0m i \u001b[33mif\u001b[0m i >= \u001b[31m1\u001b[0m && i <= \u001b[31m9\u001b[0m && digits.contains(i) => reversed.remove(i)\n\u001b[31m\u001b[31m   |\u001b[0m                                                                ^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue remove is not a member of List[Int] - did you mean List[Int].reduce?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpu7nh701q.scala:25:39 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        reversed.foreach(\u001b[36mi\u001b[0m => reversed.remove(i))\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue remove is not a member of List[Int], but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.seq AsJavaList\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversionsToJava.seq AsJavaList\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.collection asJava\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversionsToJava.collection asJava\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpu7nh701q.scala:27:51 --------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = reversedList.map(\u001b[36mi\u001b[0m => \u001b[33mif\u001b[0m (i < \u001b[31m10\u001b[0m) i \u001b[33melse\u001b[0m digits(i-\u001b[31m1\u001b[0m)).mkString(\u001b[31m\",\"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                                   ^^\u001b[0m\n\u001b[31m   |\u001b[0m                                                   Found:    (\u001b[31m10\u001b[0m : Int)\n\u001b[31m   |\u001b[0m                                                   Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpu7nh701q.scala:27:70 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = reversedList.map(\u001b[36mi\u001b[0m => \u001b[33mif\u001b[0m (i < \u001b[31m10\u001b[0m) i \u001b[33melse\u001b[0m digits(i-\u001b[",
      "stdout": "",
      "timestamp": 1660010503
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        require(arr.nonEmpty, \"You can't sort a list that has no elements\")\n        val len = arr.length\n        if(len == 1) {\n            List(arr(0).toString).reverse\n        } else {\n            val longList = arr.map(_.toLong)\n            val longs = longList.sorted\n            val reversed = longs.reverse\n            val str = reversed.map(l => if(l < 10) \"One\" else (\"Two\" until (l >= 10)))\n            str.reverse\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpd7_4jf_a.scala:25:69 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mstr\u001b[0m = reversed.map(\u001b[36ml\u001b[0m => \u001b[33mif\u001b[0m(l < \u001b[31m10\u001b[0m) \u001b[31m\"One\"\u001b[0m \u001b[33melse\u001b[0m (\u001b[31m\"Two\"\u001b[0m until (l >= \u001b[31m10\u001b[0m)))\n\u001b[31m\u001b[31m   |\u001b[0m                                                               ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                   value until is not a member of String\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010500
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        val list = arr.toList\n        val max = list.map(x => x.toString.length).max\n        val min = 0\n        if(max < 9) list.sortBy(x=> x.toString)\n        else list.sortBy(x=> x.toString.reverse).reverse.map(x => x(max - min)).map(_.replace(\"1\",\"One\")\n                .replace(\"2\",\"Two\").replace(\"3\",\"Three\").replace(\"4\",\"Four\").replace(\"5\",\"Five\")\n                .replace(\"6\",\"Six\").replace(\"7\",\"Seven\").replace(\"8\",\"Eight\").replace(\"9\",\"Nine\"))\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp0e_nhy1d.scala:20:20 --------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mif\u001b[0m(max < \u001b[31m9\u001b[0m) list.sortBy(\u001b[36mx\u001b[0m=> x.toString)\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Found:    List[\u001b[1m\u001b[31mLong\u001b[0m]\n\u001b[31m   |\u001b[0m                    Required: List[\u001b[1m\u001b[32mString\u001b[0m]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp0e_nhy1d.scala:21:66 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33melse\u001b[0m list.sortBy(x=> x.toString.reverse).reverse.map(x => x(max - min)).map(_.replace(\u001b[31m\"1\"\u001b[0m,\u001b[31m\"One\"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                    \u001b[33mparameter\u001b[0m \u001b[35mx\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp0e_nhy1d.scala:21:86 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33melse\u001b[0m list.sortBy(x=> x.toString.reverse).reverse.map(x => x(max - min)).map(_.replace(\u001b[31m\"1\"\u001b[0m,\u001b[31m\"One\"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                    ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue replace is not a member of Nothing, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.map AsJavaConcurrentMap\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.map AsScalaConcurrentMap\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversionsToJava.map AsJavaConcurrentMap\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversionsToScala.map AsScalaConcurrentMap\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.mutableMap AsJavaMap\n\u001b[31m   |\u001b[0m  import collection.convert.Imp",
      "stdout": "",
      "timestamp": 1660010502
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        val listSize = Math.abs(arr.length).abs\n        if (listSize == 0)\n            List() :+ \"\" :+ \"One\"\n        else if (listSize == 1)\n            List(\"One\") :+ \"\"\n        else {\n            val sortedList = new mutable.ArrayList[Long]()\n            arr.sortWith(_ < _)\n            val ones = arr.filter(_ <= 0l).map(_ -> \"One\")\n            val zeros = arr.filter(_ <= 0l).map(_ -> \"Zero\")\n            val listSize = arr.length.abs\n            val listLength = Math.abs(listSize)\n            var index = 0\n            while (index < listSize) {\n                if (arr(index) <= 9) {\n                    if (ones(arr(index)) == \"\")\n                        ones(arr(index)) = \"One\"\n                    else {\n                        ones(arr(index)) = ones(arr(index)) + \"\"\n                    }\n                }\n                else if (arr(index) <= 99) {\n                    if (zeros(arr(index)) == \"\")\n                        zeros(arr(index)) = \"Zero\"\n                    else {\n                        zeros(arr(index)) = zeros(arr(index)) + \"\"\n                    }\n                }\n                else\n                    ones(arr(index)) = ones(arr(index)) + \"\"\n                index++\n            }\n            var index = 0\n            while (index < listLength) {\n                if (ones(arr(index)) == \"\")\n                    ones(arr(index)) = \"One\"\n                else\n                    zeros(arr(index)) = zeros(arr(index)) + \"\"\n                index++\n            }\n            val resultList = ones :+ \"\"\n            val index = 0\n            while (index < listSize) {\n                if (arr(index) <= 9)\n                    resultList.filter(_ == arr(index)).foreach(_ => resultList.filter(_ == arr(index))(0) :+ \"One\")\n                else if (arr(index) <= 99)\n                    resultList.filter(_ == arr(index)).foreach(_ => resultList.filter(_ == arr(index))(0) :+ \"Zero\")\n                else\n                    resultList.filter(_ == arr(index)).foreach(_ => resultList.filter(_ == arr(index))(0) :+ \"Two\")\n                index++\n            }\n            resultList :+ \"\"\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpg1ln7azu.scala:47:23 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m47 |\u001b[0m                index++\n\u001b[31m\u001b[31m   |\u001b[0m                       ^\u001b[0m\n\u001b[31m   |\u001b[0m                       expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpg1ln7azu.scala:55:23 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m55 |\u001b[0m                index++\n\u001b[31m\u001b[31m   |\u001b[0m                       ^\u001b[0m\n\u001b[31m   |\u001b[0m                       expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpg1ln7azu.scala:66:23 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m66 |\u001b[0m                index++\n\u001b[31m\u001b[31m   |\u001b[0m                       ^\u001b[0m\n\u001b[31m   |\u001b[0m                       expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpg1ln7azu.scala:49:16 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m49 |\u001b[0m            \u001b[33mvar\u001b[0m \u001b[36mindex\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mindex is already defined as \u001b[33mvariable\u001b[0m \u001b[35mindex\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpg1ln7azu.scala:58:16 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m58 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mindex\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mindex is already defined as \u001b[33mvariable\u001b[0m \u001b[35mindex\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpg1ln7azu.scala:23:33 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36msortedList\u001b[0m = \u001b[33mnew\u001b[0m mutable.ArrayLis",
      "stdout": "",
      "timestamp": 1660010504
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        if (arr.isEmpty) {\n            return Nil\n        }\n        var reversed = arr.map(_.toString.reverse).reverse\n        var ones = reversed.filter(_ >= 1).map(_.toString.replaceFirst(\"1\", \"One\"))\n        var twos = reversed.filter(_ >= 2).map(_.toString.replaceFirst(\"2\", \"Two\"))\n        var threes = reversed.filter(_ >= 3).map(_.toString.replaceFirst(\"3\", \"Three\"))\n        var fours = reversed.filter(_ >= 4).map(_.toString.replaceFirst(\"4\", \"Four\"))\n        var fives = reversed.filter(_ >= 5).map(_.toString.replaceFirst(\"5\", \"Five\"))\n        var sixes = reversed.filter(_ >= 6).map(_.toString.replaceFirst(\"6\", \"Six\"))\n        var sevens = reversed.filter(_ >= 7).map(_.toString.replaceFirst(\"7\", \"Seven\"))\n        var eights = reversed.filter(_ >= 8).map(_.toString.replaceFirst(\"8\", \"Eight\"))\n        var nines = reversed.filter(_ >= 9).map(_.toString.replaceFirst(\"9\", \"Nine\"))\n        var newArray = ones.head :: twos.head :: threes.head :: fours.head :: fives.head :: sixes.head :: sevens.head :: eights.head :: nines.head :: Nil\n\n        return newArray\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpkpha9_7g.scala:21:40 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mones\u001b[0m = reversed.filter(_ >= \u001b[31m1\u001b[0m).map(_.toString.replaceFirst(\u001b[31m\"1\"\u001b[0m, \u001b[31m\"One\"\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                                        Found:    (\u001b[31m1\u001b[0m : Int)\n\u001b[31m   |\u001b[0m                                        Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpkpha9_7g.scala:22:40 --------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mtwos\u001b[0m = reversed.filter(_ >= \u001b[31m2\u001b[0m).map(_.toString.replaceFirst(\u001b[31m\"2\"\u001b[0m, \u001b[31m\"Two\"\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                                        Found:    (\u001b[31m2\u001b[0m : Int)\n\u001b[31m   |\u001b[0m                                        Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpkpha9_7g.scala:23:42 --------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mthrees\u001b[0m = reversed.filter(_ >= \u001b[31m3\u001b[0m).map(_.toString.replaceFirst(\u001b[31m\"3\"\u001b[0m, \u001b[31m\"Three\"\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                                          Found:    (\u001b[31m3\u001b[0m : Int)\n\u001b[31m   |\u001b[0m                                          Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpkpha9_7g.scala:24:41 --------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mfours\u001b[0m = reversed.filter(_ >= \u001b[31m4\u001b[0m).map(_.toString.replaceFirst(\u001b[31m\"4\"\u001b[0m, \u001b[31m\"Four\"\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                                         Found:    (\u001b[31m4\u001b[0m : Int)\n\u001b[31m   |\u001b[0",
      "stdout": "",
      "timestamp": 1660010505
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        if (arr.isEmpty) List.empty[String]\n        else {\n            def filterList(list: List[Long]) : List[Long] = {\n                var filteredList = list\n                for (i <- 1 to 9) {\n                    filteredList = filteredList.filter( x => (x < i) || (x >= i))\n                }\n                filteredList\n            }\n\n            def reverseList(list: List[Long]) : List[Long] = {\n                val reversedList = list.reverse\n                for (i <- 0 to 9) {\n                    reversedList.reverse\n                }\n                reversedList\n            }\n\n            def replaceDigit(list: List[Long]) : List[Long] = {\n                val reversedList = reverseList(list)\n                for (i <- 0 to 9) {\n                    reversedList(reversedList.indexOf(i)).map( _ => \"One\".getOrElse(\"Two\".getOrElse(\"Three\".getOrElse(\"Four\".getOrElse(\"Five\".getOrElse(\"Six\".getOrElse(\"Seven\".getOrElse(\"Eight\".getOrElse(\"Nine\".getOrElse(\"\"))))))))\n                }\n                reversedList\n            }\n\n            val listLength = arr.size\n            val listString = arr.map(_.toString)\n            val listStringLength = listString.size\n            val listNumbers = listString.map(_.toLong)\n\n            val filteredList = filterList(listNumbers)\n            val replacedList = replaceDigit(filteredList)\n            replacedList.size.toString match {\n                case listStringLength =>\n                    val resultList = replacedList.zip(listString.toList).map { case (str, strNumber) => strNumber + \" \" + str }\n                    resultList.toList\n                case _ =>\n                    List.empty[String]\n            }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpedqp31l2.scala:39:16 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m                }\n\u001b[31m\u001b[31m   |\u001b[0m                ^\u001b[0m\n\u001b[31m   |\u001b[0m                ')' expected, but '}' found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpedqp31l2.scala:38:58 ------------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m                    reversedList(reversedList.indexOf(i)).map( _ => \u001b[31m\"One\"\u001b[0m.getOrElse(\u001b[31m\"Two\"\u001b[0m.getOrElse(\u001b[31m\"Three\"\u001b[0m.getOrElse(\u001b[31m\"Four\"\u001b[0m.getOrElse(\u001b[31m\"Five\"\u001b[0m.getOrElse(\u001b[31m\"Six\"\u001b[0m.getOrElse(\u001b[31m\"Seven\"\u001b[0m.getOrElse(\u001b[31m\"Eight\"\u001b[0m.getOrElse(\u001b[31m\"Nine\"\u001b[0m.getOrElse(\u001b[31m\"\"\u001b[0m))))))))\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    value map is not a member of Long\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660010502
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        arr\n          .filter(num => num < 9)\n          .sortWith(_ < _)\n          .reverse\n          .map(name => Integer.toString(num))\n          .toList\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpykbfjl7t.scala:21:40 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m          .map(name => Integer.toString(num))\n\u001b[31m\u001b[31m   |\u001b[0m                                        ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                        Not found: num\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010502
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n      if (arr.isEmpty) List(\"\")\n      else {\n        // sort the list for length\n        val nums = arr.sortWith((x, y) => x.compareTo(y))\n        // reverse the list and then convert each digit to its corresponding string\n        val (reverse, digits) = nums.tail.span(!_.isDigit, 2) match {\n          case (xs, y) => (xs.reverse, y.reverse)\n          case _ => (nums.reverse, nums.head)\n        }\n        val ones = reverse(digits.reverse.map(_.toString).toList)\n        val twos = reverse(ones.map(s => s.replaceAll(\"1\", \"\") + \"Two\"))\n        val threes = reverse(ones.map(s => s.replaceAll(\"1\", \"\") + \"Three\"))\n        val fours = reverse(ones.map(s => s.replaceAll(\"1\", \"\") + \"Four\"))\n        val fives = reverse(ones.map(s => s.replaceAll(\"1\", \"\") + \"Five\"))\n        val sixes = reverse(ones.map(s => s.replaceAll(\"1\", \"\") + \"Six\"))\n        val sevens = reverse(ones.map(s => s.replaceAll(\"1\", \"\") + \"Seven\"))\n        val eights = reverse(ones.map(s => s.replaceAll(\"1\", \"\") + \"Eight\"))\n        val nines = reverse(ones.map(s => s.replaceAll(\"1\", \"\") + \"Nine\"))\n        ones.flatMap( s => List(\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\").find(_ == s))\n      }\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpyw7uw8cr.scala:20:53 --------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnums\u001b[0m = arr.sortWith((\u001b[36mx\u001b[0m, \u001b[36my\u001b[0m) => x.compareTo(y))\n\u001b[31m\u001b[31m   |\u001b[0m                                          ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                          Found:    Int\n\u001b[31m   |\u001b[0m                                          Required: Boolean\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E081] Type Error: /tmp/tmpyw7uw8cr.scala:22:48 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m (reverse, digits) = nums.tail.span(!_.isDigit, \u001b[31m2\u001b[0m) \u001b[33mmatch\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m                                                ^\u001b[0m\n\u001b[31m   |\u001b[0m   Missing parameter type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m   I could not infer the type of the parameter _$1 of expanded function:\n\u001b[31m   |\u001b[0m   _$1 => ! _$1.isDigit.\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpyw7uw8cr.scala:26:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mones\u001b[0m = reverse(digits.reverse.map(_.toString).toList)\n\u001b[31m\u001b[31m   |\u001b[0m                           ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                           value reverse is not a member of Matchable\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpyw7uw8cr.scala:27:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mtwos\u001b[0m = reverse(ones.map(\u001b[36ms\u001b[0m => s.replaceAll(\u001b[31m\"1\"\u001b[0m, \u001b[31m\"\"\u001b[0m) + \u001b[31m\"Two\"\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                           ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                           value map is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpyw7uw8cr.scala:28:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mthrees\u001b[0m = reverse(ones.map(\u001b[36ms\u001b[0m => s.replaceAll(\u001b[31m\"1\"\u001b[0m, \u001b[31m\"\"\u001b[0m) + \u001b[31m\"Three\"\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                             ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                             value map is not",
      "stdout": "",
      "timestamp": 1660010510
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        val n = arr.size\n        val n1 = n.toInt\n        val nums = arr.sortWith(_ < _)\n        val maxN1 = nums.head.toInt\n        val firsts = nums.takeWhile(_ < maxN1)\n        val lasts = nums.dropWhile(_ < maxN1)\n        val len = firsts.size\n        val str = \"\"\n        if(len == n1) {\n            firsts.foreach(x => str = str + lookup(x.toInt))\n        }\n        if(len < n1) {\n            firsts.foreach(x => str = str + lookup(x.toInt) + \", \")\n        }\n        lasts.foreach(x => str = str + lookup(x.toInt))\n        str\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpzfh260z3.scala:26:44 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m            firsts.foreach(\u001b[36mx\u001b[0m => str = str + lookup(x.toInt))\n\u001b[31m\u001b[31m   |\u001b[0m                                            ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                            Not found: lookup\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpzfh260z3.scala:29:44 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m            firsts.foreach(\u001b[36mx\u001b[0m => str = str + lookup(x.toInt) + \u001b[31m\", \"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                            ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                            Not found: lookup\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpzfh260z3.scala:31:39 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        lasts.foreach(\u001b[36mx\u001b[0m => str = str + lookup(x.toInt))\n\u001b[31m\u001b[31m   |\u001b[0m                                       ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                       Not found: lookup\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpzfh260z3.scala:32:8 ---------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        str\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Found:    (str : String)\n\u001b[31m   |\u001b[0m        Required: List[String]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "stdout": "",
      "timestamp": 1660010507
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        val result = new ListBuffer[String]()\n        val min = arr.min\n        val max = arr.max\n        if (min < 2 && max > 9) {\n            arr.foreach { n =>\n                if ((min == 1 && n == 1) || (min == 9 && n == 9)) {\n                    result += s\"One\"\n                } else if (min == 2 && n == 1) {\n                    result += s\"Two\"\n                } else if (min == 3 && n == 1) {\n                    result += s\"Three\"\n                } else if (min == 4 && n == 1) {\n                    result += s\"Four\"\n                } else if (min == 5 && n == 1) {\n                    result += s\"Five\"\n                } else if (min == 6 && n == 1) {\n                    result += s\"Six\"\n                } else if (min == 7 && n == 1) {\n                    result += s\"Seven\"\n                } else if (min == 8 && n == 1) {\n                    result += s\"Eight\"\n                } else if (min == 9 && n == 1) {\n                    result += s\"Nine\"\n                } else if (min == 1 && n == 2) {\n                    result += s\"One\"\n                } else if (min == 2 && n == 2) {\n                    result += s\"Two\"\n                } else if (min == 3 && n == 2) {\n                    result += s\"Three\"\n                } else if (min == 4 && n == 2) {\n                    result += s\"Four\"\n                } else if (min == 5 && n == 2) {\n                    result += s\"Five\"\n                } else if (min == 6 && n == 2) {\n                    result += s\"Six\"\n                } else if (min == 7 && n == 2) {\n                    result += s\"Seven\"\n                } else if (min == 8 && n == 2) {\n                    result += s\"Eight\"\n                } else if (min == 9 && n == 2) {\n                    result += s\"Nine\"\n                } else if (min == 1 && n == 3) {\n                    result += s\"One\"\n                } else if (min == 2 && n == 3) {\n                    result += s\"Two\"\n                } else if (min == 3 && n == 3) {\n                    result += s\"Three\"\n                } else if (min == 4 && n == 3) {\n                    result += s\"Four\"\n                } else if (min == 5 && n == 3) {\n                    result += s\"Five\"\n                } else if (min == 6 && n == 3) {\n                    result += s\"Six\"\n                } else if (min == 7 && n == 3) {\n                    result += s\"Seven\"\n                } else if (min == 8 && n == 3) {\n                    result += s\"Eight\"\n                } else if (min == 9 && n == 3) {\n                    result += s\"Nine\"\n                } else if (min == 1 && n == 4) {\n                    result += s\"One\"\n                } else if (min == 2 && n == 4) {\n                    result += s\"Two\"\n                } else if (min == 3 && n == 4) {\n                    \n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpfw1hy2wn.scala:92:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m92 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpfw1hy2wn.scala:20:8 ---------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mif\u001b[0m (min < \u001b[31m2\u001b[0m && max > \u001b[31m9\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m        ^\u001b[0m\n\u001b[31m   |\u001b[0m        Found:    Unit\n\u001b[31m   |\u001b[0m        Required: List[String]\n\u001b[31m   |\u001b[0m        Maybe you are missing an else part for the conditional?\n\u001b[31m21 |\u001b[0m            arr.foreach { \u001b[36mn\u001b[0m =>\n\u001b[31m22 |\u001b[0m                \u001b[33mif\u001b[0m ((min == \u001b[31m1\u001b[0m && n == \u001b[31m1\u001b[0m) || (min == \u001b[31m9\u001b[0m && n == \u001b[31m9\u001b[0m)) {\n\u001b[31m23 |\u001b[0m                    result += \u001b[31ms\"One\"\u001b[0m\n\u001b[31m24 |\u001b[0m                } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (min == \u001b[31m2\u001b[0m && n == \u001b[31m1\u001b[0m) {\n\u001b[31m25 |\u001b[0m                    result += \u001b[31ms\"Two\"\u001b[0m\n\u001b[31m26 |\u001b[0m                } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (min == \u001b[31m3\u001b[0m && n == \u001b[31m1\u001b[0m) {\n\u001b[31m27 |\u001b[0m                    result += \u001b[31ms\"Three\"\u001b[0m\n\u001b[31m28 |\u001b[0m                } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (min == \u001b[31m4\u001b[0m && n == \u001b[31m1\u001b[0m) {\n\u001b[31m29 |\u001b[0m                    result += \u001b[31ms\"Four\"\u001b[0m\n\u001b[31m30 |\u001b[0m                } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (min == \u001b[31m5\u001b[0m && n == \u001b[31m1\u001b[0m) {\n\u001b[31m31 |\u001b[0m                    result += \u001b[31ms\"Five\"\u001b[0m\n\u001b[31m32 |\u001b[0m                } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (min == \u001b[31m6\u001b[0m && n == \u001b[31m1\u001b[0m) {\n\u001b[31m33 |\u001b[0m                    result += \u001b[31ms\"Six\"\u001b[0m\n\u001b[31m34 |\u001b[0m                } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (min == \u001b[31m7\u001b[0m && n == \u001b[31m1\u001b[0m) {\n\u001b[31m35 |\u001b[0m                    result += \u001b[31ms\"Seven\"\u001b[0m\n\u001b[31m36 |\u001b[0m                } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (min == \u001b[31m8\u001b[0m && n == \u001b[31m1\u001b[0m) {\n\u001b[31m37 |\u001b[0m                    result += \u001b[31ms\"Eight\"\u001b[0m\n\u001b[31m38 |\u001b[0m                } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (min == \u001b[31m9\u001b[0m && n == \u001b[31m1\u001b[0m) {\n\u001b[31m39 |\u001b[0m                    result += \u001b[31ms\"Nine\"\u001b[0m\n\u001b[31m",
      "stdout": "",
      "timestamp": 1660010504
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        var reversedArr : List[Long] = Nil\n        var retArr : List[String] = Nil\n        for (i <- 0 until arr.size) {\n            val cur = arr(i)\n            if (cur <= 9) retArr ::= (cur + \"\").toCharArray\n            else if (cur <= 99) retArr ::= (cur + \"\").toCharArray\n            else if (cur <= 999) retArr ::= (cur + \"\").toCharArray\n            else retArr ::= (cur + \"\").toCharArray\n        }\n        reversedArr ::= retArr.reverse\n        if (reversedArr.isEmpty) retArr\n        else byLength(byDigit(reversedArr))\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp2jmtexi1.scala:21:33 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m            \u001b[33mif\u001b[0m (cur <= \u001b[31m9\u001b[0m) retArr ::= (cur + \u001b[31m\"\"\u001b[0m).toCharArray\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue ::= is not a member of List[String] - did you mean List[String].::?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp2jmtexi1.scala:22:39 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (cur <= \u001b[31m99\u001b[0m) retArr ::= (cur + \u001b[31m\"\"\u001b[0m).toCharArray\n\u001b[31m\u001b[31m   |\u001b[0m                                ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue ::= is not a member of List[String] - did you mean List[String].::?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp2jmtexi1.scala:23:40 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m            \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (cur <= \u001b[31m999\u001b[0m) retArr ::= (cur + \u001b[31m\"\"\u001b[0m).toCharArray\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue ::= is not a member of List[String] - did you mean List[String].::?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp2jmtexi1.scala:24:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m            \u001b[33melse\u001b[0m retArr ::= (cur + \u001b[31m\"\"\u001b[0m).toCharArray\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue ::= is not a member of List[String] - did you mean List[String].::?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp2jmtexi1.scala:26:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        reversedArr ::= retArr.reverse\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m   value ::= is not a member of List[Long] - did you mean List[Long].::?\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp2jmtexi1.scala:28:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        \u001b[33melse\u001b[0m byLength(byDigit(reversedArr))\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      Not found: byDigit\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n6 errors ",
      "stdout": "",
      "timestamp": 1660010508
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        val arr = arr.reverse\n        var result = List[String]()\n        var isOne = false\n        var isTwo = false\n        var isThree = false\n        var isFour = false\n        var isFive = false\n        var isSix = false\n        var isSeven = false\n        var isEight = false\n        var isNine = false\n        for (i <- 0 until arr.length) {\n            if (arr(i).toString.toInt+\"\" == \"1\") {\n                isOne = true\n            } else if (arr(i).toString.toInt+\"\" == \"2\") {\n                isTwo = true\n            } else if (arr(i).toString.toInt+\"\" == \"3\") {\n                isThree = true\n            } else if (arr(i).toString.toInt+\"\" == \"4\") {\n                isFour = true\n            } else if (arr(i).toString.toInt+\"\" == \"5\") {\n                isFive = true\n            } else if (arr(i).toString.toInt+\"\" == \"6\") {\n                isSix = true\n            } else if (arr(i).toString.toInt+\"\" == \"7\") {\n                isSeven = true\n            } else if (arr(i).toString.toInt+\"\" == \"8\") {\n                isEight = true\n            } else if (arr(i).toString.toInt+\"\" == \"9\") {\n                isNine = true\n            }\n        }\n        if (isOne) {\n            result += \"One\"\n        } else if (isTwo) {\n            result += \"Two\"\n        } else if (isThree) {\n            result += \"Three\"\n        } else if (isFour) {\n            result += \"Four\"\n        } else if (isFive) {\n            result += \"Five\"\n        } else if (isSix) {\n            result += \"Six\"\n        } else if (isSeven) {\n            result += \"Seven\"\n        } else if (isEight) {\n            result += \"Eight\"\n        } else if (isNine) {\n            result += \"Nine\"\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpl88484d0.scala:17:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = arr.reverse\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Recursive \u001b[33mvalue\u001b[0m \u001b[35marr\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpl88484d0.scala:50:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m50 |\u001b[0m            result += \u001b[31m\"One\"\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue += is not a member of List[String] - did you mean List[String].!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpl88484d0.scala:52:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m52 |\u001b[0m            result += \u001b[31m\"Two\"\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue += is not a member of List[String] - did you mean List[String].!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpl88484d0.scala:54:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m54 |\u001b[0m            result += \u001b[31m\"Three\"\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue += is not a member of List[String] - did you mean List[String].!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpl88484d0.scala:56:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m56 |\u001b[0m            result += \u001b[31m\"Four\"\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue += is not a member of List[String] - did you mean List[String].!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpl88484d0.scala:58:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m58 |\u001b[0m            result += \u001b[31m\"Five\"\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue += is not a member of List[String] - did you mean List[String].!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpl88484d0.scala:60:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m60 |\u001b[0m            result += \u001b[31m\"Six\"\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue += is not a member of List[String] - did you mean List[String].!=?\n",
      "stdout": "",
      "timestamp": 1660010510
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        def revInts(x: Long) : List[Long] = x match {\n            case 1 => 1\n            case 2 => 2\n            case 3 => 3\n            case 4 => 4\n            case 5 => 5\n            case 6 => 6\n            case 7 => 7\n            case 8 => 8\n            case 9 => 9\n            case _ => x\n        }\n        val map: mutable.Map[Int, String] = mutable.HashMap.empty[Int, String]\n        arr.foreach {\n            case 1 => map.updated(1l, \"One\")\n            case 2 => map.updated(2l, \"Two\")\n            case 3 => map.updated(3l, \"Three\")\n            case 4 => map.updated(4l, \"Four\")\n            case 5 => map.updated(5l, \"Five\")\n            case 6 => map.updated(6l, \"Six\")\n            case 7 => map.updated(7l, \"Seven\")\n            case 8 => map.updated(8l, \"Eight\")\n            case 9 => map.updated(9l, \"Nine\")\n            case _ => ()\n        }\n        revInts(arr).reverse.map {\n            case x => map.getOrElse(x, \"\").trim\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmppqt4s_02.scala:18:22 --------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m            \u001b[33mcase\u001b[0m \u001b[31m1\u001b[0m => \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                      Found:    (\u001b[31m1\u001b[0m : Int)\n\u001b[31m   |\u001b[0m                      Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmppqt4s_02.scala:19:22 --------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m            \u001b[33mcase\u001b[0m \u001b[31m2\u001b[0m => \u001b[31m2\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                      Found:    (\u001b[31m2\u001b[0m : Int)\n\u001b[31m   |\u001b[0m                      Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmppqt4s_02.scala:20:22 --------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m            \u001b[33mcase\u001b[0m \u001b[31m3\u001b[0m => \u001b[31m3\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                      Found:    (\u001b[31m3\u001b[0m : Int)\n\u001b[31m   |\u001b[0m                      Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmppqt4s_02.scala:21:22 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m            \u001b[33mcase\u001b[0m \u001b[31m4\u001b[0m => \u001b[31m4\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                      Found:    (\u001b[31m4\u001b[0m : Int)\n\u001b[31m   |\u001b[0m                      Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmppqt4s_02.scala:22:22 --------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            \u001b[33mcase\u001b[0m \u001b[31m5\u001b[0m => \u001b[31m5\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                      Found:    (\u001b[31m5\u001b[0m : Int)\n\u001b[31m   |\u001b[0m                      Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation avai",
      "stdout": "",
      "timestamp": 1660010511
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        arr.sortWith((a, b) => a < b) match {\n            case Nil => Nil\n            case (a :: Nil) => (a % 10).map(i => s\"One\").filter(!_ == \"One\").mkString(\"\")\n            case (a :: tail) => (a % 10).map(i => s\"$i\").filter(!_ == \"One\").mkString(\"\") :: byLength(tail)\n            case (_ :: b) => (b % 10).map(i => s\"$i\").filter(!_ == \"One\").mkString(\"\") :: byLength(arr)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpvbv8xzr7.scala:19:40 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m            \u001b[33mcase\u001b[0m (a :: Nil) => (a % \u001b[31m10\u001b[0m).map(i => \u001b[31ms\"One\"\u001b[0m).filter(!_ == \u001b[31m\"One\"\u001b[0m).mkString(\u001b[31m\"\"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                               ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                               value map is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpvbv8xzr7.scala:20:41 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m            \u001b[33mcase\u001b[0m (a :: tail) => (a % \u001b[31m10\u001b[0m).map(i => \u001b[31ms\"\u001b[0m$i\u001b[31m\"\u001b[0m).filter(!_ == \u001b[31m\"One\"\u001b[0m).mkString(\u001b[31m\"\"\u001b[0m) :: byLength(tail)\n\u001b[31m\u001b[31m   |\u001b[0m                                ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                value map is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpvbv8xzr7.scala:21:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m            \u001b[33mcase\u001b[0m (_ :: b) => (b % \u001b[31m10\u001b[0m).map(i => \u001b[31ms\"\u001b[0m$i\u001b[31m\"\u001b[0m).filter(!_ == \u001b[31m\"One\"\u001b[0m).mkString(\u001b[31m\"\"\u001b[0m) :: byLength(arr)\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue % is not a member of List[Long], but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mThe following import might make progress towards fixing the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.Integral.Implicits.infixIntegralOps\n\u001b[31m   |\u001b[0m\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660010510
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        if (arr.isEmpty) {\n            return []\n        }\n        val len = arr.head\n        val res = arr.tail.sortBy(_.toInt).reverse\n        if (res.nonEmpty) {\n            val one = res find {\n                _.toInt == 1\n            }\n            if (one != null) {\n                res.find(_._1.toInt == 1).foreach { r =>\n                    val f = r.toString.charAt(r.toString.length - 1)\n                    val m = ones.find(_.toString == f).getOrElse(null)\n                    val o = ones.get(m)\n                    res remove r\n                    res += ((o + r.toString).replaceFirst(f, m))\n                }\n            }\n        }\n        if (res.nonEmpty) {\n            res.map {\n                r => r.replaceFirst(\"9\", \"Nine\").replaceFirst(\"7\", \"Six\")\n            }\n        }\n        else {\n            List[String]()\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpug6rhtkk.scala:18:20 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m            \u001b[33mreturn\u001b[0m []\n\u001b[31m\u001b[31m   |\u001b[0m                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                    an identifier expected, but ']' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpug6rhtkk.scala:19:8 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        }\n\u001b[31m\u001b[31m   |\u001b[0m        ^\u001b[0m\n\u001b[31m   |\u001b[0m        '=>' expected, but '}' found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpug6rhtkk.scala:27:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m                res.find(_._1.toInt == \u001b[31m1\u001b[0m).foreach { \u001b[36mr\u001b[0m =>\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         value _1 is not a member of Long\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpug6rhtkk.scala:29:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m                    \u001b[33mval\u001b[0m \u001b[36mm\u001b[0m = ones.find(_.toString == f).getOrElse(\u001b[31mnull\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                            ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                            Not found: ones\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpug6rhtkk.scala:30:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m                    \u001b[33mval\u001b[0m \u001b[36mo\u001b[0m = ones.get(m)\n\u001b[31m\u001b[31m   |\u001b[0m                            ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                            Not found: ones\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpug6rhtkk.scala:31:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m                    res remove r\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue remove is not a member of List[Long], but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.seq AsJavaList\n\u001b[31m   |\u001b[0m  impor",
      "stdout": "",
      "timestamp": 1660010512
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        if (arr.nonEmpty) {\n            val len = arr.map(_.toString).map(_.length).max\n            val reversed = arr.sortWith(_ > _)\n            val result = reversed.map(_.toString)\n            val index = (result.map(_.length) zip (result.map(_.toString)) map {case (x, y) => (y * Math.pow(10, x)) to y})\n            val rMap = new scala.collection.mutable.HashMap[Int, String]()\n            val rLen = index.toArray.length\n            for (i <- 0 until rLen) {\n                rMap.put(index(i), result(i))\n            }\n            val rLen = result.map(_.length).max\n            rMap.filterValues { v => v.length == rLen }.toList.sortWith(_ > _)\n                .map(kv => kv._1 -> kv._2)\n        } else {\n            List()\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp36rwq4l1.scala:27:16 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mrLen\u001b[0m = result.map(_.length).max\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mrLen is already defined as \u001b[33mvalue\u001b[0m \u001b[35mrLen\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp36rwq4l1.scala:21:108 -------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mindex\u001b[0m = (result.map(_.length) zip (result.map(_.toString)) map {\u001b[33mcase\u001b[0m (x, y) => (y * Math.pow(\u001b[31m10\u001b[0m, x)) to y})\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                                    ^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                                        Found:    Double\n\u001b[31m   |\u001b[0m                                                        Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp36rwq4l1.scala:21:120 -------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mindex\u001b[0m = (result.map(_.length) zip (result.map(_.toString)) map {\u001b[33mcase\u001b[0m (x, y) => (y * Math.pow(\u001b[31m10\u001b[0m, x)) to y})\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                                                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                           Found:    (y : String)\n\u001b[31m   |\u001b[0m                           Required: scala.collection.Factory[Char, Any]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- Error: /tmp/tmp36rwq4l1.scala:23:36 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mrLen\u001b[0m = index.toArray.length\n\u001b[31m\u001b[31m   |\u001b[0m                                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                                    No ClassTa",
      "stdout": "",
      "timestamp": 1660010512
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n      var list = new List[String]\n      var i = 0\n      while (i < arr.size) {\n        if (arr(i) <= 9) {\n          list = list ::: (arr(i) map {\n            case \"0\"  => \"Zero\"\n            case \"1\"  => \"One\"\n            case \"2\"  => \"Two\"\n            case \"3\"  => \"Three\"\n            case \"4\"  => \"Four\"\n            case \"5\"  => \"Five\"\n            case \"6\"  => \"Six\"\n            case \"7\"  => \"Seven\"\n            case \"8\"  => \"Eight\"\n            case \"9\"  => \"Nine\"\n            case _   => \"?\"\n          })\n        } else {\n          list = list ::: (\"?\" map {\n            case \"1\"  => \"One\"\n            case \"2\"  => \"Two\"\n            case \"3\"  => \"Three\"\n            case \"4\"  => \"Four\"\n            case \"5\"  => \"Five\"\n            case \"6\"  => \"Six\"\n            case \"7\"  => \"Seven\"\n            case \"8\"  => \"Eight\"\n            case \"9\"  => \"Nine\"\n            case _   => \"?\"\n          })\n        }\n        i = i + 1\n      }\n      if (list.nonEmpty) {\n        val reverse = list.tail.reverse\n        var j = 0\n        val indexedList = reverse.map {\n          case \"?\" => arr(j)\n          case \"One\"  => 1\n          case \"Two\"  => 2\n          case \"Three\" => 3\n          case \"Four\" => 4\n          case \"Five\" => 5\n          case \"Six\"   => 6\n          case \"Seven\" => 7\n          case \"Eight\" => 8\n          case \"Nine\" => 9\n          case \"Zero\" => 0\n          case a => (a - (indexedList.indexOf(a) + 1)).toLong\n        }\n        list = (reverse ::: indexedList).reverse\n      }\n      list\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmps1k3p3y_.scala:21:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m          list = list ::: (arr(i) map {\n\u001b[31m\u001b[31m   |\u001b[0m                           ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                           value map is not a member of Long\n\u001b[31m\u001b[31m-- Error: /tmp/tmps1k3p3y_.scala:36:17 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m            \u001b[33mcase\u001b[0m \u001b[31m\"1\"\u001b[0m  => \u001b[31m\"One\"\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Values of types String and Char cannot be compared with == or !=\n\u001b[31m\u001b[31m-- Error: /tmp/tmps1k3p3y_.scala:37:17 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m            \u001b[33mcase\u001b[0m \u001b[31m\"2\"\u001b[0m  => \u001b[31m\"Two\"\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Values of types String and Char cannot be compared with == or !=\n\u001b[31m\u001b[31m-- Error: /tmp/tmps1k3p3y_.scala:38:17 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m            \u001b[33mcase\u001b[0m \u001b[31m\"3\"\u001b[0m  => \u001b[31m\"Three\"\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Values of types String and Char cannot be compared with == or !=\n\u001b[31m\u001b[31m-- Error: /tmp/tmps1k3p3y_.scala:39:17 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m            \u001b[33mcase\u001b[0m \u001b[31m\"4\"\u001b[0m  => \u001b[31m\"Four\"\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Values of types String and Char cannot be compared with == or !=\n\u001b[31m\u001b[31m-- Error: /tmp/tmps1k3p3y_.scala:40:17 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m            \u001b[33mcase\u001b[0m \u001b[31m\"5\"\u001b[0m  => \u001b[31m\"Five\"\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Values of types String and Char cannot be compared with == or !=\n\u001b[31m\u001b[31m-- Error: /tmp/tmps1k3p3y_.scala:41:17 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m            \u001b[33mcase\u001b[0m \u001b[31m\"6\"\u001b[0m  => \u001b[31m\"Six\"\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Values of types String and Ch",
      "stdout": "",
      "timestamp": 1660010513
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        var res = arr.toList\n        val one = Array.fill(9)(1l)\n        val tens = Array.fill(10)(0l)\n        val strs = new mutable.ListBuffer[String]\n        for (i <- 0 until arr.size) {\n            val curr = arr(i)\n            if (curr > 9) {\n                strs += Array(curr.toString.toUpperCase)\n            } else {\n                val digit = curr / 10\n                val tensDigit = curr - digit * 10\n                if (digit < 1 || digit > 9) {\n                    strs += \"?\"\n                } else if (tensDigit < 0) {\n                    strs += \"?\"\n                } else if (tensDigit < 5) {\n                    strs += \"One\"\n                } else if (tensDigit < 10) {\n                    strs += \"Ten\"\n                } else {\n                    strs += \"Five\"\n                }\n                tens(digit) += 1\n            }\n        }\n        for (i <- 0 until strs.size) {\n            if (one(i) > 0)\n                strs.apply(i) += \"One\"\n            if (tens(i) > 0)\n                strs.apply(i) += \"Ten\"\n            if (tens(i) > 0)\n                strs.apply(i) += \"Five\"\n        }\n        if (strs.size == 0)\n            res\n        else\n            strs.toList\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp6u1zf0jb.scala:20:23 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstrs\u001b[0m = \u001b[33mnew\u001b[0m mutable.ListBuffer[\u001b[35mString\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp6u1zf0jb.scala:39:21 --------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m                tens(digit) += \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Found:    (digit : Long)\n\u001b[31m   |\u001b[0m                     Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp6u1zf0jb.scala:51:12 --------------------\u001b[0m\u001b[0m\n\u001b[31m51 |\u001b[0m            res\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^\u001b[0m\n\u001b[31m   |\u001b[0m            Found:    (res : List[Long])\n\u001b[31m   |\u001b[0m            Required: List[String]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660010512
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        var ans = List[String]()\n        for(i<- 0 until arr.size) {\n            val item = arr(i)\n            if(item < 10) {\n                ans = ans :+ item.toString\n            } else if(item < 100) {\n                ans = ans :+ (item % 10).asInstanceOf[String]\n            } else if(item < 1000) {\n                ans = ans :+ (item % 100).asInstanceOf[String]\n            } else if(item < 10000) {\n                ans = ans :+ (item % 1000).asInstanceOf[String]\n            } else if(item < 100000) {\n                ans = ans :+ (item % 10000).asInstanceOf[String]\n            } else if(item < 1000000) {\n                ans = ans :+ (item % 100000).asInstanceOf[String]\n            } else if(item < 10000000) {\n                ans = ans :+ (item % 1000000).asInstanceOf[String]\n            } else if(item < 100000000) {\n                ans = ans :+ (item % 10000000).asInstanceOf[String]\n            } else if(item < 1000000000) {\n                ans = ans :+ (item % 100000000).asInstanceOf[String]\n            } else if(item < 10000000000) {\n                ans = ans :+ (item % 1000000000).asInstanceOf[String]\n            } else if(item < 100000000000) {\n                ans = ans :+ (item % 10000000000).asInstanceOf[String]\n            } else if(item < 1000000000000) {\n                ans = ans :+ (item % 100000000000).asInstanceOf[String]\n            } else if(item < 10000000000000) {\n                ans = ans :+ (item % 1000000000000).asInstanceOf[String]\n            } else if(item < 100000000000000) {\n                ans = ans :+ (item % 10000000000000).asInstanceOf[String]\n            } else if(item < 1000000000000000) {\n                ans = ans :+ (item % 100000000000000).asInstanceOf[String]\n            } else if(item < 10000000000000000) {\n                ans = ans :+ (item % 1000000000000000).asInstanceOf[String]\n            } else if(item < 100000000000000000) {\n                ans = ans :+ (item % 10000000000000000).asInstanceOf[String]\n            } else if(item < 1000000000000000010) {\n                ans = ans :+ (item % 100000000000000000).asInstanceOf[String]\n            } else if(item < 10000000000000000100) {\n                ans = \n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmp50ecv614.scala:57:21 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m57 |\u001b[0m                ans = \n\u001b[31m\u001b[31m   |\u001b[0m                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                     expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp50ecv614.scala:68:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m68 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- Error: /tmp/tmp50ecv614.scala:38:29 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m(item < \u001b[31m10000000000\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                             ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                             number too large\n\u001b[31m\u001b[31m-- Error: /tmp/tmp50ecv614.scala:40:29 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m(item < \u001b[31m100000000000\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                             ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                             number too large\n\u001b[31m\u001b[31m-- Error: /tmp/tmp50ecv614.scala:41:37 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m                ans = ans :+ (item % \u001b[31m10000000000\u001b[0m).asInstanceOf[\u001b[35mString\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                     number too large\n\u001b[31m\u001b[31m-- Error: /tmp/tmp50ecv614.scala:42:29 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m(item < \u001b[31m1000000000000\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                             ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                             number too large\n\u001b[31m\u001b[31m-- Error: /tmp/tmp50ecv614.scala:43:37 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m43 |\u001b[0m                ans = ans :+ (item % \u001b[31m100000000000\u001b[0m).asInstanceOf[\u001b[35mString\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^^^^^^^^",
      "stdout": "",
      "timestamp": 1660010508
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n      var result = new scala.collection.mutable.ListBuffer[String]();\n      if (arr.isEmpty) {\n        result += \"()\";\n      } else {\n        var index = 1;\n        var counter = 0;\n        while(counter < arr.length) {\n          while (arr.take(index).size < 8) {\n            index++;\n          }\n          result += (arr[counter].toString.toCharArray.map( x => byLengthRep(x)).mkString(\"\"));\n          counter++;\n        }\n      }\n      result.reverse;\n      result\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmp3laushej.scala:25:19 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m            index++;\n\u001b[31m\u001b[31m   |\u001b[0m                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                   expression expected but \u001b[31m';'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmp3laushej.scala:28:19 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m          counter++;\n\u001b[31m\u001b[31m   |\u001b[0m                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                   expression expected but \u001b[31m';'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp3laushej.scala:27:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m          result += (arr[\u001b[35mcounter\u001b[0m].toString.toCharArray.map( \u001b[36mx\u001b[0m => byLengthRep(x)).mkString(\u001b[31m\"\"\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: type counter\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp3laushej.scala:32:6 ---------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m      result\n\u001b[31m\u001b[31m   |\u001b[0m      ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      Found:    (result : scala.collection.mutable.ListBuffer[String])\n\u001b[31m   |\u001b[0m      Required: List[String]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "stdout": "",
      "timestamp": 1660010513
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        arr.filter(i => i <= 9 && i >= 1) match {\n            case List() => List()\n            case x::xs => reverse(xs) match {\n                case List() => List()\n                case x::x2 => x.toString() +: byLength(x2)\n            }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp6a6b30iv.scala:19:26 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m            \u001b[33mcase\u001b[0m x::xs => reverse(xs) \u001b[33mmatch\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          Not found: reverse\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp6a6b30iv.scala:21:55 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m                \u001b[33mcase\u001b[0m x::x2 => x.toString() +: byLength(x2)\n\u001b[31m\u001b[31m   |\u001b[0m                                                       ^^\u001b[0m\n\u001b[31m   |\u001b[0m                                                       Not found: x2\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660010509
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        var output: List[String] = Nil\n        var prev = 0L\n        var digit = 0\n        for(i <- 0 until arr.size){\n            val nextDigit = arr(i)\n            if(nextDigit < 1L || nextDigit > 9L) {\n                output = Nil\n                break\n            }\n            if(prev + 1L != nextDigit) {\n                output = output :+ getDigitName(nextDigit - 1L)\n            }\n            prev = nextDigit\n            digit = nextDigit\n        }\n        if(digit < 1L || digit > 9L) {\n            output = Nil\n        }\n        output :+ getDigitName(digit - 1L)\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp11xeiuj7.scala:24:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m                break\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: break\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp11xeiuj7.scala:27:35 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m                output = output :+ getDigitName(nextDigit - \u001b[31m1L\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                   ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                   Not found: getDigitName\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp11xeiuj7.scala:30:20 --------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m            digit = nextDigit\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Found:    (nextDigit : Long)\n\u001b[31m   |\u001b[0m                    Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp11xeiuj7.scala:35:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m        output :+ getDigitName(digit - \u001b[31m1L\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  Not found: getDigitName\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "stdout": "",
      "timestamp": 1660010513
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        val mapA = Map(1->\"One\", 2->\"Two\", 3->\"Three\", 4->\"Four\", 5->\"Five\", 6->\"Six\", 7->\"Seven\", 8->\"Eight\", 9->\"Nine\")\n        val mapB = Map(1->\"One\", 2->\"Two\", 3->\"Three\", 4->\"Four\", 5->\"Five\", 6->\"Six\", 7->\"Seven\", 8->\"Eight\", 9->\"Nine\")\n        val mapC = Map(1->\"One\", 2->\"Two\", 3->\"Three\", 4->\"Four\", 5->\"Five\", 6->\"Six\", 7->\"Seven\", 8->\"Eight\", 9->\"Nine\")\n        val mapD = Map(1->\"One\", 2->\"Two\", 3->\"Three\", 4->\"Four\", 5->\"Five\", 6->\"Six\", 7->\"Seven\", 8->\"Eight\", 9->\"Nine\")\n        val mapE = Map(1->\"One\", 2->\"Two\", 3->\"Three\", 4->\"Four\", 5->\"Five\", 6->\"Six\", 7->\"Seven\", 8->\"Eight\", 9->\"Nine\")\n        val mapF = Map(1->\"One\", 2->\"Two\", 3->\"Three\", 4->\"Four\", 5->\"Five\", 6->\"Six\", 7->\"Seven\", 8->\"Eight\", 9->\"Nine\")\n        val mapG = Map(1->\"One\", 2->\"Two\", 3->\"Three\", 4->\"Four\", 5->\"Five\", 6->\"Six\", 7->\"Seven\", 8->\"Eight\", 9->\"Nine\")\n        val mapH = Map(1->\"One\", 2->\"Two\", 3->\"Three\", 4->\"Four\", 5->\"Five\", 6->\"Six\", 7->\"Seven\", 8->\"Eight\", 9->\"Nine\")\n        val mapI = Map(1->\"One\", 2->\"Two\", 3->\"Three\", 4->\"Four\", 5->\"Five\", 6->\"Six\", 7->\"Seven\", 8->\"Eight\", 9->\"Nine\")\n        val mapJ = Map(\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmp_1s7qriz.scala:26:23 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmapJ\u001b[0m = Map(\n\u001b[31m\u001b[31m   |\u001b[0m                       ^\u001b[0m\n\u001b[31m   |\u001b[0m                       expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp_1s7qriz.scala:27:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[String]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660010513
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        val digits = arr.filter( x => x >= 1l && x <= 9l).toList\n        var reversedList: List[Long] = List();\n        var reversedDigits: Set[Long] = Set()\n        for(d <- digits) {\n            if(!reversedDigits.contains(d)) {\n                reversedList ::= d\n                reversedDigits += d\n            }\n        }\n        if(reversedList.isEmpty) List()\n        else reversedList.map(x => byDigit(x % 10).mkString(\"\") ++ byDigit(x / 10).mkString(\"\"))\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpv_k3c6te.scala:27:35 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33melse\u001b[0m reversedList.map(x => byDigit(x % \u001b[31m10\u001b[0m).mkString(\u001b[31m\"\"\u001b[0m) ++ byDigit(x / \u001b[31m10\u001b[0m).mkString(\u001b[31m\"\"\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                                   ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                   Not found: byDigit\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010511
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        var result: List[String] = Nil\n        arr.foreach {x =>\n            if (x < 1l) return\n            if (x > 9l) return\n            var result : List[String] = Nil\n            var index = x\n            var one = One\n            var two = Two\n            var three = Three\n            var four = Four\n            var five = Five\n            var six = Six\n            var seven = Seven\n            var eight = Eight\n            var nine = Nine\n            result ::= one.toString.replaceFirst(one.toString(), \"\").replaceFirst(two.toString(), \"\").replaceFirst(three.toString(), \"\").replaceFirst(four.toString(), \"\").replaceFirst(five.toString(), \"\").replaceFirst(six.toString(), \"\").replaceFirst(seven.toString(), \"\").replaceFirst(eight.toString(), \"\").replaceFirst(nine.toString(), \"\") :: result\n            result += index.toString().replaceFirst(one.toString(), \"\").replaceFirst(two.toString(), \"\").replaceFirst(three.toString(), \"\").replaceFirst(four.toString(), \"\").replaceFirst(five.toString(), \"\").replaceFirst(six.toString(), \"\").replaceFirst(seven.toString(), \"\").replaceFirst(eight.toString(), \"\").replaceFirst(nine.toString(), \"\") :: result\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpz_q8u0o8.scala:19:24 --------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m            \u001b[33mif\u001b[0m (x < \u001b[31m1l\u001b[0m) \u001b[33mreturn\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        Found:    Unit\n\u001b[31m   |\u001b[0m                        Required: List[String]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpz_q8u0o8.scala:20:24 --------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m            \u001b[33mif\u001b[0m (x > \u001b[31m9l\u001b[0m) \u001b[33mreturn\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        Found:    Unit\n\u001b[31m   |\u001b[0m                        Required: List[String]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpz_q8u0o8.scala:23:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m            \u001b[33mvar\u001b[0m \u001b[36mone\u001b[0m = One\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      Not found: One\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpz_q8u0o8.scala:24:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m            \u001b[33mvar\u001b[0m \u001b[36mtwo\u001b[0m = Two\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      Not found: Two\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpz_q8u0o8.scala:25:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m            \u001b[33mvar\u001b[0m \u001b[36mthree\u001b[0m = Three\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        Not found: Three\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpz_q8u0o8.scala:26:23 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m            \u001b[33mvar\u001b[0m \u001b[36mfour\u001b[0m = Four\n\u001b[31m\u001b",
      "stdout": "",
      "timestamp": 1660010515
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        // If there is only one element return it:\n        if (arr.size <= 1) return Nil\n        // Otherwise, go through the list and keep track of the lengths of the numbers so far:\n        var counts = arr.groupBy(_.toInt).mapValues(_.length).toList\n        // If the list is too short, return it:\n        if (counts.length <= 1) return Nil\n        // Otherwise sort them:\n        counts = counts.sortBy(-_._2)\n        // Return their string representation:\n        return counts map { case (count, string) =>\n            if (string <= \"Nine\") 0\n            else if (string <= \"Eight\") 1\n            else if (string <= \"Seven\") 2\n            else if (string <= \"Six\") 3\n            else if (string <= \"Five\") 4\n            else if (string <= \"Four\") 5\n            else if (string <= \"Three\") 6\n            else if (string <= \"Two\") 7\n            else if (string <= \"One\") 8\n            else 9\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E134] Type Error: /tmp/tmpr263ly7p.scala:27:23 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m            \u001b[33mif\u001b[0m (string <= \u001b[31m\"Nine\"\u001b[0m) \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mNone of the overloaded alternatives of \u001b[33mmethod\u001b[0m \u001b[35m<=\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mInt\u001b[0m with types\n\u001b[31m   |\u001b[0m (x: Double): Boolean\n\u001b[31m   |\u001b[0m (x: Float): Boolean\n\u001b[31m   |\u001b[0m (x: Long): Boolean\n\u001b[31m   |\u001b[0m (x: Int): Boolean\n\u001b[31m   |\u001b[0m (x: Char): Boolean\n\u001b[31m   |\u001b[0m (x: Short): Boolean\n\u001b[31m   |\u001b[0m (x: Byte): Boolean\n\u001b[31m   |\u001b[0mmatch arguments ((\u001b[32m\"Nine\"\u001b[0m : String))\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpr263ly7p.scala:27:34 --------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m            \u001b[33mif\u001b[0m (string <= \u001b[31m\"Nine\"\u001b[0m) \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Found:    (\u001b[31m0\u001b[0m : Int)\n\u001b[31m   |\u001b[0m                                  Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E134] Type Error: /tmp/tmpr263ly7p.scala:28:28 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m            \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (string <= \u001b[31m\"Eight\"\u001b[0m) \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mNone of the overloaded alternatives of \u001b[33mmethod\u001b[0m \u001b[35m<=\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mInt\u001b[0m with types\n\u001b[31m   |\u001b[0m (x: Double): Boolean\n\u001b[31m   |\u001b[0m (x: Float): Boolean\n\u001b[31m   |\u001b[0m (x: Long): Boolean\n\u001b[31m   |\u001b[0m (x: Int): Boolean\n\u001b[31m   |\u001b[0m (x: Char): Boolean\n\u001b[31m   |\u001b[0m (x: Short): Boolean\n\u001b[31m   |\u001b[0m (x: Byte): Boolean\n\u001b[31m   |\u001b[0mmatch arguments ((\u001b[32m\"Eight\"\u001b[0m : String))\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpr263ly7p.scala:28:40 --------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m            \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (string <= \u001b[31m\"Eight\"\u001b[0m) \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                         ",
      "stdout": "",
      "timestamp": 1660010516
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        if (arr.isEmpty) List()\n        else if (arr.head == -1) List()\n        else byLength((arr.head to arr.last).sorted)\n            .map(n => n.toString).reverse\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpjeri5_j5.scala:19:22 --------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33melse\u001b[0m byLength((arr.head to arr.last).sorted)\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      Found:    IndexedSeq[Long]\n\u001b[31m   |\u001b[0m                      Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010514
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        if (arr.nonEmpty) byLengthRecursive(arr)\n        else List(\"Empty\")\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmphji9meop.scala:17:26 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        \u001b[33mif\u001b[0m (arr.nonEmpty) byLengthRecursive(arr)\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          Not found: byLengthRecursive\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010512
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        // Write your logic here\n        var arr = arr.reverse\n        var newArr: List[String] = List()\n        var isFirst = true\n        for(i <- arr.length) {\n            if(arr.contains(i.toLong)) {\n                val name = One.name + (i % 10).toString\n                arr.remove(arr.indexOf(i.toLong))\n                newArr = newArr :+ name\n                isFirst = false\n            } else if(isFirst) {\n                newArr = newArr :+ (One.name + (i % 10).toString)\n            } else {\n                newArr = newArr :+ (\"One\")\n            }\n        }\n        return newArr\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpznsuigcy.scala:18:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36marr\u001b[0m = arr.reverse\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Recursive \u001b[33mvariable\u001b[0m \u001b[35marr\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010512
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n      val list = arr.filter(x => x < 9 && x > 0 && x % 10 == 0)\n      if (list.size == 0) list.empty\n      else {\n        val list = arr.reverse\n        val str = list.map(i => s\"$i\").mkString(\"\", \"Reverse\", \"\", \"\")\n        val charList = str.split(\"Reverse\".toCharArray).map(_.toUpperCase)\n        val strList = charList.map(cnt => cnt -> charList.filter(_._2 == cnt).head._1)\n        strList.map { case (cnt, name) =>\n          val idx = list.indexWhere(x => x % 10 == cnt)\n          (name.toString, list[idx])\n        }.foldLeft(strList)(_++ _)\n      }\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp4s8sdd6b.scala:18:31 --------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m      \u001b[33mif\u001b[0m (list.size == \u001b[31m0\u001b[0m) list.empty\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    List[Long @uncheckedVariance]\n\u001b[31m   |\u001b[0m                          Required: List[String]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp4s8sdd6b.scala:21:48 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstr\u001b[0m = list.map(\u001b[36mi\u001b[0m => \u001b[31ms\"\u001b[0m$i\u001b[31m\"\u001b[0m).mkString(\u001b[31m\"\"\u001b[0m, \u001b[31m\"Reverse\"\u001b[0m, \u001b[31m\"\"\u001b[0m, \u001b[31m\"\"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                                ^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              Found:    (String, String, String, String)\n\u001b[31m   |\u001b[0m                              Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp4s8sdd6b.scala:22:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mcharList\u001b[0m = str.split(\u001b[31m\"Reverse\"\u001b[0m.toCharArray).map(_.toUpperCase)\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       value split is not a member of Char\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660010517
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        if (arr.isEmpty || arr.map(_.toString.length).max > 9)\n            List()\n        else\n            arr.filter(_.toString.length == arr.map(_.toString.length).max).sortWith((x, y) => y < x).map {\n                x => if (x < 10) x.toString else String.format(\"%s[%s]\", \n                        x%10 + 48,\n                        x)\n            }.reverse\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpcyjor_8z.scala:27)\n\tat Problem.main(tmpcyjor_8z.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660010517
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        val res = arr match {\n            case Nil => List()\n            case x :: y => y.filter( y => y % 10 == 1 || y % 10 == 2 || y % 10 == 3 || y % 10 == 4 || y % 10 == 5 || y % 10 == 6 || y % 10 == 7 || y % 10 == 8 || y % 10 == 9)\n                                .map(i => i match {\n                                    case 0 => \"One\"\n                                    case 1 => \"Two\"\n                                    case 2 => \"Three\"\n                                    case 3 => \"Four\"\n                                    case 4 => \"Five\"\n                                    case 5 => \"Six\"\n                                    case 6 => \"Seven\"\n                                    case 7 => \"Eight\"\n                                    case 8 => \"Nine\"\n                                    case 9 => \"Nine\"\n                                    case _ => \"?\"\n                                }).reverse\n        }\n        res\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp2adii8qu.scala:37)\n\tat Problem.main(tmp2adii8qu.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660010519
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n      val list = arr.toList\n      list.reverse.map(_.toString.replaceAll(\"\"\"(\\d+)\"\"\", s => getName(s.toInt)).mkString(\"\"))\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E081] Type Error: /tmp/tmpttwvv33g.scala:18:58 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m      list.reverse.map(_.toString.replaceAll(\u001b[31m\"\"\"(\\d+)\"\"\"\u001b[0m, \u001b[36ms\u001b[0m => getName(s.toInt)).mkString(\u001b[31m\"\"\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                                                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Missing parameter type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m                          I could not infer the type of the parameter s.\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpttwvv33g.scala:18:63 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m      list.reverse.map(_.toString.replaceAll(\u001b[31m\"\"\"(\\d+)\"\"\"\u001b[0m, \u001b[36ms\u001b[0m => getName(s.toInt)).mkString(\u001b[31m\"\"\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                                                               ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                                      Not found: getName\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660010516
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        val m = arr.max\n        val min = arr.min\n        val n = (arr diff Set(1l, 9l) map (_.toLong)) sortWith(_ < _)\n        val r = n map (_.toString.replaceFirst(\"\\\\D\", \"\"))\n        if(m.toString.isEmpty){\n            r\n        }\n        else {\n            val o = r.takeWhile(_ <= m).mkString\n            val n = r.drop(o.length).mkString\n            o :: n :: r.takeWhile(_ <= m).mkString\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpjppucit6.scala:19:29 --------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mn\u001b[0m = (arr diff Set(\u001b[31m1l\u001b[0m, \u001b[31m9l\u001b[0m) map (_.toLong)) sortWith(_ < _)\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    scala.collection.\u001b[1m\u001b[31mmutable\u001b[0m\u001b[1m\u001b[31m.\u001b[0m\u001b[1m\u001b[31mSet\u001b[0m[Long]\n\u001b[31m   |\u001b[0m                          Required: scala.collection.\u001b[1m\u001b[32mSeq\u001b[0m[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpjppucit6.scala:25:37 --------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mo\u001b[0m = r.takeWhile(_ <= m).mkString\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                                     Found:    (m : Long)\n\u001b[31m   |\u001b[0m                                     Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpjppucit6.scala:27:39 --------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m            o :: n :: r.takeWhile(_ <= m).mkString\n\u001b[31m\u001b[31m   |\u001b[0m                                       ^\u001b[0m\n\u001b[31m   |\u001b[0m                                       Found:    (m : Long)\n\u001b[31m   |\u001b[0m                                       Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660010519
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        val list = arr.toList\n        val len = arr.size\n        var list = list.sortWith( (a,b) => a < b).toList.reverse\n        val arr2 = new Array[String](len)\n        var i = 0\n        while (i < len) {\n            if (i % 2 == 0) {\n                arr2(i / 2) = One.name\n            }\n            else {\n                arr2(i / 2) = Two.name\n            }\n            i += 1\n        }\n        list = list.map(d => d.toString.replaceFirst(\"[0123456789]\", arr2(d.toInt - 1))).reverse\n        if (list.isEmpty)\n            list\n        else\n            list\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpke4vg3s9.scala:19:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mlist\u001b[0m = list.sortWith( (\u001b[36ma\u001b[0m,\u001b[36mb\u001b[0m) => a < b).toList.reverse\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mlist is already defined as \u001b[33mvalue\u001b[0m \u001b[35mlist\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpke4vg3s9.scala:24:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m                arr2(i / \u001b[31m2\u001b[0m) = One.name\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              Not found: One\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpke4vg3s9.scala:27:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m                arr2(i / \u001b[31m2\u001b[0m) = Two.name\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              Not found: Two\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpke4vg3s9.scala:31:89 --------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        list = list.map(\u001b[36md\u001b[0m => d.toString.replaceFirst(\u001b[31m\"[0123456789]\"\u001b[0m, arr2(d.toInt - \u001b[31m1\u001b[0m))).reverse\n\u001b[31m\u001b[31m   |\u001b[0m               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m               Found:    List[\u001b[1m\u001b[31mString\u001b[0m]\n\u001b[31m   |\u001b[0m               Required: List[\u001b[1m\u001b[32mLong\u001b[0m]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpke4vg3s9.scala:33:12 --------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m            list\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            Found:    (list : List[Long])\n\u001b[31m   |\u001b[0m            Required: List[Strin",
      "stdout": "",
      "timestamp": 1660010519
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n      if (arr.isEmpty) List() else arr.map(_.toString.replaceAll(\"[1-9]+\", \"\")).toList.sorted\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpf6945p_a.scala:20)\n\tat Problem.main(tmpf6945p_a.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660010519
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        arr.foreach(n => if(n >= 1 && n <= 9) arr.insert(arr.indexOf(n), n.toString) else ())\n        arr.reverse\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpb8l_njoa.scala:17:50 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        arr.foreach(\u001b[36mn\u001b[0m => \u001b[33mif\u001b[0m(n >= \u001b[31m1\u001b[0m && n <= \u001b[31m9\u001b[0m) arr.insert(arr.indexOf(n), n.toString) \u001b[33melse\u001b[0m ())\n\u001b[31m\u001b[31m   |\u001b[0m                                              ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m     value insert is not a member of List[Long] - did you mean arr.init?\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpb8l_njoa.scala:18:12 --------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        arr.reverse\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Found:    List[\u001b[1m\u001b[31mLong\u001b[0m]\n\u001b[31m   |\u001b[0m        Required: List[\u001b[1m\u001b[32mString\u001b[0m]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660010519
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        if (arr.isEmpty) List() // empty list\n        else if (arr.head < 1 || arr.head > 9) List(\"\") // empty list\n        else {\n            // sort the list descending by length\n            val sorted = arr.sortBy(_.length)\n            val reversed = sorted.reverse\n            // reverse the sorted list\n            val reversedReversed = reversed.reverse\n            // replace each number by its corresponding name\n            val map = (0 to 9).map(i => (i, reversedReversed.dropRight(i).last)).toMap\n            val result = reversedReversed.map(_ => map.getOrElse(_, \"?\"))\n            result\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp6fetw10u.scala:21:38 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36msorted\u001b[0m = arr.sortBy(_.length)\n\u001b[31m\u001b[31m   |\u001b[0m                                    ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                    value length is not a member of Long\n\u001b[31m\u001b[31m-- Error: /tmp/tmp6fetw10u.scala:21:45 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36msorted\u001b[0m = arr.sortBy(_.length)\n\u001b[31m\u001b[31m   |\u001b[0m                                             ^\u001b[0m\n\u001b[31m   |\u001b[0mambiguous given instances: both \u001b[33mobject\u001b[0m \u001b[35mByte\u001b[0m in \u001b[33mobject\u001b[0m \u001b[35mOrdering\u001b[0m and \u001b[33mobject\u001b[0m \u001b[35mChar\u001b[0m in \u001b[33mobject\u001b[0m \u001b[35mOrdering\u001b[0m match type Ordering[B] of parameter ord of \u001b[33mmethod\u001b[0m \u001b[35msortBy\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mSeqOps\u001b[0m\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660010519
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        if (arr.isEmpty) Nil\n        else {\n            val res = arr.sortWith(_ < _) // sort the list lexicographically\n            val r = new ListBuffer[String]()\n            while (!res.isEmpty) {\n                val i = res.head\n                if (i < 100) r.append(nameFor(i))\n                else r.append(nameFor(i / 10)) // reverse the digit\n                res.remove(0) // remove the sorted number\n            }\n            if (r.isEmpty) Nil\n            else r.reverse.toList.map((_.toString.replaceAll(\"0\", \"One\").replaceAll(\"1\", \"Two\").replaceAll(\"2\", \"Three\").replaceAll(\"3\", \"Four\").replaceAll(\"4\", \"Five\").replaceAll(\"5\", \"Six\").replaceAll(\"6\", \"Seven\").replaceAll(\"7\", \"Eight\").replaceAll(\"8\", \"Nine\").toInt))\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp61tdrb3f.scala:23:38 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m                \u001b[33mif\u001b[0m (i < \u001b[31m100\u001b[0m) r.append(nameFor(i))\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                      Not found: nameFor\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp61tdrb3f.scala:24:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m                \u001b[33melse\u001b[0m r.append(nameFor(i / \u001b[31m10\u001b[0m)) \u001b[34m// reverse the digit\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              Not found: nameFor\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp61tdrb3f.scala:25:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m                res.remove(\u001b[31m0\u001b[0m) \u001b[34m// remove the sorted number\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m   value remove is not a member of List[Long] - did you mean res.reduce?\n\u001b[31m\u001b[31m-- [E081] Type Error: /tmp/tmp61tdrb3f.scala:28:39 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m            \u001b[33melse\u001b[0m r.reverse.toList.map((_.toString.replaceAll(\u001b[31m\"0\"\u001b[0m, \u001b[31m\"One\"\u001b[0m).replaceAll(\u001b[31m\"1\"\u001b[0m, \u001b[31m\"Two\"\u001b[0m).replaceAll(\u001b[31m\"2\"\u001b[0m, \u001b[31m\"Three\"\u001b[0m).replaceAll(\u001b[31m\"3\"\u001b[0m, \u001b[31m\"Four\"\u001b[0m).replaceAll(\u001b[31m\"4\"\u001b[0m, \u001b[31m\"Five\"\u001b[0m).replaceAll(\u001b[31m\"5\"\u001b[0m, \u001b[31m\"Six\"\u001b[0m).replaceAll(\u001b[31m\"6\"\u001b[0m, \u001b[31m\"Seven\"\u001b[0m).replaceAll(\u001b[31m\"7\"\u001b[0m, \u001b[31m\"Eight\"\u001b[0m).replaceAll(\u001b[31m\"8\"\u001b[0m, \u001b[31m\"Nine\"\u001b[0m).toInt))\n\u001b[31m\u001b[31m   |\u001b[0m                                       ^\u001b[0m\n\u001b[31m   |\u001b[0mMissing parameter type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mI could not infer the type of the parameter _$3 of expanded function:\n\u001b[31m   |\u001b[0m_$3 => \n\u001b[31m   |\u001b[0m  _$3.toString.replaceAll(\u001b[32m\"0\"\u001b[0m, \u001b[32m\"One\"\u001b[0m).replaceAll(\u001b[32m\"1\"\u001b[0m, \u001b[32m\"Two\"\u001b[0m).replaceAll(\u001b[32m\"2",
      "stdout": "",
      "timestamp": 1660010519
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        val ints = arr.map(_ div (10).max(0))\n        val nameList = List(\n            List(\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"),\n            List(\"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\")\n        )\n        if (arr.isEmpty)\n            List()\n        else if (ints.length == 1)\n            nameList(0)(0)\n        else if (ints.length == 2)\n            nameList(ints(0))(0)\n        else if (ints.length == 3)\n            nameList(ints(0))(ints(1))\n        else\n            byLength(ints.dropRight(3).reverse.drop(1)).flatMap { x =>\n                if (x.isEmpty) Nil\n                else if (x.length == 1) Nil\n                else {\n                    val z = ints.takeRight(2).reverse.drop(1)\n                    if (z.length == x.length) Nil\n                    else {\n                        val w = ints.takeRight(3).reverse.drop(1)\n                        if (w.length == x.length) Nil\n                        else {\n                            val y = ints.takeRight(4).reverse.drop(1)\n                            if (y.length == x.length) Nil\n                            else {\n                                val x = ints.takeRight(5).reverse.drop(1)\n                                if (x.length == x.length) Nil\n                                else nameList(ints(0))(ints(1))(ints(2))(x)\n                            }\n                        }\n                    }\n                }\n            }\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpriz3zwg9.scala:17:29 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mints\u001b[0m = arr.map(_ div (\u001b[31m10\u001b[0m).max(\u001b[31m0\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                           ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                           value div is not a member of Long\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpriz3zwg9.scala:25:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m            nameList(\u001b[31m0\u001b[0m)(\u001b[31m0\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            Found:    String\n\u001b[31m   |\u001b[0m            Required: \u001b[1m\u001b[32mList\u001b[0m\u001b[1m\u001b[32m[\u001b[0mString\u001b[1m\u001b[32m]\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpriz3zwg9.scala:27:29 --------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m            nameList(ints(\u001b[31m0\u001b[0m))(\u001b[31m0\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            Found:    String\n\u001b[31m   |\u001b[0m            Required: \u001b[1m\u001b[32mList\u001b[0m\u001b[1m\u001b[32m[\u001b[0mString\u001b[1m\u001b[32m]\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpriz3zwg9.scala:29:29 --------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m            nameList(ints(\u001b[31m0\u001b[0m))(ints(\u001b[31m1\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            Found:    String\n\u001b[31m   |\u001b[0m            Required: \u001b[1m\u001b[32mList\u001b[0m\u001b[1m\u001b[32m[\u001b[0mString\u001b[1m\u001b[32m]\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpriz3zwg9.scala:46:63 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m46 |\u001b[0m                                \u001b[33melse\u001b[0m nameList(ints(\u001b[31m0\u001b[0m))(ints(\u001b[31m1\u001b[0m))(ints(\u001b[31m2\u001b[0m))(x)\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           \u001b[33mmethod\u001b[0m \u001b[35mapply\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mStringOps\u001b[0m does not ",
      "stdout": "",
      "timestamp": 1660010519
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n    // reverse the resulting list, and then replace each digit by its corresponding name from\n    // \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    // For example:\n    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    // If the list is empty, return an empty list:\n    // >>> byLength((List[Long]()))\n    // (List[String]())\n    // If the list has any strange number ignore it:\n    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    // (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n        val str = arr.sortWith((a,b) => a < b).toList.map(s => if (s % 10 == 0) \"One\" else \"Two\" if (s % 10 == 1) \"Three\" else \"Four\" if (s % 10 == 2) \"Five\" else \"Six\" if (s % 10 == 3) \"Seven\" else \"Eight\" if (s % 10 == 4) \"Nine\" else \"Unknown\").mkString(\", \")\n        val reverseStr = str.reverse\n        val resultList = reverseStr.grouped(2).map(s => if (s.head < 10) s.head + s.last else s.head - 10).map(n => if (n < 10) \"0\" + n else n.toString)\n        resultList.mkString(\", \")\n    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp0w95_o4_.scala:17:97 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstr\u001b[0m = arr.sortWith((\u001b[36ma\u001b[0m,\u001b[36mb\u001b[0m) => a < b).toList.map(\u001b[36ms\u001b[0m => \u001b[33mif\u001b[0m (s % \u001b[31m10\u001b[0m == \u001b[31m0\u001b[0m) \u001b[31m\"One\"\u001b[0m \u001b[33melse\u001b[0m \u001b[31m\"Two\"\u001b[0m \u001b[33mif\u001b[0m (s % \u001b[31m10\u001b[0m == \u001b[31m1\u001b[0m) \u001b[31m\"Three\"\u001b[0m \u001b[33melse\u001b[0m \u001b[31m\"Four\"\u001b[0m \u001b[33mif\u001b[0m (s % \u001b[31m10\u001b[0m == \u001b[31m2\u001b[0m) \u001b[31m\"Five\"\u001b[0m \u001b[33melse\u001b[0m \u001b[31m\"Six\"\u001b[0m \u001b[33mif\u001b[0m (s % \u001b[31m10\u001b[0m == \u001b[31m3\u001b[0m) \u001b[31m\"Seven\"\u001b[0m \u001b[33melse\u001b[0m \u001b[31m\"Eight\"\u001b[0m \u001b[33mif\u001b[0m (s % \u001b[31m10\u001b[0m == \u001b[31m4\u001b[0m) \u001b[31m\"Nine\"\u001b[0m \u001b[33melse\u001b[0m \u001b[31m\"Unknown\"\u001b[0m).mkString(\u001b[31m\", \"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                                 ^^\u001b[0m\n\u001b[31m   |\u001b[0m                                            ')' expected, but 'if' found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp0w95_o4_.scala:20:27 --------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        resultList.mkString(\u001b[31m\", \"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Found:    String\n\u001b[31m   |\u001b[0m        Required: \u001b[1m\u001b[32mList\u001b[0m\u001b[1m\u001b[32m[\u001b[0mString\u001b[1m\u001b[32m]\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660010519
    }
  ]
}