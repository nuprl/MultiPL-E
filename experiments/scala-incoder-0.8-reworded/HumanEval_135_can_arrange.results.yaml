language: scala
name: HumanEval_135_can_arrange
results:
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        var largest = 0L\n        var maxIndex = -1\n        var\
    \ index = 0\n        for(i <- arr.indices)\n            if(arr(i) != arr(index))\n\
    \                largest = arr(i)\n                maxIndex = i\n            index++\n\
    \        if(maxIndex == -1)\n            largest = -1\n        return largest\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpjw6mkt8x.scala:21:19 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m            index++\n\e[31m\e[31m   |\e[0m          \
    \         ^\e[0m\n\e[31m   |\e[0m                   expression expected but \e\
    [31munindent\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659978767
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        var largest = -1L\n        var largestIndex = 0\n      \
    \  var currIndex = arr.length\n        while (largest == -1) {\n            largest\
    \ = -1L\n            largestIndex = -1L\n            for (i <- currIndex to arr.length)\
    \ {\n                if (arr(i) > largest) {\n                    largest = arr(i)\n\
    \                    largestIndex = i\n                }\n            }\n    \
    \        currIndex -= 1\n        }\n        largestIndex\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong,\
    \ 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpkqqs5p86.scala:19:27\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            largestIndex = -\e\
    [31m1L\e[0m\n\e[31m\e[31m   |\e[0m                           ^^^\e[0m\n\e[31m\
    \   |\e[0m                           Found:    (\e[31m-1L\e[0m : Long)\n\e[31m\
    \   |\e[0m                           Required: Int\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659978770
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n      val result = arr.foldLeft(-1)(lst => lst.indexOf(lst.head)\
    \ + 1)\n      if(result == -1) {\n        result\n      } else {\n        val\
    \ maxIndex = arr.indexWhere(e => e <= result)\n        if (maxIndex == -1)\n \
    \         -1\n        else\n          maxIndex\n      }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong,\
    \ 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E086] Syntax Error: /tmp/tmpo7wkqbsj.scala:14:40 ---------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m      \e[33mval\e[0m \e[36mresult\e[0m = arr.foldLeft(-\e\
    [31m1\e[0m)(\e[36mlst\e[0m => lst.indexOf(lst.head) + \e[31m1\e[0m)\n\e[31m\e\
    [31m   |\e[0m                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                 Wrong number of parameters,\
    \ expected: 2\n1 error found\n"
  stdout: ''
  timestamp: 1659978767
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        var maxIndex = 0\n       \
    \ arr.foreach { element =>\n            if(element > maxIndex){\n            \
    \    maxIndex = element\n            }\n        }\n        if(maxIndex == 0){\n\
    \            return -1\n        }else{\n            return maxIndex\n        }\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpnpgxy6l9.scala:14:18 ---------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659978767
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        var maxIndex : Long = -1\n        var maxElem : Long = -1\n\
    \        var i : Long = 0\n        var prev : Long = -1\n        var cur : Long\
    \ = 0\n        arr.foreach { elem =>\n            if (elem > maxElem) {\n    \
    \            maxElem = elem\n                maxIndex = i\n            }\n   \
    \         if (elem > prev) {\n                prev = elem\n                cur\
    \ = i\n            }\n            i += 1\n        }\n        if (maxElem < 0)\n\
    \            maxIndex\n        else\n            maxIndex - 1\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp2a1bwuvr.scala:37)\n\tat Problem.main(tmp2a1bwuvr.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978771
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        arr.foldLeft[Long](-1, -1)((prev, cur)=> if (cur < prev)\
    \ -1 else cur)\n    }\n    def main(args: Array[String]) = {\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5nho02ps.scala:14:27\
    \ --------------------\e[0m\e[0m\n\e[31m14 |\e[0m        arr.foldLeft[\e[35mLong\e\
    [0m](-\e[31m1\e[0m, -\e[31m1\e[0m)((\e[36mprev\e[0m, \e[36mcur\e[0m)=> \e[33mif\e\
    [0m (cur < prev) -\e[31m1\e[0m \e[33melse\e[0m cur)\n\e[31m\e[31m   |\e[0m   \
    \                        ^^^^^^\e[0m\n\e[31m   |\e[0m                        \
    \   Found:    (Int, Int)\n\e[31m   |\e[0m                           Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659978770
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        arr.find(x => x <= arr(0)).getOrElse(-1l)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpe1gk7um5.scala:17)\n\tat Problem.main(tmpe1gk7um5.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978771
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        var largestIndex = 0l\n        var largestIndexCount = 0\n\
    \        var currentIndex = -1\n        arr.foreach((index) => \n            if\
    \ (index > currentIndex) { \n                largestIndex = index\n          \
    \      largestIndexCount = 1\n            } else { \n                if (index\
    \ == currentIndex) { \n                    largestIndexCount += 1\n          \
    \      } \n            }\n        )\n        if (largestIndexCount > arr.length\
    \ - 1) { \n            largestIndex = -1l \n        }\n        largestIndex\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp0jyunf6a.scala:33)\n\tat Problem.main(tmp0jyunf6a.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978771
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        // Create an empty set for keeping track of which values\
    \ are already seen\n        val seen = collection.mutable.HashSet[Long]()\n  \
    \      arr.zipWithIndex.foreach { case (v, i) =>\n            // If we've seen\
    \ the element before, we're done\n            if (seen.contains(v)) {\n      \
    \          if (i == 0) -1 else arr.length\n            } else {\n            \
    \    // If we've not seen the element before, add to the set\n               \
    \ seen += v\n            }\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong,\
    \ 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpofp2xxhk.scala:16:33\
    \ --------------------\e[0m\e[0m\n\e[31m16 |\e[0m        arr.zipWithIndex.foreach\
    \ { \e[33mcase\e[0m (v, i) =>\n\e[31m\e[31m   |\e[0m        ^\e[0m\n\e[31m   |\e\
    [0m        Found:    Unit\n\e[31m   |\e[0m        Required: Long\n\e[31m17 |\e\
    [0m            \e[34m// If we've seen the element before, we're done\e[0m\n\e\
    [31m18 |\e[0m            \e[33mif\e[0m (seen.contains(v)) {\n\e[31m19 |\e[0m \
    \               \e[33mif\e[0m (i == \e[31m0\e[0m) -\e[31m1\e[0m \e[33melse\e[0m\
    \ arr.length\n\e[31m20 |\e[0m            } \e[33melse\e[0m {\n\e[31m21 |\e[0m\
    \                \e[34m// If we've not seen the element before, add to the set\e\
    [0m\n\e[31m22 |\e[0m                seen += v\n\e[31m23 |\e[0m            }\n\e\
    [31m24 |\e[0m        }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659978770
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        var max : Long = -1\n        arr.foreach{ x =>\n       \
    \     if(x >  max) {\n                max = x\n            }\n        }\n    \
    \    if (max < 0) {\n            max = -1\n        }\n        max\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpiv0bv66e.scala:26)\n\tat Problem.main(tmpiv0bv66e.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978771
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        val res = arr.last\n        for (i <- 0 until arr.length)\
    \ {\n            if (arr(i) > res)\n                return res\n        }\n  \
    \      -1\n    }\n    def main(args: Array[String]) = {\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpxz_8wbbe.scala:22)\n\tat Problem.main(tmpxz_8wbbe.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978771
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.sortWith(_ <= _)\n        val maxIndex = arr.lastOption.orElse(-1)\n\
    \        if(maxIndex == -1) return -1\n        if(maxIndex > arr.lastIndex) canArrange(arr.drop(maxIndex\
    \ - arr.lastIndex))\n        else maxIndex\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong,\
    \ 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp2453g0aj.scala:14:18 ---------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortWith(_\
    \ <= _)\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m      \
    \            Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659978767
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        val res = arr.foldLeft(-1){\n            (max, cur) => max\
    \ match {\n                case -1 => cur\n                case x if x > cur =>\
    \ x\n                case x => cur\n            }\n        }\n        res\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpv93zygfm.scala:16:27\
    \ --------------------\e[0m\e[0m\n\e[31m16 |\e[0m                \e[33mcase\e\
    [0m -\e[31m1\e[0m => cur\n\e[31m\e[31m   |\e[0m                           ^^^\e\
    [0m\n\e[31m   |\e[0m                           Found:    (cur : Long)\n\e[31m\
    \   |\e[0m                           Required: Int\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpv93zygfm.scala:18:26 --------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m                \e[33mcase\e[0m x => cur\n\e[31m\e[31m\
    \   |\e[0m                          ^^^\e[0m\n\e[31m   |\e[0m                \
    \          Found:    (cur : Long)\n\e[31m   |\e[0m                          Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659978771
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        val sortedList = arr.sorted\n        for (i <- 0 until arr.length)\
    \ {\n            if (sortedList(arr.length - i) < arr(i)) {\n                return\
    \ arr(i) + 1\n            }\n        }\n        return -1\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong,\
    \ 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 5\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.canArrange$$anonfun$1(tmpmuwgrw4a.scala:16)\n\tat scala.runtime.java8.JFunction1$mcVI$sp.apply(JFunction1$mcVI$sp.scala:18)\n\
    \tat scala.collection.immutable.Range.foreach(Range.scala:190)\n\tat Problem$.canArrange(tmpmuwgrw4a.scala:19)\n\
    \tat Problem$.main(tmpmuwgrw4a.scala:23)\n\tat Problem.main(tmpmuwgrw4a.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978772
- exit_code: -1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        var i = 0\n        var maxIndex = 0\n        while (i <\
    \ arr.length) {\n            if (arr(i) <= arr(i + 1)) {\n                maxIndex\
    \ = i\n            } else {\n                i += 1\n            }\n        }\n\
    \        if (maxIndex == 0) {\n            -1\n        } else {\n            maxIndex\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1659978775
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n      arr.zipWithIndex.max{ case(a, b) => a <= b }._1 + 1\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmppqsjxaqf.scala:14:44 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m      arr.zipWithIndex.max{ \e[33mcase\e[0m(a, b) =>\
    \ a <= b }._1 + \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m                          \
    \                ^^^^\e[0m\n\e[31m   |\e[0mvalue <= is not a member of (Long,\
    \ Int), but could be made available as an extension method.\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mOne of the following imports might fix the problem:\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m  import math.Ordered.orderingToOrdered\n\e[31m   |\e[0m \
    \ import math.Ordering.Implicits.infixOrderingOps\n\e[31m   |\e[0m\n1 error found\n"
  stdout: ''
  timestamp: 1659978771
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n      val m = new scala.collection.mutable.PriorityQueue[Long]\n\
    \      val p = 0l\n      for(i <- arr.indices) {\n        if(i != p) {\n     \
    \     m.enqueue(arr(i))\n          p = i\n        }\n      }\n      val lastIndex\
    \ = m.lastOption.getOrElse(-1l)\n      lastIndex\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong,\
    \ 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmpv_ypbeqs.scala:19:12 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m          p = i\n\e[31m\e[31m   |\e[0m          ^^^^^\e\
    [0m\n\e[31m   |\e[0m          Reassignment to val p\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659978768
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        var max = -1l\n        var idx = -1l\n        for (i <-\
    \ arr.indices) {\n            if (max < arr(i)) {\n                max = arr(i)\n\
    \                idx = i\n            }\n        }\n        idx\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp9eub25dz.scala:25)\n\tat Problem.main(tmp9eub25dz.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978771
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        if (arr.isEmpty) {\n            return -1\n        }\n \
    \       var index = 0\n        var largest = 0\n        var prev = arr(index)\n\
    \        while (index < arr.length) {\n            if (arr(index) >= prev) {\n\
    \                largest = index\n            }\n            prev = arr(index)\n\
    \            index += 1\n        }\n        if (largest == 0) {\n            largest\
    \ = -1\n        }\n        return largest\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong,\
    \ 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp46i3n4mn.scala:33)\n\tat Problem.main(tmp46i3n4mn.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978771
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        val maxIndex = arr.toList.max\n        var index = -1\n\
    \        var prevMaxIndex = -1\n        for ( i <- 0 until arr.length ) {\n  \
    \          if (arr(i) > maxIndex) {\n                index = i\n             \
    \   prevMaxIndex = maxIndex\n            }\n        }\n        if (index == -1)\
    \ {\n            prevMaxIndex\n        } else {\n            index\n        }\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmps0oc5xit.scala:20:31\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m                prevMaxIndex\
    \ = maxIndex\n\e[31m\e[31m   |\e[0m                               ^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                               Found:    (maxIndex : Long)\n\e\
    [31m   |\e[0m                               Required: Int\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659978770
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n      arr.reverse.dropWhile(_ >= arr.get).lastOption.getOrElse(-1)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpklt0g8hv.scala:14:37 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m      arr.reverse.dropWhile(_ >= arr.get).lastOption.getOrElse(-\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m                                 ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m         value get is not a member of List[Long] - did you mean\
    \ arr.seq?\n1 error found\n"
  stdout: ''
  timestamp: 1659978770
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        arr.zipWithIndex.maxBy(_._1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong,\
    \ 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpwbf2206t.scala:14:8\
    \ ---------------------\e[0m\e[0m\n\e[31m14 |\e[0m        arr.zipWithIndex.maxBy(_._1)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \        Found:    \e[1m\e[31m(\e[0mLong\e[1m\e[31m,\e[0m\e[1m\e[31m \e[0m\e[1m\e\
    [31mInt\e[0m\e[1m\e[31m)\e[0m\n\e[31m   |\e[0m        Required: Long\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659978770
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        var max = -1l\n        var maxIndex = 0\n        var maxElem\
    \ = arr(0)\n        for (i <- 1 until arr.length) {\n            if (maxElem <=\
    \ arr(i)) {\n                maxElem = arr(i)\n                maxIndex = i\n\
    \            }\n        }\n        maxIndex\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong,\
    \ 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpyx5_rgcr.scala:26)\n\tat Problem.main(tmpyx5_rgcr.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978771
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        var maxIndex = -1\n        var currentIndex = 0\n      \
    \  var max = arr(0)\n        // Traverse the list starting from the second element.\n\
    \        for (x <- arr.tail) {\n            if (x > max) {\n                //\
    \ Found an element greater than the current max.\n                // Update maxIndex\
    \ and max and current index.\n                if (currentIndex >= maxIndex) {\n\
    \                    // The current index must be greater than the previous index.\n\
    \                    maxIndex = currentIndex\n                    max = x\n  \
    \              }\n            } else if (x == max) {\n                // Found\
    \ the max element. No other element is greater than it.\n                // Update\
    \ the maxIndex and max.\n                maxIndex = currentIndex + 1\n       \
    \         max = x\n            }\n            currentIndex += 1\n        }\n \
    \       max\n    }\n    def main(args: Array[String]) = {\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp67pcuxf2.scala:38)\n\tat Problem.main(tmp67pcuxf2.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978779
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        var maxIndex = -1L\n        var lastIndex = -1L\n      \
    \  for (i<- arr.indices) {\n            if (arr(i) > arr(lastIndex)) {\n     \
    \           maxIndex = i + 1\n            } else if (arr(i) == arr(lastIndex))\
    \ {\n                lastIndex = i\n            }\n        }\n        maxIndex\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpfc4a6u0d.scala:17:29\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m            \e[33mif\e[0m (arr(i)\
    \ > arr(lastIndex)) {\n\e[31m\e[31m   |\e[0m                             ^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                             Found:    (lastIndex : Long)\n\
    \e[31m   |\e[0m                             Required: Int\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpfc4a6u0d.scala:19:37 --------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m            } \e[33melse\e[0m \e[33mif\e[0m (arr(i) ==\
    \ arr(lastIndex)) {\n\e[31m\e[31m   |\e[0m                                   \
    \  ^^^^^^^^^\e[0m\n\e[31m   |\e[0m                                     Found:\
    \    (lastIndex : Long)\n\e[31m   |\e[0m                                     Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659978778
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        // Code here\n        var largest = -1\n        var maxIndex\
    \ = -1\n        for ( i <- arr.length - 1 ){\n            if( arr(i) > arr(i+1)\
    \ ){\n                largest = i\n                maxIndex = i\n            }\n\
    \        }\n        if( largest < -1 ){ largest = maxIndex}\n        return largest\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpw8nidcqk.scala:17:19 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mfor\e[0m ( i <- arr.length - \e[31m1\e\
    [0m ){\n\e[31m\e[31m   |\e[0m                   ^^^^^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                   value foreach is not a member of Int\n1 error found\n"
  stdout: ''
  timestamp: 1659978778
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        val a = arr.sort\n        var b = a.head\n        var c\
    \ = -1l\n        for(i <- 1 until a.length) {\n            val d = a(i)\n    \
    \        if(d <= b) {\n                c = i\n                break\n        \
    \    }\n            else if(d == b) {\n                b = d\n            }\n\
    \        }\n        c\n    }\n    def main(args: Array[String]) = {\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpemtjc_r_.scala:14:20 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36ma\e[0m = arr.sort\n\e[31m\e\
    [31m   |\e[0m                ^^^^^^^^\e[0m\n\e[31m   |\e[0m     value sort is\
    \ not a member of List[Long] - did you mean arr.sortBy?\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpemtjc_r_.scala:21:16 ------------------------\e[0m\e\
    [0m\n\e[31m21 |\e[0m                break\n\e[31m\e[31m   |\e[0m             \
    \   ^^^^^\e[0m\n\e[31m   |\e[0m                Not found: break\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659978778
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        val pairs = arr.groupBy(_.toLong)\n        pairs.map(_._2.map(arr(_))).max\
    \ match {\n            case Some(pair) => pair(0)\n            case None => -1\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpvsz045lu.scala:15:31\
    \ --------------------\e[0m\e[0m\n\e[31m15 |\e[0m        pairs.map(_._2.map(arr(_))).max\
    \ \e[33mmatch\e[0m {\n\e[31m\e[31m   |\e[0m                               ^\e\
    [0m\n\e[31m   |\e[0m                               Found:    (_$3 : Long)\n\e\
    [31m   |\e[0m                               Required: Int\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E050] Type Error: /tmp/tmpvsz045lu.scala:16:31 -----------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m            \e[33mcase\e[0m Some(pair) => pair(\e[31m0\e\
    [0m)\n\e[31m\e[31m   |\e[0m                               ^^^^\e[0m\n\e[31m  \
    \ |\e[0m                               \e[33mvalue\e[0m \e[35mpair\e[0m does not\
    \ take parameters\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpvsz045lu.scala:17:17\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m            \e[33mcase\e[0m None\
    \ => -\e[31m1\e[0m\n\e[31m\e[31m   |\e[0m                 ^^^^\e[0m\n\e[31m  \
    \ |\e[0m                 Found:    None.type\n\e[31m   |\e[0m                \
    \ Required: List[Long]\n\e[31m   |\e[0m                 pattern type is incompatible\
    \ with expected type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659978779
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        var maxIndex = -1l\n        var maxValue = -1l\n       \
    \ for(i <- 0 until arr.length) {\n            var value : Long = arr(i)\n    \
    \        if (value > maxValue) {\n                maxValue = value\n         \
    \       maxIndex = i\n            }\n        }\n        return maxIndex\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmptae92xld.scala:26)\n\tat Problem.main(tmptae92xld.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978781
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        val res = arr.takeWhile(x => x >= arr(arr.length-1))\n \
    \       res.lastOption.getOrElse(-1)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong,\
    \ 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5t69ryu6.scala:18)\n\tat Problem.main(tmp5t69ryu6.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978781
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        var i = -1\n        var n = arr.size\n        var max =\
    \ -99999999999999999l.toLong\n        while(i < n) {\n          max = Math.max(max,\
    \ arr(i))\n          if (arr(i) <= max)\n            i += 1\n          else\n\
    \            i -= 1\n        }\n        max - 1\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong,\
    \ 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: -1\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:115)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.canArrange(tmpu1rk4c5h.scala:18)\n\tat Problem$.main(tmpu1rk4c5h.scala:27)\n\
    \tat Problem.main(tmpu1rk4c5h.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978781
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        val largestIndex = -1\n        val largestValue = arr(0)\n\
    \n        for (i <- arr.indices) {\n            if (arr(i) < largestValue) {\n\
    \                largestValue = arr(i)\n                largestIndex = i\n   \
    \         }\n        }\n\n        largestIndex\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong,\
    \ 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmpt9ma5qgj.scala:19:29 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m                largestValue = arr(i)\n\e[31m\e[31m \
    \  |\e[0m                ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m         \
    \       Reassignment to val largestValue\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E052]\
    \ Type Error: /tmp/tmpt9ma5qgj.scala:20:29 -----------------------------\e[0m\e\
    [0m\n\e[31m20 |\e[0m                largestIndex = i\n\e[31m\e[31m   |\e[0m  \
    \              ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                Reassignment\
    \ to val largestIndex\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659978778
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        // Your code here\n        val maxIndex = arr(arr.length-1)\n\
    \        val maxIndex = arr.indexOfMax(elem => elem < maxIndex)\n        if(maxIndex\
    \ == -1) -1\n        else arr.indexOf(maxIndex)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong,\
    \ 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpzdhly84j.scala:16:12 ---------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mmaxIndex\e[0m = arr.indexOfMax(\e\
    [36melem\e[0m => elem < maxIndex)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxIndex is already defined as \e[33mvalue\e[0m \e[35mmaxIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n1 error found\n"
  stdout: ''
  timestamp: 1659978777
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        var maxIndex = -1\n        var maxVal = -1\n        for\
    \ (i <- 0 until arr.length) {\n            if (arr(i) > maxVal) {\n          \
    \      maxVal = arr(i)\n                maxIndex = i\n            }\n        }\n\
    \        return maxIndex\n    }\n    def main(args: Array[String]) = {\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpm7cyup0g.scala:18:28\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m                maxVal = arr(i)\n\
    \e[31m\e[31m   |\e[0m                         ^^^^^^\e[0m\n\e[31m   |\e[0m   \
    \                      Found:    Long\n\e[31m   |\e[0m                       \
    \  Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659978780
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        val maxIndex = arr.zipWithIndex.maxBy(_._1)._2\n       \
    \ arr.lastIndexWhere(_ < maxIndex)\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong,\
    \ 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp6mfd5rci.scala:19)\n\tat Problem.main(tmp6mfd5rci.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978782
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        if (arr.isEmpty) -1\n        else {\n            val m =\
    \ arr.head\n            val l = arr.tail.sortBy(x => x - m).last\n           \
    \ val i = arr.indexWhere(x => x != l && x > l) + 1\n            if (i < 0) -1\n\
    \            else i\n        }\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(canArrange((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong,\
    \ 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp01exaz0c.scala:24)\n\tat Problem.main(tmp01exaz0c.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978782
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        // Code goes here\n        val m = new mutable.HashMap[Long,\
    \ Int]()\n        for(x <- arr){\n            if(m.containsKey(x))\n         \
    \       m.put(x, m.get(x) + 1)\n            else\n                m.put(x, 1)\n\
    \        }\n        var result = -1\n        for(x <- m.keys){\n            if(m.get(x)\
    \ > 1)\n                result = x\n        }\n        result\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmplp95ujfb.scala:15:20 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mm\e[0m = \e[33mnew\e[0m\
    \ mutable.HashMap[\e[35mLong\e[0m, \e[35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                  ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659978779
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        val a = arr.toList\n        val sorted = a.sortBy(x => x)\
    \ // sort by value\n        val start = -1\n        for (i<- 0 until sorted.length)\n\
    \            if (sorted[i-1] < sorted[i])\n                start = i\n       \
    \ val largest = sorted.lastOption\n        largest.getOrElse(-1l) // -1 if no\
    \ such element exists\n    }\n    def main(args: Array[String]) = {\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpy5klzg46.scala:18:24 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m            \e[33mif\e[0m (sorted[\e[35mi-\e[31m1\e[0m]\
    \ < sorted[\e[35mi\e[0m])\n\e[31m\e[31m   |\e[0m                        ^\e[0m\n\
    \e[31m   |\e[0m                        Not found: type -\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E052] Type Error: /tmp/tmpy5klzg46.scala:19:22 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m                start = i\n\e[31m\e[31m   |\e[0m    \
    \            ^^^^^^^^^\e[0m\n\e[31m   |\e[0m                Reassignment to val\
    \ start\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659978779
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        val n = arr.size\n        var maxIndex : Long = -1L\n  \
    \      var currentIndex : Long = 0\n        while (currentIndex < n) {\n     \
    \       if (arr[currentIndex] < arr[currentIndex - 1]) {\n                // The\
    \ current element is less than the previous one.\n                // So current\
    \ element is larger than previous one\n                // and current index is\
    \ the index to which we have to shift to\n                // find next element\
    \ greater than or equal to the current one.\n                maxIndex = currentIndex\n\
    \            } else {\n                // The current element is greater than\
    \ the previous one\n                // So current element is the last element\n\
    \                // We are done with traversing the list.\n                currentIndex\
    \ = maxIndex\n                break\n            }\n            currentIndex +=\
    \ 1\n        }\n        maxIndex\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(canArrange((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong,\
    \ 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmptas57anl.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m            \e[33mif\e[0m (arr[\e[35mcurrentIndex\e[0m]\
    \ < arr[\e[35mcurrentIndex\e[0m \e[35m-\e[0m \e[31m1\e[0m]) {\n\e[31m\e[31m  \
    \ |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m               \
    \     Not found: type currentIndex\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmptas57anl.scala:29:16 ------------------------\e[0m\e[0m\n\e[31m29 |\e\
    [0m                break\n\e[31m\e[31m   |\e[0m                ^^^^^\e[0m\n\e\
    [31m   |\e[0m                Not found: break\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659978779
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        if (arr.isEmpty) -1\n        else arr.takeWhile(_ < arr.last).max\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpu1k6u27m.scala:18)\n\tat Problem.main(tmpu1k6u27m.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978783
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        var maxIndex = 0L\n        for (i<-arr) {\n            if\
    \ (i >= arr(maxIndex)) {\n                maxIndex = i\n            }\n      \
    \  }\n        if (maxIndex == 0L) {\n            maxIndex = -1L\n        }\n \
    \       maxIndex\n    }\n    def main(args: Array[String]) = {\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpwuf_1oyu.scala:16:25\
    \ --------------------\e[0m\e[0m\n\e[31m16 |\e[0m            \e[33mif\e[0m (i\
    \ >= arr(maxIndex)) {\n\e[31m\e[31m   |\e[0m                         ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                         Found:    (maxIndex : Long)\n\e[31m\
    \   |\e[0m                         Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659978781
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        var index = -1\n        var maxIndex = -1\n        for (\
    \ i <- 0 until arr.length ) {\n            if ( i == 0 ) {\n                if\
    \ ( arr(i) <= arr(i+1) )\n                    index = i\n            }\n     \
    \       else {\n                if ( arr(i) <= arr(i-1) )\n                  \
    \  index = i\n            }\n            if ( index > -1 ) {\n               \
    \ if ( arr(i) > arr(maxIndex) )\n                    maxIndex = index\n      \
    \      }\n        }\n        return maxIndex\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong,\
    \ 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: -1\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:115)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.canArrange$$anonfun$1(tmpf3zvb11e.scala:26)\n\tat scala.runtime.java8.JFunction1$mcVI$sp.apply(JFunction1$mcVI$sp.scala:18)\n\
    \tat scala.collection.immutable.Range.foreach(Range.scala:190)\n\tat Problem$.canArrange(tmpf3zvb11e.scala:29)\n\
    \tat Problem$.main(tmpf3zvb11e.scala:33)\n\tat Problem.main(tmpf3zvb11e.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978783
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        val result = arr.foldLeft[Long](-1l) { (result, el) => if\
    \ (el >= result) el else result }\n        if (result > -1l) result else -1l\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp92ktidn_.scala:18)\n\tat Problem.main(tmp92ktidn_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978782
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        // Only return -1 if there are no elements or no duplicates\n\
    \        if(arr.isEmpty){\n            return -1\n        }\n        val map =\
    \ new collection.mutable.HashMap[(Long, Long), Int]()\n        // Build the map\
    \ of numbers and their indexes for O(n) time complexity\n        var i = 0\n \
    \       for(num <- arr){\n            val oldIndex = map.getOrElse((num, i), 1)\n\
    \            i += 1\n            val newIndex = oldIndex + 1\n            map.put((num,\
    \ newIndex), oldIndex)\n        }\n        // Iterate through the map and find\
    \ the element which has a lower index\n        var maxIndex = -1\n        for((num,\
    \ index) <- map.toList){\n            if(index < maxIndex){\n                //\
    \ Found a higher value so return the current index\n                maxIndex =\
    \ index\n            }\n        }\n        return maxIndex\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong,\
    \ 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp0tizzzf8.scala:38)\n\tat Problem.main(tmp0tizzzf8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978783
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        val res = arr.foldLeft((-1l, -1)) { (acc, elem)\n      \
    \         (if (elem > acc._1) (elem, acc._2) else (acc._1, elem))\n          \
    \ }\n        res._1\n    }\n    def main(args: Array[String]) = {\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp1h4c97s1.scala:14:45 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mres\e[0m = arr.foldLeft((-\e\
    [31m1l\e[0m, -\e[31m1\e[0m)) { (acc, elem)\n\e[31m\e[31m   |\e[0m            \
    \                                 ^^^\e[0m\n\e[31m   |\e[0m                  \
    \                           Not found: acc\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmp1h4c97s1.scala:14:50 ------------------------\e[0m\e\
    [0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mres\e[0m = arr.foldLeft((-\e\
    [31m1l\e[0m, -\e[31m1\e[0m)) { (acc, elem)\n\e[31m\e[31m   |\e[0m            \
    \                                      ^^^^\e[0m\n\e[31m   |\e[0m            \
    \                                      Not found: elem\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp1h4c97s1.scala:15:20 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m               (\e[33mif\e[0m (elem > acc._1) (elem,\
    \ acc._2) \e[33melse\e[0m (acc._1, elem))\n\e[31m\e[31m   |\e[0m             \
    \       ^^^^\e[0m\n\e[31m   |\e[0m                    Not found: elem\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp1h4c97s1.scala:15:36 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m               (\e[33mif\e[0m (elem > acc._1) (elem,\
    \ acc._2) \e[33melse\e[0m (acc._1, elem))\n\e[31m\e[31m   |\e[0m             \
    \                       ^^^^\e[0m\n\e[31m   |\e[0m                           \
    \         Not found: elem\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp1h4c97s1.scala:15:42 ------------------------\e[0m\e[0m\n\e[31m15 |\e\
    [0m               (\e[33mif\e[0m (elem > acc._1) (elem, acc._2) \e[33melse\e[0m\
    \ (acc._1, elem))\n\e[31m\e[31m   |\e[0m                                     \
    \     ^^^\e[0m\n\e[31m   |\e[0m                                          Not found:\
    \ acc\n\e[31m   |\e[0m\n\e[31m   |"
  stdout: ''
  timestamp: 1659978780
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        var maxIndex = -1L\n        var index = -1L\n        for\
    \ (x <- arr) {\n            index += 1\n            if (maxIndex < x) {\n    \
    \            maxIndex = index\n            }\n            if (x != arr(index-1))\
    \ {\n                maxIndex = -1L\n                index = -1L\n           \
    \ }\n        }\n        if (maxIndex == -1L) {\n            return -1L\n     \
    \   }\n        return maxIndex\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(canArrange((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong,\
    \ 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmptbqvn8or.scala:21:25\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m            \e[33mif\e[0m (x\
    \ != arr(index-\e[31m1\e[0m)) {\n\e[31m\e[31m   |\e[0m                       \
    \  ^^^^^^^\e[0m\n\e[31m   |\e[0m                         Found:    Long\n\e[31m\
    \   |\e[0m                         Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659978786
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        var max = -1L\n        var maxIndex = 0\n\n        for (i\
    \ <- 0 until arr.length) {\n            if (arr(i) > max) {\n                max\
    \ = arr(i)\n                maxIndex = i\n            }\n        }\n        maxIndex\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpwiezi54k.scala:26)\n\tat Problem.main(tmpwiezi54k.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978789
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        var maxIndex = 0\n        for (i <- arr.indices) {\n   \
    \         if (arr(i) < arr(i + 1)) {\n                maxIndex = i\n         \
    \   }\n        }\n        if (maxIndex == arr.size - 1) {\n            -1\n  \
    \      } else {\n            maxIndex\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong,\
    \ 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 5\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.canArrange$$anonfun$1(tmpjc3151zl.scala:16)\n\tat scala.runtime.java8.JFunction1$mcVI$sp.apply(JFunction1$mcVI$sp.scala:18)\n\
    \tat scala.collection.immutable.Range.foreach(Range.scala:190)\n\tat Problem$.canArrange(tmpjc3151zl.scala:19)\n\
    \tat Problem$.main(tmpjc3151zl.scala:27)\n\tat Problem.main(tmpjc3151zl.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978789
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.sortBy(_.toLong).reverse\n        val i =\
    \ arr.toList\n        val j = i.toList\n        var max = 0L\n        var ans\
    \ = -1L\n        while (j < i.length) {\n            val last = i(j)\n       \
    \     if (j != 0 && (last <= j)) {\n                if (last > j + 1) {\n    \
    \                max = j\n                }\n                j += 2\n        \
    \    } else {\n                max += 1\n                j -= 1\n            }\n\
    \            if (ans == -1) {\n                ans = max\n            } else {\n\
    \                if (max > ans) {\n                    ans = max\n           \
    \     }\n            }\n        }\n        ans\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong,\
    \ 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpjg7l1zi_.scala:14:18 ---------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(_.toLong).reverse\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659978785
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        // O(N^2) -- use a mutable list to avoid duplicates\n  \
    \      val m = mutable.ListBuffer[Long]()\n        var maxIndex = -1\n       \
    \ for (i <- 0 until arr.length) {\n            if (i != 0 && arr(i) > arr(i-1))\
    \ {\n                m.clear()\n                m += arr(i)\n                m.sortWith(_\
    \ < _)\n                maxIndex += m.last\n            } else {\n           \
    \     maxIndex += 1\n            }\n        }\n        maxIndex\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpakn6p1ij.scala:15:16 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mm\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                ^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659978785
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        arr.foldRight(-1l)((acc, cur) => if (acc >= cur) acc else\
    \ cur)\n    }\n    def main(args: Array[String]) = {\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpflwtivyj.scala:17)\n\tat Problem.main(tmpflwtivyj.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978789
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        var largest = arr.head\n        for (x <- arr) {\n     \
    \       if (x < largest + 1) {\n                largest = x\n            }\n \
    \       }\n        largest\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(canArrange((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\
    \ == (3l));\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong, 4l.toLong,\
    \ 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong, 4l.toLong,\
    \ 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong, 10l.toLong)))\
    \ == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong, 5l.toLong,\
    \ 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]())) ==\
    \ (-1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp60pelre6.scala:23)\n\tat Problem.main(tmp60pelre6.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978790
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        var i = 0\n        arr.foreach{ x =>\n            if (x\
    \ > arr(i)) i = i + 1\n        }\n        if (arr.length == i+1) -1 else i\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpcz3v0ulv.scala:23)\n\tat Problem.main(tmpcz3v0ulv.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978790
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        // Write your code here\n        var maxIndex = -1\n   \
    \     var minIndex = -1\n\n        val numOfElements = arr.length\n        val\
    \ numOfValuesBefore = arr.takeWhile(_ <= 0).length\n        for (i <- 0 until\
    \ numOfElements) {\n            if (arr(i) <= 0) {\n                maxIndex =\
    \ i\n            } else {\n                val index = i - numOfValuesBefore\n\
    \                if (maxIndex < 0 || index < maxIndex) {\n                   \
    \ maxIndex = index\n                }\n                val indexAfter = index\
    \ + 1\n                if (indexAfter < numOfElements && arr(indexAfter) > 0)\
    \ {\n                    minIndex = indexAfter\n                }\n          \
    \  }\n        }\n        if (maxIndex < 0 || maxIndex < minIndex) {\n        \
    \    return -1\n        }\n        return maxIndex\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong,\
    \ 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmppjxc90ga.scala:40)\n\tat Problem.main(tmppjxc90ga.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978791
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        var maxIdx = 0\n        var maxVal = -1L\n        for(i\
    \ <- 0 until arr.length) {\n            if (arr(i) < arr(i + 1)) {\n         \
    \       if (maxVal < arr(i)) {\n                    maxIdx = i\n             \
    \       maxVal = arr(i)\n                }\n            }\n        }\n       \
    \ if (maxIdx < 0) maxIdx = -1\n        return maxIdx\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong,\
    \ 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 5\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.canArrange$$anonfun$1(tmpzd4z96cs.scala:17)\n\tat scala.runtime.java8.JFunction1$mcVI$sp.apply(JFunction1$mcVI$sp.scala:18)\n\
    \tat scala.collection.immutable.Range.foreach(Range.scala:190)\n\tat Problem$.canArrange(tmpzd4z96cs.scala:23)\n\
    \tat Problem$.main(tmpzd4z96cs.scala:28)\n\tat Problem.main(tmpzd4z96cs.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978791
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        val l1 = arr.lastOption\n        l1.map { x => if(x >= arr.last)\
    \ -1 else arr.lastIndexOf(x) + 1 }.getOrElse(-1l)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong,\
    \ 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp00j29so9.scala:15:82\
    \ --------------------\e[0m\e[0m\n\e[31m15 |\e[0m        l1.map { \e[36mx\e[0m\
    \ => \e[33mif\e[0m(x >= arr.last) -\e[31m1\e[0m \e[33melse\e[0m arr.lastIndexOf(x)\
    \ + \e[31m1\e[0m }.getOrElse(-\e[31m1l\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    AnyVal\n\e[31m   |\e[0m        Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659978789
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        var index = 0\n        var max = 0\n        for (i <- arr.indices)\
    \ {\n            if (arr(i) > arr(index)) {\n                max = i\n       \
    \     } else {\n                if (i == 0) {\n                    index = i\n\
    \                } else {\n                    if (arr(i) < arr(index)) {\n  \
    \                      index = i\n                    }\n                }\n \
    \           }\n        }\n        index\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong,\
    \ 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpk_0tv8d7.scala:32)\n\tat Problem.main(tmpk_0tv8d7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978792
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        var maxElem : Long = arr.head\n        var currentIndex\
    \ = 0\n\n        for (elem <- arr) {\n            val index = currentIndex\n\n\
    \            while (currentIndex >= currentIndex && elem >= arr[currentIndex])\
    \ {\n                currentIndex += 1\n            }\n\n            maxElem =\
    \ elem if (currentIndex == index)\n        }\n\n        if (maxElem == arr.head)\
    \ -1 else maxElem\n    }\n    def main(args: Array[String]) = {\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp2dum6r1t.scala:24:27 -----------------------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m            maxElem = elem \e[33mif\e[0m (currentIndex\
    \ == index)\n\e[31m\e[31m   |\e[0m                           ^^\e[0m\n\e[31m \
    \  |\e[0m                           end of statement expected but 'if' found\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp2dum6r1t.scala:20:63 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m            \e[33mwhile\e[0m (currentIndex >= currentIndex\
    \ && elem >= arr[\e[35mcurrentIndex\e[0m]) {\n\e[31m\e[31m   |\e[0m          \
    \                                                     ^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                                            Not found: type currentIndex\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659978788
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        val n = arr.size\n        val max = -999999999l\n      \
    \  var index = 0l\n        var maxIndex = 0l\n\n        for ((x, _) <- arr.zipWithIndex\
    \ if x < max) {\n            if (index >= maxIndex) {\n                maxIndex\
    \ = index\n                max = x\n            }\n            index = x + 1\n\
    \        }\n        -1l\n    }\n    def main(args: Array[String]) = {\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmpjyohq7hd.scala:22:20 -----------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m                max = x\n\e[31m\e[31m   |\e[0m      \
    \          ^^^^^^^\e[0m\n\e[31m   |\e[0m                Reassignment to val max\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659978787
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        var largest = -1 // Initialize largest index to -1\n   \
    \     var largestIndex = 0 // Initialize largest index to -1\n        arr.foreach(\n\
    \            i => {\n                if(i<=largest)\n                    largestIndex\
    \ = arr.indexOf(i)\n                else\n                    largest = i\n  \
    \          }\n        )\n        largestIndex\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong,\
    \ 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp9jrudf1v.scala:21:30\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m                    largest =\
    \ i\n\e[31m\e[31m   |\e[0m                              ^\e[0m\n\e[31m   |\e[0m\
    \                              Found:    (i : Long)\n\e[31m   |\e[0m         \
    \                     Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659978791
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        val pair = arr.foldLeft((Long.MaxValue, -1)){case ((a,b),\
    \ c) =>\n            if (a >= c) (a,b) else (b,a)\n        }\n        pair._2\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpe75pt10d.scala:15:38\
    \ --------------------\e[0m\e[0m\n\e[31m15 |\e[0m            \e[33mif\e[0m (a\
    \ >= c) (a,b) \e[33melse\e[0m (b,a)\n\e[31m\e[31m   |\e[0m                   \
    \                   ^\e[0m\n\e[31m   |\e[0m                                  \
    \    Found:    (a : Long)\n\e[31m   |\e[0m                                   \
    \   Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659978791
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        if(arr.isEmpty) -1\n        else if(arr.tail.forall(a =>\
    \ a <= arr.head)) arr.size - 1\n        else -1\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong,\
    \ 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpva12fbcu.scala:19)\n\tat Problem.main(tmpva12fbcu.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978792
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        // Sort ascending\n        arr.sortWith(_ < _)\n       \
    \ val max = arr(0)\n        val res = -1L\n        for(i <- 1 to arr.length) {\n\
    \            if (arr(i) <= max)\n                max = arr(i)\n            else\
    \ {\n                res = i\n                break\n            }\n        }\n\
    \        res\n    }\n    def main(args: Array[String]) = {\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmpkolvt5wt.scala:20:20 -----------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m                max = arr(i)\n\e[31m\e[31m   |\e[0m \
    \               ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                Reassignment\
    \ to val max\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmpkolvt5wt.scala:22:20\
    \ -----------------------------\e[0m\e[0m\n\e[31m22 |\e[0m                res\
    \ = i\n\e[31m\e[31m   |\e[0m                ^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \            Reassignment to val res\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpkolvt5wt.scala:23:16 ------------------------\e[0m\e\
    [0m\n\e[31m23 |\e[0m                break\n\e[31m\e[31m   |\e[0m             \
    \   ^^^^^\e[0m\n\e[31m   |\e[0m                Not found: break\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1659978790
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        var largest = -1\n        var curr = -1\n        arr.zipWithIndex.foreach{\n\
    \            case (v, i) => {\n                if (v > largest && i != curr )\
    \ {\n                    largest = v\n                    curr = i\n         \
    \       }\n            }\n        }\n        if (largest < 0) {\n            largest\
    \ = -1\n        }\n        return largest\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong,\
    \ 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmprj6aj6hc.scala:19:30\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m                    largest =\
    \ v\n\e[31m\e[31m   |\e[0m                              ^\e[0m\n\e[31m   |\e[0m\
    \                              Found:    (v : Long)\n\e[31m   |\e[0m         \
    \                     Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659978791
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        var highest = 0\n        for (x <- arr) {\n            if\
    \ (x > arr(highest)) highest = x;\n        }\n        if (highest < 0) return\
    \ -1\n        return highest\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(canArrange((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong,\
    \ 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpngroexms.scala:16:44\
    \ --------------------\e[0m\e[0m\n\e[31m16 |\e[0m            \e[33mif\e[0m (x\
    \ > arr(highest)) highest = x;\n\e[31m\e[31m   |\e[0m                        \
    \                    ^\e[0m\n\e[31m   |\e[0m                                 \
    \           Found:    (x : Long)\n\e[31m   |\e[0m                            \
    \                Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659978792
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        val ans = arr.foldLeft[Long](-1l) {\n            (i, e)\
    \ => if (e > i) return e else i\n        }\n        ans.toLong\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpd0d79d23.scala:20)\n\tat Problem.main(tmpd0d79d23.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978794
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        var largest = -1\n        var index = 0\n        for (e\
    \ <- arr) {\n            if (largest < 0 && e >= arr(index)) {\n             \
    \   largest = index\n            } else {\n                index++\n         \
    \   }\n        }\n        return largest\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong,\
    \ 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp_ypqds5a.scala:20:23 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m                index++\n\e[31m\e[31m   |\e[0m      \
    \                 ^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659978790
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        val m = arr.indexOf(0)\n        if(m == arr.length - 1)\
    \ -1\n        else {\n            val left = arr span (_ < m(0))\n           \
    \ val right = arr span (_ < m)\n            if(left.length > 0) canArrange(left)\
    \ else if (right.length > 0) canArrange(right) else -1\n        }\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E050] Type Error: /tmp/tmp7te8gglx.scala:17:37 -----------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m            \e[33mval\e[0m \e[36mleft\e[0m = arr span\
    \ (_ < m(\e[31m0\e[0m))\n\e[31m\e[31m   |\e[0m                               \
    \      ^\e[0m\n\e[31m   |\e[0m                                     \e[33mvalue\e\
    [0m \e[35mm\e[0m does not take parameters\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp7te8gglx.scala:19:20 ------------------------\e[0m\e\
    [0m\n\e[31m19 |\e[0m            \e[33mif\e[0m(left.length > \e[31m0\e[0m) canArrange(left)\
    \ \e[33melse\e[0m \e[33mif\e[0m (right.length > \e[31m0\e[0m) canArrange(right)\
    \ \e[33melse\e[0m -\e[31m1\e[0m\n\e[31m\e[31m   |\e[0m               ^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m               value length is not a member of (List[Long],\
    \ List[Long])\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp7te8gglx.scala:19:43\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            \e[33mif\e[0m(left.length\
    \ > \e[31m0\e[0m) canArrange(left) \e[33melse\e[0m \e[33mif\e[0m (right.length\
    \ > \e[31m0\e[0m) canArrange(right) \e[33melse\e[0m -\e[31m1\e[0m\n\e[31m\e[31m\
    \   |\e[0m                                           ^^^^\e[0m\n\e[31m   |\e[0m\
    \                             Found:    (left : (List[Long], List[Long]))\n\e\
    [31m   |\e[0m                             Required: List[Long]\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmp7te8gglx.scala:19:64 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m            \e[33mif\e[0m(left.length > \e[31m0\e[0m)\
    \ canArrange(left) \e[33melse\e[0m \e[33mif\e[0m (right.length > \e[31m0\e[0m)\
    \ canArrange(right) \e[33melse\e[0m -\e[31m1\e[0m\n\e[31m\e[31m   |\e[0m     \
    \                                                     ^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                value length is not a member of (List[Long], List[Long])\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp7te8gglx.scala:19:87 --------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m            \e[33mif\e[0m(left.length > \e[31m0\e[0m)\
    \ can"
  stdout: ''
  timestamp: 1659978794
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        var i = arr.length-1\n        var candidate = 0\n      \
    \  while (i >= 0 && candidate == 0) {\n            if (arr(i) <= arr(i-1)) {\n\
    \                candidate = i\n            }\n            i -= 1\n        }\n\
    \        if (candidate == 0) {\n            return -1\n        }\n        return\
    \ candidate\n    }\n    def main(args: Array[String]) = {\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: -1\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:115)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.canArrange(tmpkp9hmccy.scala:17)\n\tat Problem$.main(tmpkp9hmccy.scala:29)\n\
    \tat Problem.main(tmpkp9hmccy.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978797
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        if (arr.isEmpty) {\n            -1\n        }\n        var\
    \ maxIndex = -1\n        var i = 0\n        var j = arr.length - 1\n        while\
    \ (i < j) {\n            if (arr(i) <= arr(j)) {\n                i += 1\n   \
    \         }\n            else {\n                j -= 1\n            }\n     \
    \       if (maxIndex < 0 || maxIndex >= arr(i)) {\n                maxIndex =\
    \ arr(i)\n            }\n        }\n        maxIndex\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong,\
    \ 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpgoeqp6za.scala:28:30\
    \ --------------------\e[0m\e[0m\n\e[31m28 |\e[0m                maxIndex = arr(i)\n\
    \e[31m\e[31m   |\e[0m                           ^^^^^^\e[0m\n\e[31m   |\e[0m \
    \                          Found:    Long\n\e[31m   |\e[0m                   \
    \        Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[33m\e[33m-- [E129] Potential Issue Warning:\
    \ /tmp/tmpgoeqp6za.scala:15:12 ----------------\e[0m\e[0m\n\e[33m15 |\e[0m   \
    \         -\e[31m1\e[0m\n\e[33m\e[33m   |\e[0m            ^^\e[0m\n\e[33m   |\e\
    [0mA pure expression does nothing in statement position; you may be omitting necessary\
    \ parentheses\n\e[33m   |\e[0m\n\e[33m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 warning found\n1 error found\n"
  stdout: ''
  timestamp: 1659978795
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        val res = arr.foldLeft[(Long, Long), Long](-1, -1)((e, i)\
    \ =>\n            if (e <= i)\n                (i, e)\n            else\n    \
    \            (e, -1)\n        )\n        if (res._2 >= 0)\n            res._1\n\
    \        else\n            -1\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(canArrange((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong,\
    \ 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E023] Syntax Error: /tmp/tmpf5aunewv.scala:14:30 ---------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mres\e[0m = arr.foldLeft[(\e\
    [35mLong\e[0m, \e[35mLong\e[0m), \e[35mLong\e[0m](-\e[31m1\e[0m, -\e[31m1\e[0m)((\e\
    [36me\e[0m, \e[36mi\e[0m) =>\n\e[31m\e[31m   |\e[0m                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m   Too many type arguments for scala.collection.LinearSeqOps.foldLeft[B]\n\
    \e[31m   |\e[0m   expected: [B]\n\e[31m   |\e[0m   actual:   [\e[35mTuple2\e[0m[\e\
    [35mLong\e[0m, \e[35mLong\e[0m], \e[35mLong\e[0m]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659978794
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        var max = 0l\n        var i = 0l\n        for (ele <- arr)\
    \ {\n            if (i >= max) {\n                if (ele >= arr(i - 1)) max =\
    \ i\n            }\n            i += 1\n        }\n        if (max == -1l) {\n\
    \            return -1l\n        }\n        return max\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong,\
    \ 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpjr1n4dob.scala:18:31\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m                \e[33mif\e[0m\
    \ (ele >= arr(i - \e[31m1\e[0m)) max = i\n\e[31m\e[31m   |\e[0m              \
    \                 ^^^^^\e[0m\n\e[31m   |\e[0m                               Found:\
    \    Long\n\e[31m   |\e[0m                               Required: Int\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659978798
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        var maxIndex = 0\n        var maxVal = arr(0)\n\n      \
    \  for (i<- 0 until arr.length) {\n            if (arr(i) > maxVal) {\n      \
    \          maxVal = arr(i)\n                maxIndex = i\n            }\n    \
    \    }\n\n        if (maxIndex == arr.length-1) {\n            -1\n        } else\
    \ {\n            maxIndex\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong,\
    \ 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp07ap0tyn.scala:31)\n\tat Problem.main(tmp07ap0tyn.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978800
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        // Your code goes here\n        val maxValue = arr.last\n\
    \        val maxIndex = 0\n        for(i <- 0 until arr.length) {\n          \
    \  val value = arr(i)\n            if(value > maxValue) {\n                maxIndex\
    \ = i\n                maxValue = value\n            }\n        }\n        if(maxIndex\
    \ > 0) {\n            maxIndex\n        } else {\n            -1\n        }\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmp6l7s2dzj.scala:20:25 -----------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m                maxIndex = i\n\e[31m\e[31m   |\e[0m \
    \               ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                Reassignment\
    \ to val maxIndex\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmp6l7s2dzj.scala:21:25\
    \ -----------------------------\e[0m\e[0m\n\e[31m21 |\e[0m                maxValue\
    \ = value\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                Reassignment to val maxValue\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659978797
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        var max = -1L\n        var maxIndex = -1L\n        for (x\
    \ <- arr) {\n            if (x > max) {\n                max = x\n           \
    \     maxIndex = arr.indexOf(x)\n            }\n        }\n        maxIndex\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpsahzkvo6.scala:25)\n\tat Problem.main(tmpsahzkvo6.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978801
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        if(arr.isEmpty) -1\n        else {\n            // Find\
    \ the largest number that is not greater than arr(0)\n            var largest\
    \ = -1\n            for(i <- 0 until arr.length) {\n                if(largest\
    \ < arr(i) && arr(i) >= arr(i-1)) largest = i\n            }\n            largest\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: -1\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:115)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.canArrange$$anonfun$1(tmpvzkjc72f.scala:19)\n\tat scala.runtime.java8.JFunction1$mcVI$sp.apply(JFunction1$mcVI$sp.scala:18)\n\
    \tat scala.collection.immutable.Range.foreach(Range.scala:190)\n\tat Problem$.canArrange(tmpvzkjc72f.scala:20)\n\
    \tat Problem$.main(tmpvzkjc72f.scala:25)\n\tat Problem.main(tmpvzkjc72f.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978801
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        var maxIndex = -1l\n        for (elem <- arr) {\n      \
    \      if(elem <= arr(maxIndex)) {\n                maxIndex = -1\n          \
    \  } else {\n                maxIndex += 1\n            }\n        }\n       \
    \ maxIndex\n    }\n    def main(args: Array[String]) = {\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp63udg6_m.scala:16:27\
    \ --------------------\e[0m\e[0m\n\e[31m16 |\e[0m            \e[33mif\e[0m(elem\
    \ <= arr(maxIndex)) {\n\e[31m\e[31m   |\e[0m                           ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                           Found:    (maxIndex : Long)\n\e\
    [31m   |\e[0m                           Required: Int\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659978799
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        var max = -1L\n        var max = -1L\n        val max =\
    \ -1\n        val arr = arr.toSeq\n        arr match {\n            case Nil =>\
    \ -1\n            case head :: tail => {\n                if (head <= tail.head)\
    \ {\n                    max = head\n                } else {\n              \
    \      max = tail.head\n                }\n            }\n        }\n        max\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpo3uf4dji.scala:15:12 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mvar\e[0m \e[36mmax\e[0m = -\e[31m1L\e[0m\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmax is already\
    \ defined as \e[33mvariable\e[0m \e[35mmax\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpo3uf4dji.scala:16:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmax\e[0m = -\e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmax is already defined as \e[33mvariable\e[0m \e[35mmax\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmpo3uf4dji.scala:17:18 ---------------------------\e[0m\e[0m\n\e\
    [31m17 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toSeq\n\e[31m\e[31m \
    \  |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                  Recursive\
    \ \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpo3uf4dji.scala:21:20 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m                \e[33mif\e[0m (head <= tail.head) {\n\
    \e[31m\e[31m   |\e[0m                    ^^^^\e[0m\n\e[31m   |\e[0m          \
    \          Not found: head\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpo3uf4dji.scala:22:26 ------------------------\e[0m\e[0m\n\e[31m22 |\e\
    [0m                    max = head\n\e[31m\e[31m   |\e[0m                     \
    \     ^^^^\e[0m\n\e[31m   |\e[0m                          Not found: head\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpo3uf4dji.scala:24:26\
    \ ------------------------\e[0m\e[0m\n\e[31m24 |\e[0m                    max =\
    \ tail.head\n\e[31m\e[31m   |\e[0m                          ^^^^\e[0m\n\e[31m\
    \   |\e"
  stdout: ''
  timestamp: 1659978796
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        var largest = -1l\n        var maxIndex = -1\n        for\
    \ (i <- 0 until arr.size) {\n            if (largest < arr(i)) {\n           \
    \     largest = arr(i)\n                maxIndex = i\n            }\n        }\n\
    \        if (maxIndex > 0) {\n            largest\n        } else {\n        \
    \    -1\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmprme81qpb.scala:29)\n\tat Problem.main(tmprme81qpb.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978802
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        arr.lastIndexWhere(_ > arr.headOption)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong,\
    \ 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpgsdaj83x.scala:14:29 -----------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        arr.lastIndexWhere(_ > arr.headOption)\n\e[31m\e\
    [31m   |\e[0m                           ^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded\
    \ alternatives of \e[33mmethod\e[0m \e[35m>\e[0m in \e[33mclass\e[0m \e[35mLong\e\
    [0m with types\n\e[31m   |\e[0m (x: Double): Boolean\n\e[31m   |\e[0m (x: Float):\
    \ Boolean\n\e[31m   |\e[0m (x: Long): Boolean\n\e[31m   |\e[0m (x: Int): Boolean\n\
    \e[31m   |\e[0m (x: Char): Boolean\n\e[31m   |\e[0m (x: Short): Boolean\n\e[31m\
    \   |\e[0m (x: Byte): Boolean\n\e[31m   |\e[0mmatch arguments ((arr.headOption\
    \ : => Option[Long]))\n1 error found\n"
  stdout: ''
  timestamp: 1659978799
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        val res = arr.foldLeft((0l, -1l)) { (a,b) => if (b > a._2)\
    \ (a, b) else (b,a) }\n        res._1 \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong,\
    \ 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpur3y5fk_.scala:14:68\
    \ --------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mres\e\
    [0m = arr.foldLeft((\e[31m0l\e[0m, -\e[31m1l\e[0m)) { (\e[36ma\e[0m,\e[36mb\e\
    [0m) => \e[33mif\e[0m (b > a._2) (a, b) \e[33melse\e[0m (b,a) }\n\e[31m\e[31m\
    \   |\e[0m                                                                   \
    \ ^\e[0m\n\e[31m   |\e[0m                                            Found:  \
    \  (a : (Long, Long))\n\e[31m   |\e[0m                                       \
    \     Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpur3y5fk_.scala:14:82\
    \ --------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mres\e\
    [0m = arr.foldLeft((\e[31m0l\e[0m, -\e[31m1l\e[0m)) { (\e[36ma\e[0m,\e[36mb\e\
    [0m) => \e[33mif\e[0m (b > a._2) (a, b) \e[33melse\e[0m (b,a) }\n\e[31m\e[31m\
    \   |\e[0m                                                                   \
    \               ^\e[0m\n\e[31m   |\e[0m                                      \
    \      Found:    (a : (Long, Long))\n\e[31m   |\e[0m                         \
    \                   Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659978801
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        arr.zipWithIndex.max{ case (el, i) =>\n            el >=\
    \ arr(i - 1)\n        }._2\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(canArrange((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\
    \ == (3l));\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong, 4l.toLong,\
    \ 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong, 4l.toLong,\
    \ 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong, 10l.toLong)))\
    \ == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong, 5l.toLong,\
    \ 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]())) ==\
    \ (-1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp6og02cih.scala:15:15 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m            el >= arr(i - \e[31m1\e[0m)\n\e[31m\e[31m\
    \   |\e[0m            ^^^^^\e[0m\n\e[31m   |\e[0mvalue >= is not a member of (Long,\
    \ Int), but could be made available as an extension method.\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mOne of the following imports might fix the problem:\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m  import math.Ordered.orderingToOrdered\n\e[31m   |\e[0m \
    \ import math.Ordering.Implicits.infixOrderingOps\n\e[31m   |\e[0m\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmp6og02cih.scala:15:24 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m            el >= arr(i - \e[31m1\e[0m)\n\e[31m\e[31m\
    \   |\e[0m                      ^^^\e[0m\n\e[31m   |\e[0mvalue - is not a member\
    \ of (Long, Int), but could be made available as an extension method.\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mOne of the following imports might make progress towards\
    \ fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659978803
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        val a = arr.reverseIterator\n        var maxIndex : Long\
    \ = -1l\n        var i : Long = 0\n        a.foreach{ elem =>\n            if(elem\
    \ < arr.head) {\n                i = elem\n            }\n            else {\n\
    \                maxIndex = i\n                i = 0\n            }\n        }\n\
    \        if(maxIndex >= arr.head) {\n            -1\n        }\n        else {\n\
    \            maxIndex\n        }\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(canArrange((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong,\
    \ 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpswaqoh5u.scala:34)\n\tat Problem.main(tmpswaqoh5u.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978803
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        val l = arr sortBy {_.toLong } reverse take 1\n        if\
    \ (l.isEmpty || l.head == l.last) {\n            -1\n        } else {\n      \
    \      arr.indexOf(l(l.reverse dropRight 1) )\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong,\
    \ 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmplvfx6w0x.scala:14:52 -----------------------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36ml\e[0m = arr sortBy {_.toLong\
    \ } reverse take \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m                         \
    \                           ^\e[0m\n\e[31m   |\e[0m                     end of\
    \ statement expected but integer literal found\n\e[31m\e[31m-- [E006] Not Found\
    \ Error: /tmp/tmplvfx6w0x.scala:14:47 ------------------------\e[0m\e[0m\n\e[31m14\
    \ |\e[0m        \e[33mval\e[0m \e[36ml\e[0m = arr sortBy {_.toLong } reverse take\
    \ \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m                                        \
    \       ^^^^\e[0m\n\e[31m   |\e[0m                                           \
    \    Not found: take\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmplvfx6w0x.scala:15:14\
    \ ------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mif\e[0m (l.isEmpty\
    \ || l.head == l.last) {\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m            value isEmpty is not a member of Long\n\e[31m\e[31m--\
    \ [E050] Type Error: /tmp/tmplvfx6w0x.scala:18:24 -----------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m            arr.indexOf(l(l.reverse dropRight \e[31m1\e\
    [0m) )\n\e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m \
    \                       \e[33mvalue\e[0m \e[35ml\e[0m does not take parameters\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmplvfx6w0x.scala:18:28\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m            arr.indexOf(l(l.reverse\
    \ dropRight \e[31m1\e[0m) )\n\e[31m\e[31m   |\e[0m                          ^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                          value reverse is not a member of\
    \ Long\n5 errors found\n"
  stdout: ''
  timestamp: 1659978802
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        val sortedList = arr.sorted\n        for (i <- 0 until sortedList.length)\
    \ \n            if(sortedList(i) >= sortedList(i-1)) \n                return\
    \ i\n        return -1\n    }\n    def main(args: Array[String]) = {\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: -1\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:115)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.canArrange$$anonfun$1(tmpr9ur6qpa.scala:16)\n\tat scala.runtime.java8.JFunction1$mcVI$sp.apply(JFunction1$mcVI$sp.scala:18)\n\
    \tat scala.collection.immutable.Range.foreach(Range.scala:190)\n\tat Problem$.canArrange(tmpr9ur6qpa.scala:17)\n\
    \tat Problem$.main(tmpr9ur6qpa.scala:21)\n\tat Problem.main(tmpr9ur6qpa.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978804
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        val m = arr.head\n        var index = 0\n        arr.foreach\
    \ { x =>\n            if (x < m) index = x\n            else m = m\n        }\n\
    \        if (index == arr.length) return -1\n        else index\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpsk3kr13a.scala:17:31\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m            \e[33mif\e[0m (x\
    \ < m) index = x\n\e[31m\e[31m   |\e[0m                               ^\e[0m\n\
    \e[31m   |\e[0m                               Found:    (x : Long)\n\e[31m   |\e\
    [0m                               Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E052] Type Error: /tmp/tmpsk3kr13a.scala:18:19 -----------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m            \e[33melse\e[0m m = m\n\e[31m\e[31m   |\e\
    [0m                 ^^^^^\e[0m\n\e[31m   |\e[0m                 Reassignment to\
    \ val m\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659978803
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        var maxIndex = 0\n        var maxVal = -1\n        var found\
    \ = false\n        for (i <- 0 until arr.length) {\n            if(found) {\n\
    \                break\n            }\n            val newVal = arr(i)\n     \
    \       if (newVal <= maxVal) {\n                maxIndex = i\n              \
    \  maxVal = newVal\n                found = true\n            }\n        }\n \
    \       if(found == false)\n            return -1\n        else\n            return\
    \ maxIndex\n    }\n    def main(args: Array[String]) = {\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmphlp8e0mb.scala:19:16 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m                break\n\e[31m\e[31m   |\e[0m        \
    \        ^^^^^\e[0m\n\e[31m   |\e[0m                Not found: break\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphlp8e0mb.scala:24:25 --------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m                maxVal = newVal\n\e[31m\e[31m   |\e[0m\
    \                         ^^^^^^\e[0m\n\e[31m   |\e[0m                       \
    \  Found:    (newVal : Long)\n\e[31m   |\e[0m                         Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659978803
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        var maxIndex = 0\n        var maxVal = arr(0) // the largest\
    \ element\n\n        for (i<-1 to arr.length-1) {\n            if (arr(i) > maxVal)\
    \ {\n                maxIndex = i\n                maxVal = arr(i)\n         \
    \   }\n        }\n        if (maxIndex >= 0) maxIndex\n        else -1\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpttevs84g.scala:27)\n\tat Problem.main(tmpttevs84g.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978805
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        val l = new mutable.LinkedList[Long]()\n        var index\
    \ = 0\n        arr.foreach(i => {\n            if (l.contains(i)) return\n   \
    \         index += 1\n            l.add(i)\n        })\n        return index\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpx_ux646g.scala:14:20 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36ml\e[0m = \e[33mnew\e[0m\
    \ mutable.LinkedList[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m               \
    \     ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found: mutable\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpx_ux646g.scala:17:31\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m            \e[33mif\e[0m (l.contains(i))\
    \ \e[33mreturn\e[0m\n\e[31m\e[31m   |\e[0m                               ^^^^^^\e\
    [0m\n\e[31m   |\e[0m                               Found:    Unit\n\e[31m   |\e\
    [0m                               Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659978803
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        var max = -1L\n        var current = 0L\n\n        for (elem\
    \ <- arr.toArray.reverse.iterator) {\n            if (current <= elem) {\n   \
    \             max = current\n            } else {\n                current = elem\
    \ - 1\n            }\n        }\n\n        max\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong,\
    \ 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpjvkwxqy_.scala:28)\n\tat Problem.main(tmpjvkwxqy_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978805
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        var index = -1l\n        var max = 0\n        var currentValue\
    \ = 0\n        var currentIndex = 0\n        arr.foreach(x => {\n            if\
    \ (x> max && x > currentValue) {\n                currentValue = x\n         \
    \       currentIndex = index\n            } else if (x != currentValue) {\n  \
    \              index = currentIndex\n                max = currentValue\n    \
    \            currentValue = 0\n            }\n        })\n        return currentIndex\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxzrnc843.scala:20:31\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m                currentValue\
    \ = x\n\e[31m\e[31m   |\e[0m                               ^\e[0m\n\e[31m   |\e\
    [0m                               Found:    (x : Long)\n\e[31m   |\e[0m      \
    \                         Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpxzrnc843.scala:21:31 --------------------\e[0m\e\
    [0m\n\e[31m21 |\e[0m                currentIndex = index\n\e[31m\e[31m   |\e[0m\
    \                               ^^^^^\e[0m\n\e[31m   |\e[0m                  \
    \             Found:    (index : Long)\n\e[31m   |\e[0m                      \
    \         Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659978805
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        val max = arr.iterator\n        val result = -1l\n     \
    \   val currIndex = -1\n        for (i <- 0 to arr.length - 1) {\n           \
    \ if(arr(i) > arr(i-1)) {\n                val tmpMax = max\n                max\
    \ = i\n                currIndex = i\n            }\n        }\n        max =\
    \ tmpMax\n        if(max == -1l && arr.size == 1) max = 0\n        result\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp40k40kh3.scala:20:22\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m                max = i\n\e[31m\e\
    [31m   |\e[0m                      ^\e[0m\n\e[31m   |\e[0m                   \
    \   Found:    (i : Int)\n\e[31m   |\e[0m                      Required: Iterator[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmp40k40kh3.scala:21:26 -----------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m                currIndex = i\n\e[31m\e[31m   |\e[0m\
    \                ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                Reassignment\
    \ to val currIndex\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp40k40kh3.scala:24:14\
    \ ------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        max = tmpMax\n\e\
    [31m\e[31m   |\e[0m              ^^^^^^\e[0m\n\e[31m   |\e[0m              Not\
    \ found: tmpMax\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- Error: /tmp/tmp40k40kh3.scala:25:11\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m25 |\e[0m       \
    \ \e[33mif\e[0m(max == -\e[31m1l\e[0m && arr.size == \e[31m1\e[0m) max = \e[31m0\e\
    [0m\n\e[31m\e[31m   |\e[0m           ^^^^^^^^^^\e[0m\n\e[31m   |\e[0mValues of\
    \ types Iterator[Long] and Long cannot be compared with == or !=\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmp40k40kh3.scala:25:46 --------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mif\e[0m(max == -\e[31m1l\e[0m && arr.size\
    \ == \e[31m1\e[0m) max = \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m                 \
    \                             ^\e[0m\n\e[31m   |\e[0m                        \
    \                      Found:    (\e[31m0\e[0m : Int)\n\e[31m   |\e[0m       \
    \                                       Required: Iterator[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    5 errors found\n"
  stdout: ''
  timestamp: 1659978807
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        var maxIndex: Long = -1\n        var max: Long = 0\n   \
    \     for (i <- 0 until arr.length) {\n            if (arr(i) > max)\n       \
    \         max = arr(i)\n            if (arr(i) == max)\n                maxIndex\
    \ = i\n        }\n        maxIndex\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong,\
    \ 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpnb9sr80a.scala:25)\n\tat Problem.main(tmpnb9sr80a.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978809
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        arr.zipWithIndex.maxBy(_._1)._2\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong,\
    \ 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp95lolihw.scala:17)\n\tat Problem.main(tmp95lolihw.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978809
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        val sorted = arr.sortWith(_ <= _)\n        val leftmost\
    \ = sorted.head\n        var maxIndex = 0\n\n        for (i <- sorted.reverse.indices)\
    \ {\n            if (sorted[i] > leftmost) {\n                maxIndex = i + 1\n\
    \                break\n            }\n        }\n        if (maxIndex == 0)\n\
    \            return -1\n        else\n            return maxIndex\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmps5e5vg05.scala:19:23 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m            \e[33mif\e[0m (sorted[\e[35mi\e[0m] > leftmost)\
    \ {\n\e[31m\e[31m   |\e[0m                       ^\e[0m\n\e[31m   |\e[0m     \
    \                  Not found: type i\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmps5e5vg05.scala:21:16 ------------------------\e[0m\e\
    [0m\n\e[31m21 |\e[0m                break\n\e[31m\e[31m   |\e[0m             \
    \   ^^^^^\e[0m\n\e[31m   |\e[0m                Not found: break\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659978804
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        // Your code goes here\n        arr.foldRight(-1, 0)((acc,\
    \ i) => {\n            val leftIndex = acc - 1\n            if (i >= arr[leftIndex])\
    \ {\n                leftIndex\n            } else {\n                -1\n   \
    \         }\n        })\n    }\n    def main(args: Array[String]) = {\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpzr9n_ptc.scala:17:18 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m            \e[33mif\e[0m (i >= arr[\e[35mleftIndex\e\
    [0m]) {\n\e[31m\e[31m   |\e[0m                ^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ >= is not a member of (Int, Int), but could be made available as an extension\
    \ method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might\
    \ fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Ordered.orderingToOrdered\n\
    \e[31m   |\e[0m  import math.Ordering.Implicits.infixOrderingOps\n\e[31m   |\e\
    [0m\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpzr9n_ptc.scala:17:25 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m            \e[33mif\e[0m (i >= arr[\e[35mleftIndex\e\
    [0m]) {\n\e[31m\e[31m   |\e[0m                         ^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                         Not found: type leftIndex\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpzr9n_ptc.scala:18:16 --------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m                leftIndex\n\e[31m\e[31m   |\e[0m    \
    \            ^^^^^^^^^\e[0m\n\e[31m   |\e[0m                Found:    (leftIndex\
    \ : Long)\n\e[31m   |\e[0m                Required: (Int, Int)\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpzr9n_ptc.scala:20:16 --------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m                -\e[31m1\e[0m\n\e[31m\e[31m   |\e[0m\
    \                ^^\e[0m\n\e[31m   |\e[0m                Found:    (\e[31m-1\e\
    [0m : Int)\n\e[31m   |\e[0m                Required: (Int, Int)\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1659978808
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n      arr.reverse.dropWhile(_ <= arr.head).reverse.indexOf(0l) -\
    \ 1\n    }\n    def main(args: Array[String]) = {\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp6d0va78s.scala:17)\n\tat Problem.main(tmp6d0va78s.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978811
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        var max = -1\n        var i = 1\n        while (i < arr.length)\
    \ {\n            if ((arr(i) < arr(i-1)) && (arr(i) != max))\n               \
    \ max = arr(i)\n            i += 1\n        }\n        max\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong,\
    \ 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp11i3z0rb.scala:18:25\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m                max = arr(i)\n\
    \e[31m\e[31m   |\e[0m                      ^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \                Found:    Long\n\e[31m   |\e[0m                      Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659978809
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        val minElem = arr.min\n        val max = arr.max\n     \
    \   val indexMap = arr.zipWithIndex.toMap\n        val newIndexMap : Map[Long,\
    \ Long] = indexMap.map{case (k, v) => k -> v + 1}\n        val res : Long = indexMap(minElem)\n\
    \        if (indexMap.contains(max)) -1 else res\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong,\
    \ 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp8y31xnxc.scala:17:79 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mnewIndexMap\e[0m : \e[35mMap\e\
    [0m[\e[35mLong\e[0m, \e[35mLong\e[0m] = indexMap.map{\e[33mcase\e[0m (k, v) =>\
    \ k -> v + \e[31m1\e[0m}\n\e[31m\e[31m   |\e[0m                              \
    \                                          ^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ + is not a member of (Long, Int), but could be made available as an extension\
    \ method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might\
    \ make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e[0m  import\
    \ math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import math.Numeric.Implicits.infixNumericOps\n\
    \e[31m   |\e[0m\n1 error found\n"
  stdout: ''
  timestamp: 1659978812
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        arr.zipWithIndex.maxBy(_._1)._2\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong,\
    \ 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp95lolihw.scala:17)\n\tat Problem.main(tmp95lolihw.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978809
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n      var max = -1l\n      var index = 0l\n      for(i <- arr.indices)\
    \ {\n        if(arr(i) > arr(index + 1))\n          index = i\n      }\n     \
    \ max = index\n      return max\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(canArrange((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong,\
    \ 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp458u67sp.scala:17:24\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mif\e[0m(arr(i)\
    \ > arr(index + \e[31m1\e[0m))\n\e[31m\e[31m   |\e[0m                        ^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                        Found:    Long\n\e[31m   |\e[0m  \
    \                      Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659978811
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        arr.headOption match {\n            case None => -1\n  \
    \          case Some(head) =>\n                val prevIndex = arr.lastIndexWhere(x\
    \ => x > head) match {\n                    case None => -1\n                \
    \    case Some(prevIndex) => prevIndex + 1\n                }\n              \
    \  if (prevIndex == -1)\n                    -1\n                else\n      \
    \              prevIndex\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong,\
    \ 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp3w_ha_2s.scala:18:25\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m                    \e[33mcase\e\
    [0m None => -\e[31m1\e[0m\n\e[31m\e[31m   |\e[0m                         ^^^^\e\
    [0m\n\e[31m   |\e[0m                         Found:    None.type\n\e[31m   |\e\
    [0m                         Required: Int\n\e[31m   |\e[0m                   \
    \      pattern type is incompatible with expected type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp3w_ha_2s.scala:19:54 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m                    \e[33mcase\e[0m Some(prevIndex) =>\
    \ prevIndex + \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m                            \
    \                ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue + is not a member of Any,\
    \ but could be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mOne of the following imports might make progress towards fixing the\
    \ problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659978813
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        val max = arr.last\n        val index = arr.indexWhere(i\
    \ => i <= max)\n        if (index == arr.length)\n            -1\n        else\n\
    \            arr.lift(index).max\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(canArrange((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong,\
    \ 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpso_me292.scala:22)\n\tat Problem.main(tmpso_me292.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978814
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        arr.foldLeft(arr.head)( (max, x) => {\n            if (max\
    \ <= x) return x\n            else return max\n        })\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong,\
    \ 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp0eizu20f.scala:20)\n\tat Problem.main(tmp0eizu20f.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978814
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        var maxIndex = -1l\n        var maxNumber = Long.MinValue\n\
    \        var previousNumber = Long.MinValue\n        arr.foreach((x) => {\n  \
    \          if( x != previousNumber ){\n                maxIndex = maxIndex + 1\n\
    \                maxNumber = x\n            }\n            previousNumber = x\n\
    \        })\n        if( maxNumber == Long.MinValue ){\n            maxIndex =\
    \ -1\n        }\n        return maxIndex\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong,\
    \ 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpszblh14_.scala:30)\n\tat Problem.main(tmpszblh14_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978814
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        var maxIndex = 0\n        arr.foreach { x => if (x > maxIndex)\
    \ maxIndex = x }\n        maxIndex\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong,\
    \ 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp3t32f8bj.scala:15:56\
    \ --------------------\e[0m\e[0m\n\e[31m15 |\e[0m        arr.foreach { \e[36mx\e\
    [0m => \e[33mif\e[0m (x > maxIndex) maxIndex = x }\n\e[31m\e[31m   |\e[0m    \
    \                                                    ^\e[0m\n\e[31m   |\e[0m \
    \                                                   Found:    (x : Long)\n\e[31m\
    \   |\e[0m                                                    Required: Int\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659978812
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        var maxIndex = -1l\n        var maxVal = -1L\n        var\
    \ i = 0\n        for (x <- arr) {\n            if (maxVal == -1L) {\n        \
    \        maxVal = x\n                maxIndex = 0\n            } else if (maxVal\
    \ < x) {\n                maxVal = x\n                maxIndex = 0\n         \
    \   } else if (maxVal == x) {\n                maxIndex = i + 1\n            }\n\
    \            i += 1\n        }\n        if (maxIndex < 0) {\n            return\
    \ -1L\n        }\n        return maxIndex\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong,\
    \ 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp77g96l7n.scala:35)\n\tat Problem.main(tmp77g96l7n.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978815
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n      val a = arr.sorted\n      var maxIndex = -1\n      var curIndex\
    \ = 0\n      for(i <- 0 until a.length) {\n        if(a(i) < a(i + 1))\n     \
    \     curIndex += 1\n        else\n          if(curIndex > maxIndex) {\n     \
    \       maxIndex = curIndex\n          }\n          curIndex = 0\n      }\n  \
    \    if(maxIndex < arr.length) {\n        return maxIndex\n      }\n      else\n\
    \        return -1\n    }\n    def main(args: Array[String]) = {\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 5\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.canArrange$$anonfun$1(tmpzf6yevq5.scala:18)\n\tat scala.runtime.java8.JFunction1$mcVI$sp.apply(JFunction1$mcVI$sp.scala:18)\n\
    \tat scala.collection.immutable.Range.foreach(Range.scala:190)\n\tat Problem$.canArrange(tmpzf6yevq5.scala:25)\n\
    \tat Problem$.main(tmpzf6yevq5.scala:33)\n\tat Problem.main(tmpzf6yevq5.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978816
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        val max = arr.max\n        if(max > 0)\n            for\
    \ (i <- arr.indices) yield {\n                if((i > 0) && (arr(i) == arr(i -\
    \ 1)))\n                    arr(i)\n                else\n                   \
    \ -1\n            }.toList.max\n        else\n            -1\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong,\
    \ 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpcc1v2615.scala:21:14 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m            \e[33mfor\e[0m (i <- arr.indices) \e[33myield\e\
    [0m {\n\e[31m17 |\e[0m                \e[33mif\e[0m((i > \e[31m0\e[0m) && (arr(i)\
    \ == arr(i - \e[31m1\e[0m)))\n\e[31m18 |\e[0m                    arr(i)\n\e[31m19\
    \ |\e[0m                \e[33melse\e[0m\n\e[31m20 |\e[0m                    -\e\
    [31m1\e[0m\n\e[31m21 |\e[0m            }.toList.max\n\e[31m\e[31m   |\e[0m   \
    \                                      ^\e[0m\n\e[31m   |\e[0m         value toList\
    \ is not a member of Long - did you mean Long.toInt?\n1 error found\n"
  stdout: ''
  timestamp: 1659978813
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        // Write your function here\n        val map = arr.foldLeft(Map.empty[Long,\
    \ Int]) { case (acc, x) =>\n            if (acc.isEmpty) acc + (x -> 1)\n    \
    \        else {\n                val found = acc.find(_._2 > x)\n            \
    \    if (found == None) acc + (x -> 1)\n                else if (found._2 > x)\
    \ acc + (x -> found._2 + 1)\n                else acc\n            }\n       \
    \ }\n        val max = map.maxBy(_._2)._1.toLong\n        if (map.contains(max))\
    \ max else -1\n    }\n    def main(args: Array[String]) = {\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpkdh70al0.scala:20:31 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m                \e[33melse\e[0m \e[33mif\e[0m (found._2\
    \ > x) acc + (x -> found._2 + \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m           \
    \              ^^^^^^^^\e[0m\n\e[31m   |\e[0m                         value _2\
    \ is not a member of Option[(Long, Int)]\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpkdh70al0.scala:20:57 ------------------------\e[0m\e[0m\n\e[31m20 |\e\
    [0m                \e[33melse\e[0m \e[33mif\e[0m (found._2 > x) acc + (x -> found._2\
    \ + \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m                                     \
    \              ^^^^^^^^\e[0m\n\e[31m   |\e[0m                         value _2\
    \ is not a member of Option[(Long, Int)]\n2 errors found\n"
  stdout: ''
  timestamp: 1659978815
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        var i = 1\n        var maxIndex = 0\n        while (i <\
    \ arr.length) {\n            if (arr(i) <= arr(i - 1) && arr(i) != -1) {\n   \
    \             maxIndex = i\n            }\n            i += 1\n        }\n   \
    \     return maxIndex\n    }\n    def main(args: Array[String]) = {\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpngif4lzz.scala:26)\n\tat Problem.main(tmpngif4lzz.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978817
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        def getIndex(e, i : Int) : Int = {\n            if (i <\
    \ arr.length && e > arr(i)) i else -1\n        }\n        val maxIndex = -1\n\
    \        var currIndex = 0\n        while(currIndex < arr.length && currIndex\
    \ != maxIndex) {\n            maxIndex = getIndex(arr(currIndex), currIndex)\n\
    \            currIndex++\n        }\n        maxIndex\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong,\
    \ 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp2jgqmvxi.scala:14:22 ---------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mdef\e[0m \e[36mgetIndex\e[0m(\e[36me\e\
    [0m, \e[36mi\e[0m : \e[35mInt\e[0m) : \e[35mInt\e[0m = {\n\e[31m\e[31m   |\e[0m\
    \                      ^\e[0m\n\e[31m   |\e[0m                      ':' expected,\
    \ but ',' found\n\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp2jgqmvxi.scala:21:23\
    \ ---------------------------\e[0m\e[0m\n\e[31m21 |\e[0m            currIndex++\n\
    \e[31m\e[31m   |\e[0m                       ^\e[0m\n\e[31m   |\e[0m          \
    \             expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E052] Type Error: /tmp/tmp2jgqmvxi.scala:20:21 -----------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m            maxIndex = getIndex(arr(currIndex), currIndex)\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m            Reassignment to val maxIndex\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1659978812
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        var maxIndex = 0\n        for (_ <- 0 until arr.length -\
    \ 1){\n            if (arr(maxIndex) <= arr(maxIndex + 1)){\n                maxIndex\
    \ = maxIndex + 1\n            }\n            else {\n                break\n \
    \           }\n        }\n        if (maxIndex != 0){\n            return maxIndex\n\
    \        }\n        else {\n            return -1\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong,\
    \ 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpns1w8txe.scala:20:16 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m                break\n\e[31m\e[31m   |\e[0m        \
    \        ^^^^^\e[0m\n\e[31m   |\e[0m                Not found: break\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659978813
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n      val maxIndex: Long = arr.length-1\n      arr.toSeq.tail.zipWithIndex.find(_._2\
    \ > _._1).get._1 + 1\n    }\n    def main(args: Array[String]) = {\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpikk5avdo.scala:15:41 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m      arr.toSeq.tail.zipWithIndex.find(_._2 > _._1).get._1\
    \ + \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m                                      \
    \ ^^^^\e[0m\n\e[31m   |\e[0m                                       value _2 is\
    \ not a member of Long\n1 error found\n"
  stdout: ''
  timestamp: 1659978816
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        val indexedList = arr.zipWithIndex\n        val firstElement\
    \ = indexedList.head\n        val secondElement = indexedList.tail.head\n    \
    \    val thirdElement = indexedList.tail.tail.head\n        // First element is\
    \ not greater than or equal to the second\n        if (firstElement < secondElement)\
    \ secondElement\n        // Second element is not greater than or equal to the\
    \ third\n        else if (secondElement < thirdElement) thirdElement\n       \
    \ // All elements are equal\n        else -1\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong,\
    \ 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpe4hf35y9.scala:19:25 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mif\e[0m (firstElement < secondElement)\
    \ secondElement\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mvalue < is not a member of (Long, Int), but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Ordered.orderingToOrdered\n\
    \e[31m   |\e[0m  import math.Ordering.Implicits.infixOrderingOps\n\e[31m   |\e\
    [0m\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpe4hf35y9.scala:19:42 --------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mif\e[0m (firstElement < secondElement)\
    \ secondElement\n\e[31m\e[31m   |\e[0m                                       \
    \   ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                                 Found:\
    \    (secondElement : (Long, Int))\n\e[31m   |\e[0m                          \
    \       Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpe4hf35y9.scala:21:31\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33melse\e[0m \e\
    [33mif\e[0m (secondElement < thirdElement) thirdElement\n\e[31m\e[31m   |\e[0m\
    \                 ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue < is not a member\
    \ of (Long, Int), but could be made available as an extension method.\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mOne of the following imports might fix the problem:\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Ordered.orderingToOrdered\n\e[31m\
    \   |\e[0m  import math.Ordering.Implicits.infixOrderingOps\n\e[31m   |\e[0m\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpe4hf35y9.scala:21:47 --------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (secondElement\
    \ < thirdElement) thirdElement\n\e[31m\e[31m   |\e[0m                        \
    \                       ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                   \
    \               Found:    (thirdElement : (Long, Int))\n\e[31m   |\e[0m      \
    \                            Required: Long\n\e[31m   |\e["
  stdout: ''
  timestamp: 1659978817
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n      val maxIndex = arr.indexWhere(x => x < arr.takeRight(1).head);\n\
    \      maxIndex == -1L ? -1L : maxIndex\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong,\
    \ 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpk7nvjzqz.scala:15:30 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m      maxIndex == -\e[31m1L\e[0m ? -\e[31m1L\e[0m : \e\
    [35mmaxIndex\e[0m\n\e[31m\e[31m   |\e[0m                              ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                              Not found: type maxIndex\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpk7nvjzqz.scala:15:22\
    \ ------------------------\e[0m\e[0m\n\e[31m15 |\e[0m      maxIndex == -\e[31m1L\e\
    [0m ? -\e[31m1L\e[0m : \e[35mmaxIndex\e[0m\n\e[31m\e[31m   |\e[0m            \
    \      ^^^^^\e[0m\n\e[31m   |\e[0m                  value ? is not a member of\
    \ Long\n2 errors found\n"
  stdout: ''
  timestamp: 1659978817
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        if (arr.isEmpty) -1\n        else {\n            var max\
    \ = -1L\n            var max = -1L\n            arr.foreach {\n              \
    \  case i => if (i < max) max = i else max = -1L\n            }\n            max\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpc1z8oj_8.scala:17:16 ---------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m            \e[33mvar\e[0m \e[36mmax\e[0m = -\e[31m1L\e\
    [0m\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmax is\
    \ already defined as \e[33mvariable\e[0m \e[35mmax\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n1 error found\n"
  stdout: ''
  timestamp: 1659978814
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        arr.zip(arr.drop(1)).maxBy(_._1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong,\
    \ 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmprmi69ts9.scala:14:8\
    \ ---------------------\e[0m\e[0m\n\e[31m14 |\e[0m        arr.zip(arr.drop(\e\
    [31m1\e[0m)).maxBy(_._1)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    (Long, Long)\n\e[31m   |\e[0m        Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659978819
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        // Create a list of all unique elements (i.e. unique pairs\
    \ with the\n        // first element distinct). We use a HashSet which eliminates\
    \ duplicate\n        // elements.\n        val unqiues = HashSet(arr)\n      \
    \  if (unqiues.isEmpty) return -1\n        val max = arr.lastOption\n        if\
    \ (max.isEmpty) return -1\n        unqiues.find(elem => elem._1 > max._1) match\
    \ {\n            case Some(lastEl) => lastEl\n            case None => -1\n  \
    \      }\n    }\n    def main(args: Array[String]) = {\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp31osx9p5.scala:21:34 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        unqiues.find(\e[36melem\e[0m => elem._1 > max._1)\
    \ \e[33mmatch\e[0m {\n\e[31m\e[31m   |\e[0m                             ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                             value _1 is not a member of List[Long]\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp31osx9p5.scala:22:33 --------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m            \e[33mcase\e[0m Some(lastEl) => lastEl\n\e\
    [31m\e[31m   |\e[0m                                 ^^^^^^\e[0m\n\e[31m   |\e\
    [0m                                 Found:    (lastEl : List[Long])\n\e[31m  \
    \ |\e[0m                                 Required: Long\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659978820
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        val sortedList = arr.toList.sortBy(x => x).reverse\n\n \
    \       var largestIndex = -1\n        var nextLargestIndex = -1\n\n        val\
    \ n = sortedList.size\n\n        if(n > 0) {\n            largestIndex = sortedList.head\
    \ - sortedList(n - 1)\n\n            nextLargestIndex = sortedList.head\n\n  \
    \          if(largestIndex > nextLargestIndex) {\n                nextLargestIndex\
    \ = largestIndex - 1\n            }\n        }\n\n        nextLargestIndex\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5u4ktviz.scala:22:27\
    \ --------------------\e[0m\e[0m\n\e[31m22 |\e[0m            largestIndex = sortedList.head\
    \ - sortedList(n - \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m                      \
    \     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m              \
    \             Found:    Long\n\e[31m   |\e[0m                           Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5u4ktviz.scala:24:42\
    \ --------------------\e[0m\e[0m\n\e[31m24 |\e[0m            nextLargestIndex\
    \ = sortedList.head\n\e[31m\e[31m   |\e[0m                               ^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                               Found:    Long\n\e[31m   |\e\
    [0m                               Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659978821
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        var largest = -1\n        arr.drop(1).foreach(x => if (x\
    \ >= largest) largest = x)\n        largest\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong,\
    \ 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5r76irjj.scala:15:61\
    \ --------------------\e[0m\e[0m\n\e[31m15 |\e[0m        arr.drop(\e[31m1\e[0m).foreach(\e\
    [36mx\e[0m => \e[33mif\e[0m (x >= largest) largest = x)\n\e[31m\e[31m   |\e[0m\
    \                                                             ^\e[0m\n\e[31m \
    \  |\e[0m                                                    Found:    (x : Long)\n\
    \e[31m   |\e[0m                                                    Required: Int\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659978820
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        var result = -1\n        var nextHighIndex = 0\n       \
    \ var currentIndex = 0\n        for (elem <- arr) {\n            if (elem >= arr[currentIndex])\
    \ {\n                nextHighIndex = currentIndex\n            }\n           \
    \ currentIndex += 1\n            if (currentIndex == arr.length) {\n         \
    \       currentIndex = 0\n            }\n        }\n        if (nextHighIndex\
    \ == -1) {\n            return result\n        } else {\n            return nextHighIndex\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpwyi_ix0g.scala:18:28 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m            \e[33mif\e[0m (elem >= arr[\e[35mcurrentIndex\e\
    [0m]) {\n\e[31m\e[31m   |\e[0m                            ^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                            Not found: type currentIndex\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659978819
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        val len = arr.length\n        val arrMap = arr.map( (a)\
    \ => a -> 1) // Create a map of original elements and their occurrences\n    \
    \    val maxMapKey = arr.last\n        val maxMapValue = arrMap(maxMapKey)\n \
    \       for (i <- 0 until len-1){\n            if (arrMap(i+maxMapKey) > maxMapValue){\n\
    \                maxMapKey = i\n                maxMapValue = arrMap(i+maxMapKey)\n\
    \            }\n        }\n        maxMapKey\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong,\
    \ 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4_4k_oou.scala:17:33\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mmaxMapValue\e\
    [0m = arrMap(maxMapKey)\n\e[31m\e[31m   |\e[0m                               \
    \  ^^^^^^^^^\e[0m\n\e[31m   |\e[0m                                 Found:    (maxMapKey\
    \ : Long)\n\e[31m   |\e[0m                                 Required: Int\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4_4k_oou.scala:19:23 --------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m            \e[33mif\e[0m (arrMap(i+maxMapKey) > maxMapValue){\n\
    \e[31m\e[31m   |\e[0m                       ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                       Found:    Long\n\e[31m   |\e[0m                      \
    \ Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmp4_4k_oou.scala:20:26\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m                maxMapKey\
    \ = i\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                Reassignment to val maxMapKey\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmp4_4k_oou.scala:21:37 --------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m                maxMapValue = arrMap(i+maxMapKey)\n\e\
    [31m\e[31m   |\e[0m                                     ^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                                     Found:    Long\n\e[31m   |\e[0m\
    \                                     Required: Int\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n4 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659978823
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        var max = 0\n        var index = 0\n        for(i <- arr.indices)\
    \ {\n            val elem = arr(i)\n            if(elem > arr(index)) {\n    \
    \            max = i\n            }\n            index += 1\n        }\n     \
    \   if(max == 0) {\n            return -1\n        }\n        return max\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpic19nazi.scala:29)\n\tat Problem.main(tmpic19nazi.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978825
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        arr.zipWithIndex.maxBy(_._1)._2\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong,\
    \ 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp95lolihw.scala:17)\n\tat Problem.main(tmp95lolihw.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978809
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        var maxIndex = 0l\n        arr.foreach { i =>\n        \
    \    if (i > maxIndex) {\n                maxIndex = i\n            }\n      \
    \  }\n        if (maxIndex < arr.lastOption.getOrElse(-1l)) {\n            return\
    \ -1\n        } else {\n            return maxIndex\n        }\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpv_a_mqhl.scala:27)\n\tat Problem.main(tmpv_a_mqhl.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978825
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        val maxIndex = arr.length - 1\n        var maxElem = arr(maxIndex)\n\
    \        var index = 0\n        while (maxElem > arr(index)) {\n            index\
    \ = index + 1\n        }\n        if (index == maxIndex) {\n            -1\n \
    \       } else {\n            maxIndex = index\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong,\
    \ 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmp07vc2vc3.scala:23:21 -----------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            maxIndex = index\n\e[31m\e[31m   |\e[0m \
    \           ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            Reassignment to\
    \ val maxIndex\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659978820
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        val m = arr.head\n        var maxIndex = -1l\n        for\
    \ (i<-1 to arr.length - 1) {\n            val n = arr(i)\n            if (n >\
    \ m)\n                maxIndex = i\n            else if (n == m)\n           \
    \     continue\n            else\n                maxIndex = -1l\n        }\n\
    \        maxIndex\n    }\n    def main(args: Array[String]) = {\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpusd1y8vo.scala:21:16 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m                continue\n\e[31m\e[31m   |\e[0m     \
    \           ^^^^^^^^\e[0m\n\e[31m   |\e[0m                Not found: continue\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659978821
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        var i = 0\n        var maxIndex = -1\n        val list =\
    \ arr.sorted\n        for (i <- 0 until list.size) {\n            if (list(i)\
    \ > list(i + 1)) {\n                maxIndex = i\n            }\n        }\n \
    \       if (maxIndex < 0) maxIndex = -1\n        maxIndex\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong,\
    \ 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 5\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.canArrange$$anonfun$1(tmpxfmzkdz3.scala:18)\n\tat scala.runtime.java8.JFunction1$mcVI$sp.apply(JFunction1$mcVI$sp.scala:18)\n\
    \tat scala.collection.immutable.Range.foreach(Range.scala:190)\n\tat Problem$.canArrange(tmpxfmzkdz3.scala:21)\n\
    \tat Problem$.main(tmpxfmzkdz3.scala:26)\n\tat Problem.main(tmpxfmzkdz3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978826
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        var lastI = 0\n        var canArrangeIndex = -1\n      \
    \  for (i <- 0 until arr.length) {\n            if (arr(i) <= arr(i-1)) lastI\
    \ = i\n            else canArrangeIndex = i\n        }\n        if(canArrangeIndex\
    \ < 0) canArrangeIndex = -1\n        lastI\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong,\
    \ 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: -1\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:115)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.canArrange$$anonfun$1(tmp93wk6pfi.scala:17)\n\tat scala.runtime.java8.JFunction1$mcVI$sp.apply(JFunction1$mcVI$sp.scala:18)\n\
    \tat scala.collection.immutable.Range.foreach(Range.scala:190)\n\tat Problem$.canArrange(tmp93wk6pfi.scala:19)\n\
    \tat Problem$.main(tmp93wk6pfi.scala:24)\n\tat Problem.main(tmp93wk6pfi.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978827
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        val sortedList = arr.sorted\n        var highestIndex =\
    \ 0\n        var currentIndex = 0\n        for (elem <- sortedList) {\n      \
    \      if (currentIndex == 0) {\n                if (elem < sortedList(sortedList.lastIndex))\
    \ {\n                    currentIndex = arr.lastIndex\n                }\n   \
    \         } else if (elem > sortedList(currentIndex - 1)) {\n                currentIndex\
    \ = currentIndex - 1\n            }\n            highestIndex = if (elem > highestIndex)\
    \ elem else highestIndex\n        }\n        if (highestIndex >= arr.last) {\n\
    \            highestIndex\n        } else {\n            -1l\n        }\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp52x0pbpl.scala:19:49 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m                \e[33mif\e[0m (elem < sortedList(sortedList.lastIndex))\
    \ {\n\e[31m\e[31m   |\e[0m                                      ^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue lastIndex is not a member of List[Long] - did you mean\
    \ sortedList.lastIndexOf?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp52x0pbpl.scala:20:39\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m                    currentIndex\
    \ = arr.lastIndex\n\e[31m\e[31m   |\e[0m                                   ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue lastIndex is not a member of List[Long] - did you mean\
    \ arr.lastIndexOf?\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp52x0pbpl.scala:25:52\
    \ --------------------\e[0m\e[0m\n\e[31m25 |\e[0m            highestIndex = \e\
    [33mif\e[0m (elem > highestIndex) elem \e[33melse\e[0m highestIndex\n\e[31m\e\
    [31m   |\e[0m                                                    ^^^^\e[0m\n\e\
    [31m   |\e[0m                                                 Found:    (elem\
    \ : Long)\n\e[31m   |\e[0m                                                 Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659978826
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        var max = 0\n        var maxIndex = 0\n        var i = 1\n\
    \        var j = 0\n        // Get max value\n        max = arr.foldLeft(0L)((a,\
    \ b) => a > b ? a : b)\n        while (i < arr.length) {\n            // Get value\
    \ before current max value\n            var value = arr(i)\n            // Check\
    \ if the value is greater than max and smaller than max minus current value\n\
    \            if (value > max && value < max - value) {\n                max =\
    \ value\n                maxIndex = i\n                j = 1\n            }\n\
    \            // Increment j\n            if (value < max) {\n                j++\n\
    \            }\n            // Increment i\n            i += 1\n            //\
    \ Check if j is greater than max and if so set max\n            if (j > max &&\
    \ value != 0) {\n                max = value\n                maxIndex = i\n \
    \           }\n        }\n        return maxIndex\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong,\
    \ 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpaeygp7cl.scala:31:19 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m                j++\n\e[31m\e[31m   |\e[0m          \
    \         ^\e[0m\n\e[31m   |\e[0m                   expression expected but \e\
    [31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpaeygp7cl.scala:19:53\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        max = arr.foldLeft(\e\
    [31m0L\e[0m)((\e[36ma\e[0m, \e[36mb\e[0m) => a > b ? a : \e[35mb\e[0m)\n\e[31m\e\
    [31m   |\e[0m                                                     ^\e[0m\n\e[31m\
    \   |\e[0m                                                     Not found: type\
    \ b\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpaeygp7cl.scala:19:47\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        max = arr.foldLeft(\e\
    [31m0L\e[0m)((\e[36ma\e[0m, \e[36mb\e[0m) => a > b ? a : \e[35mb\e[0m)\n\e[31m\e\
    [31m   |\e[0m                                             ^^^\e[0m\n\e[31m   |\e\
    [0m                                         value ? is not a member of Long\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpaeygp7cl.scala:25:22 --------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m                max = value\n\e[31m\e[31m   |\e[0m  \
    \                    ^^^^^\e[0m\n\e[31m   |\e[0m                      Found: \
    \   (value : Long)\n\e[31m   |\e[0m                      Required: Int\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpaeygp7cl.scala:37:22 --------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m                max = value\n\e[31m\e[31m   |\e[0m  \
    \                    ^^^^^\e[0m\n\e[31m   |\e[0m                      Found: \
    \   (value : Long)\n\e[31m   |\e[0m                      Required: Int\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    5 errors found\n"
  stdout: ''
  timestamp: 1659978826
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        // Add all elements of the list to an array (call it a)\n\
    \        val a: Array[Long] = arr.toArray\n        // Sort the array in descending\
    \ order\n        val sorted = a.sortWith(_ < _)\n        // Find the first element\
    \ which is not greater or equal to the previous\n        // element. If there\
    \ is no such element then return -1\n        if (sorted.head < sorted.last) sorted.last\
    \ else -1\n    }\n    def main(args: Array[String]) = {\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpwl73ojar.scala:23)\n\tat Problem.main(tmpwl73ojar.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978828
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        if (arr.isEmpty) -1\n        else arr.lastIndexWhere(x =>\
    \ x <= arr.last)\n    }\n    def main(args: Array[String]) = {\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpexrjt5q7.scala:18)\n\tat Problem.main(tmpexrjt5q7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978828
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        if(arr.isEmpty) return -1\n        val l = arr.head\n  \
    \      var cur = 0l\n        for(x <- arr.tail) {\n            if(x>l && cur==-1)\
    \ cur = x\n        }\n        if(cur==-1) return -1\n        arr(arr.indexOf(l)+1)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp8kiro8uk.scala:18:25 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m            \e[33mif\e[0m(x>l && cur==-\e[31m1\e[0m)\
    \ cur = x\n\e[31m\e[31m   |\e[0m                      ^^^^^^\e[0m\n\e[31m   |\e\
    [0m               value ==- is not a member of Long - did you mean Long.==?\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmp8kiro8uk.scala:20:14 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mif\e[0m(cur==-\e[31m1\e[0m) \e[33mreturn\e\
    [0m -\e[31m1\e[0m\n\e[31m\e[31m   |\e[0m           ^^^^^^\e[0m\n\e[31m   |\e[0m\
    \           value ==- is not a member of Long - did you mean Long.==?\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659978827
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        val a = arr.foldLeft(List.empty[Long](0l)) { (a, ele) =>\n\
    \            if (a.contains(ele)) {\n                a\n            } else {\n\
    \                a :+ ele\n            }\n        }\n        val b = a :+ arr.last\n\
    \        if (b.last.compare(b.init) < 0) -1\n        else {\n            b.last\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpzblchhoq.scala:14:46\
    \ --------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36ma\e\
    [0m = arr.foldLeft(List.empty[\e[35mLong\e[0m](\e[31m0l\e[0m)) { (\e[36ma\e[0m,\
    \ \e[36mele\e[0m) =>\n\e[31m\e[31m   |\e[0m                                  \
    \            ^^\e[0m\n\e[31m   |\e[0m                                        \
    \      Found:    (\e[31m0L\e[0m : Long)\n\e[31m   |\e[0m                     \
    \                         Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpzblchhoq.scala:15:18 ------------------------\e[0m\e\
    [0m\n\e[31m15 |\e[0m            \e[33mif\e[0m (a.contains(ele)) {\n\e[31m\e[31m\
    \   |\e[0m                ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                value\
    \ contains is not a member of Long\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpzblchhoq.scala:18:18\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m                a :+ ele\n\
    \e[31m\e[31m   |\e[0m                ^^^^\e[0m\n\e[31m   |\e[0m              \
    \  value :+ is not a member of Long\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpzblchhoq.scala:21:18\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mb\e[0m = a :+ arr.last\n\e[31m\e[31m   |\e[0m                ^^^^\e[0m\n\e\
    [31m   |\e[0m                value :+ is not a member of Long\n4 errors found\n"
  stdout: ''
  timestamp: 1659978827
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        var max = -1l\n        var i = -1\n\n        for (i <- 0\
    \ until arr.size) {\n            if (arr(i) > arr(i + 1))\n                max\
    \ = arr(i)\n        }\n\n        if (max < 0l)\n            max = -1l\n\n    \
    \    max\n    }\n    def main(args: Array[String]) = {\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 5\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.canArrange$$anonfun$1(tmp_e0x_81y.scala:18)\n\tat scala.runtime.java8.JFunction1$mcVI$sp.apply(JFunction1$mcVI$sp.scala:18)\n\
    \tat scala.collection.immutable.Range.foreach(Range.scala:190)\n\tat Problem$.canArrange(tmp_e0x_81y.scala:20)\n\
    \tat Problem$.main(tmp_e0x_81y.scala:28)\n\tat Problem.main(tmp_e0x_81y.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978829
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        val maxIndex = 0\n        arr.head match {\n           \
    \ case x if (x < arr.last) => -1\n            case x if (x > arr.last) => maxIndex\n\
    \            case x => arr.indexOf(x)\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong,\
    \ 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpa7budu6w.scala:22)\n\tat Problem.main(tmpa7budu6w.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978829
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        val l: List[Int] = arr.toList\n        val r: scala.collection.mutable.ListBuffer[Int]\
    \ = new ListBuffer()\n        var current = 0\n        var index = 0\n       \
    \ var max = 0\n        for (i <- 0 until l.length) {\n            if (l(i) <=\
    \ current) {\n                // If current is greater than or equal to l(i) then\
    \ decrement current\n                current = current - 1\n            } else\
    \ {\n                // If current is less than or equal to l(i) then append current\
    \ to r\n                index += 1\n                r += current\n           \
    \     current = l(i)\n            }\n\n            if (index == r.length) max\
    \ += current\n        }\n        if (max > arr.size) max else -1\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpjqbryfjz.scala:14:31\
    \ --------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36ml\e\
    [0m: \e[35mList\e[0m[\e[35mInt\e[0m] = arr.toList\n\e[31m\e[31m   |\e[0m     \
    \                      ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                      \
    \     Found:    List[\e[1m\e[31mLong\e[0m]\n\e[31m   |\e[0m                  \
    \         Required: List[\e[1m\e[32mInt\e[0m]\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659978828
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        if (arr.isEmpty) return -1\n        var maxIndex = 0\n \
    \       var prev = 0\n        for (i <- 0 until arr.size) {\n            if (arr(i)\
    \ < arr(prev)) {\n                maxIndex = i + 1\n                prev = i\n\
    \            }\n        }\n        if (maxIndex < arr.size - 1) maxIndex + 1\n\
    \        else -1\n    }\n    def main(args: Array[String]) = {\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp6adfyc87.scala:27)\n\tat Problem.main(tmp6adfyc87.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978829
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        var maxVal = -1\n        val l = new ListBuffer[Long]()\n\
    \        for (x <- arr) {\n            if (x < arr(l(l.length - 1)))\n       \
    \         maxVal = l(l.length - 1)\n            l.append(x)\n        }\n     \
    \   maxVal\n    }\n    def main(args: Array[String]) = {\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpaec8vrfw.scala:17:25\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m            \e[33mif\e[0m (x\
    \ < arr(l(l.length - \e[31m1\e[0m)))\n\e[31m\e[31m   |\e[0m                  \
    \      ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                        Found:   \
    \ Long\n\e[31m   |\e[0m                        Required: Int\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpaec8vrfw.scala:18:26 --------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m                maxVal = l(l.length - \e[31m1\e[0m)\n\
    \e[31m\e[31m   |\e[0m                         ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                         Found:    Long\n\e[31m   |\e[0m                  \
    \       Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659978829
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        val l1 = arr.head\n        val l2 = arr.last\n        val\
    \ l3 = arr.drop(1).dropRight(1)\n        if (l2 < l3 || l2 < l1) return -1\n \
    \       if (l3 < l2 || l3 < l1) return -1\n        arr.indexOf(l2)\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpzl8g6a0s.scala:17:15 -----------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mif\e[0m (l2 < l3 || l2 < l1) \e[33mreturn\e\
    [0m -\e[31m1\e[0m\n\e[31m\e[31m   |\e[0m            ^^^^\e[0m\n\e[31m   |\e[0mNone\
    \ of the overloaded alternatives of \e[33mmethod\e[0m \e[35m<\e[0m in \e[33mclass\e\
    [0m \e[35mLong\e[0m with types\n\e[31m   |\e[0m (x: Double): Boolean\n\e[31m \
    \  |\e[0m (x: Float): Boolean\n\e[31m   |\e[0m (x: Long): Boolean\n\e[31m   |\e\
    [0m (x: Int): Boolean\n\e[31m   |\e[0m (x: Char): Boolean\n\e[31m   |\e[0m (x:\
    \ Short): Boolean\n\e[31m   |\e[0m (x: Byte): Boolean\n\e[31m   |\e[0mmatch arguments\
    \ ((l3 : List[Long]))\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpzl8g6a0s.scala:18:15\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (l3\
    \ < l2 || l3 < l1) \e[33mreturn\e[0m -\e[31m1\e[0m\n\e[31m\e[31m   |\e[0m    \
    \        ^^^^\e[0m\n\e[31m   |\e[0mvalue < is not a member of List[Long], but\
    \ could be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mOne of the following imports might make progress towards fixing the problem:\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Ordered.orderingToOrdered\n\e[31m\
    \   |\e[0m  import math.Ordering.Implicits.infixOrderingOps\n\e[31m   |\e[0m\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659978831
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        val l = arr.length\n        val h = arr.toList.drop(1).max\n\
    \        val r = arr.toList.drop(1).min\n        val max = arr.max\n        if\
    \ (l!=0)\n        {\n            if (l>=h)\n                -1\n            else\n\
    \            {\n                if (r>max)\n                    -1\n         \
    \       else\n                    r\n            }\n        }\n        else\n\
    \        {\n            if (l>=max)\n                -1\n            else\n  \
    \          {\n                if (r>max)\n                    -1\n           \
    \     else\n                    r\n            }\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong,\
    \ 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpel04e23i.scala:44)\n\tat Problem.main(tmpel04e23i.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978832
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        // Write your code here\n        var maxIndex = -1\n   \
    \     var currentIndex = 0\n        arr.foreach( i => {\n            if(i <= arr(currentIndex))\
    \ maxIndex = currentIndex\n            currentIndex += 1\n        })\n       \
    \ maxIndex\n    }\n    def main(args: Array[String]) = {\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp69914yfw.scala:24)\n\tat Problem.main(tmp69914yfw.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978832
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        var i = 0\n        arr.foreach(i => {\n            if (i\
    \ > 0) return i\n        })\n        return -1\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong,\
    \ 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp10x5pbva.scala:21)\n\tat Problem.main(tmp10x5pbva.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978833
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        var largest = arr.head\n        var largestIndex = 0\n \
    \       var smallest = arr.head\n        var smallestIndex = 0\n        for( x\
    \ <- arr.tail) {\n            if( x < smallest) {\n                smallestIndex\
    \ = arr.indexOf(x)\n                smallest = x\n            }\n            else\
    \ if( x > largest) {\n                largestIndex = arr.indexOf(x)\n        \
    \        largest = x\n            }\n        }\n        if(smallest == arr.head\
    \ && largestIndex == 0) {\n            -1\n        }\n        else if(largest\
    \ == arr.head && largestIndex == 1) {\n            -1\n        }\n        else\
    \ if(smallest == arr.head && largestIndex == -1) {\n            -1\n        }\n\
    \        else if(smallest == arr.head && largestIndex == arr.size-1) {\n     \
    \       -1\n        }\n        else if(smallest == arr.head && largestIndex ==\
    \ arr.size-2) {\n            -1\n        }\n        else {\n            largestIndex\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmphstic5xt.scala:48)\n\tat Problem.main(tmphstic5xt.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978833
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        val len = arr.size\n        var index = 0\n        var largest\
    \ = 0L\n\n        for(i <- 0 until len) {\n            index = i\n           \
    \ largest = max(index, largest)\n        }\n\n        if(largest == -1l) -1l\n\
    \        else if(arr.contains(largest)) -1\n        else {\n            val lastIndex\
    \ = arr.lastIndexWhere(elem => elem > largest)\n            arr.find(elem => elem\
    \ < lastIndex && elem > largest).map(elem => index).getOrElse(-1)\n        }\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp51mc38zc.scala:31)\n\tat Problem.main(tmp51mc38zc.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978834
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        val max = arr.last\n        for (i <- 0 until arr.length)\
    \ {\n            if(arr(i) > max) {\n                return -1\n            }\n\
    \        }\n        return max\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(canArrange((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong,\
    \ 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpf4itzxe9.scala:23)\n\tat Problem.main(tmpf4itzxe9.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978833
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        if (arr.isEmpty) -1\n        else {\n            val maxIndex\
    \ = arr.toList.maxIndex(l => { l >= arr(0); l })\n            if (maxIndex ==\
    \ -1) -1 else maxIndex\n        }\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong,\
    \ 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp2pttk17n.scala:16:38 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m            \e[33mval\e[0m \e[36mmaxIndex\e[0m = arr.toList.maxIndex(\e\
    [36ml\e[0m => { l >= arr(\e[31m0\e[0m); l })\n\e[31m\e[31m   |\e[0m          \
    \                 ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                  \
    \         value maxIndex is not a member of List[Long]\n1 error found\n"
  stdout: ''
  timestamp: 1659978834
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        var index : Long = -1l\n        var prev : Long = -1l\n\
    \        for (i <- 0 until arr.length) {\n            if (arr(i) > arr(prev))\
    \ {\n                index = i\n            }\n            prev = i\n        }\n\
    \        return index\n    }\n    def main(args: Array[String]) = {\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpkum3wmnr.scala:17:29\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m            \e[33mif\e[0m (arr(i)\
    \ > arr(prev)) {\n\e[31m\e[31m   |\e[0m                             ^^^^\e[0m\n\
    \e[31m   |\e[0m                             Found:    (prev : Long)\n\e[31m  \
    \ |\e[0m                             Required: Int\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659978836
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        if (arr.isEmpty) -1\n        else {\n            var maxIndex\
    \ = 0\n            var currentValue = arr.get(0)\n\n            for (index <-\
    \ 1 until arr.size) {\n                if (arr(index) < currentValue) {\n    \
    \                maxIndex = index\n                    currentValue = arr(index)\n\
    \                }\n            }\n\n            maxIndex\n        }\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpblawjb8c.scala:17:35 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m            \e[33mvar\e[0m \e[36mcurrentValue\e[0m =\
    \ arr.get(\e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m                               ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m         value get is not a member of List[Long] - did you\
    \ mean arr.seq?\n1 error found\n"
  stdout: ''
  timestamp: 1659978836
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        val r = arr.scanLeft(-1)((r,v) =>\n            if(v >= r)\
    \ r else v\n        )\n        r.getOrElse(-1)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong,\
    \ 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp8m6rc9rn.scala:15:30\
    \ --------------------\e[0m\e[0m\n\e[31m15 |\e[0m            \e[33mif\e[0m(v >=\
    \ r) r \e[33melse\e[0m v\n\e[31m\e[31m   |\e[0m                              ^\e\
    [0m\n\e[31m   |\e[0m                              Found:    (v : Long)\n\e[31m\
    \   |\e[0m                              Required: Int\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp8m6rc9rn.scala:17:10 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        r.getOrElse(-\e[31m1\e[0m)\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        value getOrElse is not a member\
    \ of List[Int]\n2 errors found\n"
  stdout: ''
  timestamp: 1659978836
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        var biggest = 0\n        var index = 1\n        for(i <-\
    \ 0 until arr.length) {\n            if(arr(i) >= arr(biggest)) {\n          \
    \      biggest = i\n            } else {\n                index += 1\n       \
    \     }\n        }\n        if(index == arr.length) {\n            return -1\n\
    \        }\n        return biggest\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong,\
    \ 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpd0nfen06.scala:29)\n\tat Problem.main(tmpd0nfen06.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978839
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        // First we check to see if any elements are greater than\
    \ or equal to the\n        // element immediately preceding the current element.\
    \ If so return the\n        // index of the last element which is greater than\
    \ or equal to the current\n        // element.\n        var bigger : Long = -1\n\
    \        var i : Long = arr.length\n        while ( i >= 0 ) {\n            if\
    \ (arr(i) >= arr(i-1)) bigger = i\n            else i--\n        }\n        //\
    \ If we did not find any larger elements then return -1\n        if (bigger ==\
    \ -1) return -1\n        // If we did find an element that is greater than or\
    \ equal to the previous\n        // element then return the last index of the\
    \ element that is greater than\n        // or equal to the previous element.\n\
    \        bigger\n    }\n    def main(args: Array[String]) = {\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpqrmpqp6y.scala:22:20 ---------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m            \e[33melse\e[0m i--\n\e[31m\e[31m   |\e[0m\
    \                    ^\e[0m\n\e[31m   |\e[0m                    expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpqrmpqp6y.scala:21:20 --------------------\e[0m\e[0m\n\e[31m21\
    \ |\e[0m            \e[33mif\e[0m (arr(i) >= arr(i-\e[31m1\e[0m)) bigger = i\n\
    \e[31m\e[31m   |\e[0m                    ^\e[0m\n\e[31m   |\e[0m             \
    \       Found:    (i : Long)\n\e[31m   |\e[0m                    Required: Int\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpqrmpqp6y.scala:21:30\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m            \e[33mif\e[0m (arr(i)\
    \ >= arr(i-\e[31m1\e[0m)) bigger = i\n\e[31m\e[31m   |\e[0m                  \
    \            ^^^\e[0m\n\e[31m   |\e[0m                              Found:   \
    \ Long\n\e[31m   |\e[0m                              Required: Int\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1659978838
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        val l = arr.length\n        arr.foldLeft(-1)((maxIndex,\
    \ currentValue, currentIndex) => {\n            if ((currentIndex < 0) && (currentValue\
    \ <= arr(maxIndex))) maxIndex else currentIndex\n        })\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong,\
    \ 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E086] Syntax Error: /tmp/tmpy_m0h2oc.scala:15:64 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        arr.foldLeft(-\e[31m1\e[0m)((\e[36mmaxIndex\e\
    [0m, \e[36mcurrentValue\e[0m, \e[36mcurrentIndex\e[0m) => {\n\e[31m\e[31m   |\e\
    [0m                         ^\e[0m\n\e[31m   |\e[0m                         Wrong\
    \ number of parameters, expected: 2\n\e[31m16 |\e[0m            \e[33mif\e[0m\
    \ ((currentIndex < \e[31m0\e[0m) && (currentValue <= arr(maxIndex))) maxIndex\
    \ \e[33melse\e[0m currentIndex\n\e[31m17 |\e[0m        })\n1 error found\n"
  stdout: ''
  timestamp: 1659978834
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        // Solution here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong,\
    \ 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpp4n4fyfe.scala:13:46\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m    \e[33mdef\e[0m \e[36mcanArrange\e\
    [0m(\e[36marr\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m]) : \e[35mLong\e[0m = {\n\
    \e[31m\e[31m   |\e[0m                                              ^\e[0m\n\e\
    [31m   |\e[0m                                              Found:    Unit\n\e\
    [31m   |\e[0m                                              Required: Long\n\e\
    [31m14 |\e[0m        \e[34m// Solution here\e[0m\n\e[31m15 |\e[0m    }\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659978837
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        val maxIndex = arr.lastIndexWhere(elem => elem >= arr.last)\n\
    \        if(maxIndex == -1) -1\n        else maxIndex\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong,\
    \ 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5pmqn9o9.scala:19)\n\tat Problem.main(tmp5pmqn9o9.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978839
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        var maxIndex = -1L\n        val indexSet = mutable.Set[Long]()\n\
    \        for(i <- 0 until arr.length - 1){\n            if(arr(i) <= arr(i+1)){\n\
    \                maxIndex = i +1\n            } else {\n                indexSet\
    \ += arr(i)\n            }\n        }\n        if(indexSet.size == 0){\n     \
    \       -1\n        } else {\n            maxIndex\n        }\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp4n4fibdt.scala:15:23 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mindexSet\e[0m = mutable.Set[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                       ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                       Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659978836
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        var max = -1L\n        var maxIndex = 0L\n        var currentMax\
    \ = 0L\n        var i = 1L\n        while(i <= arr.length) {\n            if(arr(i)\
    \ > max) {\n                max = arr(i)\n                maxIndex = i\n     \
    \           currentMax = max\n            } else {\n                if(arr(i)\
    \ <= currentMax) {\n                    currentMax = arr(i)\n                }\n\
    \            }\n            i += 1\n        }\n        return maxIndex\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpnbb1t4ga.scala:19:19\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            \e[33mif\e[0m(arr(i)\
    \ > max) {\n\e[31m\e[31m   |\e[0m                   ^\e[0m\n\e[31m   |\e[0m  \
    \                 Found:    (i : Long)\n\e[31m   |\e[0m                   Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpnbb1t4ga.scala:20:26\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m                max = arr(i)\n\
    \e[31m\e[31m   |\e[0m                          ^\e[0m\n\e[31m   |\e[0m       \
    \                   Found:    (i : Long)\n\e[31m   |\e[0m                    \
    \      Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpnbb1t4ga.scala:24:23\
    \ --------------------\e[0m\e[0m\n\e[31m24 |\e[0m                \e[33mif\e[0m(arr(i)\
    \ <= currentMax) {\n\e[31m\e[31m   |\e[0m                       ^\e[0m\n\e[31m\
    \   |\e[0m                       Found:    (i : Long)\n\e[31m   |\e[0m       \
    \                Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpnbb1t4ga.scala:25:37 --------------------\e[0m\e[0m\n\e[31m25\
    \ |\e[0m                    currentMax = arr(i)\n\e[31m\e[31m   |\e[0m       \
    \                              ^\e[0m\n\e[31m   |\e[0m                       \
    \              Found:    (i : Long)\n\e[31m   |\e[0m                         \
    \            Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659978839
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        val m = arr.head\n        var maxVal = 0\n        var maxIndex\
    \ = -1\n        for (i <- arr diff arr) {\n            if (i <= m) {\n       \
    \         maxVal = i\n                maxIndex = i\n            }\n        }\n\
    \        maxIndex\n    }\n    def main(args: Array[String]) = {\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpg4ku6xif.scala:19:25\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m                maxVal = i\n\e\
    [31m\e[31m   |\e[0m                         ^\e[0m\n\e[31m   |\e[0m          \
    \               Found:    (i : Long)\n\e[31m   |\e[0m                        \
    \ Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpg4ku6xif.scala:20:27\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m                maxIndex = i\n\
    \e[31m\e[31m   |\e[0m                           ^\e[0m\n\e[31m   |\e[0m      \
    \                     Found:    (i : Long)\n\e[31m   |\e[0m                  \
    \         Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659978839
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        var maxi = -1L\n        var maxElem = arr(0)\n        for\
    \ (elem <- arr.drop(1)) {\n            if (elem <= maxElem) {\n              \
    \  maxElem = elem\n                maxi = arr.indexOfMax\n            }\n    \
    \    }\n        maxi\n    }\n    def main(args: Array[String]) = {\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmph2r1xjnh.scala:19:27 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m                maxi = arr.indexOfMax\n\e[31m\e[31m \
    \  |\e[0m                       ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue indexOfMax\
    \ is not a member of List[Long] - did you mean arr.indexOf?\n1 error found\n"
  stdout: ''
  timestamp: 1659978839
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        val max = arr(0l)\n        var index = -1l\n        for\
    \ (x <- arr)\n            if (x >= max)\n                index = x\n         \
    \   else\n                max = x\n        index\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong,\
    \ 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp075dsxgx.scala:14:22\
    \ --------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mmax\e\
    [0m = arr(\e[31m0l\e[0m)\n\e[31m\e[31m   |\e[0m                      ^^\e[0m\n\
    \e[31m   |\e[0m                      Found:    (\e[31m0L\e[0m : Long)\n\e[31m\
    \   |\e[0m                      Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E052] Type Error: /tmp/tmp075dsxgx.scala:20:20 -----------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m                max = x\n\e[31m\e[31m   |\e[0m      \
    \          ^^^^^^^\e[0m\n\e[31m   |\e[0m                Reassignment to val max\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659978839
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        val low = arr(arr.head._ - 1)\n        arr.indexWhere(_\
    \ < low)\n    }\n    def main(args: Array[String]) = {\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpcoh_hn5m.scala:14:31 ---------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mlow\e[0m = arr(arr.head._\
    \ - \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m                               ^\e[0m\n\
    \e[31m   |\e[0m                               an identifier expected, but '_'\
    \ found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659978837
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        var maxI = -1l\n        var prev = -1l\n        val arr2\
    \ = arr.toList\n        arr2.sortWith(_ < _)\n        for (i <- 0 until arr2.length)\
    \ {\n            if (arr2(i) > (prev+1)) {\n                maxI = i\n       \
    \     }\n            prev = arr2(i)\n        }\n        return maxI\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp4ym3diuc.scala:27)\n\tat Problem.main(tmp4ym3diuc.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978843
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        var result : Long = -1\n        var index : Long = -1\n\
    \        val size = arr.size\n        if (size == 0) return -1\n        for (i\
    \ <- 0 until size - 1) {\n            if (index < 0 || arr(i) < arr(index)) {\n\
    \                result = i\n                index = i\n            }\n      \
    \  }\n        return result\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(canArrange((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\
    \ == (3l));\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong, 4l.toLong,\
    \ 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong, 4l.toLong,\
    \ 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong, 10l.toLong)))\
    \ == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong, 5l.toLong,\
    \ 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]())) ==\
    \ (-1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpkyfhbb5v.scala:19:42\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            \e[33mif\e[0m (index\
    \ < \e[31m0\e[0m || arr(i) < arr(index)) {\n\e[31m\e[31m   |\e[0m            \
    \                              ^^^^^\e[0m\n\e[31m   |\e[0m                   \
    \                       Found:    (index : Long)\n\e[31m   |\e[0m            \
    \                              Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659978842
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        val l = arr.length\n        val maxIndex = -1L\n       \
    \ var currentIndex = 0\n\n        // Go through the array and find if element\
    \ will be greater than or equal to the\n        // previous one. If yes, update\
    \ maxIndex with current index\n        while (currentIndex < l) {\n          \
    \  if (arr(currentIndex) > arr(currentIndex - 1)) {\n                maxIndex\
    \ = currentIndex\n            }\n            currentIndex += 1\n        }\n\n\
    \        // If maxIndex is less than or equal to -1, means no such element exists,\
    \ so return -1\n        if (maxIndex <= -1L) {\n            -1L\n        } else\
    \ {\n            maxIndex\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong,\
    \ 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmpgih_gfus.scala:22:25 -----------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m                maxIndex = currentIndex\n\e[31m\e[31m\
    \   |\e[0m                ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \          Reassignment to val maxIndex\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659978839
- exit_code: -1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        if (arr.isEmpty)\n            return -1\n        var lastIndex\
    \ = arr.head\n        var index = 1\n        while (index < arr.length) {\n  \
    \          if (arr(index) >= lastIndex) {\n                lastIndex = arr(index)\n\
    \            } else {\n                index += 1 // move to next element\n  \
    \          }\n        }\n        return lastIndex\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong,\
    \ 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1659978847
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        // Initialize a counter and store its initial value\n  \
    \      var counter : Long = 0\n\n        // Iterate through the list and compare\
    \ each element to the element before\n        // it. If a value greater than or\
    \ equal to the previous element is found\n        // then increment the counter.\n\
    \        // This approach is O(n). No matter what approach we use, this will run\n\
    \        // in O(n).\n        for (elem <- arr) {\n            if (arr(counter)\
    \ <= elem) {\n                counter += 1\n            }\n            else {\n\
    \                // The element is not greater than or equal to the element before\n\
    \                // it, so return counter.\n                return counter\n \
    \           }\n        }\n        // If the array has one element, then it equals\
    \ the previous element.\n        return counter\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong,\
    \ 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpe5nmhjh_.scala:23:20\
    \ --------------------\e[0m\e[0m\n\e[31m23 |\e[0m            \e[33mif\e[0m (arr(counter)\
    \ <= elem) {\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                    Found:    (counter : Long)\n\e[31m   |\e[0m      \
    \              Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659978844
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        var maxIndex : Long = -1l\n        for (i <- 0 until arr.length)\
    \ {\n            if (arr(i) > arr(i-1)) {\n                maxIndex = i\n    \
    \        } else if (arr(i) < arr(i-1)) {\n                val tmp = arr(i)\n \
    \               arr(i) = arr(i-1)\n                arr(i-1) = tmp\n          \
    \  }\n        }\n        if (maxIndex < 0)\n            -1\n        else\n   \
    \         maxIndex\n    }\n    def main(args: Array[String]) = {\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp6afz2fjv.scala:20:16 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m                arr(i) = arr(i-\e[31m1\e[0m)\n\e[31m\e\
    [31m   |\e[0m                ^^^\e[0m\n\e[31m   |\e[0m  value update is not a\
    \ member of List[Long] - did you mean arr.updated?\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmp6afz2fjv.scala:21:16 ------------------------\e[0m\e[0m\n\
    \e[31m21 |\e[0m                arr(i-\e[31m1\e[0m) = tmp\n\e[31m\e[31m   |\e[0m\
    \                ^^^\e[0m\n\e[31m   |\e[0m  value update is not a member of List[Long]\
    \ - did you mean arr.updated?\n2 errors found\n"
  stdout: ''
  timestamp: 1659978845
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        val maxIndex = arr.indices.max\n        if (arr.exists(_\
    \ >= arr(maxIndex-1)))\n            -1\n        else\n            maxIndex\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpkkag819_.scala:21)\n\tat Problem.main(tmpkkag819_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978846
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        val n = arr.size\n        val max = arr.last\n        var\
    \ j = 1\n        var pos = 0\n        var k = n - 1\n        while (pos < n) {\n\
    \            if (max < arr(pos + 1)) {\n                pos = k\n            \
    \    j = 1\n                max += 1\n            }\n            j += 1\n    \
    \        pos += 1\n        }\n        if (j == 1) -1\n        else {\n       \
    \     if (pos > 1) max(pos - 1, j - 1, j - 2)\n            else\n            \
    \    max(j - 1)\n        }\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(canArrange((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\
    \ == (3l));\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong, 4l.toLong,\
    \ 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong, 4l.toLong,\
    \ 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong, 10l.toLong)))\
    \ == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong, 5l.toLong,\
    \ 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]())) ==\
    \ (-1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpwxok1spl.scala:23:20 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m                max += \e[31m1\e[0m\n\e[31m\e[31m   |\e\
    [0m                ^^^^^^\e[0m\n\e[31m   |\e[0m                value += is not\
    \ a member of Long - did you mean max.!=?\n\e[31m\e[31m-- [E050] Type Error: /tmp/tmpwxok1spl.scala:30:25\
    \ -----------------------------\e[0m\e[0m\n\e[31m30 |\e[0m            \e[33mif\e\
    [0m (pos > \e[31m1\e[0m) max(pos - \e[31m1\e[0m, j - \e[31m1\e[0m, j - \e[31m2\e\
    [0m)\n\e[31m\e[31m   |\e[0m                         ^^^\e[0m\n\e[31m   |\e[0m\
    \                         \e[33mvalue\e[0m \e[35mmax\e[0m does not take parameters\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E050] Type Error: /tmp/tmpwxok1spl.scala:32:16 -----------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m                max(j - \e[31m1\e[0m)\n\e[31m\e[31m \
    \  |\e[0m                ^^^\e[0m\n\e[31m   |\e[0m                \e[33mvalue\e\
    [0m \e[35mmax\e[0m does not take parameters\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659978845
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        // Your code here\n        var maxIdx = 0\n        var maxVal\
    \ = arr(0)\n        for (idx <- arr.indices) {\n            if (arr(idx) < maxVal)\
    \ {\n                maxIdx = idx\n            } else {\n                maxVal\
    \ = arr(idx)\n            }\n        }\n        maxIdx\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong,\
    \ 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpm9holfje.scala:28)\n\tat Problem.main(tmpm9holfje.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978847
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        var i = 0\n        var max = -1\n        arr.foreach( x\
    \ => if(x > max) max = x ) \n        i += 1\n        while( i < arr.length &&\
    \ max >= arr(i)) {\n            max = arr(i)\n            i += 1\n        }\n\
    \        if(max < arr(0)) -1\n        else max\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong,\
    \ 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpv44pbksa.scala:16:44\
    \ --------------------\e[0m\e[0m\n\e[31m16 |\e[0m        arr.foreach( \e[36mx\e\
    [0m => \e[33mif\e[0m(x > max) max = x ) \n\e[31m\e[31m   |\e[0m              \
    \                              ^\e[0m\n\e[31m   |\e[0m                       \
    \                     Found:    (x : Long)\n\e[31m   |\e[0m                  \
    \                          Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpv44pbksa.scala:19:21 --------------------\e[0m\e\
    [0m\n\e[31m19 |\e[0m            max = arr(i)\n\e[31m\e[31m   |\e[0m          \
    \        ^^^^^^\e[0m\n\e[31m   |\e[0m                  Found:    Long\n\e[31m\
    \   |\e[0m                  Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659978846
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        var maxIndex = -1\n        var maxValue = arr(0).toLong\n\
    \        var index = 0\n        arr.foreach {x =>\n            if (x > 0l) {\n\
    \                if (maxIndex == -1) {\n                    maxIndex = index\n\
    \                    maxValue = x\n                } else {\n                \
    \    if (x > maxValue) {\n                        maxIndex = index\n         \
    \               maxValue = x\n                    }\n                }\n     \
    \       }\n            index += 1\n        }\n        if (maxIndex == -1) {\n\
    \            return -1\n        } else {\n            return maxIndex\n      \
    \  }\n    }\n    def main(args: Array[String]) = {\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp2rv4sego.scala:38)\n\tat Problem.main(tmp2rv4sego.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978849
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        if (arr.isEmpty) return -1\n\n        var maxIdx = -1\n\
    \        var currIdx = -1\n\n        for (i <- 0 until arr.size) {\n         \
    \   currIdx = i\n\n            if (arr(i) < arr[currIdx]) maxIdx = currIdx\n \
    \           if (arr(i) > arr[currIdx]) break\n\n        }\n\n        maxIdx\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpsidpt09f.scala:22:29 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m            \e[33mif\e[0m (arr(i) < arr[\e[35mcurrIdx\e\
    [0m]) maxIdx = currIdx\n\e[31m\e[31m   |\e[0m                             ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                             Not found: type currIdx\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpsidpt09f.scala:23:29 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            \e[33mif\e[0m (arr(i) > arr[\e[35mcurrIdx\e\
    [0m]) break\n\e[31m\e[31m   |\e[0m                             ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                             Not found: type currIdx\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpsidpt09f.scala:23:39 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            \e[33mif\e[0m (arr(i) > arr[\e[35mcurrIdx\e\
    [0m]) break\n\e[31m\e[31m   |\e[0m                                       ^^^^^\e\
    [0m\n\e[31m   |\e[0m                                       Not found: break\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659978844
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        val i = arr.length\n        arr.foldLeft(-1){case (i, x)\
    \ => if (x > arr(i-1)) return i-1 else i}\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong,\
    \ 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: -2\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:115)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.canArrange$$anonfun$1(tmpolfg7pnz.scala:15)\n\tat scala.runtime.java8.JFunction2$mcIIJ$sp.apply(JFunction2$mcIIJ$sp.scala:17)\n\
    \tat scala.collection.LinearSeqOps.foldLeft(LinearSeq.scala:169)\n\tat scala.collection.LinearSeqOps.foldLeft$(LinearSeq.scala:165)\n\
    \tat scala.collection.immutable.List.foldLeft(List.scala:79)\n\tat Problem$.canArrange(tmpolfg7pnz.scala:15)\n\
    \tat Problem$.main(tmpolfg7pnz.scala:18)\n\tat Problem.main(tmpolfg7pnz.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978849
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        val m = arr.head\n        var n = arr.tail.length\n    \
    \    var max = 0\n        while( n >= 1 ) {\n            if ( arr(n-1) > m ) max\
    \ = n\n            n--\n        }\n        if ( max == -1 ) -1\n        else max\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpyvgnwort.scala:19:15 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m            n--\n\e[31m\e[31m   |\e[0m              \
    \ ^\e[0m\n\e[31m   |\e[0m               expression expected but \e[31m'}'\e[0m\
    \ found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659978844
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        if (arr.isEmpty) -1\n        else {\n            val i =\
    \ arr.indexOf(0)\n            if (i > -1) arr.indexOf(i) else -1\n        }\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpt8bpt4zk.scala:21)\n\tat Problem.main(tmpt8bpt4zk.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978849
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        // Your code goes here!\n        val maxIndex = arr.length\
    \ - 1\n        var index = maxIndex\n        while (!arr.exists(_ > arr(index)))\
    \ {\n            index += 1\n        }\n        index\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong,\
    \ 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 5\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.canArrange$$anonfun$1(tmpd9noum0s.scala:17)\n\tat scala.runtime.java8.JFunction1$mcZJ$sp.apply(JFunction1$mcZJ$sp.scala:17)\n\
    \tat scala.collection.immutable.List.exists(List.scala:395)\n\tat Problem$.canArrange(tmpd9noum0s.scala:17)\n\
    \tat Problem$.main(tmpd9noum0s.scala:23)\n\tat Problem.main(tmpd9noum0s.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978849
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        // Store the largest seen index so far by adding 1 to it\n\
    \        var largestSeen = -1\n\n        // Iterate through the list once\n  \
    \      var i = 0\n        while (i < arr.length) {\n            // If this index\
    \ is greater than or equal to what we've seen\n            // so far, that means\
    \ we have seen it before, and this is\n            // the biggestSeen, so increment\
    \ it and return\n            if (arr(i) < largestSeen) largestSeen = i + 1\n \
    \           // If we have seen the entire list, we can't have seen any greater\n\
    \            else return -1\n            i += 1\n        }\n        largestSeen\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpdseke5nn.scala:31)\n\tat Problem.main(tmpdseke5nn.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978850
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        var maxIndex : Long = -1\n        var maxNum : Long = -1\n\
    \        var max : Long = -1\n        for(i <- arr.iterator){\n            if(maxNum\
    \ < 0){\n                maxNum = i\n                maxIndex = i\n          \
    \  }\n            if(max < 0){\n                max = i\n            }\n     \
    \       else if(max > i){\n                maxIndex = maxNum\n               \
    \ maxNum = i\n            }\n        }\n        if(maxNum == -1){\n          \
    \  -1\n        }else{\n            maxIndex\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong,\
    \ 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp94r8gaz8.scala:37)\n\tat Problem.main(tmp94r8gaz8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978851
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        val sortedArr = arr.toList.sort\n        val res = -1\n\
    \        var i = 1\n        var lastElement = -1\n        while (i < sortedArr.length)\
    \ {\n            if (sortedArr(i) <= sortedArr(lastElement)) {\n             \
    \   lastElement = i\n            } else {\n                res = i\n         \
    \   }\n            i += 1\n        }\n        res\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong,\
    \ 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpwac9bfwb.scala:14:35 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36msortedArr\e[0m = arr.toList.sort\n\
    \e[31m\e[31m   |\e[0m                        ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mvalue sort is not a member of List[Long] - did you mean List[Long].sortBy?\n\
    \e[31m\e[31m-- [E052] Type Error: /tmp/tmpwac9bfwb.scala:22:20 -----------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m                res = i\n\e[31m\e[31m   |\e[0m      \
    \          ^^^^^^^\e[0m\n\e[31m   |\e[0m                Reassignment to val res\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659978849
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        var ans = -1\n        for (i <- 0 until arr.length) {\n\
    \            if (arr.apply(i) >= arr.apply(i+1)) {\n                ans = arr.apply(i+1)\n\
    \            }\n        }\n        if (ans == -1) {\n            ans\n       \
    \ } else {\n            -1\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong,\
    \ 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpdjn1wqtf.scala:17:31\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m                ans = arr.apply(i+\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Found:    Long\n\e[31m   |\e[0m           \
    \           Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659978849
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        // Your code here\n        if (arr.isEmpty) -1\n       \
    \ else arr.maxIndex { \n        case i if (i > 0) => arr.slice(0, i).foldLeft(-1)(_\
    \ max _)\n        case _ => -1\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong,\
    \ 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpguhv2mk6.scala:16:17 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33melse\e[0m arr.maxIndex { \n\e[31m\e[31m\
    \   |\e[0m             ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m             value maxIndex\
    \ is not a member of List[Long]\n1 error found\n"
  stdout: ''
  timestamp: 1659978849
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        if(arr.isEmpty) -1\n        else {\n            val largest\
    \ = arr.last\n            val index = arr.indexWhere(elem => elem < largest)\n\
    \            if(index > -1) index else -1\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong,\
    \ 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmppjo6bm1h.scala:22)\n\tat Problem.main(tmppjo6bm1h.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978851
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        var max : Long = -1\n        var i : Long = 0\n        while\
    \ (i < arr.length) {\n            if (arr(i) <= arr(i-1)) max = arr(i)\n     \
    \       else i += 1\n        }\n        max\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong,\
    \ 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpwfwoxorc.scala:17:20\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m            \e[33mif\e[0m (arr(i)\
    \ <= arr(i-\e[31m1\e[0m)) max = arr(i)\n\e[31m\e[31m   |\e[0m                \
    \    ^\e[0m\n\e[31m   |\e[0m                    Found:    (i : Long)\n\e[31m \
    \  |\e[0m                    Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpwfwoxorc.scala:17:30 --------------------\e[0m\e\
    [0m\n\e[31m17 |\e[0m            \e[33mif\e[0m (arr(i) <= arr(i-\e[31m1\e[0m))\
    \ max = arr(i)\n\e[31m\e[31m   |\e[0m                              ^^^\e[0m\n\e\
    [31m   |\e[0m                              Found:    Long\n\e[31m   |\e[0m   \
    \                           Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpwfwoxorc.scala:17:46 --------------------\e[0m\e\
    [0m\n\e[31m17 |\e[0m            \e[33mif\e[0m (arr(i) <= arr(i-\e[31m1\e[0m))\
    \ max = arr(i)\n\e[31m\e[31m   |\e[0m                                        \
    \      ^\e[0m\n\e[31m   |\e[0m                                              Found:\
    \    (i : Long)\n\e[31m   |\e[0m                                             \
    \ Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659978851
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        val size = arr.size\n        var maxIdx : Long = -1\n  \
    \      for ( i <- 0 until size ) {\n            if ( arr(i) < arr(maxIdx) ) {\n\
    \                maxIdx = i\n            }\n        }\n        if ( maxIdx ==\
    \ -1 ) {\n            -1\n        } else {\n            maxIdx\n        }\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp3kcv_3wb.scala:17:30\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m            \e[33mif\e[0m ( arr(i)\
    \ < arr(maxIdx) ) {\n\e[31m\e[31m   |\e[0m                              ^^^^^^\e\
    [0m\n\e[31m   |\e[0m                              Found:    (maxIdx : Long)\n\e\
    [31m   |\e[0m                              Required: Int\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659978851
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        var maxIndex : Long = -1\n        var currentIndex : Long\
    \ = -1\n        arr.foreach { x =>\n            currentIndex = currentIndex +\
    \ 1\n            if (x < arr(currentIndex)) {\n                if (maxIndex <\
    \ currentIndex) {\n                    maxIndex = currentIndex\n             \
    \   }\n            }\n        }\n        maxIndex\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong,\
    \ 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp3lz5zns4.scala:18:24\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m            \e[33mif\e[0m (x\
    \ < arr(currentIndex)) {\n\e[31m\e[31m   |\e[0m                        ^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                        Found:    (currentIndex : Long)\n\e\
    [31m   |\e[0m                        Required: Int\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659978852
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        arr.map(i => (arr.indexOf(i)).max ) match {\n          \
    \  case -1 => -1\n            case x => x\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong,\
    \ 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpbnjd42ei.scala:15:17 -----------------------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m            \e[33mcase\e[0m -\e[31m1\e[0m => -\e[31m1\e\
    [0m\n\e[31m\e[31m   |\e[0m                 ^^\e[0m\n\e[31m   |\e[0mValues of types\
    \ Int and List[Int => Int] cannot be compared with == or !=\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpbnjd42ei.scala:16:22 --------------------\e[0m\e\
    [0m\n\e[31m16 |\e[0m            \e[33mcase\e[0m x => x\n\e[31m\e[31m   |\e[0m\
    \                      ^\e[0m\n\e[31m   |\e[0m                      Found:   \
    \ (x : List[Int => Int])\n\e[31m   |\e[0m                      Required: Long\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659978853
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        var maxIndex = -1L\n        var currentMax = 0L\n      \
    \  var prevMax = 0L\n        var current = 1\n        var index = 0\n        for\
    \ (elem <- arr) {\n            index += 1\n            if (elem > currentMax)\
    \ {\n                currentMax = elem\n                maxIndex = index\n   \
    \         } else if (elem == currentMax) {\n                if (elem < prevMax)\
    \ {\n                    maxIndex = index\n                }\n            }\n\
    \            current = elem\n            prevMax = currentMax\n        }\n   \
    \     if (maxIndex == -1L) return -1\n        maxIndex\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong,\
    \ 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpdqnos_eb.scala:29:22\
    \ --------------------\e[0m\e[0m\n\e[31m29 |\e[0m            current = elem\n\e\
    [31m\e[31m   |\e[0m                      ^^^^\e[0m\n\e[31m   |\e[0m          \
    \            Found:    (elem : Long)\n\e[31m   |\e[0m                      Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659978853
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        arr.zipWithIndex.maxBy(_._1)._1\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong,\
    \ 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpxw1fec6j.scala:17)\n\tat Problem.main(tmpxw1fec6j.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978854
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        var max = -1l\n        var maxIndex = 0\n        for(index\
    \ <- 0 until arr.size){\n            if( arr(index) < arr(maxIndex) ) max = arr(index)\n\
    \            if( arr(index) == arr(maxIndex) && arr(index) < arr(index-1)) maxIndex\
    \ = index\n        }\n        if(max == -1) return -1\n        else max\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: -1\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:115)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.canArrange$$anonfun$1(tmp_w2rya94.scala:18)\n\tat scala.runtime.java8.JFunction1$mcVI$sp.apply(JFunction1$mcVI$sp.scala:18)\n\
    \tat scala.collection.immutable.Range.foreach(Range.scala:190)\n\tat Problem$.canArrange(tmp_w2rya94.scala:19)\n\
    \tat Problem$.main(tmp_w2rya94.scala:24)\n\tat Problem.main(tmp_w2rya94.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978854
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        var largest = arr.head\n        var index = arr.head\n\n\
    \        for( x <- arr.tail if x < largest ) largest = x\n        largest\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp667yrweg.scala:21)\n\tat Problem.main(tmp667yrweg.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978855
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        var max = -1l\n        for( i <- arr.indices) {\n      \
    \      if ( max < arr(i)) {\n                max = arr(i)\n            }\n   \
    \     }\n        max\n    }\n    def main(args: Array[String]) = {\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpr_brp8se.scala:23)\n\tat Problem.main(tmpr_brp8se.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978854
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        var max = -1l\n        var index = -1\n        arr.foreach\
    \ { elem =>\n            if (elem > max) {\n                max = elem\n     \
    \           index = arr.indexOf(elem)\n            }\n        }\n        if (max\
    \ == -1l) {\n            index = -1\n        }\n        index\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmppggcwvp4.scala:28)\n\tat Problem.main(tmppggcwvp4.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978855
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        var largest = -1l\n        var curIndex = 0\n        for\
    \ (i <- 0 until arr.length-1) {\n            if (arr(i) <= arr(i+1)) {\n     \
    \           largest = i\n            }\n            if (largest == -1) {\n   \
    \             largest = i\n            }\n        }\n        if (largest != -1)\
    \ {\n            val newIndex: Int = arr.lastIndexWhere(x => x <= arr(largest))\n\
    \            largest = arr.apply(newIndex)\n        }\n        largest\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp76vcgm6x.scala:25:65\
    \ --------------------\e[0m\e[0m\n\e[31m25 |\e[0m            \e[33mval\e[0m \e\
    [36mnewIndex\e[0m: \e[35mInt\e[0m = arr.lastIndexWhere(\e[36mx\e[0m => x <= arr(largest))\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \         ^^^^^^^\e[0m\n\e[31m   |\e[0m                                      \
    \        Found:    (largest : Long)\n\e[31m   |\e[0m                         \
    \                     Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659978854
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        if (arr.isEmpty) -1\n        else {\n            val minIndex\
    \ = (arr.indexWhere { i => i <= arr(0) }) match {\n                case Some(i)\
    \ => i\n                case None => -1\n            }\n            val maxIndex\
    \ = (arr.indexWhere { i => i <= arr(arr.size - 1) }) match {\n               \
    \ case Some(i) => i\n                case None => -1\n            }\n        \
    \    if (minIndex < maxIndex) {\n                maxIndex\n            } else\
    \ {\n                -1\n            }\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong,\
    \ 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpjwtsnnr8.scala:18:21\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m                \e[33mcase\e\
    [0m None => -\e[31m1\e[0m\n\e[31m\e[31m   |\e[0m                     ^^^^\e[0m\n\
    \e[31m   |\e[0m                     Found:    None.type\n\e[31m   |\e[0m     \
    \                Required: Int\n\e[31m   |\e[0m                     pattern type\
    \ is incompatible with expected type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpjwtsnnr8.scala:22:21 --------------------\e[0m\e\
    [0m\n\e[31m22 |\e[0m                \e[33mcase\e[0m None => -\e[31m1\e[0m\n\e\
    [31m\e[31m   |\e[0m                     ^^^^\e[0m\n\e[31m   |\e[0m           \
    \          Found:    None.type\n\e[31m   |\e[0m                     Required:\
    \ Int\n\e[31m   |\e[0m                     pattern type is incompatible with expected\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpjwtsnnr8.scala:24:25\
    \ ------------------------\e[0m\e[0m\n\e[31m24 |\e[0m            \e[33mif\e[0m\
    \ (minIndex < maxIndex) {\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mvalue < is not a member of Any, but could be made available as\
    \ an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports\
    \ might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m  import math.Ordered.orderingToOrdered\n\e[31m   |\e[0m  import math.Ordering.Implicits.infixOrderingOps\n\
    \e[31m   |\e[0m\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpjwtsnnr8.scala:25:16\
    \ --------------------\e[0m\e[0m\n\e[31m25 |\e[0m                maxIndex\n\e\
    [31m\e[31m   |\e[0m                ^^^^^^^^\e[0m\n\e[31m   |\e[0m            \
    \    Found:    (maxIndex : Any)\n\e[31m   |\e[0m                Required: Long\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659978855
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        if (arr.isEmpty) -1\n        else {\n            var maxIndex\
    \ = 0\n            var maxValue = arr(0)\n            for(i <- 0 until arr.length)\n\
    \            {\n                if(arr(i) >= maxValue) {\n                   \
    \ maxIndex = i\n                    maxValue = arr(i)\n                }\n   \
    \         }\n            maxIndex\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong,\
    \ 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpxjwwwnz0.scala:29)\n\tat Problem.main(tmpxjwwwnz0.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978855
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        // Write your code here\n        val l = arr.head\n    \
    \    var i = 0\n        while(i < arr.length) {\n            if(arr(i) <= l) {\n\
    \                i += 1\n            } else {\n                break\n       \
    \     }\n        }\n        if(arr.length == i) {\n            return -1\n   \
    \     }\n        return i\n    }\n    def main(args: Array[String]) = {\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp64s0dwk_.scala:21:16 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m                break\n\e[31m\e[31m   |\e[0m        \
    \        ^^^^^\e[0m\n\e[31m   |\e[0m                Not found: break\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659978854
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function which returns the largest index of an element which\n\
    \    // is not greater than or equal to the element immediately preceding it.\
    \ If\n    // no such element exists then return -1. The given list will not contain\n\
    \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long])\
    \ : Long = {\n        var maxIndex = 0\n        var maxValue = arr(0)\n\n    \
    \    for (i <- arr.indices) {\n            if (arr(i) > maxValue) {\n        \
    \        maxValue = arr(i)\n                maxIndex = i\n            }\n    \
    \    }\n        return maxIndex\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(canArrange((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong,\
    \ 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong,\
    \ 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong,\
    \ 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]()))\
    \ == (-1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpjdn_1efh.scala:26)\n\tat Problem.main(tmpjdn_1efh.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978856
