name: HumanEval_120_maximum
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Given a list arr of integers and a positive integer k, return a sorted list\
  \ \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n \
  \   // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    //\
  \ (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>>\
  \ maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong,\
  \ 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong,\
  \ 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n\
  \    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n\
  \    // 2. The elements in the list will be in the range of [-1000, 1000].\n   \
  \ // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long]\
  \ = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
  \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
  \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
  \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
  \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
  \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
  \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
  \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
  \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
  \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
  \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
  \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong,\
  \ 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong,\
  \ 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong,\
  \ -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong,\
  \ -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong,\
  \ 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
  \    }\n\n}\n"
completions: ["        var arr = arr.toList\n        val n = arr.size\n        if(arr.isEmpty)\
    \ List()\n        if(k == 1) arr\n        else if(k > n) arr\n        else if(k\
    \ == n) arr\n        else if(k <= 0 || k > n) throw new IllegalArgumentException(\"\
    k should be in the range of [0, len(arr)]\")\n\n        val sorted = arr.sort\n\
    \        val k = arr.size - 1\n        val result = new scala.collection.mutable.ListBuffer[Long]()\n\
    \        val max = new scala.collection.mutable.ListBuffer[Long]()\n        var\
    \ i : Int = 0\n        var j : Int = 0\n        while(i < n) {\n            while(j\
    \ < n) {\n                if(j > i) {\n                    val tmp = sorted(j)\n\
    \                    if(max contains tmp) {\n                        val index\
    \ = (i + (max - tmp)).max(arr.size - i)\n                        result.append(arr(index))\n\
    \                    } else result.append(arr(j))\n                }\n       \
    \         j+=1\n            }\n            i+=1\n            while(j < n) {\n\
    \                if(max contains sorted(j)) {\n                    val index =\
    \ arr.size - k.max(arr.size - i)\n                    result.append(arr(index))\n\
    \                }\n                j+=1\n            }\n            i+=1\n  \
    \      }\n        result.toList", "        // Code here\n        var maxList =\
    \ List[Long](0,0)\n        var maxIndex = 0\n        for (i <- 0 to arr.size -\
    \ 1) {\n            if(arr(i) > max(maxList))\n            {\n               \
    \ maxIndex = i\n                maxList = arr :: maxList\n            }\n    \
    \    }\n        maxList.take(k).toList", "        // Sort the list in descending\
    \ order\n        val arr = arr.sortBy(math.abs)\n        // Find first k numbers\
    \ in arr\n        val result = Array(k).zip(arr).takeWhile(x => x._1 < x._2).map(_._2)\n\
    \        // Return result\n        result", "        val m = arr.sorted\n    \
    \    val r = k - m.size\n        if(k >= m.size)\n            m ++ m.take(r)\n\
    \        else\n            m", "        def getMax(arr : List[Long], k : Long)\
    \ : List[Long] = {\n            var kmax : Long = k\n            var karr : List[Long]\
    \ = Nil\n            for( i <- 0 until arr.length ) {\n                if( arr(i)\
    \ > kmax ) {\n                    kmax = arr(i)\n                }\n         \
    \   }\n            var arrmax : List[Long] = Nil\n            for( i <- 0 until\
    \ kmax ) {\n                val temp = arr.filter( x => x < k).max\n         \
    \       if( temp > karr(i) ) {\n                    karr(i) = temp\n         \
    \       }\n                arrmax = arrmax :+ karr(i)\n            }\n       \
    \     karr.sortWith( _ > _ ).reverse\n        }\n        getMax(arr, k)", "  \
    \      val result = arr.takeOrElse(k, List[Long]())\n        result.sortWith(_\
    \ > _)\n        result", "        require(0 <= k && k <= arr.length, \"Invalid\
    \ parameters: k = \" + k + \", arr.length = \" + arr.length)\n        var l =\
    \ List[Long]()\n        var i = 0\n        while(i<k){\n            val maxElem\
    \ = Math.max(arr(i), arr(i+1))\n            if(maxElem > arr(i)) l += maxElem\n\
    \            else l += arr(i)\n            i+=1\n        }\n        return l.sortBy(l\
    \ => -l)", "        var max = new scala.collection.mutable.ArrayList[Long](k)\n\
    \        var i = 0\n        for (e <- arr) {\n            if (!max.contains(e))\
    \ {\n                max += e\n                if (i == k - 1) {\n           \
    \         i -= 1\n                    if (max.size < k) {\n                  \
    \      new scala.collection.mutable.ArrayList[Long](k - max.size).+=(max.toList)\n\
    \                    } else {\n                        max.+=(max.toList)\n  \
    \                  }\n                }\n            }\n        }\n        max.toList",
  "        val max = math.max(arr(0), arr(arr.length - 1)) / k\n        arr.take(arr.length\
    \ - k) match {\n            case List() => List(max)\n            case _ => arr\
    \ sortBy (math.abs _) take arr.length - k ++ List(max)\n        }", "        var\
    \ arr = arr\n        if (arr.length < 1 || k > arr.length)\n            return\
    \ null\n        var maxSize : Long = arr.size\n        var maxNums : List[Long]\
    \ = null\n        var maxNum : Long = 0l\n        var j = 0\n        var i = 0\n\
    \        while (i < arr.length) {\n            while (j < arr.length) {\n    \
    \            if (arr(j) < arr(i)) {\n                    maxNums = arr\n     \
    \               maxNum = arr(i)\n                    j = 0\n                }\n\
    \                j += i + 1\n            }\n            i += 1\n        }\n  \
    \      if (maxSize < k)\n            return null\n        while (i < arr.length)\
    \ {\n            if (arr(i) > maxNum) {\n                if (maxNums == null)\n\
    \                    maxNums = arr\n                else\n                   \
    \ maxNums = maxNums.zip(arr).map{ case (e1, e2) => e2 }\n                maxNum\
    \ = arr(i)\n            }\n            i += 1\n        }\n        return maxNums",
  "        val res = new ArrayList[Long]()\n        var pos = 0\n        var maxVal\
    \ = -1\n        arr.foreach(x => {\n            if (maxVal < x) {\n          \
    \      maxVal = x\n                pos = 0\n            }\n            pos +=\
    \ 1\n            if (pos == k) {\n                res.add(maxVal)\n          \
    \      pos = 0\n            }\n        })\n        return res", "        val arr1\
    \ = arr.sorted\n        val arr = arr1.takeRight(k).toList\n        arr1", " \
    \       val res = arr.sortWith( (a,b) => a < b )\n        if (res.length < k)\n\
    \            res ++ res.take(k - res.length)\n        else\n            res",
  "        val result = new collection.mutable.Buffer[Long]\n        val buffer =\
    \ new collection.mutable.PriorityQueue[(Long, Long)](List(-1000l), List((-1000l,\
    \ 0l)))\n        arr.sortWith((x,y) => (x > y)).foreach(x => buffer.add((x)))\n\
    \        while(buffer.size > 0) {\n            val l = buffer.dequeue()\n    \
    \        if(buffer.size < k) buffer.add((-l,-l))\n            if(l == -1000l)\
    \ {\n                result.clear()\n                arr.sortWith((x,y) => (x\
    \ > y)).foreach(x => buffer.add((x)))\n            } else {\n                if(buffer.size\
    \ > 1) {\n                    val max = (-1000l, buffer.dequeue()._2)\n      \
    \              if(buffer.size > k) buffer.add((-l,max))\n                    if(buffer.size\
    \ > k) buffer.add((-l,max))\n                    buffer.add((-l,l))\n        \
    \        }\n            }\n        }\n        result.toList", "        var maxArr\
    \ = arr\n\n        if(arr.length < k) maxArr = (0 until k) map (arr(_)) ++ arr\n\
    \n        val maxKey = arr.foldLeft(-1000l) {\n            case (acc, x) => if(acc\
    \ > x) acc else x\n        }\n\n        maxArr.sortWith((x, y) => if(x > y) 1\
    \ else if(x < y) -1 else 0)\n\n        maxArr.takeWhile(x => x < maxKey)", " \
    \       // Write your code here\n        if (arr.isEmpty) Nil\n        else if\
    \ (arr.size <= k) arr\n        else {\n            val m1 = arr.min { a => a }\n\
    \            val m2 = arr.max { a => a }\n            val arr1 = arr.filter{ _\
    \ != m1 }\n            val arr2 = arr.filter{ _ != m2 }\n            arr1 :::\
    \ arr2\n        }", "        val arr = arr.toArray\n        val n = arr.length\n\
    \        val maxArr = new mutable.ListBuffer[Long]\n        // Find max number\
    \ in the array arr\n        var maxIndex = -1L\n        arr.zipWithIndex.foreach{case\
    \ (v, i) => {\n            if (v > maxArr(maxIndex)) {\n                maxArr(maxIndex)\
    \ = v\n                maxIndex = i\n            }\n        }}\n        // Get\
    \ the max k numbers out of arr\n        var arr = new mutable.ArrayList[Long]()\n\
    \        for (i <- 0 until k && maxIndex >= 0) {\n            if (i < maxIndex)\
    \ {\n                arr += arr(maxIndex)\n                maxIndex -= 1\n   \
    \         }\n        }\n        arr.toList", "        val l = new scala.collection.mutable.ListBuffer[Long]\n\
    \        val nums = new scala.collection.mutable.ArrayBuffer[Long]\n        var\
    \ count = 0\n        var min = Long.MaxValue\n        var max = Long.MinValue\n\
    \n        // Step 1: find maximum\n        for ( i <- arr ) l+= i\n        for\
    \ ( i <- l ) nums += i\n        for ( i <- nums ) count++\n        min = l(0)\n\
    \        max = l(l.length - 1)\n\n        // Step 2: Sort k numbers\n        while\
    \ ( count > 0 ) {\n            count -= 1\n            val mid = ( min + max )\
    \ / 2\n            if ( mid.abs <= max.abs ) {\n                max = mid\n  \
    \          }\n            else {\n                min = mid\n            }\n \
    \       }\n\n        // Step 3: Re-build result\n        var res = 0\n       \
    \ for ( i <- nums ) {\n            res += i\n            if ( res > (k - 1) )\
    \ {\n                break\n            }\n        }\n\n        val res = l.toList.reverse\n\
    \        res.take(k).toList", "        def maxAndRemove(arr : List[Long], k :\
    \ Long) : List[Long] = {\n            def maxAndRemoveHelper(arr : List[Long],\
    \ k : Long) : List[Long] = {\n                val maxElement = arr.take(k)\n \
    \               val rest = arr.drop(k)\n                (maxElement ::: maxAndRemoveHelper(rest,\
    \ k), rest)\n            }\n            val maxElements = maxAndRemoveHelper(arr,\
    \ k)\n            val maxElement = maxElements.head\n            val rest = maxElements.tail\n\
    \            (maxElement ::: maxAndRemove(rest, k), rest)\n        }\n       \
    \ val maxElements = maxAndRemove(arr, k)\n        val maxElement = maxElements.head\n\
    \        val rest = maxElements.tail\n        (maxElement ::: maxAndRemove(rest,\
    \ k), rest)", "        val sorted = arr.sorted\n        val result = Array[Long](k).fill(null.asInstanceOf[Long]).asInstanceOf[Array[Long]]\n\
    \        if (arr.isEmpty) {\n            result\n        } else if (arr.size ==\
    \ k) {\n            val index = k - 1\n            result(index) = new Long(sorted.head)\
    \ \n            result(index + 1) = new Long(sorted.last) \n        } else {\n\
    \            for (x <- 0 until k) {\n                var max = 0\n           \
    \     var maxIndex = 0\n                for (y <- 0 until arr.size) {\n      \
    \              if (arr(y) > max && y > maxIndex && y <= arr.size - 1) {\n    \
    \                    max = arr(y)\n                        maxIndex = y\n    \
    \                }\n                }\n                result(x) = new Long(max)\n\
    \                result(x + 1) = new Long(arr(maxIndex))\n            }\n    \
    \    }\n        result", "        val m = arr.take(k)\n        val maxIdx = m(0).toInt\
    \ - k\n        var maxVal = m(0)\n        var maxIndex = maxIdx\n        var idx\
    \ = 0\n        while((idx < m.length) && (maxIdx <= arr(idx).toInt)) {\n     \
    \       idx += 1\n        }\n        val n = k - (idx-1)\n        var maxIdx2\
    \ = maxIdx\n        var maxVal2 = maxVal\n        var idx2 = 0\n        while((idx2\
    \ < n) && (maxIdx2 <= arr(idx).toInt)) {\n            idx2 += 1\n        }\n \
    \       val l = maxIdx\n        val r = maxIdx2\n        val result: List[Long]\
    \ = m.take(l) ++ m.takeRight(r)\n        result", "        val arrCopy = arr.toList.sortWith((x,\
    \ y) => x > y) \n        val maxSize = math.max(k, arr.length)\n        val result\
    \ = mutable.MutableList[Long]()\n        for (i <- 0 until arr.length) if (arrCopy(i)\
    \ == arrCopy(i)) {\n            result.add(arrCopy(i))\n            arrCopy(i)\
    \ -= 1\n        }\n        result.take(maxSize).toList", "        val max_list\
    \ = mutable.ArrayBuffer.empty[Long]\n        val max_size = arr.size\n       \
    \ val max_k = max_size / k\n        // k*arr.size <= max_size\n        if (max_k\
    \ > 0) {\n            // For each index i (0 <= i < arr.size), we need to check\
    \ \n            // if all k elements in arr are larger than arr[i].\n        \
    \    // We need to consider k elements because arr has \n            // max_size\
    \ elements.\n            // If all elements in arr are larger than arr[i], \n\
    \            // we should put arr[i] in max_list\n            // If not, we should\
    \ check arr[i], arr[i+1], ... arr[i+k-1]\n            for (i <- 0 until max_size)\
    \ {\n                if (max_list.size + 1 == max_size) {\n                  \
    \  max_list += arr(i)\n                }\n                else {\n           \
    \         max_list += arr(i)\n                    val j = 0\n                \
    \    while (j <= max_k-1) {\n                        if (arr(i+j) > arr(i)) {\n\
    \                            max_list += arr(i+j)\n                        }\n\
    \                        j += 1\n                    }\n                }\n  \
    \          }\n        }\n        max_list.toList", "        val arr = arr.sortWith(_\
    \ < _)\n        val max = arr.slice(0, k)\n        arr.slice(k)", "        val\
    \ length = arr.length\n        val result = new Array[Long](k)\n        val arr\
    \ = arr.toList\n        var maxValue = arr(0)\n        val index = 0\n       \
    \ for (i <- 1 until length) {\n            if (arr(i) > maxValue) {\n        \
    \        maxValue = arr(i)\n            }\n        }\n\n        for (i <- 1 until\
    \ k) {\n            result(i) = maxValue\n        }\n\n        return result",
  "        if(arr.isEmpty)\n            return arr\n        var ans = arr.take(k-1)\n\
    \        var maximum : List[Long] = List(0)\n        var maxIndex = -1\n     \
    \   var currentIndex = 0\n        var currentMaximum = 0\n        var currentMaxIndex\
    \ = -1\n        for(i<- 0 until arr.length){\n            if(maxIndex < 0){\n\
    \                maxIndex = i\n            }\n            currentMaximum = ans(i)\
    \ + ans(maxIndex)\n            currentIndex += 1\n            if(currentMaximum\
    \ > currentMaxIndex){\n                currentMaxIndex = currentIndex\n      \
    \      }\n            if(currentMaximum > maximum(k)){\n                maximum\
    \ = currentMaximum\n                maxIndex = currentMaxIndex\n            }\n\
    \        }\n        if(maxIndex < k){\n            maximum = ans.take(k-maxIndex)\n\
    \        }\n        return maximum", "        val newList = mutable.ListBuffer[Long]()\n\
    \        val maxLen = arr.max\n        val maxArray = arr.maxBy(_).asInstanceOf[List[Long]]\n\
    \        for(i <- 0 until k){\n            newList += maxArray(i)\n        }\n\
    \        newList.sortWith(_ < _).reverse", "        var result = new mutable.ArrayBuffer[Long]()\n\
    \        var largest = 0l\n        var temp = 0l\n        var current = 0l\n \
    \       var j = 0\n        var i = 0\n\n        for (i <- 0 until arr.length)\
    \ {\n            current = arr(i)\n\n            while (current.toLong > temp)\
    \ {\n                result.add(current.toLong)\n                result.add(temp.toLong)\n\
    \                temp = current\n                current = arr(j)\n          \
    \      j += 1\n            }\n            temp = current\n        }\n        for(i\
    \ <- 0 until result.length) result(i) += (k - result.length).toLong\n        for(i\
    \ <- 0 until result.length) result(i) %= k\n        result.sortWith((a, b) =>\
    \ a.compareTo(b) > 0)\n        result.toList", "        // Write your code here\n\
    \        val arrSorted = arr.sortWith(x => (x - arr.last).abs)\n        val newArr\
    \ : List[Long] = Array.ofDim[Long](k)\n        var max = 0\n        var curr =\
    \ arrSorted.head\n        var i : Long = 0\n        while(curr < arrSorted.last)\
    \ {\n            if(!max.equals(curr)) {\n                max = (curr :: newArr(i)).max\n\
    \                i +=1\n            }\n            curr = arrSorted.last\n   \
    \     }\n        newArr(i)", "        val result = new Array[Long](k)\n      \
    \  var i = 1\n        for(x <- arr) {\n            if(x > arr(i-1))\n        \
    \        i += 1\n            result(i) = x\n        }\n        result", "    \
    \    val l = arr.size\n        val maxArr : List[Long] = new ArrayList[Long](k)\n\
    \        for (i <- 0 until k) {\n            maxArr(i) = arr(i) //get the max\
    \ value from arr\n        }\n        for (i  <- 0 to (l-1)) {\n            maxArr(k)\
    \ = maxArr(k)\n            val temp = maxArr(k);\n            for (i1 <- i+1 to\
    \ k) {\n                if (arr(i1) > temp) {\n                    maxArr(i1)\
    \ = arr(i1)\n                }\n            }\n        }\n        return maxArr",
  "        // Write your code here\n        var maxi = List[Long]()\n        arr.foreach{\n\
    \            x =>\n                maxi ::= x\n        }\n        maxi.sortWith(\
    \ (x,y) => x.compare(y) < 0 )\n        (1 to k).map( i => maxi(i) )", "      \
    \  if (k > arr.length)\n            maximum((arr :+ 0l), arr.length)\n       \
    \ else if (k == 0)\n            arr\n        else {\n            val maxNum =\
    \ (arr :+ 0l)\n            var max : Long = 0l\n            var curMax = 0l\n\
    \            while (k > 0 && max < curMax) {\n                max += 1l\n    \
    \            curMax = maxNum.max\n                maxNum = maxNum.dropWhile(x\
    \ => x < curMax)\n            }\n            arr drop max\n        }", "     \
    \   val n = new scala.collection.mutable.Queue[Long]\n        val res = []\n \
    \       for(a <- arr) {\n            n.enqueue(a)\n            if((n.size <= k)\
    \ && (n.size >= 1))\n                res ::= n.dequeue\n        }\n        res.toList",
  "        val arr = arr.sortWith(_ > _)\n        val len = arr.length\n        (0\
    \ until k).map { i => ((i + 1) * len - i) * arr(i)\n        }.filter { _ > 0 }.sortBy(_\
    \ / len)", "        val n = arr.size\n        if (k > n || k == 0)\n         \
    \   throw new IllegalArgumentException(\"Maximum should be less than or equal\
    \ to list and array length.\")\n        val max_list = scala.collection.mutable.ArrayBuffer.empty[Long]\n\
    \        for (x <- arr) {\n            if (max_list.length <= k)\n           \
    \     max_list += x\n            else\n                if (x > max_list.last)\n\
    \                    max_list += x\n        }\n        if (max_list.length > k)\n\
    \            max_list.take(k)\n        else\n            max_list", "        if\
    \ (arr.isEmpty)\n            List[Long]()\n        else if (arr.size == k)\n \
    \           arr\n        else \n            val maxArr : List[Long] = arr.maxBy\
    \ (_ => arr.length)\n            val result : List[Long] = List((maxArr))\n  \
    \          val subResult : List[Long] = maximum (arr.drop (maxArr.length), k -\
    \ 1) //recursive calls\n            for (sub <- subResult)\n                result\
    \ ::= maxArr\n            result", "        val n = arr.size\n        var i =\
    \ k\n        val maxList = mutable.ArrayBuffer.empty[Long]\n\n        while (i\
    \ <= n && arr.contains(arr.head)) {\n            maxList += arr.head\n       \
    \     i += k\n        }\n\n        if (i <= n) {\n            val maxLength =\
    \ maxList.length\n            for (i <- 0 until maxLength) {\n               \
    \ maxList(i) = max(maxList(i), arr(i))\n            }\n        }\n\n        maxList.toList",
  "        val maxLength = Math.max(arr.length, k)\n        val res = new Array[Long](maxLength)\n\
    \        var index = 0\n        var maxIdx = 0\n\n        for(i <- 0 until arr.length\
    \ && index != maxLength) {\n            if(arr(i) > res(maxIdx)) {\n         \
    \       res(maxIdx) = arr(i)\n                maxIdx += 1\n            }\n   \
    \         index += 1\n        }\n\n        if(index < maxLength) res.drop(index)\n\
    \        else res", "        // Write your code here\n        ", "        if (k\
    \ > arr.size) k\n        if (k > arr.size) {\n            val sorted = arr.sort\n\
    \            (sorted.take(k), sorted.drop(k))\n        }\n        else arr.sort",
  "        val res = new Array[Long](k)\n        // Sort the array in descending order\
    \ and then return the first k elements of this sorted list\n        arr.sortWith(\
    \ (a: Long, b: Long) => b > a ).take(k).foreach( x => res(arr.indexOf(x) + 1)\
    \ )\n        res", "        if (k == 0) return arr\n        val arr = arr.sortBy{a\
    \ => -a}\n        val length = arr.length\n        val len = arr.take(k)\n   \
    \     var maxArr: List[Long] = Nil\n        var maxVal: Long = Nil\n        for(i\
    \ <- 0 until k)\n            if (arr(i) > maxVal)\n                maxVal = arr(i)\n\
    \        for(i <- 0 until k)\n            if (arr(i) == maxVal)\n            \
    \    maxArr = maxArr :+ arr(i)\n        maxArr", "        var maxList = List[Long]()\n\
    \        var maxNum : Long = -1\n        for (i<- 0 to k-1) {\n            var\
    \ cur = arr(i)\n            var max = 0\n            for(j <- i until arr.length)\
    \ {\n                if(arr(j) > cur) {\n                    cur = arr(j)\n  \
    \              }\n                if(cur > max) {\n                    max = cur\n\
    \                }\n            }\n            if(max > maxNum) {\n          \
    \      maxNum = max\n            }\n            maxList :+= cur\n        }\n \
    \       return maxList", "        val n = arr.length\n        val m = Math.ceil((k\
    \ * n + 1) / 2)\n        val maxheap = new MaxHeap[Long](m)\n        val maxHeapList\
    \ = mutable.ArrayBuffer(arr.take(Math.max(k, arr.length)))\n        var i = 0\n\
    \        var j = 0\n        while (i < n && j < m) {\n            val left = i\
    \ * 2 + 1\n            val right = i * 2 + 2\n            val maxValue = max(max(arr(i),\
    \ arr(left)), max(arr(j), arr(right)))\n            if (maxheap.isEmpty) {\n \
    \               maxheap += maxValue\n            } else if (maxheap.max > maxValue)\
    \ {\n                maxheap += maxValue\n            }\n            if (maxheap.size\
    \ < k && maxheap.max != maxValue) {\n                maxHeapList += maxheap.max\n\
    \                maxheap = maxheap.deleteMax()\n                i += 2\n     \
    \       } else if (maxheap.size == k) {\n                maxHeapList += maxheap.max\n\
    \                maxheap = maxheap.deleteMax()\n            } else {\n       \
    \         maxheap = maxheap.deleteMax()\n                j += 1\n            }\n\
    \        }\n        val result = maxHeapList.take(k).toList\n        if (result.size\
    \ > k) result.dropRight(k)\n        result", "        if (arr.length < 1 || k\
    \ <= 0 || arr.length > 1000) return arr;\n        var result : List[Long] = Nil;\n\
    \        var maxArr : List[Long] = Nil;\n        var maxIndex : Long = 0;\n  \
    \      var maxSum : Long = 0;\n        var index : Long = 0;\n        var sum\
    \ : Long = 0;\n        for (elem <- arr) {\n            if (sum > maxSum) {\n\
    \                maxSum = sum;\n                maxIndex = index;\n          \
    \  }\n            sum += elem;\n            index += 1;\n        }\n        while\
    \ (maxIndex < arr.length) {\n            sum += arr[maxIndex];\n            maxIndex\
    \ += 1;\n        }\n        if (maxIndex < arr.length) {\n            maxSum =\
    \ sum;\n            maxIndex = maxIndex;\n        }\n        maxArr = arr.take(maxIndex);\n\
    \        arr.delete(0, maxIndex);\n        if (arr.isEmpty) arr ++ Nil;\n    \
    \    while (!arr.isEmpty) {\n            var sum : Long = 0;\n            var\
    \ sumArr : List[Long] = Nil;\n            var index : Long = 0;\n            var\
    \ maxArrIndex : Long = 0;\n            var maxSum : Long = 0;\n            var\
    \ maxSumArr : List[Long] = Nil;\n            for (elem <- arr) {\n           \
    \     if (sum > maxSum) {\n                    maxSum = sum;\n               \
    \     maxArrIndex = index;\n                }\n                sum += elem;\n\
    \                index += 1;\n            }\n            maxSumArr = arr.take(maxArrIndex);\n\
    \            arr.delete(0, maxArrIndex);\n            if (arr.isEmpty) arr ++\
    \ Nil;\n            var sumArrIndex : Long = 0;\n            for (elem <- arr)\
    \ {\n                sumArr += arr(sumArrIndex);\n                sumArrIndex\
    \ += 1;\n            }\n            result ++= sumArr;\n        }\n        return\
    \ result;", "        val n = (1L to 1000).size\n        val a = arr.takeRight(n)\n\
    \        val b = mutable.ListBuffer[Long]()\n        var i = 0\n        for (x\
    \ <- a if i < k) {\n            if (x > max(b)) {\n                b.clear()\n\
    \                i += 1\n            }\n            b.add(x)\n        }\n    \
    \    if (i < k) {\n            b.toList\n        } else {\n            a.toList\n\
    \        }", "        val arr = arr.toList\n        val len = arr.length\n   \
    \     val max = new mutable.PriorityQueue[Long]\n        for (x <- 0 until len)\
    \ max.enqueue(arr(x))\n        if (max.size > k) {\n            val list = max\
    \ + max.take(k - 1) + max.take(k).toList\n            list\n        } else {\n\
    \            arr\n        }", "        val tempList = arr.foldLeft((List[Long](),\
    \ 0))((x, l) => {\n            val num = if (l < x) x else l\n            val\
    \ list = x.get._1.updated((num * 2, num * 2 + 1), num * 2)\n            (list,\
    \ l - num)\n        })\n        tempList._1.reverse.take(k)", "        var maxArr\
    \ : List[Long] = List.empty[Long]\n        var maxIndex : Long = 0\n        var\
    \ sum : Long = 0\n        var j : Long = 0\n        var index : Long = 1\n\n \
    \       while (maxIndex < k){\n            sum += arr(maxIndex) //sum value\n\
    \            if(maxArr == null || sum > maxArr(maxIndex)){\n                maxArr\
    \ = arr\n                maxIndex = index\n            }\n            index +=\
    \ 1\n        }\n\n        return maxArr", "        // Write your code here.\n\
    \        val length = arr.length\n        val max_k = arr.take(k).max\n      \
    \  var i = 0\n        var j = 0\n        var temp : List[Long] = null\n      \
    \  var ans : List[Long] = null\n        while(i < k && j < arr.length){\n    \
    \        if(arr(i) < max_k){\n                if(temp != null)\n             \
    \       temp = temp :+ arr(j)\n                else\n                    temp\
    \ = arr(j)\n            }else{\n                ans = ans :+ max_k\n         \
    \       break\n            }\n            i +=1\n            j +=1\n        }\n\
    \        ans = ans :+ max_k\n        return ans", "        var maximums = arr.sorted.sliding(arr.length)\n\
    \        // remove the largest k numbers, if there are enough numbers\n      \
    \  if (maximums.size <= k) {\n            maximums = maximums.dropRight(k)\n \
    \       }\n        maximums", "        var largest = 0\n        var largestIndex\
    \ = 0\n        var index = 0\n        while (index<arr.length) {\n           \
    \ var currentValue = arr(index)\n            while (index<arr.length && arr(index)\
    \ < currentValue) {\n                currentValue = arr(index)\n             \
    \   index++\n            }\n            if (currentValue > largest) {\n      \
    \          largest = currentValue\n                largestIndex = index\n    \
    \        }\n            index++\n        }\n        if (k == largestIndex+1) {\n\
    \            return arr.reverse\n        } else {\n            return maximum(arr.drop(largestIndex+1),\
    \ k-largestIndex).toList\n        }", "        val m = arr.head\n        val maxElements\
    \ = arr.tail\n        val maxList = scala.collection.mutable.ListBuffer.empty[Long]\n\
    \        maxElements.filter(_.isLessThanOrEqualTo(m)).foreach(e => {\n       \
    \     if(maxList.size + 1 >= k) {\n                maxList += e\n            }\
    \ else {\n                maxList += (maxList.head) + (e)\n            }\n   \
    \     })\n        maxList.toList", "        val heap = mutable.PriorityQueue[Long]()\n\
    \        heap += arr(0)\n        heap += arr(arr.length - 1)\n        for (i =\
    \ 1 until arr.length - k + 1){\n            if (heap.head > heap.tail){\n    \
    \            heap += arr(i)\n                heap += arr(i - 1)\n            }\
    \ else {\n                heap += arr(i)\n            }\n        }\n        return\
    \ heap.toList", "        var maxArr : List[Long] = Nil\n        var curArr = arr\n\
    \        var count = 0\n        while curArr.isEmpty == false {\n            count\
    \ +=1\n            if(count > k){\n                maxArr ::= curArr\n       \
    \         curArr = Nil\n                count = 0\n            } else {\n    \
    \            maxArr ::= curArr\n                curArr = arr\n            }\n\
    \        }\n        maxArr.reverse", "        // write your code\n        val\
    \ maxLength = arr.sortWith(_ < _).take(k).length\n        arr.sortWith(_ < _).take(maxLength)",
  "        // Do not write main() for the following tests\n        assert(arr.length\
    \ == k, \"The length of the list will be in the range of [1, 1000]\")\n      \
    \  assert(arr.forall(x => x >= -1000 &&x <= 1000), \"The elements in the list\
    \ will be in the range of [-1000, 1000]\")\n        assert(0 <= k && k <= arr.length,\
    \ \"0 <= k <= len(arr)\")\n        // \u901A\u8FC7\u9012\u5F52\u7684\u65B9\u5F0F\
    \u627E\u51FA\u6570\u7EC4\u4E2D\u5927\u4E8E\u7B49\u4E8Ek\u7684\u5143\u7D20\uFF0C\
    \n        // \u7528\u9012\u5F52\u7684\u65B9\u5F0F\u5BF9\u6574\u4E2A\u6570\u7EC4\
    \uFF0C\u627E\u51FA\u6700\u5927\u7684k\u4E2A\u6570\u3002\n        val maxNums =\
    \ arr\n        val maxNumsCount = arr.length\n        var curr = 1\n        var\
    \ maxRes = List[Long]()\n        // \u9012\u5F52\u7684\u601D\u60F3\u662F\uFF0C\
    \u5982\u679C\u5F53\u524D\u6570\u7EC4\u957F\u5EA6\u6BD4k\u5C0F\uFF0C\u5C31\u5C06\
    k-1\u4E2A\u6570\u7EC4\u7684\u957F\u5EA6\u7684\u5143\u7D20\u52A0\u5230\u6700\u540E\
    \u7684\u6570\u7EC4\u4E2D\uFF0C\n        // \u8FD9\u6837\u7684\u8BDD\uFF0C\u5982\
    \u679C\u5F53\u524D\u6570\u7EC4\u957F\u5EA6\u6BD4k\u5927\uFF0C\u5C31\u5C06\u5F53\
    \u524D\u7684\u6570\u7EC4\u957F\u5EA6\u7684\u5143\u7D20\u52A0\u5230\u6700\u540E\
    \u7684\u6570\u7EC4\u4E2D\u3002\n        // \u90A3\u4E48\u5982\u4F55\u6C42\u51FA\
    \u6700\u5927\u7684k\u4E2A\u6570\u5462\uFF1F\n        // \u9996\u5148\u627E\u51FA\
    \u5F53\u524D\u6570\u7EC4\u4E2D\u6BD4\u5F53\u524D\u6570\u7EC4\u957F\u5EA6\u5927\
    \u7684\u5143\u7D20\u7684\u4E2A\u6570\n        val kMinus1 = k - 1\n        for\
    \ (i <- 0 until arr.length) {\n            if (curr == kMinus1) {\n          \
    \      maxRes :+= maxNums(i)\n                curr += 1\n            } else {\n\
    \                maxRes :+= maxNums(i)\n            }\n        }\n        return\
    \ maxRes", "        var list = new scala.collection.mutable.Buffer[Long](k)\n\
    \        for (i <- 0 until arr.length) { \n            list += arr(i) \n     \
    \   }\n        list.sortWith(_ < _)\n        list.toList", "        val result\
    \ = new ListBuffer[Long]()\n        val n = arr.size\n        if (n == 0)\n  \
    \          result.append(0)\n        else if (n <= k)\n            result.append(arr(0))\n\
    \        else {\n            val arr = arr diff new Array[Long](n).fill(0)\n \
    \           var sum = 0\n            while (k >= 0 && k < n) {\n             \
    \   if (sum < arr(k)) {\n                    val temp = sum\n                \
    \    sum = arr(k)\n                    arr(k) = temp\n                }\n    \
    \            k -= 1\n            }\n            result.append(sum)\n        }\n\
    \        result.toList", "        if(arr.isEmpty) {\n            return Nil\n\
    \        }\n        var max = arr(0)\n        var maxIndex = 0\n        var index\
    \ = Nil\n        for(i <- 0 until arr.length) {\n            if(arr(i) > max)\
    \ {\n                max = arr(i)\n                maxIndex = i\n            }\n\
    \            if(arr(i) == max && i != maxIndex) {\n                index = List(arr(i))\n\
    \            }\n        }\n        if(k == 1) {\n            List(arr.take(maxIndex))\n\
    \        } else {\n            val leftMax = maximum(arr.take(maxIndex), k - 1)\n\
    \            val rightMax = maximum(arr.drop(maxIndex + 1), k - 1)\n         \
    \   if(leftMax.isEmpty) {\n                List(arr.take(maxIndex))\n        \
    \    } else {\n                List(leftMax, arr.take(maxIndex), rightMax)\n \
    \           }\n        }", "        if (arr.isEmpty)\n            return arr\n\
    \n        // arr: List arr of integers\n        // k: integer k\n        // The\
    \ length of result: int r\n        // The head of result: Long h\n        // The\
    \ maximum of arr and result: Long m\n        // The head of result: Long h\n \
    \       // The maximum of arr and result: Long m\n        var l = arr.head\n \
    \       var r = arr.head\n        var m = arr(0)\n        for (i <- 1 to (arr.length\
    \ - 1)) {\n            if (arr(i) > m) {\n                l = r\n            \
    \    m = arr(i)\n            } else {\n                r = r\n            }\n\
    \        }\n        if (m > k) {\n            k += arr.length\n        }\n\n \
    \       (l :: maximum(arr.reverse, k) :: r.reverse).sortWith((a, b) => b - a)",
  "        val arr = arr.toList\n        val n = arr.size\n        var i = k - 1\n\
    \        val max = List[Long]()\n        while (i >= 1) {\n            if (arr(i)\
    \ > arr(i-1)) max :+= arr(i)\n            else max :+= arr(i-1)\n            i\
    \ -= 1\n        }\n        if (arr.size == 1) max :+= arr(0)\n        if (arr.size\
    \ == 0) max\n        else maximum(k + 1, max)", "        // Write your code here\n\
    \        val maxList = arr.sortWith(e => e < arr.min).take(k)\n        val newList\
    \ = arr.filter( e => e < maxList.min).toList\n        newList :+ maxList.max",
  "        val result: mutable.Buffer[Long] = new mutable.Buffer[Long]\n        var\
    \ currentMax: Long = Long.MinValue\n        var i = 0\n        for (a <- arr)\
    \ {\n            val currentMaxForI = currentMax\n            val maxLength =\
    \ i\n            for (j <- 0 until maxLength) {\n                if (i == 0) {\n\
    \                    result.append(a)\n                    currentMax = a\n  \
    \              }\n                else if (j == maxLength - 1) {\n           \
    \         if (a > currentMax) {\n                        result.append(a)\n  \
    \                      currentMax = a\n                    }\n               \
    \ }\n                else if (a > currentMax) {\n                    result.append(a)\n\
    \                    currentMax = a\n                }\n            }\n      \
    \      i += 1\n        }\n        return result.take(k)", "        val maxVal\
    \ = arr.sortBy(_.toLong).last\n        val remaining = arr.diff(maxVal).takeRight(k)\n\
    \        maxVal::remaining", "        val n = arr.length\n        val maxNums\
    \ = mutable.ArrayBuffer.empty[Long]\n        val nums = arr.sorted\n        var\
    \ index = 0\n        var i = 0\n        while (i < n) {\n            maxNums +=\
    \ nums(i)\n            i += 1\n            if (i >= k && maxNums.size < k) {\n\
    \                index += 1\n                maxNums += nums(i)\n            \
    \    i += 1\n            }\n        }\n        val newArr = new Array[Long](index)\n\
    \        for (i <- 0 until index) {\n            newArr(i) = maxNums(i)\n    \
    \    }\n        newArr", "        val lMax = arr.takeWhile(item => item <= k).max\n\
    \        arr.filter(item => item > lMax).take(k).map(item => lMax + item)", " \
    \       // Write your code here\n        val max = new mutable.PriorityQueue[Long]\n\
    \        val num = new mutable.PriorityQueue[Long]\n        for(i <- 0 until k){\n\
    \            max.enqueue(arr.max)\n            num enqueue arr(i)\n        }\n\
    \        if(max.size > k){\n            for(i <- 0 until k){\n               \
    \ num enqueue arr(max.dequeue)\n            }\n            for(i <- 0 until k){\n\
    \                max.enqueue(arr(i))\n            }\n        }\n        max.toList",
  "        val result = new ArrayBuffer[Long]()\n        var max = -1000l\n      \
    \  var i = 0\n        while (i < arr.length && arr.length >= k) {\n          \
    \  val elm = arr(i)\n            if (max < elm) {\n                max = elm\n\
    \            }\n            i += 1\n        }\n        while (i < arr.length)\
    \ {\n            val elm = arr(i)\n            if (max < elm) {\n            \
    \    max = elm\n            }\n            i += 1\n        }\n        while (i\
    \ < arr.length) {\n            val elm = arr(i)\n            if (elm != max) {\n\
    \                result += elm\n            }\n            i += 1\n        }\n\
    \        val list = result.toList\n        list.sortWith((x, y) => x > y)\n  \
    \      list", "        if (arr.size <= k) {\n            arr\n        } else {\n\
    \            var maxList = ListBuffer[Long]()\n            var maxValue = Long.MaxValue\n\
    \            var index = 0\n            var isMax = false\n            while (index\
    \ < arr.size) {\n                val value = arr(index)\n                if (value\
    \ > maxValue) {\n                    maxValue = value\n                    isMax\
    \ = true\n                }\n                if (value < maxValue && value < arr(k))\
    \ {\n                    maxValue += 1\n                    maxList += value\n\
    \                }\n                index += 1\n            }\n            if\
    \ (maxValue == arr(k)) {\n                maxList += arr(k)\n            }\n \
    \           isMax && maxList.toList\n        }", "        def isPrime(n : Long)\
    \ : Boolean = {\n            for( x <- 2 until n ) if( n % x == 0 ) \n       \
    \         return false\n            true\n        }\n\n        def isUnique(n\
    \ : Long) : Boolean = {\n            val c = 1l.toLong\n            for( x <-\
    \ 0 until k ) if( n % x == 0 ) c += 1\n            c <= k\n        }\n\n     \
    \   def hasAtLeastK(arr : List[Long], k : Long) : Boolean = {\n            var\
    \ res = false\n            for( x <- arr ) if( k > x ) res = true\n          \
    \  res\n        }\n\n        def hasMaxK(arr : List[Long], k : Long) : Boolean\
    \ = {\n            var res = false\n            for( x <- arr ) if( k > x ) res\
    \ = true\n            res\n        }\n\n        // 1\n        val l2 = arr.toList\n\
    \        if(!hasMaxK(l2, k)) \n            throw new RuntimeException(\"Invalid\
    \ input\")\n        if(!hasAtLeastK(l2, k)) \n            throw new RuntimeException(\"\
    Invalid input\")\n\n        // 2\n        val l3 = l2.filter( x => isPrime(x)\
    \ )\n        if(!isUnique(l3)) \n            throw new RuntimeException(\"Invalid\
    \ input\")\n        if(!isPrime(l3.max)) \n            throw new RuntimeException(\"\
    Invalid input\")\n\n        // 3\n        if(!isUnique(l3.max)) \n           \
    \ throw new RuntimeException(\"Invalid input\")\n\n        // 4\n        val l4\
    \ = (l3 :+ k).toList\n        if(!hasAtLeastK(l4, k)) \n            throw new\
    \ RuntimeException(\"Invalid input\")\n\n        // 5\n        if(!isUnique(l4.max))\
    \ \n            throw new RuntimeException(\"Invalid input\")\n\n        // 6\n\
    \        val l5 = (l4 :+ k).toList\n        if(!hasAtLeastK(l5, k)) \n       \
    \     throw new RuntimeException(\"Invalid input\")\n\n        // 7\n        if(!isUnique(l5.max))\
    \ \n            throw new RuntimeException(\"Invalid input\")\n\n        l5.max",
  "        val result: List[Long] = new Array[Long](k)\n        val maxNums = arr.map(x\
    \ => if (x > 0) x else -1l)\n        val maxNumsArr = maxNums.toArray\n      \
    \  var maxNumsIdx = 0\n        var maxNumsIdxNext = 0\n        var maxNumsIdxPrev\
    \ = 0\n        for (i <- 0 until k) {\n            if (maxNumsIdxNext != maxNumsIdx\
    \ && maxNumsIdxPrev != maxNumsIdx) {\n                val curMaxNum = maxNumsArr[maxNumsIdxNext]\n\
    \                val nextMaxNum = maxNumsArr[maxNumsIdxPrev]\n               \
    \ if (nextMaxNum > curMaxNum) {\n                    val idx = maxNumsIdxNext\n\
    \                    maxNumsIdx = idx\n                    maxNumsIdxNext = maxNumsIdx\n\
    \                } else if (curMaxNum > nextMaxNum) {\n                    val\
    \ idx = maxNumsIdxPrev\n                    maxNumsIdx = idx\n               \
    \     maxNumsIdxPrev = maxNumsIdx\n                }\n            }\n        \
    \    result(i) = maxNumsArr[maxNumsIdx]\n            maxNumsIdx = maxNumsIdx +\
    \ 1\n        }\n        return result", "        val arr2 = arr.toSeq\n      \
    \  val rem = arr.size - k\n        val arr3 = Array((arr.size % k) * k).map(_+1).toSeq\n\
    \        val newArr = arr3.zip(arr.drop(arr3.size)).map {\n            x => if\
    \ (x(0) > rem)\n                (x._1 + rem, x._2)\n            else if (x._1\
    \ < rem)\n                (x._1, x._1 + rem)\n            else\n             \
    \   x\n        }.sortWith(_._1 > _._1).map(x => x._2)\n        newArr.take(rem).toList\
    \ + arr2", "        if (k > arr.size) Nil\n        else if (arr.isEmpty) Nil\n\
    \        else {\n            val heads = arr grouped k map (_.head)\n        \
    \    val tails = arr grouped (arr.size - k) map (_.tail)\n            (heads ++\
    \ maximum((tails ++ heads map (_.drop(k)).toList, k-1)))\n        }", "      \
    \  val arr = arr.toList\n        var maxCount = 1\n        var maxList = new scala.collection.mutable.ListBuffer[Long]\n\
    \        arr.sortWith((x, y) => x > y)\n        for (x <- arr){\n            if\
    \ (maxCount == k) maxList += x\n            if (maxCount > k) maxList.clear()\n\
    \            if (x == maxCount && maxCount > k) {\n                maxCount +=\
    \ 1\n            }\n        }\n        if (maxCount > k) maxList += arr.last\n\
    \        return maxList.toList", "        val nums = arr.toList\n        val m\
    \ = math.min(k, nums.length)\n        var maxIdx = 0\n        var maxRes = 0\n\
    \        var maxNum = 0\n        for (i <- 0 until m) {\n            var tmpMaxRes\
    \ = maxRes * (-1)\n            var tmpMaxIdx = 0\n            var tmpMaxNum =\
    \ 0\n            for (j <- 0 until nums.length) {\n                var res = math.max(nums(j),\
    \ tmpMaxRes)\n                var idx = math.max(0, j - maxIdx - 1)\n        \
    \        var num = math.max(0, j - maxIdx - 1)\n                if (res > tmpMaxRes)\
    \ {\n                    tmpMaxRes = res\n                    tmpMaxIdx = idx\n\
    \                    tmpMaxNum = num\n                }\n            }\n     \
    \       if (tmpMaxNum == 0)\n                maxNum = math.max(0, nums.length\
    \ - maxIdx - 1)\n            else {\n                if (tmpMaxNum > maxNum)\n\
    \                    maxNum = tmpMaxNum\n                if (tmpMaxIdx < maxIdx)\n\
    \                    maxIdx = tmpMaxIdx\n            }\n        }\n        nums.drop(maxIdx).dropRight(maxIdx\
    \ + maxNum + 1).sorted", "        val arr = arr.sorted\n        var maxk = 0\n\
    \        var maxn = 0\n        for (i <- arr.indices) {\n            if (maxk\
    \ > 0 && arr.take(i).length > (k - maxk)) {\n                maxk = maxk - 1\n\
    \                if (maxn > 0)\n                    maxn = maxn + 1\n        \
    \        maxk = k - maxn\n            }\n            else if (maxk > 0) {\n  \
    \              maxk = maxk - 1\n                if (arr.take(i).length > (k -\
    \ maxk))\n                    maxn = maxn + 1\n            }\n            else\
    \ {\n                maxk = k\n                maxn = maxn + 1\n            }\n\
    \        }\n        val result = arr.take(maxk).toList\n        if (maxk > 0)\
    \ {\n            val k = maxk - 1\n            val n = maxn\n            var max\
    \ = 0\n            val m = 0\n            while (max < (k - n)) {\n          \
    \      max += 1\n                m += 1\n                result(m) = arr(max)\n\
    \            }\n            result(k) = arr(max)\n        }\n        result",
  "        var max = 0\n        val result = new Array[Long](k)\n        for (i <-\
    \ 0 until k)\n            if (arr(i) > max)\n                max = arr(i)\n  \
    \          else\n                result(i) = (arr(i))\n        return result",
  "        val m = arr.sorted\n        val n = k\n        var i = k-1\n        val\
    \ res = []\n        while(i >= 0) {\n            if(arr(i) <= m(i)) {\n      \
    \          res = res :+ arr(i)\n                i = i - 1\n            } else\
    \ {\n                res = res :+ m(i)\n                i = i - 1\n          \
    \  }\n        }\n        res.drop(n-1)", "        require(k > 0l)\n        require(k\
    \ <= arr.length)\n\n        var maxList : List[Long] = Nil\n\n        for(i <-\
    \ 0 until k){\n            var largest = arr.head\n            var maxIndex =\
    \ 0\n            for (j <- 0 until arr.length){\n                if (arr(j) >\
    \ largest && j > maxIndex){\n                    largest = arr(j)\n          \
    \          maxIndex = j\n                }\n            }\n            maxList\
    \ = maxList :+ largest\n            arr.updated(maxIndex, 1)\n        }\n    \
    \    return maxList", "        val maxCount = arr.count(_ > 0).toInt\n       \
    \ val sortedCount = arr.count(_ < 0).toInt\n        val maxNum = if (maxCount\
    \ > sortedCount) arr(0) else arr(arr.length - 1)\n        val maxCountNum = maxCount.toLong\n\
    \        if (maxCountNum < k) arr.take(maxCountNum) else arr.take(k)", "     \
    \   val n = arr.length\n        var max: Long = -1l\n        for(i <- 0 until\
    \ k) {\n            max = -1000l // the initial value so that it won't be overwritten\
    \ later\n            for(j <- 0 until n) {\n                if(arr(j) > max) {\n\
    \                    max = arr(j)\n                }\n            }\n        \
    \    arr = arr :+ max\n        }\n        arr", "        val result = new mutable.ArrayBuffer[Long]()\n\
    \        val n = new mutable.ArrayBuffer[Long]()\n        for (elem <- arr) if\
    \ (n % 5 == 0) {\n            if (n % 5 < k)\n                n += elem\n    \
    \        else {\n                if (elem.compareTo(n(k % 5)) > 0)\n         \
    \           result += n\n                n += elem\n            }\n        }\n\
    \        if (n % 5 == 0) result += n\n        result.toList", "        val nums\
    \ = arr.toList\n        val numsLen = nums.size\n        var max : List[Long]\
    \ = Nil\n        var i = 0\n        while (i < k) {\n            val curr = nums.min\n\
    \            max = max::curr\n            i += 1\n        }\n        if (numsLen\
    \ != k) {\n            for (x <- nums.drop(k))\n                max = max::x\n\
    \        }\n        max.toList", "        var max = arr(0)\n        var maxIndex\
    \ = 0\n        for (elem <- arr) {\n            if (elem > max) {\n          \
    \      maxIndex = arr.indexOf(max)\n                max = elem\n            }\
    \ else if (elem == max) {\n                maxIndex += 1\n            }\n    \
    \    }\n        return arr.take(maxIndex.toInt)", "        val arr = arr.sortBy(_)\n\
    \        arr.take(k - 1).reverse", "        var result = new mutable.ListBuffer[Long]()\n\
    \        \n        if (arr.size < k) {\n            return arr\n        }\n  \
    \      \n        var start = 0\n        while (start < arr.size) {\n         \
    \   var end = arr.size - 1\n            while (end > start) {\n              \
    \  var m = end\n                while (m > start) {\n                    m = m\
    \ - 1\n                    if (m == 0) {\n                        result.add((arr(m)))\n\
    \                        break\n                    }\n                }\n   \
    \             end = m - 1\n                if (end == 0) {\n                 \
    \   result.add((arr(end)))\n                    break\n                }\n   \
    \         }\n            start = end + 1\n        }\n        \n        return\
    \ result.toList", "      \n        val m = arr.toArray\n        val n = arr.toList\n\
    \n        // sort the array\n        Arrays.sort(m)\n\n        // take the first\
    \ k elements\n        val maxSubList = Arrays.copyOfRange(m, 0, k)\n        val\
    \ maxList = new Array[Long](k)\n\n        // append the rest to the max list\n\
    \        val rest = n - k\n\n        maxList(0) = m(0)\n        \n        val\
    \ i : Int = 0\n        while( i < k && rest >= 1 ) {\n          if ( maxSubList(i)\
    \ > maxSubList(i+1) ) {\n            maxList(i) = maxSubList(i)\n          }\n\
    \          else {\n            maxList(i) = maxSubList(i+1)\n          }\n   \
    \       i += 1\n        }\n\n        // reverse the list and return\n        val\
    \ revList = maxList.reverse\n        revList", "        val arr = arr.reverse\
    \ //sort the arr from biggest to lowest\n        var index = 0\n        var max\
    \ = -sys.maxsize - 1\n        for (ele <- arr) {\n            if (max < ele &&\
    \ index < k) {\n                max = ele\n                index = k\n       \
    \     }\n        }\n        arr.reverse", "        var maxNums : List[Long] =\
    \ Nil\n        val size = arr.size\n        for (i <- 0 to size -1 by k) {\n \
    \           if (arr(i) > maxNums.last){\n                maxNums = arr :: maxNums\n\
    \            }\n        }\n        return maxNums", "        val len = arr.length\n\
    \        if (len <= k) arr\n        else { // k > len(arr)\n            val maxNum\
    \ = arr(len-1)\n            val sortedNums = arr.tail.sortBy(-_)\n           \
    \ if (sortedNums.length > k) {\n                val first = sortedNums.take(k)\
    \ \n                val rest = sortedNums.drop(k)\n                (first ++ rest)\n\
    \            } else maxNum\n        }", "        val result = new Array[Long](k)\n\
    \        var max = 0\n        var index = 0\n        for (i<- 0 until arr.length)\n\
    \        {\n            if(max < arr(i))\n            {\n                max =\
    \ arr(i)\n                index = i\n            }\n        }\n        for(j <-\
    \ 0 until arr.length)\n        {\n            if(j != index)\n            {\n\
    \                result(j) = arr(j)\n            }\n        }\n        result.sort\n\
    \        return result", "        val mn = arr.min\n        val mx = arr.max\n\
    \        val len = arr.length\n        val nk = (k - 1) * (len + 1)\n        val\
    \ result = new ArrayList[Long](nk)\n        var i = 0\n        var j = 0\n   \
    \     var k = 0\n        for (i <- 0 until len) {\n            for (j <- (i +\
    \ 1) until len) {\n                if (arr(i) < arr(j)) {\n                  \
    \  k = j\n                    break\n                }\n            }\n      \
    \      result(k) = arr(i)\n            i += 1\n        }\n        if (k < len)\
    \ {\n            result.add(arr(k))\n        }\n        return result.toList",
  "        if (arr.isEmpty) return Nil\n        val maxSize : Int = arr.length\n \
    \       val midIdx = maxSize / 2\n        val leftMaxIdx = maxSize - midIdx -\
    \ 1\n        val rightMaxIdx = midIdx + 1\n        val leftMaxValues = arr take\
    \ leftMaxIdx\n        val rightMaxValues = arr drop (leftMaxIdx+1)\n        \n\
    \        if (leftMaxValues.size < k)\n            maximum(leftMaxValues, k)\n\
    \        else if (rightMaxValues.size < k)\n            maximum(rightMaxValues,\
    \ k)\n        else {\n            if (leftMaxValues.size < rightMaxValues.size)\
    \ {\n                val newArr: Array[Long] = new Array[Long](k)\n          \
    \      for (x <- leftMaxValues)\n                    newArr(newArr.length-1) :=\
    \ x\n                maxSize\n            }\n            else {\n            \
    \    val newArr: Array[Long] = new Array[Long](k)\n                for (x <- rightMaxValues)\n\
    \                    newArr(newArr.length-1) := x\n                maxSize\n \
    \           }\n        }", "        var arr = arr\n        arr.sortWith(_ < _)\n\
    \        if(arr.length >= k){\n            return arr\n        }\n        val\
    \ newArr = arr.take(k - arr.length)\n        newArr ++ newArr.maxBy { a => arr.indexOf(a)\
    \ }.toList", "       // Write your code here\n       var max = List[Long]()\n\
    \       for(i <- 0 until arr.size ) {\n           val current = arr(i)\n     \
    \      if(current > max ) {\n               max = current\n           }\n    \
    \   }\n       for(i <- 0 until k ) {\n           val current = max(i)\n      \
    \     max ::= current\n       }\n       max", "        var maximums = arr\n  \
    \      var k = k\n        while(k >= 0 && maximums.length > k) {\n           \
    \ var cur = maximums.max\n            maximums = maximums.filterNot(_.equals(cur))\n\
    \            k -= 1\n        }\n        return maximums", "        val list =\
    \ new mutable.PriorityQueue[Long](k)\n        arr.foreach(x => list.enqueue(x))\
    \ //add every element to queue\n        val res = new mutable.PriorityQueue[Long](k)\n\
    \        while (list.nonEmpty) {\n            res.enqueue(list.dequeue()) //dequeue\
    \ k largest elements\n        }\n        res", "        if (arr.length < k) {\n\
    \            throw new IllegalArgumentException(\"invalid k value\")\n       \
    \ }\n        val m = new scala.collection.mutable.ArrayBuffer(arr)\n        val\
    \ max = m.maxBy(x => x)._1.toLong\n        var cur = 0\n        var i = 0\n  \
    \      while (i < k) {\n            if (m.exists(x => x == max)) {\n         \
    \       m.remove(max)\n                cur += 1\n            }\n            else\
    \ {\n                max += 1\n                m.append(max)\n            }\n\
    \            i += 1\n        }\n        val res = m.take(k)\n        res.reverse",
  "        val arr = arr.sortBy(x => -x).reverse\n        val k = arr(k).asInstanceOf[Long]\n\
    \        if(k > 0) {\n            if(arr.length < k) {\n                val arr\
    \ = arr.sortBy(x => -x).reverse\n                maximum((arr +: List.fill(k -\
    \ arr.length)(0l)), k)\n            } else {\n                maximum((arr.take(k)\
    \ :: arr.drop(k)), k)\n            }\n        } else {\n            arr.take(k)\n\
    \        }", "        val list = arr.toList\n        val length = arr.length\n\
    \        var maxNum = arr.head\n        var index = 0\n        while (maxNum !=\
    \ 0 && index < k) {\n            if (maxNum < arr.head) maxNum = arr.head\n  \
    \          else {\n                maxNum = arr.head\n                index +=\
    \ 1\n            }\n        }\n        if (maxNum != 0) list :+ maxNum\n     \
    \   else list", "        val result = new mutable.Buffer[Long]\n        val len\
    \ = arr.length\n        \n        // If k == 0 return arr\n        if( k == 0\
    \ ) arr\n\n        // If k == 1 return arr without maximum element\n        if(\
    \ k == 1 ) arr\n\n        // If k > 1 then find the maximum element and add it\
    \ to the result list\n        else {\n            arr.find( l => l >= result.min.asInstanceOf[Long]\
    \ ).take(k - 1).foreach { l => result += l }\n        }\n\n        result.toList",
  "        // write your code here\n        val arr = arr.sortBy(x=>-x)\n        var\
    \ i = 0\n        var max = 0\n        while(i < arr.length-1 && max < k) {\n \
    \           if( arr(i) > arr(i+1) ) {\n                max = k\n             \
    \   arr.apply(k) = arr(i)\n                arr.apply(i) = arr(i+1)\n         \
    \   }\n            i += 1\n        }\n        if(max < k)\n            arr.apply(k)\n\
    \        else\n            arr", "        val m = arr.size\n        val n = arr.last\n\
    \        val k1 = m * n - n\n        val k2 = (k - k1)/k\n        val max = ((arr\
    \ take k2)++(arr drop k2)).sortBy(-_.toLong)\n        (max take k1) ++ max(max\
    \ drop k1)", "        var max = new Array[Long](k)\n        var i = 0; var j =\
    \ 0\n        var temp = 0l\n        while (j < arr.length){\n            temp\
    \ = arr(i)\n            if (max != null){\n                var min = 1l\n    \
    \            var j = 0\n                while (j < k){\n                    min\
    \ =math.min(min, arr(j))\n                    j+=1\n                }\n      \
    \          max(i)=temp\n                max(i+1)=min\n            }\n        \
    \    i += 1\n        }\n        return max", "        var result : List[Long]\
    \ = Nil\n        var max = 0\n        var i : Long = 1\n        // If k is larger\
    \ than or equal than max then set max to k value.\n        // If k is smaller\
    \ than max then set max to maximum number in list minus k value.\n        while\
    \ ( i < arr.length ) {\n            max = arr.max\n            if ( k > max )\
    \ {\n                result = result :+ max\n                i = i + 1\n     \
    \       } else if ( k == max ) {\n                result = result :+ arr(i)\n\
    \                i = i + 1\n            } else if ( k < max ) {\n            \
    \    // If k is less than max then take arr element at index i as new max element.\n\
    \                result = result :+ arr(i) \n                i = i + 1\n     \
    \       }\n        }\n        return result ", "        val max = scala.collection.mutable.ListBuffer.empty[Long]\n\
    \        var i = 0\n        while (i < arr.length) {\n            if (arr(i) >\
    \ arr(i + 1)) {\n                max.append(arr(i))\n            } else {\n  \
    \              max.append(arr(i + 1))\n            }\n            i = i + 1\n\
    \        }\n        var j = 0\n        if (max.length < k) {\n            while\
    \ (j < k) {\n                max.append(0l)\n                j=j+1\n         \
    \   }\n        }\n        return max", "        if (k > arr.length) throw new\
    \ IllegalArgumentException\n        if (arr.isEmpty) return Nil\n        val m\
    \ = arr.min\n        if (m == -1l) {\n            val a = maximum(Nil, arr.length\
    \ - k)\n            val b = maximum(Nil, k)\n            return a ++ b \n    \
    \    }\n        if (m == 1l) return arr.sorted\n        val l = arr.indexOf(m)\
    \ + 1\n        val m = arr.drop(l).min\n        if (m == -1l) maximum(arr.take(l),\
    \ k)\n        else if (m == 1l) maximum(arr.take(l), k)\n        else maximum(arr.take(l\
    \ - 1).sorted ++ arr.take(l).sorted ++ arr.take(l + 1).sorted, k - 1) + maximum(arr.drop(l),\
    \ k)", "        // Your code here\n        val arrMap = arr.groupBy(i => i).map(x\
    \ => x -> x.last).sortBy(x => x._2).take(k)\n        val maxIndex = arrMap.keys.reverse.head\n\
    \        val maxValue = arrMap(maxIndex._1)\n        val maxList = arrMap(maxIndex)\n\
    \        val newList = maxList.tail.zip(maxList.tail.dropRight(1)):_*\n      \
    \  val newArr = newList.map(_._1):_*\n        arrMap.keys.map(arrMap(_)._1):_*\n\
    \        newArr", "        def maximum(arr : List[Long], k : Long, result : List[Long],\
    \ memo : mutable.Map[Long, List[Long]]): Unit = {\n            val maxValueIndex\
    \ = arr.indexOf(arr.max);\n            if (maxValueIndex == -1 || maxValueIndex\
    \ < k)\n                return ;\n            val maxValue = arr.max;\n      \
    \      memo put (maxValue, result)\n            arr.remove(maxValueIndex);\n \
    \           maximum(arr, k-1, result :+ maxValue, memo);\n            arr.remove(maxValueIndex);\n\
    \        }\n        maximum(arr, k, Nil, new mutable.HashMap[Long, List[Long]]());",
  "        var newList : List[Long] = Nil\n        var maxNum = arr(0)\n        var\
    \ index = -1\n        for(num <- arr){\n            if(num > maxNum){\n      \
    \          newList = newList :+ num\n                maxNum = num\n          \
    \      index = index + 1\n            }\n        }\n        var newNewList = newList\
    \ :+ maxNum\n        var num : Long = -1\n        if(k >= newNewList.length){\n\
    \            for(i <- 0 until newNewList.length){\n                if(i == 0){\n\
    \                    num = newNewList(i)\n                }else if(i == 1){\n\
    \                    if(num < newNewList(i)){\n                        num = newNewList(i)\n\
    \                    }\n                }else{\n                    if(num < newNewList(i)){\n\
    \                        num = newNewList(i)\n                    }\n        \
    \        }\n            }\n            newNewList = newNewList :+ num\n      \
    \  }\n        if(k <= newNewList.length){\n            newNewList = newNewList\
    \ :+ newNewList(newNewList.length - k)\n        }\n        return newNewList",
  "        var max = arr(0)\n        for(i <- 1 to arr.length-1){\n            if(arr(i)\
    \ > max){\n                max = arr(i)\n            }\n        }\n        val\
    \ res = arr.filter(_ == max)\n        for(i <- 1 to k){\n            val maxIndex\
    \ = res.indexOfMax\n            val maxIndexInRes = res.indexOf(max)\n       \
    \     if(maxIndex != maxIndexInRes){\n                res = res.updated(maxIndex,\
    \ max)\n            }\n            else{\n                res = res.updated(maxIndexInRes,\
    \ max)\n            }\n        }\n        res", "        if (k > arr.length) {\n\
    \            throw new RuntimeException(\"k should be less than arr.length\")\n\
    \        }\n        if (k == 0)\n            return arr\n        val len = arr.length\n\
    \        val n = new Array[Long](k)\n        var max = 0\n        var j = 0\n\
    \        var i = 1\n        for (m <- 0 until len) {\n            if (arr(m) >\
    \ arr(max)) {\n                max = m\n            }\n        }\n        while\
    \ (max >= 0 && (j <= k)) {\n            n(j) = arr(max)\n            max -= 1\n\
    \            j += 1\n        }\n        if (k > j)\n            n.slice(j)\n \
    \       else\n            n", "        def largest(arr : List[Long]) : List[Long]\
    \ = {\n            val max = arr(arr.length - 1)\n            var index = 0\n\
    \            arr.view.zipWithIndex.filter(_._1 > max).filter(_._2.isDefined).foreach{case(elem,\
    \ index) => {\n                if (index == k - 1) {\n                    arr(index)\
    \ = elem;\n                }\n            }\n        }\n        var size = arr.length\n\
    \        while(k <= size && arr.length > 0) {\n            largest(arr)\n    \
    \        size -= 1\n        }\n        arr", "        val length = arr.size\n\
    \        if(length < k) {\n            throw new IllegalArgumentException(\"k\
    \ must be less than arr.size\")\n        }\n        val arr = arr.sortWith(_ >\
    \ _)\n        val max = arr(length - k)\n        arr.dropRight(k)", "        //\
    \ Write your code here\n        var result: List[Long] = List[Long]()\n      \
    \  var maxNum : List[Long] = List[Long]()\n        var maxNumNum: Int = 0\n  \
    \      if(arr.length == 0){\n            result = List[Long]()\n        }\n  \
    \      else{\n            for(i<- 0 to arr.length - 1){\n                maxNumNum\
    \ = arr(i)\n                maxNum = List[Long]()\n                var maxIndex\
    \ = 0\n                for(j<- 0 to arr.length - 1){\n                    if(arr(i)\
    \ > arr(j)){\n                        maxNum = arr(j)\n                      \
    \  maxIndex = j\n                    }\n                }\n                for(j\
    \ <- 0 to maxIndex - 1){\n                    val tempNum = arr(j)\n         \
    \           val tempMaxNum = arr(maxIndex)\n                    if(tempNum > tempMaxNum){\n\
    \                        arr(maxIndex) = arr(j)\n                        arr(j)\
    \ = tempMaxNum\n                    }\n                }\n                result\
    \ = (result :+ maxNum)\n            }\n        }\n        if (k <= result.length)\n\
    \            result = result.take(k).toList\n        else\n            result\
    \ = result.take(result.length -k).toList\n        return result", "        val\
    \ n = arr.length\n        val k = k.toInt\n        if (k < 0 || k > n) {\n   \
    \         return null\n        }\n        var maxi = arr.head\n        for (i\
    \ <- 1 to k) {\n            val x = arr.min\n            if (x > maxi) {\n   \
    \             maxi = x\n            }\n        }\n        if (maxi < arr.last)\
    \ {\n            arr.tail ::: List(maxi)\n        } else {\n            arr.last\
    \ ::: List(maxi)\n        }", "        val lengths = arr.map(_.toLong)\n     \
    \   val result = new mutable.ListBuffer[Long]()\n        var max = 0\n       \
    \ while(max < k) {\n            if(lengths.contains(max)) {\n                result.+=max\n\
    \                lengths.remove(max)\n                max += 1\n            }\
    \ else {\n                break\n            }\n        }\n        if(result.nonEmpty)\
    \ {\n            result ++ arr.reverse.take(k-result.size)\n        } else {\n\
    \            result\n        }", "        var tmp : List[Long] = ListBuffer[Long]()\n\
    \        var i : Int = 0\n        var maxNum : Long = arr(0)\n        while(i\
    \ < k) {\n            if(tmp.isEmpty || arr(i) > maxNum) {\n                maxNum\
    \ = arr(i)\n                tmp = ListBuffer[Long]()\n            }\n        \
    \    i += 1\n            tmp += arr(i)\n        }\n        if (tmp.isEmpty) tmp\n\
    \        else tmp.sort((x, y) => if (x > y) -1 else if (y > x) 1 else 0)", " \
    \       def search(arr: List[Long], k : Long) : List[Long] = {\n            if\
    \ (k == 0) arr\n            else search(arr.tail, k - 1) match {\n           \
    \     case Nil => arr\n                case x :: xs => {\n                   \
    \ val m = Math.max(arr.head.asInstanceOf[Long], x.asInstanceOf[Long])\n      \
    \              x :: xs.filter(v => v > m)\n                }\n            }\n\
    \        }\n        search(arr.take(k), k)", "        val result = new mutable.PriorityQueue[Long](arr.size\
    \ by -Int, InOrder[Long])\n        var i = 0\n        while (i < arr.size) {\n\
    \            if (result.size < k)\n                result += arr(i).toLong\n \
    \           i += 1\n        }\n        result.toList.sortBy(x => -x)", "     \
    \   var m = arr.head\n        var x = List[Long](arr.toList)\n        while (k\
    \ >= x.length) {\n            x ::= List(m)\n            m = m + 1\n        }\n\
    \        return x", "        val result = new mutable.ListBuffer[Long]()\n   \
    \     if (arr.length < k) result\n        else {\n            var m = arr.head\n\
    \            var n = arr(arr.length-1)\n            val rest = arr.tail\n    \
    \        while (n<k){\n                if(m>n) result += m\n                m\
    \ = n\n                n = rest\n            }\n            result += m\n    \
    \    }\n        result.toList", "        val n = arr.size\n        val max = arr(n)\n\
    \        var i = n - 1\n        var j = k - 1\n        val r = new ArrayList[Long](k)\n\
    \        while (i-- > 0 && j-- > 0) {\n            if (arr(i) > arr(j)) r += arr(i)\n\
    \            else r += arr(j)\n        }\n        while (i-- > 0) r += arr(i)\n\
    \        while (r.size() > 0) {\n            r.remove(max);\n        }\n     \
    \   r.toList", "        val maximums = mutable.PriorityQueue[Long]()\n       \
    \ for(i <- 0 until arr.length) {\n            if (maximums.size + 1 == k || maximums.size\
    \ == k && arr(i) > maximums.head) {\n                maximums.enqueue(arr(i))\n\
    \            }\n        }\n        val result: List[Long] = new ArrayList[Long](k)\n\
    \        for(i <- 0 until k) {\n            if (maximums.contains(arr(i))) {\n\
    \                result.add(arr(i))\n            } else {\n                result.add(maximums.dequeue())\n\
    \            }\n        }\n        result", "        if (arr.isEmpty)\n      \
    \      return arr\n        val m = arr.toSet // O(n)\n        val l = new mutable.PriorityQueue[Long]()\
    \ // O(k log n)\n        for (i  <- 0 until k) {\n            if (m.contains(-1000\
    \ + i)) l.enqueue(-1000 + i)\n            if (m.contains(1000 + i)) l.enqueue(1000\
    \ + i)\n        }\n        l.toList", "        if(arr.length < k || k > arr.length)\
    \ {\n            throw new IllegalArgumentException\n        }\n\n        var\
    \ result : List[Long] = Nil\n        var maxCount : Long = 0\n        var minCount\
    \ : Long = 0\n        var i : Int = 0\n        while (i < arr.length) {\n    \
    \        if(arr(i) > maxCount) {\n                result = result :+ arr(i)\n\
    \                maxCount = arr(i)\n            } else if (arr(i) < minCount)\
    \ {\n                result = result :+ arr(i)\n                minCount = arr(i)\n\
    \            } else\n                result = result :+ arr(i)\n            i\
    \ += 1\n        }\n        result :+ minCount", "        val len = arr.length\n\
    \        val m = k / len\n        val result = (len > 0) ? arr.take(m * len) :\n\
    \            arr.take(len - m * len)\n        (len > 0) ? result.sortWith(_ >\
    \ _) : result", "        val m = arr.take(k).max\n        if (m == 0l) {\n   \
    \         arr\n        } else {\n            arr ::: List(m).take(k-arr.length).toList\n\
    \        }", "        if (arr.length < 1 || arr.length < k) throw new IllegalArgumentException\n\
    \        if (k > arr.length) throw new IllegalArgumentException\n\n        val\
    \ result = new mutable.ArrayList[Long]()\n\n        var max = -99999.0 // the\
    \ largest number in arr\n        var i = 0\n        var j = 0\n\n        // The\
    \ inner loop is used to determine the max number in arr\n        for (i <- 0 until\
    \ k) {\n            max = -99999.0\n            val maxIndex : Int = -1\n    \
    \        for (j <- 0 until arr.length) {\n                if (max < arr(j)) max\
    \ = arr(j)\n                if (arr(j) == max) maxIndex = j\n            }\n\n\
    \            // Add to result if arr contains maximum k numbers\n            if\
    \ (maxIndex >= 0) {\n                result.add(maxIndex)\n                max\
    \ = -99999.0\n            }\n        }\n\n        return result.toList", "   \
    \     val l = arr.length\n        if(l < 1) return\n        val k = Math.min(n,\
    \ k)\n        if(k <= l) arr.take(k)\n        else {\n            val maxs = arr.sortWith(_\
    \ > _)\n            val res = for (i <- 0 until k) yield maxs(i)\n           \
    \ res\n        }", "        if (arr.length == 0)\n            return List()\n\
    \        else if (arr.length == 1)\n            return arr.toList\n        else\
    \ if (arr.head > arr(arr.length - 1))\n            return maximum(arr.tail, k)\n\
    \        else {\n            var result: List[Long] = List()\n            var\
    \ maxCount = 0\n            var max: Long = -1000\n            val count = mutable.ArrayBuffer.empty[Long]\n\
    \            for (i <- 0 until arr.length) {\n                if (arr(i) == arr.last)\
    \ {\n                    count += i\n                    if (count > max)\n  \
    \                      max = count\n                } else {\n               \
    \     count += arr.length\n                    if (count > max)\n            \
    \            max = count\n                }\n            }\n            for (i\
    \ <- 0 until max) {\n                result += arr.take(i)\n            }\n  \
    \          if (max > k) {\n                result match {\n                  \
    \  case Nil => List()\n                    case head :: tail => maximum((tail),\
    \ k - head).toList ++ result\n                }\n            } else result\n \
    \       }", "        var result : List[Long] = Nil\n        if (arr.isEmpty) {\n\
    \            return result\n        }\n        if (k <= 0) {\n            return\
    \ result\n        }\n        var lowIndex = 0\n        var highIndex = arr.length-1\n\
    \        val high = arr(highIndex)\n        while (k > 0 && lowIndex < highIndex)\
    \ {\n            val currentMax = arr(lowIndex).max(high)\n            if (currentMax\
    \ == high) {\n                result ::= arr(lowIndex)\n                lowIndex\
    \ += 1\n            } else {\n                result ::= currentMax\n        \
    \        k -= 1\n            }\n            highIndex -= 1\n        }\n      \
    \  result", "        if (arr.isEmpty) List() else if (arr.length == 1) k else\
    \ if (k == 1) arr else if (k > arr.length) List(0) else { val n = arr.length;\
    \ val c = k % n; val m = k / n; val r = arr.map(i => (i - c) % n) //r: List[Long]\
    \ = List(-6, -3, -2, -1, 0, 5, 1)\n        val m = math.max(0, k - c)\n      \
    \  val r2 = r.drop(m).take(m).sorted\n        val r3 = r.drop(k).take(k).sorted\n\
    \        (r2 :+ r3).reverse }", "        if(arr.isEmpty) arr\n        else {\n\
    \            val size = arr.length\n            val maxSize = size - k\n     \
    \       val maxList = arr.take(maxSize)\n            val maxSort = maximumSort(maxList)\n\
    \            arr ++ maxSort\n        }", "        val nums = arr.sortWith((x:Long,\
    \ y:Long)=> x-y)\n        var maxk = k\n        var result: List[Long] = new ListBuffer[Long]()\n\
    \        while(maxk > 0) {\n            result.append(nums.head); maxk -= 1\n\
    \        }\n        result.toList", "        def dfs(arr : List[Long], k : Long,\
    \ visited : mutable.Set[Long]) : List[Long] = {\n            if(arr.isEmpty) return\
    \ Nil\n            if(k <= 0 || k > arr.length) return dfs(arr.tail, k-1, visited)\n\
    \            visited += arr(0)\n            List(arr(0)) ++ dfs(arr.tail, k-arr.length,\
    \ visited)\n        }\n        val visited = mutable.Set[Long]()\n        dfs(arr,\
    \ k, visited)", "        var result = new List[Long](k)\n        var index = 0\n\
    \        for (item <- arr) {\n            if (item > result.last) index += 1\n\
    \            else result = result.drop(index)\n            result(index) = item\n\
    \        }\n        return result", "        // write your code here\n       \
    \ val m = arr.length\n        val result = Array[Long](k).fill(-1l.toLong)\n \
    \       for(i <- 0 to k-1) result(i) = (max(arr.take(i+1), arr.take(i))).toLong\n\
    \        result", "        if (arr.length < k) {\n            throw new IllegalArgumentException(\"\
    k must be larger than arr.length\")\n        }\n        val result = new mutable.ListBuffer[Long]()\n\
    \        var max = 0L\n        var i = 0\n        while (i < arr.length) {\n \
    \           if (arr(i) > max) {\n                max = arr(i)\n            }\n\
    \            i += 1\n        }\n        while (i < k) {\n            max += 1\n\
    \            i += 1\n        }\n        while (i < arr.length) {\n           \
    \ val tmp = arr(i)\n            if (tmp > max) {\n                max = tmp\n\
    \            }\n            i += 1\n        }\n        result.add((max - 1l).abs)\n\
    \        result", "        var max : List[Long] = Nil\n        var max : Long\
    \ = -1\n        var arrLength = 0\n        var i = arr.length-1\n        var temp\
    \ : Long = 0\n        var j = 0\n        // check length of arr\n        for(j<-\
    \ 0 until arr.length){\n            arrLength = arrLength + arr(j).asInstanceOf[Long]\n\
    \        }\n        // check k <= arrLength\n        if (k <= arrLength){\n  \
    \          // sort arr\n            for(i<- 0 until arrLength){\n            \
    \    temp = arr(j).asInstanceOf[Long]\n                if(temp > arr(i)){\n  \
    \                  arr(j)= arr(i)\n                    arr(i)= temp\n        \
    \        }\n            }\n            // find max\n            for(i<- 0 until\
    \ arr.length){\n                temp = arr(i).asInstanceOf[Long]\n           \
    \     if(temp > max){\n                    max = temp\n                }\n   \
    \         }\n            // sort arr\n            for(j<- 0 until arr.length){\n\
    \                temp = arr(j).asInstanceOf[Long]\n                if(temp > max){\n\
    \                    max = temp\n                }\n            }\n          \
    \  // return max\n            return arr\n        }\n        else{\n         \
    \   for(i<- 0 until arr.length){\n                temp = arr(i).asInstanceOf[Long]\n\
    \                if(temp > max){\n                    max = temp\n           \
    \     }\n            }\n            return max\n        }", "        var maxVal\
    \ = arr(0)\n        var maxLen = 0\n        for (elem <- arr.drop(1))\n      \
    \      if (elem > maxVal)\n                maxVal = elem\n            if (elem.toLong\
    \ > k)\n                maxLen = k\n        arr.take(maxLen).reverse ", "    \
    \  val res = mutable.ArrayBuffer(0)\n      if(arr.size < 1) {\n        res\n \
    \     } else {\n        var max = -1000\n        for(i <- 0 until arr.size) {\n\
    \          if(max < arr(i)) {\n            max = arr(i)\n          }\n       \
    \ }\n        if(max < 0) {\n          res.clear()\n        } else {\n        \
    \  for(i <- 0 until k) {\n            res += max\n          }\n        }\n   \
    \   }\n      res", "        val maxList = new mutable.PriorityQueue[Long]()\n\
    \        val maxList2 = new mutable.PriorityQueue[Long]()\n        val maxList3\
    \ = new mutable.PriorityQueue[Long]()\n        var maxVal = arr.last\n       \
    \ val maxVal2 = arr.last\n        val maxVal3 = arr.last\n        var maxK = k\n\
    \        var maxK2 = k\n        var maxK3 = k\n        val maxValArr = new mutable.PriorityQueue[Long]()\n\
    \        val maxValArr2 = new mutable.PriorityQueue[Long]()\n        val maxValArr3\
    \ = new mutable.PriorityQueue[Long]()\n        val maxKArr = new mutable.PriorityQueue[Long]()\n\
    \        val maxKArr2 = new mutable.PriorityQueue[Long]()\n        val maxKArr3\
    \ = new mutable.PriorityQueue[Long]()\n        val maxKMin = k\n        for (i\
    \ <- 0 until arr.length) {\n            if (maxK >= arr.length) {\n          \
    \      break\n            }\n            if (arr.contains(maxVal)) {\n       \
    \         if (maxValArr2.contains(maxVal2)) {\n                    if (maxValArr3.contains(maxVal3))\
    \ {\n                        if (maxKArr2.contains(maxK2)) {\n               \
    \             if (maxKArr3.contains(maxK3)) {\n                              \
    \  maxKArr.add(maxVal)\n                                maxKArr2.add(maxVal2)\n\
    \                                maxKArr3.add(maxVal3)\n                     \
    \           maxKMin = k\n                                maxK = k\n          \
    \                  } else {\n                                maxKArr.add(maxVal)\n\
    \                                maxKArr2.add(maxVal2)\n                     \
    \           maxKArr3.add(maxVal3)\n                                maxKMin = k\n\
    \                                maxK = k\n                            }\n   \
    \                     } else {\n                            maxKArr.add(maxVal)\n\
    \                            maxKArr2.add(maxVal2)\n                         \
    \   maxKArr3.add(maxVal3)\n                            maxKMin = k\n         \
    \                   maxK = k\n                        }\n                    }\
    \ else {\n                        maxKArr.add(maxVal)\n                      \
    \  maxKArr2.add(maxVal2)\n                        maxKArr3.add(maxVal3)\n    \
    \                    maxKMin = k\n                        maxK = k\n         \
    \           }\n                } else {\n                    maxKArr.add(maxVal)\n\
    \                    maxKArr2.add(maxVal2)\n                    maxKArr3.add(maxVal3)\n\
    \                    maxKMin = k\n                    maxK = k\n             \
    \   }\n            } else {\n                if (maxValArr2.contains(maxVal2))\
    \ {\n                    if (maxKArr2.contains(max", "        if (arr.isEmpty)\
    \ {\n            List[Long]()\n        }\n        if (arr.size <= k) {\n     \
    \       arr\n        }\n        else {\n            val m = arr.head\n       \
    \     val t = arr.remove(m)\n            if (k > arr.size) {\n               \
    \ val r = maximum(arr, k)\n                arr :+ m\n            }\n         \
    \   else {\n                val r = maximum(arr, k)\n                arr :+ m\
    \ +: t\n            }\n        }", "        val len = arr.length\n        val\
    \ arr = arr.sortBy(x => -x).toArray\n        val maxArr : List[Long] = new Array[Long](k)\n\
    \        var i = 0\n        var j = 0\n        while (j < k) {\n            if\
    \ (j < len) {\n                if (arr(j) > arr(j + 1)) {\n                  \
    \  j++\n                }\n            }\n            maxArr(i) = arr(j)\n   \
    \         i += 1\n            j++\n        }\n        val result = new ArrayList[Long](k)\n\
    \        for (i = 0; i < k; i++) {\n            result(i) = maxArr(i)\n      \
    \  }\n        return result.toList", "        if (arr.length < 1 || k < 0 || k\
    \ >= arr.length) {\n            throw new IndexOutOfBoundsException(\"IndexOutOfBoundsException\"\
    )\n        }\n        \n        val size = arr.length\n        val list = mutable.ArrayBuffer(arr.head)\n\
    \        val max = list.head\n        \n        for (x <- arr diff list.tail)\
    \ {\n            if (x < max || x == max) {\n                max += x\n      \
    \      }\n        }\n\n        list ++ List(max)", "        var max = Long.MinValue\n\
    \        var maxIndex = 0\n        for (i <- 0 until k) {\n            if (arr(i)\
    \ > max) {\n                max = arr(i)\n                maxIndex = i\n     \
    \       }\n        }\n        var res = arr.take(maxIndex + 1).sortWith(_ > _)\n\
    \        for (i <- 0 until k) {\n            if (arr(i) == max) {\n          \
    \      res(i) = arr(i)\n            }\n        }\n        res.toList", "     \
    \   require(arr.length < 1000)\n        require(k <= arr.length)\n        val\
    \ result = new ArrayBuffer[Long]\n        var max = 0\n        var min = 0\n \
    \       var current = 0\n\n        for (i <- arr.indices)\n        {\n       \
    \     if (current < k)\n            {\n                if (max < arr(i))\n   \
    \             {\n                    max = arr(i)\n                    result.clear()\n\
    \                    current = 1\n                }\n            }\n         \
    \   else\n            {\n                if (arr(i) > max)\n                {\n\
    \                    max = arr(i)\n                    result.clear()\n      \
    \          }\n            }\n            if (arr(i) < min)\n            {\n  \
    \              min = arr(i)\n                result.clear()\n            }\n \
    \           current += 1\n        }\n        result.toList", "        val n =\
    \ (arr zip arr.takeRight(k).toList).foldLeft((arr zip arr.takeRight(k).toList).map{case\
    \ (x, y) => (x._1 > y._1) ? x : y}.last)\n        List(n._2)", "        require(0\
    \ <= k && k <= arr.length)\n        val result = arr.toList.sortBy(-_).take(k).toList\n\
    \        result", "        val maxNum = arr.sortWith(_.compareTo(_) > 0)\n   \
    \     val maxLen = maxNum.length\n        if (maxLen <= k) {\n            arr\n\
    \        } else {\n            val maxList = List[Long]()\n            for (i\
    \ <- 0 until k) {\n                maxList :+= maxNum(i)\n            }\n    \
    \        maxList\n        }", "        // Your code here\n        // Solution\
    \ 1: Sort the list\n        val sortedList = arr.sortBy(_*).take(k)\n        val\
    \ reverseList = sortedList.reverse\n        val sortedArray = reverseList.map(_.toLong)\n\
    \        val result = sortedArray.toList\n        result", "        def helper(arr:\
    \ mutable.ListBuffer[Long], k: Long): List[Long] = {\n            if (arr.size\
    \ == k) {\n                arr.toList\n            }\n            else {\n   \
    \             val i = arr.lastIndex\n                val res = arr.dequeue\n \
    \               val n = k - res.size + 1\n                if (n == 0) helper(arr,\
    \ k)\n                else if (n > 0) helper(arr.enqueue(res :: arr.takeRight(n)),\
    \ n)\n                else helper(arr.enqueue(res), k)\n            }\n      \
    \  }\n        val arrBuffer = arr.toList\n        val result = helper(arrBuffer,\
    \ k)\n        result.sortWith(_ > _)", "        val maxLength = arr.length\n \
    \       val maxIndex = arr.index(arr.max);\n        val newArr = Array.ofDim[Long](maxLength)\n\
    \        var i = 1\n        while(i <= maxLength) {\n            if(arr[maxIndex\
    \ - i] < arr(maxIndex - i-1)) {\n                newArr(maxIndex - i) <- arr[maxIndex\
    \ - i];\n                i += 1\n            } else {\n                newArr(maxIndex\
    \ - i) <- arr(maxIndex - i-1);\n            }\n        }\n        return newArr.toList",
  "        // Write your code here.\n        var result: List[Long] = Nil\n      \
    \  if (arr.length < 1) {\n            return Nil\n        }\n        if (arr.length\
    \ == 1) {\n            return Nil\n        }\n        if (k <= 1) {\n        \
    \    return arr\n        }\n        val low = arr.last\n        var flag = true\n\
    \        for (x <- arr) {\n            if (x <= low) {\n                flag =\
    \ false\n            }\n        }\n        if (flag) {\n            return arr\n\
    \        }\n        var high = arr.first\n        var count = 0\n        for (x\
    \ <- arr) {\n            if (x > high) {\n                count = count + 1\n\
    \                high = x\n            }\n        }\n        for (x <- 0 until\
    \ k) {\n            result.add(high)\n        }\n        result", "        val\
    \ m = arr.foldLeft(List[Long]())(_ :: _)\n        if (m.size < k) m\n        else\
    \ m.sortBy(_._2).take(k)", "        var max = List[Long]()\n        var index\
    \ = 0\n        while(arr.length != 0){\n            var m = arr.head\n       \
    \     arr.remove(arr.head)\n            while(index != k-1 && arr.length != 0){\n\
    \                var n = arr.head\n                if(n > m){\n              \
    \      max = List(arr.head, m)\n                    arr.remove(arr.head)\n   \
    \                 index++\n                }\n                else{\n        \
    \            m = n\n                    arr.remove(arr.head)\n               \
    \ }\n            }\n            max = max ++ List(m)\n        }\n        return\
    \ max", "        val result = new mutable.LinkedList[Long]()\n        val maxVal\
    \ = arr.sortBy(l => -l).last\n        var maxCount = 1\n        var last = 0\n\
    \        var i = arr.size\n        while (i >= 1) {\n            val thisVal =\
    \ arr(last)\n            if (thisVal >= maxVal) {\n                last++\n  \
    \              maxCount++\n                result.addLast(thisVal)\n         \
    \   } else {\n                last++\n                maxCount = 1\n         \
    \   }\n            i -= 1\n        }\n        if (maxCount > k) {\n          \
    \  var j = result.size\n            while (j > (k - maxCount)) {\n           \
    \     j--\n                result.addLast(result(j))\n            }\n        \
    \    result.addLast(result(k - maxCount))\n        }\n        result", "     \
    \   if (arr.isEmpty) Nil\n        else (0 to k-1)\n                .flatMap(i\
    \ => { \n                    val r = arr.slice(i+1, arr.length).max\n        \
    \            (0 to i).map(_ => r); \n                })\n                .flatten",
  "        val nums = arr.toIndexedSeq\n        val n = nums.length\n        val len\
    \ = k\n        val numsLeft = nums.tail\n        val numsRight = nums.take(n)\n\
    \        val leftLen = len - numsLeft.length\n        val rightLen = numsRight.length\n\
    \        val leftIdx = numsLeft.indices\n        val rightIdx = numsRight.indices\n\
    \        val l = if (leftLen >= 1) numsLeft.take(leftLen) else numsLeft\n    \
    \    val r = if (rightLen >= 1) numsRight.take(rightLen) else numsRight\n    \
    \    val left = numsLeft.take(l)\n        val right = numsRight.take(r)\n    \
    \    val result = left.zip(right).sortWith(_._1 < _._1).reverse.take(k)\n    \
    \    result.toList", "      val n = arr.length\n      val result = new Array[Long](k)\n\
    \      \n      // Sort arr with O(n*logn) time complexity, use insertion sort\
    \ with \n      // O(n) time complexity, use merge sort with O(nlogn) time complexity\n\
    \      val start  = System.nanoTime\n      var i = 1 // i = 1 means first element\
    \ in arr\n      var j = 0\n      var tmp : Long = 0\n      while(i < n) {\n  \
    \      // Keep inserting elements from arr into result until k numbers are \n\
    \        // sorted\n        while(j < k) {\n          tmp = arr(i)\n         \
    \ if (tmp > arr(j)) {\n            tmp = arr(j)\n          }\n          j++\n\
    \          result(j) = tmp\n        }\n        result(k) = arr(i)\n        j =\
    \ 0\n        i += 1\n      }\n      val end = System.nanoTime\n      println(\"\
    The total time complexity of sorting using insertion sort is \"+\n        (end\
    \ - start)/1000000+\"ms.\")\n      \n      // Sort arr with O(n) time complexity,\
    \ use merge sort with O(nlogn) \n      // time complexity, use selection sort\
    \ with O(n) time complexity\n      start  = System.nanoTime\n      i = 1\n   \
    \   j = 1\n      while(j < k) {\n        if(arr(i) < arr(j)) {\n          tmp\
    \ = arr(i)\n          arr(i) = arr(j)\n          arr(j) = tmp\n          i +=\
    \ 1\n          j += 1\n        }\n        else {\n          tmp = arr(j)\n   \
    \       arr(j) = arr(i)\n          arr(i) = tmp\n          j += 1\n        }\n\
    \      }\n      end = System.nanoTime\n      println(\"The total time complexity\
    \ of sorting using merge sort is \"+\n        (end - start)/1000000+\"ms.\")\n\
    \      \n      result", "        val m = arr.dropRight(k)\n        val n = arr.takeRight(k)\n\
    \        if(m.isEmpty) n\n        else maximum(m + n, k)", "        // Your code\
    \ here\n        // Implement your code\n        \n        // Write your code here\n\
    \        return arr.sortWith(_ < _).take(k)", "        var maxSize = 0\n     \
    \   var maxElem = scala.math.MinLong.max(arr(0)) //initialize min element as min\
    \ of arr\n        for(i <- 0 until arr.length) {\n            if(maxSize == k)\
    \ {\n                if(maxElem <= arr(i)) {\n                    maxElem = arr(i)\n\
    \                }\n            } else {\n                maxSize += 1\n     \
    \           maxElem = scala.math.MinLong.max(arr(i), maxElem)\n            }\n\
    \        }\n        val res = mutable.ListBuffer.empty[Long]\n        if(maxSize\
    \ > k) {\n            for(i <- 0 until k) {\n                res ++= arr(scala.math.math.max(i,\
    \ maxSize - 1))\n            }\n        } else {\n            res += maxElem\n\
    \        }\n        res.toList", "        val maxNums = mutable.ListBuffer.empty[Long]\n\
    \        var index = 0\n        for ((index, num) <- arr.zipWithIndex) {\n   \
    \         if (num > maxNums.last) maxNums.append(num)\n            if (index >\
    \ k) break\n        }\n        maxNums", "        def rec(arr : List[Long], k\
    \ : Long) : List[Long] = {\n            arr.head match {\n                case\
    \ Nil => arr.tail\n                case head :: tail => {\n                  \
    \  if(k > 0) {\n                        rec(tail, k-1)\n                    }\
    \ else {\n                        List(head) :: rec(tail, arr.length-1)\n    \
    \                }\n                }\n            }\n        }\n        List(arr(0))\
    \ match {\n            case Nil => List(arr(k))\n            case head :: tail\
    \ => rec(tail, k)\n        }", "      arr.sortBy(_ > arr.max)\n      val result\
    \ = new collection.mutable.ListBuffer[Long]()\n      while ( result.size < k )\
    \ {\n         result.append ( arr.head )\n         arr.remove(arr.head)\n    \
    \  }\n      result.toList", "        val l = arr.length\n        if(l < 1 || k\
    \ < 1 || k >= l) return null\n        val max = arr(0)\n        val max2 = Math.max(max,\
    \ k)\n        val max3 = Math.max(max, max2)\n        arr.drop(1).filter(_ > max3).zipWithIndex.map\
    \ {\n            case (x, i) => (x, i)\n        }.filter(_._2 != max2).sortWith(_.first\
    \ < _.second).take(k)", "        val sortedArr = arr.sortBy(a => -a)\n       \
    \ val len = sortedArr.length\n        if (k > len) throw new IllegalArgumentException(\"\
    k is too large.\")\n        var maxResult = sortedArr.take(k) \n        val newMax\
    \ = if (k == sortedArr.length) sortedArr else sortedArr.take(k).max\n        val\
    \ newMaxList = newMax.toList\n        var i = k\n        while (i < len) {\n \
    \           if (sortedArr(i) <= newMax) {\n                maxResult :+ sortedArr(i)\n\
    \                i += 1\n            } else {\n                maxResult = maxResult\
    \ :+ newMaxList\n                i += 1\n            }\n        }\n        maxResult",
  "        if (arr.isEmpty)\n            List()\n        else {\n            if (arr.length\
    \ == 1)\n                List(arr(0))\n            else {\n                val\
    \ pivot = arr.head\n                val max1 = maximum(arr.filter(_ < pivot),\
    \ k - 1)\n                val max2 = maximum(arr.filter(_ > pivot), k - 1)\n \
    \               max1 ++ max2\n            }\n        }", "        var max = List[Long]()\n\
    \        for (i<-0 until arr.size) {\n            if (arr(i) >= k) {\n       \
    \         max ::= arr(i)\n            } else {\n                max = (arr(i)\
    \ :: max).sortWith(_ > _)\n            }\n        }\n        max", "        //\
    \ write your code here\n        val maxSize = k\n        val maxArr = arr.sortWith(_.compare\
    \ <= _.compare)\n        val maxArray = maxArr.take(maxSize).toList\n        \n\
    \        if (maxArray.size < k) {\n            val tempArr = maxArr.take(maxArray.size).toList\n\
    \            tempArr::maximum(tempArr, k)\n        } else {\n            maxArray\n\
    \        }", "        val arr = arr.toList\n        var maxArr: List[Long] = List()\n\
    \        var maxIndex = 0\n        var currentMax = 0\n        \n        while(maxIndex\
    \ < arr.length - k) {\n            currentMax = arr(maxIndex)\n            val\
    \ newMax = arr(maxIndex + k - 1)\n            if (newMax > currentMax) {\n   \
    \             maxIndex += k\n                maxArr = ArrayBuffer(maxArr, newMax)\n\
    \            } else {\n                maxIndex += k - 1\n                maxArr\
    \ = maxArr.toList\n            }\n        }\n        maxArr", "        val len\
    \ = arr.size\n        if (k <= 0 || len < k) {\n            return List();\n \
    \       }\n        val arr = arr.sort\n        val max = new Array[Long](k)\n\
    \        for (i <- 0 until k) {\n            max(i) = 0\n        }\n        val\
    \ maxIndex = 0\n        val startIndex = 0\n        val endIndex = 0\n       \
    \ for (i <- 0 until arr.size - 1) {\n            if (arr(i) > max(maxIndex)) {\n\
    \                maxIndex(maxIndex) = 0\n                startIndex(startIndex)\
    \ = i\n                endIndex(endIndex) = i\n                maxIndex(startIndex)\
    \ = 1\n                startIndex = startIndex + 1\n            } else if (arr(i)\
    \ > max(maxIndex)) {\n                maxIndex(maxIndex) = 0\n               \
    \ startIndex(startIndex) = i\n                endIndex(endIndex) = i\n       \
    \         maxIndex(startIndex) = 1\n                startIndex = startIndex +\
    \ 1\n            } else if (arr(i) == max(maxIndex)) {\n                maxIndex(maxIndex)\
    \ = 1\n                startIndex = startIndex + 1\n            }\n        }\n\
    \        val res = new Array[Long](k)\n        for (i <- 0 until k) {\n      \
    \      res(maxIndex(i)) = 0\n        }\n        for (i <- 0 until startIndex to\
    \ endIndex) {\n            res(res(resIndex)) = arr(i)\n            res(resIndex)\
    \ = resIndex + 1\n            resIndex = resIndex + 1\n        }\n        res",
  "        val max = mutable.ArrayBuffer.empty[Long]\n        val len = arr.length\n\
    \        for( i <- 0 to (len-1) ){\n            if( arr.max <= (arr(i) + k) )\
    \ {\n                max += arr(i)\n            }\n        }\n        max.toList",
  "        if (arr.length == 0 || k < 0) \n            Nil\n        else\n       \
    \     if (arr.length == 1) \n                arr.sortBy(_)\n            else {\n\
    \                val maxIndex = arr.lastIndexWhere(_ == arr.max)\n           \
    \     val leftList = arr.take(maxIndex - k)\n                val rightList = arr.drop(maxIndex).take(k)\n\
    \                leftList.sortBy(_) ::: rightList.sortBy(_)\n            }", " \
    \       val indexedArr = arr.zipWithIndex.sortBy(_._1).reverse\n        val leftIndex\
    \ = indexedArr.take(k-1)\n        val rightIndex = indexedArr.drop(k-1)\n    \
    \    (leftIndex.map(_._2), rightIndex.map(_._2))", "        val len = arr.length\n\
    \        if(k <= 0 || k >= len)\n            throw new Exception(\"k is out of\
    \ range\")\n        var max = arr(0)\n        var max_i = 1;\n        for(i <-\
    \ 1 until len) {\n            if(arr(i) > max) {\n                max = arr(i)\n\
    \                max_i = i\n            }\n        }\n        return arr.toList\
    \ ++ List(max :: arr(max_i - k :: len - 1))", "        var maxLength = 0\n   \
    \     var maxIndex = arr.length-1\n        var maxElem = arr(maxIndex)\n     \
    \   while ( maxLength < k) {\n            while (maxIndex >= 0) {\n          \
    \      maxElem = arr(maxIndex)\n                if (maxElem > maxElem) {\n   \
    \                 maxElem = maxElem\n                    maxIndex = maxIndex-1\n\
    \                }\n                maxLength += 1\n            }\n          \
    \  maxIndex -= 1\n        }\n        if (maxLength < k) {\n            return\
    \ Arrays.copyOfRange(arr.toArray, maxIndex+1, maxIndex+k)\n        } else {\n\
    \            return Arrays.copyOfRange(arr.toArray, maxIndex, maxIndex+1)\n  \
    \      }", "        var result : List[Long] = List[Long]()\n        var cur :\
    \ Long = 0\n        var maxNum : Long = arr(0)\n        var maxIndex = 0\n   \
    \     for ( i <- 1 until arr.length && arr.length > 0 ) {\n            if ( maxNum\
    \ < arr(i) ) {\n                maxNum = arr(i)\n                maxIndex = i\n\
    \            }\n        }\n        var max = maxNum\n        while ( cur < arr.length\
    \ && max < k ) {\n            if ( cur < maxIndex + 1 ) {\n                max\
    \ += arr[cur]\n                cur += 1\n            } else {\n              \
    \  result += List(maxNum)\n                max += arr[maxIndex + 1]\n        \
    \        cur += 1\n            }\n        }\n        result ++= List(arr[maxIndex])\n\
    \        result", "        val maxSeq = if (arr.size == k) arr\n        else arr\
    \ ++ new Long(arr.size - k).sorted\n        val maxNums = maxSeq.takeWhile(_ <\
    \ arr.last)\n        val kRange = arr.last.toInt - k.toInt\n        val newMaxSeq\
    \ = new Long(kRange).sorted\n        val newMaxNums = newMaxSeq.takeWhile(_ <\
    \ arr.last)\n        val maxResult = maxNums ++ newMaxNums\n        maxResult",
  "        if (arr.size < 2) throw new ArithmeticException(\"array size cannot be\
    \ less than 2\")\n        var max = Integer.MIN_VALUE\n        var result = List[Long]()\n\
    \        for (i <- 0 until arr.size) {\n            if (arr(i) > max) {\n    \
    \            max = arr(i)\n                result = arr.filter(_ <= max)\n   \
    \         }\n        }\n        if (result.size < k) throw new ArithmeticException(\"\
    array size cannot be less than k\")\n        result", "        // write your code\
    \ here\n        val sortedList = new ListBuffer[Long]()\n        var pos = -1\n\
    \        var numOfElements = 0\n\n        for ( i <- 0 until arr.length ) {\n\
    \            if ( numOfElements < k ) {\n                pos -= 1\n          \
    \  }\n            else if ( numOfElements < k && pos == -1 ) {\n             \
    \   pos = i\n                numOfElements += 1\n            }\n            if\
    \ ( numOfElements == k ) {\n                if ( pos == -1 ) {\n             \
    \       sortedList += arr(i)\n                }\n                else {\n    \
    \                if ( arr(i) < arr(pos) ) {\n                        sortedList\
    \ += arr(i)\n                    }\n                    else {\n             \
    \           sortedList += arr(pos)\n                    }\n                }\n\
    \                numOfElements = 0\n            }\n        }\n        sortedList.toList",
  "        var result : List[Long] = Nil\n        arr.toList.sortWith( (a, b) => math.signum(a-b).reverse\
    \ )\n        result.init = arr.take(k)\n        result", "        // Write your\
    \ code here.\n        val maxList = arr.filter(_ > 0l).toList\n        val min\
    \ = arr(0)\n        val max = arr(0)\n        for (elem <- arr) {\n          \
    \  if (elem > max) {\n                max = elem\n            }\n            if\
    \ (elem < min) {\n                min = elem\n            }\n        }\n     \
    \   val mid = max * (max / min)\n        val list = arr.filter(_ < mid).toList\n\
    \        list.sortWith(_ > _).take(k).map(_ => mid)", "        var maxArr : List[Long]\
    \ = Nil\n        var maxIndex : Long = 0\n        for (i<- 0 until arr.length)\
    \ {\n            if (arr(i) > maxArr(0)) {\n                maxIndex = i\n   \
    \             maxArr = List(arr(i))\n            } else if (arr(i) == maxArr(0))\
    \ {\n                maxArr = maxArr:::List(arr(i))\n            }\n        }\n\
    \        maxArr.length <= k match {\n            case true => {\n            \
    \    maxArr.take(k)\n            }\n            case false => {\n            \
    \    val numToReturn : Long = Math.ceil(k / maxArr.length).toLong\n          \
    \      val returnArr = maxArr.take(numToReturn)\n                returnArr.zip(arr.drop(numToReturn)).foldLeft(returnArr)((returnArr,\
    \ currentVal) => returnArr:::currentVal)\n            }\n        }", "       \
    \ val m = arr.length\n        if(m == 0) Nil\n        else {\n            var\
    \ max = -Long.MaxValue\n            var maxIndex = -1\n            var i = 0\n\
    \            for(j <- 0 until k) {\n                var currMax = -Long.MaxValue\n\
    \                var currMaxIndex = -1\n                for(a <- 0 until arr.length)\
    \ {\n                    if(a > i) currMax += arr(a) - arr(i)\n              \
    \      else currMax += Long.MaxValue - Long.MinValue\n                    currMax\
    \ = if (currMax < currMax) currMax else currMax\n                    currMaxIndex\
    \ = if (currMax < currMaxIndex) currMaxIndex\n                        else a\n\
    \                }\n                if(currMax > max) {\n                    max\
    \ = currMax\n                    maxIndex = currMaxIndex\n                }\n\
    \                i += 1\n            }\n            arr.take(maxIndex)\n     \
    \   }", "        def getMax(arr: List[Long], max: Long): List[Long] = {\n    \
    \        val result = new Array[Long](k)\n            val iter = arr.iterator\n\
    \            for (i <- 0 until k) result(i - 1) = iter.next\n            result\n\
    \        }\n        val maxArr = getMax(arr, arr.max)\n        val maxIndex: Int\
    \ = (maxArr zip arr.toList map (_._1) max).indexOf(_._2)\n        val result =\
    \ arr.filterNot(_ == maxArr(0))\n        if (k > maxIndex) result :+ maxArr(0)\n\
    \        else result", "        val l = arr.toList\n        val rs = l.sortBy[Long](x\
    \ => -x).takeRight(k)\n        rs.toList", "        var max = new ArrayList[Long](k)\n\
    \        max.clear()\n        var i = 0\n        var j = 0\n        for ((x, y)\
    \ <- arr) {\n            if (x > max.get(i)) {\n                max.set(i, x)\n\
    \            }\n        }\n        for (x <- max.reverse) {\n            i -=\
    \ 1\n            if (j >= k) {\n                break\n            }\n       \
    \     if (x > max.get(j)) {\n                max.set(j, x)\n            }\n  \
    \      }\n        max.toList", "        def search(l : List[Long], k : Long, tmp:\
    \ List[Long], tmpLen : Int) : List[Long] = {\n            if((l length isEqualTo\
    \ k) && (l isEmpty || isMax(k)(l.last))) {\n                tmpLen match {\n \
    \                   case 0 => List(tmp)\n                    case 1 => tmp\n \
    \                   case _ => tmp\n                }\n            } else {\n \
    \               if(l isEmpty || isMax(k)(l.last)) {\n                    tmpLen\
    \ match {\n                        case 0 => List(tmp)\n                     \
    \   case 1 => tmp\n                        case _ => {\n                     \
    \       val temp: List[Long] = List(l.last)\n                            search(l.init,\
    \ k, temp, tmpLen + 1)\n                        }\n                    }\n   \
    \             } else {\n                    search(l.init, k, tmp, tmpLen + 1)\n\
    \                }\n            }\n        }\n        val tmpLen = 0\n       \
    \ search(arr, k, Nil, tmpLen)", "        var result : List[Long] = Nil\n     \
    \   var i = 0\n        var max = 0\n        var flag = false\n        var j =\
    \ 0\n        while (i < arr.length && j == k) {\n            max = max(arr(i),\
    \ max)\n            if (arr(i) > max) {\n                max = arr(i)\n      \
    \      }\n            i += 1\n        }\n        if (max == 0) {\n           \
    \ for (x <- arr ) {\n                if (x  > max) {\n                    max\
    \ = x\n                }\n            }\n        }\n        result = (max :: result)\n\
    \        flag = true\n        while (i< arr.length && j < k) {\n            max\
    \ = max(arr(i), max)\n            if (arr(i) > max) {\n                max = arr(i)\n\
    \            }\n            i += 1\n            if (max < max) {\n           \
    \     j += 1\n            }\n        }\n        if (!flag) {\n            result\
    \ = (max :: result)\n        }\n        result", "        if (k > arr.length)\
    \ throw new IllegalArgumentException(\"k is greater than the length of the list\"\
    )\n        if (arr.length == 0) throw new IllegalArgumentException(\"arr is empty\"\
    )\n        val n = arr.size\n        var max = 0.0\n        var maxIndex = 0\n\
    \        for (i <- 0 until n){\n            if (arr(i) > max){\n             \
    \   max = arr(i)\n                maxIndex = i\n            }\n        }\n   \
    \     arr.take(maxIndex + (k - 1))", "        def maximum(arr : List[Long], l\
    \ : List[Long], n : Int, m : Int) : List[Long] = {\n            if (l == Nil)\
    \ {\n                return l\n            } else if (n >= m) {\n            \
    \    val result = l filter (_ <= arr(n)) sortBy (_._1) filter (_._1 <= arr(n))\n\
    \                if (result == Nil) {\n                    val result = l filter\
    \ (_ <= arr(n)) sortBy (_._1) filter (_._1 > arr(n))\n                }\n    \
    \            return result :: maximum(arr, l filter (_ => arr(n) < _), n + 1 ,\
    \ m) \n            } else {\n                val result = l filter (_ <= arr(n))\
    \ sortBy (_._1) filter (_._1 > arr(n))\n                if (result == Nil) {\n\
    \                    val result = l filter (_ <= arr(n)) sortBy (_._1) filter\
    \ (_._1 < arr(n))\n                }\n                return maximum(arr, result,\
    \ n, m) :: l filter (_ => arr(n) > _)\n            }\n        }\n        maximum(arr,\
    \ Nil, 0, k) ", "        var max = 0\n        var result: List[Long] = Nil\n \
    \       var i = 0\n        while( i < arr.length ) {\n            max = max >\
    \ arr(i) ? max : arr(i)\n            if( max - k <= 0 )\n                i +=\
    \ 1\n            else {\n                result = (max to max+k).map(l => arr(i))\n\
    \                i += 1\n                max = arr(i)\n            }\n       \
    \ }\n        if( result.length == 0 )\n            result = (0 to k).map(l =>\
    \ arr(0))\n        result", "        var maxNum : List[Long] = Nil\n        var\
    \ currMax : Long = -1000000000\n        var currNum : Long = 0\n        for(i\
    \ <- arr){\n            currNum += i\n            if(currNum > currMax){\n   \
    \             currMax = currNum\n                maxNum = List(i)\n          \
    \  }else{\n                if(currNum > k){\n                    currMax = currNum\n\
    \                    maxNum = List(i)\n                }\n            }\n    \
    \    }\n        return maxNum", "        val result = new mutable.LinkedList[Long]\n\
    \        var maxSoFar = 0L\n        var max = Long.MinValue\n        for(i <-\
    \ 0 until arr.length) {\n            val thisNum = arr(i)\n            val numLessThanMax\
    \ = thisNum - max\n            val numLessThanMaxInt = numLessThanMax.toInt\n\
    \            val numLessThanMaxFloat = numLessThanMax.toFloat\n\n            if(numLessThanMaxInt\
    \ == k) {\n                result.add(i)\n            }\n            else if(numLessThanMaxInt\
    \ == -numLessThanMaxInt) {\n                result.add(i)\n            }\n   \
    \         else {\n                result.add(max)\n                maxSoFar =\
    \ max\n                max = thisNum\n            }\n        }\n        result.add(maxSoFar)\n\
    \        result", "        val size = arr.size\n        val maxList = scala.collection.mutable.ListBuffer.empty[Long]\n\
    \        var i = 0\n        while (i < size) {\n            maxList.append(arr(i))\n\
    \            i += 1\n            if (k > maxList.size) maxList.toList\n      \
    \  }\n        return maxList"]
stop_tokens:
- "\n    }\n"
