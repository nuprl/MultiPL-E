language: scala
name: HumanEval_148_bf
results:
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        // Only change code below this line\n        val mercury\
    \ = List(\"Mercury\",\"Venus\",\"Earth\",\"Mars\",\"Jupiter\",\"Saturn\",\"Uranus\"\
    )\n        val neptune = List(\"Neptune\")\n        val planets = mercury ++ planet1\
    \ :: neptune ++ planet2 :: mercury\n        val sun = List(\"Mercury\",\"Venus\"\
    ,\"Earth\",\"Mars\",\"Jupiter\",\"Saturn\",\"Uranus\",\"Neptune\")\n        val\
    \ planet1 = planets.find(x => sun.contains(x))\n        val planet2 = planets.find(x\
    \ => !sun(x).contains(x))\n        val orbit1 = planet1.getOrElse(\"Mercury\"\
    )\n        val orbit2 = planet2.getOrElse(\"Mercury\")\n        (planets.filter(x\
    \ => (orbit1 > x && orbit1 < orbit2) && (orbit2 > x && orbit2 < orbit1)).toList).sortBy(x\
    \ => sun(x).distanceTo(planet1(x)))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp3ubmm3ym.scala:27:22 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mplanet2\e[0m = planets.find(\e\
    [36mx\e[0m => !sun(x).contains(x))\n\e[31m\e[31m   |\e[0m                    \
    \  ^\e[0m\n\e[31m   |\e[0m                      Recursive \e[33mvalue\e[0m \e\
    [35mplanets\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmp3ubmm3ym.scala:26:22 ---------------------------\e[0m\e[0m\n\e[31m26\
    \ |\e[0m        \e[33mval\e[0m \e[36mplanet1\e[0m = planets.find(\e[36mx\e[0m\
    \ => sun.contains(x))\n\e[31m\e[31m   |\e[0m                      ^\e[0m\n\e[31m\
    \   |\e[0m                      Recursive \e[33mvalue\e[0m \e[35mplanets\e[0m\
    \ needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp3ubmm3ym.scala:30:121\
    \ -------------------\e[0m\e[0m\n\e[31m30 |\e[0m        (planets.filter(\e[36mx\e\
    [0m => (orbit1 > x && orbit1 < orbit2) && (orbit2 > x && orbit2 < orbit1)).toList).sortBy(\e\
    [36mx\e[0m => sun(x).distanceTo(planet1(x)))\n\e[31m\e[31m   |\e[0m          \
    \                                                                            \
    \                                   ^\e[0m\n\e[31m   |\e[0m                  \
    \                                Found:    (x : Object)\n\e[31m   |\e[0m     \
    \                                             Required: Int\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- Error: /tmp/tmp3ubmm3ym.scala:30:147 ----------------------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        (planets.filter(\e[36mx\e[0m => (orbit1 > x &&\
    \ orbit1 < orbit2) && (orbit2 > x && orbit2 < orbit1)).toList).sortBy(\e[36mx\e\
    [0m => sun(x).distanceTo(planet1(x)))\n\e[31m\e[31m   |\e[0m                 \
    \                                                                            \
    \                                                      ^\e[0m\n\e[31m   |\e[0mambiguous\
    \ given instances: both \e[33mobject\e[0m \e[35mByte\e[0m in \e[33mob"
  stdout: ''
  timestamp: 1660009721
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        // Your code goes here\n        val planet = List(planet1,\
    \ planet2)\n        def distance(p1: String, p2 : String) : Int = {\n        \
    \    var count = 0\n            if (p1 != p2) {\n                for( m <- 1 to\
    \ 1000 if p1 == p2) count += m\n            }\n            count\n        }\n\
    \        val planetSet = Set(planet, planet.reverse)\n        val sun = distance(\"\
    Earth\", \"Saturn\")\n        var orbits = ListBuffer[String]()\n        for(\
    \ p <- planetSet) {\n            val p1 = p._1\n            val p2 = p._2\n  \
    \          var count = 0\n            for( m <- 1 to 1000 if p1 == p2 && count\
    \ < sun) count += m\n            orbits.append(p1 + \"->\" + p2 + \",\" + count)\n\
    \        }\n        orbits.sortWith( distance(_, planet))\n        orbits.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"\
    Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmptbfqh60y.scala:34:23 ------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m            \e[33mval\e[0m \e[36mp1\e[0m = p._1\n\e[31m\e\
    [31m   |\e[0m                     ^^^^\e[0m\n\e[31m   |\e[0m                 \
    \    value _1 is not a member of List[String]\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmptbfqh60y.scala:35:23 ------------------------\e[0m\e[0m\n\e[31m35\
    \ |\e[0m            \e[33mval\e[0m \e[36mp2\e[0m = p._2\n\e[31m\e[31m   |\e[0m\
    \                     ^^^^\e[0m\n\e[31m   |\e[0m                     value _2\
    \ is not a member of List[String]\n\e[31m\e[31m-- [E086] Syntax Error: /tmp/tmptbfqh60y.scala:40:25\
    \ ---------------------------\e[0m\e[0m\n\e[31m40 |\e[0m        orbits.sortWith(\
    \ distance(_, planet))\n\e[31m\e[31m   |\e[0m                         ^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                         Wrong number of parameters, expected:\
    \ 2\n3 errors found\n"
  stdout: ''
  timestamp: 1660009722
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val Planets = mutable.ListBuffer[String]()\n     \
    \   for( p <- Planets ) p += planet1\n        for( p <- Planets ) p += planet2\n\
    \        Planets.toList.sortBy( x => x.indexOf( \"Sun\" ) )\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp2bb72zle.scala:21:22 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mPlanets\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660009718
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planet1orbit = orbit(planet1)\n        val planet2orbit\
    \ = orbit(planet2)\n        val planet1orbitPositions = planet1orbit.map( p =>\
    \ (abs(p.longitude - planet2.longitude), abs(p.latitude - planet2.latitude)))\n\
    \        val planet2orbitPositions = planet2orbit.map( p => (abs(p.longitude -\
    \ planet1.longitude), abs(p.latitude - planet1.latitude)))\n        val intersection\
    \ = planet1orbitPositions intersect planet2orbitPositions\n        val list =\
    \ (intersection map {case (dist1, dist2) => planet1} union intersection map {case\
    \ (dist1, dist2) => planet2}) sortBy (d => (d - abs(planet1.longitude - planet2.longitude),\
    \ abs(planet1.latitude - planet2.latitude)))\n        list.toList\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmptqhmtpms.scala:21:27 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mplanet1orbit\e[0m = orbit(planet1)\n\
    \e[31m\e[31m   |\e[0m                           ^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                         Not found: orbit\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmptqhmtpms.scala:22:27 ------------------------\e[0m\e\
    [0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mplanet2orbit\e[0m = orbit(planet2)\n\
    \e[31m\e[31m   |\e[0m                           ^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                         Not found: orbit\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660009718
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        var lst1 = List(planet1)\n        var lst2 = List(planet2)\n\
    \        val planet = if (lst1.contains(planet2)) lst1 else lst2\n        var\
    \ orbit1 = planet1\n        var orbit2 = planet2\n        val orbit = if (orbit1\
    \ == orbit2) orbit else orbit2\n        while (lst != List(orbit)) lst = List(orbit)\n\
    \        lst\n    }\n    def main(args: Array[String]) = {\n    assert(bf((\"\
    Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n\
    \    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n\
    \    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"),\
    \ (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp2k5mng6s.scala:26:42 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36morbit\e[0m = \e[33mif\e\
    [0m (orbit1 == orbit2) orbit \e[33melse\e[0m orbit2\n\e[31m\e[31m   |\e[0m   \
    \                                       ^\e[0m\n\e[31m   |\e[0m              \
    \                          Recursive \e[33mvalue\e[0m \e[35morbit\e[0m needs type\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp2k5mng6s.scala:27:15\
    \ ------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mwhile\e[0m\
    \ (lst != List(orbit)) lst = List(orbit)\n\e[31m\e[31m   |\e[0m              \
    \ ^^^\e[0m\n\e[31m   |\e[0m               Not found: lst\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmp2k5mng6s.scala:27:35 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mwhile\e[0m (lst != List(orbit)) lst = List(orbit)\n\
    \e[31m\e[31m   |\e[0m                                   ^^^\e[0m\n\e[31m   |\e\
    [0m                                   Not found: lst\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp2k5mng6s.scala:28:8 -------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        lst\n\e[31m\e[31m   |\e[0m        ^^^\e[0m\n\e\
    [31m   |\e[0m        Not found: lst\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660009718
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        var result: mutable.Buffer[String] = mutable.Buffer.empty\n\
    \        val planet1Orbit = (planet1.toUpperCase == \"EARTH\" ? 6 : planet1.toUpperCase\
    \ == \"MARS\" ? 3 : planet1.toUpperCase == \"JUPITER\" ? 2 : planet1.toUpperCase\
    \ == \"SATURN\" ? 1 : planet1.toUpperCase == \"URANUS\" ? 0 : -1)\n        val\
    \ planet2Orbit = (planet2.toUpperCase == \"EARTH\" ? 6 : planet2.toUpperCase ==\
    \ \"MARS\" ? 3 : planet2.toUpperCase == \"JUPITER\" ? 2 : planet2.toUpperCase\
    \ == \"SATURN\" ? 1 : planet2.toUpperCase == \"URANUS\" ? 0 : -1)\n        var\
    \ distance = planet1Orbit - planet2Orbit\n        for (i <- 0 to distance) {\n\
    \            if (planet1Orbit == planet2Orbit) {\n                result = (result\
    \ :+ planet1).sortBy(x => (x.toUpperCase == \"EARTH\" ? 6 : x.toUpperCase == \"\
    MARS\" ? 3 : x.toUpperCase == \"JUPITER\" ? 2 : x.toUpperCase == \"SATURN\" ?\
    \ 1 : x.toUpperCase == \"URANUS\" ? 0 : -1));\n            }\n            else\
    \ if (planet1Orbit > planet2Orbit) {\n                distance -= 1;\n       \
    \     }\n            else {\n                distance += 1;\n            }\n \
    \       }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\",\
    \ \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp3qfge8bz.scala:22:99 ---------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mplanet1Orbit\e[0m = (planet1.toUpperCase\
    \ == \e[31m\"EARTH\"\e[0m ? \e[31m6\e[0m : planet1.toUpperCase \e[35m==\e[0m \e\
    [31m\"MARS\"\e[0m \e[35m?\e[0m \e[31m3\e[0m : planet1.toUpperCase == \e[31m\"\
    JUPITER\"\e[0m ? \e[31m2\e[0m : planet1.toUpperCase == \e[31m\"SATURN\"\e[0m ?\
    \ \e[31m1\e[0m : planet1.toUpperCase == \e[31m\"URANUS\"\e[0m ? \e[31m0\e[0m :\
    \ -\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m                                      \
    \                                                             ^\e[0m\n\e[31m \
    \  |\e[0m                                             ')' expected, but ':' found\n\
    \e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp3qfge8bz.scala:23:99 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mplanet2Orbit\e[0m = (planet2.toUpperCase\
    \ == \e[31m\"EARTH\"\e[0m ? \e[31m6\e[0m : planet2.toUpperCase \e[35m==\e[0m \e\
    [31m\"MARS\"\e[0m \e[35m?\e[0m \e[31m3\e[0m : planet2.toUpperCase == \e[31m\"\
    JUPITER\"\e[0m ? \e[31m2\e[0m : planet2.toUpperCase == \e[31m\"SATURN\"\e[0m ?\
    \ \e[31m1\e[0m : planet2.toUpperCase == \e[31m\"URANUS\"\e[0m ? \e[31m0\e[0m :\
    \ -\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m                                      \
    \                                                             ^\e[0m\n\e[31m \
    \  |\e[0m                                             ')' expected, but ':' found\n\
    \e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp3qfge8bz.scala:27:117 --------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m                result = (result :+ planet1).sortBy(\e\
    [36mx\e[0m => (x.toUpperCase == \e[31m\"EARTH\"\e[0m ? \e[31m6\e[0m : x.toUpperCase\
    \ \e[35m==\e[0m \e[31m\"MARS\"\e[0m \e[35m?\e[0m \e[31m3\e[0m : x.toUpperCase\
    \ == \e[31m\"JUPITER\"\e[0m ? \e[31m2\e[0m : x.toUpperCase == \e[31m\"SATURN\"\
    \e[0m ? \e[31m1\e[0m : x.toUpperCase == \e[31m\"URANUS\"\e[0m ? \e[31m0\e[0m :\
    \ -\e[31m1\e[0m));\n\e[31m\e[31m   |\e[0m                                    \
    \                                                                            \
    \     ^\e[0m\n\e[31m   |\e[0m                                             ')'\
    \ expected, but ':' found\n\e[31m\e[31"
  stdout: ''
  timestamp: 1660009721
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        var list: List[String] = Nil\n        for ( i <- 1\
    \ to planet1 length if planet1 == planet2(i)) list += planet1(i-1)\n        if\
    \ (planet2.toInt == planet1.toInt) list += planet1\n        return list\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpnxn_9w14.scala:22:39 ---------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mfor\e[0m ( i <- \e[31m1\e[0m to planet1\
    \ length \e[33mif\e[0m planet1 == planet2(i)) list += planet1(i-\e[31m1\e[0m)\n\
    \e[31m\e[31m   |\e[0m                                       ^^\e[0m\n\e[31m  \
    \ |\e[0m                                       expression expected but \e[31mif\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpnxn_9w14.scala:22:24\
    \ --------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mfor\e[0m ( i <-\
    \ \e[31m1\e[0m to planet1 length \e[33mif\e[0m planet1 == planet2(i)) list +=\
    \ planet1(i-\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m                        ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                        Found:    (planet1 : String)\n\e[31m\
    \   |\e[0m                        Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpnxn_9w14.scala:23:49 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mif\e[0m (planet2.toInt == planet1.toInt)\
    \ list += planet1\n\e[31m\e[31m   |\e[0m                                     \
    \       ^^^^^^^\e[0m\n\e[31m   |\e[0mvalue += is not a member of List[String]\
    \ - did you mean List[String].!=?\n3 errors found\n"
  stdout: ''
  timestamp: 1660009723
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        var planets = Set(planet1, planet2)\n        while(planets.size\
    \ > 2) {\n            planets -= Set(planets.last, planets.last)\n        }\n\
    \        planets :: Set(planets.last)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4046vai1.scala:23:26\
    \ --------------------\e[0m\e[0m\n\e[31m23 |\e[0m            planets -= Set(planets.last,\
    \ planets.last)\n\e[31m\e[31m   |\e[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                       Found:    scala.collection.mutable.Set[String]\n\
    \e[31m   |\e[0m                       Required: String\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp4046vai1.scala:25:16 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        planets :: Set(planets.last)\n\e[31m\e[31m  \
    \ |\e[0m                ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue :: is\
    \ not a member of scala.collection.mutable.Set[String] - did you mean scala.collection.mutable.Set[String]./:?\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660009723
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        if (planet1 == planet2) List(planet1)\n        else\
    \ if (planet1 == \"\" ) List()\n        else if planet2 == \"\" ) List()\n   \
    \     else if (planet1.contains(planet2)){ \n            val names_between = \n\
    \                planet1.filter(planet2.contains)\n            val names_between2\
    \ = \n                planet2.filter(planet1.contains)\n            val names_between3\
    \ = \n                planet1.filter(planet2.contains)\n            val names_between4\
    \ = \n                planet2.filter(planet1.contains)\n            val names_between5\
    \ = \n                planet1.filter(planet2.contains)\n            val names_between6\
    \ = \n                planet2.filter(planet1.contains)\n            val names_between7\
    \ = \n                planet1.filter(planet2.contains)\n            val names_between8\
    \ = \n                planet2.filter(planet1.contains)\n            names_between.filter(!planet2.contains)\n\
    \        }\n        else None\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\",\
    \ \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpxreo2zel.scala:23:30 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m planet2 == \e[31m\"\
    \"\e[0m ) List()\n\e[31m\e[31m   |\e[0m                              ^\e[0m\n\e\
    [31m   |\e[0m                              'then' expected, but ')' found\n\e\
    [33m\e[33m-- [E129] Potential Issue Warning: /tmp/tmpxreo2zel.scala:44:4 -----------------\e\
    [0m\e[0m\n\e[33m43 |\e[0m        \e[33melse\e[0m None\n\e[33m44 |\e[0m    }\n\e\
    [33m\e[33m   |\e[0m                 ^\e[0m\n\e[33m   |\e[0mA pure expression does\
    \ nothing in statement position; you may be omitting necessary parentheses\n\e\
    [33m   |\e[0m\n\e[33m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 warning found\n1 error found\n"
  stdout: ''
  timestamp: 1660009719
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        var planet1 = planet1\n        var planet2 = planet2\n\
    \        planet1 match {\n            case planet2 if planet1.isEmpty = planet2\
    \ => List((planet2))\n            case planet2 if planet1.isEmpty => List()\n\
    \            case _ => List()\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpt8yexkna.scala:24:44 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m            \e[33mcase\e[0m planet2 \e[33mif\e[0m planet1.isEmpty\
    \ = planet2 => List((planet2))\n\e[31m\e[31m   |\e[0m                        \
    \                    ^\e[0m\n\e[31m   |\e[0m                                 \
    \           '=>' expected, but '=' found\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmpt8yexkna.scala:21:22 ---------------------------\e[0m\e[0m\n\e[31m21\
    \ |\e[0m        \e[33mvar\e[0m \e[36mplanet1\e[0m = planet1\n\e[31m\e[31m   |\e\
    [0m                      ^\e[0m\n\e[31m   |\e[0m                      Recursive\
    \ \e[33mvariable\e[0m \e[35mplanet1\e[0m needs type\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E045] Cyclic Error: /tmp/tmpt8yexkna.scala:22:22 ---------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mvar\e[0m \e[36mplanet2\e[0m = planet2\n\
    \e[31m\e[31m   |\e[0m                      ^\e[0m\n\e[31m   |\e[0m           \
    \           Recursive \e[33mvariable\e[0m \e[35mplanet2\e[0m needs type\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1660009719
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        if(planet1 == null || planet2 == null) return List()\n\
    \        val orbit1 = Orbit.of(planet1)\n        val orbit2 = Orbit.of(planet2)\n\
    \        // The return value is a list containing all the planets\n        //\
    \ whose orbits lie between the two planets. \n        // The distance between\
    \ the planets is measured by\n        // Eucledean distance. \n        val dist1\
    \ = orbit1.distance(orbit2)\n        val dist2 = orbit2.distance(orbit1)\n   \
    \     val distanceList = ListBuffer[Double]()\n        for(i <- 1 to dist1) {\n\
    \            distanceList += i\n        }\n        for(i <- 1 to dist2) {\n  \
    \          distanceList += i\n        }\n        val orderedList = distanceList.sortBy(distance(_))\n\
    \        orderedList.takeWhile(distance(_) <= orbit1.distance(orbit2))\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp2jgjvb1_.scala:22:21 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36morbit1\e[0m = Orbit.of(planet1)\n\
    \e[31m\e[31m   |\e[0m                     ^^^^^\e[0m\n\e[31m   |\e[0m        \
    \             Not found: Orbit\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp2jgjvb1_.scala:23:21 ------------------------\e[0m\e[0m\n\e[31m23 |\e\
    [0m        \e[33mval\e[0m \e[36morbit2\e[0m = Orbit.of(planet2)\n\e[31m\e[31m\
    \   |\e[0m                     ^^^^^\e[0m\n\e[31m   |\e[0m                   \
    \  Not found: Orbit\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp2jgjvb1_.scala:37:46\
    \ ------------------------\e[0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e\
    [36morderedList\e[0m = distanceList.sortBy(distance(_))\n\e[31m\e[31m   |\e[0m\
    \                                              ^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                                              Not found: distance\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- Error: /tmp/tmp2jgjvb1_.scala:37:58 -----------------------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e[36morderedList\e[0m = distanceList.sortBy(distance(_))\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \  ^\e[0m\n\e[31m   |\e[0mambiguous given instances: both \e[33mobject\e[0m \e\
    [35mByte\e[0m in \e[33mobject\e[0m \e[35mOrdering\e[0m and \e[33mobject\e[0m \e\
    [35mChar\e[0m in \e[33mobject\e[0m \e[35mOrdering\e[0m match type Ordering[B]\
    \ of parameter ord of \e[33mmethod\e[0m \e[35msortBy\e[0m in \e[33mtrait\e[0m\
    \ \e[35mSeqOps\e[0m\n4 errors found\n"
  stdout: ''
  timestamp: 1660009719
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        def distance(planet1 : String, planet2 : String) :\
    \ Double = {\n            // Write your code here\n            val sun = SunPosition.getInstance()\n\
    \            val sun_distance = sun.distance(planet1, planet2)\n            val\
    \ planet_distance = sun.distance(planet1, planet2)\n            val planet_position\
    \ = sun_distance.toDouble / (2 * planet_distance)\n            planet_position.toInt\n\
    \        }\n        \n        def isClosestToSun(planet1 : String, planet2 : String)\
    \ : Boolean = {\n            // Write your code here\n            val sun = SunPosition.getInstance()\n\
    \            val sun_distance = sun.distance(planet1, planet2)\n            val\
    \ planet_distance = sun.distance(planet1, planet2)\n            val planet_position\
    \ = sun_distance.toDouble / (2 * planet_distance)\n            planet_position.toInt\
    \ <= 1\n        }\n        \n        def getPlanets(planet1 : String, planet2\
    \ : String) : List[String] = {\n            // Write your code here\n        \
    \    val sun = SunPosition.getInstance()\n            val sun_distance = sun.distance(planet1,\
    \ planet2)\n            val planet_distance = sun.distance(planet1, planet2)\n\
    \            val planet_position = sun_distance.toDouble / (2 * planet_distance)\n\
    \            val planets = List(planet1, planet2)\n            if(planet_position.toInt\
    \ < 1){\n                planets\n            } else {\n                planets.filter(!isClosestToSun(planet1,\
    \ planet2))\n            }\n        }\n        \n        def getClosestToSun(planet1\
    \ : String, planet2 : String) : List[String] = {\n            // Write your code\
    \ here\n            val sun = SunPosition.getInstance()\n            val sun_distance\
    \ = sun.distance(planet1, planet2)\n            val planet_distance = sun.distance(planet1,\
    \ planet2)\n            val planet_position = sun_distance.toDouble / (2 * planet_distance)\n\
    \            val planets = List(planet1, planet2)\n            if(planet_position.toInt\
    \ <= 1){\n                planets\n            } else {\n                planets.filter(!isClosestToSun(planet1,\
    \ planet2))\n            }\n        }\n        \n        def getClosestToSun(planet1\
    \ : String, planet2 : String) : List[String] = {\n            // Write your code\
    \ here\n            val sun = SunPosition.getInstance()\n            val sun_distance\
    \ = sun.distance(planet1, planet2)\n            val planet_distance = sun.distance(planet1,\
    \ planet2)\n\n    }\n    def main(args: Array[String]) = {\n    assert(bf((\"\
    Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n\
    \    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n\
    \    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"),\
    \ (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmppmjfvtbj.scala:85:0 ----------------------------\e\
    [0m\e[0m\n\e[31m85 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmppmjfvtbj.scala:67:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m67 |\e[0m        \e[33mdef\e[0m\
    \ \e[36mgetClosestToSun\e[0m(\e[36mplanet1\e[0m : \e[35mString\e[0m, \e[36mplanet2\e\
    [0m : \e[35mString\e[0m) : \e[35mList\e[0m[\e[35mString\e[0m] = {\n\e[31m\e[31m\
    \   |\e[0m        ^\e[0m\n\e[31m   |\e[0mgetClosestToSun is already defined as\
    \ \e[33mmethod\e[0m \e[35mgetClosestToSun\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m68 |\e[0m            \e[34m// Write your code here\e[0m\n\
    \e[31m69 |\e[0m            \e[33mval\e[0m \e[36msun\e[0m = SunPosition.getInstance()\n\
    \e[31m70 |\e[0m            \e[33mval\e[0m \e[36msun_distance\e[0m = sun.distance(planet1,\
    \ planet2)\n\e[31m71 |\e[0m            \e[33mval\e[0m \e[36mplanet_distance\e\
    [0m = sun.distance(planet1, planet2)\n\e[31m72 |\e[0m    }\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmppmjfvtbj.scala:23:22 ------------------------\e[0m\e\
    [0m\n\e[31m23 |\e[0m            \e[33mval\e[0m \e[36msun\e[0m = SunPosition.getInstance()\n\
    \e[31m\e[31m   |\e[0m                      ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \                     Not found: SunPosition\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmppmjfvtbj.scala:32:22 ------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m            \e[33mval\e[0m \e[36msun\e[0m = SunPosition.getInstance()\n\
    \e[31m\e[31m   |\e[0m                      ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \                     Not found: SunPosition\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmppmjfvtbj.scala:41:22 ------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m            \e[33mval\e[0m \e[36msun\e[0m = SunPosition.getInstance()\n\
    \e[31m\e[31m   |\e[0m                      ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \        "
  stdout: ''
  timestamp: 1660009724
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planetsBetween = {\n            val sun = new\
    \ Planet(Sun)\n            val earth = new Planet(Earth)\n            val venus\
    \ = new Planet(Venus)\n            val mercury = new Planet(Mercury)\n       \
    \     val jupiter = new Planet(Jupiter)\n            val saturn = new Planet(Saturn)\n\
    \            val uranus = new Planet(Uranus)\n            val neptune = new Planet(Neptune)\n\
    \            val earthOrbit = sun.orbit(planet2)\n            val venusOrbit =\
    \ venus.orbit(planet2)\n            val mercuryOrbit = mercury.orbit(planet2)\n\
    \            val jupiterOrbit = jupiter.orbit(planet2)\n            val saturnOrbit\
    \ = saturn.orbit(planet2)\n            val uranusOrbit = uranus.orbit(planet2)\n\
    \            val neptuneOrbit = neptune.orbit(planet2)\n            val earthOrbitInEarth\
    \ = sun.isOrbitInOrbit(earth, earthOrbit)\n            val venusOrbitInVenus =\
    \ sun.isOrbitInOrbit(venus, venusOrbit)\n            val mercuryOrbitInMercury\
    \ = sun.isOrbitInOrbit(mercury, mercuryOrbit)\n            val jupiterOrbitInJupiter\
    \ = sun.isOrbitInOrbit(jupiter, jupiterOrbit)\n            val saturnOrbitInSaturn\
    \ = sun.isOrbitInOrbit(saturn, saturnOrbit)\n            val uranusOrbitInUranus\
    \ = sun.isOrbitInOrbit(uranus, uranusOrbit)\n            val neptuneOrbitInNeptune\
    \ = sun.isOrbitInOrbit(neptune, neptuneOrbit)\n            (earthOrbitInEarth,\
    \ venusOrbitInVenus, mercuryOrbitInMercury, \n            jupiterOrbitInJupiter,\
    \ saturnOrbitInSaturn, uranusOrbitInUranus, \n            neptuneOrbitInNeptune)\n\
    \        }\n        val planetsToAdd = planetsBetween.foldLeft(List[String]())\
    \ {\n            (acc, \n    }\n    def main(args: Array[String]) = {\n    assert(bf((\"\
    Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n\
    \    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n\
    \    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"),\
    \ (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpv_20h638.scala:50:4 ----------------------------\e\
    [0m\e[0m\n\e[31m50 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpv_20h638.scala:62:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m62 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E006] Not\
    \ Found Error: /tmp/tmpv_20h638.scala:22:26 ------------------------\e[0m\e[0m\n\
    \e[31m22 |\e[0m            \e[33mval\e[0m \e[36msun\e[0m = \e[33mnew\e[0m \e[35mPlanet\e\
    [0m(Sun)\n\e[31m\e[31m   |\e[0m                          ^^^^^^\e[0m\n\e[31m \
    \  |\e[0m                          Not found: type Planet\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpv_20h638.scala:23:28 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            \e[33mval\e[0m \e[36mearth\e[0m = \e[33mnew\e\
    [0m \e[35mPlanet\e[0m(Earth)\n\e[31m\e[31m   |\e[0m                          \
    \  ^^^^^^\e[0m\n\e[31m   |\e[0m                            Not found: type Planet\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpv_20h638.scala:24:28\
    \ ------------------------\e[0m\e[0m\n\e[31m24 |\e[0m            \e[33mval\e[0m\
    \ \e[36mvenus\e[0m = \e[33mnew\e[0m \e[35mPlanet\e[0m(Venus)\n\e[31m\e[31m   |\e\
    [0m                            ^^^^^^\e[0m\n\e[31m   |\e[0m                  \
    \          Not found: type Planet\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpv_20h638.scala:25:30 ------------------------\e[0m\e[0m\n\e[31m25 |\e\
    [0m            \e[33mval\e[0m \e[36mmercury\e[0m = \e[33mnew\e[0m \e[35mPlanet\e\
    [0m(Mercury)\n\e[31m\e[31m   |\e[0m                              ^^^^^^\e[0m\n\
    \e[31m   |\e[0m                              Not found: type Planet\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpv_20h638.scala:26:30 -----------------"
  stdout: ''
  timestamp: 1660009723
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        var list : List[String] = Nil\n        var sunPosition\
    \ = math.atan2(Double.NaN, Double.NaN)\n        var orbit1 : Double = Double.NaN\n\
    \        var orbit2 : Double = Double.NaN\n        var planet1Orbit : Double =\
    \ Double.NaN\n        var planet2Orbit : Double = Double.NaN\n        var orbitDistance\
    \ : Double = Double.NaN\n        var planetDistance : Double = Double.NaN\n  \
    \      var planet1OrbitOrbitDistance : Double = Double.NaN\n        var planet2OrbitOrbitDistance\
    \ : Double = Double.NaN\n        // We have to handle if both planets are sun\n\
    \        if (planet1 == planet2) {\n            return Nil\n        } else {\n\
    \            var sun : Double = math.atan2(Double.NaN, Double.NaN)\n         \
    \   var sunDistance : Double = Double.NaN\n            // We have to handle if\
    \ both planets are not sun\n            if (planet1 != \"Sun\") {\n          \
    \      // Get the orbit of planet1\n                planet1Orbit = planet1Orbit(planet1)\n\
    \                // Get the orbit of planet2\n                planet2Orbit = planet2Orbit(planet2)\n\
    \                // We have to handle if both planets are not sun\n          \
    \      if (planet1 != planet2) {\n                    // Get the distance between\
    \ planets\n                    planetDistance = planetDistance(planet1, planet2)\n\
    \                    // We have to handle if both planets are not sun\n      \
    \              if (planet1 != planet2) {\n                        // Get the orbit\
    \ distance between planets\n                        planet1OrbitOrbitDistance\
    \ = planet1OrbitOrbitDistance(planet1, planet2)\n                        // Get\
    \ the orbit distance between planets\n                        planet2OrbitOrbitDistance\
    \ = planet2OrbitOrbitDistance(planet2, planet1)\n                        // Get\
    \ the sun position\n                        sunPosition = sunPosition(planet1,\
    \ planet2)\n                        // We have to handle if both planets are not\
    \ sun\n                        if (planet1 != planet2) {\n                   \
    \         // Get the distance between planets\n                            orbitDistance\
    \ = orbitDistance(planet1, planet2)\n                            // If the distance\
    \ is less than sun distance\n                            if (orbitDistance < planet1OrbitOrbitDistance)\
    \ {\n                                // If the orbit of planet1 is between the\
    \ orbit of planet2\n                                if (orbit1 > planet2Orbit)\
    \ {\n                                    // We have to handle if both planets\
    \ are not sun\n                                    if (planet1 != planet2) {\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"\
    Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpitogxhx2.scala:77:0 ----------------------------\e\
    [0m\e[0m\n\e[31m77 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E050] Type Error: /tmp/tmpitogxhx2.scala:40:31\
    \ -----------------------------\e[0m\e[0m\n\e[31m40 |\e[0m                planet1Orbit\
    \ = planet1Orbit(planet1)\n\e[31m\e[31m   |\e[0m                             \
    \  ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                          \e[33mvariable\e\
    [0m \e[35mplanet1Orbit\e[0m does not take parameters\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E050] Type Error: /tmp/tmpitogxhx2.scala:42:31 -----------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m                planet2Orbit = planet2Orbit(planet2)\n\
    \e[31m\e[31m   |\e[0m                               ^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                          \e[33mvariable\e[0m \e[35mplanet2Orbit\e[0m\
    \ does not take parameters\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E050] Type Error:\
    \ /tmp/tmpitogxhx2.scala:46:37 -----------------------------\e[0m\e[0m\n\e[31m46\
    \ |\e[0m                    planetDistance = planetDistance(planet1, planet2)\n\
    \e[31m\e[31m   |\e[0m                                     ^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                        \e[33mvariable\e[0m \e[35mplanetDistance\e\
    [0m does not take parameters\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E050] Type Error:\
    \ /tmp/tmpitogxhx2.scala:50:52 -----------------------------\e[0m\e[0m\n\e[31m50\
    \ |\e[0m                        planet1OrbitOrbitDistance = planet1OrbitOrbitDistance(planet1,\
    \ planet2)\n\e[31m\e[31m   |\e[0m                                            \
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m             \e[33mvariable\e\
    [0m \e[35mplanet1OrbitOrbitDistance\e[0m does not take parameters\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E050] Type Error: /tmp/tmpitogxhx2.scala:52:52 ---------------"
  stdout: ''
  timestamp: 1660009719
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        // Write your code here\n        val planetNames =\
    \ Seq(planet1, planet2)\n        val sun = Planet.calculateSun(planetNames)\n\
    \        var planet1Orbit = Planet.calculateOrbit(planetNames)\n        var planet2Orbit\
    \ = Planet.calculateOrbit(planetNames)\n        for( i<- 0 to planet1Orbit.length\
    \ - 1){\n            if(planet1Orbit(i)>sun){\n                planet1Orbit(i+1)=planet1Orbit(i)-sun\n\
    \            }\n        }\n        for( i<- 0 to planet2Orbit.length - 1){\n \
    \           if(planet2Orbit(i)>sun){\n                planet2Orbit(i+1)=planet2Orbit(i)-sun\n\
    \            }\n        }\n        val proximity = List(planet1Orbit, planet2Orbit).zipWithIndex.sortWith(_._1\
    \ > _._1)\n        proximity(0)._2 :: proximity(1)._2\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpb2b3il_l.scala:23:18 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36msun\e[0m = Planet.calculateSun(planetNames)\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \        Not found: Planet\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpb2b3il_l.scala:24:27 ------------------------\e[0m\e[0m\n\e[31m24 |\e\
    [0m        \e[33mvar\e[0m \e[36mplanet1Orbit\e[0m = Planet.calculateOrbit(planetNames)\n\
    \e[31m\e[31m   |\e[0m                           ^^^^^^\e[0m\n\e[31m   |\e[0m \
    \                          Not found: Planet\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpb2b3il_l.scala:25:27 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mvar\e[0m \e[36mplanet2Orbit\e[0m = Planet.calculateOrbit(planetNames)\n\
    \e[31m\e[31m   |\e[0m                           ^^^^^^\e[0m\n\e[31m   |\e[0m \
    \                          Not found: Planet\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpb2b3il_l.scala:36:84 ------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36mproximity\e[0m = List(planet1Orbit,\
    \ planet2Orbit).zipWithIndex.sortWith(_._1 > _._1)\n\e[31m\e[31m   |\e[0m    \
    \                                                                           ^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue > is not a member of Nothing, but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import Byte.byte2double\n\
    \e[31m   |\e[0m  import Byte.byte2float\n\e[31m   |\e[0m  import Byte.byte2int\n\
    \e[31m   |\e[0m  import Byte.byte2long\n\e[31m   |\e[0m  import Byte.byte2short\n\
    \e[31m   |\e[0m  import Char.char2double\n\e[31m   |\e[0m  import Char.char2float\n\
    \e[31m   |\e[0m  import Char.char2int\n\e[31m   |\e[0m  import Char.char2long\n\
    \e[31m   |\e[0m  import math.BigDec"
  stdout: ''
  timestamp: 1660009724
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val orbits1 = getOrbits(planet1)\n        val orbits2\
    \ = getOrbits(planet2)\n        val orbits1 = orbits1.toList\n        val orbits2\
    \ = orbits2.toList\n        val result = orbits1.zip(orbits2).filter {\n     \
    \       case (l,r) => l.distance(r) < 1\n        }\n        result.sortWith(_.distance(_)\
    \ < 1).map { case (l, r) => l }.flatMap(List(_))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpoc1449k3.scala:23:12 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36morbits1\e[0m = orbits1.toList\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0morbits1\
    \ is already defined as \e[33mvalue\e[0m \e[35morbits1\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpoc1449k3.scala:24:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m\
    \ \e[36morbits2\e[0m = orbits2.toList\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0morbits2 is already defined as \e[33mvalue\e[0m \e[35morbits2\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E006] Not\
    \ Found Error: /tmp/tmpoc1449k3.scala:21:22 ------------------------\e[0m\e[0m\n\
    \e[31m21 |\e[0m        \e[33mval\e[0m \e[36morbits1\e[0m = getOrbits(planet1)\n\
    \e[31m\e[31m   |\e[0m                      ^^^^^^^^^\e[0m\n\e[31m   |\e[0m   \
    \                   Not found: getOrbits\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpoc1449k3.scala:22:22 ------------------------\e[0m\e\
    [0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36morbits2\e[0m = getOrbits(planet2)\n\
    \e[31m\e[31m   |\e[0m                      ^^^^^^^^^\e[0m\n\e[31m   |\e[0m   \
    \                   Not found: getOrbits\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660009719
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        // Write your code here\n\n        val planet1Orbits\
    \ = List(List(\"Mercury\", \"Venus\"), List(\"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\", \"Neptune\"))\n        val planet2Orbits = List(List(\"\
    Mercury\", \"Venus\"), List(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"))\n\n        val planet1Distance = planet1Orbits.map{\n        orb\
    \ => orb.map{ o2 => \n            math.pow(math.pow(o2 - planet1Orbits(0), 2)\
    \ + math.pow(o2 - planet1Orbits(1), 2), 0.5)\n        }.min}\n        val planet2Distance\
    \ = planet2Orbits.map{\n        orb => orb.map{ o2 => \n            math.pow(math.pow(o2\
    \ - planet2Orbits(0), 2) + math.pow(o2 - planet2Orbits(1), 2), 0.5)\n        }.min}\n\
    \n        val distance = math.pow(planet1Distance + planet2Distance, 0.5)\n\n\
    \        if (distance < 5.0) (planet1, planet2)\n        else if (distance < 5.0)\
    \ (planet2, planet1)\n        else ()\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmphyqfeh1q.scala:28:33 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m            math.pow(math.pow(o2 - planet1Orbits(\e[31m0\e\
    [0m), \e[31m2\e[0m) + math.pow(o2 - planet1Orbits(\e[31m1\e[0m), \e[31m2\e[0m),\
    \ \e[31m0.5\e[0m)\n\e[31m\e[31m   |\e[0m                              ^^^^\e[0m\n\
    \e[31m   |\e[0mvalue - is not a member of String, but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e\
    [0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import\
    \ math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmphyqfeh1q.scala:28:70 ------------------------\e[0m\e\
    [0m\n\e[31m28 |\e[0m            math.pow(math.pow(o2 - planet1Orbits(\e[31m0\e\
    [0m), \e[31m2\e[0m) + math.pow(o2 - planet1Orbits(\e[31m1\e[0m), \e[31m2\e[0m),\
    \ \e[31m0.5\e[0m)\n\e[31m\e[31m   |\e[0m                                     \
    \                              ^^^^\e[0m\n\e[31m   |\e[0mvalue - is not a member\
    \ of String, but could be made available as an extension method.\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mOne of the following imports might make progress towards fixing\
    \ the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmphyqfeh1q.scala:32:33 ------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m            math.pow(math.pow(o2 - planet2Orbits(\e[31m0\e\
    [0m), \e[31m2\e[0m) + math.pow(o2 - planet2Orbits(\e[31m1\e[0m), \e[31m2\e[0m),\
    \ \e[31m0.5\e[0m)\n\e[31m\e[31m   |\e[0m                              ^^^^\e[0m\n\
    \e[31m   |\e[0mvalue - is not a member of String, but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e\
    [31m   "
  stdout: ''
  timestamp: 1660009725
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        \n        // Create mutable set of planets \n    \
    \    val planetSet = mutable.Set[String]()\n        planetSet += planet1\n   \
    \     planetSet += planet2\n        \n        // Create mutable set of orbit of\
    \ planets\n        val orbitSet = mutable.Set[String]()\n        orbitSet += planet1\n\
    \        orbitSet += planet2\n        \n        // Create mutable set of closest\
    \ planet\n        val closestPlanet = mutable.Set[String]()\n        \n      \
    \  // Iterate over each planet in set 1 \n        planetSet.foreach( x =>\n  \
    \      // Add each planet in set 2 to the set \n        orbitSet += x)\n     \
    \   // Remove each planet from set 1\n        orbitSet -= planet1\n        //\
    \ Iterate over each planet in set 2\n        orbitSet.foreach( x =>\n        //\
    \ If each planet is in set 1, add it to set 2 and remove it from set 1\n     \
    \   if (planetSet.contains(x)){\n            closestPlanet += x\n            orbitSet\
    \ -= x\n        }\n        )\n        \n        // Return sorted list by proximity\
    \ to Sun\n        closestPlanet.sortBy(x => math.abs(x.hashCode()) % 7)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp0hkqv5yo.scala:23:24 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mplanetSet\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                        ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                        Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmp0hkqv5yo.scala:28:23 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36morbitSet\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                       ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                       Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmp0hkqv5yo.scala:33:28 ------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mclosestPlanet\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                            ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                            Not found: mutable\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1660009719
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        var planet1Orbit : OrbitalPlanet = OrbitalPlanet(planet1)\n\
    \        var planet2Orbit : OrbitalPlanet = OrbitalPlanet(planet2)\n        var\
    \ orbitingPlanets : List[String] = List()\n\n        while(planet1Orbit.getOrbits(planet2Orbit)\
    \ > 0){\n            orbitingPlanets = orbitingPlanets ::: List(planet1Orbit.getName())\n\
    \            planet1Orbit = planet1Orbit.getNextPlanet()\n            planet2Orbit\
    \ = planet2Orbit.getNextPlanet()\n        }\n\n        return orbitingPlanets.sortWith(_\
    \ < _)\n    }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"\
    ), (\"Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp0afdpa0m.scala:21:27 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mvar\e[0m \e[36mplanet1Orbit\e[0m : \e[35mOrbitalPlanet\e\
    [0m = OrbitalPlanet(planet1)\n\e[31m\e[31m   |\e[0m                          \
    \ ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                           Not found: type\
    \ OrbitalPlanet\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp0afdpa0m.scala:21:43\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mvar\e[0m \e\
    [36mplanet1Orbit\e[0m : \e[35mOrbitalPlanet\e[0m = OrbitalPlanet(planet1)\n\e\
    [31m\e[31m   |\e[0m                                           ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                           Not found: OrbitalPlanet\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp0afdpa0m.scala:22:27\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mvar\e[0m \e\
    [36mplanet2Orbit\e[0m : \e[35mOrbitalPlanet\e[0m = OrbitalPlanet(planet2)\n\e\
    [31m\e[31m   |\e[0m                           ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                           Not found: type OrbitalPlanet\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmp0afdpa0m.scala:22:43 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mvar\e[0m \e[36mplanet2Orbit\e[0m : \e[35mOrbitalPlanet\e\
    [0m = OrbitalPlanet(planet2)\n\e[31m\e[31m   |\e[0m                          \
    \                 ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                        \
    \                   Not found: OrbitalPlanet\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660009719
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val l1 = planets.filter(x => x._1 == planet1).length\n\
    \        val l2 = planets.filter(x => x._2 == planet2).length\n        if (l1\
    \ == 0) List() else if (l2 == 0) List() else if (l1 > l2) List(planet2) else List(planet1)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"\
    Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmphjslc217.scala:21:17 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36ml1\e[0m = planets.filter(\e\
    [36mx\e[0m => x._1 == planet1).length\n\e[31m\e[31m   |\e[0m                 ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                 Not found: planets\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmphjslc217.scala:22:17 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36ml2\e[0m = planets.filter(\e\
    [36mx\e[0m => x._2 == planet2).length\n\e[31m\e[31m   |\e[0m                 ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                 Not found: planets\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660009719
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(planet1, planet2)\n        planets\
    \ match {\n            case List() => List()\n            case x :: xs => planets.filter(\
    \ y => x < y).sortWith(_ > _).filter(_ != planet1).filter(_ != planet2).toList\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"\
    ), (\"Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpao_3tc57.scala:28)\n\tat Problem.main(tmpao_3tc57.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009724
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n    // Write your code here\n    val sun = JS.Math.toRadians(JS.Math.PI/4)\n\
    \    val planetNames = List(\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\", \"Neptune\")\n    if (planetNames.contains(planet1)\
    \ && planetNames.contains(planet2)) {\n        val sun1 = JS.Math.toRadians(JS.Math.toDegrees(JS.Math.atan2(planetNames(planetNames.indexOf(planet1)+1),\
    \ planetNames(planetNames.indexOf(planet2)))))\n        val sun2 = JS.Math.toRadians(JS.Math.toDegrees(JS.Math.atan2(planetNames(planetNames.indexOf(planet2)),\
    \ planetNames(planetNames.indexOf(planet1)))))\n        val earthOrbit = JS.Math.toRadians(JS.Math.PI\
    \ * 0.5)\n        val earth = JS.Math.toRadians(JS.Math.toDegrees(JS.Math.atan2(planetNames(planetNames.indexOf(planet1))-1,\
    \ planetNames(planetNames.indexOf(planet2)))))\n        val mars = JS.Math.toRadians(JS.Math.toDegrees(JS.Math.atan2(planetNames(planetNames.indexOf(planet2))+1,\
    \ planetNames(planetNames.indexOf(planet1)))))\n        val jupiter = JS.Math.toRadians(JS.Math.toDegrees(JS.Math.atan2(planetNames(planetNames.indexOf(planet1)),\
    \ planetNames(planetNames.indexOf(planet2)))))\n        val saturn = JS.Math.toRadians(JS.Math.toDegrees(JS.Math.atan2(planetNames(planetNames.indexOf(planet2)),\
    \ planetNames(planetNames.indexOf(planet1)))))\n        val uranus = JS.Math.toRadians(JS.Math.toDegrees(JS.Math.atan2(planetNames(planetNames.indexOf(planet1)),\
    \ planetNames(planetNames.indexOf(planet2)))))\n        val neptune = JS.Math.toRadians(JS.Math.toDegrees(JS.Math.atan2(planetNames(planetNames.indexOf(planet2)),\
    \ planetNames(planetNames.indexOf(planet1)))))\n        var i = 0\n        while\
    \ (i < planetNames.indexOf(planet2)) {\n            val orb1 = JS.Math.toRadians(JS.Math.toDegrees(JS.Math.atan2(\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"\
    Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp22eoa902.scala:36:73 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m            \e[33mval\e[0m \e[36morb1\e[0m = JS.Math.toRadians(JS.Math.toDegrees(JS.Math.atan2(\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                 ^\e[0m\n\e[31m   |\e[0m                                    \
    \   expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E040] Syntax Error: /tmp/tmp22eoa902.scala:49:0 ----------------------------\e\
    [0m\e[0m\n\e[31m49 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp22eoa902.scala:22:14\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m    \e[33mval\e[0m \e[36msun\e\
    [0m = JS.Math.toRadians(JS.Math.PI/\e[31m4\e[0m)\n\e[31m\e[31m   |\e[0m      \
    \        ^^\e[0m\n\e[31m   |\e[0m              Not found: JS\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmp22eoa902.scala:25:19 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36msun1\e[0m = JS.Math.toRadians(JS.Math.toDegrees(JS.Math.atan2(planetNames(planetNames.indexOf(planet1)+\e\
    [31m1\e[0m), planetNames(planetNames.indexOf(planet2)))))\n\e[31m\e[31m   |\e\
    [0m                   ^^\e[0m\n\e[31m   |\e[0m                   Not found: JS\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp22eoa902.scala:26:19\
    \ ------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e\
    [36msun2\e[0m = JS.Math.toRadians(JS.Math.toDegrees(JS.Math.atan2(planetNames(planetNames.indexOf(planet2)),\
    \ planetNames(planetNames.indexOf(planet1)))))\n\e[31m\e[31m   |\e[0m        \
    \           ^^\e[0m\n\e[31m   |\e[0m                   Not found: JS\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp22eoa902.scala:27:25 ------------------------\e\
    ["
  stdout: ''
  timestamp: 1660009719
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        if(planet1 == null || planet1 == \"\" || planet2 ==\
    \ null || planet2 == \"\") Empty\n        else {\n            val a1 = calculatePlanetOrbit(planet1)\n\
    \            val a2 = calculatePlanetOrbit(planet2)\n            val a3 = calculateProximity(a1,\
    \ a2)\n            val b1 = calculatePlanetOrbit(planet2)\n            val b2\
    \ = calculatePlanetOrbit(planet1)\n            val b3 = calculateProximity(b1,\
    \ b2)\n            a3 ++ b3\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpou6hi1fg.scala:21:81 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mif\e[0m(planet1 == \e[31mnull\e[0m || planet1\
    \ == \e[31m\"\"\e[0m || planet2 == \e[31mnull\e[0m || planet2 == \e[31m\"\"\e\
    [0m) Empty\n\e[31m\e[31m   |\e[0m                                            \
    \                                     ^^^^^\e[0m\n\e[31m   |\e[0m            \
    \                                            Not found: Empty\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpou6hi1fg.scala:23:21 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            \e[33mval\e[0m \e[36ma1\e[0m = calculatePlanetOrbit(planet1)\n\
    \e[31m\e[31m   |\e[0m                     ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                     Not found: calculatePlanetOrbit\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpou6hi1fg.scala:24:21 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m            \e[33mval\e[0m \e[36ma2\e[0m = calculatePlanetOrbit(planet2)\n\
    \e[31m\e[31m   |\e[0m                     ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                     Not found: calculatePlanetOrbit\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpou6hi1fg.scala:25:21 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m            \e[33mval\e[0m \e[36ma3\e[0m = calculateProximity(a1,\
    \ a2)\n\e[31m\e[31m   |\e[0m                     ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: calculateProximity\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpou6hi1fg.scala:26:21 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m            \e[33mval\e[0m \e[36mb1\e[0m = calculatePlanetOrbit(planet2)\n\
    \e[31m\e[31m   |\e[0m                     ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                     Not found: calculatePlanetOrbit\n\e[31m   |\e[0m\n\
    \e[31m "
  stdout: ''
  timestamp: 1660009718
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        var list : mutable.Set[String] = mutable.Set()\n \
    \       var planet1orbit : String = planet1\n        var planet2orbit : String\
    \ = planet2\n        var planet1orbit : Double\n        var planet2orbit : Double\n\
    \        var planet1orbit : Double\n        var planet2orbit : Double\n      \
    \  \n        // The first step of the algorithm. \n        // The planet names\
    \ are sorted alphabetically in the variable list\n        // by taking the last\
    \ element of the String (the planet name with \n        // the lowest index).\
    \ If planet1orbit is the last element in the \n        // String list (which means\
    \ that planet1 is the first element in the \n        // String list), then planet1orbit\
    \ and planet2orbit have the same \n        // value. \n        // If the planet1orbit\
    \ is not the last, then we put it first in the \n        // list. \n        if(planet1.last.equals(planet2.last)){\n\
    \            list = list.union(planet1.last)\n        }\n        else{\n     \
    \       list = list.union(planet2.last)\n        }\n        list = list.union(planet1)\n\
    \        \n        // The second step of the algorithm. \n        // We first\
    \ calculate the orbital distance between planet1 and planet2. \n        // This\
    \ is done by using the distance formula. \n        // The variable distant is\
    \ assigned the value 0.0. \n        // We can then find the smallest value in\
    \ this list by using a \n        // for loop. \n        // The variable smallest\
    \ is assigned the value of the first element \n        // in the list. \n    \
    \    for(i<- 1 to list.size){\n            planet1orbit = math.pow(math.pow((math.pow(planet2orbit,2)-math.pow(planet1orbit,2)),\
    \ 0.5), 1/2)\n            if(planet1orbit < smallest){\n                smallest\
    \ = planet1orbit\n            }\n        }\n        // The third step of the algorithm.\
    \ \n        // We now calculate the orbit of planet1 and planet2 and add them\
    \ to the list. \n        for(i<- 1 to list.size){\n            planet1orbit =\
    \ math.pow(math.pow((math.pow(planet2orbit,2)-math.pow(planet1orbit,2)), 0.5),\
    \ 1/2)\n            list.add(planet1orbit.toString)\n        }\n        \n   \
    \     // The fourth step of the algorithm. \n        // The list is now sorted\
    \ in ascending order, so we remove the first element \n        // from the list.\
    \ \n        list = list.drop(1)\n        \n        // The fifth step of the algorithm.\
    \ \n        // We now calculate the orbit of planet\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp3dlrz_0k.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mvar\e[0m \e[36mplanet1orbit\e[0m : \e[35mDouble\e\
    [0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mplanet1orbit is already defined as \e[33mvariable\e[0m \e[35mplanet1orbit\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp3dlrz_0k.scala:25:12 ---------------------------\e[0m\e[0m\n\e\
    [31m25 |\e[0m        \e[33mvar\e[0m \e[36mplanet2orbit\e[0m : \e[35mDouble\e[0m\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mplanet2orbit\
    \ is already defined as \e[33mvariable\e[0m \e[35mplanet2orbit\e[0m\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the\
    \ same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp3dlrz_0k.scala:26:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mvar\e[0m\
    \ \e[36mplanet1orbit\e[0m : \e[35mDouble\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mplanet1orbit is already defined as \e[33mvariable\e[0m \e\
    [35mplanet1orbit\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in the same group of toplevel definitions\n\e[31m\e[31m--\
    \ [E161] Naming Error: /tmp/tmp3dlrz_0k.scala:27:12 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mvar\e[0m \e[36mplanet2orbit\e[0m : \e[35mDouble\e\
    [0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mplanet2orbit is already defined as \e[33mvariable\e[0m \e[35mplanet2orbit\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E006] Not\
    \ Found Error: /tmp/tmp3dlrz_0k.scala:21:19 ------------------------\e[0m\e[0m\n\
    \e[31m21 |\e[0m        \e[33mvar\e[0m \e[36mlist\e[0m : mutable.Set[\e[35mString\e\
    [0m] = mutable.Set()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n"
  stdout: ''
  timestamp: 1660009732
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val distList: List[Double] = \n            List(Mercury.orbits.toSeq,\
    \ Venus.orbits.toSeq, Earth.orbits.toSeq, Mars.orbits.toSeq, Jupiter.orbits.toSeq,\
    \ \n                    Saturn.orbits.toSeq, Uranus.orbits.toSeq, Neptune.orbits.toSeq)\n\
    \            .map(f => { \n                f.filter(f => f.equals(planet1) ||\
    \ f.equals(planet2)).map(f => f.orbit.getOrbit.getOrbit.getDistance - sun.orbit.getOrbit.getDistance)\n\
    \            }.toList)\n            .reduce((l, r) => l.toSeq ++ r.toSeq)\n  \
    \      distList.filter(f => f > 0.0).sortBy(f => math.abs(f / sun.getOrbit.getOrbit.getDistance\
    \ - 1))\n    }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"\
    ), (\"Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpc3eabq_y.scala:22:17 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m            List(Mercury.orbits.toSeq, Venus.orbits.toSeq,\
    \ Earth.orbits.toSeq, Mars.orbits.toSeq, Jupiter.orbits.toSeq, \n\e[31m\e[31m\
    \   |\e[0m                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                 Not found:\
    \ Mercury\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpc3eabq_y.scala:22:39\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m            List(Mercury.orbits.toSeq,\
    \ Venus.orbits.toSeq, Earth.orbits.toSeq, Mars.orbits.toSeq, Jupiter.orbits.toSeq,\
    \ \n\e[31m\e[31m   |\e[0m                                       ^^^^^\e[0m\n\e\
    [31m   |\e[0m                                       Not found: Venus\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpc3eabq_y.scala:22:59 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m            List(Mercury.orbits.toSeq, Venus.orbits.toSeq,\
    \ Earth.orbits.toSeq, Mars.orbits.toSeq, Jupiter.orbits.toSeq, \n\e[31m\e[31m\
    \   |\e[0m                                                           ^^^^^\e[0m\n\
    \e[31m   |\e[0m                                                        Not found:\
    \ Earth\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpc3eabq_y.scala:22:79\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m            List(Mercury.orbits.toSeq,\
    \ Venus.orbits.toSeq, Earth.orbits.toSeq, Mars.orbits.toSeq, Jupiter.orbits.toSeq,\
    \ \n\e[31m\e[31m   |\e[0m                                                    \
    \                           ^^^^\e[0m\n\e[31m   |\e[0m                       \
    \                                  Not found: Mars\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpc3eabq_y.scala:22:98 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m            List(Mercury.orbits.toSeq, Venus.orbits.toS"
  stdout: ''
  timestamp: 1660009732
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val orbits = scala.collection.mutable.ListBuffer.empty[String]\n\
    \        var flag = false\n        var i = 0\n        for(i <- 0 to 8){\n    \
    \        if(planet1.equals(s\"$i\")){\n                flag = true\n         \
    \   }\n            else if(planet2.equals(s\"$i\")){\n                flag = true\n\
    \            }\n            else if(!flag){\n                orbits.append(s\"\
    $i\")\n            }\n        }\n        orbits.sortWith((x: String, y: String)\
    \ => x.charAt(0) - y.charAt(0))\n        val tempArray = orbits.toArray\n    \
    \    val returnArray = Array.ofDim[String](tempArray.size)\n        for (i<- 0\
    \ to tempArray.size)\n        {\n            if(i == tempArray.size-1){\n    \
    \            returnArray(i) = tempArray(i)\n            }\n            else{\n\
    \                returnArray(i) = tempArray(i) + tempArray(i+1)\n            }\n\
    \        }\n        returnArray.sorted\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5dd0pfos.scala:35:50\
    \ --------------------\e[0m\e[0m\n\e[31m35 |\e[0m        orbits.sortWith((\e[36mx\e\
    [0m: \e[35mString\e[0m, \e[36my\e[0m: \e[35mString\e[0m) => x.charAt(\e[31m0\e\
    [0m) - y.charAt(\e[31m0\e[0m))\n\e[31m\e[31m   |\e[0m                        \
    \                          ^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m   \
    \                                               Found:    Int\n\e[31m   |\e[0m\
    \                                                  Required: Boolean\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5dd0pfos.scala:47:8 ---------------------\e\
    [0m\e[0m\n\e[31m47 |\e[0m        returnArray.sorted\n\e[31m\e[31m   |\e[0m   \
    \     ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    \e[1m\e[31mArray\e\
    [0m[String]\n\e[31m   |\e[0m        Required: \e[1m\e[32mList\e[0m[String]\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660009731
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        if (planet1.toUpperCase == \"SATURN\") planet1.toUpperCase()\n\
    \        else if (planet1.toUpperCase == \"URANUS\") planet1.toUpperCase()\n \
    \       else if (planet1.toUpperCase == \"NEPTUNE\") planet1.toUpperCase()\n \
    \       else if (planet2.toUpperCase == \"MERCURY\") planet2.toUpperCase()\n \
    \       else if (planet2.toUpperCase == \"VENUS\") planet2.toUpperCase()\n   \
    \     else if (planet2.toUpperCase == \"EARTH\") planet2.toUpperCase()\n     \
    \   else if (planet2.toUpperCase == \"MARS\") planet2.toUpperCase()\n        else\
    \ if (planet2.toUpperCase == \"JUPITER\") planet2.toUpperCase()\n        else\
    \ if (planet2.toUpperCase == \"SATURN\") planet2.toUpperCase()\n        else if\
    \ (planet2.toUpperCase == \"URANUS\") planet2.toUpperCase()\n        else if (planet2.toUpperCase\
    \ == \"NEPTUNE\") planet2.toUpperCase()\n        else ()\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4n3et43q.scala:21:64\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mif\e[0m (planet1.toUpperCase\
    \ == \e[31m\"SATURN\"\e[0m) planet1.toUpperCase()\n\e[31m\e[31m   |\e[0m     \
    \                                        ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                                             Found:    String\n\e[31m\
    \   |\e[0m                                             Required: \e[1m\e[32mList\e\
    [0m\e[1m\e[32m[\e[0mString\e[1m\e[32m]\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmp4n3et43q.scala:22:69 --------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (planet1.toUpperCase\
    \ == \e[31m\"URANUS\"\e[0m) planet1.toUpperCase()\n\e[31m\e[31m   |\e[0m     \
    \                                             ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                                                  Found:    String\n\
    \e[31m   |\e[0m                                                  Required: \e\
    [1m\e[32mList\e[0m\e[1m\e[32m[\e[0mString\e[1m\e[32m]\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4n3et43q.scala:23:70 --------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (planet1.toUpperCase\
    \ == \e[31m\"NEPTUNE\"\e[0m) planet1.toUpperCase()\n\e[31m\e[31m   |\e[0m    \
    \                                               ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                                                  Found:    String\n\
    \e[31m   |\e[0m                                                  Required: \e\
    [1m\e[32mList\e[0m\e[1m\e[32m[\e[0mString\e[1m\e[32m]\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4n3et43q.scala:24:70 --------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (planet2.toUpperCase\
    \ == \e[31m\"MERCURY\"\e[0m) planet2.toUpperCase()\n\e[31m\e[31m   |\e[0m    \
    \                                               "
  stdout: ''
  timestamp: 1660009732
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        def planetOther(p1 : String) : List[String] = p1 ::\
    \ Nil\n        def planetOther2(name : String) : List[String] = Nil\n        val\
    \ planet1Orbit = planet1.toUpperCase\n        val planet2Orbit = planet2.toUpperCase\n\
    \        if (planet1Orbit.equals(\"MERCURY\") && planet2Orbit.equals(\"NEPTUNE\"\
    )) {\n            (planet1Orbit.toUpperCase :: planet2Orbit.toUpperCase :: Nil)\n\
    \        } else if (planet1Orbit.equals(\"EARTH\") && planet2Orbit.equals(\"MARS\"\
    )) {\n            (planet1Orbit.toUpperCase :: planet2Orbit.toUpperCase :: Nil)\n\
    \        } else if (planet1Orbit.equals(\"JUPITER\") && planet2Orbit.equals(\"\
    SATURN\")) {\n            (planet1Orbit.toUpperCase :: planet2Orbit.toUpperCase\
    \ :: Nil)\n        } else if (planet1Orbit.equals(\"NEPTUNE\") && planet2Orbit.equals(\"\
    URANUS\")) {\n            (planet1Orbit.toUpperCase :: planet2Orbit.toUpperCase\
    \ :: Nil)\n        } else if (planet1Orbit.equals(\"NEPTUNE\") && planet2Orbit.equals(\"\
    URANUS\")) {\n            (planet1Orbit.toUpperCase :: planet2Orbit.toUpperCase\
    \ :: Nil)\n        } else {\n            ()\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp98tbdp2s.scala:36:12\
    \ --------------------\e[0m\e[0m\n\e[31m36 |\e[0m            ()\n\e[31m\e[31m\
    \   |\e[0m            ^^\e[0m\n\e[31m   |\e[0m            Found:    Unit\n\e[31m\
    \   |\e[0m            Required: List[String]\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009731
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val orbit1 = Orbital(planet1)\n        val orbit2\
    \ = Orbital(planet2)\n        val orbitList = List(orbit1, orbit2)\n        val\
    \ earthOrbit = orbitList._1\n        val mercuryOrbit = orbitList._2\n       \
    \ val planetList = List(earthOrbit, mercuryOrbit)\n        val distance = Vector.zero\n\
    \        var distanceTuple : List[String] = Nil\n        var i = 0\n        while\
    \ (i < planetList.size) {\n            val planet = planetList(i)\n          \
    \  val planetOrbit = Orbital(planet)\n            val distanceToSun = planetOrbit.dist(planetOrbit.sun)\n\
    \            val distanceToPlanet = planetOrbit.dist(planet)\n            if (distanceToSun\
    \ > distanceToPlanet) {\n                distanceTuple = planetOrbit.sun\n   \
    \             distance = 0\n            } else {\n                distance +=\
    \ distanceToPlanet\n            }\n            i += 1\n        }\n        if (distance\
    \ < 1) {\n            return List()\n        }\n        distanceTuple.sortWith(_.dist(planet1)\
    \ <= _.dist(planet2))\n    }\n    def main(args: Array[String]) = {\n    assert(bf((\"\
    Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n\
    \    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n\
    \    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"),\
    \ (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpyiibcyzv.scala:21:21 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36morbit1\e[0m = Orbital(planet1)\n\
    \e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \               Not found: Orbital\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpyiibcyzv.scala:22:21 ------------------------\e[0m\e[0m\n\e[31m22 |\e\
    [0m        \e[33mval\e[0m \e[36morbit2\e[0m = Orbital(planet2)\n\e[31m\e[31m \
    \  |\e[0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                  \
    \   Not found: Orbital\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpyiibcyzv.scala:24:35\
    \ ------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e\
    [36mearthOrbit\e[0m = orbitList._1\n\e[31m\e[31m   |\e[0m                    \
    \     ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                         value _1 is not\
    \ a member of List[Nothing]\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpyiibcyzv.scala:25:37\
    \ ------------------------\e[0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e\
    [36mmercuryOrbit\e[0m = orbitList._2\n\e[31m\e[31m   |\e[0m                  \
    \         ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                           value _2\
    \ is not a member of List[Nothing]\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpyiibcyzv.scala:27:30\
    \ ------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e\
    [36mdistance\e[0m = Vector.zero\n\e[31m\e[31m   |\e[0m                       ^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue zero is not a member of object scala.collection.immutable.Vector\
    \ - did you mean Vector.from?\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpyiibcyzv.scala:32:30\
    \ ------------------------\e[0m\e[0m\n\e[31m32 |\e[0m            \e[33mval\e[0m\
    \ \e[36mplanetOrbit\e[0m = Orbital(planet)\n\e[31m\e[31m   |\e[0m            \
    \                  ^^^^^^^\e[0m\n\e[31m   |\e[0m                             \
    \ Not found: Orbital\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling wi"
  stdout: ''
  timestamp: 1660009732
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        def distance(planet1 : String, planet2 : String) :\
    \ Double = {\n            val p1 = Planet(planet1)\n            val p2 = Planet(planet2)\n\
    \            math.pow(p1.distance(p2), 2.0)\n        }\n        val p1 = Planet(planet1)\n\
    \        val p2 = Planet(planet2)\n        val sun = Planet(\"Sun\")\n       \
    \ val orbit1 = Orbit(p1, sun)\n        val orbit2 = Orbit(p2, sun)\n        val\
    \ orbit1List = List(orbit1, orbit2, orbit1, orbit1, orbit1, orbit1, orbit2, orbit2,\
    \ orbit2, orbit2, orbit1, orbit1, orbit1, orbit1)\n        val orbit2List = List(orbit2,\
    \ orbit1, orbit2, orbit2, orbit2, orbit2, orbit2, orbit2, orbit2, orbit2, orbit2,\
    \ orbit2, orbit2, orbit2, orbit2, orbit2)\n        val planet1List = orbit1List\
    \ ::: orbit2List\n        val planet2List = orbit2List ::: orbit1List\n      \
    \  val planet1OrbitPairs = planet1List.groupBy(orbit1 => orbit1.name)\n      \
    \  val planet2OrbitPairs = planet2List.groupBy(orbit2 => orbit2.name)\n      \
    \  val planet1OrbitPairsList = planet1OrbitPairs.values.toList\n        val planet2OrbitPairsList\
    \ = planet2OrbitPairs.values.toList\n        val closest = math.pow(planet1.distance(planet2),\
    \ 2.0)\n        val closestPairs = planet1OrbitPairsList.zipWithIndex.filter {\
    \ case (orbit1, orbit2Index) => math.pow(orbit1.distance(orbit2), 2.0) == closest\
    \ }\n        val closestOrbitPairs = closestPairs.groupBy(_._2)\n        val closest\
    \ = closestOrbitPairs.values.toList\n        return closest\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmphbjkn14k.scala:42:12 ---------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m        \e[33mval\e[0m \e[36mclosest\e[0m = closestOrbitPairs.values.toList\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mclosest is already defined as \e[33mvalue\e[0m \e[35mclosest\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E006] Not\
    \ Found Error: /tmp/tmphbjkn14k.scala:22:21 ------------------------\e[0m\e[0m\n\
    \e[31m22 |\e[0m            \e[33mval\e[0m \e[36mp1\e[0m = Planet(planet1)\n\e\
    [31m\e[31m   |\e[0m                     ^^^^^^\e[0m\n\e[31m   |\e[0m         \
    \            Not found: Planet\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmphbjkn14k.scala:23:21 ------------------------\e[0m\e[0m\n\e[31m23 |\e\
    [0m            \e[33mval\e[0m \e[36mp2\e[0m = Planet(planet2)\n\e[31m\e[31m  \
    \ |\e[0m                     ^^^^^^\e[0m\n\e[31m   |\e[0m                    \
    \ Not found: Planet\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmphbjkn14k.scala:26:17\
    \ ------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e\
    [36mp1\e[0m = Planet(planet1)\n\e[31m\e[31m   |\e[0m                 ^^^^^^\e\
    [0m\n\e[31m   |\e[0m                 Not found: Planet\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmphbjkn14k.scala:27:17 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mp2\e[0m = Planet(planet2)\n\
    \e[31m\e[31m   |\e[0m                 ^^^^^^\e[0m\n\e[31m   |\e[0m           \
    \      Not found: Planet\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmphbjkn14k.scala:28:18 ------------------------\e[0m\e[0m\n\e[31m28 |\e\
    [0m        \e[33mval\e[0m \e[36msun\e[0m = Planet(\e[31m\"Sun\"\e[0m)\n\e[31m\e\
    [31m   |\e[0m  "
  stdout: ''
  timestamp: 1660009732
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        planet1 match {\n            case \"Earth\" => (\"\
    Venus\", planet2)\n            case \"Mercury\" => (\"Venus\", planet2)\n    \
    \        case \"Venus\" => (\"Earth\", planet2)\n            case \"Mars\" =>\
    \ (\"Jupiter\", planet2)\n            case \"Jupiter\" => (\"Saturn\", planet2)\n\
    \            case \"Saturn\" => (\"Uranus\", planet2)\n            case \"Uranus\"\
    \ => (\"Neptune\", planet2)\n            case \"Neptune\" => (\"Jupiter\", planet2)\n\
    \            case \"Mercury\" => List(planet2)\n            case _ => Nil\n  \
    \      }\n    }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"\
    ), (\"Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpz3s9psil.scala:22:28\
    \ --------------------\e[0m\e[0m\n\e[31m22 |\e[0m            \e[33mcase\e[0m \e\
    [31m\"Earth\"\e[0m => (\e[31m\"Venus\"\e[0m, planet2)\n\e[31m\e[31m   |\e[0m \
    \                           ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m         \
    \                   Found:    (String, String)\n\e[31m   |\e[0m              \
    \              Required: List[String]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpz3s9psil.scala:23:30 --------------------\e[0m\e\
    [0m\n\e[31m23 |\e[0m            \e[33mcase\e[0m \e[31m\"Mercury\"\e[0m => (\e\
    [31m\"Venus\"\e[0m, planet2)\n\e[31m\e[31m   |\e[0m                          \
    \    ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                              Found:\
    \    (String, String)\n\e[31m   |\e[0m                              Required:\
    \ List[String]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpz3s9psil.scala:24:28\
    \ --------------------\e[0m\e[0m\n\e[31m24 |\e[0m            \e[33mcase\e[0m \e\
    [31m\"Venus\"\e[0m => (\e[31m\"Earth\"\e[0m, planet2)\n\e[31m\e[31m   |\e[0m \
    \                           ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m         \
    \                   Found:    (String, String)\n\e[31m   |\e[0m              \
    \              Required: List[String]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpz3s9psil.scala:25:27 --------------------\e[0m\e\
    [0m\n\e[31m25 |\e[0m            \e[33mcase\e[0m \e[31m\"Mars\"\e[0m => (\e[31m\"\
    Jupiter\"\e[0m, planet2)\n\e[31m\e[31m   |\e[0m                           ^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                           Found:    (String, String)\n\e\
    [31m   |\e[0m                           Required: List[String]\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpz3s9psil.scala:26:30 --------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m            \e[33mcase\e[0m \e["
  stdout: ''
  timestamp: 1660009733
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val orbit_planet1 = Orbit(planet1)\n        val orbit_planet2\
    \ = Orbit(planet2)\n        val sun = Orbit(\"Sun\")\n        \n        // Calculate\
    \ orbit of planet1\n        val orbit_planet1_1 = orbit_planet1.earth_moon\n \
    \       val orbit_planet1_2 = orbit_planet1.sun\n        \n        // Calculate\
    \ orbit of planet2\n        val orbit_planet2_1 = orbit_planet2.earth_moon\n \
    \       val orbit_planet2_2 = orbit_planet2.sun\n        \n        // For planet1,\
    \ find orbit of planet2\n        val orbit_planet1_2_1 = orbit_planet1_2.earth_moon\n\
    \        val orbit_planet1_2_2 = orbit_planet1_2.sun\n        \n        // For\
    \ planet2, find orbit of planet1\n        val orbit_planet2_1_1 = orbit_planet2_1.earth_moon\n\
    \        val orbit_planet2_1_2 = orbit_planet2_1.sun\n        \n        // Calculate\
    \ distance\n        val distance12 = Vector3.distance(orbit_planet1_2.position,\n\
    \                                       orbit_planet1_2.position)\n        val\
    \ distance21 = Vector3.distance(orbit_planet1_2.position,\n                  \
    \                     orbit_planet2_1.position)\n        val distance22 = Vector3.distance(orbit_planet2_1.position,\n\
    \                                       orbit_planet2_1.position)\n        val\
    \ distance121 = Vector3.distance(orbit_planet1_2.position,\n                 \
    \                       orbit_planet2_1.position)\n        val distance122 = Vector3.distance(orbit_planet1_2.position,\n\
    \                                        orbit_planet2_2.position)\n        val\
    \ distance1222 = Vector3.distance(orbit_planet1_2.position,\n                \
    \                         orbit_planet2_2.position)\n        \n        // Create\
    \ planets list\n        val planets12: List[String] = if (distance12 < distance21)\n\
    \                                        List(planet1, planet2)\n            \
    \                        else if (distance22 < distance121)\n                \
    \                        List(planet2, planet1)\n                            \
    \        else List()\n        val planets21: List[String] = if (distance12 < distance22)\n\
    \                                        List(planet2, planet1)\n            \
    \                        else if (distance22 < distance121)\n                \
    \                        List(planet1, planet2)\n                            \
    \        else List()\n        val planets121: List[String] = if (distance122 <\
    \ distance22\n    }\n    def main(args: Array[String]) = {\n    assert(bf((\"\
    Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n\
    \    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n\
    \    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"),\
    \ (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp21l_a6n1.scala:67:4 ----------------------------\e\
    [0m\e[0m\n\e[31m67 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp21l_a6n1.scala:21:28\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36morbit_planet1\e[0m = Orbit(planet1)\n\e[31m\e[31m   |\e[0m               \
    \             ^^^^^\e[0m\n\e[31m   |\e[0m                            Not found:\
    \ Orbit\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp21l_a6n1.scala:22:28\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36morbit_planet2\e[0m = Orbit(planet2)\n\e[31m\e[31m   |\e[0m               \
    \             ^^^^^\e[0m\n\e[31m   |\e[0m                            Not found:\
    \ Orbit\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp21l_a6n1.scala:23:18\
    \ ------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e\
    [36msun\e[0m = Orbit(\e[31m\"Sun\"\e[0m)\n\e[31m\e[31m   |\e[0m              \
    \    ^^^^^\e[0m\n\e[31m   |\e[0m                  Not found: Orbit\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp21l_a6n1.scala:42:25 ------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m        \e[33mval\e[0m \e[36mdistance12\e[0m = Vector3.distance(orbit_planet1_2.position,\n\
    \e[31m\e[31m   |\e[0m                         ^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                       Not found: Vector3\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmp21l_a6n1.scala:44:25 ------------------------\e[0m\e\
    [0m\n\e[31m44 |\e[0m        \e[33mval\e[0m \e[36mdistance21\e[0m = Vector3.distance(orbit_planet1_2.position,\n\
    \e[31m\e[31m   |\e[0m                         ^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                       Not found: Vector3\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation "
  stdout: ''
  timestamp: 1660009731
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(planet1, planet2)\n        val\
    \ orbit1 = orbs(planet1)\n        val orbit2 = orbs(planet2)\n        val intersection\
    \ = orbit1.intersection(orbit2)\n        val distBetween = intersection.map(_.distanceTo(new\
    \ Point3d(0,0,1)))\n        val toList = intersection.toList\n        toList.sortWith(_.distanceTo(new\
    \ Point3d(0,0,1)) < _.distanceTo(new Point3d(0,0,1)))\n        toList\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp_xt94977.scala:22:21 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36morbit1\e[0m = orbs(planet1)\n\
    \e[31m\e[31m   |\e[0m                     ^^^^\e[0m\n\e[31m   |\e[0m         \
    \            Not found: orbs\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp_xt94977.scala:23:21 ------------------------\e[0m\e[0m\n\e[31m23 |\e\
    [0m        \e[33mval\e[0m \e[36morbit2\e[0m = orbs(planet2)\n\e[31m\e[31m   |\e\
    [0m                     ^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ orbs\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660009726
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        var result : List[String] = Nil\n        var temp\
    \ : List[String] = Nil\n        for(j <- 0 to 6) {\n            if((planet1.equals(Planet(j)).planet)\
    \ && \n              (planet2.equals(Planet(j+1)).planet)) {\n               \
    \ temp <- temp :+ Planet(j).name\n            }\n            if((planet2.equals(Planet(j)).planet)\
    \ && \n              (planet1.equals(Planet(j+1)).planet)) {\n               \
    \ temp <- temp :+ Planet(j+1).name\n            }\n        }\n        for(j <-\
    \ 0 to 6) {\n            if((temp.contains(Planet(j)).planet) && \n          \
    \    (temp.contains(Planet(j+1)).planet)) {\n                result <- result\
    \ :+ Planet(j).name\n            }\n            if((temp.contains(Planet(j+1)).planet)\
    \ && \n              (temp.contains(Planet(j)).planet)) {\n                result\
    \ <- result :+ Planet(j+1).name\n            }\n        }\n        result.sortWith((x,\
    \ y) => (x.compare(y)) * -1)\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpnn1vr8xw.scala:26:21 -----------------------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m                temp <- temp :+ Planet(j).name\n\e[31m\e\
    [31m   |\e[0m                     ^^\e[0m\n\e[31m   |\e[0m                   \
    \  end of statement expected but '<-' found\n\e[31m\e[31m-- Error: /tmp/tmpnn1vr8xw.scala:30:21\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m30 |\e[0m       \
    \         temp <- temp :+ Planet(j+\e[31m1\e[0m).name\n\e[31m\e[31m   |\e[0m \
    \                    ^^\e[0m\n\e[31m   |\e[0m                     end of statement\
    \ expected but '<-' found\n\e[31m\e[31m-- Error: /tmp/tmpnn1vr8xw.scala:36:23\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m36 |\e[0m       \
    \         result <- result :+ Planet(j).name\n\e[31m\e[31m   |\e[0m          \
    \             ^^\e[0m\n\e[31m   |\e[0m                       end of statement\
    \ expected but '<-' found\n\e[31m\e[31m-- Error: /tmp/tmpnn1vr8xw.scala:40:23\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m40 |\e[0m       \
    \         result <- result :+ Planet(j+\e[31m1\e[0m).name\n\e[31m\e[31m   |\e\
    [0m                       ^^\e[0m\n\e[31m   |\e[0m                       end of\
    \ statement expected but '<-' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpnn1vr8xw.scala:24:31\
    \ ------------------------\e[0m\e[0m\n\e[31m24 |\e[0m            \e[33mif\e[0m((planet1.equals(Planet(j)).planet)\
    \ && \n\e[31m\e[31m   |\e[0m                               ^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                               Not found: Planet\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpnn1vr8xw.scala:28:31 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m            \e[33mif\e[0m((planet2.equals(Planet(j)).planet)\
    \ && \n\e[31m\e[31m   |\e[0m                               ^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                               Not found: Planet\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpnn1vr8xw.scala:34:30 ------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        "
  stdout: ''
  timestamp: 1660009731
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        var planets1= List(planet1, planet2)\n        var\
    \ planets2= List(planet2, planet1)\n        while(planets1.nonEmpty || planets2.nonEmpty)\
    \ {\n            var planet1orbit = planets1.head\n            var planet2orbit\
    \ = planets2.head\n            planets1 :=  planets1.tail\n            planets2\
    \ :=  planets2.tail\n            if( planet1orbit == planet2orbit) yield planet1orbit\n\
    \            else if( planet1orbit < planet2orbit) yield {planets1; planet2orbit}\n\
    \            else {planet2orbit; planets1; planet1orbit}\n        }\n        List()\
    \ \n    }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"),\
    \ (\"Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmprysantiy.scala:28:46 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m            \e[33mif\e[0m( planet1orbit == planet2orbit)\
    \ \e[33myield\e[0m planet1orbit\n\e[31m\e[31m   |\e[0m                       \
    \                       ^^^^^\e[0m\n\e[31m   |\e[0m                          \
    \            'then' expected, but 'yield' found\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmprysantiy.scala:26:21 ------------------------\e[0m\e[0m\n\e[31m26\
    \ |\e[0m            planets1 :=  planets1.tail\n\e[31m\e[31m   |\e[0m        \
    \    ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue := is not a member of List[String]\
    \ - did you mean List[String].!=?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmprysantiy.scala:27:21\
    \ ------------------------\e[0m\e[0m\n\e[31m27 |\e[0m            planets2 := \
    \ planets2.tail\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mvalue := is not a member of List[String] - did you mean List[String].!=?\n\e\
    [33m\e[33m-- [E129] Potential Issue Warning: /tmp/tmprysantiy.scala:31:8 -----------------\e\
    [0m\e[0m\n\e[33m30 |\e[0m            \e[33melse\e[0m {planet2orbit; planets1;\
    \ planet1orbit}\n\e[33m31 |\e[0m        }\n\e[33m\e[33m   |\e[0m             \
    \                                          ^\e[0m\n\e[33m   |\e[0mA pure expression\
    \ does nothing in statement position; you may be omitting necessary parentheses\n\
    \e[33m   |\e[0m\n\e[33m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 warning found\n3 errors found\n"
  stdout: ''
  timestamp: 1660009732
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        def sortByProximity(planet1 : String, planet2 : String,\
    \ \n                             orb1 : String, orb2 : String, sunO : Double)\
    \ :\n                                  (Double, List[String]) = {\n          \
    \  val dO = orb1.longitude - orb2.longitude\n            val dS = sunO - orb1.latitude\n\
    \            val dP = sunO - orb2.latitude\n            if (dS < 0 || dP < 0)\
    \ {\n                return (dS, List(planet1, planet2))\n            } else if\
    \ (dO < 0 || dS < 0 || dP < 0) {\n                return (dO, List(planet1, planet2))\n\
    \            } else if (dO < 0 || dS < 0 || dP > 0) {\n                return\
    \ (dP, List(planet1, planet2))\n            } else if (dS > 0 || dP > 0) {\n \
    \               return (dS, List(planet1, planet2))\n            } else if (dS\
    \ > 0 || dP < 0) {\n                return (dP, List(planet1, planet2))\n    \
    \        }\n        }\n        val planets = List((\"Mercury\"), (\"Venus\"),\
    \ (\"Earth\"), \n                          (\"Mars\"), (\"Jupiter\"), (\"Saturn\"\
    ), \n                          (\"Uranus\"), (\"Neptune\"))\n        var result:\
    \ List[String] = Nil\n        var sunO : Double = 7.292115 * Math.cos(math.radians(23.439))\n\
    \        var orb1 : Double = 0.0\n        var orb2 : Double = 0.0\n        for\
    \ (planet <- planets) {\n            val d = sortByProximity(planet1, planet2,\
    \ planet, planet, sunO)\n            sunO = d._1\n            if (sunO < 0.0)\
    \ sunO = 0.0\n            orb1 = d._2(0).toDouble\n            orb2 = d._2(1).toDouble\n\
    \            if ((orb1 < 0.0 || orb1 > 360.0) || (orb2 < 0.0 || orb2 > 360.0))\
    \ {\n                result += d._2.toList\n            } else {\n           \
    \     if (orb1 > orb2) {\n                    if (orb1 - orb2 < 0.0) {\n     \
    \                   result += d._2.toList\n                    } else {\n    \
    \                    result += d._2.toList.drop(1)\n                    }\n  \
    \              } else {\n                    if (orb2 - orb1 < 0.0) {\n      \
    \                  result += d._2.toList.drop(1)\n                    } else {\n\
    \                        result += d._2.toList\n                    }\n      \
    \          }\n            }\n        }\n        return result\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpdamf_62l.scala:24:26 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m            \e[33mval\e[0m \e[36mdO\e[0m = orb1.longitude\
    \ - orb2.longitude\n\e[31m\e[31m   |\e[0m                     ^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                     value longitude is not a member of String\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpdamf_62l.scala:25:33 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m            \e[33mval\e[0m \e[36mdS\e[0m = sunO - orb1.latitude\n\
    \e[31m\e[31m   |\e[0m                            ^^^^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                            value latitude is not a member of String\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpdamf_62l.scala:26:33 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m            \e[33mval\e[0m \e[36mdP\e[0m = sunO - orb2.latitude\n\
    \e[31m\e[31m   |\e[0m                            ^^^^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                            value latitude is not a member of String\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpdamf_62l.scala:35:19 --------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m            } \e[33melse\e[0m \e[33mif\e[0m (dS > \e\
    [31m0\e[0m || dP < \e[31m0\e[0m) {\n\e[31m\e[31m   |\e[0m                   ^\e\
    [0m\n\e[31m   |\e[0m                 Found:    Unit\n\e[31m   |\e[0m         \
    \        Required: (Double, List[String])\n\e[31m   |\e[0m                 Maybe\
    \ you are missing an else part for the conditional?\n\e[31m36 |\e[0m         \
    \       \e[33mreturn\e[0m (dP, List(planet1, planet2))\n\e[31m37 |\e[0m      \
    \      }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpdamf_62l.scala:43:53\
    \ ------------------------\e[0m\e[0m\n\e[31m43 |\e[0m        \e[33mvar\e[0m \e\
    [36msunO\e[0m : \e[35mDouble\e[0m = \e[31m7.292115\e[0m * Math.cos(math.radians(\e\
    [31m23.439\e[0m))\n\e[31m\e[31m   |\e[0m                                     \
    \           ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                               \
    \    value radians is not a member of math\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpdamf_62l.scala:53:23 ----------------"
  stdout: ''
  timestamp: 1660009734
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        var allPlanets = List.empty[String]\n        var earthOrbit\
    \ = Array.empty[Double]\n        var earthDist = List.empty[Double]\n        var\
    \ earthProxy = List.empty[Double]\n        var marsOrbit = Array.empty[Double]\n\
    \        var marsDist = List.empty[Double]\n        var marsProxy = List.empty[Double]\n\
    \        var jupOrbit = Array.empty[Double]\n        var jupDist = List.empty[Double]\n\
    \        var jupProxy = List.empty[Double]\n        var satOrbit = Array.empty[Double]\n\
    \        var satDist = List.empty[Double]\n        var satProxy = List.empty[Double]\n\
    \        var uranusOrbit = Array.empty[Double]\n        var uranusDist = List.empty[Double]\n\
    \        var uranusProxy = List.empty[Double]\n        var neptuneOrbit = Array.empty[Double]\n\
    \        var neptuneDist = List.empty[Double]\n        var neptuneProxy = List.empty[Double]\n\
    \        if(planet1 == planet2) {\n            allPlanets = List(\"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        }\n       \
    \ else {\n            allPlanets = List(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\")\n        }\n        for(planet <- allPlanets) {\n            if(planet\
    \ == \"Earth\") {\n                earthOrbit = Array(4.3958, 6.67384)\n     \
    \           earthDist = List(53.7649, 60.7406)\n                earthProxy = List(46.5822,\
    \ 51.9722)\n            }\n            else if(planet == \"Mars\") {\n       \
    \         marsOrbit = Array(3.6338, 8.76764)\n                marsDist = List(59.4014,\
    \ 69.0953)\n                marsProxy = List(52.5039, 58.2778)\n            }\n\
    \            else if(planet == \"Jupiter\") {\n                jupOrbit = Array(3.1444,\
    \ 2.1765)\n                jupDist = List(68.9043, 73.4396)\n                jupProxy\
    \ = List(54.0114, 59.6463)\n            }\n            else if(planet == \"Saturn\"\
    ) {\n                satOrbit = Array(2.4496, 3.6234)\n                satDist\
    \ = List(54.5934, 58.0534)\n                satProxy = List(53.8893, 55.\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmppb33z_9g.scala:66:4 ----------------------------\e\
    [0m\e[0m\n\e[31m66 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tmppb33z_9g.scala:78:0 ----------------------------\e[0m\e[0m\n\e[31m78\
    \ |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\
    \e[33m\e[33m-- Warning: /tmp/tmppb33z_9g.scala:67:4 ----------------------------------------\e\
    [0m\e[0m\n\e[33m67 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m\
    \   |\e[0m    Line is indented too far to the left, or a `}` is missing\n1 warning\
    \ found\n2 errors found\n"
  stdout: ''
  timestamp: 1660009732
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n      val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n      val dists\
    \ = Map(\n          (\"Mercury\", \"Venus\") -> 1,\n          (\"Mercury\", \"\
    Earth\") -> 1.414,\n          (\"Mercury\", \"Mars\") -> 0.881,\n          (\"\
    Mercury\", \"Jupiter\") -> 0.785,\n          (\"Mercury\", \"Saturn\") -> 0.612,\n\
    \          (\"Mercury\", \"Uranus\") -> 0.646,\n          (\"Mercury\", \"Neptune\"\
    ) -> 0.646,\n          (\"Venus\", \"Earth\") -> 1.414,\n          (\"Venus\"\
    , \"Mars\") -> 1.414,\n          (\"Venus\", \"Jupiter\") -> 1.414,\n        \
    \  (\"Venus\", \"Saturn\") -> 1.414,\n          (\"Venus\", \"Uranus\") -> 1.414,\n\
    \          (\"Venus\", \"Neptune\") -> 1.414,\n          (\"Earth\", \"Mars\"\
    ) -> 0.881,\n          (\"Earth\", \"Jupiter\") -> 0.785,\n          (\"Earth\"\
    , \"Saturn\") -> 0.612,\n          (\"Earth\", \"Uranus\") -> 0.646,\n       \
    \   (\"Earth\", \"Neptune\") -> 0.646,\n          (\"Mars\", \"Jupiter\") -> 0.881,\n\
    \          (\"Mars\", \"Saturn\") -> 0.612,\n          (\"Mars\", \"Uranus\")\
    \ -> 0.646,\n          (\"Mars\", \"Neptune\") -> 0.646,\n          (\"Jupiter\"\
    , \"Saturn\") -> 0.785,\n          (\"Jupiter\", \"Uranus\") -> 0.646,\n     \
    \     (\"Jupiter\", \"Neptune\") -> 0.646,\n          (\"Saturn\", \"Uranus\"\
    ) -> 0.612,\n          (\"Saturn\", \"Neptune\") -> 0.646)\n      \n      def\
    \ dist(planet1 : String, planet2 : String) : Double = {\n        dists.get(planet1,\
    \ planet2)\n      }\n\n      val orbits = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n      val orbits1\
    \ = orbits.map( o => (o, o))\n      val orbits2 = orbits1.map( o => (o, o))\n\
    \      val orbits3 = orbits2.map( o => (o, o))\n\n      val orbits1 = orbits.map(\
    \ o => (\n    }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"\
    ), (\"Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmps10ravd9.scala:60:38 ---------------------------\e\
    [0m\e[0m\n\e[31m60 |\e[0m      \e[33mval\e[0m \e[36morbits1\e[0m = orbits.map(\
    \ \e[36mo\e[0m => (\n\e[31m\e[31m   |\e[0m                                   \
    \   ^\e[0m\n\e[31m   |\e[0m                                      expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmps10ravd9.scala:52:17 --------------------\e[0m\e[0m\n\e[31m52\
    \ |\e[0m        dists.get(planet1, planet2)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Option[AnyVal]\n\e[31m   |\e[0m        Required:\
    \ Double\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmps10ravd9.scala:61:5\
    \ ---------------------\e[0m\e[0m\n\e[31m61 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[String]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660009735
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val p1 = List(planet1,planet2)\n        val p2 = List(planet2,planet1)\n\
    \        val orbit1 = orbit(p1,p2)\n        val orbit2 = orbit(p2,p1)\n      \
    \  val orbits = List(orbit1, orbit2)\n        val sun = orbits.flatMap(planet\
    \ => orbit(planet,List(planet)))\n        sun match {\n            case Nil =>\
    \ List()\n            case x :: Nil => (x +: sun).sortWith((a,b) => b - a)\n \
    \           case x :: xs => x +: (xs ++ sun).sortWith((a,b) => b - a)\n      \
    \  }\n    }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"\
    ), (\"Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp5i92rgqw.scala:23:21 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36morbit1\e[0m = orbit(p1,p2)\n\
    \e[31m\e[31m   |\e[0m                     ^^^^^\e[0m\n\e[31m   |\e[0m        \
    \             Not found: orbit\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp5i92rgqw.scala:24:21 ------------------------\e[0m\e[0m\n\e[31m24 |\e\
    [0m        \e[33mval\e[0m \e[36morbit2\e[0m = orbit(p2,p1)\n\e[31m\e[31m   |\e\
    [0m                     ^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ orbit\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp5i92rgqw.scala:26:43\
    \ ------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e\
    [36msun\e[0m = orbits.flatMap(\e[36mplanet\e[0m => orbit(planet,List(planet)))\n\
    \e[31m\e[31m   |\e[0m                                           ^^^^^\e[0m\n\e\
    [31m   |\e[0m                                           Not found: orbit\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp5i92rgqw.scala:29:60 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m            \e[33mcase\e[0m x :: Nil => (x +: sun).sortWith((a,b)\
    \ => b - a)\n\e[31m\e[31m   |\e[0m                                           \
    \               ^^^\e[0m\n\e[31m   |\e[0mvalue - is not a member of Nothing, but\
    \ could be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mOne of the following imports might fix the problem:\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m  import Byte.byte2double\n\e[31m   |\e[0m  import Byte.byte2float\n\
    \e[31m   |\e[0m  import Byte.byte2int\n\e[31m   |\e[0m  import Byte.byte2long\n\
    \e[31m   |\e[0m  import Byte.byte2short\n\e[31m   |\e[0m  import Char.char2double\n\
    \e[31m   |\e[0m  import Char.char2float\n\e[31m   |\e[0m  import Char.char2int\n\
    \e[31m   |\e[0m  import Char.char2long\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.properties\
    \ AsScalaMap\n\e[31m   |\e[0m\n\e[3"
  stdout: ''
  timestamp: 1660009736
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planet1Orbit = orbit(planet1)\n        val planet2Orbit\
    \ = orbit(planet2)\n        val proximity = proximity(planet1Orbit, planet2Orbit)\n\
    \        proximity.toList.sortBy(x => x)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpfwx65fpg.scala:21:27 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mplanet1Orbit\e[0m = orbit(planet1)\n\
    \e[31m\e[31m   |\e[0m                           ^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                         Not found: orbit\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpfwx65fpg.scala:22:27 ------------------------\e[0m\e\
    [0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mplanet2Orbit\e[0m = orbit(planet2)\n\
    \e[31m\e[31m   |\e[0m                           ^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                         Not found: orbit\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E045]\
    \ Cyclic Error: /tmp/tmpfwx65fpg.scala:23:24 ---------------------------\e[0m\e\
    [0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mproximity\e[0m = proximity(planet1Orbit,\
    \ planet2Orbit)\n\e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m \
    \  |\e[0m                        Recursive \e[33mvalue\e[0m \e[35mproximity\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660009731
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planet1 = planet1.toUpperCase()\n        val planet2\
    \ = planet2.toUpperCase()\n        val planets = List(\"Mercury\", \"Venus\",\
    \ \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n   \
    \     val planets = planets.toSet\n        val planet1 = planets(planets.indexOf(planet1))\n\
    \        val planet2 = planets(planets.indexOf(planet2))\n        val sun = Orbits(0.0,\
    \ 0.0, 0.0)\n        val orbit = Orbits(planet1.ra(), planet1.dec(), sun.dec)\n\
    \        var orbits = orbit.orbits\n        var a = 0.0\n        var b = 0.0\n\
    \        var c = 0.0\n        var d = 0.0\n        var x = 0.0\n        var y\
    \ = 0.0\n        var z = 0.0\n        var d = orbits(planets.indexOf(planet1))\n\
    \        var e = 0\n        var f = orbits(planets.indexOf(planet2))\n       \
    \ while (e < orbits.size) {\n            while (f < orbits.size && orbits(f) <\
    \ d) {\n                f = f + 1\n            }\n            d = d\n        \
    \    while (a < orbits.size) {\n                while (c < orbits.size && orbits(c)\
    \ < d && orbits(a) < d) {\n                    c = c + 1\n                }\n\
    \                d = d\n                while (x < orbits.size) {\n          \
    \          while (y < orbits.size && orbits(y) < d && orbits(x) < d) {\n     \
    \                   y = y + 1\n                    }\n                    d =\
    \ d\n                    while (z < orbits.size) {\n                        while\
    \ (y < orbits.size && orbits(y) < d && orbits(z) < d) {\n                    \
    \        y = y + 1\n                        }\n                        d = d\n\
    \                        if (orbits(a) < d) {\n                            x =\
    \ x + 1\n                        }\n                        if (orbits(b) < d)\
    \ {\n                            z = z + 1\n                        }\n      \
    \                  if (orbits(c) < d) {\n                            z = z + 1\n\
    \                        }\n                        if (orbits(d) < d) {\n   \
    \                         x = x + 1\n                        }\n             \
    \           if (y >= orbits.size) {\n                            a = 0\n     \
    \                       b = 0\n                            c = 0\n           \
    \                 d = 0.0\n                            x = 0.0\n             \
    \               y = 0.0\n                            z = 0.0\n               \
    \         }\n                    }\n                }\n            }\n       \
    \     orbits = orbits.updated(e, d)\n            e = e + 1\n        }\n      \
    \  val planets = orbits.toList\n        val res = planets.filter(x => x.equals(sun.dec))\n\
    \        if (res.isEmpty) {\n            List[String]()\n        } else {\n  \
    \          res\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(bf((\"\
    Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n\
    \    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n\
    \    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"),\
    \ (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp81h4dxcs.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mplanets\e[0m = planets.toSet\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mplanets\
    \ is already defined as \e[33mvalue\e[0m \e[35mplanets\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp81h4dxcs.scala:25:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m\
    \ \e[36mplanet1\e[0m = planets(planets.indexOf(planet1))\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mplanet1\
    \ is already defined as \e[33mvalue\e[0m \e[35mplanet1\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp81h4dxcs.scala:26:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m\
    \ \e[36mplanet2\e[0m = planets(planets.indexOf(planet2))\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mplanet2\
    \ is already defined as \e[33mvalue\e[0m \e[35mplanet2\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp81h4dxcs.scala:37:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m37 |\e[0m        \e[33mvar\e[0m\
    \ \e[36md\e[0m = orbits(planets.indexOf(planet1))\n\e[31m\e[31m   |\e[0m     \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0md is already\
    \ defined as \e[33mvariable\e[0m \e[35md\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp81h4dxcs.scala:87:12 ---------------------------\e\
    [0m\e[0m\n\e[31m87 |\e[0m        \e[33mval\e[0m \e[36mplanets\e[0m = orbits.toList\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mplanets\
    \ is already defined as \e[33mvalue\e[0m \e"
  stdout: ''
  timestamp: 1660009733
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n    val planets1 =  List(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n    val planets2 = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n    \n    var planets1 = planets1\n    var planets2 = planets2\n    \n    if(planets1\
    \ == planets2) planets1 = List()\n    if(planets1 == List()) planets1 = planets2\n\
    \    if(planets2 == List()) planets2 = planets1\n    \n    if (planets1.contains(planet1)\
    \ && planets2.contains(planet2)) {\n      val a = planets1.indexWhere(x => x ==\
    \ planet1)\n      val b = planets2.indexWhere(x => x == planet2)\n      val sun\
    \ = planets1(a).distanceTo(planets2(b))\n      \n      val orbits = planets1 ++\
    \ planets2\n        .filterNot(x => x == planet1) ++ planets2 ++ planets1\n  \
    \      .filterNot(x => x == planet2)\n        .map(x => (planets1(a).distanceTo(x)\
    \ - sun, x))\n      \n      val sorted = orbits.sortBy(_._1).reverse\n      sorted.filter(!_._1\
    \ < 0)\n        .filter(!_._1 >= sun)\n        .map(x => x._2)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmptjw8w1yj.scala:57:0 ----------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmptjw8w1yj.scala:24:8\
    \ ----------------------------\e[0m\e[0m\n\e[31m24 |\e[0m    \e[33mvar\e[0m \e\
    [36mplanets1\e[0m = planets1\n\e[31m\e[31m   |\e[0m    ^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mplanets1 is already defined as \e[33mvalue\e[0m \e[35mplanets1\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmptjw8w1yj.scala:25:8 ----------------------------\e[0m\e[0m\n\e\
    [31m25 |\e[0m    \e[33mvar\e[0m \e[36mplanets2\e[0m = planets2\n\e[31m\e[31m \
    \  |\e[0m    ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mplanets2 is already\
    \ defined as \e[33mvalue\e[0m \e[35mplanets2\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmptjw8w1yj.scala:27:38\
    \ -----------------------------\e[0m\e[0m\n\e[31m27 |\e[0m    \e[33mif\e[0m(planets1\
    \ == planets2) planets1 = List()\n\e[31m\e[31m   |\e[0m                      \
    \       ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                             Reassignment\
    \ to val planets1\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmptjw8w1yj.scala:28:36\
    \ -----------------------------\e[0m\e[0m\n\e[31m28 |\e[0m    \e[33mif\e[0m(planets1\
    \ == List()) planets1 = planets2\n\e[31m\e[31m   |\e[0m                      \
    \     ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                           Reassignment\
    \ to val planets1\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmptjw8w1yj.scala:29:36\
    \ -----------------------------\e[0m\e[0m\n\e[31m29 |\e[0m    \e[33mif\e[0m(planets2\
    \ == List()) planets2 = planets1\n\e[31m\e[31m   |\e[0m                      \
    \     ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                        "
  stdout: ''
  timestamp: 1660009738
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        // your code\n        var sun : Double = 0.0\n   \
    \     var planets : List[String] = Nil\n        var planet1 : List[String] = Nil\n\
    \        var planet2 : List[String] = Nil\n        if (planet1.equals(planet2))\n\
    \        {\n            planet1 = List(\"Sun\")\n            planet2 = List(\"\
    Sun\")\n        }\n        if (planet1.contains(\"Sun\"))\n        {\n       \
    \     sun = Math.toRadians(planet1.indexOf(\"Sun\") + 1)\n            planet1\
    \ = planet1.filterNot(_.equals(\"Sun\"))\n        }\n        if (planet2.contains(\"\
    Sun\"))\n        {\n            sun = Math.toRadians(planet2.indexOf(\"Sun\")\
    \ + 1)\n            planet2 = planet2.filterNot(_.equals(\"Sun\"))\n        }\n\
    \        val distances = planet1 zip planet2 map { case (planet1, planet2) =>\n\
    \            val distance = Math.toRadians(math.pow(math.sin(planet2 - planet1),\
    \ 2))\n            distance\n        }\n        planet1 = planet1.sortBy(distance\
    \ compare sun)\n        planet2 = planet2.sortBy(distance compare sun)\n     \
    \   planets = planet1 ::: planet2\n        planets = planets.filterNot(_.equals(\"\
    Sun\"))\n        planets = planets.sorted\n        return planets\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmprhmon3u4.scala:42:68 ------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m            \e[33mval\e[0m \e[36mdistance\e[0m = Math.toRadians(math.pow(math.sin(planet2\
    \ - planet1), \e[31m2\e[0m))\n\e[31m\e[31m   |\e[0m                          \
    \                                  ^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue - is not\
    \ a member of String, but could be made available as an extension method.\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might make progress\
    \ towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmprhmon3u4.scala:45:33 ------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m        planet1 = planet1.sortBy(distance compare sun)\n\
    \e[31m\e[31m   |\e[0m                                 ^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                                 Not found: distance\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- Error: /tmp/tmprhmon3u4.scala:45:54 -----------------------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m        planet1 = planet1.sortBy(distance compare sun)\n\
    \e[31m\e[31m   |\e[0m                                                      ^\e\
    [0m\n\e[31m   |\e[0mambiguous given instances: both \e[33mobject\e[0m \e[35mByte\e\
    [0m in \e[33mobject\e[0m \e[35mOrdering\e[0m and \e[33mobject\e[0m \e[35mChar\e\
    [0m in \e[33mobject\e[0m \e[35mOrdering\e[0m match type Ordering[B] of parameter\
    \ ord of \e[33mmethod\e[0m \e[35msortBy\e[0m in \e[33mtrait\e[0m \e[35mSeqOps\e\
    [0m\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmprhmon3u4.scala:46:33 ------------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m        planet2 = planet2.sortBy(distance compare sun)\n\
    \e[31m\e[31m   |\e[0m                                 ^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                                 Not found: distance\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [3"
  stdout: ''
  timestamp: 1660009738
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        // write your code here\n        \n        val planetsBetweenSunAndPlanet1\
    \ = List(\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\", \"Neptune\")\n        val planetsBetweenSunAndPlanet2 = List(\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\")\n        var planets1 = planetsBetweenSunAndPlanet1.filter(_ ==\
    \ planet1)\n        var planets2 = planetsBetweenSunAndPlanet2.filter(_ == planet2)\n\
    \        val orbsBetweenSunAndPlanet1 = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val orbsBetweenSunAndPlanet2\
    \ = List(\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\", \"Neptune\")\n        val orbsBetweenPlanetAndPlanet1 = List(List(\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"), List(\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\", \"Neptune\"))\n        val orbsBetweenPlanetAndPlanet2\
    \ = List(List(\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\", \"Neptune\"), List(\"Mercury\", \"Venus\", \"Earth\", \"Mars\",\
    \ \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"))\n        \n        var planet1Orbs\
    \ : List[String] = List(planet1)\n        var planet2Orbs : List[String] = List(planet2)\n\
    \        val planetDistance = planet1Orbs.zip(planet2Orbs)\n        val distances\
    \ = planetDistance.filter(_._2 != 0)\n        val distanceForPlanet1 = distances.filter(_._1\
    \ == planet1).map(_._2).sum\n        val distanceForPlanet2 = distances.filter(_._1\
    \ == planet2).map(_._2).sum\n        val distanceToSun = distanceForPlanet1.map(\
    \ orb => math.pow(orb, 2) - math.pow(math.pow((orb - 1), 2) + math.pow((orb -\
    \ 2), 2), 0.5))\n        val distanceToSun2 = distanceForPlanet2.filter( orb =>\
    \ math.\n    }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"\
    ), (\"Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpyqdda7gn.scala:40:4 ----------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- Error: /tmp/tmpyqdda7gn.scala:35:46\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m35 |\e[0m       \
    \ \e[33mval\e[0m \e[36mdistances\e[0m = planetDistance.filter(_._2 != \e[31m0\e\
    [0m)\n\e[31m\e[31m   |\e[0m                                              ^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m         Values of types String and Int cannot be compared\
    \ with == or !=\n\e[31m\e[31m-- Error: /tmp/tmpyqdda7gn.scala:36:80 -----------------------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36mdistanceForPlanet1\e[0m\
    \ = distances.filter(_._1 == planet1).map(_._2).sum\n\e[31m\e[31m   |\e[0m   \
    \                                                                            \
    \ ^\e[0m\n\e[31m   |\e[0m                No implicit Ordering defined for B\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m                where:    B is a type variable with\
    \ constraint >: String\n\e[31m   |\e[0m                .\n\e[31m\e[31m-- Error:\
    \ /tmp/tmpyqdda7gn.scala:37:80 -----------------------------------------\e[0m\e\
    [0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e[36mdistanceForPlanet2\e[0m = distances.filter(_._1\
    \ == planet2).map(_._2).sum\n\e[31m\e[31m   |\e[0m                           \
    \                                                     ^\e[0m\n\e[31m   |\e[0m\
    \                No implicit Ordering defined for B\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m                where:    B is a type variable with constraint >: String\n\
    \e[31m   |\e[0m                .\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpyqdda7gn.scala:40:5\
    \ ---------------------\e[0m\e[0m\n\e[31m40 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[String]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n5 errors found\n"
  stdout: ''
  timestamp: 1660009737
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        var a = 0\n        var b = 5\n        var c = 0\n\
    \        var d = 7\n        var e = 0\n        var f = 0\n        var g = 7\n\
    \        var h = 0\n        var i = 0\n        var j = 0\n        var k = 0\n\
    \        var l = 0\n        var m = 0\n        var n = 0\n        var o = 0\n\
    \        var p = 8\n        var q = 7\n        var r = 0\n        var s = 0\n\
    \        var t = 0\n        var u = 0\n        var v = 7\n        var w = 8\n\
    \        var x = 0\n        var y = 0\n        var z = 8\n        val sun = Sun()\n\
    \        var a = sun.getOrbitalDistance(planet1)\n        var b = sun.getOrbitalDistance(planet2)\n\
    \        var c = sun.getOrbitalDistance(planet2)\n        var d = sun.getOrbitalDistance(planet1)\n\
    \        var e = sun.getOrbitalDistance(planet1)\n        var f = sun.getOrbitalDistance(planet1)\n\
    \        var g = sun.getOrbitalDistance(planet2)\n        var h = sun.getOrbitalDistance(planet2)\n\
    \        var i = sun.getOrbitalDistance(planet2)\n        var j = sun.getOrbitalDistance(planet1)\n\
    \        var k = sun.getOrbitalDistance(planet1)\n        var l = sun.getOrbitalDistance(planet1)\n\
    \        var m = sun.getOrbitalDistance(planet2)\n        var n = sun.getOrbitalDistance(planet1)\n\
    \        var o = sun.getOrbitalDistance(planet1)\n        var p = sun.getOrbitalDistance(planet2)\n\
    \        var q = sun.getOrbitalDistance(planet2)\n        var r = sun.getOrbitalDistance(planet1)\n\
    \        var s = sun.getOrbitalDistance(planet1)\n        var t = sun.getOrbitalDistance(planet1)\n\
    \        var u = sun.getOrbitalDistance(planet1)\n        var v = sun.getOrbitalDistance(planet1)\n\
    \        var w = sun.getOrbitalDistance(planet1)\n        var x = sun.getOrbitalDistance(planet1)\n\
    \        var y = sun.getOrbitalDistance(planet1)\n        var z = sun.getOrbitalDistance(planet1)\n\
    \        if (planet1 == planet2) {\n            return (List(\"Mercury\", \"Saturn\"\
    , \"Uranus\", \"Neptune\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Venus\"\
    ))\n        }\n        val planets = List(\"Mercury\", \"Saturn\", \"Uranus\"\
    , \"Neptun\n    }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"\
    ), (\"Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpry1jdlre.scala:77:58 -----------------------------------------\e\
    [0m\e[0m\n\e[31m77 |\e[0m        \e[33mval\e[0m \e[36mplanets\e[0m = List(\e[31m\"\
    Mercury\"\e[0m, \e[31m\"Saturn\"\e[0m, \e[31m\"Uranus\"\e[0m, \"Neptun\n\e[31m\e\
    [31m   |\e[0m                                                          ^\e[0m\n\
    \e[31m   |\e[0m                                                 unclosed string\
    \ literal\n\e[31m\e[31m-- Error: /tmp/tmpry1jdlre.scala:79:34 -----------------------------------------\e\
    [0m\e[0m\n\e[31m79 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[31m\e[31m   |\e[0m                \
    \                  ^\e[0m\n\e[31m   |\e[0m                                 end\
    \ of statement expected but '=' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpry1jdlre.scala:48:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m48 |\e[0m        \e[33mvar\e[0m\
    \ \e[36ma\e[0m = sun.getOrbitalDistance(planet1)\n\e[31m\e[31m   |\e[0m      \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0ma is already defined\
    \ as \e[33mvariable\e[0m \e[35ma\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpry1jdlre.scala:49:12 ---------------------------\e\
    [0m\e[0m\n\e[31m49 |\e[0m        \e[33mvar\e[0m \e[36mb\e[0m = sun.getOrbitalDistance(planet2)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mb is already defined as \e[33mvariable\e[0m \e[35mb\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpry1jdlre.scala:50:12 ---------------------------\e[0m\e[0m\n\e[31m50\
    \ |\e[0m        \e[33mvar\e[0m \e[36mc\e[0m = sun.getOrbitalDistance(planet2)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mc is already defined as \e[33mvariable\e[0m \e[35mc\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Na"
  stdout: ''
  timestamp: 1660009735
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planet1Orbit = orbit(planet1)\n        val planet2Orbit\
    \ = orbit(planet2)\n        val planetList = List(planet1, planet2)\n        val\
    \ planetList = planetList.map(planet => (planet, planetOrbit(planet)))\n     \
    \   val planetList1 = planetList.filter(_._1 == \"Earth\")\n        val planetList2\
    \ = planetList.filter(_._1 == \"Mercury\")\n        val planetList3 = planetList.filter(_._1\
    \ == \"Venus\")\n        val planetList4 = planetList.filter(_._1 == \"Mars\"\
    )\n        val planetList5 = planetList.filter(_._1 == \"Jupiter\")\n        val\
    \ planetList6 = planetList.filter(_._1 == \"Saturn\")\n        val planetList7\
    \ = planetList.filter(_._1 == \"Uranus\")\n        val planetList8 = planetList.filter(_._1\
    \ == \"Neptune\")\n        val planetList9 = planetList.filterNot(_._1 == \"Earth\"\
    )\n        val planetList10 = planetList.filterNot(_._1 == \"Mercury\")\n    \
    \    val planetList11 = planetList.filterNot(_._1 == \"Venus\")\n        val planetList12\
    \ = planetList.filterNot(_._1 == \"Mars\")\n        val planetList13 = planetList.filterNot(_._1\
    \ == \"Jupiter\")\n        val planetList14 = planetList.filterNot(_._1 == \"\
    Saturn\")\n        val planetList15 = planetList.filterNot(_._1 == \"Uranus\"\
    )\n        val planetList16 = planetList.filterNot(_._1 == \"Neptune\")\n\n  \
    \      val orbit1 = planet1Orbit.zip(planetList1).map{case (planet, orbit) =>\
    \ (planet, orbit)}.sortBy(_._2).map(_._1)\n        val orbit2 = planet2Orbit.zip(planetList2).map{case\
    \ (planet, orbit) => (planet, orbit)}.sortBy(_._2).map(_._1)\n        val orbit3\
    \ = planetList3.zip(planetList4).map{case (planet, orbit) => (planet, orbit)}.sortBy(_._2).map(_._1)\n\
    \        val orbit4 = planetList5.zip(planetList6).map{case (planet, orbit) =>\
    \ (planet, orbit)\n    }\n    def main(args: Array[String]) = {\n    assert(bf((\"\
    Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n\
    \    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n\
    \    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"),\
    \ (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmputbey7r8.scala:58:0 ----------------------------\e\
    [0m\e[0m\n\e[31m58 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmputbey7r8.scala:24:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m\
    \ \e[36mplanetList\e[0m = planetList.map(\e[36mplanet\e[0m => (planet, planetOrbit(planet)))\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mplanetList is already defined as \e[33mvalue\e[0m \e[35mplanetList\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E006] Not\
    \ Found Error: /tmp/tmputbey7r8.scala:21:27 ------------------------\e[0m\e[0m\n\
    \e[31m21 |\e[0m        \e[33mval\e[0m \e[36mplanet1Orbit\e[0m = orbit(planet1)\n\
    \e[31m\e[31m   |\e[0m                           ^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                         Not found: orbit\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmputbey7r8.scala:22:27 ------------------------\e[0m\e\
    [0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mplanet2Orbit\e[0m = orbit(planet2)\n\
    \e[31m\e[31m   |\e[0m                           ^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                         Not found: orbit\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmputbey7r8.scala:25:46 ------------------------\e[0m\e\
    [0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mplanetList1\e[0m = planetList.filter(_._1\
    \ == \e[31m\"Earth\"\e[0m)\n\e[31m\e[31m   |\e[0m                            \
    \                ^^^^\e[0m\n\e[31m   |\e[0m                                  \
    \    value _1 is not a member of String\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmputbey7r8.scala:26:46 ------------------------\e[0m\e[0m\n\e[31m26 |\e\
    [0m        \e[33mval\e[0m \e[36mplanetList2\e[0m = planetList.filter(_._1 == \e\
    [31m\"Mercury\"\e[0m)\n\e[31m\e[31m   |\e[0m                           "
  stdout: ''
  timestamp: 1660009741
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        // Create a list to store the planets\n        var\
    \ l : List[String] = Nil\n        val planets = List(planet1, planet2)\n     \
    \   for(planet <- planets){ // Iterate over each planet\n            // Get the\
    \ orbit for planet1 and planet2\n            val orbit1 = PlanetOrbit(planet,\
    \ planet1)\n            val orbit2 = PlanetOrbit(planet, planet2)\n          \
    \  // Find the distance between these two orbits\n            val d = orbit1.distanceTo(orbit2)\n\
    \            // If the distance is less than or equal to 1 the add it to a new\
    \ list\n            if(d <= 1){ \n                l :: planets.filterNot(_ ==\
    \ planet).sortBy(_.distanceTo(orbit1))\n            }\n        }\n        // Return\
    \ an empty list if neither of planets were valid\n        l match {\n        \
    \    case Nil => Nil\n            case _ => l\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp5v3fl0vo.scala:26:25 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m            \e[33mval\e[0m \e[36morbit1\e[0m = PlanetOrbit(planet,\
    \ planet1)\n\e[31m\e[31m   |\e[0m                         ^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                         Not found: PlanetOrbit\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmp5v3fl0vo.scala:27:25 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m            \e[33mval\e[0m \e[36morbit2\e[0m = PlanetOrbit(planet,\
    \ planet2)\n\e[31m\e[31m   |\e[0m                         ^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                         Not found: PlanetOrbit\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmp5v3fl0vo.scala:32:61 ------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m                l :: planets.filterNot(_ == planet).sortBy(_.distanceTo(orbit1))\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \   ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                              value distanceTo\
    \ is not a member of String\n\e[31m\e[31m-- Error: /tmp/tmp5v3fl0vo.scala:32:80\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m32 |\e[0m       \
    \         l :: planets.filterNot(_ == planet).sortBy(_.distanceTo(orbit1))\n\e\
    [31m\e[31m   |\e[0m                                                          \
    \                      ^\e[0m\n\e[31m   |\e[0mambiguous given instances: both\
    \ \e[33mobject\e[0m \e[35mByte\e[0m in \e[33mobject\e[0m \e[35mOrdering\e[0m and\
    \ \e[33mobject\e[0m \e[35mChar\e[0m in \e[33mobject\e[0m \e[35mOrdering\e[0m match\
    \ type Ordering[B] of parameter ord of \e[33mmethod\e[0m \e[35msortBy\e[0m in\
    \ \e[33mtrait\e[0m \e[35mSeqOps\e[0m\n4 errors found\n"
  stdout: ''
  timestamp: 1660009738
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(planet1, planet2)\n        val\
    \ planetList = planets.sorted\n        val Sun = orbit(planetList(0), planets(1))\n\
    \        val Mercury = orbit(planets(0), planets(2))\n        val Venus = orbit(planets(0),\
    \ planets(3))\n        val Earth = orbit(planets(0), planets(4))\n        val\
    \ Mars = orbit(planets(0), planets(5))\n        val Jupiter = orbit(planets(0),\
    \ planets(6))\n        val Saturn = orbit(planets(0), planets(7))\n        val\
    \ Uranus = orbit(planets(0), planets(8))\n        val Neptune = orbit(planets(1),\
    \ planets(2))\n        val MercuryToSun = Venus - Sun\n        val VenusToSun\
    \ = Earth.distance - Sun\n        val EarthToSun = Mars.distance - Sun\n     \
    \   val MarsToSun = Jupiter.distance - Sun\n        val JupiterToSun = Saturn.distance\
    \ - Sun\n        val SaturnToSun = Uranus.distance - Sun\n        val UranusToSun\
    \ = Neptune.distance - Sun\n        val VenusToMercury = Earth.distance - Mercury\n\
    \        val EarthToMercury = Mars.distance - Mercury\n        val MarsToMercury\
    \ = Jupiter.distance - Mercury\n        val JupiterToMercury = Saturn.distance\
    \ - Mercury\n        val SaturnToMercury = Uranus.distance - Mercury\n       \
    \ val UranusToMercury = Neptune.distance - Mercury\n        val VenusToEarth =\
    \ Earth.distance - Earth\n        val EarthToEarth = Mars.distance - Earth\n \
    \       val MarsToEarth = Jupiter.distance - Earth\n        val JupiterToEarth\
    \ = Saturn.distance - Earth\n        val SaturnToEarth = Uranus.distance - Earth\n\
    \        val UranusToEarth = Neptune.distance - Earth\n        val VenusToMars\
    \ = Earth.distance - Mars\n        val EarthToMars = Mars.distance - Mars\n  \
    \      val MarsToMars = Jupiter.distance - Mars\n        val JupiterToMars = Saturn.distance\
    \ - Mars\n        val SaturnToMars = Uran\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmppgk0il7z.scala:23:18 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mSun\e[0m = orbit(planetList(\e\
    [31m0\e[0m), planets(\e[31m1\e[0m))\n\e[31m\e[31m   |\e[0m                  ^^^^^\e\
    [0m\n\e[31m   |\e[0m                  Not found: orbit\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmppgk0il7z.scala:24:22 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mMercury\e[0m = orbit(planets(\e\
    [31m0\e[0m), planets(\e[31m2\e[0m))\n\e[31m\e[31m   |\e[0m                   \
    \   ^^^^^\e[0m\n\e[31m   |\e[0m                      Not found: orbit\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmppgk0il7z.scala:25:20 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mVenus\e[0m = orbit(planets(\e\
    [31m0\e[0m), planets(\e[31m3\e[0m))\n\e[31m\e[31m   |\e[0m                   \
    \ ^^^^^\e[0m\n\e[31m   |\e[0m                    Not found: orbit\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmppgk0il7z.scala:26:20 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mEarth\e[0m = orbit(planets(\e\
    [31m0\e[0m), planets(\e[31m4\e[0m))\n\e[31m\e[31m   |\e[0m                   \
    \ ^^^^^\e[0m\n\e[31m   |\e[0m                    Not found: orbit\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmppgk0il7z.scala:27:19 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mMars\e[0m = orbit(planets(\e\
    [31m0\e[0m), planets(\e[31m5\e[0m))\n\e[31m\e[31m   |\e[0m                   ^^^^^\e\
    [0m\n\e[31m   |\e[0m                   Not found: orbit\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmppgk0il7z.scala:28:22 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval"
  stdout: ''
  timestamp: 1660009743
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        var planetsToReturn = List[String]()\n        var\
    \ firstPlanet : String = planet1\n        var secondPlanet : String = planet2\n\
    \n        var firstPlanetOrbit = scala.math.Orbit(firstPlanet)\n        var secondPlanetOrbit\
    \ = scala.math.Orbit(secondPlanet)\n\n        var firstPlanetOrbitOrbit = scala.math.Orbit.orbit(firstPlanetOrbit)\n\
    \        var secondPlanetOrbitOrbit = scala.math.Orbit.orbit(secondPlanetOrbit)\n\
    \n        // The loop checks if the first planet is between the orbits of \n \
    \       // the other two planets\n        while(firstPlanetOrbitOrbit != secondPlanetOrbitOrbit)\
    \ {\n            if(firstPlanetOrbitOrbit > secondPlanetOrbitOrbit) {\n      \
    \          firstPlanetOrbit = scala.math.Orbit(firstPlanet)\n                firstPlanetOrbitOrbit\
    \ = scala.math.Orbit.orbit(firstPlanetOrbit)\n            } else {\n         \
    \       secondPlanetOrbit = scala.math.Orbit(secondPlanet)\n                secondPlanetOrbitOrbit\
    \ = scala.math.Orbit.orbit(secondPlanetOrbit)\n            }\n        }\n    \
    \    // The loop checks if the second planet is between the orbits of \n     \
    \   // the first two planets\n        while(secondPlanetOrbitOrbit != firstPlanetOrbitOrbit)\
    \ {\n            if(secondPlanetOrbitOrbit > firstPlanetOrbitOrbit) {\n      \
    \          secondPlanetOrbit = scala.math.Orbit(secondPlanet)\n              \
    \  secondPlanetOrbitOrbit = scala.math.Orbit.orbit(secondPlanetOrbit)\n      \
    \      } else {\n                firstPlanetOrbit = scala.math.Orbit(firstPlanet)\n\
    \                firstPlanetOrbitOrbit = scala.math.Orbit.orbit(firstPlanetOrbit)\n\
    \            }\n        }\n        planetsToReturn = List(firstPlanet, secondPlanet)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"\
    Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpareid0fp.scala:25:42 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mvar\e[0m \e[36mfirstPlanetOrbit\e[0m =\
    \ scala.math.Orbit(firstPlanet)\n\e[31m\e[31m   |\e[0m                       \
    \        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                              \
    \ value Orbit is not a member of math\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpareid0fp.scala:26:43 ------------------------\e[0m\e[0m\n\e[31m26 |\e\
    [0m        \e[33mvar\e[0m \e[36msecondPlanetOrbit\e[0m = scala.math.Orbit(secondPlanet)\n\
    \e[31m\e[31m   |\e[0m                                ^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                                value Orbit is not a member of math\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpareid0fp.scala:28:47 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mvar\e[0m \e[36mfirstPlanetOrbitOrbit\e\
    [0m = scala.math.Orbit.orbit(firstPlanetOrbit)\n\e[31m\e[31m   |\e[0m        \
    \                            ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \                          value Orbit is not a member of math\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpareid0fp.scala:29:48 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mvar\e[0m \e[36msecondPlanetOrbitOrbit\e\
    [0m = scala.math.Orbit.orbit(secondPlanetOrbit)\n\e[31m\e[31m   |\e[0m       \
    \                              ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        \
    \                             value Orbit is not a member of math\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpareid0fp.scala:35:46 ------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m                firstPlanetOrbit = scala.math.Orbit(firstPlanet)\n\
    \e[31m\e[31m   |\e[0m                                   ^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                   value Orbit is not a member\
    \ of math\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpareid0fp.scala:36:51\
    \ ------------------------\e[0m\e[0m\n\e[31m36 |\e[0m                firstPlanetOrbitOrbit\
    \ = scala.math.Orbit.orbit(firstPlanetOrbit)\n\e[31m\e[31m   |\e[0m          \
    \                              ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    "
  stdout: ''
  timestamp: 1660009744
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        if (planet1 == null || planet2 == null || planet1.length\
    \ < 1 || planet2.length < 1) {\n            return Nil\n        }\n        val\
    \ orbit1 = Orbital(planet1)\n        val orbit2 = Orbital(planet2)\n        val\
    \ orbits = List(orbit1, orbit2)\n        val sun = Orbital(\"Sun\")\n        val\
    \ orbitsBetween = orbits.filter( orb => \n            orb.orbitalOrbit(sun) <\
    \ orb.orbitalOrbit(sun))\n        val closest = orbitsBetween.sortBy(orb => orb.orbitalOrbit(sun))(0)\n\
    \        val proximity = closest.orbitalOrbit(sun)\n        val allPlanets = orbits.filter(\
    \ orb => \n            orb.orbitalOrbit(sun) < orb.orbitalOrbit(sun) && \n   \
    \         orb.orbitalOrbit(sun) > proximity)\n        val sortFunction = (planet1,\
    \ planet2) => \n            allPlanets.map( orb => \n                orb.name.toString.compare(planet1.toString)\
    \ > 0 && \n                orb.name.toString.compare(planet2.toString) > 0).sum\n\
    \        val proximityOrganiser = sortFunction\n        val sortFunction2: (Int,\
    \ String) => Int = \n            (proximityOrganiser, planet1) => \n         \
    \   allPlanets.map( orb => \n                orb.name.toString.compare(planet1.toString)\
    \ > 0).sum\n        val proximityOrganiser2 = sortFunction2\n        val proximityOrganiser3\
    \ = sortFunction2\n        val sortFunction3: (Int, String) => Int = \n      \
    \      (proximityOrganiser3, planet2) => \n            allPlanets.map( orb =>\
    \ \n                orb.name.toString.compare(planet2.toString) > 0).sum\n   \
    \     val proximityOrganiser4 = sortFunction3\n        val sortFunction4 = (proximityOrganiser4,\
    \ planet2) => \n            allPlanets.map( orb => \n                orb.name.toString.compare(planet2.toString)\
    \ < 0).sum\n        val proximityOrganiser5 = sortFunction4\n        val sortFunction5:\
    \ (Int, String) => Int = \n            (proximityOrganiser5, planet1) => \n  \
    \          allPlanets.map( orb => \n                orb.name.toString.compare(planet1.toString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"\
    Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpo6n5vlue.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpo6n5vlue.scala:24:21\
    \ ------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e\
    [36morbit1\e[0m = Orbital(planet1)\n\e[31m\e[31m   |\e[0m                    \
    \ ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found: Orbital\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpo6n5vlue.scala:25:21 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36morbit2\e[0m = Orbital(planet2)\n\
    \e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \               Not found: Orbital\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpo6n5vlue.scala:27:18 ------------------------\e[0m\e[0m\n\e[31m27 |\e\
    [0m        \e[33mval\e[0m \e[36msun\e[0m = Orbital(\e[31m\"Sun\"\e[0m)\n\e[31m\e\
    [31m   |\e[0m                  ^^^^^^^\e[0m\n\e[31m   |\e[0m                 \
    \ Not found: Orbital\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpo6n5vlue.scala:29:16\
    \ ------------------------\e[0m\e[0m\n\e[31m29 |\e[0m            orb.orbitalOrbit(sun)\
    \ < orb.orbitalOrbit(sun))\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m            value orbitalOrbit is not a member of Nothing\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpo6n5vlue.scala:30:54 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mclosest\e[0m = orbitsBetween.sortBy(\e\
    [36morb\e[0m => orb.orbitalOrbit(sun))(\e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \                                                ^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                           value orbitalOrbit is not a member of Nothing\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpo6n5vlue.scala:30:73 -----------------"
  stdout: ''
  timestamp: 1660009746
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val orb = SolarSystem.getOrbits(planet1, planet2)\n\
    \        // If there are no orbits between the two planets return an empty list\n\
    \        if (orb.isEmpty) {\n            List()\n        } else {\n          \
    \  val sun = SolarSystem.getSun()\n            val nplanets = SolarSystem.getPlanets()\n\
    \            // sort the orbits\n            val sortedOrb = orb.sortWith(x =>\
    \ Math.abs(x - sun))\n            // the orbit of the smaller planet will be before\
    \ or equal to the \n            // orbit of the larger planet\n            val\
    \ comp = x => x == sun\n            val result = sortedOrb.foldLeft((List[String](),\
    \ sun)) { (acc, curr) =>\n                if (comp(curr)) (acc :+ nplanets.find(x\
    \ => x == curr).toString)\n                else {\n                    if (nplanets.contains(curr))\
    \ (acc :+ nplanets.find(x => x == curr).toString)\n                    else (acc\
    \ :+ curr)\n                }\n            }\n            result match {\n   \
    \             case (acc, sun) => acc\n                case (_, sun) => List()\n\
    \                case (acc, _) => acc\n            }\n        }\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp9himdw3f.scala:21:18 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36morb\e[0m = SolarSystem.getOrbits(planet1,\
    \ planet2)\n\e[31m\e[31m   |\e[0m                  ^^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                  Not found: SolarSystem\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp9himdw3f.scala:26:22 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m            \e[33mval\e[0m \e[36msun\e[0m = SolarSystem.getSun()\n\
    \e[31m\e[31m   |\e[0m                      ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \                     Not found: SolarSystem\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp9himdw3f.scala:27:27 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m            \e[33mval\e[0m \e[36mnplanets\e[0m = SolarSystem.getPlanets()\n\
    \e[31m\e[31m   |\e[0m                           ^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                           Not found: SolarSystem\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E081] Type Error: /tmp/tmp9himdw3f.scala:32:23 -----------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m            \e[33mval\e[0m \e[36mcomp\e[0m = \e[36mx\e\
    [0m => x == sun\n\e[31m\e[31m   |\e[0m                       ^\e[0m\n\e[31m  \
    \ |\e[0m                       Missing parameter type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m                       I could not infer the type of the parameter x.\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp9himdw3f.scala:41:35 ------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m                \e[33mcase\e[0m (acc, sun) => acc\n\e\
    [31m\e[31m   |\e[0m                                   ^^^\e[0m\n\e[31m   |\e[0m\
    \                                   Not found: acc\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp9himdw3f.scala:43:33 ------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m                \e[33mcase\e[0m (acc"
  stdout: ''
  timestamp: 1660009739
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        if (planet1 == planet2) {\n            return (planet1\
    \ :: Nil)\n        }\n        var orbit1 = (planet1 :: Nil)\n        var orbit2\
    \ = (planet2 :: Nil)\n        while orbit1.head != planet2 {\n            orbit1\
    \ = orbit1 :+ orbit1.head\n        }\n        while orbit2.head != planet1 {\n\
    \            orbit2 = orbit2 :+ orbit2.head\n        }\n        val dist = orbit1\
    \ diff orbit2\n        dist.map(x => orbit1 diff orbit2).sortWith(_ > _)\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp9tlxw_j6.scala:29:8 ----------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mwhile\e[0m orbit2.head != planet1 {\n\e\
    [31m\e[31m   |\e[0m        ^^^^^\e[0m\n\e[31m   |\e[0m        'do' expected, but\
    \ 'while' found\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp9tlxw_j6.scala:27:19\
    \ --------------------\e[0m\e[0m\n\e[31m27 |\e[0m            orbit1 = orbit1 :+\
    \ orbit1.head\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m            Found:    Unit\n\e[31m   |\e[0m            Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp9tlxw_j6.scala:33:8\
    \ -------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        dist.map(\e[36mx\e\
    [0m => orbit1 diff orbit2).sortWith(_ > _)\n\e[31m\e[31m   |\e[0m        ^^^^\e\
    [0m\n\e[31m   |\e[0m        Not found: dist\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[33m\e[33m--\
    \ [E129] Potential Issue Warning: /tmp/tmp9tlxw_j6.scala:33:0 -----------------\e\
    [0m\e[0m\n\e[33m31 |\e[0m        }\n\e[33m32 |\e[0m        \e[33mval\e[0m dist\
    \ = orbit1 diff orbit2\n\e[33m\e[33m   |\e[0m         ^\e[0m\n\e[33m   |\e[0mA\
    \ pure expression does nothing in statement position; you may be omitting necessary\
    \ parentheses\n\e[33m   |\e[0m\n\e[33m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 warning found\n3 errors found\n"
  stdout: ''
  timestamp: 1660009743
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val orbit1 = orbit(planet1)\n        val orbit2 =\
    \ orbit(planet2)\n        val planetsInOrbit1 = orbit1.filter { case (planet,\
    \ _) => orbit2.contains(planet) }\n        val planetsInOrbit2 = orbit2.filter\
    \ { case (planet, _) => orbit1.contains(planet) }\n        val planetsInOrbit\
    \ = planetsInOrbit1.union(planetsInOrbit2)\n        planetsInOrbit.sort { case\
    \ (planet1, planet2) => distance(planet1, planet2) }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpsz72lt5k.scala:21:21 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36morbit1\e[0m = orbit(planet1)\n\
    \e[31m\e[31m   |\e[0m                     ^^^^^\e[0m\n\e[31m   |\e[0m        \
    \             Not found: orbit\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpsz72lt5k.scala:22:21 ------------------------\e[0m\e[0m\n\e[31m22 |\e\
    [0m        \e[33mval\e[0m \e[36morbit2\e[0m = orbit(planet2)\n\e[31m\e[31m   |\e\
    [0m                     ^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ orbit\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660009739
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val distances\
    \ = List(4.844018e3, 4.349065e3, 4.230013e3, 3.861618e3, 3.620746e3, 3.441059e3,\
    \ 3.191355e3, 3.001407e3, 2.716878e3)\n        val sunDistance = 5.748772e3\n\
    \        \n        val result = planets.filter(planet => planets.contains(planet)\
    \ && planets.contains(planet2)).map(planet => (planet, distances.zip(planets).map(planetDistance\
    \ => math.min(planetDistance._1, planetDistance._2)-sunDistance)))\n         \
    \   .sortBy(distance => distance)\n            .filter(distance => distance >\
    \ 0)\n        \n        if (result.isEmpty) {\n            Nil\n        } else\
    \ {\n            result.toList\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpin1u_9rn.scala:25:174 ----------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = planets.filter(\e\
    [36mplanet\e[0m => planets.contains(planet) && planets.contains(planet2)).map(\e\
    [36mplanet\e[0m => (planet, distances.zip(planets).map(\e[36mplanetDistance\e\
    [0m => math.min(planetDistance._1, planetDistance._2)-sunDistance)))\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \                                                                            \
    \                             ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded\
    \ alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e\
    [0m with types\n\e[31m   |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m\
    \ (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m\
    \   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch arguments ((planetDistance._1\
    \ : => Double), (planetDistance._2 : => String))\n\e[31m\e[31m-- Error: /tmp/tmpin1u_9rn.scala:26:41\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m26 |\e[0m       \
    \     .sortBy(distance => distance)\n\e[31m\e[31m   |\e[0m                   \
    \                      ^\e[0m\n\e[31m   |\e[0mNo implicit Ordering defined for\
    \ (String, List[Nothing])..\n\e[31m   |\e[0mI found:\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m    scala.math.Ordering.Tuple2[\e[35mString\e[0m, \e[35mList[Nothing]\e\
    [0m](scala.math.Ordering.String, \n\e[31m   |\e[0m      scala.math.Ordering.comparatorToOrdering[\e\
    [35mList[Nothing]\e[0m](\n\e[31m   |\e[0m        /* missing */summon[java.util.Comparator[List[Nothing]]]\n\
    \e[31m   |\e[0m      )\n\e[31m   |\e[0m    )\n\e[31m   |\e[0m\n\e[31m   |\e[0mBut\
    \ no implicit values were found that match type java.util.Comparator[List[Nothing]].\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660009744
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val p1 = planet1.toLowerCase\n        val p2 = planet2.toLowerCase\n\
    \n        val sun = math.sqrt(Math.pow(p2.toDouble, 2) \n                    \
    \       + Math.pow(p1.toDouble, 2))\n\n        val orbit1 = p2.toDouble - p1.toDouble\n\
    \        val orbit2 = sun.toDouble - orbit1\n\n        (if (p1.toDouble < p2.toDouble)\
    \ List(planet2) else List(planet1)) \n         .filter(p=> orbit1<sun && orbit2>sun)\
    \ \n         .sortBy(p=> abs(p.toDouble - sun.toDouble)) \n         .toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"\
    Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.NumberFormatException: For input string: \"neptune\"\n\tat java.base/jdk.internal.math.FloatingDecimal.readJavaFormatString(FloatingDecimal.java:2054)\n\
    \tat java.base/jdk.internal.math.FloatingDecimal.parseDouble(FloatingDecimal.java:110)\n\
    \tat java.base/java.lang.Double.parseDouble(Double.java:651)\n\tat scala.collection.StringOps$.toDouble$extension(StringOps.scala:956)\n\
    \tat Problem$.bf(tmpei0g8qhb.scala:24)\n\tat Problem$.main(tmpei0g8qhb.scala:36)\n\
    \tat Problem.main(tmpei0g8qhb.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009745
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        // A list containing all orbits of planet1 and the\
    \ orbits of planet2\n        val allPlanets = List(planet1, planet2)\n       \
    \ val mapPlanetsToPlanets = mutable.Map[String, List[String]]()\n        allPlanets.foreach(planet\
    \ => {\n            // The map which contains all the orbits of planet and their\
    \ name\n            mapPlanetsToPlanets += (planet -> allPlanets)\n        })\n\
    \        \n        // The map which contains all planets whose orbit are located\
    \ between the \n        // orbit of planet1 and the orbit of planet2\n       \
    \ val allPlanetsInBetween = mutable.Map[String, List[String]]()\n        // A\
    \ Set containing all the planets which are in between \n        // the orbit of\
    \ planet1 and the orbit of planet2\n        val allPlanetsInBetweenPlanets = mutable.Set[String]()\n\
    \        // A list containing all the planets which are in between \n        //\
    \ the orbit of planet1 and the orbit of planet2\n        val planetsInBetween\
    \ = mutable.ListBuffer[String]()\n        \n        // For every planet in the\
    \ map\n        mapPlanetsToPlanets.map {\n            // Get the list of all planets\n\
    \            case(planet, allPlanets) => {\n                // For every orbit\
    \ of planet\n                allPlanets.map(planetInOrbit => {\n             \
    \       // If planet and orbit are in between planets\n                    if(planetInOrbit\
    \ == planet && planetInOrbit != planet) {\n                        // Add the\
    \ planet to the set of planets in between \n                        allPlanetsInBetweenPlanets\
    \ += planet\n                        // Add the orbit of the planet to the set\
    \ of planets \n                        planetsInBetween += planetInOrbit\n   \
    \                     // Add the planet name to the list of planets whose orbits\
    \ \n                        // are located between the orbit of planet and the\
    \ orbit of planet2\n                        allPlanetsInBetween += planet\n  \
    \                  }\n                }) \n            }\n        }\n        //\
    \ The list which contains all the planets whose orbit are located between the\
    \ \n        // orbit of planet1 and the orbit of planet2\n        planetsInBetween.distinct\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"\
    Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpuiwaxbi7.scala:23:34 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mmapPlanetsToPlanets\e[0m\
    \ = mutable.Map[\e[35mString\e[0m, \e[35mList\e[0m[\e[35mString\e[0m]]()\n\e[31m\e\
    [31m   |\e[0m                                  ^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \                                 Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpuiwaxbi7.scala:31:34 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mallPlanetsInBetween\e[0m\
    \ = mutable.Map[\e[35mString\e[0m, \e[35mList\e[0m[\e[35mString\e[0m]]()\n\e[31m\e\
    [31m   |\e[0m                                  ^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \                                 Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpuiwaxbi7.scala:34:41 ------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36mallPlanetsInBetweenPlanets\e\
    [0m = mutable.Set[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                \
    \                         ^^^^^^^\e[0m\n\e[31m   |\e[0m                      \
    \                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpuiwaxbi7.scala:37:31 ------------------------\e[0m\e\
    [0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e[36mplanetsInBetween\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                               ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                               Not found: mutable\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1660009740
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planet1 = planet1.toLowerCase()\n        val planet2\
    \ = planet2.toLowerCase()\n        val planet1orbits = List(\n            \"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\",\n            \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\")\n        val planet2orbits = List(\n            \"Mercury\", \"\
    Venus\", \"Earth\", \"Mars\",\n            \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\")\n        // We will sort the planets according to proximity to\
    \ the sun\n        // We could also sort them according to distance to the sun\
    \ \n        // But we won't do it now, just to show you how it works.\n      \
    \  val orderedPlanets1 =  planet1orbits.sortWith(\n            (planet1, planet2)\
    \ => if (planet1.toDouble() > planet2.toDouble()) 1\n            else if (planet1.toDouble()\
    \ < planet2.toDouble()) -1\n            else 0)\n        val orderedPlanets2 =\
    \ planet2orbits.sortWith(\n            (planet1, planet2) => if (planet1.toDouble()\
    \ > planet2.toDouble()) -1\n            else if (planet1.toDouble() < planet2.toDouble())\
    \ 1\n            else 0)\n        // The function should return a tuple containing\
    \ all planets whose orbits are \n        // located between the orbit of planet1\
    \ and the orbit of planet2, sorted by \n        // the proximity to the sun\n\
    \        // We need 2 iterators, the second one is for the planet2\n        //\
    \ Iterate through both iterators\n        // If the iterator's next element (planet2\
    \ name) is NOT equal\n        // to the planet1 name (planet1 name) and the iterators\
    \ elements\n        // are equal, return planet1 with that planet name\n     \
    \   // The iterators elements should be sorted by proximity to the sun\n     \
    \   // The return value should be a list of all planets whose orbits are\n   \
    \     // located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n        // the proximity to the sun\n        val iterator = orderedPlanets2.iterator\n\
    \        val iterator2 = orderedPlanets1.iterator\n        var retVal = List.empty[String]\n\
    \        while (!iterator2.hasNext && iterator.hasNext) {\n            if (iterator2.next().get.toString\
    \ != planet1.get.toString \n                && iterator2.next().get.toString ==\
    \ iterator.next().get.toString) {\n                retVal += iterator2.next().get.toString\n\
    \            }\n        }\n        if (!iterator2.hasNext && !\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp3oi5wy7i.scala:62:4 ----------------------------\e\
    [0m\e[0m\n\e[31m62 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp3oi5wy7i.scala:21:22\
    \ ---------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m\
    \ \e[36mplanet1\e[0m = planet1.toLowerCase()\n\e[31m\e[31m   |\e[0m          \
    \            ^\e[0m\n\e[31m   |\e[0m                      Recursive \e[33mvalue\e\
    [0m \e[35mplanet1\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmp3oi5wy7i.scala:22:22 ---------------------------\e[0m\e[0m\n\e[31m22\
    \ |\e[0m        \e[33mval\e[0m \e[36mplanet2\e[0m = planet2.toLowerCase()\n\e\
    [31m\e[31m   |\e[0m                      ^\e[0m\n\e[31m   |\e[0m             \
    \         Recursive \e[33mvalue\e[0m \e[35mplanet2\e[0m needs type\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E050] Type Error: /tmp/tmp3oi5wy7i.scala:33:46 -----------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m            (\e[36mplanet1\e[0m, \e[36mplanet2\e[0m)\
    \ => \e[33mif\e[0m (planet1.toDouble() > planet2.toDouble()) \e[31m1\e[0m\n\e\
    [31m\e[31m   |\e[0m                                      ^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m             \e[33mmethod\e[0m \e[35mtoDouble\e[0m in \e[33mclass\e\
    [0m \e[35mStringOps\e[0m does not take parameters\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmp3oi5wy7i.scala:33:79 --------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m            (\e[36mplanet1\e[0m, \e[36mplanet2\e[0m)\
    \ => \e[33mif\e[0m (planet1.toDouble() > planet2.toDouble()) \e[31m1\e[0m\n\e\
    [31m\e[31m   |\e[0m                                                          \
    \                     ^\e[0m\n\e[31m   |\e[0m                                \
    \                     Found:    (\e[31m1\e[0m : Int)\n\e[31m   |\e[0m        \
    \                                             Required: Boolean\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer exp"
  stdout: ''
  timestamp: 1660009744
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n      planet1 +: planet2.filter(planet => planet != planet1).map(_.toDouble).sorted.takeWhile(_\
    \ != 0).map(_.toString).toList\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\",\
    \ \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpv6jnz8vw.scala:21:42 -----------------------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m      planet1 +: planet2.filter(\e[36mplanet\e[0m =>\
    \ planet != planet1).map(_.toDouble).sorted.takeWhile(_ != \e[31m0\e[0m).map(_.toString).toList\n\
    \e[31m\e[31m   |\e[0m                                          ^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Values of types Char and String cannot be compared\
    \ with == or !=\n1 error found\n"
  stdout: ''
  timestamp: 1660009744
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        if (planet1.equalsIgnoreCase(\"Mercury\") && planet2.equalsIgnoreCase(\"\
    Earth\")) List(\"Venus\")\n        else if (planet1.equalsIgnoreCase(\"Mercury\"\
    ) && planet2.equalsIgnoreCase(\"Mars\")) List(\"Venus\", \"Earth\")\n        else\
    \ if (planet1.equalsIgnoreCase(\"Mercury\") && planet2.equalsIgnoreCase(\"Jupiter\"\
    )) List(\"Venus\", \"Earth\", \"Mars\")\n        else if (planet1.equalsIgnoreCase(\"\
    Mercury\") && planet2.equalsIgnoreCase(\"Saturn\")) List(\"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\")\n        else if (planet1.equalsIgnoreCase(\"Mercury\"\
    ) && planet2.equalsIgnoreCase(\"Uranus\")) List(\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\")\n        else if (planet1.equalsIgnoreCase(\"Mercury\"\
    ) && planet2.equalsIgnoreCase(\"Neptune\")) List(\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\")\n        else if (planet1.equalsIgnoreCase(\"\
    Venus\") && planet2.equalsIgnoreCase(\"Earth\")) List(\"Mercury\", \"Earth\")\n\
    \        else if (planet1.equalsIgnoreCase(\"Venus\") && planet2.equalsIgnoreCase(\"\
    Mars\")) List(\"Mercury\", \"Earth\", \"Mars\")\n        else if (planet1.equalsIgnoreCase(\"\
    Venus\") && planet2.equalsIgnoreCase(\"Jupiter\")) List(\"Mercury\", \"Earth\"\
    , \"Mars\", \"Jupiter\")\n        else if (planet1.equalsIgnoreCase(\"Venus\"\
    ) && planet2.equalsIgnoreCase(\"Saturn\")) List(\"Mercury\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\")\n        else if (planet1.equalsIgnoreCase(\"Venus\"\
    ) && planet2.equalsIgnoreCase(\"Uranus\")) List(\"Mercury\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\")\n        else if (planet1.equalsIgnoreCase(\"\
    Venus\") && planet2.equalsIgnoreCase(\"Neptune\")) List(\"Mercury\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        else if\
    \ (planet1.equalsIgnoreCase(\"Earth\") && planet2.equalsIgnoreCase(\"Mercury\"\
    )) List(\"Mars\", \"Jup\n    }\n    def main(args: Array[String]) = {\n    assert(bf((\"\
    Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n\
    \    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n\
    \    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"),\
    \ (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpny6qjccd.scala:33:104 ----------------------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (planet1.equalsIgnoreCase(\e\
    [31m\"Earth\"\e[0m) && planet2.equalsIgnoreCase(\e[31m\"Mercury\"\e[0m)) List(\e\
    [31m\"Mars\"\e[0m, \"Jup\n\e[31m\e[31m   |\e[0m                              \
    \                                                                          ^\e\
    [0m\n\e[31m   |\e[0m                                                 unclosed\
    \ string literal\n\e[31m\e[31m-- Error: /tmp/tmpny6qjccd.scala:35:34 -----------------------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[31m\e[31m   |\e[0m                \
    \                  ^\e[0m\n\e[31m   |\e[0m                                 end\
    \ of statement expected but '=' found\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpny6qjccd.scala:35:4 -------------------------\e[0m\e[0m\n\e[31m35 |\e\
    [0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e[35mArray\e[0m[\e[35mString\e\
    [0m]) = {\n\e[31m\e[31m   |\e[0m    ^^^\e[0m\n\e[31m   |\e[0m    Not found: Jupdef\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660009740
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val sun = Vector(0.0, 0.0, 1.0)\n        val planet\
    \ = Vector(0.0, 1.0)\n        val planets = Vector(planet1, planet2)\n       \
    \ val suns = Vector(sun)\n        val orbit = Vector(0.0, 1.0)\n\n        def\
    \ closest(planet1: String, planet2: String) : Double = { \n            // return\
    \ closest, or infinity\n            val planetVector = Vector(planet1, planet2)\n\
    \            val dist = Vector.dot(planetVector, planet) - sun\n            return\
    \ dist.mag\n        }\n\n        def nextOrbit(orbit1: Vector, orbit2: Vector)\
    \ : Vector = { \n            // returns vector containing orbit and next orbit\n\
    \            val vec = Vector(orbit1) - orbit2\n            val dist = vec.mag\n\
    \            vec.normalize\n            val next = vec + orbit2\n            next.normalize\n\
    \            (next, dist)\n        }\n\n        def proximity(planet1: String,\
    \ planet2: String) : Double = {\n            // returns distance between planets\n\
    \            val vector = Vector(planet1, planet2)\n            val dist = Vector.dot(vector,\
    \ sun) - sun\n            dist\n        }\n\n        def nextPlanet(planet1: String,\
    \ planet2: String) : String = { \n            // returns the next planet in the\
    \ list\n            // return an empty string if either planet is not in the list\n\
    \            if (planets.contains(planet1) && planets.contains(planet2)) \n  \
    \              planets.head \n            else \n                \"\"\n      \
    \  }\n\n        def orbits(planet1: String, planet2: String) : List[(Vector, Vector)]\
    \ = {\n            // returns a list of all orbits of both planets\n         \
    \   val result: List[(Vector, Vector)] = Nil\n            val closest = Vector.dot(planetVector,\
    \ planet) - sun\n            if (closest > 0.0) {\n                val nextOrbit\
    \ = nextOrbit(orbit, planetVector)\n                if (nextOrbit.mag > 0.0) {\n\
    \                    val nextPlanet = nextPlanet(planet1, planet2)\n         \
    \           val distance = proximity(planet1, planet2)\n                    val\
    \ nextOrbitDist = proximity(planet1, nextPlanet)\n                    val nextPlanetDist\
    \ = proximity(nextPlanet, planet2)\n                    val nextOrbitDist = proximity(nextPlanet,\
    \ nextPlanet)\n                    val nextPlanetDist = proximity(planet2, planet1)\n\
    \                    if (distance < nextOrbitDist) \n                        result\
    \ += ((orbit, nextOrbit))\n\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\", \"\
    Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp9gxfkczo.scala:88:0 ----------------------------\e\
    [0m\e[0m\n\e[31m88 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp9gxfkczo.scala:30:30\
    \ ------------------------\e[0m\e[0m\n\e[31m30 |\e[0m            \e[33mval\e[0m\
    \ \e[36mdist\e[0m = Vector.dot(planetVector, planet) - sun\n\e[31m\e[31m   |\e\
    [0m                       ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m   value dot is not\
    \ a member of object scala.collection.immutable.Vector\n\e[31m\e[31m-- [E056]\
    \ Syntax Error: /tmp/tmp9gxfkczo.scala:34:30 ---------------------------\e[0m\e\
    [0m\n\e[31m34 |\e[0m        \e[33mdef\e[0m \e[36mnextOrbit\e[0m(\e[36morbit1\e\
    [0m: \e[35mVector\e[0m, \e[36morbit2\e[0m: \e[35mVector\e[0m) : \e[35mVector\e\
    [0m = { \n\e[31m\e[31m   |\e[0m                              ^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                              Missing type parameter for Vector\n\e\
    [31m\e[31m-- [E056] Syntax Error: /tmp/tmp9gxfkczo.scala:34:46 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mdef\e[0m \e[36mnextOrbit\e[0m(\e[36morbit1\e\
    [0m: \e[35mVector\e[0m, \e[36morbit2\e[0m: \e[35mVector\e[0m) : \e[35mVector\e\
    [0m = { \n\e[31m\e[31m   |\e[0m                                              ^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                       Missing type parameter\
    \ for Vector\n\e[31m\e[31m-- [E056] Syntax Error: /tmp/tmp9gxfkczo.scala:34:56\
    \ ---------------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mdef\e[0m\
    \ \e[36mnextOrbit\e[0m(\e[36morbit1\e[0m: \e[35mVector\e[0m, \e[36morbit2\e[0m:\
    \ \e[35mVector\e[0m) : \e[35mVector\e[0m = { \n\e[31m\e[31m   |\e[0m         \
    \                                               ^^^^^^\e[0m\n\e[31m   |\e[0m \
    \                                      Missing type parameter for Vector\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp9gxfkczo.scala:36:37 ------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m            \e[33mval\e[0m \e[36mvec\e[0m = Vector(orbit1)\
    \ - orbit2\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mvalue - is not a member of Vector[Nothing], but could be made available\
    \ as an extension m"
  stdout: ''
  timestamp: 1660009747
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planetList = List(\"Mercury\",\"Venus\",\"Earth\"\
    ,\"Mars\",\"Jupiter\",\"Saturn\",\"Uranus\",\"Neptune\")\n        // The function\
    \ should return the planets whose orbits are located between the \n        //\
    \ orbit of planet1 and the orbit of planet2, sorted by the proximity to \n   \
    \     // the sun. The proximity is given by calculating the distance between the\
    \ \n        // position of the planets relative to the Sun.\n        val planet1Orbits\
    \ = planetList.filter(planet1 => planetList.contains(planet1))\n        val planet2Orbits\
    \ = planetList.filter(planet2 => planetList.contains(planet2))\n\n        val\
    \ orbits1 = planet1Orbits.map(planet => (planet, planetList.indexOf(planet))).toList\n\
    \        val orbits2 = planet2Orbits.map(planet => (planet, planetList.indexOf(planet))).toList\n\
    \n        val orbits = orbits1.union(orbits2).sortBy(planet => (planet._2 - planet._1))\
    \ \n\n        if (planet1 != planet2) orbits\n        else List()\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpa0a9bdlt.scala:32:72 -----------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36morbits\e[0m = orbits1.union(orbits2).sortBy(\e\
    [36mplanet\e[0m => (planet._2 - planet._1)) \n\e[31m\e[31m   |\e[0m          \
    \                                                    ^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m None of the overloaded alternatives of \e[33mmethod\e[0m \e[35m-\e\
    [0m in \e[33mclass\e[0m \e[35mInt\e[0m with types\n\e[31m   |\e[0m  (x: Double):\
    \ Double\n\e[31m   |\e[0m  (x: Float): Float\n\e[31m   |\e[0m  (x: Long): Long\n\
    \e[31m   |\e[0m  (x: Int): Int\n\e[31m   |\e[0m  (x: Char): Int\n\e[31m   |\e\
    [0m  (x: Short): Int\n\e[31m   |\e[0m  (x: Byte): Int\n\e[31m   |\e[0m match arguments\
    \ ((planet._1 : => String))\n\e[31m\e[31m-- Error: /tmp/tmpa0a9bdlt.scala:32:85\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m32 |\e[0m       \
    \ \e[33mval\e[0m \e[36morbits\e[0m = orbits1.union(orbits2).sortBy(\e[36mplanet\e\
    [0m => (planet._2 - planet._1)) \n\e[31m\e[31m   |\e[0m                      \
    \                                                               ^\e[0m\n\e[31m\
    \   |\e[0mambiguous given instances: both \e[33mobject\e[0m \e[35mByte\e[0m in\
    \ \e[33mobject\e[0m \e[35mOrdering\e[0m and \e[33mobject\e[0m \e[35mBigInt\e[0m\
    \ in \e[33mobject\e[0m \e[35mOrdering\e[0m match type Ordering[B] of parameter\
    \ ord of \e[33mmethod\e[0m \e[35msortBy\e[0m in \e[33mtrait\e[0m \e[35mSeqOps\e\
    [0m\n2 errors found\n"
  stdout: ''
  timestamp: 1660009743
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        var planet1Orbit = Orbit(planet1).orbit.lon\n    \
    \    var planet2Orbit = Orbit(planet2).orbit.lon\n        var planet1OrbitSun\
    \ = Orbit(\"Sun\").orbit.lon\n        var planet2OrbitSun = Orbit(\"Sun\").orbit.lon\n\
    \        var result = List[String]()\n        while(planet1Orbit < planet2Orbit)\
    \ {\n            val distance = planet1OrbitSun - planet2OrbitSun\n          \
    \  val closest = math.min(distance, planet1Orbit, planet2Orbit)\n            planet1OrbitSun\
    \ = closest\n            planet2OrbitSun = closest\n            result += List(Orbit(planet1).name)\n\
    \            planet1Orbit += 1\n            planet2Orbit += 1\n        }\n   \
    \     result :+ Orbit(planet1).name\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpnmymwo6s.scala:21:27 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mvar\e[0m \e[36mplanet1Orbit\e[0m = Orbit(planet1).orbit.lon\n\
    \e[31m\e[31m   |\e[0m                           ^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                         Not found: Orbit\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpnmymwo6s.scala:22:27 ------------------------\e[0m\e\
    [0m\n\e[31m22 |\e[0m        \e[33mvar\e[0m \e[36mplanet2Orbit\e[0m = Orbit(planet2).orbit.lon\n\
    \e[31m\e[31m   |\e[0m                           ^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                         Not found: Orbit\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpnmymwo6s.scala:23:30 ------------------------\e[0m\e\
    [0m\n\e[31m23 |\e[0m        \e[33mvar\e[0m \e[36mplanet1OrbitSun\e[0m = Orbit(\e\
    [31m\"Sun\"\e[0m).orbit.lon\n\e[31m\e[31m   |\e[0m                           \
    \   ^^^^^\e[0m\n\e[31m   |\e[0m                              Not found: Orbit\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpnmymwo6s.scala:24:30\
    \ ------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mvar\e[0m \e\
    [36mplanet2OrbitSun\e[0m = Orbit(\e[31m\"Sun\"\e[0m).orbit.lon\n\e[31m\e[31m \
    \  |\e[0m                              ^^^^^\e[0m\n\e[31m   |\e[0m           \
    \                   Not found: Orbit\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpnmymwo6s.scala:31:19 ------------------------\e[0m\e\
    [0m\n\e[31m31 |\e[0m            result += List(Orbit(planet1).name)\n\e[31m\e\
    [31m   |\e[0m            ^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue += is not a member\
    \ of List[String] - did you mean List[String].!=?\n\e[31m\e[31m-- [E006] Not Found\
    \ Error: /tmp/tmpnmymwo6s.scala:31:27 ------------------------\e[0m\e[0m\n\e[31m31\
    \ |\e[0m            result += List(Orbit(planet1).name)\n\e[31m\e[31m   |\e[0m\
    \                    "
  stdout: ''
  timestamp: 1660009745
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        var planets1= Set(planet1, planet2)\n        var planets2=\
    \ Set(planet2)\n        var planets3= Set(planet2)\n        var planets4= Set(planet2)\n\
    \        var planets5= Set(planet2)\n        var planets6= Set(planet2)\n    \
    \    var planets7= Set(planet2)\n        var planets8= Set(planet2)\n        var\
    \ planets9= Set(planet2)\n        for(planet <- planets1) {\n            val r\
    \ = sun(planet)\n            for(planet2 <- planets2) {\n                if(planet\
    \ == planet2) {\n                    continue\n                }\n           \
    \     val r = sun(planet2)\n                val distance = distance(r, r)\n  \
    \              val radius = distance\n                val angle = (r.toRadians\
    \ - r2.toRadians) * (180 / Math.PI)\n                if (Math.abs(angle) < 1)\
    \ {\n                    if (angle > 1) {\n                        planets7 =\
    \ planets7 :+ planet\n                    }\n                    if(angle < 1)\
    \ {\n                        planets8 = planets8 :+ planet\n                 \
    \   }\n                }\n            }\n        }\n        planets9.sortWith(\
    \ (x,y) => x.compareTo( y))\n        planets9.sortWith( (x,y) => x.compareTo(\
    \ y))\n        planets9.sortWith( (x,y) => x.compareTo( y))\n        planets9.sortWith(\
    \ (x,y) => x.compareTo( y))\n        planets9.sortWith( (x,y) => x.compareTo(\
    \ y))\n        planets9.sortWith( (x,y) => x.compareTo( y))\n        planets9.sortWith(\
    \ (x,y) => x.compareTo( y))\n        planets9.sortWith( (x,y) => x.compareTo(\
    \ y))\n        planets9.sortWith( (x,y) => x.compareTo( y))\n        planets9.sortWith(\
    \ (x,y) => x.compareTo( y))\n        planets9.sortWith( (x,y) => x.compareTo(\
    \ y))\n        planets9.sortWith( (x,y) => x.compareTo( y))\n        planets9.sortWith(\
    \ (x,y) => x.compareTo( y))\n        planets9.sortWith( (x,y) => x.compareTo(\
    \ y))\n        planets9.sortWith( (x,y) => x.compareTo( y))\n        planet\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"\
    Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E050] Type Error: /tmp/tmp6jw_z8lx.scala:31:20 -----------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m            \e[33mval\e[0m \e[36mr\e[0m = sun(planet)\n\
    \e[31m\e[31m   |\e[0m                    ^^^\e[0m\n\e[31m   |\e[0m           \
    \         \e[33mpackage\e[0m \e[35msun\e[0m does not take parameters\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp6jw_z8lx.scala:34:20 ------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m                    continue\n\e[31m\e[31m   |\e[0m \
    \                   ^^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ continue\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E050] Type Error: /tmp/tmp6jw_z8lx.scala:36:24\
    \ -----------------------------\e[0m\e[0m\n\e[31m36 |\e[0m                \e[33mval\e\
    [0m \e[36mr\e[0m = sun(planet2)\n\e[31m\e[31m   |\e[0m                       \
    \ ^^^\e[0m\n\e[31m   |\e[0m                        \e[33mpackage\e[0m \e[35msun\e\
    [0m does not take parameters\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmp6jw_z8lx.scala:42:44 ------------------------\e[0m\e[0m\n\e[31m42 |\e\
    [0m                        planets7 = planets7 :+ planet\n\e[31m\e[31m   |\e[0m\
    \                                   ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue :+\
    \ is not a member of scala.collection.mutable.Set[String] - did you mean scala.collection.mutable.Set[String].++?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp6jw_z8lx.scala:45:44 ------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m                        planets8 = planets8 :+ planet\n\
    \e[31m\e[31m   |\e[0m                                   ^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mvalue :+ is not a member of scala.collection.mutable.Set[String] - did\
    \ you mean scala.collection.mutable.Set[String].++?\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmp6jw_z8lx.scala:50:17 ------------------------\e[0m\e[0m\n\
    \e[31m50 |\e[0m        planets9.sortWith( (\e[36mx\e[0m,\e[36my\e[0m) => x.compareTo(\
    \ y))\n\e[31m\e[31m   "
  stdout: ''
  timestamp: 1660009750
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val dist = (planet1, planet2) match {\n          \
    \  case (planet1, planet2) => math.pow((math.pow(planet1.toDouble - sun.longitude,\
    \ 2) + math.pow(planet2.toDouble - sun.longitude, 2)), 0.5)\n        }\n     \
    \   var planetList = ListBuffer[String]()\n        for (planet <- List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )) {\n            if(dist < math.pow((math.pow(planet.toDouble - sun.longitude,\
    \ 2) + math.pow(planet2.toDouble - sun.longitude, 2)), 0.5))\n               \
    \ planetList += planet\n        }\n        planetList.sorted.toList\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpqdk7rpi0.scala:22:81 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m            \e[33mcase\e[0m (planet1, planet2) => math.pow((math.pow(planet1.toDouble\
    \ - sun.longitude, \e[31m2\e[0m) + math.pow(planet2.toDouble - sun.longitude,\
    \ \e[31m2\e[0m)), \e[31m0.5\e[0m)\n\e[31m\e[31m   |\e[0m                     \
    \                                                        ^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                                  value longitude is not a member\
    \ of sun\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpqdk7rpi0.scala:22:129\
    \ -----------------------\e[0m\e[0m\n\e[31m22 |\e[0m            \e[33mcase\e[0m\
    \ (planet1, planet2) => math.pow((math.pow(planet1.toDouble - sun.longitude, \e\
    [31m2\e[0m) + math.pow(planet2.toDouble - sun.longitude, \e[31m2\e[0m)), \e[31m0.5\e\
    [0m)\n\e[31m\e[31m   |\e[0m                                                  \
    \                                                                           ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                  value longitude is not a\
    \ member of sun\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpqdk7rpi0.scala:26:63\
    \ ------------------------\e[0m\e[0m\n\e[31m26 |\e[0m            \e[33mif\e[0m(dist\
    \ < math.pow((math.pow(planet.toDouble - sun.longitude, \e[31m2\e[0m) + math.pow(planet2.toDouble\
    \ - sun.longitude, \e[31m2\e[0m)), \e[31m0.5\e[0m))\n\e[31m\e[31m   |\e[0m   \
    \                                                        ^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                                  value longitude is not a member\
    \ of sun\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpqdk7rpi0.scala:26:111\
    \ -----------------------\e[0m\e[0m\n\e[31m26 |\e[0m            \e[33mif\e[0m(dist\
    \ < math.pow((math.pow(planet.toDouble - sun.longitude, \e[31m2\e[0m) + math.pow(planet2.toDouble\
    \ - sun.longitude, \e[31m2\e[0m)), \e[31m0.5\e[0m))\n\e[31m\e[31m   |\e[0m   \
    \                                                                            \
    \                            ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m             \
    \                     value longitude is not a member of sun\n4 errors found\n"
  stdout: ''
  timestamp: 1660009749
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        def orbit(planet : String) : List[String] = {\n  \
    \          val (x, y, z) = planet.split(' ')\n            val p = Point(x, y,\
    \ z).unit\n            val d = math.sqrt(p.x^2 + p.y^2 + p.z^2)\n            val\
    \ r = 6378.1 // earth's mean radius in km\n            val mu = math.pi/180\n\
    \            val r2 = r * r\n            val a = 6378.137\n            val b =\
    \ 6955.86\n            val c = 94.56\n            val d = a*b*c\n            val\
    \ dsqrt = math.sqrt\n            val p = Point(x, y, z).unit\n            val\
    \ x = p.x - mu*math.sin(p.y)*dsqrt\n            val y = p.y + mu*math.sin(p.x)*dsqrt\n\
    \            val z = p.z - mu*math.cos(p.x)*dsqrt\n            val r = math.sqrt(x^2\
    \ + y^2 + z^2)\n            val m = math.pi/180\n            val e = math.acos(dsqrt)\n\
    \            val i = a*b*math.sin(m*e)\n            val j = b*c*math.sin(m*e)\n\
    \            val k = c*math.sin(m*e)\n            val n = a*b*c*math.sin(m*e)\n\
    \            val phi = n*j/k\n            val theta = math.atan2(y,x)\n      \
    \      val r = math.sqrt(r^2 + phi)\n            val t = r + r2*math.sin(theta*d)\n\
    \            val phi2 = r2 + r2*math.sin(theta*d)\n            val theta2 = theta*d\n\
    \            val x = p.x + r2*math.cos(theta2*d)\n            val y = p.y + r2*math.cos(theta2*d)\n\
    \            val z = p.z + r2*math.cos(theta2*d)\n            val r = math.sqrt(x^2\
    \ + y^2 + z^2)\n            val m = math.pi/180\n            val e = math.acos(dsqrt)\n\
    \            val i = a*b*math.sin(m*e)\n            val j = b*c*math.sin(m*e)\n\
    \            val k = c*math.sin(m*e)\n            val n = a*b*c*math.sin(m*e)\n\
    \            val phi = n*j/k\n            val theta = math.atan2(y,x)\n      \
    \      val r = math.sqrt(r^2 + phi)\n            val t = r + r2*math.sin(theta*d)\n\
    \            val phi2 = r2 + r2*math.sin(theta*d)\n            val theta2 = theta*d\n\
    \            val x = p.x + r2*math.cos(theta2*d)\n            val y = p.y + r2*math.cos(theta2*d)\n\
    \            \n    }\n    def main(args: Array[String]) = {\n    assert(bf((\"\
    Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n\
    \    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n\
    \    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"),\
    \ (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpspfr985z.scala:81:0 ----------------------------\e\
    [0m\e[0m\n\e[31m81 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpspfr985z.scala:31:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m31 |\e[0m            \e[33mval\e\
    [0m \e[36md\e[0m = a*b*c\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0md is already defined as \e[33mvalue\e[0m \e[35md\e[0m\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpspfr985z.scala:33:16 ---------------------------\e[0m\e[0m\n\e[31m33\
    \ |\e[0m            \e[33mval\e[0m \e[36mp\e[0m = Point(x, y, z).unit\n\e[31m\e\
    [31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mp is\
    \ already defined as \e[33mvalue\e[0m \e[35mp\e[0m\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpspfr985z.scala:34:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m34 |\e[0m            \e[33mval\e\
    [0m \e[36mx\e[0m = p.x - mu*math.sin(p.y)*dsqrt\n\e[31m\e[31m   |\e[0m       \
    \     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mx is already defined\
    \ as \e[33mvalue\e[0m \e[35mx\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpspfr985z.scala:35:16 ---------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m            \e[33mval\e[0m \e[36my\e[0m = p.y + mu*math.sin(p.x)*dsqrt\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0my is already defined as \e[33mvalue\e[0m \e[35my\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpspfr985z.scala:36:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m36 |\e[0m            \e[33mval\e\
    [0m \e[36mz\e[0m = p.z - mu*math.cos(p.x)*dsqrt\n\e[31m\e[31m   |\e[0m       \
    \     ^"
  stdout: ''
  timestamp: 1660009751
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val orbit1 = orbit(planet1)\n        val orbit2 =\
    \ orbit(planet2)\n        if(orbit1.isEmpty) Nil\n        else if(orbit2.isEmpty)\
    \ Nil\n        else orbit1.toList.intersect(orbit2.toList).sortWith(_ < _)\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"\
    Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmprqpb6vb6.scala:21:21 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36morbit1\e[0m = orbit(planet1)\n\
    \e[31m\e[31m   |\e[0m                     ^^^^^\e[0m\n\e[31m   |\e[0m        \
    \             Not found: orbit\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmprqpb6vb6.scala:22:21 ------------------------\e[0m\e[0m\n\e[31m22 |\e\
    [0m        \e[33mval\e[0m \e[36morbit2\e[0m = orbit(planet2)\n\e[31m\e[31m   |\e\
    [0m                     ^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ orbit\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660009745
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val sun = Vector3(Vector3(0.0, 0.0, 1.0), \n     \
    \                     Vector3(0.0, 0.0, -1.0))\n        val earth = Vector3(Vector3(1.0,\
    \ 0.0, 0.0), \n                          Vector3(0.0, 1.0, 0.0))\n        val\
    \ mercury = Vector3(Vector3(0.0, 0.0, 1.0), \n                          Vector3(0.0,\
    \ 1.0, 0.0))\n        val venus = Vector3(Vector3(0.0, 0.0, -1.0), \n        \
    \                  Vector3(1.0, 0.0, 0.0))\n        val mars = Vector3(Vector3(1.0,\
    \ 0.0, 0.0), \n                          Vector3(0.0, -1.0, 0.0))\n        val\
    \ jupiter = Vector3(Vector3(0.0, 1.0, 0.0), \n                          Vector3(1.0,\
    \ 0.0, 0.0))\n        val saturn = Vector3(Vector3(0.0, -1.0, 0.0), \n       \
    \                   Vector3(1.0, 0.0, 0.0))\n        val uranus = Vector3(Vector3(1.0,\
    \ 0.0, 0.0), \n                          Vector3(0.0, 1.0, 0.0))\n        val\
    \ neptune = Vector3(Vector3(0.0, -1.0, 0.0), \n                          Vector3(1.0,\
    \ 0.0, 0.0))\n        val planets = List(earth,mercury,venus,mars,jupiter,saturn,uranus,neptune)\n\
    \        (planets.filter(x => x.name == planet1 && x.name == planet2).sortBy(x\
    \ => distance(x.location, sun)))\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\",\
    \ \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpvr6x73u5.scala:21:18 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36msun\e[0m = Vector3(Vector3(\e\
    [31m0.0\e[0m, \e[31m0.0\e[0m, \e[31m1.0\e[0m), \n\e[31m\e[31m   |\e[0m       \
    \           ^^^^^^^\e[0m\n\e[31m   |\e[0m                  Not found: Vector3\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpvr6x73u5.scala:21:26\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36msun\e[0m = Vector3(Vector3(\e[31m0.0\e[0m, \e[31m0.0\e[0m, \e[31m1.0\e[0m),\
    \ \n\e[31m\e[31m   |\e[0m                          ^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                          Not found: Vector3\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpvr6x73u5.scala:22:26 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m                          Vector3(\e[31m0.0\e[0m, \e\
    [31m0.0\e[0m, -\e[31m1.0\e[0m))\n\e[31m\e[31m   |\e[0m                       \
    \   ^^^^^^^\e[0m\n\e[31m   |\e[0m                          Not found: Vector3\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpvr6x73u5.scala:23:20\
    \ ------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e\
    [36mearth\e[0m = Vector3(Vector3(\e[31m1.0\e[0m, \e[31m0.0\e[0m, \e[31m0.0\e[0m),\
    \ \n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e[31m   |\e[0m   \
    \                 Not found: Vector3\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpvr6x73u5.scala:23:28 ------------------------\e[0m\e\
    [0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mearth\e[0m = Vector3(Vector3(\e\
    [31m1.0\e[0m, \e[31m0.0\e[0m, \e[31m0.0\e[0m), \n\e[31m\e[31m   |\e[0m       \
    \                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                          \
    \  Not found: Vector3\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:"
  stdout: ''
  timestamp: 1660009751
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        var mercury_orbit = Orbit.mercury\n        var venus_orbit\
    \ = Orbit.venus\n        var earth_orbit = Orbit.earth\n        var mars_orbit\
    \ = Orbit.mars\n        var jupiter_orbit = Orbit.jupiter\n        var saturn_orbit\
    \ = Orbit.saturn\n        var uranus_orbit = Orbit.uranus\n        var neptune_orbit\
    \ = Orbit.neptune\n        var earthOrbit_list : List[String] = List(earth_orbit)\n\
    \        var mercuryOrbit_list : List[String] = List(mercury_orbit)\n        var\
    \ venusOrbit_list : List[String] = List(venus_orbit)\n        var marsOrbit_list\
    \ : List[String] = List(mars_orbit)\n        var jupiterOrbit_list : List[String]\
    \ = List(jupiter_orbit)\n        var saturnOrbit_list : List[String] = List(saturn_orbit)\n\
    \        var uranusOrbit_list : List[String] = List(uranus_orbit)\n        var\
    \ neptuneOrbit_list : List[String] = List(neptune_orbit)\n        \n        if\
    \ (planet1 == planet2) return (List(planet1))\n        if (planet1 < planet2)\
    \ return ()\n        else if (planet1 == planet2) return (List(planet2))\n   \
    \     else {\n            val Mercury_Orbit_List : List[String] = List(mercury_orbit)\n\
    \            val Venus_Orbit_List : List[String] = List(venus_orbit)\n       \
    \     val Earth_Orbit_List : List[String] = List(earth_orbit)\n            val\
    \ Mars_Orbit_List : List[String] = List(mars_orbit)\n            val Jupiter_Orbit_List\
    \ : List[String] = List(jupiter_orbit)\n            val Saturn_Orbit_List : List[String]\
    \ = List(saturn_orbit)\n            val Uranus_Orbit_List : List[String] = List(uranus_orbit)\n\
    \            val Neptune_Orbit_List : List[String] = List(neptune_orbit)\n\n \
    \           val Mercury_Orbit_Or_Earth_Or_Jupiter_Or_Saturn_Or_Uranus_Or_Neptune_Or_Earth_Or_Uranus_Or_Neptune_Or_Earth_Or_Uranus_Or_NeptuneOr_Earth_Or_Uranus_Or_Neptune_Or_Earth_Or_Uranus_Or_Neptune_Or_Earth_Or_Uranus_Or_\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"\
    Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp4opxyt56.scala:52:4 ----------------------------\e\
    [0m\e[0m\n\e[31m52 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp4opxyt56.scala:64:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m64 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E006] Not\
    \ Found Error: /tmp/tmp4opxyt56.scala:21:28 ------------------------\e[0m\e[0m\n\
    \e[31m21 |\e[0m        \e[33mvar\e[0m \e[36mmercury_orbit\e[0m = Orbit.mercury\n\
    \e[31m\e[31m   |\e[0m                            ^^^^^\e[0m\n\e[31m   |\e[0m \
    \                           Not found: Orbit\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp4opxyt56.scala:22:26 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mvar\e[0m \e[36mvenus_orbit\e[0m = Orbit.venus\n\
    \e[31m\e[31m   |\e[0m                          ^^^^^\e[0m\n\e[31m   |\e[0m   \
    \                       Not found: Orbit\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmp4opxyt56.scala:23:26 ------------------------\e[0m\e\
    [0m\n\e[31m23 |\e[0m        \e[33mvar\e[0m \e[36mearth_orbit\e[0m = Orbit.earth\n\
    \e[31m\e[31m   |\e[0m                          ^^^^^\e[0m\n\e[31m   |\e[0m   \
    \                       Not found: Orbit\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmp4opxyt56.scala:24:25 ------------------------\e[0m\e\
    [0m\n\e[31m24 |\e[0m        \e[33mvar\e[0m \e[36mmars_orbit\e[0m = Orbit.mars\n\
    \e[31m\e[31m   |\e[0m                         ^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                     Not found: Orbit\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmp4opxyt56.scala:25:28 ------------------------\e[0m\e\
    [0m\n\e[31m25 |\e[0m        \e[33mvar\e[0m \e[36mjupiter_orbit\e[0m = Orbit.jupiter\n\
    \e[31m\e[31m   |\e[0m                     "
  stdout: ''
  timestamp: 1660009752
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        var planet3 = \"\"\n        var planet4 = \"\"\n \
    \       var planet5 = \"\"\n        var planet6 = \"\"\n        var planet7 =\
    \ \"\"\n        var planet8 = \"\"\n        val planets = List(planet1, planet2,\
    \ planet3, planet4, planet5, planet6, planet7, planet8)\n        var j = 0\n \
    \       var j1 = planets.size - 1\n        var k = 0\n        var k1 = planets.size\
    \ - 1\n        var l = 0\n        var l1 = planets.size - 1\n        while (j\
    \ != l1) {\n            if (planets.contains(planet3) && planets.contains(planet4))\
    \ {\n                planet3 += 1\n                planet4 += 1\n            }\
    \ else if (planets.contains(planet3) && planets.contains(planet5)) {\n       \
    \         planet3 += 1\n                planet5 += 1\n            } else if (planets.contains(planet3)\
    \ && planets.contains(planet6)) {\n                planet3 += 1\n            \
    \    planet6 += 1\n            } else if (planets.contains(planet4) && planets.contains(planet5))\
    \ {\n                planet4 += 1\n                planet5 += 1\n            }\
    \ else if (planets.contains(planet4) && planets.contains(planet6)) {\n       \
    \         planet4 += 1\n                planet6 += 1\n            } else if (planets.contains(planet5)\
    \ && planets.contains(planet6)) {\n                planet5 += 1\n            \
    \    planet6 += 1\n            } else if (planets.contains(planet7) && planets.contains(planet8))\
    \ {\n                planet7 += 1\n                planet8 += 1\n            }\
    \ else if (planets.contains(planet7) && planets.contains(planet8)) {\n       \
    \         planet7 += 1\n                planet8 += 1\n            } else if (planets.contains(planet7)\
    \ && planets.contains(planet8)) {\n                planet7 += 1\n            \
    \    planet8 += 1\n            } else if (planets.contains(planet8) && planets.contains(planet8))\
    \ {\n                planet8 += 1\n                planet8 += 1\n            }\
    \ else if (planets.contains(planet8) && planets.contains(planet8)) {\n       \
    \         planet8 += 1\n                planet8 += 1\n            } else if (planets.contains(planet8)\
    \ && planets.contains(planet8)) {\n                planet8 += 1\n            \
    \    planet8 += 1\n            } else {\n                j += 1\n            \
    \    j1 -= 1\n                k += 1\n                k1 -= 1\n              \
    \  l += 1\n                l1 -= 1\n            }\n        }\n        var planet11\
    \ = \"\"\n        var plan\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\", \"\
    Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp864vlblq.scala:82:4 ----------------------------\e\
    [0m\e[0m\n\e[31m82 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmp864vlblq.scala:82:5 ---------------------\e[0m\e[0m\n\e[31m82 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: List[String]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660009750
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val a = (planet1 :: planet2).zipWithIndex.toList \n\
    \        val b = (planet2 :: planet1).zipWithIndex.toList\n        val c = (planet1\
    \ :: planet2).zipWithIndex.filter{ case (x,y) => x != y }\n        val d = (planet2\
    \ :: planet1).zipWithIndex.filter{ case (x,y) => x != y }\n        val f = (planet2\
    \ :: planet1).zipWithIndex.filter{ case (x,y) => x != y }\n        val e = (planet1\
    \ :: planet2).zipWithIndex.filter{ case (x,y) => x != y }\n        val g = (planet2\
    \ :: planet1).zipWithIndex.filter{ case (x,y) => x != y }\n        val h = (planet2\
    \ :: planet1).zipWithIndex.filter{ case (x,y) => x != y }\n        val i = ((planet1\
    \ :: planet2).zipWithIndex.filter{ case (x,y) => x != y }).zipWithIndex.toList\n\
    \        val j = (planet2 :: planet1).zipWithIndex.filter{ case (x,y) => x !=\
    \ y }\n        val k = (planet1 :: planet2).zipWithIndex.filter{ case (x,y) =>\
    \ x != y }\n        val l = ((planet2 :: planet1).zipWithIndex.filter{ case (x,y)\
    \ => x != y }).zipWithIndex.toList\n        val m = (planet1 :: planet2).zipWithIndex.filter{\
    \ case (x,y) => x != y }\n        val n = (planet2 :: planet1).zipWithIndex.filter{\
    \ case (x,y) => x != y }\n        val o = (planet1 :: planet2).zipWithIndex.filter{\
    \ case (x,y) => x != y }\n        val p = (planet2 :: planet1).zipWithIndex.filter{\
    \ case (x,y) => x != y }\n        val q = planet1 :: planet2\n        val r =\
    \ (planet2 :: planet1)\n        val s = (planet2 :: planet2)\n        val t =\
    \ (planet1 :: planet2)\n        val u = (planet2 :: planet1)\n        val v =\
    \ (planet2 :: planet2)\n        val w = (planet1 :: planet2)\n        val x =\
    \ (planet2 :: planet1)\n        val y = (planet1 :: planet2)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpe8x4w8xh.scala:21:25 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36ma\e[0m = (planet1 :: planet2).zipWithIndex.toList\
    \ \n\e[31m\e[31m   |\e[0m                         ^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                         value :: is not a member of String\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpe8x4w8xh.scala:22:25 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mb\e[0m = (planet2 :: planet1).zipWithIndex.toList\n\
    \e[31m\e[31m   |\e[0m                         ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                         value :: is not a member of String\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpe8x4w8xh.scala:23:25 ------------------------\e[0m\e\
    [0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mc\e[0m = (planet1 :: planet2).zipWithIndex.filter{\
    \ \e[33mcase\e[0m (x,y) => x != y }\n\e[31m\e[31m   |\e[0m                   \
    \      ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                         value :: is not\
    \ a member of String\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpe8x4w8xh.scala:24:25\
    \ ------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e\
    [36md\e[0m = (planet2 :: planet1).zipWithIndex.filter{ \e[33mcase\e[0m (x,y) =>\
    \ x != y }\n\e[31m\e[31m   |\e[0m                         ^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                         value :: is not a member of String\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpe8x4w8xh.scala:25:25 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mf\e[0m = (planet2 :: planet1).zipWithIndex.filter{\
    \ \e[33mcase\e[0m (x,y) => x != y }\n\e[31m\e[31m   |\e[0m                   \
    \      ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                         value :: is not\
    \ a member of String\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpe8x4w8xh.scala:26:25\
    \ ------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e\
    [36me\e[0m = (planet1 :: planet2).zipWithIndex.filter{ \e[33mcase\e[0m (x,y) =>\
    \ x != y }\n\e[31m\e[31m   |\e[0m                         ^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                         value :: is not a member of String\n\e[31m\e\
    ["
  stdout: ''
  timestamp: 1660009754
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets1: List[String] = List(planet1, planet2)\
    \ \n        val planets2: List[String] = List(planet2, planet1)\n\n        val\
    \ earth_dist = Maths.distance(planet2, planet1)\n        val sun_dist = Maths.distance(planet1,\
    \ \"Sun\")\n        val jupiter_dist = Maths.distance(planet1, \"Jupiter\")\n\
    \        val venus_dist = Maths.distance(planet1, \"Venus\")\n\n        val planets3:\
    \ List[String] = planets1.zip(planets2).filter(_._1 != _._1).map(_._2)\n     \
    \   val planets4: List[String] = planets2.zip(planets1).filter(_._1 != _._1).map(_._2)\n\
    \n        // TODO: find out why this isn't working\n        val planets5: List[String]\
    \ = planets3.zip(planets4).filter(_._1 != _._1).map(_._2)\n\n        // TODO:\
    \ find out why this isn't working\n        val planets6: List[String] = planets5.zip(planets4).filter(_._1\
    \ != _._1).map(_._2)\n\n        val planets7: List[String] = planets6.zip(planets5).filter(_._1\
    \ != _._1).map(_._2)\n        val planets8: List[String] = planets5.zip(planets6).filter(_._1\
    \ != _._1).map(_._2)\n\n        val planets9: List[String] = planets7.zip(planets8).filter(_._1\
    \ != _._1).map(_._2)\n        val planets10: List[String] = planets8.zip(planets7).filter(_._1\
    \ != _._1).map(_._2)\n\n        val planets11: List[String] = planets9.zip(planets10).filter(_._1\
    \ != _._1).map(_._2)\n        val planets12: List[String] = planets10.zip(planets9).filter(_._1\
    \ != _._1).map(_._2)\n\n        val planets13: List[String] = planets11.zip(planets12).filter(_._1\
    \ != _._1).map(_._2)\n        val planets14: List[String] = planets12.zip(planets11).filter(_._1\
    \ != _._1).map(_._2)\n\n        val planets15: List[String] = planets13.zip(planets14).filter(_._1\
    \ != _._1).map(_._2)\n        val plan\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp6xwd8hjl.scala:52:4 ----------------------------\e\
    [0m\e[0m\n\e[31m52 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp6xwd8hjl.scala:24:25\
    \ ------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e\
    [36mearth_dist\e[0m = Maths.distance(planet2, planet1)\n\e[31m\e[31m   |\e[0m\
    \                         ^^^^^\e[0m\n\e[31m   |\e[0m                        \
    \ Not found: Maths\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp6xwd8hjl.scala:25:23\
    \ ------------------------\e[0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e\
    [36msun_dist\e[0m = Maths.distance(planet1, \e[31m\"Sun\"\e[0m)\n\e[31m\e[31m\
    \   |\e[0m                       ^^^^^\e[0m\n\e[31m   |\e[0m                 \
    \      Not found: Maths\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp6xwd8hjl.scala:26:27\
    \ ------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e\
    [36mjupiter_dist\e[0m = Maths.distance(planet1, \e[31m\"Jupiter\"\e[0m)\n\e[31m\e\
    [31m   |\e[0m                           ^^^^^\e[0m\n\e[31m   |\e[0m          \
    \                 Not found: Maths\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp6xwd8hjl.scala:27:25 ------------------------\e[0m\e[0m\n\e[31m27 |\e\
    [0m        \e[33mval\e[0m \e[36mvenus_dist\e[0m = Maths.distance(planet1, \e[31m\"\
    Venus\"\e[0m)\n\e[31m\e[31m   |\e[0m                         ^^^^^\e[0m\n\e[31m\
    \   |\e[0m                         Not found: Maths\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp6xwd8hjl.scala:29:69 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mplanets3\e[0m: \e[35mList\e\
    [0m[\e[35mString\e[0m] = planets1.zip(planets2).filter(_._1 != _._1).map(_._2)\n\
    \e[31m\e[31m   |\e[0m                                     "
  stdout: ''
  timestamp: 1660009756
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        def allOrbits(name : String) : List[String] = { \n\
    \            if (name != \"Earth\" && name != \"Mercury\" && name != \"Venus\"\
    \ && name != \"Mars\" && name != \"Jupiter\" && name != \"Saturn\" && name !=\
    \ \"Uranus\" && name != \"Neptune\") \n                List(name)\n          \
    \  else { \n                val orb =  if (name == \"Earth\") \n             \
    \       List(List(List(name = \"Earth\"), List(name = \"Mars\"))) \n         \
    \       else if (name == \"Mercury\") \n                    List(List(List(name\
    \ = \"Earth\"), List(name = \"Venus\"))) \n                else if (name == \"\
    Venus\") \n                    List(List(List(name = \"Earth\"), List(name = \"\
    Mars\"))) \n                else if (name == \"Mars\") \n                    List(List(List(name\
    \ = \"Earth\"), List(name = \"Jupiter\"))) \n                else if (name ==\
    \ \"Jupiter\") \n                    List(List(List(name = \"Earth\"), List(name\
    \ = \"Saturn\"))) \n                else if (name == \"Saturn\") \n          \
    \          List(List(List(name = \"Earth\"), List(name = \"Uranus\"))) \n    \
    \            else if (name == \"Uranus\") \n                    List(List(List(name\
    \ = \"Earth\"), List(name = \"Neptune\"))) \n                else if (name ==\
    \ \"Neptune\") \n                    List(List(List(name = \"Earth\"), List(name\
    \ = \"Mercury\"))) \n                else\n                    List() \n     \
    \           orb \n            } \n        } \n        val planet1Orbs = allOrbits(planet1)\n\
    \        val planet2Orbs = allOrbits(planet2)\n        def bf(p : List[List[String]],\
    \ p1 : String, p2 : List[String]) : List[String] = {\n            val p : scala.collection.mutable.List[scala.collection.mutable.List[String]]\
    \ = p.toList\n            val p1 : scala.collection.mutable.List[String] = p1.toList\n\
    \            val p2 : scala.collection.mutable.List[String] = p2.toList\n    \
    \        val p1: scala.collection.mutable.List[List[String]] = p1.toList\n   \
    \         val p2: scala.collection.mutable.List[List[String]] = p2.toList\n  \
    \          val p1: scala.collection.mutable.List[List[String]] = p1.toList\n \
    \           val p2: scala.collection.mutable.List[List[String]] = p2.toList\n\
    \            val p1: scala.collection.mutable.List[List[String]] = p1.toList\n\
    \            val p2: scala.collection.mutable.List[List[String]] = p2.toList\n\
    \            val p1: scala.collection.mutable.List[List[String]] = p1.toList\n\
    \            val p2: scala.collection.mutable.List[List[String]] = p2.\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpjbv42yu2.scala:60:4 ----------------------------\e\
    [0m\e[0m\n\e[31m60 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tmpjbv42yu2.scala:72:0 ----------------------------\e[0m\e[0m\n\e[31m72\
    \ |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\
    \e[31m\e[31m-- Error: /tmp/tmpjbv42yu2.scala:26:40 -----------------------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m                    List(List(List(name = \e[31m\"Earth\"\
    \e[0m), List(name = \e[31m\"Mars\"\e[0m))) \n\e[31m\e[31m   |\e[0m           \
    \                        ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\e[33mmethod\e[0m\
    \ \e[35mapply\e[0m in \e[33mtrait\e[0m \e[35mIterableFactory\e[0m: (elems: Any*):\
    \ List[Any] does not have a parameter name\n\e[31m\e[31m-- Error: /tmp/tmpjbv42yu2.scala:26:62\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m26 |\e[0m       \
    \             List(List(List(name = \e[31m\"Earth\"\e[0m), List(name = \e[31m\"\
    Mars\"\e[0m))) \n\e[31m\e[31m   |\e[0m                                       \
    \                  ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\e[33mmethod\e[0m \e[35mapply\e\
    [0m in \e[33mtrait\e[0m \e[35mIterableFactory\e[0m: (elems: Any*): List[Any] does\
    \ not have a parameter name\n\e[31m\e[31m-- Error: /tmp/tmpjbv42yu2.scala:28:40\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m28 |\e[0m       \
    \             List(List(List(name = \e[31m\"Earth\"\e[0m), List(name = \e[31m\"\
    Venus\"\e[0m))) \n\e[31m\e[31m   |\e[0m                                   ^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m\e[33mmethod\e[0m \e[35mapply\e[0m in \e[33mtrait\e[0m \e\
    [35mIterableFactory\e[0m: (elems: Any*): List[Any] does not have a parameter name\n\
    \e[31m\e[31m-- Error: /tmp/tmpjbv42yu2.scala:28:62 -----------------------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m                    List(List(List(name = \e[31m\"Earth\"\
    \e[0m), List(name = \e[31m\"Venus\"\e[0m))) \n\e[31m\e[31m   |\e[0m          \
    \                                               ^^^^^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m\e[33mmethod\e[0m \e[35mapply\e[0m in \e[33mtrait\e[0m \e[35mIterableFactory\e\
    ["
  stdout: ''
  timestamp: 1660009758
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        // write your code here\n        val orbits =  List((\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\")).map(x => (x.toUpperCase,x.toUpperCase))\n        val orbits1 =\
    \  List((\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\", \"Neptune\")).map(x => (x.toUpperCase,x.toUpperCase))\n        val\
    \ orbits2 =  List((\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"\
    Saturn\", \"Uranus\", \"Neptune\")).map(x => (x.toUpperCase,x.toUpperCase))\n\
    \        val orbits3 =  List((\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")).map(x => (x.toUpperCase,x.toUpperCase))\n\
    \        val orbits4 =  List((\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")).map(x => (x.toUpperCase,x.toUpperCase))\n\
    \        val orbits5 =  List((\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")).map(x => (x.toUpperCase,x.toUpperCase))\n\
    \        val orbits6 =  List((\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")).map(x => (x.toUpperCase,x.toUpperCase))\n\
    \        val orbits7 =  List((\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")).map(x => (x.toUpperCase,x.toUpperCase))\n\
    \        val orbits8 =  List((\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")).map(x => (x.toUpperCase,x.toUpperCase))\n\
    \        val orbits9 =  List((\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")).map(x => (x.toUpperCase,x.toUpperCase))\n\
    \        val orbits10 =  List((\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")).map(x => (\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpexdvtfry.scala:32:120 --------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36morbits10\e[0m =  List((\e\
    [31m\"Mercury\"\e[0m, \e[31m\"Venus\"\e[0m, \e[31m\"Earth\"\e[0m, \e[31m\"Mars\"\
    \e[0m, \e[31m\"Jupiter\"\e[0m, \e[31m\"Saturn\"\e[0m, \e[31m\"Uranus\"\e[0m, \e\
    [31m\"Neptune\"\e[0m)).map(\e[36mx\e[0m => (\n\e[31m\e[31m   |\e[0m          \
    \                                                                            \
    \                                  ^\e[0m\n\e[31m   |\e[0m                   \
    \                    expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpexdvtfry.scala:22:120 -----------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36morbits\e[0m =  List((\e\
    [31m\"Mercury\"\e[0m, \e[31m\"Venus\"\e[0m, \e[31m\"Earth\"\e[0m, \e[31m\"Mars\"\
    \e[0m, \e[31m\"Jupiter\"\e[0m, \e[31m\"Saturn\"\e[0m, \e[31m\"Uranus\"\e[0m, \e\
    [31m\"Neptune\"\e[0m)).map(\e[36mx\e[0m => (x.toUpperCase,x.toUpperCase))\n\e\
    [31m\e[31m   |\e[0m                                                          \
    \                                                            ^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mvalue toUpperCase is not a member of (String, String, String, String,\
    \ String, String, String, String)\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpexdvtfry.scala:22:134\
    \ -----------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36morbits\e[0m =  List((\e[31m\"Mercury\"\e[0m, \e[31m\"Venus\"\e[0m, \e[31m\"\
    Earth\"\e[0m, \e[31m\"Mars\"\e[0m, \e[31m\"Jupiter\"\e[0m, \e[31m\"Saturn\"\e\
    [0m, \e[31m\"Uranus\"\e[0m, \e[31m\"Neptune\"\e[0m)).map(\e[36mx\e[0m => (x.toUpperCase,x.toUpperCase))\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                                                            ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue toUpperCase is not a member of (String, String, String,\
    \ String, String, String, String, String)\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpexdvtfry.scala:23:121 -----------------------\e[0m\e[0m\n\e[31m23 |\e\
    [0m       "
  stdout: ''
  timestamp: 1660009758
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        var list: List[String] = Nil\n        var orbit1 =\
    \ List.empty[String]\n        var orbit2 = List.empty[String]\n        if(planet1\
    \ != \"Sun\" && planet2 != \"Sun\"){\n            for(planet <- Planets.find(planet1)){\n\
    \                for(orbit <- planet.orbits){\n                    orbit1 += orbit\n\
    \                }\n            }\n            for(planet <- Planets.find(planet2)){\n\
    \                for(orbit <- planet.orbits){\n                    orbit2 += orbit\n\
    \                }\n            }\n            val orb1 = orbit1.toList.sortWith((x:\
    \ String, y: String) =>  abs(x - y))\n            val orb2 = orbit2.toList.sortWith((x:\
    \ String, y: String) =>  abs(x - y))\n            val dist1 = orbit1.map(x=>abs(orb1.indexOf(x)\
    \ - orb2.indexOf(orb1.indexOf(x))))\n            val dist2 = orbit2.map(x=>abs(orb2.indexOf(x)\
    \ - orb1.indexOf(orb2.indexOf(x))))\n            val index = Array[Int](dist1.zipWithIndex.toList.sortBy(_._1).reverse).zipWithIndex.toList\n\
    \            val list = for(x <- index.toList; (y, z) <- dist1.zip(dist2.filter(_==x)))\
    \ yield (y, z)\n            list.toList\n        }\n        else Nil\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpcs1d03c1.scala:25:26 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m            \e[33mfor\e[0m(planet <- Planets.find(planet1)){\n\
    \e[31m\e[31m   |\e[0m                          ^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \                         Not found: Planets\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpcs1d03c1.scala:30:26 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m            \e[33mfor\e[0m(planet <- Planets.find(planet2)){\n\
    \e[31m\e[31m   |\e[0m                          ^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \                         Not found: Planets\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpcs1d03c1.scala:35:79 ------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m            \e[33mval\e[0m \e[36morb1\e[0m = orbit1.toList.sortWith((\e\
    [36mx\e[0m: \e[35mString\e[0m, \e[36my\e[0m: \e[35mString\e[0m) =>  abs(x - y))\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                     ^^^\e[0m\n\e[31m   |\e[0mvalue - is not a member of String,\
    \ but could be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mOne of the following imports might make progress towards fixing the\
    \ problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpcs1d03c1.scala:36:79 ------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m            \e[33mval\e[0m \e[36morb2\e[0m = orbit2.toList.sortWith((\e\
    [36mx\e[0m: \e[35mString\e[0m, \e[36my\e[0m: \e[35mString\e[0m) =>  abs(x - y))\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                     ^^^\e[0m\n\e[31m   |\e[0mvalue - is not a member of String,\
    \ but could be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mOne of the following imports might make prog"
  stdout: ''
  timestamp: 1660009756
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        // Your code here\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val sun_distance =  new mutable.TreeMap[String,Int]()\n        for(planet\
    \ <- planets){\n            val distance = Sun_distance.getOrElse(planet,0)\n\
    \            sun_distance += (planet->distance)\n        }\n        val bf = sun_distance.filter(_._1\
    \ <= sun_distance.getOrElse(planet2,0)) && (sun_distance.getOrElse(planet2,0)\
    \ <= sun_distance.getOrElse(planet1,0))\n        val sortedResult = bf\n     \
    \       .sortBy(_._2.toDouble - sun_distance.getOrElse(planet2,0).toDouble)\n\
    \            .map { case (planet, distance) =>\n                planet +\": \"\
    + distance\n            }\n            .toList\n        sortedResult.distinct\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"\
    Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpsz7_xjn6.scala:23:32 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36msun_distance\e[0m =  \e\
    [33mnew\e[0m mutable.TreeMap[\e[35mString\e[0m,\e[35mInt\e[0m]()\n\e[31m\e[31m\
    \   |\e[0m                                ^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \                          Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpsz7_xjn6.scala:25:27 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m            \e[33mval\e[0m \e[36mdistance\e[0m = Sun_distance.getOrElse(planet,\e\
    [31m0\e[0m)\n\e[31m\e[31m   |\e[0m                           ^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                           Not found: Sun_distance\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660009751
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        def getDist(planet : String, sun : String) : Double\
    \ = {\n            val planet1 = planet.toLowerCase\n            val planet2 =\
    \ sun.toLowerCase\n            val planet1PlanetName = planet1 + \" \" + planet2\n\
    \            val planet2Sun = sun + \" \" + planet1\n            val planet1Planet2PlanetName\
    \ = planet1 + \" \" + planet2 + \"  \" + planet2\n            val planet1Planet2Sun\
    \ = sun + \" \" + planet1 + \"  \" + planet2\n            val planet1Planet2SunPlanetName\
    \ = planet1 + \" \" + planet2 + \"  \" + sun + \" \" + planet1\n            val\
    \ planet2Planet1Planet2SunPlanetName = planet2 + \"  \" + planet1 + \"  \" + sun\
    \ + \" \" + planet1\n            val planet1Planet1Planet2Planet2SunPlanetName\
    \ = planet1 + \" \" + planet1 + \"  \" + planet2 + \"  \" + sun + \" \" + planet1\n\
    \            val planet1Planet1Planet2SunPlanet1Planet2Planet2Planet2Planet1Planet1Planet1Planet2Planet2Name\
    \ = planet1 + \" \" + planet1 + \"  \" + sun + \" \" + planet1 + \"  \" + planet2\
    \ + \"  \" + planet2 + \"  \" + planet2 + \"  \" + sun + \" \" + planet1\n   \
    \         val planet1Planet1Planet2Planet2Planet1Planet1Planet1Planet2Planet2Planet2Planet2Planet1Planet1Planet1Planet1Planet2Planet2Name\
    \ = planet1 + \" \" + planet1 + \"  \" + planet2 + \"  \" + planet2 + \"  \" +\
    \ planet1 + \" \" + planet2 + \"  \" + planet2 + \"  \" + planet2 + \"  \" + sun\
    \ + \" \" + planet1\n            val planet1Planet1Planet2Planet1Planet1Planet1Planet1Planet2Planet2Planet1Planet1Planet1Planet2Planet2Planet2Planet1Planet1Planet2Planet1Planet1Planet1Planet2Planet1Planet1Planet1Planet1Planet2Planet1Planet1Planet1Planet1Planet2Planet1Planet1Planet1Planet\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"\
    Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpxt78hs9n.scala:34:4 ----------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpxt78hs9n.scala:46:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m46 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmpxt78hs9n.scala:34:5 ---------------------\e[0m\e[0m\n\
    \e[31m34 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:\
    \    Unit\n\e[31m   |\e[0m     Required: Double\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpxt78hs9n.scala:45:1 ---------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e[0m\n\e[31m   |\e[0m Found:\
    \    Unit\n\e[31m   |\e[0m Required: List[String]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[33m\e[33m--\
    \ Warning: /tmp/tmpxt78hs9n.scala:35:4 ----------------------------------------\e\
    [0m\e[0m\n\e[33m35 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m\
    \   |\e[0m    Line is indented too far to the left, or a `}` is missing\n1 warning\
    \ found\n4 errors found\n"
  stdout: ''
  timestamp: 1660009756
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val list = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val sun\
    \ = List(\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\", \"Neptune\", \"Mars\")\n\n        def getOrbit(p : String) : List[String]\
    \ = {\n            val p1 = p.split(\"_\")(0)\n            val p2 = p.split(\"\
    _\")(1)\n            (p1 :: sun) filter (_ == p2) filter (x => list.contains(x))\n\
    \        }\n\n        val orbit1 = getOrbit(planet1)\n        val orbit2 = getOrbit(planet2)\n\
    \n        val result = orbit1 filter { a => orbit2 contains a}.sortBy( x => {\
    \ Math.abs(x.toDouble - sun.head.toDouble) } )\n        result\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E081] Type Error: /tmp/tmpu9lbno16.scala:33:37 -----------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = orbit1 filter\
    \ { \e[36ma\e[0m => orbit2 contains a}.sortBy( \e[36mx\e[0m => { Math.abs(x.toDouble\
    \ - sun.head.toDouble) } )\n\e[31m\e[31m   |\e[0m                            \
    \         ^\e[0m\n\e[31m   |\e[0m                          Missing parameter type\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m                          I could not infer the\
    \ type of the parameter a.\n1 error found\n"
  stdout: ''
  timestamp: 1660009751
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        def f(planet : String) : Boolean = {\n           \
    \ val sun = Melon.getSun\n            val moon = Melon.getMoon\n            val\
    \ earth = Melon.getEarth\n            val mars = Melon.getMars\n            val\
    \ jup = Melon.getJup\n            val sat = Melon.getSat\n            val uranus\
    \ = Melon.getUranus\n            val neptune = Melon.getNeptune\n            val\
    \ venus = Melon.getVenus\n            val earthRadius = earth.getRadius\n    \
    \        val marsRadius = mars.getRadius\n            val jupRadius = jup.getRadius\n\
    \            val satRadius = sat.getRadius\n            val uranusRadius = uranus.getRadius\n\
    \            val neptuneRadius = neptune.getRadius\n            val venusRadius\
    \ = venus.getRadius\n            val sunRadius = sun.getRadius\n            val\
    \ planetRadius = planet.getRadius\n            val sunDistance = sun.distance(Melon.getSun)\n\
    \            val moonDistance = moon.distance(Melon.getMoon)\n            val\
    \ earthDistance = earth.distance(Melon.getEarth)\n            val marsDistance\
    \ = mars.distance(Melon.getMars)\n            val jupDistance = jup.distance(Melon.getJup)\n\
    \            val satDistance = sat.distance(Melon.getSat)\n            val uranusDistance\
    \ = uranus.distance(Melon.getUranus)\n            val neptuneDistance = neptune.distance(Melon.getNeptune)\n\
    \            val venusDistance = venus.distance(Melon.getVenus)\n            val\
    \ planetDistance = planet.distance(Melon.getVenus)\n            val planetRadius2\
    \ = planet.getRadius*planet.getRadius\n            val planetRadius : Double =\
    \ planetRadius*planetRadius\n            val sunDistance : Double = sunDistance*sunDistance\n\
    \            val moonDistance : Double = moonDistance*moonDistance\n         \
    \   val earthDistance : Double = earthDistance*earthDistance\n            val\
    \ marsDistance : Double = marsDistance*marsDistance\n            val jupDistance\
    \ : Double = jupDistance*jupDistance\n            val satDistance : Double = satDistance*satDistance\n\
    \            val uranusDistance : Double = uran\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp8iivn0o0.scala:71:0 ----------------------------\e\
    [0m\e[0m\n\e[31m71 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp8iivn0o0.scala:51:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m51 |\e[0m            \e[33mval\e\
    [0m \e[36mplanetRadius\e[0m : \e[35mDouble\e[0m = planetRadius*planetRadius\n\e\
    [31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mplanetRadius is already defined as \e[33mvalue\e[0m \e[35mplanetRadius\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp8iivn0o0.scala:52:16 ---------------------------\e[0m\e[0m\n\e\
    [31m52 |\e[0m            \e[33mval\e[0m \e[36msunDistance\e[0m : \e[35mDouble\e\
    [0m = sunDistance*sunDistance\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msunDistance is already defined as \e[33mvalue\e[0m \e[35msunDistance\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp8iivn0o0.scala:53:16 ---------------------------\e[0m\e[0m\n\e\
    [31m53 |\e[0m            \e[33mval\e[0m \e[36mmoonDistance\e[0m : \e[35mDouble\e\
    [0m = moonDistance*moonDistance\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmoonDistance is already defined as \e[33mvalue\e[0m \e[35mmoonDistance\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp8iivn0o0.scala:54:16 ---------------------------\e[0m\e[0m\n\e\
    [31m54 |\e[0m            \e[33mval\e[0m \e[36mearthDistance\e[0m : \e[35mDouble\e\
    [0m = earthDistance*earthDistance\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mearthDistance is already defined as \e[33mvalue\e[0m \e[35mearthDistance\e\
    [0m\n\e[31"
  stdout: ''
  timestamp: 1660009759
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        // Your solution goes here\n        val planetsBetweenJupiterAndNeptune\
    \ = mutable.Set(\"Mercury\", \"Saturn\", \"Uranus\")\n        val planetsBetweenEarthAndMercury\
    \ = mutable.Set(\"Venus\")\n        val planetsBetweenEarthAndVenus = mutable.Set(\"\
    Earth\")\n        val planetsBetweenEarthAndMars = mutable.Set(\"Mars\")\n   \
    \     val planetsBetweenEarthAndJupiter = mutable.Set(\"Jupiter\")\n        val\
    \ planetsBetweenEarthAndSaturn = mutable.Set(\"Saturn\")\n        val planetsBetweenEarthAndUranus\
    \ = mutable.Set(\"Uranus\")\n        val planetsBetweenEarthAndNeptune = mutable.Set(\"\
    Neptune\")\n        if(planet1.toUpper == planet2.toUpper) {\n            if(planetsBetweenJupiterAndNeptune.contains(planet1)\
    \ && planetsBetweenJupiterAndNeptune.contains(planet2)) {\n                List(planet1,\
    \ planet2)\n            } else {\n                List()\n            }\n    \
    \    } else if(planet1.toUpper == \"EARTH\" && planet2.toUpper == \"MERCURY\"\
    ) {\n            if(planetsBetweenEarthAndMercury.contains(planet1) && planetsBetweenEarthAndMercury.contains(planet2))\
    \ {\n                List(planet1, planet2)\n            } else {\n          \
    \      List()\n            }\n        } else if(planet1.toUpper == \"EARTH\" &&\
    \ planet2.toUpper == \"VENUS\") {\n            if(planetsBetweenEarthAndVenus.contains(planet1)\
    \ && planetsBetweenEarthAndVenus.contains(planet2)) {\n                List(planet1,\
    \ planet2)\n            } else {\n                List()\n            }\n    \
    \    } else if(planet1.toUpper == \"EARTH\" && planet2.toUpper == \"MARS\") {\n\
    \            if(planetsBetweenEarthAndMars.contains(planet1) && planetsBetweenEarthAndMars.contains(planet2))\
    \ {\n                List(planet1, planet2)\n            } else {\n          \
    \      List()\n            }\n        } else if(planet1.toUpper == \"EARTH\" &&\
    \ planet2.toUpper == \"JUPITER\") {\n            if(planetsBetweenEarthAndJupiter.contains(planet1)\
    \ && planetsBetweenEarthAndJupiter.contains(planet2)) {\n                List(planet1,\
    \ plan\n    }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"\
    ), (\"Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpw_ctbe5w.scala:57:4 ----------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpw_ctbe5w.scala:69:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m69 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E006] Not\
    \ Found Error: /tmp/tmpw_ctbe5w.scala:22:46 ------------------------\e[0m\e[0m\n\
    \e[31m22 |\e[0m        \e[33mval\e[0m \e[36mplanetsBetweenJupiterAndNeptune\e\
    [0m = mutable.Set(\e[31m\"Mercury\"\e[0m, \e[31m\"Saturn\"\e[0m, \e[31m\"Uranus\"\
    \e[0m)\n\e[31m\e[31m   |\e[0m                                              ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                              Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpw_ctbe5w.scala:23:44\
    \ ------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e\
    [36mplanetsBetweenEarthAndMercury\e[0m = mutable.Set(\e[31m\"Venus\"\e[0m)\n\e\
    [31m\e[31m   |\e[0m                                            ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                                            Not found: mutable\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpw_ctbe5w.scala:24:42\
    \ ------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e\
    [36mplanetsBetweenEarthAndVenus\e[0m = mutable.Set(\e[31m\"Earth\"\e[0m)\n\e[31m\e\
    [31m   |\e[0m                                          ^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                                          Not found: mutable\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpw_ctbe5w.scala:25:41 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mplanetsBetweenEarthAndMars\e\
    [0m = mutable.Set(\e[31m\"Mars\"\e[0m)\n\e[31m\e[31m   |\e[0m                \
    \                         ^^^^^^^\e[0m\n\e[31m   |\e[0m                      \
    \       "
  stdout: ''
  timestamp: 1660009759
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        def isInside(sun: Vector[Double], planet : String)\
    \ = {\n            val planetPosition = Vector(planet.trim.split(\"[\\\\s,]\"\
    ).map(_.toDouble))\n            sun min planetPosition >=  0.0\n        }\n  \
    \      val sunVector = Vector(sun.x, sun.y, sun.z)\n        val planetVector1\
    \ = Vector(planet1.trim.split(\"[\\\\s,]\").map(_.toDouble))\n        val planetVector2\
    \ = Vector(planet2.trim.split(\"[\\\\s,]\").map(_.toDouble))\n        val planetPosition\
    \ = Vector(planetVector1 zip planetVector2)\n        val planetList = List(planet1,\
    \ planet2) filter (isInside(sunVector, planet))\n        if (planetList.isEmpty)\
    \ List()\n        else planetList.sortWith(compare(planetPosition))\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp9gef63li.scala:23:35 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            sun min planetPosition >=  \e[31m0.0\e[0m\n\
    \e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mvalue >= is not a member of Vector[Array[Double]], but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m  import math.Ordered.orderingToOrdered\n\e[31m   |\e[0m  import\
    \ math.Ordering.Implicits.infixOrderingOps\n\e[31m   |\e[0m\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp9gef63li.scala:25:35 ------------------------\e[0m\e\
    [0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36msunVector\e[0m = Vector(sun.x,\
    \ sun.y, sun.z)\n\e[31m\e[31m   |\e[0m                               ^^^^^\e[0m\n\
    \e[31m   |\e[0m                               value x is not a member of sun\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp9gef63li.scala:25:42 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36msunVector\e[0m = Vector(sun.x,\
    \ sun.y, sun.z)\n\e[31m\e[31m   |\e[0m                                      ^^^^^\e\
    [0m\n\e[31m   |\e[0m                                      value y is not a member\
    \ of sun\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp9gef63li.scala:25:49\
    \ ------------------------\e[0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e\
    [36msunVector\e[0m = Vector(sun.x, sun.y, sun.z)\n\e[31m\e[31m   |\e[0m      \
    \                                       ^^^^^\e[0m\n\e[31m   |\e[0m          \
    \                                value z is not a member of sun\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp9gef63li.scala:29:76 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mplanetList\e[0m = List(planet1,\
    \ planet2) filter (isInside(sunVector, planet))\n\e[31m\e[31m   |\e[0m       \
    \                                                                     ^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                                       Not\
    \ found: planet\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compi"
  stdout: ''
  timestamp: 1660009759
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets1 = Seq(planet1, planet2).map(_.capitalize)\n\
    \        val planets2 = Seq(planet2, planet1).map(_.capitalize)\n        val planets3\
    \ = Seq(planet2, planet1).map(_.capitalize).reverse\n        val sun = Seq(planet1,\
    \ planet2).map(_.capitalize).reverse.find(_.equals(\"Sun\"))\n        val mercury\
    \ = Seq(planet1, planet2).filter(_.equals(\"Mercury\"))\n        val venus = Seq(planet1,\
    \ planet2).filter(_.equals(\"Venus\"))\n        val earth = Seq(planet1, planet2).filter(_.equals(\"\
    Earth\"))\n        val mars = Seq(planet1, planet2).filter(_.equals(\"Mars\"))\n\
    \        val jupiter = Seq(planet1, planet2).filter(_.equals(\"Jupiter\"))\n \
    \       val saturn = Seq(planet1, planet2).filter(_.equals(\"Saturn\"))\n    \
    \    val uranus = Seq(planet1, planet2).filter(_.equals(\"Uranus\"))\n       \
    \ val neptune = Seq(planet1, planet2).filter(_.equals(\"Neptune\"))\n        val\
    \ planets4 = Seq(planet1, planet2).filter(_.equals(\"Mercury\")).filter(_.equals(\"\
    Venus\"))\n        val planets5 = Seq(planet1, planet2).filter(_.equals(\"Mercury\"\
    )).filter(_.equals(\"Earth\"))\n        val planets6 = Seq(planet1, planet2).filter(_.equals(\"\
    Mercury\")).filter(_.equals(\"Mars\"))\n        val planets7 = Seq(planet1, planet2).filter(_.equals(\"\
    Mercury\")).filter(_.equals(\"Jupiter\"))\n        val planets8 = Seq(planet1,\
    \ planet2).filter(_.equals(\"Mercury\")).filter(_.equals(\"Saturn\"))\n      \
    \  val planets9 = Seq(planet1, planet2).filter(_.equals(\"Mercury\")).filter(_.equals(\"\
    Uranus\"))\n        val planets10 = Seq(planet1, planet2).filter(_.equals(\"Mercury\"\
    )).filter(_.equals(\"Neptune\"))\n        val planets11 = Seq(planet1, planet2).filter(_.equals(\"\
    Venus\")).filter(_.equals(\"Earth\"))\n        val planets12 = Seq(planet\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"\
    Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpduoiky6i.scala:42:4 ----------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpduoiky6i.scala:41:28\
    \ ------------------------\e[0m\e[0m\n\e[31m41 |\e[0m        \e[33mval\e[0m \e\
    [36mplanets12\e[0m = Seq(planet\n\e[31m\e[31m   |\e[0m                       \
    \     ^^^^^^\e[0m\n\e[31m   |\e[0m                            Not found: planet\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpduoiky6i.scala:42:5\
    \ ---------------------\e[0m\e[0m\n\e[31m42 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[String]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660009759
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planetsBetween = (planet1, planet2) match {\n\
    \            case (planet1, planet2) if planets.contains(planet1) == false =>\
    \ ()\n            case (planet1, planet2) if planets.contains(planet2) == false\
    \ => ()\n            case (planet1, planet2) if planets.contains(planet1) && planets.contains(planet2)\
    \ => planets\n            case _ => ()\n        }\n        (planetsBetween._1\
    \ ++ planetsBetween._2).sortWith( (x:String, y:String) => math.abs(x - y)).filter(_\
    \ > 0).map(_._1)\n    }\n    def main(args: Array[String]) = {\n    assert(bf((\"\
    Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n\
    \    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n\
    \    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"),\
    \ (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp_7bihs3w.scala:22:39 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m            \e[33mcase\e[0m (planet1, planet2) \e[33mif\e\
    [0m planets.contains(planet1) == \e[31mfalse\e[0m => ()\n\e[31m\e[31m   |\e[0m\
    \                                       ^^^^^^^\e[0m\n\e[31m   |\e[0m        \
    \                               Not found: planets\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp_7bihs3w.scala:23:39 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            \e[33mcase\e[0m (planet1, planet2) \e[33mif\e\
    [0m planets.contains(planet2) == \e[31mfalse\e[0m => ()\n\e[31m\e[31m   |\e[0m\
    \                                       ^^^^^^^\e[0m\n\e[31m   |\e[0m        \
    \                               Not found: planets\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp_7bihs3w.scala:24:39 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m            \e[33mcase\e[0m (planet1, planet2) \e[33mif\e\
    [0m planets.contains(planet1) && planets.contains(planet2) => planets\n\e[31m\e\
    [31m   |\e[0m                                       ^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                                       Not found: planets\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmp_7bihs3w.scala:24:97 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m            \e[33mcase\e[0m (planet1, planet2) \e[33mif\e\
    [0m planets.contains(planet1) && planets.contains(planet2) => planets\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \                                 ^^^^^^^\e[0m\n\e[31m   |\e[0m              \
    \                                        Not found: planets\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmp_7bihs3w.scala:27:24 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        (planetsBetween._1 ++ planetsBetwee"
  stdout: ''
  timestamp: 1660009757
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n      import scala.math._\n      import scala.collection.mutable._\n\
    \      if (planet1 == planet2) {\n        return Nil\n      }\n      var planets\
    \ = mutable.ListBuffer[String]()\n      planets += planet1\n      planets += planet2\n\
    \      planets.sortWith((a, b) => a.compareTo(b) < 0)\n      planets.foreach {\n\
    \        case a if a.equals(\"Mercury\") && b.equals(\"Uranus\") =>\n        \
    \  planets += \"Earth\"\n          planets += \"Mars\"\n          planets += \"\
    Jupiter\"\n          planets += \"Saturn\"\n          planets += \"Uranus\"\n\
    \          planets += \"Neptune\"\n          planets += \"Venus\"\n          planets\
    \ += \"Earth\"\n          planets += \"Mars\"\n          planets += \"Jupiter\"\
    \n          planets += \"Saturn\"\n          planets += \"Uranus\"\n         \
    \ planets += \"Neptune\"\n          planets += \"Venus\"\n        case a if a.equals(\"\
    Venus\") && b.equals(\"Earth\") =>\n          planets += \"Mars\"\n          planets\
    \ += \"Jupiter\"\n          planets += \"Saturn\"\n          planets += \"Uranus\"\
    \n          planets += \"Neptune\"\n          planets += \"Mercury\"\n       \
    \   planets += \"Venus\"\n          planets += \"Earth\"\n          planets +=\
    \ \"Mars\"\n          planets += \"Jupiter\"\n          planets += \"Saturn\"\n\
    \          planets += \"Uranus\"\n          planets += \"Neptune\"\n        case\
    \ a if a.equals(\"Mercury\") && b.equals(\"Mercury\") =>\n          planets +=\
    \ \"Mercury\"\n          planets += \"Venus\"\n          planets += \"Earth\"\n\
    \          planets += \"Mars\"\n          planets += \"Jupiter\"\n          planets\
    \ += \"Saturn\"\n          planets += \"Uranus\"\n          planets += \"Neptune\"\
    \n        case a if a.equals(\"Venus\") && b.equals(\"Venus\") =>\n          planets\
    \ += \"Mercury\"\n          planets += \"Earth\"\n          planets += \"Mars\"\
    \n          planets += \n    }\n    def main(args: Array[String]) = {\n    assert(bf((\"\
    Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n\
    \    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n\
    \    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"),\
    \ (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpfwip8p8w.scala:73:20 ---------------------------\e\
    [0m\e[0m\n\e[31m73 |\e[0m          planets += \n\e[31m\e[31m   |\e[0m        \
    \            ^\e[0m\n\e[31m   |\e[0m                    expression expected but\
    \ \e[31munindent\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tmpfwip8p8w.scala:86:0 ----------------------------\e[0m\e[0m\n\e[31m86\
    \ |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpfwip8p8w.scala:26:20 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m      \e[33mvar\e[0m \e[36mplanets\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpfwip8p8w.scala:85:1 ---------------------\e\
    [0m\e[0m\n\e[31m85 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e[0m\n\e[31m   |\e[0m Found:\
    \    Unit\n\e[31m   |\e[0m Required: List[String]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[33m\e[33m--\
    \ Warning: /tmp/tmpfwip8p8w.scala:75:4 ----------------------------------------\e\
    [0m\e[0m\n\e[33m75 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m\
    \   |\e[0m    Line is indented too far to the left, or a `}` is missing\n1 warning\
    \ found\n4 errors found\n"
  stdout: ''
  timestamp: 1660009759
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planet1 = Map(\"Mercury\" -> 0, \"Venus\" -> 1,\
    \ \"Earth\" -> 2, \"Mars\" -> 3, \"Jupiter\" -> 4, \"Saturn\" -> 5, \"Uranus\"\
    \ -> 6, \"Neptune\" -> 7)\n        val planet2 = Map(\"Mercury\" -> 0, \"Venus\"\
    \ -> 1, \"Earth\" -> 2, \"Mars\" -> 3, \"Jupiter\" -> 4, \"Saturn\" -> 5, \"Uranus\"\
    \ -> 6, \"Neptune\" -> 7)\n        val planet1 = planet1.toList.map((_,1))\n \
    \       val planet2 = planet2.toList.map((_,1))\n        val sun = List((\"Mercury\"\
    ,7),(\"Venus\",4),(\"Earth\",2),(\"Mars\",3),(\"Jupiter\",2),(\"Saturn\",2),(\"\
    Uranus\",2),(\"Neptune\",2))\n        val dist = sun zip sun map{case (x,y) =>\
    \ sqrt(sqr(x(0)-x(1))+sqr(y(0)-y(1)))}\n        val planets1 = planet1 ++ planet2\
    \ diff sun\n        val planets2 = planet1 diff planet2 diff sun\n        val\
    \ planets3 = planets1 ++ planets2 diff planet1 diff planet2 diff sun\n       \
    \ val planets4 = planets1 ++ planets3 diff planet1 diff planet2 diff planet1 diff\
    \ sun diff sun\n        val planets5 = planets4 diff planets1 diff planet2 diff\
    \ planet1 diff planet2 diff planet1 diff sun diff sun\n        val planets6 =\
    \ planets4 diff planets2 diff planet1 diff planet2 diff planet1 diff planet2 diff\
    \ planet1 diff sun diff sun\n        val planets7 = planets6 diff planets1 diff\
    \ planet2 diff planet1 diff planet2 diff planet1 diff planet2 diff planet1 diff\
    \ sun diff sun\n        val planets8 = planets6 diff planets2 diff planet1 diff\
    \ planet2 diff planet1 diff planet2 diff planet1 diff planet2 diff planet1 diff\
    \ sun diff sun diff sun diff sun diff sun diff sun diff sun diff sun diff sun\
    \ diff sun diff sun diff sun diff sun\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpjqar_ab6.scala:23:12 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mplanet1\e[0m = planet1.toList.map((_,\e\
    [31m1\e[0m))\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mplanet1 is already defined as \e[33mvalue\e[0m \e[35mplanet1\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpjqar_ab6.scala:24:12 ---------------------------\e[0m\e[0m\n\e\
    [31m24 |\e[0m        \e[33mval\e[0m \e[36mplanet2\e[0m = planet2.toList.map((_,\e\
    [31m1\e[0m))\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mplanet2 is already defined as \e[33mvalue\e[0m \e[35mplanet2\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E006] Not\
    \ Found Error: /tmp/tmpjqar_ab6.scala:26:54 ------------------------\e[0m\e[0m\n\
    \e[31m26 |\e[0m        \e[33mval\e[0m \e[36mdist\e[0m = sun zip sun map{\e[33mcase\e\
    [0m (x,y) => sqrt(sqr(x(\e[31m0\e[0m)-x(\e[31m1\e[0m))+sqr(y(\e[31m0\e[0m)-y(\e\
    [31m1\e[0m)))}\n\e[31m\e[31m   |\e[0m                                        \
    \              ^^^\e[0m\n\e[31m   |\e[0m                                     \
    \                 Not found: sqr\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpjqar_ab6.scala:26:62 ------------------------\e[0m\e[0m\n\e[31m26 |\e\
    [0m        \e[33mval\e[0m \e[36mdist\e[0m = sun zip sun map{\e[33mcase\e[0m (x,y)\
    \ => sqrt(sqr(x(\e[31m0\e[0m)-x(\e[31m1\e[0m))+sqr(y(\e[31m0\e[0m)-y(\e[31m1\e\
    [0m)))}\n\e[31m\e[31m   |\e[0m                                               \
    \           ^^^^^\e[0m\n\e[31m   |\e[0mvalue - is not a member of String, but\
    \ could be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mOne of the following imports might make progress towards fixing the problem:\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m"
  stdout: ''
  timestamp: 1660009760
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val jup : Planet = (\"Jupiter\")\n        val nep\
    \ : Planet = (\"Neptune\")\n        val mercury : Planet = (\"Mercury\")\n   \
    \     val venus : Planet = (\"Venus\")\n        val earth : Planet = (\"Earth\"\
    )\n        val mars : Planet = (\"Mars\")\n        val jupiter : Planet = (\"\
    Jupiter\")\n        val saturn : Planet = (\"Saturn\")\n        val uranus : Planet\
    \ = (\"Uranus\")\n        val neptune : Planet = (\"Neptune\")\n        if (planet1\
    \ == planet2) {\n            return List()\n        } else if (planet1 == jup\
    \ || planet1 == jupiter || planet1 == mars || planet1 == saturn || planet1 ==\
    \ uranus || planet1 == neptune) {\n            val planet1 = (\"Saturn\", \"Uranus\"\
    )\n        }\n        val orbit1 = jupiter.orbit(planet1)\n        val orbit2\
    \ = neptune.orbit(planet2)\n        val difference = orbit1.distance(orbit2)\n\
    \        val planets1 = orbit1.toList\n        val planets2 = orbit2.toList\n\
    \        val planets3 = planets1 diff planets2\n        val planets4 = planets3\
    \ diff List(venus)\n        val planets5 = planets4 diff List(earth, mars)\n \
    \       val planets6 = planets5 diff List(jupiter, saturn)\n        val planets7\
    \ = planets6 diff List(uranus, neptune)\n        planets7.sorted\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpts4bay42.scala:21:18 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mjup\e[0m : \e[35mPlanet\e\
    [0m = (\e[31m\"Jupiter\"\e[0m)\n\e[31m\e[31m   |\e[0m                  ^^^^^^\e\
    [0m\n\e[31m   |\e[0m                  Not found: type Planet\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpts4bay42.scala:22:18 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mnep\e[0m : \e[35mPlanet\e\
    [0m = (\e[31m\"Neptune\"\e[0m)\n\e[31m\e[31m   |\e[0m                  ^^^^^^\e\
    [0m\n\e[31m   |\e[0m                  Not found: type Planet\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpts4bay42.scala:23:22 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mmercury\e[0m : \e[35mPlanet\e\
    [0m = (\e[31m\"Mercury\"\e[0m)\n\e[31m\e[31m   |\e[0m                      ^^^^^^\e\
    [0m\n\e[31m   |\e[0m                      Not found: type Planet\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpts4bay42.scala:24:20 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mvenus\e[0m : \e[35mPlanet\e\
    [0m = (\e[31m\"Venus\"\e[0m)\n\e[31m\e[31m   |\e[0m                    ^^^^^^\e\
    [0m\n\e[31m   |\e[0m                    Not found: type Planet\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpts4bay42.scala:25:20 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mearth\e[0m : \e[35mPlanet\e\
    [0m = (\e[31m\"Earth\"\e[0m)\n\e[31m\e[31m   |\e[0m                    ^^^^^^\e\
    [0m\n\e[31m   |\e[0m                    Not found: type Planet\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpts4bay42.scala:26:19 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mmars\e[0m :"
  stdout: ''
  timestamp: 1660009755
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        // 1. Calculate the distances of planet1 and planet2\n\
    \        var distM : Double = 0\n        var distV : Double = 0\n        val p1\
    \ = planet1.toUpperCase\n        val p2 = planet2.toUpperCase\n        distM =\
    \ math.pow((math.pow(M(p1),2) +math.pow(M(p2),2)) -1, 2)\n        distV = math.pow((math.pow(V(p1),2)\
    \ +math.pow(V(p2),2)) -1, 2)\n\n        // 2. Calculate the orbital angles\n \
    \       val a1 = math.acos(math.sin(math.pi/2 - math.acos(M(p1))) * math.sin(math.pi/2\
    \ - math.acos(M(p2))))\n        val a2 = math.acos(math.sin(math.pi/2 - math.acos(V(p1)))\
    \ * math.sin(math.pi/2 - math.acos(V(p2))))\n\n        // 3. Calculate the planets\
    \ orbits\n        var orbitsM: List[String] = Nil\n        var orbitsV: List[String]\
    \ = Nil\n        if (a1 < a2) {\n            orbitsM = (M(p1) + M(p2)).sorted.toList\n\
    \            orbitsV = (V(p1) + V(p2)).sorted.toList\n        } else if (a1 >\
    \ a2) {\n            orbitsM = (M(p2) + M(p1)).sorted.toList\n            orbitsV\
    \ = (V(p2) + V(p1)).sorted.toList\n        }\n        return orbitsM.filter( x=>\
    \ orbitsV.indexOf(x) < orbitsV.indexOf(\"SUN\") ).sorted\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpv3z12wwz.scala:26:35 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        distM = math.pow((math.pow(M(p1),\e[31m2\e[0m)\
    \ +math.pow(M(p2),\e[31m2\e[0m)) -\e[31m1\e[0m, \e[31m2\e[0m)\n\e[31m\e[31m  \
    \ |\e[0m                                   ^\e[0m\n\e[31m   |\e[0m           \
    \                        Not found: M\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpv3z12wwz.scala:26:54 ------------------------\e[0m\e\
    [0m\n\e[31m26 |\e[0m        distM = math.pow((math.pow(M(p1),\e[31m2\e[0m) +math.pow(M(p2),\e\
    [31m2\e[0m)) -\e[31m1\e[0m, \e[31m2\e[0m)\n\e[31m\e[31m   |\e[0m             \
    \                                         ^\e[0m\n\e[31m   |\e[0m            \
    \                                          Not found: M\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpv3z12wwz.scala:27:35 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        distV = math.pow((math.pow(V(p1),\e[31m2\e[0m)\
    \ +math.pow(V(p2),\e[31m2\e[0m)) -\e[31m1\e[0m, \e[31m2\e[0m)\n\e[31m\e[31m  \
    \ |\e[0m                                   ^\e[0m\n\e[31m   |\e[0m           \
    \                        Not found: V\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpv3z12wwz.scala:27:54 ------------------------\e[0m\e\
    [0m\n\e[31m27 |\e[0m        distV = math.pow((math.pow(V(p1),\e[31m2\e[0m) +math.pow(V(p2),\e\
    [31m2\e[0m)) -\e[31m1\e[0m, \e[31m2\e[0m)\n\e[31m\e[31m   |\e[0m             \
    \                                         ^\e[0m\n\e[31m   |\e[0m            \
    \                                          Not found: V\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpv3z12wwz.scala:30:41 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36ma1\e[0m = math.acos(math.sin(math.pi/\e\
    [31m2\e[0m - math.acos(M(p1))) * math.sin(math.pi/\e[31m2\e[0m - math.acos(M(p2))))\n\
    \e[31m\e[3"
  stdout: ''
  timestamp: 1660009762
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val distances = Map(planet1 -> 0.0, planet2 -> 0.0)\n\
    \        val planetsBetween = (List(planet1, planet2) map { p => p -> (distances(p)\
    \ + planetDistance(p, planet2, planet1)) })\n        val planetsToKeep = planetsBetween.filter\
    \ { case (p1, distance) =>\n            val p2 = distances.filterKeys(_ != p1).head\n\
    \            distance <= distances(p2)\n        }\n        planetsToKeep.map(p\
    \ => p._1).sorted\n    }\n    def main(args: Array[String]) = {\n    assert(bf((\"\
    Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n\
    \    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n\
    \    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"),\
    \ (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp00xcmwhi.scala:22:85 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mplanetsBetween\e[0m = (List(planet1,\
    \ planet2) map { \e[36mp\e[0m => p -> (distances(p) + planetDistance(p, planet2,\
    \ planet1)) })\n\e[31m\e[31m   |\e[0m                                        \
    \                                             ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                                               Not found: planetDistance\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp00xcmwhi.scala:25:21\
    \ ------------------------\e[0m\e[0m\n\e[31m25 |\e[0m            distance <= distances(p2)\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue <= is\
    \ not a member of Nothing, but could be made available as an extension method.\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might fix the problem:\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m  import Byte.byte2double\n\e[31m   |\e[0m  import\
    \ Byte.byte2float\n\e[31m   |\e[0m  import Byte.byte2int\n\e[31m   |\e[0m  import\
    \ Byte.byte2long\n\e[31m   |\e[0m  import Byte.byte2short\n\e[31m   |\e[0m  import\
    \ Char.char2double\n\e[31m   |\e[0m  import Char.char2float\n\e[31m   |\e[0m \
    \ import Char.char2int\n\e[31m   |\e[0m  import Char.char2long\n\e[31m   |\e[0m\
    \  import math.BigDecimal.RoundingMode.ValueOrdering.mkOrderingOps\n\e[31m   |\e\
    [0m\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp00xcmwhi.scala:25:34 --------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m            distance <= distances(p2)\n\e[31m\e[31m \
    \  |\e[0m                                  ^^\e[0m\n\e[31m   |\e[0m          \
    \                        Found:    (p2 : (String, Double))\n\e[31m   |\e[0m  \
    \                                Required: String\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660009764
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val orbitsBetweenJupiterAndMercury = List(\n     \
    \       Planet(\"Mercury\", Orbit(Jupiter, Pluto(Venus, Earth)),\n           \
    \         Orbit(Mercury, Pluto(Venus, Earth), Orbit(Mercury, Pluto(Earth))),\n\
    \                    Orbit(Mercury, Pluto(Mars, Saturn), Orbit(Mercury, Pluto(Saturn)))),\n\
    \            Planet(\"Jupiter\", Orbit(Jupiter, Pluto(Venus, Earth)),\n      \
    \              Orbit(Jupiter, Pluto(Earth), Orbit(Jupiter, Pluto(Mars)))),\n \
    \           Planet(\"Saturn\", Orbit(Saturn, Pluto(Uranus, Neptune)),\n      \
    \              Orbit(Saturn, Pluto(Neptune, Earth), Orbit(Saturn, Pluto(Earth))),\n\
    \                    Orbit(Saturn, Pluto(Earth), Orbit(Saturn, Pluto(Mars))),\n\
    \                    Orbit(Saturn, Pluto(Mars, Saturn), Orbit(Saturn, Pluto(Mars))),\n\
    \                    Orbit(Saturn, Pluto(Mars, Saturn), Orbit(Saturn, Pluto(Mercury))),\n\
    \                    Orbit(Saturn, Pluto(Mercury, Saturn), Orbit(Saturn, Pluto(Mercury))),\n\
    \                    Orbit(Saturn, Pluto(Mercury, Saturn), Orbit(Saturn, Pluto(Venus))),\n\
    \                    Orbit(Saturn, Pluto(Venus, Saturn), Orbit(Saturn, Pluto(Venus))),\n\
    \                    Orbit(Saturn, Pluto(Venus, Saturn), Orbit(Saturn, Pluto(Earth))),\n\
    \                    Orbit(Saturn, Pluto(Earth), Orbit(Saturn, Pluto(Earth))),\n\
    \                    Orbit(Saturn, Pluto(Earth), Orbit(Saturn, Pluto(Venus))),\n\
    \                    Orbit(Saturn, Pluto(Venus, Saturn), Orbit(Saturn, Pluto(Venus))),\n\
    \                    Orbit(Saturn, Pluto(Venus, Saturn), Orbit(Saturn, Pluto(Earth))),\n\
    \                    Orbit(Saturn, Plu\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp0rlidynz.scala:41:4 ----------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp0rlidynz.scala:22:12\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m            Planet(\e[31m\"\
    Mercury\"\e[0m, Orbit(Jupiter, Pluto(Venus, Earth)),\n\e[31m\e[31m   |\e[0m  \
    \          ^^^^^^\e[0m\n\e[31m   |\e[0m            Not found: Planet\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp0rlidynz.scala:22:30 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m            Planet(\e[31m\"Mercury\"\e[0m, Orbit(Jupiter,\
    \ Pluto(Venus, Earth)),\n\e[31m\e[31m   |\e[0m                              ^^^^^\e\
    [0m\n\e[31m   |\e[0m                              Not found: Orbit\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp0rlidynz.scala:22:36 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m            Planet(\e[31m\"Mercury\"\e[0m, Orbit(Jupiter,\
    \ Pluto(Venus, Earth)),\n\e[31m\e[31m   |\e[0m                               \
    \     ^^^^^^^\e[0m\n\e[31m   |\e[0m                                    Not found:\
    \ Jupiter\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp0rlidynz.scala:22:45\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m            Planet(\e[31m\"\
    Mercury\"\e[0m, Orbit(Jupiter, Pluto(Venus, Earth)),\n\e[31m\e[31m   |\e[0m  \
    \                                           ^^^^^\e[0m\n\e[31m   |\e[0m      \
    \                                       Not found: Pluto\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmp0rlidynz.scala:22:51 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m            Planet(\e[31m\"Mercury\"\e[0m, Orbit(Jupiter,\
    \ Pluto(Venus, Earth)),\n\e[31m\e[31m   |\e[0m                               \
    \                    ^^^^^\e[0m\n\e["
  stdout: ''
  timestamp: 1660009764
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n    \n        val planets = List((\"Mercury\"),\n        \
    \                  (\"Venus\"),\n                          (\"Earth\"),\n    \
    \                      (\"Mars\"),\n                          (\"Jupiter\"),\n\
    \                          (\"Saturn\"),\n                          (\"Uranus\"\
    ),\n                          (\"Neptune\"))\n        val sortedPlanets = planets.sortWith(x\
    \ => distance(planet1, x._1))\n        val rangeBetweenPlanets = sortedPlanets.map(x\
    \ => distance(x,planet2))\n        \n        val sortedRange = rangeBetweenPlanets.sortWith(x\
    \ => distance(x, planet1))\n        val sunOrbit = sortedRange.map(x => x._2)\n\
    \        val planetsWithinSunOrbit = sortedPlanets.filter(x => sunOrbit.contains(x._1))\n\
    \        \n        return planetsWithinSunOrbit.map(x => x._2)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E086] Syntax Error: /tmp/tmpgv4t3wfs.scala:30:47 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36msortedPlanets\e[0m = planets.sortWith(\e\
    [36mx\e[0m => distance(planet1, x._1))\n\e[31m\e[31m   |\e[0m                \
    \                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                                 Wrong number of parameters, expected: 2\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpgv4t3wfs.scala:31:57 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mrangeBetweenPlanets\e[0m\
    \ = sortedPlanets.map(\e[36mx\e[0m => distance(x,planet2))\n\e[31m\e[31m   |\e\
    [0m                                                         ^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                                                     Not found: distance\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E086] Syntax Error: /tmp/tmpgv4t3wfs.scala:33:57\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36msortedRange\e[0m = rangeBetweenPlanets.sortWith(\e[36mx\e[0m => distance(x,\
    \ planet1))\n\e[31m\e[31m   |\e[0m                                           \
    \            ^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                 \
    \                Wrong number of parameters, expected: 2\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpgv4t3wfs.scala:34:46 ------------------------\e[0m\e\
    [0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36msunOrbit\e[0m = sortedRange.map(\e\
    [36mx\e[0m => x._2)\n\e[31m\e[31m   |\e[0m                                   \
    \         ^^^^\e[0m\n\e[31m   |\e[0m                                     value\
    \ _2 is not a member of Nothing\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpgv4t3wfs.scala:35:82\
    \ ------------------------\e[0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e\
    [36mplanetsWithinSunOrbit\e[0m = sortedPlanets.filter(\e[36mx\e[0m => sunOrbit.contains(x._1))\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                        ^^^^\e[0m\n\e[31m   |\e[0m                          \
    \            value _1 is not a member of Strin"
  stdout: ''
  timestamp: 1660009764
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n      val planets = List(\n        \"Mercury\", \"Venus\"\
    , \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \n        \"Uranus\", \"Neptune\"\
    )\n      val planets_1 = planets.filter(x => x != planet1)\n      val planets_2\
    \ = planets.filter(x => x != planet2)\n      val pairs = planets_1 zip planets_2\n\
    \      val distances = pairs.map(x => math.sqrt((x._1 - x._2)^2))\n      distances.toList.sortBy(x\
    \ => x).filter(x => x >= 0).take(8)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpp03n9csr.scala:27:53 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m      \e[33mval\e[0m \e[36mdistances\e[0m = pairs.map(\e\
    [36mx\e[0m => math.sqrt((x._1 - x._2)^\e[31m2\e[0m))\n\e[31m\e[31m   |\e[0m  \
    \                                              ^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ - is not a member of String, but could be made available as an extension method.\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might make progress\
    \ towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpp03n9csr.scala:28:62 --------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m      distances.toList.sortBy(\e[36mx\e[0m => x).filter(\e\
    [36mx\e[0m => x >= \e[31m0\e[0m).take(\e[31m8\e[0m)\n\e[31m\e[31m   |\e[0m   \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0m      Found:    List[Double]\n\e[31m   |\e[0m      Required: List[String]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660009766
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val orbit1 = Orbit.getOrbit(planet1)\n        val\
    \ orbit2 = Orbit.getOrbit(planet2)\n        val sun = Orbit.getSun\n        val\
    \ sun_dist1 = sun.distanceTo(orbit1)\n        val sun_dist2 = sun.distanceTo(orbit2)\n\
    \        val dist_diff1 = sun_dist1 - orbit1.distanceTo(sun)\n        val dist_diff2\
    \ = sun_dist2 - orbit2.distanceTo(sun)\n        if (dist_diff1 < dist_diff2) (planet1,\
    \ planet2)\n        else if (dist_diff1 > dist_diff2) (planet2, planet1)\n   \
    \     else (planet1 :: planet2 :: Nil)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmptpsfgw0z.scala:21:21 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36morbit1\e[0m = Orbit.getOrbit(planet1)\n\
    \e[31m\e[31m   |\e[0m                     ^^^^^\e[0m\n\e[31m   |\e[0m        \
    \             Not found: Orbit\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmptpsfgw0z.scala:22:21 ------------------------\e[0m\e[0m\n\e[31m22 |\e\
    [0m        \e[33mval\e[0m \e[36morbit2\e[0m = Orbit.getOrbit(planet2)\n\e[31m\e\
    [31m   |\e[0m                     ^^^^^\e[0m\n\e[31m   |\e[0m                \
    \     Not found: Orbit\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmptpsfgw0z.scala:23:18\
    \ ------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e\
    [36msun\e[0m = Orbit.getSun\n\e[31m\e[31m   |\e[0m                  ^^^^^\e[0m\n\
    \e[31m   |\e[0m                  Not found: Orbit\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmptpsfgw0z.scala:28:37 --------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mif\e[0m (dist_diff1 < dist_diff2) (planet1,\
    \ planet2)\n\e[31m\e[31m   |\e[0m                                     ^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                     Found:    (String, String)\n\
    \e[31m   |\e[0m                                     Required: List[String]\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmptpsfgw0z.scala:29:42\
    \ --------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33melse\e[0m \e[33mif\e\
    [0m (dist_diff1 > dist_diff2) (planet2, planet1)\n\e[31m\e[31m   |\e[0m      \
    \                                    ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                                          Found:    (String, String)\n\e[31m\
    \   |\e[0m                                          Required: List[String]\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation avail"
  stdout: ''
  timestamp: 1660009765
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        // Code here\n        var temp1 : List[String] = Nil\n\
    \        var temp2 : List[String] = Nil\n        var temp3 : List[String] = Nil\n\
    \        var temp4 : List[String] = Nil\n        var temp5 : List[String] = Nil\n\
    \        var temp6 : List[String] = Nil\n        var temp7 : List[String] = Nil\n\
    \        var temp8 : List[String] = Nil\n        temp1 = (Planets.filter(_._1.equals(planet1)).map(_._2).sorted).reverse\n\
    \        temp2 = (Planets.filter(_._1.equals(planet2)).map(_._2).sorted).reverse\n\
    \        temp3 = (temp1.zip(temp2)).sortBy(_._1).takeWhile(_.length < 2).map(_.swap)\n\
    \        temp4 = (temp3.zip(temp2.zipWithIndex.filter(_._2 != temp3.last)).sortBy(_._2).takeWhile(_.length\
    \ < 4).map(_.swap)).filterNot(_._2._1.equals(temp3.last)).filter(_._2._1.equals(temp3.last)).map(_._2._2.toString).toList\n\
    \        temp5 = (temp4.map(x => (x, temp4.indexOf(x) + 1)) -> temp4.filter(x\
    \ => x != temp4.indexOf(x + 1))).sortBy(_._1).map(_._2._2)\n        temp6 = (temp5.map(x\
    \ => (x, temp5.indexOf(x) + 1)) -> temp5.filter(x => x != temp5.indexOf(x + 1))).sortBy(_._1).map(_._2._2)\n\
    \        temp7 = (temp6.map(x => (x, temp6.indexOf(x) + 1)) -> temp6.filter(x\
    \ => x != temp6.indexOf(x + 1))).sortBy(_._1).map(_._2._2)\n        temp8 = (temp7.map(x\
    \ => (x, temp7.indexOf(x) + 1)) -> temp7.filter(x => x != temp7.indexOf(x + 1))).sortBy(_._1).map(_._2._2)\n\
    \        temp8.takeWhile(_.length < 8).sortBy(_._1).take(8).toList\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp66o6z1y5.scala:30:17 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        temp1 = (Planets.filter(_._1.equals(planet1)).map(_._2).sorted).reverse\n\
    \e[31m\e[31m   |\e[0m                 ^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \       Not found: Planets\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp66o6z1y5.scala:31:17 ------------------------\e[0m\e[0m\n\e[31m31 |\e\
    [0m        temp2 = (Planets.filter(_._1.equals(planet2)).map(_._2).sorted).reverse\n\
    \e[31m\e[31m   |\e[0m                 ^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \       Not found: Planets\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmp66o6z1y5.scala:32:60 ------------------------\e[0m\e[0m\n\e[31m32 |\e\
    [0m        temp3 = (temp1.zip(temp2)).sortBy(_._1).takeWhile(_.length < \e[31m2\e\
    [0m).map(_.swap)\n\e[31m\e[31m   |\e[0m                                      \
    \                    ^^^^^^^^\e[0m\n\e[31m   |\e[0m                        value\
    \ length is not a member of (String, String)\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp66o6z1y5.scala:32:78 --------------------\e[0m\e[0m\n\e[31m32\
    \ |\e[0m        temp3 = (temp1.zip(temp2)).sortBy(_._1).takeWhile(_.length < \e\
    [31m2\e[0m).map(_.swap)\n\e[31m\e[31m   |\e[0m                               \
    \                                             ^^^^^^\e[0m\n\e[31m   |\e[0m   \
    \                                           Found:    \e[1m\e[31m(\e[0m\e[1m\e\
    [31mString\e[0m\e[1m\e[31m,\e[0m\e[1m\e[31m \e[0mString\e[1m\e[31m)\e[0m\n\e[31m\
    \   |\e[0m                                              Required: String\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- Error: /tmp/tmp66o6z1y5.scala:33:53 -----------------------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        temp4 = (temp3.zip(temp2.zipWithIndex.filter(_._2\
    \ != temp3.last)).sortBy(_._2).takeWhile(_.length < \e[31m4\e[0m).map(_.swap)).filterNot(_._2._1.equals(temp3.last)).filter(_"
  stdout: ''
  timestamp: 1660009767
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val a = List(\"Mercury\",\"Venus\",\"Earth\",\"Mars\"\
    ,\"Jupiter\",\"Saturn\",\"Uranus\",\"Neptune\")\n        val b = List(\"Venus\"\
    ,\"Jupiter\",\"Mercury\",\"Saturn\",\"Uranus\",\"Neptune\",\"Earth\",\"Mars\"\
    )\n        val c = List(\"Mercury\",\"Jupiter\",\"Saturn\",\"Uranus\",\"Neptune\"\
    ,\"Earth\",\"Mars\",\"Venus\")\n        val d = List(\"Mars\",\"Jupiter\",\"Saturn\"\
    ,\"Uranus\",\"Neptune\",\"Earth\",\"Venus\",\"Mercury\")\n        val e = List(\"\
    Jupiter\",\"Saturn\",\"Uranus\",\"Neptune\",\"Earth\",\"Mars\",\"Venus\",\"Mercury\"\
    )\n        val f = List(\"Venus\",\"Saturn\",\"Uranus\",\"Neptune\",\"Earth\"\
    ,\"Mars\",\"Jupiter\",\"Mercury\")\n        val g = List(\"Saturn\",\"Uranus\"\
    ,\"Neptune\",\"Earth\",\"Mars\",\"Jupiter\",\"Mercury\",\"Venus\")\n        val\
    \ h = List(\"Uranus\",\"Neptune\",\"Earth\",\"Mars\",\"Jupiter\",\"Mercury\",\"\
    Venus\",\"Mars\")\n        val i = List(\"Neptune\",\"Earth\",\"Mars\",\"Jupiter\"\
    ,\"Mercury\",\"Venus\",\"Mars\",\"Uranus\")\n        val j = List(\"Neptune\"\
    ,\"Mars\",\"Jupiter\",\"Mercury\",\"Venus\",\"Uranus\",\"Earth\",\"Mars\")\n \
    \       val k = List(\"Earth\",\"Mars\",\"Jupiter\",\"Mercury\",\"Venus\",\"Uranus\"\
    ,\"Mars\",\"Uranus\")\n        val l = List(\"Earth\",\"Mars\",\"Jupiter\",\"\
    Mercury\",\"Venus\",\"Uranus\",\"Neptune\",\"Mars\")\n        val m = List(\"\
    Jupiter\",\"Mercury\",\"Venus\",\"Uranus\",\"Neptune\",\"Mars\",\"Earth\",\"Mars\"\
    )\n        val n = List(\"Jupiter\",\"Mercury\",\"Venus\",\"Uranus\",\"Neptune\"\
    ,\"Earth\",\"Mars\",\"Mars\")\n        val o = List(\"Jupiter\",\"Mercury\",\"\
    Saturn\",\"Uranus\",\"Neptune\",\"Earth\",\"Mars\",\"Mars\")\n        val p =\
    \ List(\"Saturn\",\"Uranus\",\"Ne\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpmgbp4lvf.scala:36:39 -----------------------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36mp\e[0m = List(\e[31m\"Saturn\"\
    \e[0m,\e[31m\"Uranus\"\e[0m,\"Ne\n\e[31m\e[31m   |\e[0m                      \
    \                 ^\e[0m\n\e[31m   |\e[0m                                    \
    \   unclosed string literal\n\e[31m\e[31m-- Error: /tmp/tmpmgbp4lvf.scala:38:34\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m38 |\e[0m    \e[33mdef\e\
    [0m \e[36mmain\e[0m(\e[36margs\e[0m: \e[35mArray\e[0m[\e[35mString\e[0m]) = {\n\
    \e[31m\e[31m   |\e[0m                                  ^\e[0m\n\e[31m   |\e[0m\
    \                                 end of statement expected but '=' found\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpmgbp4lvf.scala:37:5 ---------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: List[String]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmgbp4lvf.scala:38:4 -------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[31m\e[31m   |\e[0m    ^^^\e[0m\n\e\
    [31m   |\e[0m    Not found: Nedef\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660009764
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\n            (\"Mercury\"),\n\
    \            (\"Venus\"),\n            (\"Earth\"),\n            (\"Mars\"),\n\
    \            (\"Jupiter\"),\n            (\"Saturn\"),\n            (\"Uranus\"\
    ),\n            (\"Neptune\")\n        )\n        val sun = Orbit.sun\n      \
    \  val sunPos = Vector(sun.pos.x, sun.pos.y)\n        val planet1Pos = Vector(planets.indexOf(planet1),\
    \ sun.pos.z)\n        val planet2Pos = Vector(planets.indexOf(planet2), sun.pos.z)\n\
    \        val distance = Vector.subtract(sunPos, planet1Pos)\n        val angleBetweenPlanets\
    \ = Vector.angleBetween(distance, planet2Pos)\n        val closest = Vector.min(Vector.subtract(distance,\
    \ Vector.multiply(angleBetweenPlanets, distance)))\n        val nearPlanets =\
    \ Vector.subtract(planet2Pos, closest)\n        val nearPlanets = Vector.min(Vector.subtract(distance,\
    \ Vector.multiply(angleBetweenPlanets, distance)))\n        val nearPlanets =\
    \ Vector.min(Vector.subtract(distance, Vector.multiply(angleBetweenPlanets, distance)))\n\
    \        val nearPlanets = Vector.min(Vector.subtract(distance, Vector.multiply(angleBetweenPlanets,\
    \ distance)))\n        val nearPlanets = Vector.min(Vector.subtract(distance,\
    \ Vector.multiply(angleBetweenPlanets, distance)))\n        val nearPlanets =\
    \ Vector.min(Vector.subtract(distance, Vector.multiply(angleBetweenPlanets, distance)))\n\
    \        val nearPlanets = Vector.min(Vector.subtract(distance, Vector.multiply(angleBetweenPlanets,\
    \ distance)))\n        val nearPlanets = Vector.min(Vector.subtract(distance,\
    \ Vector.multiply(angleBetweenPlanets, distance)))\n        val nearPlanets =\
    \ Vector.min(Vector.subtract(distance, Vector.multiply(angleBetweenPlanets, distance)))\n\
    \        val nearPlanets = Vector.min(Vector.subtract(distance, Vector.multiply(angleBetweenPlanets,\
    \ distance)))\n        val nearPlanets = Vector.min(Vector.subtract(distance,\
    \ Vector.multiply(angleBetweenPlanets, distance)))\n        val nearPlanets =\
    \ Vector.min(Vector.subtract(distance, Vector.multiply(angleBetweenPlanets, distance)))\n\
    \        val nearPlanets = Vector.min(Vector.subtract(distance, Vector.multiply(angleBetweenPlanets,\
    \ distance)))\n        val nearPlanets = Vector.min(Vector.subtract(distance,\
    \ Vector.multiply(angleBetweenPlanets, distance)))\n        val nearPlanets =\
    \ Vector.min(Vector.subtract(distance, Vector.multiply(angleBetween\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpic46g5j6.scala:53:4 ----------------------------\e\
    [0m\e[0m\n\e[31m53 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpic46g5j6.scala:39:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m\
    \ \e[36mnearPlanets\e[0m = Vector.min(Vector.subtract(distance, Vector.multiply(angleBetweenPlanets,\
    \ distance)))\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mnearPlanets is already defined as \e[33mvalue\e[0m \e[35mnearPlanets\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpic46g5j6.scala:40:12 ---------------------------\e[0m\e[0m\n\e\
    [31m40 |\e[0m        \e[33mval\e[0m \e[36mnearPlanets\e[0m = Vector.min(Vector.subtract(distance,\
    \ Vector.multiply(angleBetweenPlanets, distance)))\n\e[31m\e[31m   |\e[0m    \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mnearPlanets is already defined as \e[33mvalue\e[0m \e[35mnearPlanets\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpic46g5j6.scala:41:12 ---------------------------\e[0m\e[0m\n\e\
    [31m41 |\e[0m        \e[33mval\e[0m \e[36mnearPlanets\e[0m = Vector.min(Vector.subtract(distance,\
    \ Vector.multiply(angleBetweenPlanets, distance)))\n\e[31m\e[31m   |\e[0m    \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mnearPlanets is already defined as \e[33mvalue\e[0m \e[35mnearPlanets\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpic46g5j6.scala:42:12 ---------------------------\e[0m\e[0m\n\e\
    [31m42 |\e[0m        \e[33mv"
  stdout: ''
  timestamp: 1660009767
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        if(planet1.toUpperCase != planet2.toUpperCase) List(planet1,\
    \ planet2)\n        else {\n            val solarSystem = \n              new\
    \ OrbitalSystem(\n                new Planet(\"Mercury\", 1.05),\n           \
    \     new Planet(\"Venus\", 0.91),\n                new Planet(\"Earth\", 0.84),\n\
    \                new Planet(\"Mars\", 0.72),\n                new Planet(\"Jupiter\"\
    , 0.5),\n                new Planet(\"Saturn\", 0.44),\n                new Planet(\"\
    Uranus\", 0.34),\n                new Planet(\"Neptune\", 0.24))\n           \
    \ val sunOrbit = solarSystem.orbit(planet1.toUpperCase)\n            val sunOrbit2\
    \ = solarSystem.orbit(planet2.toUpperCase)\n            val orbits = solarSystem.orbits(planet1.toUpperCase,\
    \ planet2.toUpperCase)\n            val orbits2 = solarSystem.orbits(planet2.toUpperCase,\
    \ planet1.toUpperCase)\n            val distance = solarSystem.distanceBetween(planet1.toUpperCase,\
    \ planet2.toUpperCase)\n            val distance2 = solarSystem.distanceBetween(planet2.toUpperCase,\
    \ planet1.toUpperCase)\n            val distance3 = solarSystem.distanceBetween(planet1.toUpperCase,\
    \ planet2.toUpperCase)\n            val distance4 = solarSystem.distanceBetween(planet1.toUpperCase,\
    \ planet2.toUpperCase)\n            val distance5 = solarSystem.distanceBetween(planet2.toUpperCase,\
    \ planet1.toUpperCase)\n            val distance6 = solarSystem.distanceBetween(planet2.toUpperCase,\
    \ planet1.toUpperCase)\n            val distance7 = solarSystem.distanceBetween(planet2.toUpperCase,\
    \ planet1.toUpperCase)\n            val distance8 = solarSystem.distanceBetween(planet2.toUpperCase,\
    \ planet1.toUpperCase)\n            val distance9 = solarSystem.distanceBetween(planet2.toUpperCase,\
    \ planet1.toUpperCase)\n            val distance10 = solarSystem.distanceBetween(planet2.toUpperCase,\
    \ planet1.toUpperCase)\n            val distance11 = solarSystem.distanceBetween(planet2.toUpperCase,\
    \ planet1.toUpperCase)\n            val distance12 = solarSystem.distanceBetween(planet2.toUpperCase,\
    \ planet1.toUpperCase)\n            val distance13 = solarSystem.distanceBetween(planet2.toUpperCase,\
    \ planet1.toUpperCase)\n            val distance14 = solarSystem.distanceBetween(planet2.toUpperCase,\
    \ plan\n    }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"\
    ), (\"Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp9q46xyj0.scala:51:4 ----------------------------\e\
    [0m\e[0m\n\e[31m51 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp9q46xyj0.scala:63:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m63 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E006] Not\
    \ Found Error: /tmp/tmp9q46xyj0.scala:24:18 ------------------------\e[0m\e[0m\n\
    \e[31m24 |\e[0m              \e[33mnew\e[0m \e[35mOrbitalSystem\e[0m(\n\e[31m\e\
    [31m   |\e[0m                  ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m           \
    \       Not found: type OrbitalSystem\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmp9q46xyj0.scala:62:1 ---------------------\e[0m\e\
    [0m\n\e[31m62 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e[0m\n\e[31m   |\e[0m Found:  \
    \  Unit\n\e[31m   |\e[0m Required: List[String]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[33m\e[33m--\
    \ Warning: /tmp/tmp9q46xyj0.scala:52:4 ----------------------------------------\e\
    [0m\e[0m\n\e[33m52 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m\
    \   |\e[0m    Line is indented too far to the left, or a `}` is missing\n1 warning\
    \ found\n4 errors found\n"
  stdout: ''
  timestamp: 1660009766
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        var result = List[String]()\n        \n        //\
    \ Planet 1\n        result ++= List(planet1 + \"Jupiter\", planet1 + \"Earth\"\
    , planet1 + \"Mars\", planet1 + \"Mercury\", planet1 + \"Neptune\")\n        \n\
    \        // Planet 2\n        result ++= List(planet2 + \"Jupiter\", planet2 +\
    \ \"Earth\", planet2 + \"Mars\", planet2 + \"Mercury\", planet2 + \"Neptune\"\
    )\n        \n        // Jupiter and Earth Orbit to Venus\n        result ++= List(planet1\
    \ + \"Jupiter\", \"Earth\" -> planet1 + \"Venus\")\n        \n        // Mars\
    \ and Mercury Orbit to Venus\n        result ++= List(planet1 + \"Mars\", \"Mercury\"\
    \ -> planet1 + \"Venus\")\n        \n        // Jupiter and Earth Orbit to Mercury\n\
    \        result ++= List(planet1 -> planet1 + \"Mercury\", planet1 + \"Earth\"\
    )\n        \n        // Jupiter and Earth Orbit to Venus\n        result ++= List(planet1\
    \ -> planet1 + \"Jupiter\", planet1 + \"Earth\")\n        \n        // Mercury\
    \ and Earth Orbit to Mercury\n        result ++= List(planet1 -> planet1 + \"\
    Mercury\", planet1 + \"Earth\")\n        \n        // Mercury and Earth Orbit\
    \ to Venus\n        result ++= List(planet1 -> planet1 + \"Mercury\", planet1\
    \ -> \"Venus\")\n        \n        // Neptune and Earth Orbit to Mars\n      \
    \  result ++= List(planet1 -> planet1 + \"Neptune\", planet1 -> \"Mars\")\n  \
    \      \n        // Neptune and Earth Orbit to Mercury\n        result ++= List(planet1\
    \ -> planet1 + \"Neptune\", planet1 -> \"Mercury\")\n        \n        // Neptune\
    \ and Earth Orbit to Venus\n        result ++= List(planet1 -> planet1 + \"Neptune\"\
    , planet1 -> \"Venus\")\n        \n        // Jupiter and Earth Orbit to Mercury\n\
    \        result ++= List(planet1 -> planet1 + \"Jupiter\", planet1 -> \"Mercury\"\
    )\n        \n        // Jupiter and \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpvlj64lrc.scala:30:15 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        result ++= List(planet1 + \e[31m\"Jupiter\"\e\
    [0m, \e[31m\"Earth\"\e[0m -> planet1 + \e[31m\"Venus\"\e[0m)\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue ++= is not a member of List[String]\
    \ - did you mean List[String].++?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpvlj64lrc.scala:30:64\
    \ ------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        result ++= List(planet1\
    \ + \e[31m\"Jupiter\"\e[0m, \e[31m\"Earth\"\e[0m -> planet1 + \e[31m\"Venus\"\e\
    [0m)\n\e[31m\e[31m   |\e[0m                                             ^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue + is not a member of (String, String), but could be\
    \ made available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne\
    \ of the following imports might make progress towards fixing the problem:\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpvlj64lrc.scala:33:15 ------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        result ++= List(planet1 + \e[31m\"Mars\"\e[0m,\
    \ \e[31m\"Mercury\"\e[0m -> planet1 + \e[31m\"Venus\"\e[0m)\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue ++= is not a member of List[String]\
    \ - did you mean List[String].++?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpvlj64lrc.scala:33:63\
    \ ------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        result ++= List(planet1\
    \ + \e[31m\"Mars\"\e[0m, \e[31m\"Mercury\"\e[0m -> planet1 + \e[31m\"Venus\"\e\
    [0m)\n\e[31m\e[31m   |\e[0m                                          ^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue + is not a member of (String, String), but could be\
    \ made available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne\
    \ of the following imports might make progress towards fixing the problem:\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral"
  stdout: ''
  timestamp: 1660009772
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val orb1 = planetOrbit(planet1)\n        val orb2\
    \ = planetOrbit(planet2)\n        // Find the nearest orbital to planet1 \n  \
    \      val nearest1 = findNearest(planetOrbit(planet1), orb1)\n        // Find\
    \ the nearest orbital to planet2 \n        val nearest2 = findNearest(planetOrbit(planet2),\
    \ orb2)\n        // Find the orbits that are located between the two planets \n\
    \        val orbits = orbits(nearest1, nearest2)\n        // Sort the planets\
    \ by proximity to the sun \n        val sortedOrbits = orbits.sortBy(x => x.distance(planetOrbit(planet1)))\n\
    \        val sortedPlanets = sortedOrbits.map(x => x.name)\n        sortedPlanets\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"\
    Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpxzdl9sca.scala:21:19 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36morb1\e[0m = planetOrbit(planet1)\n\
    \e[31m\e[31m   |\e[0m                   ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \               Not found: planetOrbit\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpxzdl9sca.scala:22:19 ------------------------\e[0m\e\
    [0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36morb2\e[0m = planetOrbit(planet2)\n\
    \e[31m\e[31m   |\e[0m                   ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \               Not found: planetOrbit\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpxzdl9sca.scala:24:23 ------------------------\e[0m\e\
    [0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mnearest1\e[0m = findNearest(planetOrbit(planet1),\
    \ orb1)\n\e[31m\e[31m   |\e[0m                       ^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                       Not found: findNearest\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpxzdl9sca.scala:24:35 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mnearest1\e[0m = findNearest(planetOrbit(planet1),\
    \ orb1)\n\e[31m\e[31m   |\e[0m                                   ^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                   Not found: planetOrbit\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpxzdl9sca.scala:26:23\
    \ ------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e\
    [36mnearest2\e[0m = findNearest(planetOrbit(planet2), orb2)\n\e[31m\e[31m   |\e\
    [0m                       ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                  \
    \     Not found: findNearest\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpxzdl9sca.scala:26:35 ------------------------\e[0m\e[0m\n\e["
  stdout: ''
  timestamp: 1660009765
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        if (planet1.equals(\"Earth\") && planet2.equals(\"\
    Mars\"))\n            return List((\"Venus\"))\n        if (planet1.equals(\"\
    Mars\") && planet2.equals(\"Earth\"))\n            return List((\"Jupiter\"))\n\
    \        if (planet1.equals(\"Jupiter\") && planet2.equals(\"Earth\"))\n     \
    \       return List((\"Saturn\", \"Uranus\"))\n        if (planet1.equals(\"Saturn\"\
    ) && planet2.equals(\"Mercury\"))\n            return List((\"Uranus\"))\n   \
    \     if (planet1.equals(\"Uranus\") && planet2.equals(\"Mercury\"))\n       \
    \     return List((\"Saturn\", \"Venus\"))\n        if (planet1.equals(\"Venus\"\
    ) && planet2.equals(\"Jupiter\"))\n            return List((\"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n        if (planet1.equals(\"Mars\") && planet2.equals(\"\
    Jupiter\"))\n            return List((\"Earth\", \"Venus\", \"Saturn\", \"Uranus\"\
    ))\n        if (planet1.equals(\"Jupiter\") && planet2.equals(\"Saturn\"))\n \
    \           return List((\"Earth\", \"Mars\", \"Uranus\", \"Venus\"))\n      \
    \  if (planet1.equals(\"Uranus\") && planet2.equals(\"Saturn\"))\n           \
    \ return List((\"Earth\", \"Jupiter\", \"Mars\", \"Venus\"))\n        if (planet1.equals(\"\
    Venus\") && planet2.equals(\"Jupiter\"))\n            return List((\"Earth\",\
    \ \"Mars\", \"Saturn\", \"Uranus\"))\n        if (planet1.equals(\"Mars\") &&\
    \ planet2.equals(\"Saturn\"))\n            return List((\"Earth\", \"Jupiter\"\
    , \"Uranus\", \"Venus\"))\n        if (planet1.equals(\"Jupiter\") && planet2.equals(\"\
    Uranus\"))\n            return List((\"Earth\", \"Mars\", \"Venus\", \"Saturn\"\
    ))\n        if (planet1.equals(\"Uranus\") && planet2.equals(\"Venus\"))\n   \
    \         return List((\"Earth\", \"Jupiter\", \"Mars\", \"Saturn\"))\n      \
    \  if (planet1.equals(\"Venus\") && planet2.equals(\"Jupiter\"))\n           \
    \ return List((\"Earth\", \"Mars\", \"Uranus\", \"Saturn\"))\n        if (planet1.equals(\"\
    Mars\") && planet2.equals(\"Uranus\"))\n            return List((\"Earth\", \"\
    Jupiter\", \"Venus\", \"Uranus\"))\n        if (planet1.equals(\"Jupiter\") &&\
    \ planet2.equals(\"Venus\n    }\n    def main(args: Array[String]) = {\n    assert(bf((\"\
    Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n\
    \    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n\
    \    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"),\
    \ (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpbug5khuu.scala:51:56 -----------------------------------------\e\
    [0m\e[0m\n\e[31m51 |\e[0m        \e[33mif\e[0m (planet1.equals(\e[31m\"Jupiter\"\
    \e[0m) && planet2.equals(\"Venus\n\e[31m\e[31m   |\e[0m                      \
    \                                  ^\e[0m\n\e[31m   |\e[0m                   \
    \                              unclosed string literal\n\e[31m\e[31m-- Error:\
    \ /tmp/tmpbug5khuu.scala:53:34 -----------------------------------------\e[0m\e\
    [0m\n\e[31m53 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e[35mArray\e\
    [0m[\e[35mString\e[0m]) = {\n\e[31m\e[31m   |\e[0m                           \
    \       ^\e[0m\n\e[31m   |\e[0m                                 end of statement\
    \ expected but '=' found\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpbug5khuu.scala:26:24\
    \ --------------------\e[0m\e[0m\n\e[31m26 |\e[0m            \e[33mreturn\e[0m\
    \ List((\e[31m\"Saturn\"\e[0m, \e[31m\"Uranus\"\e[0m))\n\e[31m\e[31m   |\e[0m\
    \                        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \              Found:    \e[1m\e[31m(\e[0m\e[1m\e[31mString\e[0m\e[1m\e[31m,\e\
    [0m\e[1m\e[31m \e[0mString\e[1m\e[31m)\e[0m\n\e[31m   |\e[0m                 \
    \       Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpbug5khuu.scala:30:24 --------------------\e[0m\e[0m\n\e[31m30\
    \ |\e[0m            \e[33mreturn\e[0m List((\e[31m\"Saturn\"\e[0m, \e[31m\"Venus\"\
    \e[0m))\n\e[31m\e[31m   |\e[0m                        ^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                        Found:    \e[1m\e[31m(\e[0m\e[1m\e[31mString\e\
    [0m\e[1m\e[31m,\e[0m\e[1m\e[31m \e[0mString\e[1m\e[31m)\e[0m\n\e[31m   |\e[0m\
    \                        Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpbug5khuu.scala:32:24 --------------------\e[0m\e\
    [0m\n\e[31m32 |\e[0m            \e[33mreturn\e[0m List((\e[31m\"Earth\"\e[0m,\
    \ \e[31m\"Mars\"\e[0m, \e[31m\"Jupiter\"\e[0m, \e[31m\"Saturn\"\e[0m))\n\e[31m\e\
    [31m   |\e[0m                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n"
  stdout: ''
  timestamp: 1660009771
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        // Your code goes here\n        val earth_orbit =\
    \ scala.math.Orbit.ofBodyAndPlanet(\"Earth\", \"Sun\")\n        val mercury_orbit\
    \ = scala.math.Orbit.ofBodyAndPlanet(\"Mercury\", \"Sun\")\n        val venus_orbit\
    \ = scala.math.Orbit.ofBodyAndPlanet(\"Venus\", \"Sun\")\n        val mars_orbit\
    \ = scala.math.Orbit.ofBodyAndPlanet(\"Mars\", \"Sun\")\n        val jupiter_orbit\
    \ = scala.math.Orbit.ofBodyAndPlanet(\"Jupiter\", \"Sun\")\n        val saturn_orbit\
    \ = scala.math.Orbit.ofBodyAndPlanet(\"Saturn\", \"Sun\")\n        val uranus_orbit\
    \ = scala.math.Orbit.ofBodyAndPlanet(\"Uranus\", \"Sun\")\n        val neptune_orbit\
    \ = scala.math.Orbit.ofBodyAndPlanet(\"Neptune\", \"Sun\")\n        val earth_planet_orbit\
    \ = scala.math.Orbit.ofBodyAndPlanet(\"Earth\", planet1)\n        val mercury_planet_orbit\
    \ = scala.math.Orbit.ofBodyAndPlanet(\"Mercury\", planet1)\n        val venus_planet_orbit\
    \ = scala.math.Orbit.ofBodyAndPlanet(\"Venus\", planet1)\n        val mars_planet_orbit\
    \ = scala.math.Orbit.ofBodyAndPlanet(\"Mars\", planet1)\n        val jupiter_planet_orbit\
    \ = scala.math.Orbit.ofBodyAndPlanet(\"Jupiter\", planet1)\n        val saturn_planet_orbit\
    \ = scala.math.Orbit.ofBodyAndPlanet(\"Saturn\", planet1)\n        val uranus_planet_orbit\
    \ = scala.math.Orbit.ofBodyAndPlanet(\"Uranus\", planet1)\n        val neptune_planet_orbit\
    \ = scala.math.Orbit.ofBodyAndPlanet(\"Neptune\", planet1)\n        val earth_planet_planet_orbit\
    \ = scala.math.Orbit.ofBodyAndPlanet(planet1, planet1)\n        val mercury_planet_planet_orbit\
    \ = scala.math.Orbit.ofBodyAndPlanet(planet1, planet2)\n        val venus_planet_planet_orbit\
    \ = scala.math.Orbit.ofBodyAndPlanet(plan\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpzatxg0h0.scala:41:4 ----------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpzatxg0h0.scala:22:37\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mearth_orbit\e[0m = scala.math.Orbit.ofBodyAndPlanet(\e[31m\"Earth\"\e[0m,\
    \ \e[31m\"Sun\"\e[0m)\n\e[31m\e[31m   |\e[0m                          ^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                          value Orbit is not a member of math\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpzatxg0h0.scala:23:39 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mmercury_orbit\e[0m = scala.math.Orbit.ofBodyAndPlanet(\e\
    [31m\"Mercury\"\e[0m, \e[31m\"Sun\"\e[0m)\n\e[31m\e[31m   |\e[0m             \
    \               ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                       \
    \     value Orbit is not a member of math\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpzatxg0h0.scala:24:37 ------------------------\e[0m\e[0m\n\e[31m24 |\e\
    [0m        \e[33mval\e[0m \e[36mvenus_orbit\e[0m = scala.math.Orbit.ofBodyAndPlanet(\e\
    [31m\"Venus\"\e[0m, \e[31m\"Sun\"\e[0m)\n\e[31m\e[31m   |\e[0m               \
    \           ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                          value\
    \ Orbit is not a member of math\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpzatxg0h0.scala:25:36\
    \ ------------------------\e[0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e\
    [36mmars_orbit\e[0m = scala.math.Orbit.ofBodyAndPlanet(\e[31m\"Mars\"\e[0m, \e\
    [31m\"Sun\"\e[0m)\n\e[31m\e[31m   |\e[0m                         ^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                         value Orbit is not a member of math\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpzatxg0h0.scala:26:39 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mjupiter_orbit\e[0m = scala.math.Orbit.ofBodyAndPlanet(\e\
    [31m\"Jupiter\"\e[0m, \e[31m\"Sun\"\e[0m)\n\e[31m\e[31m   |\e[0m             \
    \               ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                       \
    \     value Orbit is not a member of math\n\e[31m\e[31m-- [E008] Not Found "
  stdout: ''
  timestamp: 1660009771
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val p1 = planets.filter(_.name == planet1)\n     \
    \   val p2 = planets.filter(_.name == planet2)\n        val p3 = p2.take(p1.length)\n\
    \        val p4 = p2.drop(p1.length)\n        val orbs = p3.map(p4 => (p1.map(_.orbit.longitude).zip(\n\
    \            p4.map(_.orbit.longitude)).map(x => x.diff(x)).sum))\n        val\
    \ s = orbs.map(_._2).sum\n        if(orbs.isEmpty) Nil\n        else (orbs sortBy\
    \ (_._2 - s) map {_._1}).reverse\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\",\
    \ \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp9fxsq5u1.scala:21:17 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mp1\e[0m = planets.filter(_.name\
    \ == planet1)\n\e[31m\e[31m   |\e[0m                 ^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                 Not found: planets\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmp9fxsq5u1.scala:22:17 ------------------------\e[0m\e\
    [0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mp2\e[0m = planets.filter(_.name\
    \ == planet2)\n\e[31m\e[31m   |\e[0m                 ^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                 Not found: planets\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660009766
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        def getPlanetList(planet1 : String, planet2 : String)\
    \ : List[String] = {\n            val name1 = planet1.toUpperCase\n          \
    \  val name2 = planet2.toUpperCase\n            val planet1List = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n            val planet2List = List(\"Mercury\", \"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n            planet1List.zip(planet2List).map\
    \ { case (name1item, name2item) =>\n                if (name1item == name2) {\n\
    \                    if (name2item == \"Mercury\")\n                        name1item\n\
    \                    else if (name2item == \"Venus\")\n                      \
    \  name1item + \", \" + name2item\n                    else if (name2item == \"\
    Earth\")\n                        name1item + \", \" + name2item + \", \" + name1item\n\
    \                    else if (name2item == \"Mars\")\n                       \
    \ name1item + \", \" + name2item + \", \" + name1item + \", \" + name1item\n \
    \                   else if (name2item == \"Jupiter\")\n                     \
    \   name1item + \", \" + name2item + \", \" + name1item + \", \" + name1item +\
    \ \", \" + name2item\n                    else if (name2item == \"Saturn\")\n\
    \                        name1item + \", \" + name2item + \", \" + name1item +\
    \ \", \" + name1item + \", \" + name2item + \", \" + name1item\n             \
    \       else if (name2item == \"Uranus\")\n                        name1item +\
    \ \", \" + name2item + \", \" + name1item + \", \" + name1item + \", \" + name2item\
    \ + \", \" + name1item + \", \" + name1item\n                    else if (name2item\
    \ == \"Neptune\")\n                        name1item + \", \" + name2item + \"\
    , \" + name1item + \", \" + name1item + \", \" + name2item + \", \" + name1item\
    \ + \", \" + name1item + \", \" + name2item\n                }\n            }.filter\
    \ { planetItem =>\n                val planet1List = planet1List.toList\n    \
    \            val planet2List = planet2List.toList\n                val name1 =\
    \ planet1List.last\n                val name2 = planet2List.last\n           \
    \     if (name1 == name2) {\n                    if (name1 == \"Mercury\") {\n\
    \                        if (name2 == \"Mercury\")\n                         \
    \   true\n\n    }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"\
    ), (\"Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp620zyw0b.scala:67:0 ----------------------------\e\
    [0m\e[0m\n\e[31m67 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp620zyw0b.scala:50:16\
    \ --------------------\e[0m\e[0m\n\e[31m50 |\e[0m                \e[33mif\e[0m\
    \ (name1 == name2) {\n\e[31m\e[31m   |\e[0m                ^\e[0m\n\e[31m   |\e\
    [0m                Found:    Unit\n\e[31m   |\e[0m                Required: Boolean\n\
    \e[31m   |\e[0m                Maybe you are missing an else part for the conditional?\n\
    \e[31m51 |\e[0m                    \e[33mif\e[0m (name1 == \e[31m\"Mercury\"\e\
    [0m) {\n\e[31m52 |\e[0m                        \e[33mif\e[0m (name2 == \e[31m\"\
    Mercury\"\e[0m)\n\e[31m53 |\e[0m                            \e[31mtrue\e[0m\n\e\
    [31m54 |\e[0m    }\n\e[31m55 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e\
    [0m: \e[35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[31m56 |\e[0m    assert(bf((\e\
    [31m\"Jupiter\"\e[0m), (\e[31m\"Neptune\"\e[0m)).equals((List[\e[35mString\e[0m](\e\
    [31m\"Saturn\"\e[0m, \e[31m\"Uranus\"\e[0m))));\n\e[31m57 |\e[0m    assert(bf((\e\
    [31m\"Earth\"\e[0m), (\e[31m\"Mercury\"\e[0m)).equals((List[\e[35mString\e[0m](\e\
    [31m\"Venus\"\e[0m))));\n\e[31m58 |\e[0m    assert(bf((\e[31m\"Mercury\"\e[0m),\
    \ (\e[31m\"Uranus\"\e[0m)).equals((List[\e[35mString\e[0m](\e[31m\"Venus\"\e[0m,\
    \ \e[31m\"Earth\"\e[0m, \e[31m\"Mars\"\e[0m, \e[31m\"Jupiter\"\e[0m, \e[31m\"\
    Saturn\"\e[0m))));\n\e[31m59 |\e[0m    assert(bf((\e[31m\"Neptune\"\e[0m), (\e\
    [31m\"Venus\"\e[0m)).equals((List[\e[35mString\e[0m](\e[31m\"Earth\"\e[0m, \e\
    [31m\"Mars\"\e[0m, \e[31m\"Jupiter\"\e[0m, \e[31m\"Saturn\"\e[0m, \e[31m\"Uranus\"\
    \e[0m))));\n\e[31m60 |\e[0m    assert(bf((\e[31m\"Earth\"\e[0m), (\e[31m\"Earth\"\
    \e[0m)).equals((List[\e[35mString\e[0m]())));\n\e[31m61 |\e[0m    assert(bf((\e\
    [31m\"Mars\"\e[0m), (\e[31m\"Earth\"\e[0m)).equals((List[\e[35mString\e[0m]())));\n\
    \e[31m62 |\e[0m    assert(bf((\e[31m\"Jupiter\"\e[0m), (\e[31m\"Makemake\"\e[0m)).equals((List[\e\
    [35mString\e[0m]())));\n\e[31m63 |\e[0m    }\n\e[31m64 |\e[0m}\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [33m\e[33m-- [E129] Potential Issue Warning: /tmp/tmp620zyw0b.scala:29:24 ----"
  stdout: ''
  timestamp: 1660009768
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List((\"Mercury\"), (\"Venus\"), (\"\
    Earth\"), (\"Mars\"),\n                (\"Jupiter\"), (\"Saturn\"), (\"Uranus\"\
    ), (\"Neptune\"), (\"Venus\"))\n        var planet1 : Option[String] = Option(planet1)\n\
    \        var planet2 : Option[String] = Option(planet2)\n        var output: List[String]\
    \ = Nil\n        var x = 0\n        var y = 0\n        var i = 0\n        while\
    \ (i < planets.length) {\n            val p1 = planets(i).trim\n            val\
    \ p2 = planets(i + 1).trim\n            if (planet1.toString == p1 && planet2.toString\
    \ == p2) {\n                output = List(planets(i))\n                i += 1\n\
    \            } else {\n                if (planet1.toString == p1) {\n       \
    \             planet1 = planet1.getOrElse(planet1)\n                    x = x\
    \ + 1\n                } else if (planet2.toString == p2) {\n                \
    \    planet2 = planet2.getOrElse(planet2)\n                    y = y + 1\n   \
    \             }\n                while (x < y && planets.exists(_.trim.equals(planets(x))))\
    \ {\n                    x = x + 1\n                }\n                while (x\
    \ > y && planets.exists(_.trim.equals(planets(x)))) {\n                    y =\
    \ y + 1\n                }\n            }\n        }\n        output\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp9u2hiivj.scala:23:46\
    \ --------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mvar\e[0m \e[36mplanet1\e\
    [0m : \e[35mOption\e[0m[\e[35mString\e[0m] = Option(planet1)\n\e[31m\e[31m   |\e\
    [0m                                              ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                                    Found:    (planet1 : Option[String])\n\e\
    [31m   |\e[0m                                    Required: String\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp9u2hiivj.scala:24:46 --------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mvar\e[0m \e[36mplanet2\e[0m : \e[35mOption\e\
    [0m[\e[35mString\e[0m] = Option(planet2)\n\e[31m\e[31m   |\e[0m              \
    \                                ^^^^^^^\e[0m\n\e[31m   |\e[0m               \
    \                     Found:    (planet2 : Option[String])\n\e[31m   |\e[0m  \
    \                                  Required: String\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmp9u2hiivj.scala:37:47 --------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m                    planet1 = planet1.getOrElse(planet1)\n\
    \e[31m\e[31m   |\e[0m                              ^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                              Found:    Object\n\e[31m   |\e\
    [0m                              Required: Option[String]\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp9u2hiivj.scala:40:47 --------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m                    planet2 = planet2.getOrElse(planet2)\n\
    \e[31m\e[31m   |\e[0m                              ^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                              Found:    Object\n\e[31m   |\e\
    [0m                              Required: Option[String]\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n4 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660009772
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        def distance(planet1 : String, planet2 : String) \n\
    \          = scala.math.abs(planet1 - planet2)\n        def orbits(planet1 : String,\
    \ planet2 : String) \n          = ((planet1 -> planet2), (planet2 -> planet1))\n\
    \        def neighbors(planet1 : String, planet2 : String) \n          = (planet1,\
    \ planet2) \n        def sortByProximity(planet1 : String, planet2 : String) \n\
    \          = (distance(planet1, planet2) > distance(planet2, planet1) ? \n   \
    \            sortByProximity(planet2, planet1) \n               : \n         \
    \      sortByProximity(planet1, planet2))\n        def sortByProximity2(planet1\
    \ : String, planet2 : String) \n          = (distance(planet1, planet2) < distance(planet2,\
    \ planet1) ? \n               sortByProximity2(planet2, planet1) \n          \
    \     : \n               sortByProximity2(planet1, planet2))\n        def sortByProximity3(planet1\
    \ : String, planet2 : String) \n          = (distance(planet1, planet2) >= distance(planet2,\
    \ planet1) ? \n               sortByProximity3(planet2, planet1) \n          \
    \     : \n               sortByProximity3(planet1, planet2))\n        sortByProximity(planet1,\
    \ planet2) match {\n            case Some(tuple) => (tuple filter (_._1._1==planet1)\n\
    \                               map (_._2)\n                               map\
    \ (_._1)\n                               filter (_._1==planet2)\n            \
    \                   filter (_._2==planet1)\n                               sortByProximity2(planet1,\
    \ planet2)\n                               sortByProximity3(planet1, planet2)\n\
    \                               map (_._2))\n            case None => (Nil)\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"\
    ), (\"Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpe2k3lj2_.scala:31:30 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m               sortByProximity(planet1, planet2))\n\e\
    [31m\e[31m   |\e[0m                              ^\e[0m\n\e[31m   |\e[0m     \
    \                         ')' expected, but '(' found\n\e[31m\e[31m-- [E040] Syntax\
    \ Error: /tmp/tmpe2k3lj2_.scala:36:31 ---------------------------\e[0m\e[0m\n\e\
    [31m36 |\e[0m               sortByProximity2(planet1, planet2))\n\e[31m\e[31m\
    \   |\e[0m                               ^\e[0m\n\e[31m   |\e[0m             \
    \                  ')' expected, but '(' found\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tmpe2k3lj2_.scala:41:31 ---------------------------\e[0m\e[0m\n\e[31m41\
    \ |\e[0m               sortByProximity3(planet1, planet2))\n\e[31m\e[31m   |\e\
    [0m                               ^\e[0m\n\e[31m   |\e[0m                    \
    \           ')' expected, but '(' found\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpe2k3lj2_.scala:22:35 ------------------------\e[0m\e[0m\n\e[31m22 |\e\
    [0m          = scala.math.abs(planet1 - planet2)\n\e[31m\e[31m   |\e[0m      \
    \                     ^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue - is not a member of\
    \ String, but could be made available as an extension method.\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mOne of the following imports might make progress towards fixing\
    \ the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpe2k3lj2_.scala:43:33 ------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m            \e[33mcase\e[0m Some(tuple) => (tuple filter\
    \ (_._1._1==planet1)\n\e[31m\e[31m   |\e[0m                                 ^^^^^\e\
    [0m\n\e[31m   |\e[0m                                 Not found: tuple\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    5 errors found\n"
  stdout: ''
  timestamp: 1660009771
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        var earth_planet_list : List[String] = List()\n  \
    \      var mercury_planet_list : List[String] = List()\n        var venus_planet_list\
    \ : List[String] = List()\n        var mars_planet_list : List[String] = List()\n\
    \        var jupiter_planet_list : List[String] = List()\n        var saturn_planet_list\
    \ : List[String] = List()\n        var uranus_planet_list : List[String] = List()\n\
    \        var neptune_planet_list : List[String] = List()\n        var solar_planet_list\
    \ : List[String] = List()\n\n        val sun_distance = math.sqrt(math.pow(planet1.length,\
    \ 2) + math.pow(planet2.length, 2))\n\n        if (planet1 == planet2) {\n   \
    \         solar_planet_list = List(planet1, planet2)\n            return solar_planet_list\n\
    \        }\n\n        if (planet1 == (\"Earth\")) {\n            earth_planet_list\
    \ = List(\"Venus\")\n            return earth_planet_list\n        }\n\n     \
    \   if (planet1 == (\"Mercury\")) {\n            mercury_planet_list = List(\"\
    Venus\", \"Earth\")\n            return mercury_planet_list\n        }\n\n   \
    \     if (planet1 == (\"Venus\")) {\n            venus_planet_list = List(\"Mercury\"\
    , \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\")\n            return\
    \ venus_planet_list\n        }\n\n        if (planet1 == (\"Mars\")) {\n     \
    \       mars_planet_list = List(\"Venus\", \"Earth\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\")\n            return mars_planet_list\n        }\n\n        if (planet1\
    \ == (\"Jupiter\")) {\n            jupiter_planet_list = List(\"Venus\", \"Earth\"\
    , \"Mars\", \"Saturn\", \"Uranus\")\n            return jupiter_planet_list\n\
    \        }\n\n        if (planet1 == (\"Saturn\")) {\n            saturn_planet_list\
    \ = List(\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Uranus\")\n          \
    \  return saturn_planet_list\n        }\n\n        if (planet1 == (\"Uranus\"\
    )) {\n            uranus_planet_list = List(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\")\n            return uranus_planet_list\n        }\n\n \
    \       if (planet1 == (\"Neptune\")) {\n            neptune_planet_list = List(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\")\n         \
    \   return neptune_planet_list\n        }\n\n        if (planet2 == (\"Earth\"\
    )) {\n            earth_planet_list = List(\"Mercury\")\n            return \n\
    \    }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"\
    Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpigb80k45.scala:93:0 ----------------------------\e\
    [0m\e[0m\n\e[31m93 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpigb80k45.scala:80:12\
    \ --------------------\e[0m\e[0m\n\e[31m80 |\e[0m            \e[33mreturn\e[0m\
    \ \n\e[31m\e[31m   |\e[0m            ^^^^^^\e[0m\n\e[31m   |\e[0m            Found:\
    \    Unit\n\e[31m   |\e[0m            Required: List[String]\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpigb80k45.scala:92:1 ---------------------\e\
    [0m\e[0m\n\e[31m92 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e[0m\n\e[31m   |\e[0m Found:\
    \    Unit\n\e[31m   |\e[0m Required: List[String]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[33m\e[33m--\
    \ Warning: /tmp/tmpigb80k45.scala:82:4 ----------------------------------------\e\
    [0m\e[0m\n\e[33m82 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m\
    \   |\e[0m    Line is indented too far to the left, or a `}` is missing\n1 warning\
    \ found\n3 errors found\n"
  stdout: ''
  timestamp: 1660009773
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        var foundPlanets : List[String] = Nil\n        //\
    \ We will iterate over the planets of the first planet's orbit, \n        // and\
    \ look if planet2 orbits are in the planet's orbit\n        val firstPlanet =\
    \ firstOrbit(planet1)\n        val firstPlanetOrbit = orbit(firstPlanet)\n   \
    \     val firstPlanetOrbitPlanet = orbit(firstPlanet).head\n        var foundPlanet2\
    \ : Boolean = false\n        // Iterate over all planets of the first planet's\
    \ orbit\n        for (i <- 0 until firstPlanetOrbit.size) {\n            // The\
    \ planet is currently in the firstPlanet's orbit\n            if (i == 0) {\n\
    \                foundPlanet2 = true\n            }\n            if (foundPlanet2)\
    \ {\n                // If planet2 is in the firstPlanet's orbit\n           \
    \     if (planet2 == firstPlanetOrbitPlanet) {\n                    // If planet2\
    \ is also in the second planet's orbit\n                    if (orbit(planet2).exists(planet1\
    \ => planet1 == planet2)) {\n                        // We have found a planet\
    \ in between those two planets\n                        foundPlanets = found ::\
    \ foundPlanets\n                        foundPlanet2 = false\n               \
    \     }\n                }\n            }\n        }\n        // return an empty\
    \ list if the first planet is not correct\n        if (firstPlanet == null) {\n\
    \            Nil\n        } else {\n            // If planet2 is not in the first\
    \ planet's orbit\n            if (!foundPlanet2) {\n                // And planet2\
    \ is not in the second planet's orbit\n                Nil\n            } else\
    \ {\n                // If both planets are in the second planet's orbit\n   \
    \             foundPlanets\n            }\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp4k0_v9np.scala:24:26 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mfirstPlanet\e[0m = firstOrbit(planet1)\n\
    \e[31m\e[31m   |\e[0m                          ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                          Not found: firstOrbit\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp4k0_v9np.scala:25:31 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mfirstPlanetOrbit\e[0m =\
    \ orbit(firstPlanet)\n\e[31m\e[31m   |\e[0m                               ^^^^^\e\
    [0m\n\e[31m   |\e[0m                               Not found: orbit\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp4k0_v9np.scala:26:37 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mfirstPlanetOrbitPlanet\e\
    [0m = orbit(firstPlanet).head\n\e[31m\e[31m   |\e[0m                         \
    \            ^^^^^\e[0m\n\e[31m   |\e[0m                                     Not\
    \ found: orbit\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp4k0_v9np.scala:38:24\
    \ ------------------------\e[0m\e[0m\n\e[31m38 |\e[0m                    \e[33mif\e\
    [0m (orbit(planet2).exists(\e[36mplanet1\e[0m => planet1 == planet2)) {\n\e[31m\e\
    [31m   |\e[0m                        ^^^^^\e[0m\n\e[31m   |\e[0m             \
    \           Not found: orbit\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp4k0_v9np.scala:40:39 ------------------------\e[0m\e[0m\n\e[31m40 |\e\
    [0m                        foundPlanets = found :: foundPlanets\n\e[31m\e[31m\
    \   |\e[0m                                       ^^^^^\e[0m\n\e[31m   |\e[0m \
    \                                      Not found: found\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n5 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660009768
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n      val planet1Orbits = orbits(planet1)\n      val planet2Orbits\
    \ = orbits(planet2)\n      val diffsBetweenOrbits = planet1Orbits.diff(planet2Orbits)\n\
    \      val sortedDiffsBetweenOrbits = diffsBetweenOrbits.sortBy(_.distance)\n\
    \      val sunOrbit = orbits(\"Sun\")\n      val planetsWithInBetweenOrbits =\
    \ sortedDiffsBetweenOrbits.takeWhile(d => d <= sunOrbit.distance)\n      val planetsWithoutInBetweenOrbits\
    \ = sortedDiffsBetweenOrbits.takeWhile(d => d > sunOrbit.distance)\n      (planetsWithInBetweenOrbits\
    \ ++ planetsWithoutInBetweenOrbits) \n          .sortBy(_.distance.toDouble -\
    \ sunOrbit.distance.toDouble)\n          .map(p => p.name)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmplq0ejjx0.scala:21:26 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m      \e[33mval\e[0m \e[36mplanet1Orbits\e[0m = orbits(planet1)\n\
    \e[31m\e[31m   |\e[0m                          ^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                        Not found: orbits\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmplq0ejjx0.scala:22:26 ------------------------\e[0m\e\
    [0m\n\e[31m22 |\e[0m      \e[33mval\e[0m \e[36mplanet2Orbits\e[0m = orbits(planet2)\n\
    \e[31m\e[31m   |\e[0m                          ^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                        Not found: orbits\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmplq0ejjx0.scala:25:21 ------------------------\e[0m\e\
    [0m\n\e[31m25 |\e[0m      \e[33mval\e[0m \e[36msunOrbit\e[0m = orbits(\e[31m\"\
    Sun\"\e[0m)\n\e[31m\e[31m   |\e[0m                     ^^^^^^\e[0m\n\e[31m   |\e\
    [0m                     Not found: orbits\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660009767
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(Mercury, Venus, Earth, Mars, Jupiter,\
    \ Saturn, Uranus, Neptune)\n        val orbits = planets.map(planet => (planet,\
    \ planet.orbits(planet1, planet2)))\n        var result: List[String] = Nil\n\
    \        for (planet1 <- planets; planet2 <- planets) {\n            val distance\
    \ = orbits(planet1).distance(orbits(planet2))\n            if (distance <= 0.5)\
    \ {\n                result = result.filterNot(orbits(planet1).name == planet2.name)\n\
    \            } else {\n                result = result.filterNot(orbits(planet2).name\
    \ == planet1.name)\n            }\n        }\n        result :+ Mercury\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp961dc4u6.scala:21:27 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mplanets\e[0m = List(Mercury,\
    \ Venus, Earth, Mars, Jupiter, Saturn, Uranus, Neptune)\n\e[31m\e[31m   |\e[0m\
    \                           ^^^^^^^\e[0m\n\e[31m   |\e[0m                    \
    \       Not found: Mercury\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp961dc4u6.scala:21:36 ------------------------\e[0m\e[0m\n\e[31m21 |\e\
    [0m        \e[33mval\e[0m \e[36mplanets\e[0m = List(Mercury, Venus, Earth, Mars,\
    \ Jupiter, Saturn, Uranus, Neptune)\n\e[31m\e[31m   |\e[0m                   \
    \                 ^^^^^\e[0m\n\e[31m   |\e[0m                                \
    \    Not found: Venus\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp961dc4u6.scala:21:43\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mplanets\e[0m = List(Mercury, Venus, Earth, Mars, Jupiter, Saturn, Uranus,\
    \ Neptune)\n\e[31m\e[31m   |\e[0m                                           ^^^^^\e\
    [0m\n\e[31m   |\e[0m                                           Not found: Earth\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp961dc4u6.scala:21:50\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mplanets\e[0m = List(Mercury, Venus, Earth, Mars, Jupiter, Saturn, Uranus,\
    \ Neptune)\n\e[31m\e[31m   |\e[0m                                            \
    \      ^^^^\e[0m\n\e[31m   |\e[0m                                            \
    \      Not found: Mars\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp961dc4u6.scala:21:56\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mplanets\e[0m = List(Mercury, Venus, Earth, Mars, Jupiter, Saturn, Uranus,\
    \ Neptune)\n\e[31m\e[31m   |\e[0m                                "
  stdout: ''
  timestamp: 1660009773
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n       // TODO: Implement this function\n       println(planet1\
    \ + \" \" + planet2)\n    }\n    def main(args: Array[String]) = {\n    assert(bf((\"\
    Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n\
    \    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n\
    \    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"),\
    \ (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp74xin93w.scala:22:14\
    \ --------------------\e[0m\e[0m\n\e[31m22 |\e[0m       println(planet1 + \e[31m\"\
    \ \"\e[0m + planet2)\n\e[31m\e[31m   |\e[0m       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m       Found:    Unit\n\e[31m   |\e[0m       Required: List[String]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009772
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        // TODO: use pattern matching and a switch statement\
    \ to decide which \n        // case is to be performed.\n        val planets:\
    \ List[String] = List(planet1, planet2)\n        val orbits = planets.map(_.toLowerCase).toSet\n\
    \        val sun = Planet.calculateSunOrbit()\n        val sunOrbit = Planet.calculateOrbit(planet1,\
    \ sun)\n        val sunOrbit1 = Planet.calculateOrbit(planet2, sun)\n        val\
    \ sunOrbit2 = Planet.calculateOrbit(planet1, sunOrbit)\n        val sunOrbit3\
    \ = Planet.calculateOrbit(planet2, sunOrbit1)\n        val sunOrbit4 = Planet.calculateOrbit(planet1,\
    \ sunOrbit2)\n        val sunOrbit5 = Planet.calculateOrbit(planet2, sunOrbit3)\n\
    \        val sunOrbit6 = Planet.calculateOrbit(planet1, sunOrbit4)\n        val\
    \ sunOrbit7 = Planet.calculateOrbit(planet2, sunOrbit5)\n        val sunOrbit8\
    \ = Planet.calculateOrbit(planet1, sunOrbit6)\n        val sunOrbit9 = Planet.calculateOrbit(planet2,\
    \ sunOrbit7)\n        val sunOrbit10 = Planet.calculateOrbit(planet1, sunOrbit8)\n\
    \        val sunOrbit11 = Planet.calculateOrbit(planet2, sunOrbit9)\n        val\
    \ sunOrbit12 = Planet.calculateOrbit(planet1, sunOrbit10)\n        val sunOrbit13\
    \ = Planet.calculateOrbit(planet2, sunOrbit11)\n        val sunOrbit14 = Planet.calculateOrbit(planet1,\
    \ sunOrbit12)\n        val sunOrbit15 = Planet.calculateOrbit(planet2, sunOrbit13)\n\
    \        val sunOrbit16 = Planet.calculateOrbit(planet1, sunOrbit14)\n       \
    \ val sunOrbit17 = Planet.calculateOrbit(planet2, sunOrbit15)\n        val sunOrbit18\
    \ = Planet.calculateOrbit(planet1, sunOrbit16)\n        val sunOrbit19 = Planet.calculateOrbit(planet2,\
    \ sunOrbit17)\n        val sunOrbit20 = Planet.calculateOrbit(planet1, sunOrbit18)\n\
    \        val sunOrbit21 = Planet.calculateOrbit(planet2, sunOrbit19)\n       \
    \ val sunOrbit\n    }\n    def main(args: Array[String]) = {\n    assert(bf((\"\
    Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n\
    \    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n\
    \    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"),\
    \ (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpvfb42vwy.scala:49:4 ----------------------------\e\
    [0m\e[0m\n\e[31m49 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpvfb42vwy.scala:25:18\
    \ ------------------------\e[0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e\
    [36msun\e[0m = Planet.calculateSunOrbit()\n\e[31m\e[31m   |\e[0m             \
    \     ^^^^^^\e[0m\n\e[31m   |\e[0m                  Not found: Planet\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpvfb42vwy.scala:26:23 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36msunOrbit\e[0m = Planet.calculateOrbit(planet1,\
    \ sun)\n\e[31m\e[31m   |\e[0m                       ^^^^^^\e[0m\n\e[31m   |\e\
    [0m                       Not found: Planet\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpvfb42vwy.scala:27:24 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36msunOrbit1\e[0m = Planet.calculateOrbit(planet2,\
    \ sun)\n\e[31m\e[31m   |\e[0m                        ^^^^^^\e[0m\n\e[31m   |\e\
    [0m                        Not found: Planet\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpvfb42vwy.scala:28:24 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36msunOrbit2\e[0m = Planet.calculateOrbit(planet1,\
    \ sunOrbit)\n\e[31m\e[31m   |\e[0m                        ^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                        Not found: Planet\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpvfb42vwy.scala:29:24 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36msunOrbit3\e[0m = Planet.calculateOrbit(planet2,\
    \ sunOrbit1)\n\e[31m\e[31m   |\e[0m                        ^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                        Not found: Planet\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer"
  stdout: ''
  timestamp: 1660009774
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        var sol : List[String] = List()\n        var list1\
    \ : List[String] = List()\n        var list2 : List[String] = List()\n       \
    \ var list3 : List[String] = List()\n        var list4 : List[String] = List()\n\
    \        var list5 : List[String] = List()\n        var list6 : List[String] =\
    \ List()\n        var list7 : List[String] = List()\n        var list8 : List[String]\
    \ = List()\n        \n        if (planet1 != planet2) {\n            sol = sol\
    \ :+ planet1\n        }\n        else {\n            sol = sol :+ planet2\n  \
    \      }\n        \n        val planets1 : List[String] = List(\"Mercury\",\"\
    Venus\",\"Earth\",\"Mars\",\"Jupiter\",\"Saturn\",\"Uranus\",\"Neptune\")\n  \
    \      val planets2 : List[String] = List(\"Mercury\",\"Venus\",\"Earth\",\"Mars\"\
    ,\"Jupiter\",\"Saturn\",\"Uranus\",\"Neptune\")\n        \n        // If planet1\
    \ is the same as planet2\n        \n        if (planet1 == planet2) {\n      \
    \      sol = sol :+ planet1\n        }\n        else {\n            val planetIndex1\
    \ : Int = planets1.indexOf(planet1)\n            val planetIndex2 : Int = planets2.indexOf(planet2)\n\
    \            \n            for (i <- 0 until 8)\n            {\n             \
    \   // If planet1 is between the two planets indexed i and i+1\n             \
    \   \n                if (planets1(planetIndex1) == planets1(i) && planets1(planetIndex1\
    \ + 1) == planets1(i + 1))\n                {\n                    // If planet2\
    \ index is between the two planets indexed j and j+1\n                    \n \
    \                   if (planets2(planetIndex2) == planets2(j) && planets2(planetIndex2\
    \ + 1) == planets2(j + 1))\n                    {\n                        //\
    \ if i and j are within range of the list\n                        \n        \
    \                val j = j + 1\n                        val i = i + 1\n      \
    \                  val r = math.abs(i - j) \n                        \n      \
    \                  // if r is in range\n                        if (0 <= r &&\
    \ r <= 1)\n                        {\n                            // Append the\
    \ planets to the list\n                            if (planets1(planetIndex1)\
    \ == planets2(planetIndex2))\n                            {\n                \
    \                list1 = list1 :+ planets2(i)\n                            }\n\
    \                            else\n                            {\n           \
    \                     list1 = list1 :+ planets1(i)\n                         \
    \   }\n                            if (planets1(planetIndex1 + 1) == planets\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"\
    Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp1hz5bntm.scala:79:4 ----------------------------\e\
    [0m\e[0m\n\e[31m79 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp1hz5bntm.scala:91:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m91 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmp1hz5bntm.scala:44:16 --------------------\e[0m\e[0m\n\
    \e[31m44 |\e[0m            sol = sol :+ planet1\n\e[31m\e[31m   |\e[0m       \
    \     ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            Found:    Unit\n\e\
    [31m   |\e[0m            Required: List[String]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp1hz5bntm.scala:58:59 ------------------------\e\
    [0m\e[0m\n\e[31m58 |\e[0m                    \e[33mif\e[0m (planets2(planetIndex2)\
    \ == planets2(j) && planets2(planetIndex2 + \e[31m1\e[0m) == planets2(j + \e[31m1\e\
    [0m))\n\e[31m\e[31m   |\e[0m                                                 \
    \          ^\e[0m\n\e[31m   |\e[0m                                           \
    \                Not found: j\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp1hz5bntm.scala:58:104 -----------------------\e[0m\e[0m\n\e[31m58 |\e\
    [0m                    \e[33mif\e[0m (planets2(planetIndex2) == planets2(j) &&\
    \ planets2(planetIndex2 + \e[31m1\e[0m) == planets2(j + \e[31m1\e[0m))\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \                                        ^\e[0m\n\e[31m   |\e[0m             \
    \                                               Not found: j\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmp1hz5bntm.scala:78:62 ------------------------\e\
    [0m\e[0m\n\e[31m78 |\e[0m                            \e[33mif\e[0m (planets1(planetIndex1\
    \ + \e[31m1\e[0m) == planets\n\e[31m\e[31m   |\e[0m                         "
  stdout: ''
  timestamp: 1660009776
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        // Write your code here.\n        var list: List[String]\
    \ = List()\n        if(planet1 == planet2){\n            list = List(planet1)\n\
    \        }else if(planet1.contains(\"Neptune\") || planet2.contains(\"Neptune\"\
    )){\n            list = List()\n        }else{\n            val distances = Array(50.2,\
    \ 101.4, 204.3, 309.6, 420.4, 527.8, 642.4, 756.3, 870.6, 987.4)\n           \
    \ val startTime = System.nanoTime\n            val distance1 = distances.filter(_\
    \ == distances.indexOf(planet1)).head\n            val distance2 = distances.filter(_\
    \ == distances.indexOf(planet2)).head\n            val difference = distance1\
    \ - distance2\n            val endTime = System.nanoTime\n            val totalTimeInSeconds\
    \ = (endTime - startTime)/1e9\n            val timeInSeconds = totalTimeInSeconds\
    \ * (difference/distance1)\n            list = distances.filter(_ == distance1).sortBy(x\
    \ => x/distance1).takeWhile(_ < timeInSeconds)\n        }\n        list.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"\
    Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpmvyf7udw.scala:30:68\
    \ --------------------\e[0m\e[0m\n\e[31m30 |\e[0m            \e[33mval\e[0m \e\
    [36mdistance1\e[0m = distances.filter(_ == distances.indexOf(planet1)).head\n\e\
    [31m\e[31m   |\e[0m                                                          \
    \          ^^^^^^^\e[0m\n\e[31m   |\e[0m                                     \
    \       Found:    (planet1 : String)\n\e[31m   |\e[0m                        \
    \                    Required: Double\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpmvyf7udw.scala:31:68 --------------------\e[0m\e\
    [0m\n\e[31m31 |\e[0m            \e[33mval\e[0m \e[36mdistance2\e[0m = distances.filter(_\
    \ == distances.indexOf(planet2)).head\n\e[31m\e[31m   |\e[0m                 \
    \                                                   ^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                                            Found:    (planet2 : String)\n\e\
    [31m   |\e[0m                                            Required: Double\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpmvyf7udw.scala:36:86\
    \ --------------------\e[0m\e[0m\n\e[31m36 |\e[0m            list = distances.filter(_\
    \ == distance1).sortBy(\e[36mx\e[0m => x/distance1).takeWhile(_ < timeInSeconds)\n\
    \e[31m\e[31m   |\e[0m                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                   Found:    Array[Double]\n\e[31m   |\e[0m\
    \                   Required: List[String]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660009777
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n    val distanceMatrix = Array.ofDim[Int](7, 7)\n    val planetsBetween\
    \ = List(planet1, planet2).sorted\n    for (i <- 0 until 7) {\n        for (j\
    \ <- 0 until 7) {\n            distanceMatrix(i, j) = math.pow(math.pow(math.pow(i\
    \ - planet1.toDouble, 2) + math.pow(j - planet2.toDouble, 2), 0.5), 0.5)\n   \
    \     }\n    }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"\
    ), (\"Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpdwtycg2k.scala:39:0 ----------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpdwtycg2k.scala:25:30\
    \ --------------------\e[0m\e[0m\n\e[31m25 |\e[0m            distanceMatrix(i,\
    \ j) = math.pow(math.pow(math.pow(i - planet1.toDouble, \e[31m2\e[0m) + math.pow(j\
    \ - planet2.toDouble, \e[31m2\e[0m), \e[31m0.5\e[0m), \e[31m0.5\e[0m)\n\e[31m\e\
    [31m   |\e[0m                              ^\e[0m\n\e[31m   |\e[0m           \
    \                   Found:    (j : Int)\n\e[31m   |\e[0m                     \
    \         Required: Array[Int]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- Error: /tmp/tmpdwtycg2k.scala:25:43\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m25 |\e[0m       \
    \     distanceMatrix(i, j) = math.pow(math.pow(math.pow(i - planet1.toDouble,\
    \ \e[31m2\e[0m) + math.pow(j - planet2.toDouble, \e[31m2\e[0m), \e[31m0.5\e[0m),\
    \ \e[31m0.5\e[0m)\n\e[31m\e[31m   |\e[0m                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mtoo many arguments for \e[33mmethod\e[0m \e[35mupdate\e[0m\
    \ in \e[33mclass\e[0m \e[35mArray\e[0m: (i: Int, x: Array[Int]): Unit\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpdwtycg2k.scala:38:1 ---------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e[0m\n\e[31m   |\e[0m Found:\
    \    Unit\n\e[31m   |\e[0m Required: List[String]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660009777
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        // Code here\n        (planet1.toInt, planet2.toInt).flatMap{\n\
    \            case (x, y) => if(x >= y){\n                List(planet2) :: List(planet1)\n\
    \            } else {\n                List(planet1) :: List(planet2)\n      \
    \      }\n        }.toList\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\", \"\
    Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp24emi9z8.scala:22:39 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        (planet1.toInt, planet2.toInt).flatMap{\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m        value flatMap is not a member of (Int, Int)\n1 error found\n"
  stdout: ''
  timestamp: 1660009777
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        var planet1Orbits = ListBuffer[String]()\n       \
    \ var planet2Orbits = ListBuffer[String]()\n        planet1Orbits = orbits(planet1)\n\
    \        planet2Orbits = orbits(planet2)\n        if (planet1Orbits.isEmpty)\n\
    \            return (planet2Orbits)\n        if (planet2Orbits.isEmpty)\n    \
    \        return (planet1Orbits)\n        var orbitsBetween = planet1Orbits.intersect(planet2Orbits)\n\
    \        planet1Orbits.foreach { planet1orbit =>\n            planet2Orbits.foreach\
    \ { planet2orbit =>\n                if (planet1orbit < planet2orbit) {\n    \
    \                orbitsBetween = planet1Orbits.intersect(planet2Orbits)\n    \
    \            }\n            }\n        }\n        orbitsBetween.sort { distanceToSun(it)\
    \ }\n    }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"\
    ), (\"Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpkqul2atu.scala:23:24 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        planet1Orbits = orbits(planet1)\n\e[31m\e[31m\
    \   |\e[0m                        ^^^^^^\e[0m\n\e[31m   |\e[0m               \
    \         Not found: orbits\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpkqul2atu.scala:24:24 ------------------------\e[0m\e[0m\n\e[31m24 |\e\
    [0m        planet2Orbits = orbits(planet2)\n\e[31m\e[31m   |\e[0m            \
    \            ^^^^^^\e[0m\n\e[31m   |\e[0m                        Not found: orbits\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpkqul2atu.scala:26:20\
    \ --------------------\e[0m\e[0m\n\e[31m26 |\e[0m            \e[33mreturn\e[0m\
    \ (planet2Orbits)\n\e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m Found:    (planet2Orbits : scala.collection.mutable.ListBuffer[String])\n\
    \e[31m   |\e[0m Required: List[String]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpkqul2atu.scala:28:20 --------------------\e[0m\e\
    [0m\n\e[31m28 |\e[0m            \e[33mreturn\e[0m (planet1Orbits)\n\e[31m\e[31m\
    \   |\e[0m                    ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m Found:    (planet1Orbits\
    \ : scala.collection.mutable.ListBuffer[String])\n\e[31m   |\e[0m Required: List[String]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpkqul2atu.scala:37:22\
    \ ------------------------\e[0m\e[0m\n\e[31m37 |\e[0m        orbitsBetween.sort\
    \ { distanceToSun(it) }\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mvalue sort is not a member of scala.collection.mutable.ListBuffer[String],\
    \ but could be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mOne of the following imports might fix the problem:\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m  import collection.convert.ImplicitConversions.bu"
  stdout: ''
  timestamp: 1660009778
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val sun = new Planet(\"Sun\")\n        val mercury\
    \ = new Planet(\"Mercury\")\n        val venus = new Planet(\"Venus\")\n     \
    \   val earth = new Planet(\"Earth\")\n        val mars = new Planet(\"Mars\"\
    )\n        val jupiter = new Planet(\"Jupiter\")\n        val saturn = new Planet(\"\
    Saturn\")\n        val uranus = new Planet(\"Uranus\")\n        val neptune =\
    \ new Planet(\"Neptune\")\n        val planetList1 = List(mercury, venus, earth,\
    \ mars, jupiter, saturn, uranus, neptune)\n        val planetList2 = List(sun,\
    \ planet1, planet2)\n        val planetList3 = planetList1.union(planetList2).sortBy(p\
    \ => distance(p.position, sun))\n        val planetList4 = planetList3.filter(_\
    \ == planet1 || _ == planet2)\n        return planetList4.toList\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpcexopcrw.scala:21:22 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36msun\e[0m = \e[33mnew\e[0m\
    \ \e[35mPlanet\e[0m(\e[31m\"Sun\"\e[0m)\n\e[31m\e[31m   |\e[0m               \
    \       ^^^^^^\e[0m\n\e[31m   |\e[0m                      Not found: type Planet\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpcexopcrw.scala:22:26\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mmercury\e[0m = \e[33mnew\e[0m \e[35mPlanet\e[0m(\e[31m\"Mercury\"\e[0m)\n\e\
    [31m\e[31m   |\e[0m                          ^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                      Not found: type Planet\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpcexopcrw.scala:23:24 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mvenus\e[0m = \e[33mnew\e\
    [0m \e[35mPlanet\e[0m(\e[31m\"Venus\"\e[0m)\n\e[31m\e[31m   |\e[0m           \
    \             ^^^^^^\e[0m\n\e[31m   |\e[0m                        Not found: type\
    \ Planet\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpcexopcrw.scala:24:24\
    \ ------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e\
    [36mearth\e[0m = \e[33mnew\e[0m \e[35mPlanet\e[0m(\e[31m\"Earth\"\e[0m)\n\e[31m\e\
    [31m   |\e[0m                        ^^^^^^\e[0m\n\e[31m   |\e[0m            \
    \            Not found: type Planet\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpcexopcrw.scala:25:23 ------------------------\e[0m\e[0m\n\e[31m25 |\e\
    [0m        \e[33mval\e[0m \e[36mmars\e[0m = \e[33mnew\e[0m \e[35mPlanet\e[0m(\e\
    [31m\"Mars\"\e[0m)\n\e[31m\e[31m   |\e[0m                       ^^^^^^\e[0m\n\e\
    [31m   |\e[0m                       Not found: type Planet\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpcexopcrw.scala:26"
  stdout: ''
  timestamp: 1660009777
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val sun : java.math.Coordinate = java.util.Arrays.asList(1,0,0)\n\
    \        val earth : java.math.Coordinate = java.util.Arrays.asList(0,0,1)\n \
    \       val mercury : java.math.Coordinate = java.util.Arrays.asList(0,1,0)\n\
    \        val venus : java.math.Coordinate = java.util.Arrays.asList(0,-1,0)\n\
    \        val mars : java.math.Coordinate = java.util.Arrays.asList(-1,0,0)\n \
    \       val jupiter : java.math.Coordinate = java.util.Arrays.asList(0,-1,-1)\n\
    \        val saturn : java.math.Coordinate = java.util.Arrays.asList(-1,0,-1)\n\
    \        val uranus : java.math.Coordinate = java.util.Arrays.asList(-1,0,1)\n\
    \        val neptune : java.math.Coordinate = java.util.Arrays.asList(1,0,1)\n\
    \        val planetsList : List[String] = new mutable.HashSet[String]()\n\n  \
    \      planetsList.addAll(planet1, planet2)\n        planetsList.addAll(planet2,\
    \ planet1)\n        if (planetsList.toSet.size == 2) {\n            return planetsList.toList.sortBy(e\
    \ => sun.distance(e, earth))\n        }\n        return List() // return an empty\
    \ list if planetsList doesn't contain exactly two planets\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpdh6ajl26.scala:21:28 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36msun\e[0m : java.math.Coordinate\
    \ = java.util.Arrays.asList(\e[31m1\e[0m,\e[31m0\e[0m,\e[31m0\e[0m)\n\e[31m\e\
    [31m   |\e[0m                  ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \              type Coordinate is not a member of java.math\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpdh6ajl26.scala:22:30 ------------------------\e[0m\e\
    [0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mearth\e[0m : java.math.Coordinate\
    \ = java.util.Arrays.asList(\e[31m0\e[0m,\e[31m0\e[0m,\e[31m1\e[0m)\n\e[31m\e\
    [31m   |\e[0m                    ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                  type Coordinate is not a member of java.math\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpdh6ajl26.scala:23:32 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mmercury\e[0m : java.math.Coordinate\
    \ = java.util.Arrays.asList(\e[31m0\e[0m,\e[31m1\e[0m,\e[31m0\e[0m)\n\e[31m\e\
    [31m   |\e[0m                      ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                      type Coordinate is not a member of java.math\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpdh6ajl26.scala:24:30 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mvenus\e[0m : java.math.Coordinate\
    \ = java.util.Arrays.asList(\e[31m0\e[0m,-\e[31m1\e[0m,\e[31m0\e[0m)\n\e[31m\e\
    [31m   |\e[0m                    ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                  type Coordinate is not a member of java.math\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpdh6ajl26.scala:25:29 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mmars\e[0m : java.math.Coordinate\
    \ = java.util.Arrays.asList(-\e[31m1\e[0m,\e[31m0\e[0m,\e[31m0\e[0m)\n\e[31m\e\
    [31m   |\e[0m                   ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m   \
    \                type Coordinate is not a member of java.math\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpdh6ajl26.scala:26:32 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mjupiter\e[0m : java.math.Coordinate\
    \ = java.util.Arra"
  stdout: ''
  timestamp: 1660009780
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val a = mutable.MutableList[String]()\n        for(((s,\
    \ p1), (p2, d)) <- planetsAndDistances(planet1, planet2).zipWithIndex) {\n   \
    \         var xx = s\n            var yy = p1\n            var zz = p2\n     \
    \       val d = d / Math.sqrt(Math.pow(xx - yy,2) + Math.pow(zx - zz,2))\n   \
    \         val p = d * ((xx - yy) * Math.pow(zx - zz, 2) + (yy - zz) * Math.pow(xx\
    \ - zz, 2))\n            val q = d * ((yy - zz) * Math.pow(xx - zz, 2) + (xx -\
    \ zz) * Math.pow(yy - zz, 2))\n            val r = Math.sqrt((p * p) + (q * q))\n\
    \            if(r > 1){\n                r = r / Math.sqrt(Math.pow(xx - yy,2)\
    \ + Math.pow(zx - zz,2))\n                val (x1, y1) = xx, yy = yy\n       \
    \         val (x2, y2) = zz, zz\n                val dx = x2 - x1\n          \
    \      val dy = y2 - y1\n                val d = Math.sqrt(Math.pow(dx,2) + Math.pow(dy,2))\n\
    \                val r = Math.sqrt((p * p) + (q * q))\n                val x =\
    \ (dx * p + dy * q) / (r * r * r)\n                val y = (dy * p + dx * q) /\
    \ (r * r * r)\n                val z = ((p * x) + (q * y)) / (r * r * r)\n   \
    \             val (xx1, yy1) = xx, yy = yy\n                val (zz1, zz2) = zz,\
    \ zz\n                val d = Math.sqrt(Math.pow(xx1 - yy1,2) + Math.pow(zz1 -\
    \ zz2,2))\n                val p = d * ((xx1 - yy1) * Math.pow(zz1 - zz2, 2) +\
    \ (yy1 - zz1) * Math.pow(xx1 - zz2, 2))\n                val q = d * ((yy1 - zz1)\
    \ * Math.pow(xx1 - zz2, 2) + (xx1 - zz1) * Math.pow(yy1 - zz2, 2))\n         \
    \       val r = Math.sqrt((p * p) + (q * q))\n                val x = (dx * p\
    \ + dy * q) / (r * r * r)\n                val y = (dy * p + dx * q) / (r * r\
    \ * r)\n                val z = ((p * x) + (q * y)) / (r * r * r)\n          \
    \      a = a :+ ((x).toString + \"|\" + (y).toString + \"|\" + (z).toString)\n\
    \            }\n        }\n        a.sortWith((s1, s2) => s1 < s2)\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpzg4rp3ma.scala:32:33 -----------------------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m                \e[33mval\e[0m (x1, y1) = xx, yy = yy\n\
    \e[31m\e[31m   |\e[0m                                 ^\e[0m\n\e[31m   |\e[0m\
    \                                 end of statement expected but ',' found\n\e\
    [31m\e[31m-- Error: /tmp/tmpzg4rp3ma.scala:33:33 -----------------------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m                \e[33mval\e[0m (x2, y2) = zz, zz\n\e\
    [31m\e[31m   |\e[0m                                 ^\e[0m\n\e[31m   |\e[0m  \
    \                               end of statement expected but ',' found\n\e[31m\e\
    [31m-- Error: /tmp/tmpzg4rp3ma.scala:41:35 -----------------------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m                \e[33mval\e[0m (xx1, yy1) = xx, yy =\
    \ yy\n\e[31m\e[31m   |\e[0m                                   ^\e[0m\n\e[31m \
    \  |\e[0m                                 end of statement expected but ',' found\n\
    \e[31m\e[31m-- Error: /tmp/tmpzg4rp3ma.scala:42:35 -----------------------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m                \e[33mval\e[0m (zz1, zz2) = zz, zz\n\e\
    [31m\e[31m   |\e[0m                                   ^\e[0m\n\e[31m   |\e[0m\
    \                                 end of statement expected but ',' found\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpzg4rp3ma.scala:21:16 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36ma\e[0m = mutable.MutableList[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpzg4rp3ma.scala:22:34 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mfor\e[0m(((s, p1), (p2, d)) <- planetsAndDistances(planet1,\
    \ planet2).zipWithIndex) {\n\e[31m\e[31m   |\e[0m                            \
    \      ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                             \
    \     Not found: planetsAndDistances\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n6 er"
  stdout: ''
  timestamp: 1660009775
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(planet1, planet2)\n        val\
    \ sun = Planet(Planet.Name.SUN, \"Sun\", Planet.Position.ZERO)\n        val mercury\
    \ = Planet(Planet.Name.MERCURY, \"Mercury\", Planet.Position.ZERO)\n        val\
    \ venus = Planet(Planet.Name.VENUS, \"Venus\", Planet.Position.ZERO)\n       \
    \ val earth = Planet(Planet.Name.EARTH, \"Earth\", Planet.Position.ZERO)\n   \
    \     val mars = Planet(Planet.Name.MARS, \"Mars\", Planet.Position.ZERO)\n  \
    \      val jupiter = Planet(Planet.Name.JUPITER, \"Jupiter\", Planet.Position.ZERO)\n\
    \        val saturn = Planet(Planet.Name.SATURN, \"Saturn\", Planet.Position.ZERO)\n\
    \        val uranus = Planet(Planet.Name.URANUS, \"Uranus\", Planet.Position.ZERO)\n\
    \        val neptune = Planet(Planet.Name.NEPTUNE, \"Neptune\", Planet.Position.ZERO)\n\
    \        val planetList = (List(mercury, venus, earth, mars, jupiter, saturn,\
    \ uranus, neptune), List(sun))\n        val planetsAfterMercuryAndEarth = planetList.map\
    \ { p => (p) }\n        planetsAfterMercuryAndEarth = planetsAfterMercuryAndEarth.map\
    \ { p => (p.name.toString, p.position.toString, p.radius.toDouble) }\n       \
    \ val planetsAfterMercuryAndEarth1 = planetsAfterMercuryAndEarth.map { x => x._1\
    \ }\n        val planetsAfterMercuryAndEarth2 = planetsAfterMercuryAndEarth.map\
    \ { x => x._2 }\n        val sunOrbit = sun.getOrbit(mercury, earth)\n       \
    \ val mercuryOrbit = mercury.getOrbit(sun, venus)\n        val earthOrbit = earth.getOrbit(sun,\
    \ mars)\n        val marsOrbit = mars.getOrbit(sun, jupiter)\n        val jupiterOrbit\
    \ = jupiter.getOrbit(sun, saturn)\n        val saturnOrbit = saturn.getOrbit(sun,\
    \ uranus)\n    }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"\
    ), (\"Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp7jk6sp4_.scala:22:18 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36msun\e[0m = Planet(Planet.Name.SUN,\
    \ \e[31m\"Sun\"\e[0m, Planet.Position.ZERO)\n\e[31m\e[31m   |\e[0m           \
    \       ^^^^^^\e[0m\n\e[31m   |\e[0m                  Not found: Planet\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp7jk6sp4_.scala:22:25 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36msun\e[0m = Planet(Planet.Name.SUN,\
    \ \e[31m\"Sun\"\e[0m, Planet.Position.ZERO)\n\e[31m\e[31m   |\e[0m           \
    \              ^^^^^^\e[0m\n\e[31m   |\e[0m                         Not found:\
    \ Planet\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp7jk6sp4_.scala:22:49\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36msun\e[0m = Planet(Planet.Name.SUN, \e[31m\"Sun\"\e[0m, Planet.Position.ZERO)\n\
    \e[31m\e[31m   |\e[0m                                                 ^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                                 Not found:\
    \ Planet\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp7jk6sp4_.scala:23:22\
    \ ------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e\
    [36mmercury\e[0m = Planet(Planet.Name.MERCURY, \e[31m\"Mercury\"\e[0m, Planet.Position.ZERO)\n\
    \e[31m\e[31m   |\e[0m                      ^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \                Not found: Planet\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp7jk6sp4_.scala:23:29 ------------------------\e[0m\e[0m\n\e[31m23 |\e\
    [0m        \e[33mval\e[0m \e[36mmercury\e[0m = Planet(Planet.Name.MERCURY, \e\
    [31m\"Mercury\"\e[0m, Planet.Position.ZERO)\n\e[31m\e[31m   |\e[0m           \
    \                  ^^^^^^\e[0m\n\e[31m   |\e[0m                             Not\
    \ found: Planet\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer e"
  stdout: ''
  timestamp: 1660009779
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val orbit1 = Orbits(planet1)\n        val orbit2 =\
    \ Orbits(planet2)\n\n        val orbit1sun = orbit1.getSunPosition\n        val\
    \ orbit2sun = orbit2.getSunPosition\n\n        val orbit1Orbits = orbit1.getAllOrbits\n\
    \        val orbit2Orbits = orbit2.getAllOrbits\n\n        val orbit1OrbitsSun\
    \ = orbit1Orbits.filter(orbit1 => orbit1.getSunPosition.distanceToOrbit(orbit1sun)\
    \ < 0.2)\n        val orbit2OrbitsSun = orbit2Orbits.filter(orbit2 => orbit2.getSunPosition.distanceToOrbit(orbit2sun)\
    \ < 0.2)\n\n        // return empty list if planet1 or planet2 not correct planet\
    \ names\n        if (orbit1OrbitsSun.isEmpty || orbit2OrbitsSun.isEmpty)\n   \
    \         List()\n        else {\n            val orbit1OrbitsSunSorted = orbit1OrbitsSun.sortWith((orbit1,\
    \ orbit2) => orbit1.getSunPosition.distanceToOrbit(orbit1sun) - orbit2.getSunPosition.distanceToOrbit(orbit2sun))\n\
    \            val orbit2OrbitsSunSorted = orbit2OrbitsSun.sortWith((orbit1, orbit2)\
    \ => orbit1.getSunPosition.distanceToOrbit(orbit1sun) - orbit2.getSunPosition.distanceToOrbit(orbit2sun))\n\
    \n            (orbit1OrbitsSunSorted.take(3), orbit2OrbitsSunSorted.take(3))\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"\
    ), (\"Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpotvfr1n3.scala:21:21 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36morbit1\e[0m = Orbits(planet1)\n\
    \e[31m\e[31m   |\e[0m                     ^^^^^^\e[0m\n\e[31m   |\e[0m       \
    \              Not found: Orbits\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpotvfr1n3.scala:22:21 ------------------------\e[0m\e[0m\n\e[31m22 |\e\
    [0m        \e[33mval\e[0m \e[36morbit2\e[0m = Orbits(planet2)\n\e[31m\e[31m  \
    \ |\e[0m                     ^^^^^^\e[0m\n\e[31m   |\e[0m                    \
    \ Not found: Orbits\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpotvfr1n3.scala:40:12\
    \ --------------------\e[0m\e[0m\n\e[31m40 |\e[0m            (orbit1OrbitsSunSorted.take(\e\
    [31m3\e[0m), orbit2OrbitsSunSorted.take(\e[31m3\e[0m))\n\e[31m\e[31m   |\e[0m\
    \            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m            Found:    (Nothing, Nothing)\n\e[31m   |\e[0m\
    \            Required: List[String]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660009778
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        planet1 match {\n            case planet1 if (planet1.length\
    \ < 2) => \"no planet\"\n            case planet1 if (planet1.length < 4) => \"\
    no planet\"\n            case planet1 if (planet1.length < 6) => \"no planet\"\
    \n            case planet1 if (planet1.length < 8) => \"no planet\"\n        \
    \    case planet1 if (planet1.length < 10) => \"no planet\"\n            case\
    \ planet1 if (planet1.length < 12) => \"no planet\"\n            case planet1\
    \ if (planet1.length < 14) => \"no planet\"\n            case planet1 if (planet1.length\
    \ < 16) => \"no planet\"\n            case planet1 if (planet1.length < 18) =>\
    \ \"no planet\"\n            case planet1 if (planet1.length < 20) => \"no planet\"\
    \n            case planet1 if (planet1.length < 22) => \"no planet\"\n       \
    \     case planet1 if (planet1.length < 24) => \"no planet\"\n            case\
    \ planet1 if (planet1.length < 26) => \"no planet\"\n            case planet1\
    \ if (planet1.length < 28) => \"no planet\"\n            case planet1 if (planet1.length\
    \ < 30) => \"no planet\"\n            case planet1 if (planet1.length < 32) =>\
    \ \"no planet\"\n            case planet1 if (planet1.length < 34) => \"no planet\"\
    \n            case planet1 if (planet1.length < 36) => \"no planet\"\n       \
    \     case planet1 if (planet1.length < 38) => \"no planet\"\n            case\
    \ planet1 if (planet1.length < 40) => \"no planet\"\n            case planet1\
    \ if (planet1.length < 42) => \"no planet\"\n            case planet1 if (planet1.length\
    \ < 44) => \"no planet\"\n            case planet1 if (planet1.length < 46) =>\
    \ \"no planet\"\n            case planet1 if (planet1.length < 48) => \"no planet\"\
    \n            case planet1 if (planet1.length < 50) => \"no planet\"\n       \
    \     case planet1 if (planet1.length < 52) => \"no planet\"\n            case\
    \ planet1 if (planet1.length < 54) => \"no planet\"\n            case planet1\
    \ if (planet1.length < 56) => \"no planet\"\n            case planet1 if (plan\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"\
    Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpjmkd5drq.scala:51:4 ----------------------------\e\
    [0m\e[0m\n\e[31m51 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpjmkd5drq.scala:63:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m63 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E006] Not\
    \ Found Error: /tmp/tmpjmkd5drq.scala:50:29 ------------------------\e[0m\e[0m\n\
    \e[31m50 |\e[0m            \e[33mcase\e[0m planet1 \e[33mif\e[0m (plan\n\e[31m\e\
    [31m   |\e[0m                             ^^^^\e[0m\n\e[31m   |\e[0m         \
    \                    Not found: plan\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpjmkd5drq.scala:62:1 ---------------------\e[0m\e\
    [0m\n\e[31m62 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e[0m\n\e[31m   |\e[0m Found:  \
    \  Unit\n\e[31m   |\e[0m Required: List[String]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[33m\e[33m--\
    \ Warning: /tmp/tmpjmkd5drq.scala:52:4 ----------------------------------------\e\
    [0m\e[0m\n\e[33m52 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m\
    \   |\e[0m    Line is indented too far to the left, or a `}` is missing\n1 warning\
    \ found\n4 errors found\n"
  stdout: ''
  timestamp: 1660009780
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = mutable.ListBuffer[String]()\n     \
    \   planets ++= Seq(\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\", \"Neptune\")\n        planets ++= Seq(planet1, planet2)\n\
    \        planets.toList sortBy (x => planets.indexOf(x.toUpperCase).asInstanceOf[Int]\
    \ - planets.indexOf(x.toUpperCase).asInstanceOf[Int]) * planets.indexOf(planet1.toUpperCase).asInstanceOf[Int]\
    \ - planets.indexOf(planet2.toUpperCase).asInstanceOf[Int]\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmguo_mvs.scala:21:22 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mplanets\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660009776
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n      val planetsBetween = for {\n        planet <- Planets\n\
    \        if (planet.name == planet1) || (planet.name == planet2)\n      } yield\
    \ planet.name\n      val planetsBetweenWithDistance = for {\n        planet <-\
    \ Planets\n        if (planet.name == planet1) || (planet.name == planet2)\n \
    \     } yield (planet.name, distance(planet))\n      planetsBetween.sortBy(_._2)\n\
    \    } \n    def distance(p1 : Planet) : Double = {\n      val earth = Sun\n \
    \     val sun = p1.orbit(earth)\n      val p2 = p1.orbit(p1.orbit(sun))\n    \
    \  val p3 = p2.orbit(p2.orbit(sun))\n      val p4 = p3.orbit(p3.orbit(sun))\n\
    \      val p5 = p4.orbit(p4.orbit(sun))\n      val p6 = p5.orbit(p5.orbit(sun))\n\
    \      val p7 = p6.orbit(p6.orbit(sun))\n      val p8 = p7.orbit(p7.orbit(sun))\n\
    \      val planet1Dist = math.pow((sun - p1), 2)\n      val planet2Dist = math.pow((sun\
    \ - p2), 2)\n      val planet3Dist = math.pow((sun - p3), 2)\n      val planet4Dist\
    \ = math.pow((sun - p4), 2)\n      val planet5Dist = math.pow((sun - p5), 2)\n\
    \      val planet6Dist = math.pow((sun - p6), 2)\n      val planet7Dist = math.pow((sun\
    \ - p7), 2)\n      val planet8Dist = math.pow((sun - p8), 2)\n      math.sqrt(((planet1Dist\
    \ + planet2Dist + planet3Dist + planet4Dist + planet5Dist + planet6Dist + planet7Dist\
    \ + planet8Dist)^(1/2)))\n    }\n    def main(args: Array[String]) = {\n    assert(bf((\"\
    Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n\
    \    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n\
    \    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"),\
    \ (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmps0aqneco.scala:22:18 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        planet <- Planets\n\e[31m\e[31m   |\e[0m    \
    \              ^^^^^^^\e[0m\n\e[31m   |\e[0m                  Not found: Planets\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmps0aqneco.scala:26:18\
    \ ------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        planet <- Planets\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^\e[0m\n\e[31m   |\e[0m         \
    \         Not found: Planets\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmps0aqneco.scala:31:22 ------------------------\e[0m\e[0m\n\e[31m31 |\e\
    [0m    \e[33mdef\e[0m \e[36mdistance\e[0m(\e[36mp1\e[0m : \e[35mPlanet\e[0m) :\
    \ \e[35mDouble\e[0m = {\n\e[31m\e[31m   |\e[0m                      ^^^^^^\e[0m\n\
    \e[31m   |\e[0m                      Not found: type Planet\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmps0aqneco.scala:32:18 ------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m      \e[33mval\e[0m \e[36mearth\e[0m = Sun\n\e[31m\e\
    [31m   |\e[0m                  ^^^\e[0m\n\e[31m   |\e[0m                  Not\
    \ found: Sun\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmps0aqneco.scala:49:128\
    \ -----------------------\e[0m\e[0m\n\e[31m49 |\e[0m      math.sqrt(((planet1Dist\
    \ + planet2Dist + planet3Dist + planet4Dist + planet5Dist + planet6Dist + planet7Dist\
    \ + planet8Dist)^(\e[31m1\e[0m/\e[31m2\e[0m)))\n\e[31m\e[31m   |\e[0m        \
    \         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                 value ^ is not a member of Double\n5 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660009779
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        def distance(a: Double, b: Double) : Double = a *\
    \ b\n        val planets = Set(planet1, planet2)\n        val a1 = planets.filter(x\
    \ => x == planet1).map(x => distance(x,0))\n        val a2 = planets.filter(x\
    \ => x == planet2).map(x => distance(0, x))\n        val b = a1.zip(a2).map(x\
    \ => distance(x(0), x(1)))\n        val sorted = b.sortBy(x => x)\n        if\
    \ (sorted.last < 0 ) { List() } else { sorted.reverse }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxk7kmm_n.scala:23:69\
    \ --------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36ma1\e\
    [0m = planets.filter(\e[36mx\e[0m => x == planet1).map(\e[36mx\e[0m => distance(x,\e\
    [31m0\e[0m))\n\e[31m\e[31m   |\e[0m                                          \
    \                           ^\e[0m\n\e[31m   |\e[0m                          \
    \                        Found:    (x : String)\n\e[31m   |\e[0m             \
    \                                     Required: Double\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpxk7kmm_n.scala:24:72 --------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36ma2\e[0m = planets.filter(\e\
    [36mx\e[0m => x == planet2).map(\e[36mx\e[0m => distance(\e[31m0\e[0m, x))\n\e\
    [31m\e[31m   |\e[0m                                                          \
    \              ^\e[0m\n\e[31m   |\e[0m                                       \
    \           Found:    (x : String)\n\e[31m   |\e[0m                          \
    \                        Required: Double\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpxk7kmm_n.scala:26:23 ------------------------\e[0m\e\
    [0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36msorted\e[0m = b.sortBy(\e[36mx\e\
    [0m => x)\n\e[31m\e[31m   |\e[0m                     ^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m    value sortBy is not a member of scala.collection.mutable.Set[Double]\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1660009782
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        // TODO: your code here\n        val a = List(planet1,\
    \ planet2)\n        var b : List[String] = Nil\n        for (x <- a){\n      \
    \      var c : List[String] = Nil\n            for (y <- a){\n               \
    \ val distance = getDistance(planet1, x)\n                if (distance < getDistance(x,\
    \ planet2)){\n                    c = x :: y\n                }\n            }\n\
    \            b +=  c.sortWith((x1,x2) => x1.compareTo(x2))\n        }\n      \
    \  b.toList\n    }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"\
    ), (\"Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpxom0u688.scala:27:31 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m                \e[33mval\e[0m \e[36mdistance\e[0m =\
    \ getDistance(planet1, x)\n\e[31m\e[31m   |\e[0m                             \
    \  ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                               Not found:\
    \ getDistance\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpxom0u688.scala:29:26\
    \ ------------------------\e[0m\e[0m\n\e[31m29 |\e[0m                    c = x\
    \ :: y\n\e[31m\e[31m   |\e[0m                          ^^^^\e[0m\n\e[31m   |\e\
    [0m                          value :: is not a member of String\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpxom0u688.scala:32:14 ------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m            b +=  c.sortWith((\e[36mx1\e[0m,\e[36mx2\e\
    [0m) => x1.compareTo(x2))\n\e[31m\e[31m   |\e[0m            ^^^^\e[0m\n\e[31m\
    \   |\e[0mvalue += is not a member of List[String] - did you mean List[String].!=?\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxom0u688.scala:32:52 --------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m            b +=  c.sortWith((\e[36mx1\e[0m,\e[36mx2\e\
    [0m) => x1.compareTo(x2))\n\e[31m\e[31m   |\e[0m                             \
    \           ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                           \
    \             Found:    Int\n\e[31m   |\e[0m                                 \
    \       Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660009783
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val mercury = getOrbital(planet1)\n        val venus\
    \ = getOrbital(planet2)\n        val earth = getOrbital(planet1)\n        val\
    \ mars = getOrbital(planet2)\n        val jupiter = getOrbital(planet1)\n    \
    \    val saturn = getOrbital(planet2)\n        val uranus = getOrbital(planet2)\n\
    \        val neptune = getOrbital(planet2)\n        val planets = List(mercury,\
    \ venus, earth, mars, jupiter, saturn, uranus, neptune)\n        val sunOrbit\
    \ = Orbital(\"Sun\", 0, 0, 0)\n        val orbits = List(mercury, venus, earth,\
    \ mars, jupiter, saturn, uranus, neptune)\n        val sunOrbitIndex = orbits.index(sunOrbit)\n\
    \        val planet1 = orbits(sunOrbitIndex)\n        val planet2 = orbits((sunOrbitIndex\
    \ + 1) %orbits.length)\n        val distance = math.sqrt((planet1.x - planet2.x)\
    \ * (planet1.x - planet2.x) + (planet1.y - planet2.y) * (planet1.y - planet2.y)\
    \ + (planet1.z - planet2.z) * (planet1.z - planet2.z))\n        var sortedOrbits\
    \ = orbits.filterNot(p => planets.contains(p)).sortWith((a, b) => math.abs(a.x\
    \ - b.x) < math.abs(a.y - b.y) && math.abs(a.x - b.x) < math.abs(a.z - b.z))\n\
    \        val distances = sortedOrbits.map(p => math.sqrt((p.x - planet1.x) * (p.x\
    \ - planet1.x) + (p.y - planet1.y) * (p.y - planet1.y) + (p.z - planet1.z) * (p.z\
    \ - planet1.z)))\n        val result = distances.filter(_ < distance)\n      \
    \  result.map(p => orbits((orbits.index(planet1) + p) %orbits.length)).toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"\
    Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpkvo2iv2w.scala:21:22 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mmercury\e[0m = getOrbital(planet1)\n\
    \e[31m\e[31m   |\e[0m                      ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                    Not found: getOrbital\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpkvo2iv2w.scala:22:20 ------------------------\e[0m\e\
    [0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mvenus\e[0m = getOrbital(planet2)\n\
    \e[31m\e[31m   |\e[0m                    ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                Not found: getOrbital\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E045]\
    \ Cyclic Error: /tmp/tmpkvo2iv2w.scala:34:22 ---------------------------\e[0m\e\
    [0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36mplanet2\e[0m = orbits((sunOrbitIndex\
    \ + \e[31m1\e[0m) %orbits.length)\n\e[31m\e[31m   |\e[0m                     \
    \ ^\e[0m\n\e[31m   |\e[0m                      Recursive \e[33mvalue\e[0m \e[35morbits\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpkvo2iv2w.scala:32:28\
    \ ---------------------------\e[0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m\
    \ \e[36msunOrbitIndex\e[0m = orbits.index(sunOrbit)\n\e[31m\e[31m   |\e[0m   \
    \                         ^\e[0m\n\e[31m   |\e[0m                            Recursive\
    \ \e[33mvalue\e[0m \e[35morbits\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpkvo2iv2w.scala:23:20 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mearth\e[0m = getOrbital(planet1)\n\
    \e[31m\e[31m   |\e[0m                    ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                Not found: getOrbital\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E045]\
    \ Cyclic Error: /tmp/tmpkvo2iv2w.scala:23:31 ---------------------------\e[0m\e\
    [0m\n\e[31m2"
  stdout: ''
  timestamp: 1660009784
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        if(planet1.toUpperCase == \"MERCURY\"){\n        \
    \    if(planet2.toUpperCase == \"NEPTUNE\"){\n                return List(\"Saturn\"\
    , \"Uranus\")\n            }\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpr6fqa163.scala:21:8\
    \ ---------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mif\e[0m(planet1.toUpperCase\
    \ == \e[31m\"MERCURY\"\e[0m){\n\e[31m\e[31m   |\e[0m        ^\e[0m\n\e[31m   |\e\
    [0m        Found:    Unit\n\e[31m   |\e[0m        Required: List[String]\n\e[31m\
    \   |\e[0m        Maybe you are missing an else part for the conditional?\n\e\
    [31m22 |\e[0m            \e[33mif\e[0m(planet2.toUpperCase == \e[31m\"NEPTUNE\"\
    \e[0m){\n\e[31m23 |\e[0m                \e[33mreturn\e[0m List(\e[31m\"Saturn\"\
    \e[0m, \e[31m\"Uranus\"\e[0m)\n\e[31m24 |\e[0m            }\n\e[31m25 |\e[0m \
    \       }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009780
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = mutable.LinkedHashMap[String, String]()\n\
    \        planets +=(\"Jupiter\" -> \"Saturn\")\n        planets +=(\"Earth\" ->\
    \ \"Venus\")\n        planets +=(\"Mercury\" -> \"Uranus\")\n        planets +=(\"\
    Venus\" -> \"Earth\")\n        planets +=(\"Mars\" -> \"Jupiter\")\n        planets\
    \ +=(\"Saturn\" -> \"Mercury\")\n        planets +=(\"Uranus\" -> \"Mercury\"\
    )\n        planets +=(\"Neptune\" -> \"Earth\")\n\n        (planets.get(planet1),\
    \ planets.get(planet2)).filter(_ != null).map(_._2).sortBy(_ > _)\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp7shwpzdx.scala:21:22 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mplanets\e[0m = mutable.LinkedHashMap[\e\
    [35mString\e[0m, \e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                 \
    \     ^^^^^^^\e[0m\n\e[31m   |\e[0m                      Not found: mutable\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp7shwpzdx.scala:31:53\
    \ ------------------------\e[0m\e[0m\n\e[31m31 |\e[0m        (planets.get(planet1),\
    \ planets.get(planet2)).filter(_ != \e[31mnull\e[0m).map(_._2).sortBy(_ > _)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        value filter is not a member of (Nothing, Nothing)\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660009784
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val orbit_planet1 = orbit(planet1, planet2)\n    \
    \    val orbit_planet2 = orbit(planet2, planet1)\n        val list1 = findOrbitBetweenPlanets(orbit_planet1,\
    \ orbit_planet2)\n        val list2 = findOrbitBetweenPlanets(orbit_planet2, orbit_planet1)\n\
    \        list1 ::: list2\n    }\n    def main(args: Array[String]) = {\n    assert(bf((\"\
    Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n\
    \    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n\
    \    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"),\
    \ (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp2w98fxqr.scala:21:28 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36morbit_planet1\e[0m = orbit(planet1,\
    \ planet2)\n\e[31m\e[31m   |\e[0m                            ^^^^^\e[0m\n\e[31m\
    \   |\e[0m                            Not found: orbit\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp2w98fxqr.scala:22:28 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36morbit_planet2\e[0m = orbit(planet2,\
    \ planet1)\n\e[31m\e[31m   |\e[0m                            ^^^^^\e[0m\n\e[31m\
    \   |\e[0m                            Not found: orbit\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp2w98fxqr.scala:23:20 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mlist1\e[0m = findOrbitBetweenPlanets(orbit_planet1,\
    \ orbit_planet2)\n\e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                    Not found: findOrbitBetweenPlanets\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp2w98fxqr.scala:24:20\
    \ ------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e\
    [36mlist2\e[0m = findOrbitBetweenPlanets(orbit_planet2, orbit_planet1)\n\e[31m\e\
    [31m   |\e[0m                    ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                    Not found: findOrbitBetweenPlanets\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n4 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660009781
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = mutable.ListBuffer[String]()\n     \
    \   planets ++= scala.util.parsing.combinator.JavaTokenParsers.spaceDelimitedList(rep(word(alphabet)))\n\
    \        planets ++= scala.util.parsing.combinator.JavaTokenParsers.spaceDelimitedList(rep(word(alphabet)))\n\
    \        planets ++= scala.util.parsing.combinator.JavaTokenParsers.spaceDelimitedList(rep(word(alphabet)))\n\
    \        planets ++= scala.util.parsing.combinator.JavaTokenParsers.spaceDelimitedList(rep(word(alphabet)))\n\
    \        planets ++= scala.util.parsing.combinator.JavaTokenParsers.spaceDelimitedList(rep(word(alphabet)))\n\
    \        planets ++= scala.util.parsing.combinator.JavaTokenParsers.spaceDelimitedList(rep(word(alphabet)))\n\
    \        planets ++= scala.util.parsing.combinator.JavaTokenParsers.spaceDelimitedList(rep(word(alphabet)))\n\
    \        planets ++= scala.util.parsing.combinator.JavaTokenParsers.spaceDelimitedList(rep(word(alphabet)))\n\
    \        planets ++= scala.util.parsing.combinator.JavaTokenParsers.spaceDelimitedList(rep(word(alphabet)))\n\
    \        planets ++= scala.util.parsing.combinator.JavaTokenParsers.spaceDelimitedList(rep(word(alphabet)))\n\
    \        planets ++= scala.util.parsing.combinator.JavaTokenParsers.spaceDelimitedList(rep(word(alphabet)))\n\
    \        planets ++= scala.util.parsing.combinator.JavaTokenParsers.spaceDelimitedList(rep(word(alphabet)))\n\
    \        planets ++= scala.util.parsing.combinator.JavaTokenParsers.spaceDelimitedList(rep(word(alphabet)))\n\
    \        planets ++= scala.util.parsing.combinator.JavaTokenParsers.spaceDelimitedList(rep(word(alphabet)))\n\
    \        planets ++= scala.util.parsing.combinator.JavaTokenParsers.spaceDelimitedList(rep(word(alphabet)))\n\
    \        planets ++= scala.util.parsing.combinator.JavaTokenParsers.spaceDelimitedList(rep(word(alphabet)))\n\
    \        planets ++= scala.util.parsing.combinator.JavaTokenParsers.spaceDelimitedList(rep(word(alphabet)))\n\
    \        planets ++= scala.util.parsing.combinator.JavaTokenParsers.spaceDelimitedList(re\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"\
    Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpjgiw_7lc.scala:40:4 ----------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpjgiw_7lc.scala:21:22\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mplanets\e[0m = mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e\
    [0m                      ^^^^^^^\e[0m\n\e[31m   |\e[0m                      Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660009780
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(planet1, planet2)\n        val\
    \ sunOrbit = planets.map(_ -> 1).sum\n        val sun = planets.map(_ -> 0).sum\n\
    \        val orbit = planets.map((_, _) => 0).zipWithIndex\n        val planets\
    \ = orbit.filter(_._2 <= sun).filter(_._2 > sunOrbit).sortBy(_._1)\n        val\
    \ a = planets.filter(_._1 == \"Earth\")\n        val b = planets.filter(_._1 ==\
    \ \"Mercury\")\n        val c = planets.filter(_._1 == \"Venus\")\n        val\
    \ d = planets.filter(_._1 == \"Mars\")\n        val e = planets.filter(_._1 ==\
    \ \"Jupiter\")\n        val f = planets.filter(_._1 == \"Saturn\")\n        val\
    \ g = planets.filter(_._1 == \"Uranus\")\n        val h = planets.filter(_._1\
    \ == \"Neptune\")\n        a :+ b :+ c :+ d :+ e :+ f :+ g :+ h match {\n    \
    \        case x => x.toList\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpx82bu8hq.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mplanets\e[0m = orbit.filter(_._2\
    \ <= sun).filter(_._2 > sunOrbit).sortBy(_._1)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mplanets is already defined as \e[33mvalue\e[0m \e[35mplanets\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- Error: /tmp/tmpx82bu8hq.scala:22:46\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m22 |\e[0m       \
    \ \e[33mval\e[0m \e[36msunOrbit\e[0m = planets.map(_ -> \e[31m1\e[0m).sum\n\e\
    [31m\e[31m   |\e[0m                                              ^\e[0m\n\e[31m\
    \   |\e[0m         No implicit Ordering defined for B\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m         where:    B is a type variable with constraint >: (String,\
    \ Int)\n\e[31m   |\e[0m         .\n\e[31m\e[31m-- Error: /tmp/tmpx82bu8hq.scala:23:41\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m23 |\e[0m       \
    \ \e[33mval\e[0m \e[36msun\e[0m = planets.map(_ -> \e[31m0\e[0m).sum\n\e[31m\e\
    [31m   |\e[0m                                         ^\e[0m\n\e[31m   |\e[0m\
    \         No implicit Ordering defined for B\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \         where:    B is a type variable with constraint >: (String, Int)\n\e\
    [31m   |\e[0m         .\n\e[31m\e[31m-- [E086] Syntax Error: /tmp/tmpx82bu8hq.scala:24:39\
    \ ---------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m\
    \ \e[36morbit\e[0m = planets.map((_, _) => \e[31m0\e[0m).zipWithIndex\n\e[31m\e\
    [31m   |\e[0m                                ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                                Wrong number of parameters, expected: 1\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpx82bu8hq.scala:26:33 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36ma\e[0m = planets.filter(_._1\
    \ == \e[31m\"Earth\"\e[0m)\n\e[31m\e[31m   |\e[0m                            \
    \   ^^^^\e[0m\n\e[31m   |\e[0m                               value _1 is not a\
    \ member of Stri"
  stdout: ''
  timestamp: 1660009787
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n      val (earth, mercury, venus, mars, jupiter, saturn, uranus,\
    \ neptune) = (planet1 :: planet2).sliding(2)\n      \n      val (earth1, mercury1,\
    \ venus1, mars1, jupiter1, saturn1, uranus1, neptune1) = (earth :+ mercury, venus\
    \ :+ mercury, venus :+ mars, jupiter, saturn, uranus, neptune)\n      val (earth2,\
    \ mercury2, venus2, mars2, jupiter2, saturn2, uranus2, neptune2) = (earth :+ mercury,\
    \ venus :+ mercury, venus :+ mars, jupiter, saturn, uranus, neptune)\n      \n\
    \      val p1 = earth1 ++ mercury1 ++ venus1 ++ mars1 ++ jupiter1 ++ saturn1 ++\
    \ uranus1 ++ neptune1\n      val p2 = earth2 ++ mercury2 ++ venus2 ++ mars2 ++\
    \ jupiter2 ++ saturn2 ++ uranus2 ++ neptune2\n\n      val p1 = p1.toList\n   \
    \   val p2 = p2.toList\n\n      val p1 = p1 diff p2\n      val p2 = p2 diff p1\n\
    \n      val p1 = p1 sortBy (x => math.abs(x - math.round(math.sin(math.pi/6) *\
    \ (x - (math.pi/6))))) \n      val p2 = p2 sortBy (x => math.abs(x - math.round(math.sin(math.pi/6)\
    \ * (x - (math.pi/6))))) \n      \n      p1 ++ p2\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp5f9fk0ei.scala:29:10 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m      \e[33mval\e[0m \e[36mp1\e[0m = p1.toList\n\e[31m\e\
    [31m   |\e[0m      ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mp1 is already defined\
    \ as \e[33mvalue\e[0m \e[35mp1\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp5f9fk0ei.scala:30:10 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m      \e[33mval\e[0m \e[36mp2\e[0m = p2.toList\n\e[31m\e\
    [31m   |\e[0m      ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mp2 is already defined\
    \ as \e[33mvalue\e[0m \e[35mp2\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp5f9fk0ei.scala:32:10 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m      \e[33mval\e[0m \e[36mp1\e[0m = p1 diff p2\n\e[31m\e\
    [31m   |\e[0m      ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mp1 is already defined\
    \ as \e[33mvalue\e[0m \e[35mp1\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp5f9fk0ei.scala:33:10 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m      \e[33mval\e[0m \e[36mp2\e[0m = p2 diff p1\n\e[31m\e\
    [31m   |\e[0m      ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mp2 is already defined\
    \ as \e[33mvalue\e[0m \e[35mp2\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp5f9fk0ei.scala:35:10 ---------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m      \e[33mval\e[0m \e[36mp1\e[0m = p1 sortBy (\e[36mx\e\
    [0m => math.abs(x - math.round(math.sin(math.pi/\e[31m6\e[0m) * (x - (math.pi/\e\
    [31m6\e[0m))))) \n\e[31m\e[31m   |\e[0m      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mp1 is already defined as \e[33mvalue\e[0m \e[35mp1\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must al"
  stdout: ''
  timestamp: 1660009785
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(planet1, planet2)\n        val\
    \ sun = Planet(\"Sun\")\n        val mercury = Planet(\"Mercury\")\n        val\
    \ venus = Planet(\"Venus\")\n        val earth = Planet(\"Earth\")\n        val\
    \ mars = Planet(\"Mars\")\n        val jupiter = Planet(\"Jupiter\")\n       \
    \ val saturn = Planet(\"Saturn\")\n        val uranus = Planet(\"Uranus\")\n \
    \       val neptune = Planet(\"Neptune\")\n\n        // A simple function to find\
    \ the distance between two planets\n        val distanceBetweenPlanets = (planet:\
    \ Planet) => planet.distanceTo(sun)\n\n        // Planets where the planet is\
    \ located between its orbits\n        val planetsBetweenPlanets = planets.map(distanceBetweenPlanets)\n\
    \            .filter( d => d > 0)\n\n        // Sort planets\n        val orderedPlanets\
    \ = planetsBetweenPlanets.sorted\n            .zipWithIndex.filter{case (planet,\
    \ index) => planet > 0}\n            .map{case (planet, index) => planets(index)\
    \ }\n\n        // return empty list if one of the planets are not correct\n  \
    \      if (planet1 != planet2) {\n            val empty = List[String]()\n   \
    \         if (planet1 == null || planet2 == null) {\n                empty\n \
    \           } else if (planet1 == planet2) {\n                List(planet1)\n\
    \            } else {\n                List(planet1, planet2)\n            }\n\
    \        } else {\n            orderedPlanets\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpjnz2o6ke.scala:22:18 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36msun\e[0m = Planet(\e[31m\"\
    Sun\"\e[0m)\n\e[31m\e[31m   |\e[0m                  ^^^^^^\e[0m\n\e[31m   |\e\
    [0m                  Not found: Planet\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpjnz2o6ke.scala:23:22 ------------------------\e[0m\e\
    [0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mmercury\e[0m = Planet(\e[31m\"\
    Mercury\"\e[0m)\n\e[31m\e[31m   |\e[0m                      ^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                      Not found: Planet\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpjnz2o6ke.scala:24:20 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mvenus\e[0m = Planet(\e[31m\"\
    Venus\"\e[0m)\n\e[31m\e[31m   |\e[0m                    ^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                    Not found: Planet\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpjnz2o6ke.scala:25:20 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mearth\e[0m = Planet(\e[31m\"\
    Earth\"\e[0m)\n\e[31m\e[31m   |\e[0m                    ^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                    Not found: Planet\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpjnz2o6ke.scala:26:19 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mmars\e[0m = Planet(\e[31m\"\
    Mars\"\e[0m)\n\e[31m\e[31m   |\e[0m                   ^^^^^^\e[0m\n\e[31m   |\e\
    [0m                   Not found: Planet\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpjnz2o6ke.scala:27:22 ------------------------\e[0m\e\
    [0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mjupiter\e[0m = Planet(\e[31m\"\
    Jupiter\"\e[0m)\n\e[31m\e[31m   |\e[0m                      ^^^^^^\e[0m\n\e[31m\
    \  "
  stdout: ''
  timestamp: 1660009786
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        def distance(x: Double, y: Double) : Double = {\n\
    \            val dist = sqrt(x*x + y*y)\n            dist\n        }\n       \
    \ val list1 = List(\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"\
    Uranus\", \"Neptune\")\n        val list2 = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        if(planet1.toUpperCase\
    \ == \"JUPITER\" && planet2.toUpperCase == \"NEPTUNE\") {\n            return\
    \ list2.sortWith(distance(_, 8.4))\n        } else if (planet1.toUpperCase ==\
    \ \"EARTH\" && planet2.toUpperCase == \"MERCURY\") {\n            return list1.sortWith(distance(_,\
    \ 8.4))\n        } else if (planet1.toUpperCase == \"MERCURY\" && planet2.toUpperCase\
    \ == \"URANUS\") {\n            return list1.sortWith(distance(_, 4.4))\n    \
    \    } else if (planet1.toUpperCase == \"MERCURY\" && planet2.toUpperCase == \"\
    NEPTUNE\") {\n            return list2.sortWith(distance(_, 4.4))\n        } else\
    \ if (planet1.toUpperCase == \"MARS\" && planet2.toUpperCase == \"JUPITER\") {\n\
    \            return list1.sortWith(distance(_, 8.4))\n        } else if (planet1.toUpperCase\
    \ == \"MARS\" && planet2.toUpperCase == \"SATURN\") {\n            return list2.sortWith(distance(_,\
    \ 8.4))\n        } else if (planet1.toUpperCase == \"MARS\" && planet2.toUpperCase\
    \ == \"URANUS\") {\n            return list1.sortWith(distance(_, 4.4))\n    \
    \    } else if (planet1.toUpperCase == \"MARS\" && planet2.toUpperCase == \"NEPTUNE\"\
    ) {\n            return list2.sortWith(distance(_, 4.4))\n        } else if (planet1.toUpperCase\
    \ == \"JUPITER\" && planet2.toUpperCase == \"SATURN\") {\n            return list1.sortWith(distance(_,\
    \ 8.4))\n        } else if (planet1.toUpperCase == \"JUPITER\" && planet2.toUpperCase\
    \ == \"URANUS\") {\n            return list1.sortWith(distance(_, 4.4))\n    \
    \    } else if (planet1.toUpperCase == \"JUPITER\" && planet2.toUpperCase == \"\
    NEPTUNE\") {\n            return list2.sortWith(distance(_, 4.4))\n        } else\
    \ if (planet1.toUpperCase == \"SATURN\" && planet2.toUpperCase == \"URANUS\")\
    \ {\n            return list1.\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\",\
    \ \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp7tqk_l5t.scala:51:4 ----------------------------\e\
    [0m\e[0m\n\e[31m51 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tmp7tqk_l5t.scala:63:0 ----------------------------\e[0m\e[0m\n\e[31m63\
    \ |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\
    \e[31m\e[31m-- [E086] Syntax Error: /tmp/tmp7tqk_l5t.scala:28:34 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m            \e[33mreturn\e[0m list2.sortWith(distance(_,\
    \ \e[31m8.4\e[0m))\n\e[31m\e[31m   |\e[0m                                  ^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                 Wrong number of parameters,\
    \ expected: 2\n\e[31m\e[31m-- [E086] Syntax Error: /tmp/tmp7tqk_l5t.scala:30:34\
    \ ---------------------------\e[0m\e[0m\n\e[31m30 |\e[0m            \e[33mreturn\e\
    [0m list1.sortWith(distance(_, \e[31m8.4\e[0m))\n\e[31m\e[31m   |\e[0m       \
    \                           ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m           \
    \                      Wrong number of parameters, expected: 2\n\e[31m\e[31m--\
    \ [E086] Syntax Error: /tmp/tmp7tqk_l5t.scala:32:34 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m            \e[33mreturn\e[0m list1.sortWith(distance(_,\
    \ \e[31m4.4\e[0m))\n\e[31m\e[31m   |\e[0m                                  ^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                 Wrong number of parameters,\
    \ expected: 2\n\e[31m\e[31m-- [E086] Syntax Error: /tmp/tmp7tqk_l5t.scala:34:34\
    \ ---------------------------\e[0m\e[0m\n\e[31m34 |\e[0m            \e[33mreturn\e\
    [0m list2.sortWith(distance(_, \e[31m4.4\e[0m))\n\e[31m\e[31m   |\e[0m       \
    \                           ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m           \
    \                      Wrong number of parameters, expected: 2\n\e[31m\e[31m--\
    \ [E086] Syntax Error: /tmp/tmp7tqk_l5t.scala:36:34 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m            \e[33mreturn\e[0m list1.sortWith(distance(_,\
    \ \e[31m8.4\e[0m))\n\e[31m\e[31m   |\e[0m                                  ^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                 Wron"
  stdout: ''
  timestamp: 1660009788
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val orbits = Map(\n            (\"Jupiter\", \"Mercury\"\
    ),\n            (\"Venus\", \"Earth\"),\n            (\"Earth\", \"Mars\"),\n\
    \            (\"Mars\", \"Jupiter\"),\n            (\"Jupiter\", \"Saturn\"),\n\
    \            (\"Saturn\", \"Uranus\"),\n            (\"Uranus\", \"Neptune\")\n\
    \        )\n        val orbit1 = orbits(planet1)\n        val orbit2 = orbits(planet2)\n\
    \        val intersections = intersection(orbit1, orbit2)\n        val planetsInOrbit1\
    \ = intersections.map(x => orbits(x)).sortBy(x => scala.math.sqrt((x - orbit2).pow(2)).abs)\n\
    \        val planetsInOrbit2 = intersections.map(x => orbits(x)).sortBy(x => scala.math.sqrt((x\
    \ - orbit1).pow(2)).abs)\n        val intersection = planetsInOrbit1 ++ planetsInOrbit2\n\
    \        val sun = orbits(\"Sun\")\n        val planetsInOrbit = intersection.map(x\
    \ => orbits(x)).sortBy(x => scala.math.sqrt((x - sun).pow(2)).abs)\n        planetsInOrbit\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"\
    Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpy3mxe55u.scala:33:30 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mplanetsInOrbit1\e[0m = intersections.map(\e\
    [36mx\e[0m => orbits(x)).sortBy(\e[36mx\e[0m => scala.math.sqrt((x - orbit2).pow(\e\
    [31m2\e[0m)).abs)\n\e[31m\e[31m   |\e[0m                              ^\e[0m\n\
    \e[31m   |\e[0m                              Recursive \e[33mvalue\e[0m \e[35mintersections\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009785
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val orbit1 = List(Mercury, Venus, Earth, Mars, Jupiter,\
    \ Saturn, Uranus, Neptune).toMap\n        val orbit2 = List(Mercury, Venus, Earth,\
    \ Mars, Jupiter, Saturn, Uranus, Neptune).toMap\n        val orbit12 = orbit1\
    \ ++ orbit2\n        val sun = Melania\n        val dist = new DistanceCalc(sun)\n\
    \        val planetsBetween = (planet1 :: planet2) map { planet => planet }\n\
    \        if (planetsBetween.forall(_.startsWith(\"Mercury\"))) List(planet1) else\
    \ List()\n    } \n    // There is only one planet in our solar system Earth. \n\
    \    // Write a function that, given a string planet name, returns the orbit \n\
    \    // of that planet. \n    // The function should return \"0.0\" if the planet\
    \ does not exist. \n    // Examples\n    // >>> planet(Melania)\n    // 0.0\n\
    \    // >>> planet(\"Mercury\")\n    // 0.0\n    // >>> planet(\"Earth\")\n  \
    \  // 0.0\n    // >>> planet(\"Venus\")\n    // 0.0\n    def planet(planet : String)\
    \ : Double = {\n        val orbit = List(Mercury, Venus, Earth, Mars, Jupiter,\
    \ Saturn, Uranus, Neptune).toMap\n        if (planet.startsWith(\"Mercury\"))\
    \ 0.0\n        else if (planet.startsWith(\"Venus\")) 0.0\n        else if (planet.startsWith(\"\
    Earth\")) 0.0\n        else if (planet.startsWith(\"Mars\")) 0.0\n        else\
    \ if (planet.startsWith(\"Jupiter\")) 0.0\n        else if (planet.startsWith(\"\
    Saturn\")) 0.0\n        else if (planet.startsWith(\"Uranus\")) 0.0\n        else\
    \ if (planet.startsWith(\"Neptune\")) 0.0\n        else orbit.get(planet)\n  \
    \  } \n    // The radius of the Sun is 0.6973 au. \n    // Write a function that,\
    \ given a name of a planet and returns its radius. \n    // The function should\
    \ return \"0.0\" if the planet does not exist. \n    // Examples\n    // >>> radius(Melania)\n\
    \    // 0.0\n    // >>> radius(\"Mercury\")\n    // 0.0\n    // >>> radius(\"\
    Earth\")\n    // 0.0\n    // >>> radius(\"Venus\")\n    // 0.0\n    def radius(planet\
    \ : String) : Double = {\n        val orbit = List(Mercury, Venus, Earth, Mars,\
    \ Jupiter, Saturn, Uranus, Ne\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\",\
    \ \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpdil2oz9_.scala:68:4 ----------------------------\e\
    [0m\e[0m\n\e[31m68 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpdil2oz9_.scala:21:26\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36morbit1\e[0m = List(Mercury, Venus, Earth, Mars, Jupiter, Saturn, Uranus, Neptune).toMap\n\
    \e[31m\e[31m   |\e[0m                          ^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \                         Not found: Mercury\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpdil2oz9_.scala:21:35 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36morbit1\e[0m = List(Mercury,\
    \ Venus, Earth, Mars, Jupiter, Saturn, Uranus, Neptune).toMap\n\e[31m\e[31m  \
    \ |\e[0m                                   ^^^^^\e[0m\n\e[31m   |\e[0m       \
    \                            Not found: Venus\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpdil2oz9_.scala:21:42 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36morbit1\e[0m = List(Mercury,\
    \ Venus, Earth, Mars, Jupiter, Saturn, Uranus, Neptune).toMap\n\e[31m\e[31m  \
    \ |\e[0m                                          ^^^^^\e[0m\n\e[31m   |\e[0m\
    \                                          Not found: Earth\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpdil2oz9_.scala:21:49 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36morbit1\e[0m = List(Mercury,\
    \ Venus, Earth, Mars, Jupiter, Saturn, Uranus, Neptune).toMap\n\e[31m\e[31m  \
    \ |\e[0m                                                 ^^^^\e[0m\n\e[31m   |\e\
    [0m                                                 Not found: Mars\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpdil2oz9_.scala:21:55 -"
  stdout: ''
  timestamp: 1660009790
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planet1 = \"Mercury\"\n        val planet2 = \"\
    Venus\"\n        val planet3 = \"Earth\"\n        val planet4 = \"Mars\"\n   \
    \     val planet5 = \"Jupiter\"\n        val planet6 = \"Saturn\"\n        val\
    \ planet7 = \"Uranus\"\n        val planet8 = \"Neptune\"\n        val planet\
    \ = planet1 :: planet2 :: planet3 :: planet4 :: planet5 :: planet6 :: planet7\
    \ :: planet8\n        val sun = Planet.sun\n        val orb = (planet contains\
    \ planet1) match {\n            case true => (planet contains planet2)\n     \
    \       case false => orb(planet1, planet2)\n        }\n        val sun_orb =\
    \ (sun contains planet1) match {\n            case true => (sun contains planet2)\n\
    \            case false => orb(planet1, planet2)\n        }\n        if (sun_orb.isDefined)\
    \ List(planet1.toString -> sun_orb.get.orbit.toString, sun_orb.get.orbit.toString)\
    \ :: orb.toList else orb\n    }\n    def main(args: Array[String]) = {\n    assert(bf((\"\
    Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n\
    \    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n\
    \    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"),\
    \ (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp1wtcigjw.scala:29:95 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mplanet\e[0m = planet1 ::\
    \ planet2 :: planet3 :: planet4 :: planet5 :: planet6 :: planet7 :: planet8\n\e\
    [31m\e[31m   |\e[0m                                                          \
    \                                     ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m       \
    \                               value :: is not a member of String\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp1wtcigjw.scala:30:18 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36msun\e[0m = Planet.sun\n\e\
    [31m\e[31m   |\e[0m                  ^^^^^^\e[0m\n\e[31m   |\e[0m            \
    \      Not found: Planet\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmp1wtcigjw.scala:33:26 ---------------------------\e[0m\e[0m\n\e[31m33\
    \ |\e[0m            \e[33mcase\e[0m \e[31mfalse\e[0m => orb(planet1, planet2)\n\
    \e[31m\e[31m   |\e[0m                          ^\e[0m\n\e[31m   |\e[0m       \
    \                   Recursive \e[33mvalue\e[0m \e[35morb\e[0m needs type\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1660009789
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val sunOrbit = List(\n            List(List(List(0.12,\
    \ 0.12, 0.12), List(0.17, 0.17, 0.17), List(0.30, 0.30, 0.30)), \n           \
    \ List(List(0.07, 0.13, 0.06), List(0.06, 0.11, 0.07), List(0.09, 0.12, 0.12),\
    \ List(0.09, 0.11, 0.11)), \n            List(List(0.06, 0.07, 0.06), List(0.06,\
    \ 0.07, 0.11), List(0.05, 0.11, 0.05)),\n            List(List(0.05, 0.11, 0.05),\
    \ List(0.05, 0.11, 0.05), List(0.07, 0.11, 0.07)),\n            List(List(0.07,\
    \ 0.11, 0.07), List(0.07, 0.11, 0.07)), \n            List(List(0.09, 0.10, 0.09),\
    \ List(0.09, 0.11, 0.09), List(0.09, 0.11, 0.11)), \n            List(List(0.05,\
    \ 0.12, 0.10), List(0.05, 0.11, 0.10), List(0.05, 0.11, 0.10), List(0.07, 0.11,\
    \ 0.10)), \n            List(List(0.05, 0.11, 0.10), List(0.05, 0.12, 0.10), List(0.05,\
    \ 0.11, 0.10), List(0.06, 0.11, 0.10)), \n            List(List(0.07, 0.11, 0.10),\
    \ List(0.05, 0.12, 0.10), List(0.05, 0.11, 0.10), List(0.06, 0.11, 0.10)),\n \
    \           List(List(0.05, 0.11, 0.10), List(0.05, 0.12, 0.10), List(0.05, 0.11,\
    \ 0.10), List(0.06, 0.11, 0.10))\n        )\n        val p1 = planet1 \n     \
    \   val p2 = planet2 \n        val orbits1 = sunOrbit(p1)\n        val orbits2\
    \ = sunOrbit(p2)\n        val orbits = orbits1.intersect(orbits2).sortBy(x =>\
    \ x.diff[Double](x.productElement(0)))\n        orbits.flatMap(x => List(if (p1\
    \ < x) p1 else x, if (p2 < x) p2 else x))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpoze7havq.scala:33:8 ----------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mp1\e[0m = planet1 \n\e[31m\e\
    [31m   |\e[0m        ^^^\e[0m\n\e[31m   |\e[0m        ')' expected, but 'val'\
    \ found\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpoze7havq.scala:39:5\
    \ ---------------------\e[0m\e[0m\n\e[31m39 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[String]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660009789
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        var list : List[String] = Nil\n        var x = 0\n\
    \        var y = 0\n        var z = 100\n\n        //The sun should be located\
    \ in Earth\n        if (planet1.equals(\"Earth\")) list = Nil\n\n        //Mercury\
    \ is a great planet but is located between Mars and Jupiter\n        else if (planet1.equals(\"\
    Mercury\") && planet2.equals(\"Mars\") || planet1.equals(\"Mercury\") && planet2.equals(\"\
    Jupiter\")) list += planet1\n\n        //Mercury and Venus are far apart so they\
    \ aren't in the list.\n        else if (planet1.equals(\"Mercury\") && planet2.equals(\"\
    Venus\")) list = Nil\n\n        //Earth and Jupiter are both great planets so\
    \ they will be in the list\n        else if (planet1.equals(\"Earth\") && planet2.equals(\"\
    Jupiter\")) list += planet1\n\n        //Mercury and Venus are too close so the\
    \ planets must be in the list.\n        else if (planet1.equals(\"Mercury\") &&\
    \ planet2.equals(\"Venus\")) list += planet1\n\n        //The two planets are\
    \ near each other so they are in the list.\n        else if (planet1.equals(\"\
    Neptune\") && planet2.equals(\"Pluto\")) list += planet1\n\n        //The two\
    \ planets are too far apart so the planets must be in the list.\n        else\
    \ if (planet1.equals(\"Neptune\") && planet2.equals(\"Pluto\")) list += planet1\n\
    \n        //The two planets are near each other but Mercury and Venus are too\
    \ far apart so they are in the list.\n        else if (planet1.equals(\"Neptune\"\
    ) && planet2.equals(\"Pluto\")) list += planet1\n\n        //The two planets are\
    \ too far apart so the planets must be in the list.\n        else if (planet1.equals(\"\
    Neptune\") && planet2.equals(\"Pluto\")) list += planet1\n\n        //The two\
    \ planets are too far apart so the planets must be in the list.\n        else\
    \ if (planet1.equals(\"Neptune\") && planet2.equals(\"Pluto\")) list += planet1\n\
    \n        //The two planets are too far apart so the planets must be in the list.\n\
    \        else if (planet1.equals(\"Neptune\") && planet2.equals(\"Pluto\")) list\
    \ += planet1\n\n        //The two \n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmprc19210r.scala:27:42\
    \ --------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mif\e[0m (planet1.equals(\e\
    [31m\"Earth\"\e[0m)) list = Nil\n\e[31m\e[31m   |\e[0m                       \
    \              ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                              \
    \       Found:    Unit\n\e[31m   |\e[0m                                     Required:\
    \ List[String]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmprc19210r.scala:30:133\
    \ -----------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33melse\e[0m \e\
    [33mif\e[0m (planet1.equals(\e[31m\"Mercury\"\e[0m) && planet2.equals(\e[31m\"\
    Mars\"\e[0m) || planet1.equals(\e[31m\"Mercury\"\e[0m) && planet2.equals(\e[31m\"\
    Jupiter\"\e[0m)) list += planet1\n\e[31m\e[31m   |\e[0m                      \
    \                                                                            \
    \                              ^^^^^^^\e[0m\n\e[31m   |\e[0mvalue += is not a\
    \ member of List[String] - did you mean List[String].!=?\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmprc19210r.scala:33:76 --------------------\e[0m\e\
    [0m\n\e[31m33 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (planet1.equals(\e[31m\"\
    Mercury\"\e[0m) && planet2.equals(\e[31m\"Venus\"\e[0m)) list = Nil\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \       ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                                     \
    \             Found:    Unit\n\e[31m   |\e[0m                                \
    \                  Required: List[String]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmprc19210r.scala:36:76 ------------------------\e[0m\e\
    [0m\n\e[31m36 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (planet1.equals(\e[31m\"\
    Earth\"\e[0m) && planet2.equals(\e[31m\"Jupiter\"\e[0m)) list += planet1\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \       ^^^^^^^\e[0m\n\e[31m   |\e[0mvalue += is not a member of List[String]\
    \ - did you mean List[String].!=?\n\e[31m\e[31m--"
  stdout: ''
  timestamp: 1660009791
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val mercuryVsJupiter = orbbetween(\"Mercury\", \"\
    Jupiter\")\n        val venusVsEarth = orbbetween(\"Venus\", \"Earth\")\n    \
    \    val mercuryVsMercury = orbbetween(\"Mercury\", \"Mercury\")\n        val\
    \ mercuryVsVenus = orbbetween(\"Mercury\", \"Venus\")\n        val mercuryVsEarth\
    \ = orbbetween(\"Mercury\", \"Earth\")\n        val mercuryVsMars = orbbetween(\"\
    Mercury\", \"Mars\")\n        val mercuryVsJupiter = orbbetween(\"Mercury\", \"\
    Jupiter\")\n        val mercuryVsSaturn = orbbetween(\"Mercury\", \"Saturn\")\n\
    \        val mercuryVsUranus = orbbetween(\"Mercury\", \"Uranus\")\n        val\
    \ mercuryVsNeptune = orbbetween(\"Mercury\", \"Neptune\")\n        val venusVsEarth\
    \ = orbbetween(\"Venus\", \"Earth\")\n        val mercuryVsMercury = orbbetween(\"\
    Mercury\", \"Mercury\")\n        val mercuryVsVenus = orbbetween(\"Mercury\",\
    \ \"Venus\")\n        val mercuryVsEarth = orbbetween(\"Mercury\", \"Earth\")\n\
    \        val mercuryVsMars = orbbetween(\"Mercury\", \"Mars\")\n        val mercuryVsJupiter\
    \ = orbbetween(\"Mercury\", \"Jupiter\")\n        val mercuryVsSaturn = orbbetween(\"\
    Mercury\", \"Saturn\")\n        val mercuryVsUranus = orbbetween(\"Mercury\",\
    \ \"Uranus\")\n        val mercuryVsNeptune = orbbetween(\"Mercury\", \"Neptune\"\
    )\n        val venusVsMars = orbbetween(\"Venus\", \"Mars\")\n        val mercuryVsJupiter\
    \ = orbbetween(\"Mercury\", \"Jupiter\")\n        val mercuryVsSaturn = orbbetween(\"\
    Mercury\", \"Saturn\")\n        val mercuryVsUranus = orbbetween(\"Mercury\",\
    \ \"Uranus\")\n        val mercuryVsNeptune = orbbetween(\"Mercury\", \"Neptune\"\
    )\n        val venusVs\n    }\n    def main(args: Array[String]) = {\n    assert(bf((\"\
    Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n\
    \    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n\
    \    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"),\
    \ (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpa155dla3.scala:46:4 ----------------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpa155dla3.scala:27:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmercuryVsJupiter\e[0m = orbbetween(\e[31m\"Mercury\"\e[0m, \e[31m\"Jupiter\"\
    \e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmercuryVsJupiter is already defined as \e[33mvalue\e[0m \e\
    [35mmercuryVsJupiter\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpa155dla3.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mvenusVsEarth\e[0m = orbbetween(\e\
    [31m\"Venus\"\e[0m, \e[31m\"Earth\"\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvenusVsEarth is already defined as \e[33mvalue\e[0m \e[35mvenusVsEarth\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpa155dla3.scala:32:12 ---------------------------\e[0m\e[0m\n\e\
    [31m32 |\e[0m        \e[33mval\e[0m \e[36mmercuryVsMercury\e[0m = orbbetween(\e\
    [31m\"Mercury\"\e[0m, \e[31m\"Mercury\"\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmercuryVsMercury is already defined as \e[33mvalue\e[0m \e\
    [35mmercuryVsMercury\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpa155dla3.scala:33:12 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mmercuryVsVenus\e[0m = orbbetween(\e\
    [31m\"Mercury\"\e[0m, \e[31m\"Venus\"\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmercuryVsVenus is already defined as \e[33mvalue\e[0m"
  stdout: ''
  timestamp: 1660009790
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n      val planets = mutable.ListBuffer[String]()\n      val\
    \ planet1 = planet1.toUpperCase\n      val planet2 = planet2.toUpperCase\n   \
    \   \n      if(planet1 == planet2) planets += planet1\n      else {\n        if(planet1\
    \ == planets(\"Mercury\"))\n          planets ++= planets(\"Mercury\") :+ planet2\n\
    \        else\n          planets ++= planets(\"Earth\") :+ planets(\"Mars\") :+\
    \ planets(\"Jupiter\") :+ planets(\"Saturn\") :+ planets(\"Uranus\") :+ planets(\"\
    Neptune\")\n      }\n      \n      planets.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp8f1yeftx.scala:21:20 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m      \e[33mval\e[0m \e[36mplanets\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E045] Cyclic Error: /tmp/tmp8f1yeftx.scala:22:20 ---------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m      \e[33mval\e[0m \e[36mplanet1\e[0m = planet1.toUpperCase\n\
    \e[31m\e[31m   |\e[0m                    ^\e[0m\n\e[31m   |\e[0m             \
    \       Recursive \e[33mvalue\e[0m \e[35mplanet1\e[0m needs type\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp8f1yeftx.scala:23:20 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m      \e[33mval\e[0m \e[36mplanet2\e[0m = planet2.toUpperCase\n\
    \e[31m\e[31m   |\e[0m                    ^\e[0m\n\e[31m   |\e[0m             \
    \       Recursive \e[33mvalue\e[0m \e[35mplanet2\e[0m needs type\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1660009786
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val orbit1 = Orbit(planet1, 0, 0, 0)\n        val\
    \ orbit2 = Orbit(planet2, 0, 0, 0)\n        var earth_distance : Double = 0.0\n\
    \        var earth_list: List[String] = Nil\n        var earth_name = \"\"\n \
    \       var i = 0\n        var j = 0\n        var k = 0\n        for( i <- 0 to\
    \ orbit1.earth_distance) {\n            earth_distance += orbit1.earth_distance\n\
    \            for( j <- 0 to orbit2.earth_distance) {\n                if(earth_distance\
    \ > orbit2.earth_distance) {\n                    break\n                }\n \
    \               if((orbit1.earth_distance == orbit2.earth_distance) && (earth_distance\
    \ == orbit1.earth_distance)) {\n                    for( k <- 0 to orbit2.earth_distance)\
    \ {\n                        if(earth_distance > orbit2.earth_distance) {\n  \
    \                          break\n                        }\n                \
    \        if((orbit1.earth_distance == orbit2.earth_distance) && (earth_distance\
    \ == orbit1.earth_distance)) {\n                            if(orbit1.sun_distance\
    \ < orbit2.sun_distance) {\n                                earth_name = planet1\n\
    \                                earth_list = orbit2.orbit1\n                \
    \            }\n                            if(orbit1.sun_distance > orbit2.sun_distance)\
    \ {\n                                earth_name = planet2\n                  \
    \              earth_list = orbit1.orbit1\n                            }\n   \
    \                         earth_distance = orbit2.earth_distance\n           \
    \             }\n                    }\n                }\n                earth_distance\
    \ = orbit2.earth_distance\n            }\n        }\n        return earth_list.sortWith(_\
    \ < _)\n    }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"\
    ), (\"Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp7ij6z5_6.scala:21:21 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36morbit1\e[0m = Orbit(planet1,\
    \ \e[31m0\e[0m, \e[31m0\e[0m, \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m           \
    \          ^^^^^\e[0m\n\e[31m   |\e[0m                     Not found: Orbit\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp7ij6z5_6.scala:22:21\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36morbit2\e[0m = Orbit(planet2, \e[31m0\e[0m, \e[31m0\e[0m, \e[31m0\e[0m)\n\e\
    [31m\e[31m   |\e[0m                     ^^^^^\e[0m\n\e[31m   |\e[0m          \
    \           Not found: Orbit\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp7ij6z5_6.scala:33:20 ------------------------\e[0m\e[0m\n\e[31m33 |\e\
    [0m                    break\n\e[31m\e[31m   |\e[0m                    ^^^^^\e\
    [0m\n\e[31m   |\e[0m                    Not found: break\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmp7ij6z5_6.scala:38:28 ------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m                            break\n\e[31m\e[31m   |\e\
    [0m                            ^^^^^\e[0m\n\e[31m   |\e[0m                   \
    \         Not found: break\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660009787
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val orbit1 = getOrbit(planet1)\n        val orbit2\
    \ = getOrbit(planet2)\n        var res : List[String] = Nil\n        for ( i <-\
    \ 1 to orbit1.length ) {\n            res ::= getOrbit(orbit1.get(i)) \n     \
    \       if (orbit2.contains(orbit1.get(i))) {\n                for ( j <- 1 to\
    \ orbit2.length ) {\n                    if (orbit1.contains(orbit2.get(j))) {\n\
    \                        res += orbit2.get(j)\n                    }\n       \
    \         }\n            }\n        }\n        res\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpgrjco22_.scala:21:21 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36morbit1\e[0m = getOrbit(planet1)\n\
    \e[31m\e[31m   |\e[0m                     ^^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                Not found: getOrbit\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpgrjco22_.scala:22:21 ------------------------\e[0m\e\
    [0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36morbit2\e[0m = getOrbit(planet2)\n\
    \e[31m\e[31m   |\e[0m                     ^^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                Not found: getOrbit\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpgrjco22_.scala:25:16 ------------------------\e[0m\e\
    [0m\n\e[31m25 |\e[0m            res ::= getOrbit(orbit1.get(i)) \n\e[31m\e[31m\
    \   |\e[0m            ^^^^^^^\e[0m\n\e[31m   |\e[0mvalue ::= is not a member of\
    \ List[String] - did you mean List[String].::?\n\e[31m\e[31m-- [E006] Not Found\
    \ Error: /tmp/tmpgrjco22_.scala:25:20 ------------------------\e[0m\e[0m\n\e[31m25\
    \ |\e[0m            res ::= getOrbit(orbit1.get(i)) \n\e[31m\e[31m   |\e[0m  \
    \                  ^^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ getOrbit\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpgrjco22_.scala:29:28\
    \ ------------------------\e[0m\e[0m\n\e[31m29 |\e[0m                        res\
    \ += orbit2.get(j)\n\e[31m\e[31m   |\e[0m                        ^^^^^^\e[0m\n\
    \e[31m   |\e[0mvalue += is not a member of List[String] - did you mean List[String].!=?\n\
    5 errors found\n"
  stdout: ''
  timestamp: 1660009792
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        var planets : List[String] = Nil\n        var i =\
    \ 0\n        while(i < planet1.length) {\n            planets = planets ++ List((planet1.substring(i,\
    \ i + 1), planet2.substring(i, i + 1)))\n            i += 2\n        }\n     \
    \   var j = 0\n        var k = 0\n        var j1 = 0\n        var k2 = 0\n   \
    \     while(j < planet2.length) {\n            if(planet1.length == j1) {\n  \
    \              planets = planets ++ List((planet2.substring(j, j), planet2.substring(k,\
    \ k)))\n                j += 2\n                k += 2\n            }\n      \
    \      if(planet1.length == k2) {\n                planets = planets ++ List((planet1.substring(j,\
    \ j), planet1.substring(k, k)))\n                j += 2\n                k +=\
    \ 2\n            }\n            j1 = j + 1\n            k2 = k + 1\n        }\n\
    \        if(planet1.length != j) {\n            planets = planets ++ List((planet1.substring(j,\
    \ j), planet2.substring(j, j)))\n        }\n        if(planet2.length != k) {\n\
    \            planets = planets ++ List((planet1.substring(j, j), planet2.substring(k,\
    \ k)))\n        }\n        planets.sortBy(x => (getProximity(x).toDouble))\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"\
    Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphktqkean.scala:24:38\
    \ --------------------\e[0m\e[0m\n\e[31m24 |\e[0m            planets = planets\
    \ ++ List((planet1.substring(i, i + \e[31m1\e[0m), planet2.substring(i, i + \e\
    [31m1\e[0m)))\n\e[31m\e[31m   |\e[0m                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                      Found:    \e[1m\e[31m(\e\
    [0m\e[1m\e[31mString\e[0m\e[1m\e[31m,\e[0m\e[1m\e[31m \e[0mString\e[1m\e[31m)\e\
    [0m\n\e[31m   |\e[0m                                      Required: String\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphktqkean.scala:33:42\
    \ --------------------\e[0m\e[0m\n\e[31m33 |\e[0m                planets = planets\
    \ ++ List((planet2.substring(j, j), planet2.substring(k, k)))\n\e[31m\e[31m  \
    \ |\e[0m                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                          Found:    \e[1m\e\
    [31m(\e[0m\e[1m\e[31mString\e[0m\e[1m\e[31m,\e[0m\e[1m\e[31m \e[0mString\e[1m\e\
    [31m)\e[0m\n\e[31m   |\e[0m                                          Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphktqkean.scala:38:42\
    \ --------------------\e[0m\e[0m\n\e[31m38 |\e[0m                planets = planets\
    \ ++ List((planet1.substring(j, j), planet1.substring(k, k)))\n\e[31m\e[31m  \
    \ |\e[0m                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                          Found:    \e[1m\e\
    [31m(\e[0m\e[1m\e[31mString\e[0m\e[1m\e[31m,\e[0m\e[1m\e[31m \e[0mString\e[1m\e\
    [31m)\e[0m\n\e[31m   |\e[0m                                          Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphktqkean.scala:46:38\
    \ --------------------\e[0m\e[0m\n\e[31m46 |\e[0m            planets = planets\
    \ ++ L"
  stdout: ''
  timestamp: 1660009794
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n      val planets = Set(planet1, planet2)\n      val planetList1\
    \ = List(\n        \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"\
    Uranus\",\n        \"Neptune\")\n      val planetList2 = List(\n        \"Mercury\"\
    , \"Moon\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\",\n       \
    \ \"Uranus\", \"Neptune\")\n      val distFunc = (planet1: String, planet2: String)\
    \ => \n        planetList1.map(planet1 => planetList2.map(planet2 => \n      \
    \    if (planet1 == planet2) 0 else\n        math.sqrt((planetList1.indexWhere(p\
    \ => p < planet1) + \n          planetList1.indexWhere(p => p > planet1) + \n\
    \          planetList2.indexWhere(p => p < planet2) + \n          planetList2.indexWhere(p\
    \ > planet2)) - planetList1.indexWhere(p => \n          p < planet1) + planetList2.indexWhere(p\
    \ > planet2))).max(0)).min(0)\n      val result = (planets: Iterable[String]).iterator.map(planet1\
    \ =>\n        planets.filter(planet2 => distFunc(planet1, planet2) == distFunc(planet2,\
    \ \n          planet1)).toList)\n      result.flatten.sorted\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp212j5w35.scala:34:33 ------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m          planetList2.indexWhere(p > planet2)) - planetList1.indexWhere(p\
    \ => \n\e[31m\e[31m   |\e[0m                                 ^\e[0m\n\e[31m  \
    \ |\e[0m                                 Not found: p\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp212j5w35.scala:35:48 ------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m          p < planet1) + planetList2.indexWhere(p > planet2))).max(\e\
    [31m0\e[0m)).min(\e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m                        \
    \                        ^\e[0m\n\e[31m   |\e[0m                             \
    \                   Not found: p\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp212j5w35.scala:35:67 --------------------\e[0m\e[0m\n\e[31m35\
    \ |\e[0m          p < planet1) + planetList2.indexWhere(p > planet2))).max(\e\
    [31m0\e[0m)).min(\e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m                        \
    \                                           ^\e[0m\n\e[31m   |\e[0m          \
    \                                    Found:    (\e[31m0\e[0m : Int)\n\e[31m  \
    \ |\e[0m                                              Required: Ordering[Double]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp212j5w35.scala:35:75\
    \ --------------------\e[0m\e[0m\n\e[31m35 |\e[0m          p < planet1) + planetList2.indexWhere(p\
    \ > planet2))).max(\e[31m0\e[0m)).min(\e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m   \
    \                                                                        ^\e[0m\n\
    \e[31m   |\e[0m                                              Found:    (\e[31m0\e\
    [0m : Int)\n\e[31m   |\e[0m                                              Required:\
    \ Ordering[Double]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp212j5w35.scala:39:21\
    \ ----------------"
  stdout: ''
  timestamp: 1660009794
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        if (planet1 == planet2) List(planet1)\n        else\
    \ if (planet1 <> planet2) List()\n        else (\n            (\n            \
    \    planet1.toUpperCase.takeWhile(_ != 'E').foldLeft(List())((list, letter) =>\n\
    \                    val (i, planet) = if (letter == 'M') (planet1.toUpperCase.indexOf(\"\
    MERCURY\") + 1, planet1)\n                              else if (letter == 'V')\
    \ (planet1.toUpperCase.indexOf(\"VENUS\") + 1, planet1)\n                    \
    \          else if (letter == 'E') (planet1.toUpperCase.indexOf(\"EARTH\") + 1,\
    \ planet1)\n                              else if (letter == 'M') (planet1.toUpperCase.indexOf(\"\
    MARS\") + 1, planet1)\n                              else if (letter == 'J') (planet1.toUpperCase.indexOf(\"\
    JUPITER\") + 1, planet1)\n                              else if (letter == 'S')\
    \ (planet1.toUpperCase.indexOf(\"SATURN\") + 1, planet1)\n                   \
    \           else if (letter == 'U') (planet1.toUpperCase.indexOf(\"URANUS\") +\
    \ 1, planet1)\n                              else if (letter == 'N') (planet1.toUpperCase.indexOf(\"\
    NEPTUNE\") + 1, planet1)\n                              else (\n             \
    \                   0, planet1\n                              )\n            \
    \        if (i > 0) {\n                        (list + planet, planet)\n     \
    \               } else {\n                        (list, planet)\n           \
    \         }\n                )\n            ).flatten.toList ++\n            (\n\
    \                planet2.toUpperCase.takeWhile(_ != 'E').foldLeft(List())((list,\
    \ letter) =>\n                    val (i, planet) = if (letter == 'M') (planet2.toUpperCase.indexOf(\"\
    MERCURY\") + 1, planet2)\n                              else if (letter == 'V')\
    \ (planet2.toUpperCase.indexOf(\"VENUS\") + 1, planet2)\n                    \
    \          else if (letter == 'E') (planet2.toUpperCase.indexOf(\"EARTH\") + 1,\
    \ planet2)\n                              else if (letter == 'M') (planet2.toUpperCase.indexOf(\"\
    MARS\") + 1, planet2)\n                              else if (letter == 'J') (planet2.toUpperCase.indexOf(\"\
    JUPITER\") + 1, planet2)\n                              else if (letter == 'S')\
    \ (planet2.toUpperCase.indexOf(\"SATURN\") + 1, planet2)\n                   \
    \           else if (letter == 'U') (planet2.toUpperCase.indexOf(\"URANUS\") +\
    \ 1, planet2)\n\n    }\n    def main(args: Array[String]) = {\n    assert(bf((\"\
    Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n\
    \    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n\
    \    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"),\
    \ (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpdcdqbspa.scala:54:4 ----------------------------\e\
    [0m\e[0m\n\e[31m54 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpdcdqbspa.scala:22:25\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33melse\e[0m \e\
    [33mif\e[0m (planet1 <> planet2) List()\n\e[31m\e[31m   |\e[0m               \
    \  ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                 value <> is not a member of\
    \ String\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpdcdqbspa.scala:38:30\
    \ ------------------------\e[0m\e[0m\n\e[31m38 |\e[0m                        (list\
    \ + planet, planet)\n\e[31m\e[31m   |\e[0m                         ^^^^^^\e[0m\n\
    \e[31m   |\e[0mvalue + is not a member of List[Nothing], but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e\
    [0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import\
    \ math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpdcdqbspa.scala:40:24 --------------------\e[0m\e\
    [0m\n\e[31m40 |\e[0m                        (list, planet)\n\e[31m\e[31m   |\e\
    [0m                        ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m              \
    \          Found:    \e[1m\e[31m(\e[0mList[Nothing]\e[1m\e[31m,\e[0m\e[1m\e[31m\
    \ \e[0m\e[1m\e[31mString\e[0m\e[1m\e[31m)\e[0m\n\e[31m   |\e[0m              \
    \          Required: List[Nothing]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpdcdqbspa.scala:52:106 -------------------\e[0m\e[0m\n\e[31m52\
    \ |\e[0m                              \e[33melse\e[0m \e[33mif\e[0m (letter ==\
    \ \e[31m'U'\e[0m) (planet2.toUpperCase.indexOf(\e[31m\"URANUS\"\e[0m) + \e[31m1\e\
    [0m, planet2)\n\e[31m\e[31m   |\e[0m                                         \
    \                                                                 ^\e[0m\n\e[31m\
    \   |\e[0m                    "
  stdout: ''
  timestamp: 1660009794
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        planet1 :: planet2 :: planet1.toLower :: planet2.toLower\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"\
    Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp3otpcebf.scala:21:57 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        planet1 :: planet2 :: planet1.toLower :: planet2.toLower\n\
    \e[31m\e[31m   |\e[0m                                                 ^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                 value toLower is not a member\
    \ of String\n1 error found\n"
  stdout: ''
  timestamp: 1660009793
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        var orbit : String = \"\"\n        var distance :\
    \ Double = Double.MaxValue\n        var orbitList : List[String] = ListBuffer[String]()\n\
    \        val orbit1 = orbit(planet1)\n        val orbit2 = orbit(planet2)\n  \
    \      val orbit1List = orbitList(orbit1)\n        val orbit2List = orbitList(orbit2)\n\
    \        if (planet1 == planet2) (orbit1List :+ orbit2List)\n        else if (orbit1List\
    \ == List()) {\n            (orbit2List :+ planet2)\n        } else if (orbit2List\
    \ == List()) {\n            (orbit1List :+ planet1)\n        } else {\n      \
    \      orbit1List.foreach((orbit1Planet) => {\n                orbit2List.foreach((orbit2Planet)\
    \ => {\n                    val orbitPlanet1 = orbit1Planet + orbit2Planet\n \
    \                   val distancePlanet1 = distance(planet1, orbitPlanet1)\n  \
    \                  val distancePlanet2 = distance(planet2, orbitPlanet1)\n   \
    \                 if (distancePlanet1 <= distancePlanet2) {\n                \
    \        distancePlanet1 <- distancePlanet2\n                        distancePlanet1\
    \ <- distancePlanet1\n                    }\n                    if (distancePlanet1\
    \ < distance) {\n                        distancePlanet1 <- distancePlanet1\n\
    \                        orbitPlanet1 <- orbitPlanet1\n                    }\n\
    \                    if (distancePlanet1 > distance) {\n                     \
    \   distancePlanet1 <- distancePlanet1\n                        orbitPlanet1 <-\
    \ orbitPlanet1\n                    }\n                    if (distancePlanet2\
    \ < distance) {\n                        distancePlanet2 <- distancePlanet2\n\
    \                        orbitPlanet2 <- orbitPlanet2\n                    }\n\
    \                    if (distancePlanet2 > distance) {\n                     \
    \   distancePlanet2 <- distancePlanet2\n                        orbitPlanet2 <-\
    \ orbitPlanet2\n                    }\n                    if (distancePlanet1\
    \ == distancePlanet2) {\n                        orbitList += (orbitPlanet1 :+\
    \ orbitPlanet2)\n                    }\n                    if (distancePlanet2\
    \ < distancePlanet1) {\n                        distancePlanet1 <- distancePlanet2\n\
    \                        orbitPlanet1 <- orbitPlanet1\n                    }\n\
    \                    if (distancePlanet1 < distancePlanet2) {\n              \
    \          distancePlanet2 <- distancePlanet1\n                        orbitPlanet2\
    \ <- orbitPlanet2\n                    }\n                    if (distancePlanet1\
    \ > distancePlanet2) {\n                        distancePlanet1 <- distancePlanet1\n\
    \                        orbitPlanet1 <- orbitPlanet1\n                    }\n\
    \                })\n            })\n        }\n        if (orbitList == List())\
    \ {\n            (List())\n        } else {\n            orbitList.sorted\n  \
    \      }\n    }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"\
    ), (\"Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmprdkvj721.scala:40:40 -----------------------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m                        distancePlanet1 <- distancePlanet2\n\
    \e[31m\e[31m   |\e[0m                                        ^^\e[0m\n\e[31m \
    \  |\e[0m                                end of statement expected but '<-' found\n\
    \e[31m\e[31m-- Error: /tmp/tmprdkvj721.scala:41:40 -----------------------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m                        distancePlanet1 <- distancePlanet1\n\
    \e[31m\e[31m   |\e[0m                                        ^^\e[0m\n\e[31m \
    \  |\e[0m                                end of statement expected but '<-' found\n\
    \e[31m\e[31m-- Error: /tmp/tmprdkvj721.scala:44:40 -----------------------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m                        distancePlanet1 <- distancePlanet1\n\
    \e[31m\e[31m   |\e[0m                                        ^^\e[0m\n\e[31m \
    \  |\e[0m                                end of statement expected but '<-' found\n\
    \e[31m\e[31m-- Error: /tmp/tmprdkvj721.scala:45:37 -----------------------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m                        orbitPlanet1 <- orbitPlanet1\n\
    \e[31m\e[31m   |\e[0m                                     ^^\e[0m\n\e[31m   |\e\
    [0m                                end of statement expected but '<-' found\n\e\
    [31m\e[31m-- Error: /tmp/tmprdkvj721.scala:48:40 -----------------------------------------\e\
    [0m\e[0m\n\e[31m48 |\e[0m                        distancePlanet1 <- distancePlanet1\n\
    \e[31m\e[31m   |\e[0m                                        ^^\e[0m\n\e[31m \
    \  |\e[0m                                end of statement expected but '<-' found\n\
    \e[31m\e[31m-- Error: /tmp/tmprdkvj721.scala:49:37 -----------------------------------------\e\
    [0m\e[0m\n\e[31m49 |\e[0m                        orbitPlanet1 <- orbitPlanet1\n\
    \e[31m\e[31m   |\e[0m                                     ^^\e[0m\n\e[31m   |\e\
    [0m                                end of statement expected but '<-' found\n\e\
    [31m\e[31m-- Error: /tmp/tmprdkvj721.scala:52:40 -----------------------------------------\e\
    [0m\e[0m\n\e[31m52 |\e[0m                      "
  stdout: ''
  timestamp: 1660009795
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        if(planet1.toUpperCase != planet2.toUpperCase)\n \
    \           return (List())\n        else {\n            val m1 = List(Planets.Mercury,Planets.Venus,Planets.Earth,Planets.Mars,Planets.Jupiter,Planets.Saturn,Planets.Uranus,Planets.Neptune)\n\
    \            val m2 = List(Planets.Mercury,Planets.Venus,Planets.Earth,Planets.Mars,Planets.Jupiter,Planets.Saturn,Planets.Uranus,Planets.Neptune)\n\
    \            val i1 = m1.toSet.contains(planet1.toUpperCase)\n            val\
    \ i2 = m2.toSet.contains(planet2.toUpperCase)\n            if(!(planet1.toUpperCase.equals(planet2.toUpperCase)))\n\
    \                return (List())\n            else if((m1.toSet.contains(planet1.toUpperCase))\
    \ && (m2.toSet.contains(planet2.toUpperCase)))\n                return (m1.filter(x\
    \ => x.toString.contains(planet1.toUpperCase)).sorted((x1,x2) => java.lang.Math.abs(x1.getOrbit(planet1).getTime(x2)-planet2.toString.toString.toDouble).get))\n\
    \            else if((m1.toSet.contains(planet2.toUpperCase)) && (m2.toSet.contains(planet1.toUpperCase)))\n\
    \                return (m2.filter(x => x.toString.contains(planet2.toUpperCase)).sorted((x1,x2)\
    \ => java.lang.Math.abs(x1.getOrbit(planet1).getTime(x2)-planet2.toString.toString.toDouble).get))\n\
    \            else if((m1.toSet.contains(planet1.toUpperCase)) && (m2.toSet.contains(planet2.toUpperCase)))\n\
    \                return (m1.filter(x => x.toString.contains(planet1.toUpperCase)).sorted((x1,x2)\
    \ => java.lang.Math.abs(x1.getOrbit(planet2).getTime(x2)-planet1.toString.toString.toDouble).get))\n\
    \            else if((m1.toSet.contains(planet2.toUpperCase)) && (m2.toSet.contains(planet1.toUpperCase)))\n\
    \                return (m2.filter(x => x.toString.contains(planet2.toUpperCase)).sorted((x1,x2)\
    \ => java.lang.Math.abs(x1.getOrbit(planet2).getTime(x2)-planet1.toString.toString.toDouble).get))\n\
    \            else if((m1.toSet.contains(planet1.toUpperCase)) && (m2.toSet.contains(planet2.toUpperCase\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"\
    Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp5nwxist9.scala:39:4 ----------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp5nwxist9.scala:51:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m51 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E006] Not\
    \ Found Error: /tmp/tmp5nwxist9.scala:24:26 ------------------------\e[0m\e[0m\n\
    \e[31m24 |\e[0m            \e[33mval\e[0m \e[36mm1\e[0m = List(Planets.Mercury,Planets.Venus,Planets.Earth,Planets.Mars,Planets.Jupiter,Planets.Saturn,Planets.Uranus,Planets.Neptune)\n\
    \e[31m\e[31m   |\e[0m                          ^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \                         Not found: Planets\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp5nwxist9.scala:24:42 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m            \e[33mval\e[0m \e[36mm1\e[0m = List(Planets.Mercury,Planets.Venus,Planets.Earth,Planets.Mars,Planets.Jupiter,Planets.Saturn,Planets.Uranus,Planets.Neptune)\n\
    \e[31m\e[31m   |\e[0m                                          ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                                          Not found: Planets\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp5nwxist9.scala:24:56\
    \ ------------------------\e[0m\e[0m\n\e[31m24 |\e[0m            \e[33mval\e[0m\
    \ \e[36mm1\e[0m = List(Planets.Mercury,Planets.Venus,Planets.Earth,Planets.Mars,Planets.Jupiter,Planets.Saturn,Planets.Uranus,Planets.Neptune)\n\
    \e[31m\e[31m   |\e[0m                                                        ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                                      Not\
    \ found: Planets\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp5nwxist9.scala:24:70\
    \ ------------------------\e[0m\e[0m\n\e[31m24 |\e[0m            \e[33mval\e[0m\
    \ \e[36mm1\e[0m = List"
  stdout: ''
  timestamp: 1660009795
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        var planets = List(planet1, planet2)\n        var\
    \ i = 0\n        while(planets.contains(planet2) && (i < planets.length-1)) {\n\
    \            planets = planets.filter(!planets.contains(planet1))\n          \
    \  i += 1\n        }\n        planets\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpze2sx70n.scala:24:37\
    \ --------------------\e[0m\e[0m\n\e[31m24 |\e[0m            planets = planets.filter(!planets.contains(planet1))\n\
    \e[31m\e[31m   |\e[0m                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                     Found:    Boolean\n\e\
    [31m   |\e[0m                                     Required: \e[1m\e[32mString\e\
    [0m\e[1m\e[32m \e[0m\e[1m\e[32m=\e[0m\e[1m\e[32m>\e[0m\e[1m\e[32m \e[0mBoolean\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009794
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val orbit1 = orbit(planet1)\n        val orbit2 =\
    \ orbit(planet2)\n        val planet = if (orbit1.size < orbit2.size) planet2\
    \ else planet1\n        val orbit = orbit1 ++ orbit2\n        val d = distanceFromSun(planet)\n\
    \        val d = orbit.sortWith((a,b) => (a < b).abs, (a,b) => (a > b).abs).takeWhile(_\
    \ < d)\n        d.toList\n    }\n    def main(args: Array[String]) = {\n    assert(bf((\"\
    Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n\
    \    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n\
    \    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"),\
    \ (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpniplb1ga.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36md\e[0m = orbit.sortWith((\e\
    [36ma\e[0m,\e[36mb\e[0m) => (a < b).abs, (\e[36ma\e[0m,\e[36mb\e[0m) => (a > b).abs).takeWhile(_\
    \ < d)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0md is already defined as \e[33mvalue\e[0m \e[35md\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmpniplb1ga.scala:24:20 ---------------------------\e[0m\e[0m\n\e[31m24\
    \ |\e[0m        \e[33mval\e[0m \e[36morbit\e[0m = orbit1 ++ orbit2\n\e[31m\e[31m\
    \   |\e[0m                    ^\e[0m\n\e[31m   |\e[0m                    Recursive\
    \ \e[33mvalue\e[0m \e[35morbit1\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpniplb1ga.scala:25:16 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36md\e[0m = distanceFromSun(planet)\n\
    \e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m   \
    \             Not found: distanceFromSun\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660009792
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        var list1 : List[String] = List(planet1, planet2)\n\
    \        var list2 : List[String] = List(planet2)\n        var list3 : List[String]\
    \ = List()\n        while(list1.head != list2.head && list2.head != list3.head){\n\
    \            list1 :::: list3 :: list2.reverse :::: list3\n            list1 ::::\
    \ list2 :: list3\n            list2 :::: list1 :: list3\n        }\n        \n\
    \        val map1 = Map (List (planet1, planet2) -> (1,0))\n        val map2 =\
    \ Map (List (planet2, planet1) -> (0,1))\n        list3.filter( x => map1.containsKey(x)\
    \ || map2.containsKey(x)).toList\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\",\
    \ \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp_eba4_dh.scala:25:46 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m            list1 :::: list3 :: list2.reverse :::: list3\n\
    \e[31m\e[31m   |\e[0m                                              ^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue :::: is not a member of List[String] - did you mean\
    \ List[String].:::?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp_eba4_dh.scala:26:18\
    \ ------------------------\e[0m\e[0m\n\e[31m26 |\e[0m            list1 :::: list2\
    \ :: list3\n\e[31m\e[31m   |\e[0m                  ^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mvalue :::: is not a member of List[Object] - did you mean List[Object].:::?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp_eba4_dh.scala:27:18 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m            list2 :::: list1 :: list3\n\e[31m\e[31m \
    \  |\e[0m                  ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue ::::\
    \ is not a member of List[Object] - did you mean List[Object].:::?\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmp_eba4_dh.scala:32:32 ------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        list3.filter( \e[36mx\e[0m => map1.containsKey(x)\
    \ || map2.containsKey(x)).toList\n\e[31m\e[31m   |\e[0m                      \
    \     ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue containsKey is not a member\
    \ of scala.collection.mutable.Map[List[String], (Int, Int)], but could be made\
    \ available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the\
    \ following imports might fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m \
    \ import collection.convert.ImplicitConversions.mutableMap AsJavaMap\n\e[31m \
    \  |\e[0m  import collection.convert.ImplicitConversionsToJava.mutableMap AsJavaMap\n\
    \e[31m   |\e[0m  import collection.convert.ImplicitConversions.map AsJavaMap\n\
    \e[31m   |\e[0m  import collection.convert.ImplicitConversionsToJava.map AsJavaMap\n\
    \e[31m   |\e[0m\n4 errors found\n"
  stdout: ''
  timestamp: 1660009798
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        var planet1Orbit : Option[Double] = None\n       \
    \ var planet2Orbit : Option[Double] = None\n        var orbitDistance : Double\
    \ = 0.0\n        var orbits : List[String] = Nil\n        for(p <- planet1, p\
    \ <- planet2){\n            val orbit = calculateOrbit(planet1Orbit, planet2Orbit)\n\
    \            orbitDistance += math.pow((orbit(2) - orbit(1)), 2)\n           \
    \ orbits = orbits.::(p) :: orbits\n            planet1Orbit = orbit(1)\n     \
    \       planet2Orbit = orbit(2)\n        }\n        if (planet1Orbit == None ||\
    \ planet2Orbit == None)\n            Nil\n        else\n            orbits.sortBy(orbitDistance)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"\
    Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmphnhoz87y.scala:25:24 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mfor\e[0m(p <- planet1, p <- planet2){\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               ')' expected, but ',' found\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmphnhoz87y.scala:26:24 ------------------------\e[0m\e[0m\n\e[31m26 |\e\
    [0m            \e[33mval\e[0m \e[36morbit\e[0m = calculateOrbit(planet1Orbit,\
    \ planet2Orbit)\n\e[31m\e[31m   |\e[0m                        ^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                        Not found: calculateOrbit\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphnhoz87y.scala:28:30 --------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m            orbits = orbits.::(p) :: orbits\n\e[31m\e\
    [31m   |\e[0m                     ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m         \
    \            Found:    List[Matchable]\n\e[31m   |\e[0m                     Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphnhoz87y.scala:35:26\
    \ --------------------\e[0m\e[0m\n\e[31m35 |\e[0m            orbits.sortBy(orbitDistance)\n\
    \e[31m\e[31m   |\e[0m                          ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                          Found:    (orbitDistance : Double)\n\e[31m   |\e\
    [0m                          Required: String => Any\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- Error: /tmp/tmphnhoz87y.scala:35:40 -----------------------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m            orbits.sortBy(orbitDistance)\n\e[31m\e[31m\
    \   |\e[0m                                        ^\e[0m\n\e[31m   |\e[0mambiguous\
    \ given instances: both \e[33mobject\e[0m \e[35mByte\e[0m in \e[33mobject\e[0m\
    \ \e[35mOrdering\e[0m and \e[33mobject\e[0m \e[35mBigDecimal\e[0m in \e[33mobject\e\
    [0m \e[35mOrdering\e[0m match type Ordering[B] of parameter ord of \e[33mmethod\e\
    [0m \e[35msortBy\e[0m in \e[33mtrait\e[0m \e[35mSeqOps\e[0"
  stdout: ''
  timestamp: 1660009797
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val solar_system = SolarSystem.getInstance\n     \
    \   val mercury = solar_system.getPlanetOrbit(planet1)\n        val venus = solar_system.getPlanetOrbit(planet2)\n\
    \        val earth = solar_system.getPlanetOrbit(\"Earth\")\n        val mars\
    \ = solar_system.getPlanetOrbit(\"Mars\")\n        val jupiter = solar_system.getPlanetOrbit(\"\
    Jupiter\")\n        val saturn = solar_system.getPlanetOrbit(\"Saturn\")\n   \
    \     val uranus = solar_system.getPlanetOrbit(\"Uranus\")\n        val neptune\
    \ = solar_system.getPlanetOrbit(\"Neptune\")\n        var orbit_list = [mercury,\
    \ venus, earth, mars, jupiter, saturn, uranus, neptune]\n        orbit_list =\
    \ orbit_list.filter(_ != null).sortWith((e1, e2) => e1.distance < e2.distance).map(_.name)\n\
    \        orbit_list.filter(_ != planet1).filter(_ != planet2).filter(_ != planet1\
    \ + planet2)\n    }\n    def main(args: Array[String]) = {\n    assert(bf((\"\
    Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n\
    \    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n\
    \    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"),\
    \ (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpn6qaclmn.scala:31:0 ----------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        orbit_list = orbit_list.filter(_ != \e[31mnull\e\
    [0m).sortWith((\e[36me1\e[0m, \e[36me2\e[0m) => e1.distance < e2.distance).map(_.name)\n\
    \e[31m\e[31m   |\e[0m^^^^^^^^^^\e[0m\n\e[31m   |\e[0m'=>' expected, but 'end of\
    \ statement' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpn6qaclmn.scala:21:27\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36msolar_system\e[0m = SolarSystem.getInstance\n\e[31m\e[31m   |\e[0m       \
    \                    ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                       \
    \    Not found: SolarSystem\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpn6qaclmn.scala:31:32 ------------------------\e[0m\e[0m\n\e[31m31 |\e\
    [0m        orbit_list = orbit_list.filter(_ != \e[31mnull\e[0m).sortWith((\e[36me1\e\
    [0m, \e[36me2\e[0m) => e1.distance < e2.distance).map(_.name)\n\e[31m\e[31m  \
    \ |\e[0m                     ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue filter\
    \ is not a member of Null, but could be made available as an extension method.\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might fix the problem:\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m  import Option.option2Iterable\n\e[31m   |\e\
    [0m  import collection.LazyZip2.lazyZip2ToIterable\n\e[31m   |\e[0m  import collection.LazyZip3.lazyZip3ToIterable\n\
    \e[31m   |\e[0m  import collection.LazyZip4.lazyZip4ToIterable\n\e[31m   |\e[0m\
    \  import collection.convert.ImplicitConversions.list asScalaBuffer\n\e[31m  \
    \ |\e[0m  import collection.convert.ImplicitConversions.properties AsScalaMap\n\
    \e[31m   |\e[0m  import collection.convert.ImplicitConversions.enumeration AsScalaIterator\n\
    \e[31m   |\e[0m  import collection.convert.ImplicitConversions.iterator asScala\n\
    \e[31m   |\e[0m  import collection.convert.ImplicitConversions.map AsScalaConcurrentMap\n\
    \e[31m   |\e[0m  import collection.convert.ImplicitConversions.set asScala\n\e\
    [31m   |\e[0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpn6qaclmn.scala:32:19\
    \ -------------"
  stdout: ''
  timestamp: 1660009798
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\n            new Planet(\"Mercury\"\
    , new OrbitalPeriod(3, 245600)),\n            new Planet(\"Venus\", new OrbitalPeriod(4,\
    \ 1138000)),\n            new Planet(\"Earth\", new OrbitalPeriod(5, 968000)),\n\
    \            new Planet(\"Mars\", new OrbitalPeriod(6, 731000)),\n           \
    \ new Planet(\"Jupiter\", new OrbitalPeriod(7, 388000)),\n            new Planet(\"\
    Saturn\", new OrbitalPeriod(8, 242000)),\n            new Planet(\"Uranus\", new\
    \ OrbitalPeriod(9, 1285000)),\n            new Planet(\"Neptune\", new OrbitalPeriod(10,\
    \ 811000))\n        )\n        planets.filter{planet => planet1.equals(planet.orbitalPeriod.name)\
    \ && planet2.equals(planet.orbitalPeriod.name)}\n            .sortBy(planet =>\
    \ planet.orbitalPeriod.distance(planet.orbitalPeriod.name))\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp34_4hqqu.scala:22:16 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m            \e[33mnew\e[0m \e[35mPlanet\e[0m(\e[31m\"\
    Mercury\"\e[0m, \e[33mnew\e[0m \e[35mOrbitalPeriod\e[0m(\e[31m3\e[0m, \e[31m245600\e\
    [0m)),\n\e[31m\e[31m   |\e[0m                ^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \            Not found: type Planet\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp34_4hqqu.scala:23:16 ------------------------\e[0m\e[0m\n\e[31m23 |\e\
    [0m            \e[33mnew\e[0m \e[35mPlanet\e[0m(\e[31m\"Venus\"\e[0m, \e[33mnew\e\
    [0m \e[35mOrbitalPeriod\e[0m(\e[31m4\e[0m, \e[31m1138000\e[0m)),\n\e[31m\e[31m\
    \   |\e[0m                ^^^^^^\e[0m\n\e[31m   |\e[0m                Not found:\
    \ type Planet\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp34_4hqqu.scala:24:16\
    \ ------------------------\e[0m\e[0m\n\e[31m24 |\e[0m            \e[33mnew\e[0m\
    \ \e[35mPlanet\e[0m(\e[31m\"Earth\"\e[0m, \e[33mnew\e[0m \e[35mOrbitalPeriod\e\
    [0m(\e[31m5\e[0m, \e[31m968000\e[0m)),\n\e[31m\e[31m   |\e[0m                ^^^^^^\e\
    [0m\n\e[31m   |\e[0m                Not found: type Planet\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmp34_4hqqu.scala:25:16 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m            \e[33mnew\e[0m \e[35mPlanet\e[0m(\e[31m\"\
    Mars\"\e[0m, \e[33mnew\e[0m \e[35mOrbitalPeriod\e[0m(\e[31m6\e[0m, \e[31m731000\e\
    [0m)),\n\e[31m\e[31m   |\e[0m                ^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \            Not found: type Planet\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp34_4hqqu.scala:26:16 ------------------------\e[0m\e[0m\n\e[31m26 |\e\
    [0m            \e[33mnew\e[0m \e[35mPlanet\e[0m(\e[31m\"Jupiter\"\e[0m, \e[33mnew\e\
    [0m \e[35mOrbitalPeriod\e[0m(\e[31m7\e[0m, \e[31m388000\e[0m)),\n\e[31m\e[31m\
    \   |\e[0m                ^^^^^^\e[0m\n\e[31m   |\e[0m                Not found:\
    \ type Planet\n\e[31m   |\e[0m\n\e[3"
  stdout: ''
  timestamp: 1660009798
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets1 = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val planets2\
    \ = List(\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\", \"Neptune\")\n        if (planets1.indexOf(planet1) < 0 || planets1.indexOf(planet2)\
    \ < 0) {\n            return List()\n        }\n        if (planets2.indexOf(planet2)\
    \ < 0 || planets2.indexOf(planet1) < 0) {\n            return List()\n       \
    \ }\n        val sun = math.sqrt((1 - Math.pow(planet1.toDouble/planet2.toDouble,2)/Math.pow(planet2.toDouble/planet1.toDouble,2)))\n\
    \        planets2.map(planet2 => if (planet1.toDouble / planet2.toDouble < sun.toDouble)\
    \ planet2 else planet1).sortWith((x,y) => Math.abs(x-y) < sun).map((x => x)).sorted\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"\
    Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpf03_ox0_.scala:30:138 -----------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        planets2.map(\e[36mplanet2\e[0m => \e[33mif\e\
    [0m (planet1.toDouble / planet2.toDouble < sun.toDouble) planet2 \e[33melse\e\
    [0m planet1).sortWith((\e[36mx\e[0m,\e[36my\e[0m) => Math.abs(x-y) < sun).map((\e\
    [36mx\e[0m => x)).sorted\n\e[31m\e[31m   |\e[0m                              \
    \                                                                            \
    \                               ^^\e[0m\n\e[31m   |\e[0mvalue - is not a member\
    \ of String, but could be made available as an extension method.\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mOne of the following imports might make progress towards fixing\
    \ the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n1 error found\n"
  stdout: ''
  timestamp: 1660009800
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n      val p1 = planet1\n      val p2 = planet2\n      val\
    \ p1_orbits = planets(p1)\n      val p2_orbits = planets(p2)\n      val p1_orbits_long\
    \ = orbits_long(p1_orbits)\n      val p2_orbits_long = orbits_long(p2_orbits)\n\
    \      val sun_coords = sun_coords()\n      val sun_coords_long = sun_coords_long()\n\
    \      val planets_within_range = \n        p1_orbits_long.zip(p2_orbits_long)\
    \ filter \n        { (p2_orbits_long, p2_orbits_long) => \n          (distance(p2_orbits_long,\
    \ sun_coords) <= distance(p1_orbits_long, sun_coords))\n        } \n        sort\
    \ { (p1, p2) => distance(p1, p2) }\n      val planets_sorted = planets_within_range\
    \ filter\n        { (planet1, planet2) => \n          (planets(planet1) exists\
    \ p1_orbits) || (planets(planet2) exists p2_orbits)\n        }\n      planets_sorted.toList\
    \ \n    }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"),\
    \ (\"Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpbr0ibsc_.scala:23:22 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m      \e[33mval\e[0m \e[36mp1_orbits\e[0m = planets(p1)\n\
    \e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                 Not found: planets\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpbr0ibsc_.scala:24:22 ------------------------\e[0m\e\
    [0m\n\e[31m24 |\e[0m      \e[33mval\e[0m \e[36mp2_orbits\e[0m = planets(p2)\n\e\
    [31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m   |\e[0m       \
    \               Not found: planets\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpbr0ibsc_.scala:25:27 ------------------------\e[0m\e[0m\n\e[31m25 |\e\
    [0m      \e[33mval\e[0m \e[36mp1_orbits_long\e[0m = orbits_long(p1_orbits)\n\e\
    [31m\e[31m   |\e[0m                           ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                           Not found: orbits_long\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpbr0ibsc_.scala:26:27 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m      \e[33mval\e[0m \e[36mp2_orbits_long\e[0m = orbits_long(p2_orbits)\n\
    \e[31m\e[31m   |\e[0m                           ^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                           Not found: orbits_long\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E045] Cyclic Error: /tmp/tmpbr0ibsc_.scala:27:23 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m      \e[33mval\e[0m \e[36msun_coords\e[0m = sun_coords()\n\
    \e[31m\e[31m   |\e[0m                       ^\e[0m\n\e[31m   |\e[0m          \
    \             Recursive \e[33mvalue\e[0m \e[35msun_coords\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpbr0ibsc_.scala:28:28\
    \ ---------------------------\e[0m\e[0m\n\e[31m28 |\e[0m      \e[33mval\e[0m \e\
    [36msun_coords_long\e[0m"
  stdout: ''
  timestamp: 1660009795
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        var orbits1 = List(\"Mercury\", \"Saturn\", \"Uranus\"\
    , \"Neptune\")\n        var orbits2 = List(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        var i = 0\n        for\
    \ (i <- 0 to orbits2.size - 1 by 2) {\n            if (orbits1(i) <= planet1 &&\
    \ planet1 <= orbits1(i + 1) && orbits1(i + 1) <= planet2)\n                orbits1\
    \ = orbits1.drop(i + 1)\n            else if (orbits1(i) > planet1 && planet1\
    \ <= orbits1(i + 1) && orbits1(i + 1) <= planet2)\n                orbits1 = orbits1.drop(i)\n\
    \            else if (orbits2(i) <= planet1 && planet1 <= orbits2(i + 1) && orbits2(i\
    \ + 1) <= planet2)\n                orbits2 = orbits2.drop(i + 1)\n          \
    \  else if (orbits2(i) > planet1 && planet1 <= orbits2(i + 1) && orbits2(i + 1)\
    \ <= planet2)\n                orbits2 = orbits2.drop(i)\n        }\n        orbits1.sorted\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"\
    Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 4\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.bf$$anonfun$1(tmplli565z6.scala:25)\n\tat scala.runtime.java8.JFunction1$mcVI$sp.apply(JFunction1$mcVI$sp.scala:18)\n\
    \tat scala.collection.immutable.Range.foreach(Range.scala:190)\n\tat Problem$.bf(tmplli565z6.scala:33)\n\
    \tat Problem$.main(tmplli565z6.scala:37)\n\tat Problem.main(tmplli565z6.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009802
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val l1 = planet1.toUpperCase\n        val l2 = planet2.toUpperCase\n\
    \        val planets = List(\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\", \"Neptune\")\n        val orbits = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        var orbit1 = 0\n        var orbit2 = 0\n        var orbit3 = 0\n  \
    \      var orbit4 = 0\n        var orbit5 = 0\n        var orbit6 = 0\n      \
    \  var orbit7 = 0\n        var orbit8 = 0\n        var orbit1 = 0\n        var\
    \ orbit2 = 0\n        var orbit3 = 0\n        var orbit4 = 0\n        var orbit5\
    \ = 0\n        var orbit6 = 0\n        var orbit7 = 0\n        var orbit8 = 0\n\
    \        if (l1 == planet1) (planets.filter { x => x == l2 }, 0)\n        else\
    \ if (l2 == planet2) (planets.filter { x => x == l1 }, 0)\n        else {\n  \
    \          orbit1 = orbit(planet1)\n            orbit2 = orbit(planet2)\n    \
    \        orbit3 = orbit(planet1)\n            orbit4 = orbit(planet2)\n      \
    \      orbit5 = orbit(planet1)\n            orbit6 = orbit(planet2)\n        \
    \    orbit7 = orbit(planet1)\n            orbit8 = orbit(planet2)\n          \
    \  return (planets.filter { x => orbit(planet1) < orbit(planet2) }, 0)\n     \
    \   }\n    }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"\
    ), (\"Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbgfmhzdf.scala:33:12 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mvar\e[0m \e[36morbit1\e[0m = \e[31m0\e\
    [0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0morbit1 is\
    \ already defined as \e[33mvariable\e[0m \e[35morbit1\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbgfmhzdf.scala:34:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mvar\e[0m\
    \ \e[36morbit2\e[0m = \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0morbit2 is already defined as \e[33mvariable\e[0m \e[35morbit2\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpbgfmhzdf.scala:35:12 ---------------------------\e[0m\e[0m\n\e\
    [31m35 |\e[0m        \e[33mvar\e[0m \e[36morbit3\e[0m = \e[31m0\e[0m\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0morbit3 is already defined\
    \ as \e[33mvariable\e[0m \e[35morbit3\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbgfmhzdf.scala:36:12 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mvar\e[0m \e[36morbit4\e[0m = \e[31m0\e\
    [0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0morbit4 is\
    \ already defined as \e[33mvariable\e[0m \e[35morbit4\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbgfmhzdf.scala:37:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m37 |\e[0m        \e[33mvar\e[0m\
    \ \e[36morbit5\e[0m = \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0morbit5 is already defined as \e[33mvariable\e[0m \e[35morbit5\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpb"
  stdout: ''
  timestamp: 1660009800
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val m1 = orbit(planet1, planet2)\n        val m2 =\
    \ orbit(planet2, planet1)\n        val m3 = orbit(planet1, planet3)\n        val\
    \ m4 = orbit(planet3, planet1)\n        val m5 = orbit(planet1, planet5)\n   \
    \     val m6 = orbit(planet5, planet1)\n        val m7 = orbit(planet1, planet7)\n\
    \        val m8 = orbit(planet7, planet1)\n        val orbits = List(m1, m2, m3,\
    \ m4, m5, m6, m7, m8)\n        orbits.sort((x: Double, y: Double) => math.abs(x\
    \ - y))\n    }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"\
    ), (\"Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmphrps2l66.scala:21:17 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mm1\e[0m = orbit(planet1,\
    \ planet2)\n\e[31m\e[31m   |\e[0m                 ^^^^^\e[0m\n\e[31m   |\e[0m\
    \                 Not found: orbit\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmphrps2l66.scala:22:17 ------------------------\e[0m\e[0m\n\e[31m22 |\e\
    [0m        \e[33mval\e[0m \e[36mm2\e[0m = orbit(planet2, planet1)\n\e[31m\e[31m\
    \   |\e[0m                 ^^^^^\e[0m\n\e[31m   |\e[0m                 Not found:\
    \ orbit\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmphrps2l66.scala:23:17\
    \ ------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e\
    [36mm3\e[0m = orbit(planet1, planet3)\n\e[31m\e[31m   |\e[0m                 ^^^^^\e\
    [0m\n\e[31m   |\e[0m                 Not found: orbit\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmphrps2l66.scala:23:32 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mm3\e[0m = orbit(planet1,\
    \ planet3)\n\e[31m\e[31m   |\e[0m                                ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                Not found: planet3\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmphrps2l66.scala:24:17 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mm4\e[0m = orbit(planet3,\
    \ planet1)\n\e[31m\e[31m   |\e[0m                 ^^^^^\e[0m\n\e[31m   |\e[0m\
    \                 Not found: orbit\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmphrps2l66.scala:24:23 ------------------------\e[0m\e[0m\n\e[31m24 |\e\
    [0m        \e[33mval\e[0m \e[36mm4\e[0m = orbit(planet3, planet1)\n\e[31m\e[31m\
    \   |\e[0m                       ^^^^^^^\e[0m\n\e[31m   |\e[0m               \
    \       "
  stdout: ''
  timestamp: 1660009800
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        var sun = Planet(\"Sun\")\n        var planetList:\
    \ List[Planet] = Nil\n        if (planet1 == sun) {\n            planetList =\
    \ List(Planet(planet1))\n        } else if (planet2 == sun) {\n            planetList\
    \ = List(Planet(planet2))\n        } else {\n            planetList = List(Planet(planet1),\
    \ Planet(planet2))\n            val distance = sun\n            val distanceList:\
    \ List[Planet] = List(sun)\n            planetList.foreach(x => {\n          \
    \      var d = distance\n                val distanceList: List[Planet] = List(d)\n\
    \                distanceList.foreach(y => {\n                    if (Planet(x).isAdjacent(Planet(y)))\
    \ {\n                        distance = d\n                    }\n           \
    \     })\n            })\n        }\n        planetList.sortBy(_.distanceTo(sun))\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"\
    Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpidalr94l.scala:21:18 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mvar\e[0m \e[36msun\e[0m = Planet(\e[31m\"\
    Sun\"\e[0m)\n\e[31m\e[31m   |\e[0m                  ^^^^^^\e[0m\n\e[31m   |\e\
    [0m                  Not found: Planet\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpidalr94l.scala:22:29 ------------------------\e[0m\e\
    [0m\n\e[31m22 |\e[0m        \e[33mvar\e[0m \e[36mplanetList\e[0m: \e[35mList\e\
    [0m[\e[35mPlanet\e[0m] = Nil\n\e[31m\e[31m   |\e[0m                          \
    \   ^^^^^^\e[0m\n\e[31m   |\e[0m                             Not found: type Planet\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpidalr94l.scala:24:30\
    \ ------------------------\e[0m\e[0m\n\e[31m24 |\e[0m            planetList =\
    \ List(Planet(planet1))\n\e[31m\e[31m   |\e[0m                              ^^^^^^\e\
    [0m\n\e[31m   |\e[0m                              Not found: Planet\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpidalr94l.scala:26:30 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m            planetList = List(Planet(planet2))\n\e[31m\e\
    [31m   |\e[0m                              ^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \                        Not found: Planet\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpidalr94l.scala:28:30 ------------------------\e[0m\e\
    [0m\n\e[31m28 |\e[0m            planetList = List(Planet(planet1), Planet(planet2))\n\
    \e[31m\e[31m   |\e[0m                              ^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                              Not found: Planet\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpidalr94l.scala:28:47 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m            planetList = List(Planet(planet1), Planet(planet2"
  stdout: ''
  timestamp: 1660009798
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val p1 = planet1.toLowerCase ; val p2 = planet2.toLowerCase\n\
    \        if(!(planet1.equals(\"mercury\") || planet2.equals(\"venus\"))) return\
    \ Nil\n        val x = Vector(0,0,0) ; val y = Vector(0,0,0) ; val z = Vector(0,0,0)\
    \ \n        val p3 = (planet1.equals(\"mercury\") || planet2.equals(\"venus\"\
    )) ? \"mercury\" : \"venus\" \n        val mercury  = Vector(3.241592653589793\
    \ , 0.69545221033424 , -3.141592653589793) ; val venus   = Vector(6.283185307179586\
    \ , -1.511906410991249 , 3.141592653589793) ; val earth   = Vector(0.7853981633974483\
    \ , 1.570796326794921 , -4.71238898038469) ; val mars    = Vector(0.7853981633974483\
    \ , 0.5403023058681349 , 2.694915254237288) ; val jupiter = Vector(0.7853981633974483\
    \ , -0.9644113294334183 , 3.141592653589793) ; val saturn  = Vector(0.7853981633974483\
    \ , -1.598770757324219 , 2.78055059864084) ; val uranus  = Vector(2.598076211353345\
    \ , -1.791927837593352 , -1.791927837593352)\n        val distMercury = {\n  \
    \          val distMercury1 = distance(p1,mercury)\n            val distMercury2\
    \ = distance(p3,mercury)\n            if(distMercury1 < distMercury2) distMercury1\n\
    \            else if(distMercury1 > distMercury2) distMercury2\n            else\
    \ distMercury1 + distMercury2\n        }\n        val distVenus = {\n        \
    \    val distVenus1 = distance(p1,venus)\n            val distVenus2 = distance(p3,venus)\n\
    \            if(distVenus1 < distVenus2) distVenus1\n            else if(distVenus1\
    \ > distVenus2) distVenus2\n            else distVenus1 + distVenus2\n       \
    \ }\n        val distEarth = {\n            val distEarth1 = distance(p1,earth)\n\
    \            val distEarth2 = distance(p\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp4hnmboq4.scala:43:4 ----------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp4hnmboq4.scala:55:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m55 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmp4hnmboq4.scala:24:72 ------------------------\e[0m\e[0m\n\
    \e[31m24 |\e[0m        \e[33mval\e[0m \e[36mp3\e[0m = (planet1.equals(\e[31m\"\
    mercury\"\e[0m) || planet2.equals(\e[31m\"venus\"\e[0m)) ? \e[31m\"mercury\"\e\
    [0m : \e[31m\"venus\"\e[0m \n\e[31m\e[31m   |\e[0m                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                 value ? is not a member of Boolean\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp4hnmboq4.scala:27:31 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m            \e[33mval\e[0m \e[36mdistMercury1\e[0m =\
    \ distance(p1,mercury)\n\e[31m\e[31m   |\e[0m                               ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                               Not found: distance\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp4hnmboq4.scala:28:31 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m            \e[33mval\e[0m \e[36mdistMercury2\e[0m =\
    \ distance(p3,mercury)\n\e[31m\e[31m   |\e[0m                               ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                               Not found: distance\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp4hnmboq4.scala:34:29 ------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m            \e[33mval\e[0m \e[36mdistVenus1\e[0m = distance(p1,venus)\n\
    \e[31m\e[31m   |\e[0m                             ^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                             Not found: distance\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp4hnmboq4.scala:35:29 -----------"
  stdout: ''
  timestamp: 1660009803
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        var orbit1 = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        var orbit2\
    \ = List(\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\", \"Neptune\")\n        var orbit3 = List(\"Mercury\", \"Venus\",\
    \ \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n   \
    \     var orbit4 = List(\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\", \"Neptune\")\n        var orbit5 = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        var orbit6 = List(\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\", \"Neptune\")\n        var orbit7 = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        var orbit8 = List(\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\", \"Neptune\")\n\n        if (planet1 == planet2) {\n\
    \            return (List())\n        }\n        orbit1.foreach {\n          \
    \  planet => if (planet.equalsIgnoreCase(planet1)) {\n                orbit2.foreach\
    \ {\n                    planet => if (planet.equalsIgnoreCase(planet2)) {\n \
    \                       orbit3.foreach {\n                            planet =>\
    \ if (planet.equalsIgnoreCase(planet1)) {\n                                orbit4.foreach\
    \ {\n                                    planet => if (planet.equalsIgnoreCase(planet2))\
    \ {\n                                        orbit5.foreach {\n              \
    \                              planet => if (planet.equalsIgnoreCase(planet1))\
    \ {\n                                                orbit6.foreach {\n      \
    \                                              planet => if (planet.equalsIgnoreCase(planet2))\
    \ {\n                                                        orbit7.foreach {\n\
    \                                                            planet => if (planet.equalsIgnoreCase(planet1))\
    \ {\n                                                                orbit8.foreach\
    \ {\n                                                                    planet\
    \ => if (planet.equalsIgnoreCase(planet2)) {\n                               \
    \                                         return(List(planet1, planet2))\n   \
    \                                                                 }\n        \
    \                                                        }\n                 \
    \                                           }\n                              \
    \                          }\n                                               \
    \     }\n                                                }\n                 \
    \                           }\n                                        }\n   \
    \                                 }\n                                }\n     \
    \                       }\n                        }\n                    }\n\
    \                }\n            }\n\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpp3ilpdrx.scala:78:0 ----------------------------\e\
    [0m\e[0m\n\e[31m78 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpp3ilpdrx.scala:77:1\
    \ ---------------------\e[0m\e[0m\n\e[31m77 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e\
    [0m\n\e[31m   |\e[0m Found:    Unit\n\e[31m   |\e[0m Required: List[String]\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[33m\e[33m-- Warning: /tmp/tmpp3ilpdrx.scala:67:4 ----------------------------------------\e\
    [0m\e[0m\n\e[33m67 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m\
    \   |\e[0m    Line is indented too far to the left, or a `}` is missing\n1 warning\
    \ found\n2 errors found\n"
  stdout: ''
  timestamp: 1660009803
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        var j : List[String] = List[String]()\n        var\
    \ jd : Double = 0.0 // Distance between planet1 and planet2\n        var d : Double\
    \ = 0.0 // Distance between planet1 and sun\n        var s : Double = 0.0 // Distance\
    \ between sun and planet1\n        var sd : Double = 0.0 // Distance between sun\
    \ and planet2\n        var r : Double = 0.0 // Distance between planet1 and planet2\n\
    \        var u : Double = 0.0 // Distance between planet1 and sun\n        var\
    \ v : Double = 0.0 // Distance between sun and planet1\n        var vd : Double\
    \ = 0.0 // Distance between sun and planet2\n        var c : Double = 0.0 // Time\
    \ between planet1 and planet2\n        var c : Double = 0.0 // Time between planet1\
    \ and sun\n        var c : Double = 0.0 // Time between sun and planet1\n    \
    \    var c : Double = 0.0 // Time between sun and planet1\n        planet1.toUpperCase\
    \ match {\n            case planet2 => return List(planet2)\n            case\
    \ planet => {\n                planet2.toUpperCase match {\n                 \
    \   case planet => {\n                        jd = math.sqrt((j.toDouble - jd.toDouble)*(j.toDouble\
    \ - jd.toDouble))\n                        d = math.sqrt((j.toDouble - d.toDouble)*(j.toDouble\
    \ - d.toDouble))\n                        s = math.sqrt((s.toDouble - sd.toDouble)*(s.toDouble\
    \ - sd.toDouble))\n                        r = math.sqrt((r.toDouble - u.toDouble)*(j.toDouble\
    \ - r.toDouble))\n                        v = math.sqrt((v.toDouble - vd.toDouble)*(v.toDouble\
    \ - vd.toDouble))\n                        c = math.sqrt((c.toDouble - c.toDouble)*(c.toDouble\
    \ - c.toDouble))\n                        val temp = planet1.toUpperCase + \"\
    \ \" + planet2.toUpperCase\n                        for (a <- List(planet1, planet2))\
    \ {\n                            if (a.equals(planet)) {\n                   \
    \             j = List(planet)\n                            }\n              \
    \          }\n                        val planet = planet.toUpperCase + \" SUN\"\
    \n                        jd = math.sqrt((j.toDouble - jd.toDouble)*(j.toDouble\
    \ - jd.toDouble))\n                        d = math.sqrt((j.toDouble - d.toDouble)*(j.toDouble\
    \ - d.toDouble))\n                        s = math.sqrt((s.toDouble - sd.toDouble)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"\
    Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpp24d5ko1.scala:55:4 ----------------------------\e\
    [0m\e[0m\n\e[31m55 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpp24d5ko1.scala:67:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m67 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpp24d5ko1.scala:31:12 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m        \e[33mvar\e[0m \e[36mc\e[0m : \e[35mDouble\e[0m = \e[31m0.0\e\
    [0m \e[34m// Time between planet1 and sun\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mc is already defined as \e[33mvariable\e[0m \e[35mc\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpp24d5ko1.scala:32:12 ---------------------------\e[0m\e[0m\n\e[31m32\
    \ |\e[0m        \e[33mvar\e[0m \e[36mc\e[0m : \e[35mDouble\e[0m = \e[31m0.0\e\
    [0m \e[34m// Time between sun and planet1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mc is already defined as \e[33mvariable\e[0m \e[35mc\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpp24d5ko1.scala:33:12 ---------------------------\e[0m\e[0m\n\e[31m33\
    \ |\e[0m        \e[33mvar\e[0m \e[36mc\e[0m : \e[35mDouble\e[0m = \e[31m0.0\e\
    [0m \e[34m// Time between sun and planet1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mc is already defined as \e[33mvariable\e[0m \e[35mc\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpp24d5ko1.scala:39:42 ------------------------\e[0m\e[0m\n\e[31m39 |\e\
    [0m                        jd = math.sqrt((j.toDouble - jd.toDouble)*(j.toDouble\
    \ - jd.toDouble))\n\e[31m\e[31m   |\e[0m                                     \
    \   ^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue toDouble is not a memb"
  stdout: ''
  timestamp: 1660009806
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        var orbit1 = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        var orbit2\
    \ = orbit1\n        val planet1Orbit = orbit1.toSet.filter( x => x == planet1\
    \ )\n        val planet2Orbit = orbit2.toSet.filter( x => x == planet2 )\n   \
    \     if(!planet1Orbit.contains(planet2) || !planet2Orbit.contains(planet1) )\n\
    \            return Nil\n        val result = planet1Orbit.map(x => orbit2.find(\
    \ y => Math.abs(x - y) < Math.sqrt(2) ) )\n        result.filter( x => x != None).sortWith(\
    \ x => x._1.toDouble - x._2.toDouble )\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp0ckj4i6_.scala:27:72 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = planet1Orbit.map(\e\
    [36mx\e[0m => orbit2.find( \e[36my\e[0m => Math.abs(x - y) < Math.sqrt(\e[31m2\e\
    [0m) ) )\n\e[31m\e[31m   |\e[0m                                              \
    \                        ^^^\e[0m\n\e[31m   |\e[0mvalue - is not a member of String,\
    \ but could be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mOne of the following imports might make progress towards fixing the\
    \ problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp0ckj4i6_.scala:28:39 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        result.filter( \e[36mx\e[0m => x != None).sortWith(\
    \ \e[36mx\e[0m => x._1.toDouble - x._2.toDouble )\n\e[31m\e[31m   |\e[0m     \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        value\
    \ sortWith is not a member of Set[Option[String]]\n2 errors found\n"
  stdout: ''
  timestamp: 1660009806
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        planet1.toList match {\n            case PlanetNames(Planet1(a))\
    \ => planet2.toList match {\n                case PlanetNames(Planet2(b)) => {\
    \ \n                    val r = scala.math.sqrt(math.pow(a, 2) + math.pow(b, 2))\n\
    \                    val r1 = math.pow(r, 1.0/3.0)\n                    math.round(math.sqrt(r1)*100)/100.0\n\
    \                }\n            }\n            case PlanetNames(Planet1(a, _,\
    \ _, _, _, _, _, _)) => planet2.toList match {\n                case PlanetNames(Planet2(b,\
    \ _, _, _, _, _, _, _)) => { \n                    val r = scala.math.sqrt(math.pow(a,\
    \ 2) + math.pow(b, 2))\n                    val r1 = math.pow(r, 1.0/3.0)\n  \
    \                  math.round(math.sqrt(r1)*100)/100.0\n                }\n  \
    \          }\n            case PlanetNames(Planet1(_, _, _, _, _, _, _, _)) =>\
    \ planet2.toList match {\n                case PlanetNames(Planet2(_, _, _, _,\
    \ _, _, _, _)) => { \n                    val r = scala.math.sqrt(math.pow(a,\
    \ 2) + math.pow(b, 2))\n                    val r1 = math.pow(r, 1.0/3.0)\n  \
    \                  math.round(math.sqrt(r1)*100)/100.0\n                }\n  \
    \          }\n            case PlanetNames(Planet1(_, _, _, _, _, _, _, _, _))\
    \ => planet2.toList match {\n                case PlanetNames(Planet2(_, _, _,\
    \ _, _, _, _, _, _)) => { \n                    val r = scala.math.sqrt(math.pow(a,\
    \ 2) + math.pow(b, 2))\n                    val r1 = math.pow(r, 1.0/3.0)\n  \
    \                  math.round(math.sqrt(r1)*100)/100.0\n                }\n  \
    \          }\n            case PlanetNames(Planet1(_, _, _, _, _, _, _, _, _,\
    \ _)) => planet2.toList match {\n                case PlanetNames(Planet2(_, _,\
    \ _, _, _, _, _, _, _, _)) => { \n                    val r = scala.math.sqrt(math.pow(a,\
    \ 2) + math.pow(b, 2))\n                    val r1 = math.pow(r, 1.0/3.0)\n  \
    \                  math.round(math.sqrt(r1)*100)/100.0\n                }\n  \
    \          }\n            case PlanetNames(Planet1(_, _, _, _, _, _, _, _, _,\
    \ _, _)) => planet2.toList match {\n                case PlanetNames(Planet2(_,\
    \ _, _, _, _, _, _, _, _, _, _)) => { \n                    val r = scala.math.sqrt(math.pow(a,\
    \ 2) + math.pow(b, 2))\n                    val r1 = math.pow(r, 1.0/3.\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpnzdpd0rm.scala:61:4 ----------------------------\e\
    [0m\e[0m\n\e[31m61 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tmpnzdpd0rm.scala:73:0 ----------------------------\e[0m\e[0m\n\e[31m73\
    \ |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpnzdpd0rm.scala:22:17 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m            \e[33mcase\e[0m PlanetNames(Planet1(a)) =>\
    \ planet2.toList \e[33mmatch\e[0m {\n\e[31m\e[31m   |\e[0m                 ^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                 Not found: PlanetNames\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpnzdpd0rm.scala:22:29 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m            \e[33mcase\e[0m PlanetNames(Planet1(a)) =>\
    \ planet2.toList \e[33mmatch\e[0m {\n\e[31m\e[31m   |\e[0m                   \
    \          ^^^^^^^\e[0m\n\e[31m   |\e[0m                             Not found:\
    \ Planet1\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpnzdpd0rm.scala:23:21\
    \ ------------------------\e[0m\e[0m\n\e[31m23 |\e[0m                \e[33mcase\e\
    [0m PlanetNames(Planet2(b)) => { \n\e[31m\e[31m   |\e[0m                     ^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                     Not found: PlanetNames\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpnzdpd0rm.scala:23:33 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m                \e[33mcase\e[0m PlanetNames(Planet2(b))\
    \ => { \n\e[31m\e[31m   |\e[0m                                 ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                                 Not found: Planet2\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpnzdpd0rm.scala:24:53 --------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m   "
  stdout: ''
  timestamp: 1660009806
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        var orbit1 = Planet(planet1).orbit\n        var orbit2\
    \ = Planet(planet2).orbit\n        var orb: List[String] = Nil\n\n        while(orbit1.size\
    \ != 0 || orbit2.size != 0) {\n            if(orbit1.contains(orbit2.head)) {\n\
    \                orb = orbit1 ++ orbit2 ++ orb\n            }\n        }\n   \
    \     \n        orb.sortWith((x: String, y: String) => x.distance < y.distance)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"\
    Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmphmfp8vsn.scala:21:21 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mvar\e[0m \e[36morbit1\e[0m = Planet(planet1).orbit\n\
    \e[31m\e[31m   |\e[0m                     ^^^^^^\e[0m\n\e[31m   |\e[0m       \
    \              Not found: Planet\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmphmfp8vsn.scala:22:21 ------------------------\e[0m\e[0m\n\e[31m22 |\e\
    [0m        \e[33mvar\e[0m \e[36morbit2\e[0m = Planet(planet2).orbit\n\e[31m\e\
    [31m   |\e[0m                     ^^^^^^\e[0m\n\e[31m   |\e[0m               \
    \      Not found: Planet\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmphmfp8vsn.scala:31:49 ------------------------\e[0m\e[0m\n\e[31m31 |\e\
    [0m        orb.sortWith((\e[36mx\e[0m: \e[35mString\e[0m, \e[36my\e[0m: \e[35mString\e\
    [0m) => x.distance < y.distance)\n\e[31m\e[31m   |\e[0m                      \
    \                         ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                   \
    \             value distance is not a member of String\n3 errors found\n"
  stdout: ''
  timestamp: 1660009805
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planet1Orbs = planet1.toLowerCase ++ \"orbit\"\
    .toLowerCase + \"orbit\".toLowerCase + \"orbit\".toLowerCase + \"orbit\".toLowerCase\
    \ + \"orbit\".toLowerCase + \"orbit\".toLowerCase + \"orbit\".toLowerCase + \"\
    orbit\".toLowerCase + \"orbit\".toLowerCase + \"orbit\".toLowerCase + \"orbit\"\
    .toLowerCase + \"orbit\".toLowerCase + \"orbit\".toLowerCase + \"orbit\".toLowerCase\
    \ + \"orbit\".toLowerCase + \"orbit\".toLowerCase + \"orbit\".toLowerCase + \"\
    orbit\".toLowerCase + \"orbit\".toLowerCase + \"orbit\".toLowerCase + \"orbit\"\
    .toLowerCase + \"orbit\".toLowerCase + \"orbit\".toLowerCase + \"orbit\".toLowerCase\
    \ + \"orbit\".toLowerCase + \"orbit\".toLowerCase + \"orbit\".toLowerCase + \"\
    orbit\".toLowerCase + \"orbit\".toLowerCase + \"orbit\".toLowerCase + \"orbit\"\
    .toLowerCase + \"orbit\".toLowerCase + \"orbit\".toLowerCase + \"orbit\".toLowerCase\
    \ + \"orbit\".toLowerCase + \"orbit\".toLowerCase + \"orbit\".toLowerCase + \"\
    orbit\".toLowerCase + \"orbit\".toLowerCase + \"orbit\".toLowerCase + \"orbit\"\
    .toLowerCase + \"orbit\".toLowerCase + \"orbit\".toLowerCase + \"orbit\".toLowerCase\
    \ + \"orbit\".toLowerCase + \"orbit\".toLowerCase + \"orbit\".toLowerCase + \"\
    orbit\".toLowerCase + \"orbit\".toLowerCase + \"orbit\".toLowerCase + \"orbit\"\
    .toLowerCase + \"orbit\".toLowerCase + \"orbit\".toLowerCase + \"orbit\".toLowerCase\
    \ + \"orbit\".toLowerCase + \"orbit\".toLowerCase + \"orbit\".toLowerCase + \"\
    orbit\".toLowerCase + \"orbit\".toLowerCase + \"orbit\".toLowerCase + \"orbit\"\
    .toLowerCase + \"orbit\".toLowerCase + \"orbit\".toLowerCase + \"orbit\".toLowerCase\
    \ + \"orbit\".toLowerCase + \"orbit\".toLowerCase + \"orbit\".toLowerCase + \"\
    orbit\".toLowerCase + \"orbit\".toLowerCase + \"orbit\".toLowerCase + \"orbit\"\
    .toLowerCase + \"orbit\".toLowerCase + \"orbit\".toLowerCase + \"orbit\".toLowerCase\
    \ + \"orbit\".toLowerCase + \"orbit\".toLowerCase + \"orbit\".toLowerCase + \"\
    orbit\".toLowerCase + \"orbit\".toLowerCase + \"orbit\".toLowerCase + \"orbit\"\
    .toLowerCase + \"orbit\".toLowerCase + \"orbit\".toLower\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpop6i1ktl.scala:21:1861 ----------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mplanet1Orbs\e[0m = planet1.toLowerCase\
    \ ++ \e[31m\"orbit\"\e[0m.toLowerCase + \e[31m\"orbit\"\e[0m.toLowerCase + \e\
    [31m\"orbit\"\e[0m.toLowerCase + \e[31m\"orbit\"\e[0m.toLowerCase + \e[31m\"orbit\"\
    \e[0m.toLowerCase + \e[31m\"orbit\"\e[0m.toLowerCase + \e[31m\"orbit\"\e[0m.toLowerCase\
    \ + \e[31m\"orbit\"\e[0m.toLowerCase + \e[31m\"orbit\"\e[0m.toLowerCase + \e[31m\"\
    orbit\"\e[0m.toLowerCase + \e[31m\"orbit\"\e[0m.toLowerCase + \e[31m\"orbit\"\e\
    [0m.toLowerCase + \e[31m\"orbit\"\e[0m.toLowerCase + \e[31m\"orbit\"\e[0m.toLowerCase\
    \ + \e[31m\"orbit\"\e[0m.toLowerCase + \e[31m\"orbit\"\e[0m.toLowerCase + \e[31m\"\
    orbit\"\e[0m.toLowerCase + \e[31m\"orbit\"\e[0m.toLowerCase + \e[31m\"orbit\"\e\
    [0m.toLowerCase + \e[31m\"orbit\"\e[0m.toLowerCase + \e[31m\"orbit\"\e[0m.toLowerCase\
    \ + \e[31m\"orbit\"\e[0m.toLowerCase + \e[31m\"orbit\"\e[0m.toLowerCase + \e[31m\"\
    orbit\"\e[0m.toLowerCase + \e[31m\"orbit\"\e[0m.toLowerCase + \e[31m\"orbit\"\e\
    [0m.toLowerCase + \e[31m\"orbit\"\e[0m.toLowerCase + \e[31m\"orbit\"\e[0m.toLowerCase\
    \ + \e[31m\"orbit\"\e[0m.toLowerCase + \e[31m\"orbit\"\e[0m.toLowerCase + \e[31m\"\
    orbit\"\e[0m.toLowerCase + \e[31m\"orbit\"\e[0m.toLowerCase + \e[31m\"orbit\"\e\
    [0m.toLowerCase + \e[31m\"orbit\"\e[0m.toLowerCase + \e[31m\"orbit\"\e[0m.toLowerCase\
    \ + \e[31m\"orbit\"\e[0m.toLowerCase + \e[31m\"orbit\"\e[0m.toLowerCase + \e[31m\"\
    orbit\"\e[0m.toLowerCase + \e[31m\"orbit\"\e[0m.toLowerCase + \e[31m\"orbit\"\e\
    [0m.toLowerCase + \e[31m\"orbit\"\e[0m.toLowerCase + \e[31m\"orbit\"\e[0m.toLowerCase\
    \ + \e[31m\"orbit\"\e[0m.toLowerCase + \e[31m\"orbit\"\e[0m.toLowerCase + \e[31m\"\
    orbit\"\e[0m.toLowerCase + \e[31m\"orbit\"\e[0m.toLowerCase + \e[31m\"orbit\"\e\
    [0m.toLowerCase + \e[31m\"orbit\"\e[0m.toLowerCase + \e[31m\"orbit\"\e[0m.toLowerCase\
    \ + \e[31m\"orbit\"\e[0m.toLowerCase + \e[31m\"orbit\"\e[0m.toLowerCase + \e[31m\"\
    orbit\"\e[0m.toLowerCase + \e[31m\"orbit\"\e[0m.toLowerCase + \e[31m\"orbit\"\e\
    [0m.toLowerCase + \e[31m\"orbit\"\e[0m.toLowerCase + \e[31m\"orbit\"\e[0m.toLowerCase\
    \ + \e[31m\"orbit\"\e[0m.toLowerCase + \e[31m\"orbit\"\e[0m.toLowerCase + \e[31m\"\
    orbit\"\e[0m.toLowerCase + \e[31m\"orbit\"\e[0m.toLowerCase + \e[31m\"orb"
  stdout: ''
  timestamp: 1660009804
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        if(planet1 == planet2) (List[String]())\n        if(planet1.equals(\"\
    Mercury\") && planet2.equals(\"Venus\")) (List[String](\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"))\n        if(planet1.equals(\"\
    Mercury\") && planet2.equals(\"Earth\")) (List[String](\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"))\n        if(planet1.equals(\"\
    Mercury\") && planet2.equals(\"Mars\")) (List[String](\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"))\n        if(planet1.equals(\"\
    Mercury\") && planet2.equals(\"Jupiter\")) (List[String](\"Earth\", \"Mars\",\
    \ \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"))\n        if(planet1.equals(\"\
    Mercury\") && planet2.equals(\"Saturn\")) (List[String](\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"))\n        if(planet1.equals(\"\
    Mercury\") && planet2.equals(\"Uranus\")) (List[String](\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"))\n        if(planet1.equals(\"\
    Mercury\") && planet2.equals(\"Neptune\")) (List[String](\"Earth\", \"Mars\",\
    \ \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"))\n        if(planet1.equals(\"\
    Venus\") && planet2.equals(\"Mercury\")) (List[String](\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"))\n        if(planet1.equals(\"\
    Venus\") && planet2.equals(\"Earth\")) (List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\", \"Neptune\"))\n        if(planet1.equals(\"Venus\")\
    \ && planet2.equals(\"Mars\")) (List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\", \"Neptune\"))\n        if(planet1.equals(\"Venus\")\
    \ && planet2.equals(\"Jupiter\")) (List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\", \"Neptune\"))\n        if(planet1.equals(\"Ven\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp4tj8ct71.scala:33:26 -----------------------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mif\e[0m(planet1.equals(\"Ven\n\e[31m\e\
    [31m   |\e[0m                          ^\e[0m\n\e[31m   |\e[0m               \
    \           unclosed string literal\n\e[31m\e[31m-- Error: /tmp/tmp4tj8ct71.scala:35:34\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m35 |\e[0m    \e[33mdef\e\
    [0m \e[36mmain\e[0m(\e[36margs\e[0m: \e[35mArray\e[0m[\e[35mString\e[0m]) = {\n\
    \e[31m\e[31m   |\e[0m                                  ^\e[0m\n\e[31m   |\e[0m\
    \                                 end of statement expected but '=' found\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmp4tj8ct71.scala:35:4 -------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[31m\e[31m   |\e[0m    ^^^\e[0m\n\e\
    [31m   |\e[0m    Not found: Vendef\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[33m\e[33m-- [E129] Potential Issue\
    \ Warning: /tmp/tmp4tj8ct71.scala:34:4 -----------------\e[0m\e[0m\n\e[33m33 |\e\
    [0m        \e[33mif\e[0m(planet1.equals(\"Ven\n\e[33m34 |\e[0m    }\n\e[33m\e\
    [33m   |\e[0m                              ^\e[0m\n\e[33m   |\e[0mA pure expression\
    \ does nothing in statement position; you may be omitting necessary parentheses\n\
    \e[33m   |\e[0m\n\e[33m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 warning found\n3 errors found\n"
  stdout: ''
  timestamp: 1660009802
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val a = getOrbits(planet1, planet2)\n        val b\
    \ = getOrbits(planet2, planet1)\n        val intersection = a.filter(b(_) > 0)\
    \ \n\n        val distances = intersection.map(x => \n            Math.abs(getDistance(planet1,\
    \ planet2, x) / 2.0)) \n        val tuple = intersection.sortedBy(distances.max)\n\
    \        if (distances.size == 0) (List[String]())\n        else tuple\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp_x947a1r.scala:21:16 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36ma\e[0m = getOrbits(planet1,\
    \ planet2)\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                Not found: getOrbits\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmp_x947a1r.scala:22:16 ------------------------\e[0m\e\
    [0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mb\e[0m = getOrbits(planet2, planet1)\n\
    \e[31m\e[31m   |\e[0m                ^^^^^^^^^\e[0m\n\e[31m   |\e[0m         \
    \       Not found: getOrbits\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660009802
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(planet1, planet2)\n        val\
    \ d = Distances.sunSphereDistance(planets, Planets.planets(0))\n        if (planets\
    \ == Nil || d == 0.0) Nil\n        else planets.sortBy(Planets.distanceFromSun).filter(p\
    \ => d > Planets.sunSphereDistance(List(p), Planets.planets(0)).abs)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpbd4rlims.scala:22:16 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36md\e[0m = Distances.sunSphereDistance(planets,\
    \ Planets.planets(\e[31m0\e[0m))\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                Not found: Distances\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpbd4rlims.scala:24:28 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33melse\e[0m planets.sortBy(Planets.distanceFromSun).filter(p\
    \ => d > Planets.sunSphereDistance(List(p), Planets.planets(\e[31m0\e[0m)).abs)\n\
    \e[31m\e[31m   |\e[0m                            ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                            Not found: Planets\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ Error: /tmp/tmpbd4rlims.scala:24:52 -----------------------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33melse\e[0m planets.sortBy(Planets.distanceFromSun).filter(p\
    \ => d > Planets.sunSphereDistance(List(p), Planets.planets(\e[31m0\e[0m)).abs)\n\
    \e[31m\e[31m   |\e[0m                                                    ^\e[0m\n\
    \e[31m   |\e[0mambiguous given instances: both \e[33mobject\e[0m \e[35mByte\e\
    [0m in \e[33mobject\e[0m \e[35mOrdering\e[0m and \e[33mobject\e[0m \e[35mChar\e\
    [0m in \e[33mobject\e[0m \e[35mOrdering\e[0m match type Ordering[B] of parameter\
    \ ord of \e[33mmethod\e[0m \e[35msortBy\e[0m in \e[33mtrait\e[0m \e[35mSeqOps\e\
    [0m\n3 errors found\n"
  stdout: ''
  timestamp: 1660009804
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val orbits = List(\n            List(\"Venus\", \"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"),\n      \
    \      List(\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\", \"Neptune\"),\n            List(\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\", \"Neptune\"),\n            List(\"Earth\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\", \"Neptune\"),\n            List(\"Jupiter\", \"Saturn\"\
    , \"Uranus\", \"Neptune\"),\n            List(\"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"),\n            List(\"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        )\n        val p = orbits(planet1)\n        val q = orbits(planet2)\n\
    \        val a = (p diff q).toList\n        val b = (q diff p).toList\n      \
    \  (a.toList ++ b.toList).sortWith((a, b) => math.abs(a.toDouble - b.toDouble))\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"\
    Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpcniboxpc.scala:30:23\
    \ --------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mp\e\
    [0m = orbits(planet1)\n\e[31m\e[31m   |\e[0m                       ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                       Found:    (planet1 : String)\n\e[31m   |\e\
    [0m                       Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpcniboxpc.scala:31:23 --------------------\e[0m\e\
    [0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mq\e[0m = orbits(planet2)\n\e\
    [31m\e[31m   |\e[0m                       ^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \                 Found:    (planet2 : String)\n\e[31m   |\e[0m              \
    \         Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpcniboxpc.scala:34:58\
    \ --------------------\e[0m\e[0m\n\e[31m34 |\e[0m        (a.toList ++ b.toList).sortWith((\e\
    [36ma\e[0m, \e[36mb\e[0m) => math.abs(a.toDouble - b.toDouble))\n\e[31m\e[31m\
    \   |\e[0m                                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                                  Found: \
    \   Double\n\e[31m   |\e[0m                                                  Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660009807
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        // Write your code here\n        val planets = new\
    \ mutable.ListBuffer[String]()\n        val distances = mutable.ListBuffer[Double]()\n\
    \        for(planet <- List(planet1, planet2)){\n            // Compute distance\
    \ of planets\n            distances.clear()\n            for(i <- 0 until Planets[planet].length){\n\
    \                val distance = Planets[planet](i).distanceTo(Planets(planet))\n\
    \                distances += distance\n            }\n            // Add planets\
    \ to list\n            planets ++= Planets(planet).filterNot(distance => distances.contains(distance))\n\
    \        }\n        planets.toList.sortWith(_ < _).reverse\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpaznbv2o7.scala:22:26 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mplanets\e[0m = \e[33mnew\e\
    [0m mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m           \
    \               ^^^^^^^\e[0m\n\e[31m   |\e[0m                          Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpaznbv2o7.scala:23:24\
    \ ------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e\
    [36mdistances\e[0m = mutable.ListBuffer[\e[35mDouble\e[0m]()\n\e[31m\e[31m   |\e\
    [0m                        ^^^^^^^\e[0m\n\e[31m   |\e[0m                     \
    \   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpaznbv2o7.scala:27:37\
    \ ------------------------\e[0m\e[0m\n\e[31m27 |\e[0m            \e[33mfor\e[0m(i\
    \ <- \e[31m0\e[0m until Planets[\e[35mplanet\e[0m].length){\n\e[31m\e[31m   |\e\
    [0m                                     ^^^^^^\e[0m\n\e[31m   |\e[0m         \
    \                            Not found: type planet\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpaznbv2o7.scala:27:29 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m            \e[33mfor\e[0m(i <- \e[31m0\e[0m until Planets[\e\
    [35mplanet\e[0m].length){\n\e[31m\e[31m   |\e[0m                             ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                             Not found: Planets\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpaznbv2o7.scala:28:39 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m                \e[33mval\e[0m \e[36mdistance\e[0m =\
    \ Planets[\e[35mplanet\e[0m](i).distanceTo(Planets(planet))\n\e[31m\e[31m   |\e\
    [0m                                       ^^^^^^\e[0m\n\e[31m   |\e[0m       \
    \                                Not found: type planet\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling "
  stdout: ''
  timestamp: 1660009803
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planet1Orbit = orbit(planet1)\n        val planet2Orbit\
    \ = orbit(planet2)\n        if (planet1Orbit == Nil || planet2Orbit == Nil) {\n\
    \            return Nil\n        }\n        if (planet1Orbit.isEmpty || planet2Orbit.isEmpty)\
    \ {\n            return Nil\n        }\n        if (planet1Orbit contains planet2Orbit)\
    \ {\n            val list = planet1Orbit ++ planet2Orbit\n            val sorted\
    \ = list.sortWith(a => distance(a, sun))\n            return sorted\n        }\n\
    \        else {\n            return Nil\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp8zmp8uhu.scala:21:27 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mplanet1Orbit\e[0m = orbit(planet1)\n\
    \e[31m\e[31m   |\e[0m                           ^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                         Not found: orbit\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmp8zmp8uhu.scala:22:27 ------------------------\e[0m\e\
    [0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mplanet2Orbit\e[0m = orbit(planet2)\n\
    \e[31m\e[31m   |\e[0m                           ^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                         Not found: orbit\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660009803
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val orbit1 = List(\n                new Planet(\"\
    Venus\", 6378.147, 0.0866),\n                new Planet(\"Mercury\", 6378.1392,\
    \ -0.0308),\n                new Planet(\"Earth\", 6378, (2 * math.pi/180)),\n\
    \                new Planet(\"Mars\", 6378.339, (2 * math.pi/180)),\n        \
    \        new Planet(\"Jupiter\", 6378.346, (3 * math.pi/180)),\n             \
    \   new Planet(\"Saturn\", 6378.340, (4 * math.pi/180)),\n                new\
    \ Planet(\"Uranus\", 6378.341, (5 * math.pi/180)),\n                new Planet(\"\
    Neptune\", 6378.337, (6 * math.pi/180))\n                )\n\n        val orbit2\
    \ = List(\n                new Planet(\"Saturn\", 6378.0, (4 * math.pi/180)),\n\
    \                new Planet(\"Uranus\", 6378.0, (5 * math.pi/180)),\n        \
    \        new Planet(\"Neptune\", 6378.0, (6 * math.pi/180)),\n               \
    \ new Planet(\"Mercury\", 6378.0, (2 * math.pi/180)),\n                new Planet(\"\
    Mars\", 6378.0, (2 * math.pi/180)),\n                new Planet(\"Jupiter\", 6378.0,\
    \ (3 * math.pi/180)),\n                new Planet(\"Earth\", 6378.0, (2 * math.pi/180)),\n\
    \                new Planet(\"Venus\", 6378.0, (0.0866 * math.pi/180))\n     \
    \           )\n\n        var output: List[String] = List()\n        var j = 0\n\
    \        var i = orbit1.size\n        while (i < orbit2.size) {\n            if\
    \ (orbit1(i).name == planet1 && orbit2(i).name == planet2) {\n               \
    \ output = output :+ orbit1(i).name\n                j = j + 1\n             \
    \   if (j == orbit1.size) {\n                    i = 0\n                    j\
    \ = 0\n                }\n            }\n            i = i + 1\n        }\n  \
    \      if (output.size == 0) {\n            output = List()\n        }\n     \
    \   output.sortBy(e => orbit1.find(e => e.name == e).distanceTo(orbit2.find(e\
    \ => e.name == e).distanceTo))\n        return output\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmppshm1m8m.scala:22:20 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m                \e[33mnew\e[0m \e[35mPlanet\e[0m(\e[31m\"\
    Venus\"\e[0m, \e[31m6378.147\e[0m, \e[31m0.0866\e[0m),\n\e[31m\e[31m   |\e[0m\
    \                    ^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ type Planet\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmppshm1m8m.scala:23:20\
    \ ------------------------\e[0m\e[0m\n\e[31m23 |\e[0m                \e[33mnew\e\
    [0m \e[35mPlanet\e[0m(\e[31m\"Mercury\"\e[0m, \e[31m6378.1392\e[0m, -\e[31m0.0308\e\
    [0m),\n\e[31m\e[31m   |\e[0m                    ^^^^^^\e[0m\n\e[31m   |\e[0m \
    \                   Not found: type Planet\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmppshm1m8m.scala:24:20 ------------------------\e[0m\e\
    [0m\n\e[31m24 |\e[0m                \e[33mnew\e[0m \e[35mPlanet\e[0m(\e[31m\"\
    Earth\"\e[0m, \e[31m6378\e[0m, (\e[31m2\e[0m * math.pi/\e[31m180\e[0m)),\n\e[31m\e\
    [31m   |\e[0m                    ^^^^^^\e[0m\n\e[31m   |\e[0m                \
    \    Not found: type Planet\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmppshm1m8m.scala:25:20 ------------------------\e[0m\e[0m\n\e[31m25 |\e\
    [0m                \e[33mnew\e[0m \e[35mPlanet\e[0m(\e[31m\"Mars\"\e[0m, \e[31m6378.339\e\
    [0m, (\e[31m2\e[0m * math.pi/\e[31m180\e[0m)),\n\e[31m\e[31m   |\e[0m        \
    \            ^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found: type Planet\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmppshm1m8m.scala:26:20\
    \ ------------------------\e[0m\e[0m\n\e[31m26 |\e[0m                \e[33mnew\e\
    [0m \e[35mPlanet\e[0m(\e[31m\"Jupiter\"\e[0m, \e[31m6378.346\e[0m, (\e[31m3\e\
    [0m * math.pi/\e[31m180\e[0m)),\n\e[31m\e[31m   |\e[0m                    ^^^^^^\e\
    [0m\n\e[31m   |\e[0m                    Not found: type Planet\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation ava"
  stdout: ''
  timestamp: 1660009809
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        def makePlanetName(planets: Array[String], x: Int):\
    \ String = \n            planets.reduceLeft((p1, p2) => p1 + \" \" + p2 + \" \"\
    ) + (\"Planet \" + x)\n        def makeOrbitNames(planets: Array[String]): Array[String]\
    \ =\n            planets.map(p => makePlanetName(planets, p.length))\n       \
    \ def makeOrbit(planets: Array[String], x: Int): String =\n            planets.map(p\
    \ => \"Orbit of \" + p).reduceLeft((p1, p2) => \"Orbit of \" + p1 + \" and \"\
    \ + p2).drop(2)\n        val planets = makeOrbitNames(Array(planet1, planet2))\n\
    \        val orbit1 = makeOrbit(planets, 0)\n        val orbit2 = makeOrbit(planets,\
    \ 1)\n        val orbits = makeOrbitNames(Array(orbit1, orbit2))\n        val\
    \ sunOrbit = orbits.filter(_.startsWith(\"Orbit of Sun\"))\n        val sunOrbitIndex\
    \ = orbits.indexOf(sunOrbit.last)\n        val sunOrbitList = orbits(sunOrbitIndex)\n\
    \        val sunOrbitNames = makePlanetName(planets, sunOrbitList.length)\n  \
    \      val sunOrbitString = sunOrbitNames + \" and \" + sunOrbitList\n       \
    \ val sunOrbitToPlanets = sunOrbitList.map(planet => sunOrbitNames.drop(sunOrbitNames.indexOf(planet)).mkString(\"\
    \ \")).map(planets => planets + \" \" + planet)\n        val proximity = (sunOrbitList.size\
    \ / sunOrbitList.size.toDouble).toInt\n        val sunOrbits = proximity * sunOrbitList\n\
    \        val sunOrbitsIndex = sunOrbitNames.indexOf(sunOrbits)\n        val sunOrbitsList\
    \ = sunOrbitNames(sunOrbitsIndex) + \" and \" + sunOrbitList\n        val sunOrbitsName\
    \ = sunOrbitsList.mkString(\" \")\n        val planetsInOrbit = planets.filter(p1\
    \ => planet1.equals(p1))\n        val planetsNotInOrbit = planets.filter(p1 =>\
    \ !planet1.equals(p1))\n        val planetsInOrbitIndex = planets.indexOf(planetsInOrbit)\n\
    \        val planetsInOrbitList = planetsInOrbit(planetsInOrbitIndex)\n      \
    \  val planetsInOrbitNames = planetsInOr\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpk2m7nw_s.scala:36:155 -----------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36msunOrbitToPlanets\e[0m =\
    \ sunOrbitList.map(\e[36mplanet\e[0m => sunOrbitNames.drop(sunOrbitNames.indexOf(planet)).mkString(\e\
    [31m\" \"\e[0m)).map(\e[36mplanets\e[0m => planets + \e[31m\" \"\e[0m + planet)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                                                            \
    \                       ^^^^^^\e[0m\n\e[31m   |\e[0m                         \
    \                              Not found: planet\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E134] Type Error: /tmp/tmpk2m7nw_s.scala:38:34 -----------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m \e[36msunOrbits\e[0m = proximity\
    \ * sunOrbitList\n\e[31m\e[31m   |\e[0m                        ^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m None of the overloaded alternatives of \e[33mmethod\e[0m \e[35m*\e\
    [0m in \e[33mclass\e[0m \e[35mInt\e[0m with types\n\e[31m   |\e[0m  (x: Double):\
    \ Double\n\e[31m   |\e[0m  (x: Float): Float\n\e[31m   |\e[0m  (x: Long): Long\n\
    \e[31m   |\e[0m  (x: Int): Int\n\e[31m   |\e[0m  (x: Char): Int\n\e[31m   |\e\
    [0m  (x: Short): Int\n\e[31m   |\e[0m  (x: Byte): Int\n\e[31m   |\e[0m match arguments\
    \ ((sunOrbitList : String))\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpk2m7nw_s.scala:44:50\
    \ --------------------\e[0m\e[0m\n\e[31m44 |\e[0m        \e[33mval\e[0m \e[36mplanetsInOrbitIndex\e\
    [0m = planets.indexOf(planetsInOrbit)\n\e[31m\e[31m   |\e[0m                 \
    \                                 ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m       \
    \                       Found:    (planetsInOrbit : Array[String])\n\e[31m   |\e\
    [0m                              Required: String\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpk2m7nw_s.scala:46:34 ------------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m        \e[33mval\e[0m \e[36mplanetsInOrbitNames\e[0m\
    \ = planetsInOr\n\e[31m\e[31m   |\e[0m                "
  stdout: ''
  timestamp: 1660009811
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val earth = scala.collection.mutable.ListBuffer()\n\
    \        val mercury = scala.collection.mutable.ListBuffer()\n        val venus\
    \ = scala.collection.mutable.ListBuffer()\n        val mars = scala.collection.mutable.ListBuffer()\n\
    \        val jupiter = scala.collection.mutable.ListBuffer()\n        val saturn\
    \ = scala.collection.mutable.ListBuffer()\n        val uranus = scala.collection.mutable.ListBuffer()\n\
    \        val neptune = scala.collection.mutable.ListBuffer()\n        val earthOrbit\
    \ = scala.collection.mutable.ListBuffer()\n        val mercuryOrbit = scala.collection.mutable.ListBuffer()\n\
    \        val venusOrbit = scala.collection.mutable.ListBuffer()\n        val marsOrbit\
    \ = scala.collection.mutable.ListBuffer()\n        val jupiterOrbit = scala.collection.mutable.ListBuffer()\n\
    \        val saturnOrbit = scala.collection.mutable.ListBuffer()\n        val\
    \ uranusOrbit = scala.collection.mutable.ListBuffer()\n        val neptuneOrbit\
    \ = scala.collection.mutable.ListBuffer()\n        scala.collection.mutable.ListBuffer(\"\
    Venus\", \"Mercury\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\")\n        scala.collection.mutable.ListBuffer(\"Mercury\", \"Venus\"\
    , \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n   \
    \     scala.collection.mutable.ListBuffer(\"Earth\", \"Mercury\", \"Venus\", \"\
    Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        scala.collection.mutable.ListBuffer(\"\
    Mars\", \"Mercury\", \"Earth\", \"Venus\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\")\n        scala.collection.mutable.ListBuffer(\"Jupiter\", \"Saturn\"\
    , \"Uranus\", \"Neptune\")\n        scala.collection.mutable.ListBuffer(\"Saturn\"\
    , \"Uranus\", \"Neptune\")\n        scala.collection.mutable.ListBuffer(\"Uranus\"\
    , \"Neptune\")\n        scala.collection.mutable.ListBuffer(\"Neptune\")\n   \
    \     if(planet1.equals(planet2) || planet1.equals(\"Earth\")){\n            planet1\
    \ +: planet2\n        }\n        else if(planet2.equals(planet1) || planet\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"\
    Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp78ufw8rf.scala:49:4 ----------------------------\e\
    [0m\e[0m\n\e[31m49 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmp78ufw8rf.scala:46:12 --------------------\e[0m\e[0m\n\e[31m46 |\e[0m\
    \            planet1 +: planet2\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m            Found:    IndexedSeq[Matchable]\n\e[31m   |\e\
    [0m            Required: List[String]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmp78ufw8rf.scala:48:43 ------------------------\e[0m\e\
    [0m\n\e[31m48 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m(planet2.equals(planet1)\
    \ || planet\n\e[31m\e[31m   |\e[0m                                           ^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                           Not found: planet\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660009809
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val sun = Planet(\"sun\")\n        val earth = Planet(\"\
    Earth\")\n        val mercury = Planet(\"Mercury\")\n        val venus = Planet(\"\
    Venus\")\n        val mars = Planet(\"Mars\")\n        val jupiter = Planet(\"\
    Jupiter\")\n        val saturn = Planet(\"Saturn\")\n        val uranus = Planet(\"\
    Uranus\")\n        val neptune = Planet(\"Neptune\")\n\n        val sunOrbit =\
    \ sun.orbit(planet2)\n        val earthOrbit = earth.orbit(planet1)\n        val\
    \ mercuryOrbit = mercury.orbit(planet1)\n        val venusOrbit = venus.orbit(planet1)\n\
    \        val marsOrbit = mars.orbit(planet1)\n        val jupiterOrbit = jupiter.orbit(planet1)\n\
    \        val saturnOrbit = saturn.orbit(planet1)\n        val uranusOrbit = uranus.orbit(planet1)\n\
    \        val neptuneOrbit = neptune.orbit(planet1)\n\n        def proximity(planetOrbit\
    \ : String, sunOrbit : String) : Int = {\n            if (planetOrbit == sunOrbit)\
    \ 0 else 1\n        }\n\n        val planet1 = List(mercury, venus, mars, jupiter,\
    \ saturn, uranus, neptune).sortBy(proximity)\n        val planet2 = List(sun,\
    \ earth, mercury, venus, mars, jupiter, saturn, uranus, neptune).sortBy(proximity)\n\
    \n        val orbits = planet1 ++ planet2\n        val planetOrbits = orbits.filter(_.orbit(planet1)\
    \ == _.orbit(planet2)).sortBy(proximity)\n\n        val result = planetOrbits.map(p\
    \ => (p.name, p.orbit(planet2)))\n        return result.sortBy(_._1).map(_._2).toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"\
    Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpi1ipeskt.scala:21:18 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36msun\e[0m = Planet(\e[31m\"\
    sun\"\e[0m)\n\e[31m\e[31m   |\e[0m                  ^^^^^^\e[0m\n\e[31m   |\e\
    [0m                  Not found: Planet\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpi1ipeskt.scala:22:20 ------------------------\e[0m\e\
    [0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mearth\e[0m = Planet(\e[31m\"\
    Earth\"\e[0m)\n\e[31m\e[31m   |\e[0m                    ^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                    Not found: Planet\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpi1ipeskt.scala:23:22 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mmercury\e[0m = Planet(\e\
    [31m\"Mercury\"\e[0m)\n\e[31m\e[31m   |\e[0m                      ^^^^^^\e[0m\n\
    \e[31m   |\e[0m                      Not found: Planet\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpi1ipeskt.scala:24:20 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mvenus\e[0m = Planet(\e[31m\"\
    Venus\"\e[0m)\n\e[31m\e[31m   |\e[0m                    ^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                    Not found: Planet\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpi1ipeskt.scala:25:19 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mmars\e[0m = Planet(\e[31m\"\
    Mars\"\e[0m)\n\e[31m\e[31m   |\e[0m                   ^^^^^^\e[0m\n\e[31m   |\e\
    [0m                   Not found: Planet\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpi1ipeskt.scala:26:22 ------------------------\e[0m\e\
    [0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mjupiter\e[0m = Planet(\e[31m\"\
    Jupiter\"\e[0m)\n\e[31m\e[31m   |\e[0m                      ^^^^^^\e[0m\n\e[31m\
    \  "
  stdout: ''
  timestamp: 1660009812
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        // Write your logic here\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpjp_xuc44.scala:20:64\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m    \e[33mdef\e[0m \e[36mbf\e\
    [0m(\e[36mplanet1\e[0m : \e[35mString\e[0m, \e[36mplanet2\e[0m : \e[35mString\e\
    [0m) : \e[35mList\e[0m[\e[35mString\e[0m] = {\n\e[31m\e[31m   |\e[0m         \
    \                                                       ^\e[0m\n\e[31m   |\e[0m\
    \                                                  Found:    Unit\n\e[31m   |\e\
    [0m                                                  Required: List[String]\n\e\
    [31m21 |\e[0m        \e[34m// Write your logic here\e[0m\n\e[31m22 |\e[0m    }\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009810
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planet1_orbit =  getOrbital(planet1)\n       \
    \ val planet2_orbit =  getOrbital(planet2)\n        if (planet1_orbit == 0 ||\
    \ planet2_orbit == 0) \n            return Nil\n        var planet1 : List[String]\
    \ = Nil\n        var planet2 : List[String] = Nil\n        var orbit1 : List[String]\
    \ = Nil\n        var orbit2 : List[String] = Nil\n        var orbit_distance :\
    \ Double = 0.0 \n        var orbits_distance : List[Double] = List(0)\n      \
    \  var distance_difference : Double = 0\n        var planet1_orbits : List[String]\
    \ = List(0)\n        var planet2_orbits : List[String] = List(0)\n        for\
    \ ((orbit1, orbit_distance) in planet1_orbits) {\n            if (orbit_distance\
    \ < orbit_distance) {\n                planet1 += orbit1\n                orbits_distance\
    \ += orbit_distance\n            }\n        }\n        for ((orbit2, orbit_distance)\
    \ in planet2_orbits) {\n            if (orbit_distance < orbit_distance) {\n \
    \               planet2 += orbit2\n                orbits_distance += orbit_distance\n\
    \            }\n        }\n        planet1 = planet1.sortWith((x,y) => x.compareTo(y))\n\
    \        planet2 = planet2.sortWith((x,y) => x.compareTo(y))\n        planet1\
    \ = planet1.sortWith((x,y) => x.compareTo(\"Sun\"))\n        planet2 = planet2.sortWith((x,y)\
    \ => x.compareTo(\"Sun\"))\n        planet1 = planet1.filter((x,i) => i < planet1.length)\n\
    \        planet2 = planet2.filter((x,i) => i < planet2.length)\n        planet1\
    \ = planet1.map((x,i) => Planet(x, orbits_distance(i)))\n        planet2 = planet2.map((x,i)\
    \ => Planet(x, orbits_distance(i)))\n        planet1.toList.zip(planet2.toList).foreach\
    \ { case (planet1, planet2) =>\n            planet1.getOrbit_distance(planet2)\n\
    \            if (planet1 <- planet1 && planet2 <- planet2) {\n               \
    \ distance_difference = planet1.getOrbit_distance(planet2) \n                planet1.getOrbits(planet2)\n\
    \                planet2.getOrbits(planet1)\n                distance_difference\n\
    \            }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(bf((\"\
    Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n\
    \    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n\
    \    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"),\
    \ (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpose5rier.scala:34:57 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mfor\e[0m ((orbit1, orbit_distance) in planet1_orbits)\
    \ {\n\e[31m\e[31m   |\e[0m                                                   \
    \      ^\e[0m\n\e[31m   |\e[0m                                            '<-'\
    \ expected, but '{' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpose5rier.scala:54:42\
    \ ---------------------------\e[0m\e[0m\n\e[31m54 |\e[0m        planet1.toList.zip(planet2.toList).foreach\
    \ { \e[33mcase\e[0m (planet1, planet2) =>\n\e[31m\e[31m   |\e[0m             \
    \                             ^\e[0m\n\e[31m   |\e[0m                        \
    \                  '<-' expected, but '.' found\n\e[31m\e[31m-- [E006] Not Found\
    \ Error: /tmp/tmpose5rier.scala:21:29 ------------------------\e[0m\e[0m\n\e[31m21\
    \ |\e[0m        \e[33mval\e[0m \e[36mplanet1_orbit\e[0m =  getOrbital(planet1)\n\
    \e[31m\e[31m   |\e[0m                             ^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                             Not found: getOrbital\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpose5rier.scala:22:29 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mplanet2_orbit\e[0m =  getOrbital(planet2)\n\
    \e[31m\e[31m   |\e[0m                             ^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                             Not found: getOrbital\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpose5rier.scala:32:49 --------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mvar\e[0m \e[36mplanet1_orbits\e[0m : \e\
    [35mList\e[0m[\e[35mString\e[0m] = List(\e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m \
    \                                                ^\e[0m\n\e[31m   |\e[0m     \
    \                                            Found:    (\e[31m0\e[0m : Int)\n\e\
    [31m   |\e[0m                                                 Required: String\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type"
  stdout: ''
  timestamp: 1660009811
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planetsBetweenSun = \n            (for { \n  \
    \              a <- Planets(planet1) \n                b <- Planets(planet2) \n\
    \                if (a.orbit(b) < 0) \n                } yield (a, b)).sortBy(-_._2)\n\
    \        val sun = Planets(\"Sun\")\n        val planetsBetweenPlanets = planetsBetweenSun.filter(_._1\
    \ ne sun).flatMap(p => Planets(p._1))\n        val result: List[String] = planetsBetweenPlanets.filter(p2\
    \ => p2.orbit(sun) < 0).sortBy(-_.orbit(sun))\n        if (result.isEmpty) result\
    \ else result.reverse\n    }\n    def main(args: Array[String]) = {\n    assert(bf((\"\
    Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n\
    \    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n\
    \    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"),\
    \ (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp10kvjo_8.scala:23:21 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m                a <- Planets(planet1) \n\e[31m\e[31m\
    \   |\e[0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                 \
    \    Not found: Planets\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp10kvjo_8.scala:27:18\
    \ ------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e\
    [36msun\e[0m = Planets(\e[31m\"Sun\"\e[0m)\n\e[31m\e[31m   |\e[0m            \
    \      ^^^^^^^\e[0m\n\e[31m   |\e[0m                  Not found: Planets\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660009809
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val orbits = List(\n            List(\n          \
    \      List(\"Venus\", \"Earth\"),\n                List(\"Jupiter\", \"Mars\"\
    ),\n                List(\"Saturn\", \"Uranus\"),\n                List(\"Uranus\"\
    , \"Neptune\")\n                ),\n            List(\n                List(\"\
    Mercury\", \"Earth\"),\n                List(\"Venus\", \"Mars\"),\n         \
    \       List(\"Saturn\", \"Jupiter\"),\n                List(\"Jupiter\", \"Saturn\"\
    )\n                )\n            )\n        for (planetsOrbit <- orbits) {\n\
    \            val planet1 = planetsOrbit(0)\n            val planet2 = planetsOrbit(1)\n\
    \            val planet1Orbit = planet1.toList.flatMap(planet => planet.toList)\n\
    \            val planet2Orbit = planet2.toList.flatMap(planet => planet.toList)\n\
    \            val sunOrbit = PlanetOrbit(planet1, planet2).orbit\n            val\
    \ result = planet1Orbit.filter(orbit => orbit.distance(sunOrbit) >= planet1Orbit.distance\
    \ + planet2Orbit.distance - sunOrbit.distance)\n            result\n        }\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"\
    Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpsw11q9fj.scala:40:27 ------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m            \e[33mval\e[0m \e[36msunOrbit\e[0m = PlanetOrbit(planet1,\
    \ planet2).orbit\n\e[31m\e[31m   |\e[0m                           ^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                           Not found: PlanetOrbit\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpsw11q9fj.scala:41:60 ------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m            \e[33mval\e[0m \e[36mresult\e[0m = planet1Orbit.filter(\e\
    [36morbit\e[0m => orbit.distance(sunOrbit) >= planet1Orbit.distance + planet2Orbit.distance\
    \ - sunOrbit.distance)\n\e[31m\e[31m   |\e[0m                                \
    \                      ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                  \
    \                value distance is not a member of Char\n2 errors found\n"
  stdout: ''
  timestamp: 1660009812
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        var temp : List[String] = Nil\n        // TODO\n \
    \       if (planet1 == \"Mercury\" && planet2 == \"Neptune\")\n            temp\
    \ = \"Saturn\"\n        else if (planet1 == \"Venus\" && planet2 == \"Earth\"\
    )\n            temp = \"Earth\"\n        else if (planet1 == \"Venus\" && planet2\
    \ == \"Neptune\")\n            temp = \"Uranus\"\n        else if (planet1 ==\
    \ \"Earth\" && planet2 == \"Mercury\")\n            temp = \"Mercury\"\n     \
    \   else if (planet1 == \"Earth\" && planet2 == \"Neptune\")\n            temp\
    \ = \"Mars\"\n        else if (planet1 == \"Mars\" && planet2 == \"Mercury\")\n\
    \            temp = \"Mercury\"\n        else if (planet1 == \"Mars\" && planet2\
    \ == \"Neptune\")\n            temp = \"Jupiter\"\n        else if (planet1 ==\
    \ \"Jupiter\" && planet2 == \"Mercury\")\n            temp = \"Mercury\"\n   \
    \     else if (planet1 == \"Jupiter\" && planet2 == \"Neptune\")\n           \
    \ temp = \"Saturn\"\n        else if (planet1 == \"Saturn\" && planet2 == \"Mercury\"\
    )\n            temp = \"Mercury\"\n        else if (planet1 == \"Saturn\" && planet2\
    \ == \"Neptune\")\n            temp = \"Uranus\"\n        else if (planet1 ==\
    \ \"Uranus\" && planet2 == \"Mercury\")\n            temp = \"Mercury\"\n    \
    \    else if (planet1 == \"Uranus\" && planet2 == \"Neptune\")\n            temp\
    \ = \"Venus\"\n        else if (planet1 == \"Neptune\" && planet2 == \"Mercury\"\
    )\n            temp = \"Mercury\"\n        else if (planet1 == \"Neptune\" &&\
    \ planet2 == \"Earth\")\n            temp = \"Earth\"\n        else if (planet1\
    \ == \"Neptune\" && planet2 == \"Venus\")\n            temp = \"Venus\"\n    \
    \    else if (planet1 == \"Neptune\" && planet2 == \"Mars\")\n            temp\
    \ = \"Mars\"\n        else if (planet1 == \"Neptune\" && planet2 == \"Jupiter\"\
    )\n            temp = \"Jupiter\"\n        else if (planet1 == \"Neptune\" &&\
    \ planet2 == \"Saturn\")\n            temp = \"Saturn\"\n        else if (planet1\
    \ == \"Neptune\" && planet2 == \"Uranus\")\n            temp = \"Uranus\"\n  \
    \      else if (planet1 == \"Neptune\" && planet2 == \"Neptune\")\n          \
    \  temp = \"Mercury\"\n        \n        return \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmph_0k7ht8.scala:24:19\
    \ --------------------\e[0m\e[0m\n\e[31m24 |\e[0m            temp = \e[31m\"Saturn\"\
    \e[0m\n\e[31m\e[31m   |\e[0m                   ^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                   Found:    (\e[32m\"Saturn\"\e[0m : String)\n\e[31m   |\e[0m\
    \                   Required: List[String]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmph_0k7ht8.scala:26:19 --------------------\e[0m\e\
    [0m\n\e[31m26 |\e[0m            temp = \e[31m\"Earth\"\e[0m\n\e[31m\e[31m   |\e\
    [0m                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                   Found: \
    \   (\e[32m\"Earth\"\e[0m : String)\n\e[31m   |\e[0m                   Required:\
    \ List[String]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmph_0k7ht8.scala:28:19\
    \ --------------------\e[0m\e[0m\n\e[31m28 |\e[0m            temp = \e[31m\"Uranus\"\
    \e[0m\n\e[31m\e[31m   |\e[0m                   ^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                   Found:    (\e[32m\"Uranus\"\e[0m : String)\n\e[31m   |\e[0m\
    \                   Required: List[String]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmph_0k7ht8.scala:30:19 --------------------\e[0m\e\
    [0m\n\e[31m30 |\e[0m            temp = \e[31m\"Mercury\"\e[0m\n\e[31m\e[31m  \
    \ |\e[0m                   ^^^^^^^^^\e[0m\n\e[31m   |\e[0m                   Found:\
    \    (\e[32m\"Mercury\"\e[0m : String)\n\e[31m   |\e[0m                   Required:\
    \ List[String]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmph_0k7ht8.scala:32:19\
    \ --------------------\e[0m\e[0m\n\e[31m32 |\e[0m            temp = \e[31m\"Mars\"\
    \e[0m\n\e[31m\e[31m   |\e[0m                   ^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                 Found:    (\e[32m\"Mars\"\e[0m : String)\n\e[31m   |\e[0m  \
    \                 Required: List[String]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with "
  stdout: ''
  timestamp: 1660009815
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        if(planet1 == planet2) List();\n        if(planet1\
    \ == \"\" || planet2 == \"\") List(\"\");\n        val planets1 : List[String]\
    \ = List(planet1, planet2, planet1 + \"_Mercury\", planet1 + \"_Jupiter\", planet1\
    \ + \"_Saturn\", planet1 + \"_Uranus\", planet1 + \"_Neptune\", planet1 + \"_Mars\"\
    )\n        val planets2 : List[String] = List(planet2 + \"_Mercury\", planet2\
    \ + \"_Jupiter\", planet2 + \"_Saturn\", planet2 + \"_Uranus\", planet2 + \"_Neptune\"\
    , planet2 + \"_Mars\")\n        val planets3 : List[String] = planets2 ++ planets1\n\
    \        val planets4 : List[String] = planets3 filter { planet1 + \"_Mercury\"\
    \ =:= planet2 + \"_Mercury\" } \n        val planets5 : List[String] = planets4\
    \ filter { planet1 + \"_Jupiter\" =:= planet2 + \"_Jupiter\" } \n        val planets6\
    \ : List[String] = planets5 filter { planet1 + \"_Saturn\" =:= planet2 + \"_Saturn\"\
    \ } \n        val planets7 : List[String] = planets6 filter { planet1 + \"_Uranus\"\
    \ =:= planet2 + \"_Uranus\" } \n        val planets8 : List[String] = planets7\
    \ filter { planet1 + \"_Neptune\" =:= planet2 + \"_Neptune\" } \n        val planets9\
    \ : List[String] = planets8 filter { planet1 + \"_Mars\" =:= planet2 + \"_Mars\"\
    \ } \n        planets9.sorted\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\",\
    \ \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpakk5y587.scala:26:77 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mplanets4\e[0m : \e[35mList\e\
    [0m[\e[35mString\e[0m] = planets3 filter { planet1 + \e[31m\"_Mercury\"\e[0m =:=\
    \ planet2 + \e[31m\"_Mercury\"\e[0m } \n\e[31m\e[31m   |\e[0m                \
    \                                        ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m           value =:= is not a member of String - did you mean String.==?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpakk5y587.scala:27:77 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mplanets5\e[0m : \e[35mList\e\
    [0m[\e[35mString\e[0m] = planets4 filter { planet1 + \e[31m\"_Jupiter\"\e[0m =:=\
    \ planet2 + \e[31m\"_Jupiter\"\e[0m } \n\e[31m\e[31m   |\e[0m                \
    \                                        ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m           value =:= is not a member of String - did you mean String.==?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpakk5y587.scala:28:76 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mplanets6\e[0m : \e[35mList\e\
    [0m[\e[35mString\e[0m] = planets5 filter { planet1 + \e[31m\"_Saturn\"\e[0m =:=\
    \ planet2 + \e[31m\"_Saturn\"\e[0m } \n\e[31m\e[31m   |\e[0m                 \
    \                                       ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0m           value =:= is not a member of String - did you mean String.==?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpakk5y587.scala:29:76 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mplanets7\e[0m : \e[35mList\e\
    [0m[\e[35mString\e[0m] = planets6 filter { planet1 + \e[31m\"_Uranus\"\e[0m =:=\
    \ planet2 + \e[31m\"_Uranus\"\e[0m } \n\e[31m\e[31m   |\e[0m                 \
    \                                       ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0m           value =:= is not a member of String - did you mean String.==?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpakk5y587.scala:30:77 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mplanets8\e[0m : \e[35mList\e\
    [0m[\e[35mString\e[0m] = planets7 filter { planet1 + "
  stdout: ''
  timestamp: 1660009814
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        //TODO: write your solution here\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpcesxp7s_.scala:20:64\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m    \e[33mdef\e[0m \e[36mbf\e\
    [0m(\e[36mplanet1\e[0m : \e[35mString\e[0m, \e[36mplanet2\e[0m : \e[35mString\e\
    [0m) : \e[35mList\e[0m[\e[35mString\e[0m] = {\n\e[31m\e[31m   |\e[0m         \
    \                                                       ^\e[0m\n\e[31m   |\e[0m\
    \                                                  Found:    Unit\n\e[31m   |\e\
    [0m                                                  Required: List[String]\n\e\
    [31m21 |\e[0m        \e[34m//TODO: write your solution here\e[0m\n\e[31m22 |\e\
    [0m    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009813
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        // Your code goes here\n        val planet1Orbits\
    \ = List(planet1 + \"Orbit\", planet1 + \"Orbits\")\n        val planet2Orbits\
    \ = List(planet2 + \"Orbit\", planet2 + \"Orbits\")\n        val sunOrbits = List(\"\
    Sun\", \"Suns\")\n        val planet1Orbit = planet1Orbits.filter(_ contains planet1)\n\
    \        val planet2Orbit = planet2Orbits.filter(_ contains planet2)\n       \
    \ val sunOrbit = sunOrbits.filter(_ contains planet1)\n        val orbs = planet1Orbit\
    \ ++ planet2Orbit ++ sunOrbit\n        val suns = sunOrbit.map(_ + \" Orbit\"\
    )\n        val orbOrb = orbs.map(_ + \" Orbits\")\n        val planets = orbOrb\
    \ ++ suns\n        val sunOrbits = suns.map(_ + \" Orbit\")\n        val sunOrbits1\
    \ = suns.map(_ + \" Orbits\")\n        val orbOrb1 = orbOrb.map(_ + \" Orbits\"\
    )\n        val orbOrb2 = orbOrb.map(_ + \" Orbit\")\n        val orbOrb3 = orbOrb.map(_\
    \ + \" Orbits\")\n        val sunOrbits2 = suns.map(_ + \" Orbits\")\n       \
    \ val orbOrb4 = orbOrb1.map(_ + \" Orbit\")\n        val orbOrb5 = orbOrb2.map(_\
    \ + \" Orbit\")\n        val orbOrb6 = orbOrb3.map(_ + \" Orbits\")\n        val\
    \ orbOrb7 = sunOrbits.map(_ + \" Orbits\")\n        val orbOrb8 = orbOrb4.map(_\
    \ + \" Orbits\")\n        val orbOrb9 = orbOrb5.map(_ + \" Orbit\")\n        val\
    \ orbOrb10 = orbOrb6.map(_ + \" Orbit\")\n        val orbOrb11 = orbOrb7.map(_\
    \ + \" Orbit\")\n        val orbOrb12 = orbOrb8.map(_ + \" Orbits\")\n       \
    \ val orbOrb13 = orbOrb9.map(_ + \" Orbit\")\n        val orbOrb14 = orbOrb10.map(_\
    \ + \" Orbit\")\n        val orbOrb15 = orb\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmph6ck9r70.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36msunOrbits\e[0m = suns.map(_\
    \ + \e[31m\" Orbit\"\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msunOrbits is already defined as \e[33mvalue\e[0m \e[35msunOrbits\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E006] Not\
    \ Found Error: /tmp/tmph6ck9r70.scala:49:23 ------------------------\e[0m\e[0m\n\
    \e[31m49 |\e[0m        \e[33mval\e[0m \e[36morbOrb15\e[0m = orb\n\e[31m\e[31m\
    \   |\e[0m                       ^^^\e[0m\n\e[31m   |\e[0m                   \
    \    Not found: orb\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmph6ck9r70.scala:50:5\
    \ ---------------------\e[0m\e[0m\n\e[31m50 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[String]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660009815
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        var firstOrbit : Double = 0.0, secondOrbit : Double\
    \ = 0.0\n        var firstPlanet : List[String] = Nil\n        var secondPlanet\
    \ : List[String] = Nil\n        // If the planet names are correct, the following\
    \ code will work\n        if (planet1 != \"Mercury\" && planet1 != \"Venus\" &&\
    \ planet1 != \"Earth\" && planet1 != \"Mars\" && planet1 != \"Jupiter\" && planet1\
    \ != \"Saturn\" && planet1 != \"Uranus\" && planet1 != \"Neptune\") return Nil\n\
    \        if (planet2 != \"Mercury\" && planet2 != \"Venus\" && planet2 != \"Earth\"\
    \ && planet2 != \"Mars\" && planet2 != \"Jupiter\" && planet2 != \"Saturn\" &&\
    \ planet2 != \"Uranus\" && planet2 != \"Neptune\") return Nil\n        if (planet1\
    \ == planet2) return (List(planet1))\n        if (planet1 -> planet2 == (\"Mercury\"\
    \ -> \"Earth\")) return (List(\"Earth\" -> \"Mars\"))\n        if (planet1 ->\
    \ planet2 == (\"Mercury\" -> \"Earth\" -> \"Mars\")) return (List(\"Earth\" ->\
    \ \"Mars\" -> \"Jupiter\"))\n        if (planet1 -> planet2 == (\"Mercury\" ->\
    \ \"Earth\" -> \"Mars\" -> \"Jupiter\")) return (List(\"Earth\" -> \"Mars\" ->\
    \ \"Jupiter\" -> \"Saturn\"))\n        if (planet1 -> planet2 == (\"Mercury\"\
    \ -> \"Earth\" -> \"Mars\" -> \"Jupiter\" -> \"Saturn\")) return (List(\"Earth\"\
    \ -> \"Mars\" -> \"Jupiter\" -> \"Saturn\" -> \"Uranus\"))\n        if (planet1\
    \ -> planet2 == (\"Mercury\" -> \"Earth\" -> \"Mars\" -> \"Jupiter\" -> \"Saturn\"\
    \ -> \"Uranus\")) return (List(\"Earth\" -> \"Mars\" -> \"Jupiter\" -> \"Saturn\"\
    \ -> \"Uranus\" -> \"Neptune\"))\n        if (planet1 -> planet2 == (\"Mercury\"\
    \ -> \"Earth\" -> \"Mars\" -> \"Jupiter\" -> \"Saturn\" -> \"Uranus\" -> \"Neptune\"\
    )) return (List(\"Earth\" -> \"Mars\" -> \"Jupiter\" -> \"Saturn\" -> \"Uranus\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"\
    Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmperw6k6u8.scala:21:37 -----------------------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mvar\e[0m \e[36mfirstOrbit\e[0m : \e[35mDouble\e\
    [0m = \e[31m0.0\e[0m, secondOrbit : Double = \e[31m0.0\e[0m\n\e[31m\e[31m   |\e\
    [0m                                     ^\e[0m\n\e[31m   |\e[0m              \
    \                   end of statement expected but ',' found\n\e[31m\e[31m-- Error:\
    \ /tmp/tmperw6k6u8.scala:33:177 ----------------------------------------\e[0m\e\
    [0m\n\e[31m33 |\e[0m        \e[33mif\e[0m (planet1 -> planet2 == (\e[31m\"Mercury\"\
    \e[0m -> \e[31m\"Earth\"\e[0m -> \e[31m\"Mars\"\e[0m -> \e[31m\"Jupiter\"\e[0m\
    \ -> \e[31m\"Saturn\"\e[0m -> \e[31m\"Uranus\"\e[0m -> \e[31m\"Neptune\"\e[0m))\
    \ \e[33mreturn\e[0m (List(\e[31m\"Earth\"\e[0m -> \e[31m\"Mars\"\e[0m -> \e[31m\"\
    Jupiter\"\e[0m -> \e[31m\"Saturn\"\e[0m -> \"Uranus\n\e[31m\e[31m   |\e[0m   \
    \                                                                            \
    \                                                                            \
    \                      ^\e[0m\n\e[31m   |\e[0m                               \
    \                  unclosed string literal\n\e[31m\e[31m-- Error: /tmp/tmperw6k6u8.scala:35:34\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m35 |\e[0m    \e[33mdef\e\
    [0m \e[36mmain\e[0m(\e[36margs\e[0m: \e[35mArray\e[0m[\e[35mString\e[0m]) = {\n\
    \e[31m\e[31m   |\e[0m                                  ^\e[0m\n\e[31m   |\e[0m\
    \                                 end of statement expected but '=' found\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmperw6k6u8.scala:28:71 --------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mif\e[0m (planet1 -> planet2 == (\e[31m\"\
    Mercury\"\e[0m -> \e[31m\"Earth\"\e[0m)) \e[33mreturn\e[0m (List(\e[31m\"Earth\"\
    \e[0m -> \e[31m\"Mars\"\e[0m))\n\e[31m\e[31m   |\e[0m                        \
    \                                               ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                                              Found:    \e[1m\e[31m(\e\
    [0m\e[1m\e[31mString\e[0m\e[1m\e[31m,\e[0m\e[1m\e[31m \e[0mString\e[1m\e[31m)\e\
    [0m\n\e[31m   |\e[0m                                              Required: String\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanat"
  stdout: ''
  timestamp: 1660009816
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n      val orbit1 = orbit(planet1)\n      val orbit2 = orbit(planet2)\n\
    \      val orbit1Sun = orbit(planet1.substring(0, planet1.length-1))\n      val\
    \ orbit2Sun = orbit(planet2.substring(0, planet2.length-1))\n      if (planet1.equals(planet2))\
    \ {\n        return List()\n      } else if (orbit1Sun == null || orbit1Sun.size\
    \ < 1) {\n        return List()\n      } else if (orbit2Sun == null || orbit2Sun.size\
    \ < 1) {\n        return List()\n      }\n      val orbit1SunPlus1 = orbit1Sun.map(x\
    \ => x + 1.toDouble)\n      val orbit2SunPlus1 = orbit2Sun.map(x => x + 1.toDouble)\n\
    \      val orbit1SunMinus1 = orbit1Sun.map(x => x - 1.toDouble)\n      val orbit2SunMinus1\
    \ = orbit2Sun.map(x => x - 1.toDouble)\n      var temp1 : List[Double] = List()\n\
    \      var temp2 : List[Double] = List()\n      val result: mutable.Set[String]\
    \ = new mutable.HashSet[String]()\n      for (i <- 0 until orbit1SunPlus1.size)\
    \ {\n        temp1 = orbit1SunPlus1.map( x => x - i ).toList\n        for (j <-\
    \ 0 until orbit2SunPlus1.size) {\n          temp2 = orbit2SunPlus1.map( x => x\
    \ - j ).toList\n          if (temp1.forall(f => temp2.exists( g=> f < g)) && temp2.forall(f\
    \ => temp1.exists( g=> f < g))) {\n            result.add(planet1 + \"-\" + planet2)\n\
    \          } else {\n          }\n        }\n      }\n      result.map(x => println(x)).sorted\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"\
    Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp_hixkt5r.scala:21:19 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m      \e[33mval\e[0m \e[36morbit1\e[0m = orbit(planet1)\n\
    \e[31m\e[31m   |\e[0m                   ^^^^^\e[0m\n\e[31m   |\e[0m          \
    \         Not found: orbit\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp_hixkt5r.scala:22:19 ------------------------\e[0m\e[0m\n\e[31m22 |\e\
    [0m      \e[33mval\e[0m \e[36morbit2\e[0m = orbit(planet2)\n\e[31m\e[31m   |\e\
    [0m                   ^^^^^\e[0m\n\e[31m   |\e[0m                   Not found:\
    \ orbit\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp_hixkt5r.scala:23:22\
    \ ------------------------\e[0m\e[0m\n\e[31m23 |\e[0m      \e[33mval\e[0m \e[36morbit1Sun\e\
    [0m = orbit(planet1.substring(\e[31m0\e[0m, planet1.length-\e[31m1\e[0m))\n\e\
    [31m\e[31m   |\e[0m                      ^^^^^\e[0m\n\e[31m   |\e[0m         \
    \             Not found: orbit\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp_hixkt5r.scala:24:22 ------------------------\e[0m\e[0m\n\e[31m24 |\e\
    [0m      \e[33mval\e[0m \e[36morbit2Sun\e[0m = orbit(planet2.substring(\e[31m0\e\
    [0m, planet2.length-\e[31m1\e[0m))\n\e[31m\e[31m   |\e[0m                    \
    \  ^^^^^\e[0m\n\e[31m   |\e[0m                      Not found: orbit\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp_hixkt5r.scala:38:18 ------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m      \e[33mval\e[0m \e[36mresult\e[0m: mutable.Set[\e\
    [35mString\e[0m] = \e[33mnew\e[0m mutable.HashSet[\e[35mString\e[0m]()\n\e[31m\e\
    [31m   |\e[0m                  ^^^^^^^\e[0m\n\e[31m   |\e[0m                 \
    \ Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp_hixkt5r.scala:38:44\
    \ ------------------------\e[0m\e[0m\n\e[31m38 |\e[0m      \e[33mval\e"
  stdout: ''
  timestamp: 1660009812
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val sun = Planet(Planet.Sun.name, Planet.Sun.mass,\
    \ Planet.Sun.distance, Planet.Sun.mass)\n        val mercury = Planet(Planet.Mercury.name,\
    \ Planet.Mercury.mass, Planet.Mercury.distance, Planet.Mercury.mass)\n       \
    \ val venus = Planet(Planet.Venus.name, Planet.Venus.mass, Planet.Venus.distance,\
    \ Planet.Venus.mass)\n        val earth = Planet(Planet.Earth.name, Planet.Earth.mass,\
    \ Planet.Earth.distance, Planet.Earth.mass)\n        val mars = Planet(Planet.Mars.name,\
    \ Planet.Mars.mass, Planet.Mars.distance, Planet.Mars.mass)\n        val jupiter\
    \ = Planet(Planet.jupiter.name, Planet.jupiter.mass, Planet.jupiter.distance,\
    \ Planet.jupiter.mass)\n        val saturn = Planet(Planet.saturn.name, Planet.saturn.mass,\
    \ Planet.saturn.distance, Planet.saturn.mass)\n        val uranus = Planet(Planet.uranus.name,\
    \ Planet.uranus.mass, Planet.uranus.distance, Planet.uranus.mass)\n        val\
    \ neptune = Planet(Planet.neptune.name, Planet.neptune.mass, Planet.neptune.distance,\
    \ Planet.neptune.mass)\n        val planets = (List( earth, mars, jupiter, saturn,\
    \ uranus, neptune ))\n\n        val distance = planets.map { p =>\n          \
    \  p.orbit(planet1, planet2).distance\n        }.sortBy(distance).reverse\n  \
    \      distance.head :: distance\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\",\
    \ \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp90mwodpl.scala:21:18 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36msun\e[0m = Planet(Planet.Sun.name,\
    \ Planet.Sun.mass, Planet.Sun.distance, Planet.Sun.mass)\n\e[31m\e[31m   |\e[0m\
    \                  ^^^^^^\e[0m\n\e[31m   |\e[0m                  Not found: Planet\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp90mwodpl.scala:21:25\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36msun\e[0m = Planet(Planet.Sun.name, Planet.Sun.mass, Planet.Sun.distance, Planet.Sun.mass)\n\
    \e[31m\e[31m   |\e[0m                         ^^^^^^\e[0m\n\e[31m   |\e[0m   \
    \                      Not found: Planet\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmp90mwodpl.scala:21:42 ------------------------\e[0m\e\
    [0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36msun\e[0m = Planet(Planet.Sun.name,\
    \ Planet.Sun.mass, Planet.Sun.distance, Planet.Sun.mass)\n\e[31m\e[31m   |\e[0m\
    \                                          ^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \                                    Not found: Planet\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp90mwodpl.scala:21:59 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36msun\e[0m = Planet(Planet.Sun.name,\
    \ Planet.Sun.mass, Planet.Sun.distance, Planet.Sun.mass)\n\e[31m\e[31m   |\e[0m\
    \                                                           ^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                                                       Not found: Planet\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp90mwodpl.scala:21:80\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36msun\e[0m = Planet(Planet.Sun.name, Planet.Sun.mass, Planet.Sun.distance, Planet.Sun.mass)\n\
    \e[31m\e[31m   |\e[0m                   "
  stdout: ''
  timestamp: 1660009815
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        var orbit1 = orbitOf(planet1)\n        var orbit2\
    \ = orbitOf(planet2)\n        var orbitsBetween = orbit2.toSet - orbit1.toSet\n\
    \        val result = orbitsBetween.sorted\n        result match {\n         \
    \   case Nil => List()\n            case _ => result\n        }\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpej7picav.scala:21:21 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mvar\e[0m \e[36morbit1\e[0m = orbitOf(planet1)\n\
    \e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \               Not found: orbitOf\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpej7picav.scala:22:21 ------------------------\e[0m\e[0m\n\e[31m22 |\e\
    [0m        \e[33mvar\e[0m \e[36morbit2\e[0m = orbitOf(planet2)\n\e[31m\e[31m \
    \  |\e[0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                  \
    \   Not found: orbitOf\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660009812
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planet1 = Planet(planet1)\n        val planet2\
    \ = Planet(planet2)\n        val sun = Planet(\"Sun\")\n        // The orbits\
    \ of planet1 & planet2 are given as a pair \n        val orbits1 = planet1.orbits(planet2)\n\
    \        val orbits2 = planet2.orbits(planet1)\n        // The planets are located\
    \ between their orbits and the sun\n        val planetsBetweenOrbits = orbits1\
    \ ++ orbits2 ++ List(sun)\n        // The orbits between the planets are sorted\
    \ by their distance to the sun\n        val proximityToSun = planetsBetweenOrbits.sorted\n\
    \        // The planets that are between their orbits and the sun are in the list\n\
    \        val planetsWithinOrbits = proximityToSun.filter(_.inOrbits(planet1))\n\
    \        val planetsWithoutOrbits = proximityToSun.filter(_.inOrbits(planet2))\n\
    \        // The planets that aren't within their orbits are in the list\n    \
    \    val planetsWithoutOrbitsBoth = proximityToSun.filter(!_.inOrbits(planet1))\n\
    \        val planetsWithoutOrbitsOnly = proximityToSun.filter(!_.inOrbits(planet2))\n\
    \n        if (planetsWithoutOrbitsBoth.isEmpty)\n            (planetsWithoutOrbitsOnly.toList)\n\
    \        else\n            (planetsWithoutOrbitsBoth.toList ++ planetsWithoutOrbitsOnly.toList)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"\
    Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpnkm1l_5x.scala:21:22 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mplanet1\e[0m = Planet(planet1)\n\
    \e[31m\e[31m   |\e[0m                      ^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \                Not found: Planet\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmpnkm1l_5x.scala:21:29 ---------------------------\e[0m\e[0m\n\e[31m21\
    \ |\e[0m        \e[33mval\e[0m \e[36mplanet1\e[0m = Planet(planet1)\n\e[31m\e\
    [31m   |\e[0m                             ^\e[0m\n\e[31m   |\e[0m            \
    \                 Recursive \e[33mvalue\e[0m \e[35mplanet1\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpnkm1l_5x.scala:22:22\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mplanet2\e[0m = Planet(planet2)\n\e[31m\e[31m   |\e[0m                    \
    \  ^^^^^^\e[0m\n\e[31m   |\e[0m                      Not found: Planet\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpnkm1l_5x.scala:22:29 ---------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mplanet2\e[0m = Planet(planet2)\n\
    \e[31m\e[31m   |\e[0m                             ^\e[0m\n\e[31m   |\e[0m    \
    \                         Recursive \e[33mvalue\e[0m \e[35mplanet2\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpnkm1l_5x.scala:23:18\
    \ ------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e\
    [36msun\e[0m = Planet(\e[31m\"Sun\"\e[0m)\n\e[31m\e[31m   |\e[0m             \
    \     ^^^^^^\e[0m\n\e[31m   |\e[0m                  Not found: Planet\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    5 errors found\n"
  stdout: ''
  timestamp: 1660009813
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(planet1, planet2)\n        val\
    \ sun = Planet(\"Sun\")\n        val mercury = Planet(\"Mercury\")\n        val\
    \ venus = Planet(\"Venus\")\n        val earth = Planet(\"Earth\")\n        val\
    \ mars = Planet(\"Mars\")\n        val jupiter = Planet(\"Jupiter\")\n       \
    \ val saturn = Planet(\"Saturn\")\n        val uranus = Planet(\"Uranus\")\n \
    \       val neptune = Planet(\"Neptune\")\n        val list = mutable.ListBuffer[Planet]()\n\
    \        var list2 = mutable.ListBuffer[Planet]()\n        var list3 = mutable.ListBuffer[Planet]()\n\
    \        for (p <- planets) {\n            list += p\n            if (sun == p)\
    \ {\n                continue\n            } else {\n                list2 = list\
    \ ++ List(p, sun)\n            }\n            if (mercury == p) {\n          \
    \      continue\n            } else {\n                list2 = list2 ++ List(p,\
    \ mercury)\n            }\n            if (venus == p) {\n                continue\n\
    \            } else {\n                list2 = list2 ++ List(p, venus)\n     \
    \       }\n            if (earth == p) {\n                continue\n         \
    \   } else {\n                list2 = list2 ++ List(p, earth)\n            }\n\
    \            if (mars == p) {\n                continue\n            } else {\n\
    \                list2 = list2 ++ List(p, mars)\n            }\n            if\
    \ (jupiter == p) {\n                continue\n            } else {\n         \
    \       list2 = list2 ++ List(p, jupiter)\n            }\n            if (saturn\
    \ == p) {\n                continue\n            } else {\n                list2\
    \ = list2 ++ List(p, saturn)\n            }\n            if (uranus == p) {\n\
    \                continue\n            } else {\n                list2 = list2\
    \ ++ List(p, uranus)\n            }\n            if (neptune == p) {\n       \
    \         continue\n            } else {\n                list2 = list2 ++ List(p,\
    \ neptune)\n            }\n        }\n        list2.filter(n => list.indexOf(n)\
    \ < list.indexOf(sun)).filter(n => list.indexOf(n) < list.indexOf(mercury))\n\
    \        .filter(n => list.indexOf(n) < list.indexOf(venus))\n        .filter(n\
    \ => list.indexOf(n) < list.indexOf(earth))\n        .filter(n => list.indexOf(n)\
    \ < list.indexOf(mars))\n        .filter(n => list.indexOf(n) < list.indexOf(jupiter))\n\
    \        .filter(n => list.indexOf(n) < list.indexOf(saturn))\n        .filter(n\
    \ => list.indexOf(n) < list.indexOf(uranus))\n        .filter(n => list.indexOf(n)\
    \ < list.indexOf(neptun\n    }\n    def main(args: Array[String]) = {\n    assert(bf((\"\
    Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n\
    \    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n\
    \    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"),\
    \ (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpsg05zoh2.scala:90:4 ----------------------------\e\
    [0m\e[0m\n\e[31m90 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpsg05zoh2.scala:22:18\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36msun\e[0m = Planet(\e[31m\"Sun\"\e[0m)\n\e[31m\e[31m   |\e[0m             \
    \     ^^^^^^\e[0m\n\e[31m   |\e[0m                  Not found: Planet\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpsg05zoh2.scala:23:22 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mmercury\e[0m = Planet(\e\
    [31m\"Mercury\"\e[0m)\n\e[31m\e[31m   |\e[0m                      ^^^^^^\e[0m\n\
    \e[31m   |\e[0m                      Not found: Planet\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpsg05zoh2.scala:24:20 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mvenus\e[0m = Planet(\e[31m\"\
    Venus\"\e[0m)\n\e[31m\e[31m   |\e[0m                    ^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                    Not found: Planet\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpsg05zoh2.scala:25:20 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mearth\e[0m = Planet(\e[31m\"\
    Earth\"\e[0m)\n\e[31m\e[31m   |\e[0m                    ^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                    Not found: Planet\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpsg05zoh2.scala:26:19 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mmars\e[0m = Planet(\e[31m\"\
    Mars\"\e[0m)\n\e[31m\e[31m   |\e[0m                   ^^^^^^\e[0m\n\e[31m   |\e\
    [0m                   Not found: Planet\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmps"
  stdout: ''
  timestamp: 1660009814
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        if (planet1 == planet2) List()\n        else {\n \
    \           val a = List(planet1, planet2)\n            val b = a.zipWithIndex.filter(x\
    \ => x._1.equals(x._2))\n            b.sortBy(x => x._1.distance(x._2))\n    \
    \    }\n    }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"\
    ), (\"Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpc6v09cr9.scala:25:31 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m            b.sortBy(\e[36mx\e[0m => x._1.distance(x._2))\n\
    \e[31m\e[31m   |\e[0m                          ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                          value distance is not a member of String\n\e[31m\e\
    [31m-- Error: /tmp/tmpc6v09cr9.scala:25:46 -----------------------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m            b.sortBy(\e[36mx\e[0m => x._1.distance(x._2))\n\
    \e[31m\e[31m   |\e[0m                                              ^\e[0m\n\e\
    [31m   |\e[0mambiguous given instances: both \e[33mobject\e[0m \e[35mByte\e[0m\
    \ in \e[33mobject\e[0m \e[35mOrdering\e[0m and \e[33mobject\e[0m \e[35mChar\e\
    [0m in \e[33mobject\e[0m \e[35mOrdering\e[0m match type Ordering[B] of parameter\
    \ ord of \e[33mmethod\e[0m \e[35msortBy\e[0m in \e[33mtrait\e[0m \e[35mSeqOps\e\
    [0m\n2 errors found\n"
  stdout: ''
  timestamp: 1660009815
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        if (planet1 == \"\" || planet2 == \"\") return Nil\n\
    \        val l1 = planet1.toList.sorted\n        val l2 = planet2.toList.sorted\n\
    \        val l3 = l1.zipWithIndex.flatMap(x => {\n            val p = x._1\n \
    \           val ix = x._2\n            l2.zipWithIndex.flatMap(x => {\n      \
    \          val q = x._1\n                val iy = x._2\n                l3.zipWithIndex.flatMap(x\
    \ => {\n                    val r = x._1\n                    val iz = x._2\n\
    \                    val v1 = l2.indexWhere(p < x._1)\n                    val\
    \ v2 = l2.indexWhere(p > x._1)\n                    val v3 = l2.indexWhere(q <\
    \ x._1)\n                    val v4 = l2.indexWhere(q > x._1)\n              \
    \      val v5 = l2.indexWhere(r < x._1)\n                    val v6 = l2.indexWhere(r\
    \ > x._1)\n                    val v7 = l2.indexWhere(iy < x._1)\n           \
    \         val v8 = l2.indexWhere(iy > x._1)\n                    val v9 = l2.indexWhere(iz\
    \ < x._1)\n                    val v10 = l2.indexWhere(iz > x._1)\n          \
    \          if (v1 == -1) Nil\n                    else if (v1 == 0 && v2 == -1)\
    \ Nil\n                    else if (v1 == 0 && v2 == 0 && v3 == -1) Nil\n    \
    \                else if (v1 == 0 && v2 == 0 && v3 == 0 && v4 == -1) Nil\n   \
    \                 else if (v1 == 0 && v2 == 0 && v3 == 0 && v4 == 0 && v5 == -1)\
    \ Nil\n                    else if (v1 == 0 && v2 == 0 && v3 == 0 && v4 == 0 &&\
    \ v5 == 0 && v6 == -1) Nil\n                    else if (v1 == 0 && v2 == 0 &&\
    \ v3 == 0 && v4 == 0 && v5 == 0 && v6 == 0 && v7 == -1) Nil\n                \
    \    else if (v1 == 0 && v2 == 0 && v3 == 0 && v4 == 0 && v5 == 0 && v6 == 0 &&\
    \ v7 == 0 && v8 == -1) Nil\n                    else if (v1 == 0 && v2 == 0 &&\
    \ v3 == 0 && v4 == 0 && v5 == 0 && v6 == 0 && v7 == 0 && v8 == 0 && v9 == -1)\
    \ Nil\n                    else if (v1 == 0 && v2 == 0 && v3 == 0 && v4 == 0 &&\
    \ v5 == 0 && v6 == 0 && v7 == 0 && v8 == 0 && v9 == 0 && v10 == -1) Nil\n    \
    \                else if (v1 == 0 && v2 == 0 && v3 == 0 && v4 == 0 && v5 == 0\
    \ && v6 == 0 && v7 == 0 && v8 == 0 && \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp1rlm8s76.scala:53:116 --------------------------\e\
    [0m\e[0m\n\e[31m53 |\e[0m                    \e[33melse\e[0m \e[33mif\e[0m (v1\
    \ == \e[31m0\e[0m && v2 == \e[31m0\e[0m && v3 == \e[31m0\e[0m && v4 == \e[31m0\e\
    [0m && v5 == \e[31m0\e[0m && v6 == \e[31m0\e[0m && v7 == \e[31m0\e[0m && v8 ==\
    \ \e[31m0\e[0m && \n\e[31m\e[31m   |\e[0m                                    \
    \                                                                            \
    \    ^\e[0m\n\e[31m   |\e[0m                                       expression\
    \ expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tmp1rlm8s76.scala:55:4 ----------------------------\e[0m\e[0m\n\e[31m55\
    \ |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e[35mArray\e[0m[\e\
    [35mString\e[0m]) = {\n\e[31m\e[31m   |\e[0m    ^^^\e[0m\n\e[31m   |\e[0m    ')'\
    \ expected, but 'def' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp1rlm8s76.scala:66:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m66 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m')' expected, but eof found\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmp1rlm8s76.scala:30:16 ---------------------------\e[0m\e[0m\n\e\
    [31m30 |\e[0m                l3.zipWithIndex.flatMap(\e[36mx\e[0m => {\n\e[31m\e\
    [31m   |\e[0m                ^\e[0m\n\e[31m   |\e[0m                Recursive\
    \ \e[33mvalue\e[0m \e[35ml3\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmp1rlm8s76.scala:65:1 ---------------------\e\
    [0m\e[0m\n\e[31m65 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e[0m\n\e[31m   |\e[0m Found:\
    \    Unit\n\e[31m   |\e[0m Required: List[String]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n5 errors found\n"
  stdout: ''
  timestamp: 1660009816
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val p1 = Planet(planet1)\n        val p2 = Planet(planet2)\n\
    \        val sun = Planet(\"Sun\")\n        val ps = List(sun, p1, p2)\n     \
    \   val orbits = Orbits(ps).all\n        if (orbits.isEmpty) return Nil\n    \
    \    val p1 = orbits(0)\n        val p2 = orbits(1)\n        val a = orbits.map{case\
    \ Orbit(Sun, p, p, p) => p.orbit}\n        val b = orbits.map{case Orbit(Sun,\
    \ p, p, p) => p.orbit}\n        val c = orbits.map{case Orbit(Sun, p, p, p) =>\
    \ p.orbit}\n        val d = orbits.map{case Orbit(Sun, p, p, p) => p.orbit}\n\
    \        val e = orbits.map{case Orbit(Sun, p, p, p) => p.orbit}\n        val\
    \ f = orbits.map{case Orbit(Sun, p, p, p) => p.orbit}\n        val g = orbits.map{case\
    \ Orbit(Sun, p, p, p) => p.orbit}\n        val h = orbits.map{case Orbit(Sun,\
    \ p, p, p) => p.orbit}\n        val i = orbits.map{case Orbit(Sun, p, p, p) =>\
    \ p.orbit}\n        val j = orbits.map{case Orbit(Sun, p, p, p) => p.orbit}\n\
    \        val k = orbits.map{case Orbit(Sun, p, p, p) => p.orbit}\n        val\
    \ l = orbits.map{case Orbit(Sun, p, p, p) => p.orbit}\n        val m = orbits.map{case\
    \ Orbit(Sun, p, p, p) => p.orbit}\n        val n = orbits.map{case Orbit(Sun,\
    \ p, p, p) => p.orbit}\n        val o = orbits.map{case Orbit(Sun, p, p, p) =>\
    \ p.orbit}\n        val p = orbits.map{case Orbit(Sun, p, p, p) => p.orbit}\n\
    \        val q = orbits.map{case Orbit(Sun, p, p, p) => p.orbit}\n        val\
    \ r = orbits.map{case Orbit(Sun, p, p, p) => p.orbit}\n        val s = orbits.map{case\
    \ Orbit(Sun, p, p, p) => p.orbit}\n        val t = orbits.map{case Orbit(Sun,\
    \ p, p, p) => p.orbit}\n        val u = orbits.map{case Orbit(Sun, p, p, \n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"\
    Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpf5y11ejw.scala:50:4 ----------------------------\e\
    [0m\e[0m\n\e[31m50 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpf5y11ejw.scala:62:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m62 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpf5y11ejw.scala:27:12 ---------------------------\e[0m\e[0m\n\e\
    [31m27 |\e[0m        \e[33mval\e[0m \e[36mp1\e[0m = orbits(\e[31m0\e[0m)\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mp1 is already defined\
    \ as \e[33mvalue\e[0m \e[35mp1\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpf5y11ejw.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mp2\e[0m = orbits(\e[31m1\e\
    [0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mp2\
    \ is already defined as \e[33mvalue\e[0m \e[35mp2\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpf5y11ejw.scala:21:17\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mp1\e[0m = Planet(planet1)\n\e[31m\e[31m   |\e[0m                 ^^^^^^\e\
    [0m\n\e[31m   |\e[0m                 Not found: Planet\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpf5y11ejw.scala:22:17 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mp2\e[0m = Planet(planet2)\n\
    \e[31m\e[31m   |\e[0m                 ^^^^^^\e[0m\n\e[31m   |\e[0m           \
    \      Not found: Planet\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpf5y11ejw.scala:23:18 ------------------------\e[0m\e[0m\n\e[31m23 |\e\
    [0m        \e[33mval\e[0m \e[36msun\e[0m = Planet(\e[31m\"Sun\"\e[0m)\n\e[31m\e\
    [31m   |\e[0m    "
  stdout: ''
  timestamp: 1660009816
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val orbits = List(\n            Planet(planet1, Planet(\"\
    Venus\", Planet(\"Earth\", Planet(\"Mars\", Planet(\"Jupiter\", Planet(\"Saturn\"\
    , Planet(\"Uranus\", Planet(\"Neptune\", Planet(\"Mercury\", Planet(\"Venus\"\
    , Planet(\"Earth\", Planet(\"Mars\", Planet(\"Jupiter\", Planet(\"Saturn\", Planet(\"\
    Uranus\", Planet(\"Mercury\", Planet(\"Venus\", Planet(\"Earth\", Planet(\"Mars\"\
    , Planet(\"Jupiter\", Planet(\"Saturn\", Planet(\"Uranus\", Planet(\"Mercury\"\
    , Planet(\"Venus\", Planet(\"Earth\", Planet(\"Mars\", Planet(\"Jupiter\", Planet(\"\
    Saturn\", Planet(\"Uranus\", Planet(\"Mercury\", Planet(\"Venus\", Planet(\"Earth\"\
    , Planet(\"Mars\", Planet(\"Jupiter\", Planet(\"Saturn\", Planet(\"Uranus\", Planet(\"\
    Mercury\", Planet(\"Venus\", Planet(\"Earth\", Planet(\"Mars\", Planet(\"Jupiter\"\
    , Planet(\"Saturn\", Planet(\"Uranus\", Planet(\"Mercury\", Planet(\"Venus\",\
    \ Planet(\"Earth\", Planet(\"Mars\", Planet(\"Jupiter\", Planet(\"Saturn\", Planet(\"\
    Uranus\", Planet(\"Mercury\", Planet(\"Venus\", Planet(\"Earth\", Planet(\"Mars\"\
    , Planet(\"Jupiter\", Planet(\"Saturn\", Planet(\"Uranus\", Planet(\"Mercury\"\
    , Planet(\"Venus\", Planet(\"Earth\", Planet(\"Mars\", Planet(\"Jupiter\", Planet(\"\
    Saturn\", Planet(\"Uranus\", Planet(\"Mercury\", Planet(\"Venus\", Planet(\"Earth\"\
    , Planet(\"Mars\", Planet(\"Jupiter\", Planet(\"Saturn\", Planet(\"Uranus\", Planet(\"\
    Mercury\", Planet(\"Venus\", Planet(\"Earth\", Planet(\"Mars\", Planet(\"Jupiter\"\
    , Planet(\"Saturn\", Planet(\"Uranus\", Planet(\"Mercury\", Planet(\"Venus\",\
    \ Planet(\"Earth\", Planet(\"Mars\", Planet(\"Jupiter\", Planet(\"Saturn\", \n\
    \    }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"\
    Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpcopgeuff.scala:23:4 ----------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpcopgeuff.scala:22:12\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m            Planet(planet1,\
    \ Planet(\e[31m\"Venus\"\e[0m, Planet(\e[31m\"Earth\"\e[0m, Planet(\e[31m\"Mars\"\
    \e[0m, Planet(\e[31m\"Jupiter\"\e[0m, Planet(\e[31m\"Saturn\"\e[0m, Planet(\e\
    [31m\"Uranus\"\e[0m, Planet(\e[31m\"Neptune\"\e[0m, Planet(\e[31m\"Mercury\"\e\
    [0m, Planet(\e[31m\"Venus\"\e[0m, Planet(\e[31m\"Earth\"\e[0m, Planet(\e[31m\"\
    Mars\"\e[0m, Planet(\e[31m\"Jupiter\"\e[0m, Planet(\e[31m\"Saturn\"\e[0m, Planet(\e\
    [31m\"Uranus\"\e[0m, Planet(\e[31m\"Mercury\"\e[0m, Planet(\e[31m\"Venus\"\e[0m,\
    \ Planet(\e[31m\"Earth\"\e[0m, Planet(\e[31m\"Mars\"\e[0m, Planet(\e[31m\"Jupiter\"\
    \e[0m, Planet(\e[31m\"Saturn\"\e[0m, Planet(\e[31m\"Uranus\"\e[0m, Planet(\e[31m\"\
    Mercury\"\e[0m, Planet(\e[31m\"Venus\"\e[0m, Planet(\e[31m\"Earth\"\e[0m, Planet(\e\
    [31m\"Mars\"\e[0m, Planet(\e[31m\"Jupiter\"\e[0m, Planet(\e[31m\"Saturn\"\e[0m,\
    \ Planet(\e[31m\"Uranus\"\e[0m, Planet(\e[31m\"Mercury\"\e[0m, Planet(\e[31m\"\
    Venus\"\e[0m, Planet(\e[31m\"Earth\"\e[0m, Planet(\e[31m\"Mars\"\e[0m, Planet(\e\
    [31m\"Jupiter\"\e[0m, Planet(\e[31m\"Saturn\"\e[0m, Planet(\e[31m\"Uranus\"\e\
    [0m, Planet(\e[31m\"Mercury\"\e[0m, Planet(\e[31m\"Venus\"\e[0m, Planet(\e[31m\"\
    Earth\"\e[0m, Planet(\e[31m\"Mars\"\e[0m, Planet(\e[31m\"Jupiter\"\e[0m, Planet(\e\
    [31m\"Saturn\"\e[0m, Planet(\e[31m\"Uranus\"\e[0m, Planet(\e[31m\"Mercury\"\e\
    [0m, Planet(\e[31m\"Venus\"\e[0m, Planet(\e[31m\"Earth\"\e[0m, Planet(\e[31m\"\
    Mars\"\e[0m, Planet(\e[31m\"Jupiter\"\e[0m, Planet(\e[31m\"Saturn\"\e[0m, Planet(\e\
    [31m\"Uranus\"\e[0m, Planet(\e[31m\"Mercury\"\e[0m, Planet(\e[31m\"Venus\"\e[0m,\
    \ Planet(\e[31m\"Earth\"\e[0m, Planet(\e[31m\"Mars\"\e[0m, Planet(\e[31m\"Jupiter\"\
    \e[0m, Planet(\e[31m\"Saturn\"\e[0m, Planet(\e[31m\"Uranus\"\e[0m, Planet(\e[31m\"\
    Mercury\"\e[0m, Planet(\e[31m\"Venus\"\e[0m, Planet(\e[31m\"Earth\"\e[0m, Planet(\e\
    [31m\"Mars\"\e[0m, Planet(\e[31m\"Jupiter\"\e[0m, Planet(\e[31m\"Saturn\"\e[0m,\
    \ Planet(\e[31m\"Uranus\"\e[0m, Planet(\e[31m\"Mercury\"\e[0m, Planet(\e[31m\"\
    Venus\"\e[0m, Planet(\e[31m\"Earth\"\e[0m, Planet(\e[31m\"Mars\"\e["
  stdout: ''
  timestamp: 1660009817
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n      val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n      val orbits\
    \ = planets.map(x => (x, x))\n        .reduce((x: (List[String], List[String]),\
    \ y: (List[String], List[String])) => {\n            val x1: List[String] = x._1;\n\
    \            val x2: List[String] = x._2;\n            val y1: List[String] =\
    \ y._1;\n            val y2: List[String] = y._2;\n            val orb1 = orbits(x1);\n\
    \            val orb2 = orbits(x2);\n            val dist1 = orb1.map(x1 => orb2.map(y2\
    \ => (x1, y2)).minBy(_._2).map(_._2).map(_._1).map(x => Math.pow(x - y, 2)).sum)\n\
    \            val dist2 = orb2.map(x2 => orb1.map(y1 => (x2, y1)).minBy(_._2).map(_._2).map(_._1).map(x\
    \ => Math.pow(x - y, 2)).sum)\n            (dist1, dist2)\n        }) match {\n\
    \        case (Some(a), Some(b)) => (a :: b)\n        case _ => List()\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpb5hidjqi.scala:48:0 ----------------------------\e\
    [0m\e[0m\n\e[31m48 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpb5hidjqi.scala:28:23\
    \ ---------------------------\e[0m\e[0m\n\e[31m28 |\e[0m            \e[33mval\e\
    [0m \e[36morb1\e[0m = orbits(x1);\n\e[31m\e[31m   |\e[0m                     \
    \  ^\e[0m\n\e[31m   |\e[0m                       Recursive \e[33mvalue\e[0m \e\
    [35morbits\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmpb5hidjqi.scala:29:23 ---------------------------\e[0m\e[0m\n\e[31m29\
    \ |\e[0m            \e[33mval\e[0m \e[36morb2\e[0m = orbits(x2);\n\e[31m\e[31m\
    \   |\e[0m                       ^\e[0m\n\e[31m   |\e[0m                     \
    \  Recursive \e[33mvalue\e[0m \e[35morbits\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpb5hidjqi.scala:34:38 ------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mcase\e[0m (Some(a), Some(b)) => (a :: b)\n\
    \e[31m\e[31m   |\e[0m                                      ^^^^\e[0m\n\e[31m \
    \  |\e[0m                                      value :: is not a member of Any\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpb5hidjqi.scala:47:1 ---------------------\e\
    [0m\e[0m\n\e[31m47 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e[0m\n\e[31m   |\e[0m Found:\
    \    Unit\n\e[31m   |\e[0m Required: List[String]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[33m\e[33m--\
    \ Warning: /tmp/tmpb5hidjqi.scala:37:4 ----------------------------------------\e\
    [0m\e[0m\n\e[33m37 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m\
    \   |\e[0m    Line is indented too far to the left, or a `}` is missing\n1 warning\
    \ found\n5 errors found\n"
  stdout: ''
  timestamp: 1660009817
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planetList : List[String] = Nil\n        val orbits\
    \ = List(\n            new Orbit(planet1, 0, 0),\n            new Orbit(planet1,\
    \ 1, 0),\n            new Orbit(planet1, 2, 0),\n            new Orbit(planet1,\
    \ 3, 0),\n            new Orbit(planet1, 4, 0),\n            new Orbit(planet1,\
    \ 5, 0),\n            new Orbit(planet1, 6, 0),\n            new Orbit(planet1,\
    \ 7, 0),\n            new Orbit(planet1, 8, 0)\n            )\n        for (orbit\
    \ <- orbits) {\n            if (planetList.contains(orbit.planet)) {\n       \
    \     }\n            else {\n                val distance = (planetList.indexOf(orbit.planet)\
    \ * 1000 + orbit.orbit)\n                planetList += orbit.planet\n        \
    \    }\n        }\n        return planetList.sortWith((s1, s2) => {\n        \
    \    val d1 =  (planetList.indexOf(s1) * 1000 + orbitList.indexOf(s1))\n     \
    \       val d2 =  (planetList.indexOf(s2) * 1000 + orbitList.indexOf(s2))\n  \
    \          (d1 - d2) / (d1 + d2)\n        })\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp2rg4szaf.scala:23:16 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            \e[33mnew\e[0m \e[35mOrbit\e[0m(planet1,\
    \ \e[31m0\e[0m, \e[31m0\e[0m),\n\e[31m\e[31m   |\e[0m                ^^^^^\e[0m\n\
    \e[31m   |\e[0m                Not found: type Orbit\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp2rg4szaf.scala:24:16 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m            \e[33mnew\e[0m \e[35mOrbit\e[0m(planet1,\
    \ \e[31m1\e[0m, \e[31m0\e[0m),\n\e[31m\e[31m   |\e[0m                ^^^^^\e[0m\n\
    \e[31m   |\e[0m                Not found: type Orbit\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp2rg4szaf.scala:25:16 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m            \e[33mnew\e[0m \e[35mOrbit\e[0m(planet1,\
    \ \e[31m2\e[0m, \e[31m0\e[0m),\n\e[31m\e[31m   |\e[0m                ^^^^^\e[0m\n\
    \e[31m   |\e[0m                Not found: type Orbit\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp2rg4szaf.scala:26:16 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m            \e[33mnew\e[0m \e[35mOrbit\e[0m(planet1,\
    \ \e[31m3\e[0m, \e[31m0\e[0m),\n\e[31m\e[31m   |\e[0m                ^^^^^\e[0m\n\
    \e[31m   |\e[0m                Not found: type Orbit\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp2rg4szaf.scala:27:16 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m            \e[33mnew\e[0m \e[35mOrbit\e[0m(planet1,\
    \ \e[31m4\e[0m, \e[31m0\e[0m),\n\e[31m\e[31m   |\e[0m                ^^^^^\e[0m\n\
    \e[31m   |\e[0m                Not found: type Orbit\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp2rg4szaf.scala:28:16 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m            \e[33mnew\e[0m \e[35mOrbit\e[0m(planet1,\
    \ \e[31m5\e[0m, \e[31m0\e[0m),\n\e[31m\e[31m   |\e[0"
  stdout: ''
  timestamp: 1660009817
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        def isCorrectPlanet(planetName : String) : Boolean\
    \ = {\n            planetName match {\n                case \"Mercury\" => \"\
    Mercury\" != \"Earth\" && \"Mercury\" != \"Mars\"\n                case \"Venus\"\
    \ => \"Venus\" != \"Earth\" && \"Venus\" != \"Mars\"\n                case \"\
    Earth\" => \"Earth\" != \"Mercury\" && \"Earth\" != \"Venus\" && \n          \
    \          \"Earth\" != \"Mars\"\n                case \"Mars\" => \"Mars\" !=\
    \ \"Earth\" && \"Mars\" != \"Venus\" && \n                    \"Mars\" != \"Jupiter\"\
    \n                case \"Jupiter\" => \"Jupiter\" != \"Earth\" && \"Jupiter\"\
    \ != \"Mars\" && \n                    \"Jupiter\" != \"Saturn\"\n           \
    \     case \"Saturn\" => \"Saturn\" != \"Earth\" && \"Saturn\" != \"Mars\" &&\
    \ \n                    \"Saturn\" != \"Uranus\"\n                case \"Uranus\"\
    \ => \"Uranus\" != \"Earth\" && \"Uranus\" != \"Mars\" && \n                 \
    \   \"Uranus\" != \"Neptune\"\n                case \"Neptune\" => \"Neptune\"\
    \ != \"Earth\" && \"Neptune\" != \"Mars\" && \n                    \"Neptune\"\
    \ != \"Uranus\"\n                case _ => false\n            }\n        }\n\n\
    \        def orbitalPlanets(planetName : String) : List[String] = {\n        \
    \    planetName match {\n                case \"Mercury\" => List(\"Venus\", \"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n       \
    \         case \"Venus\" => List(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\", \"Neptune\")\n                case \"Earth\" => List(\"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n                case \"Mars\"\
    \ => List(\"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n                case\
    \ \"Jupiter\" => List(\"Saturn\", \"Uranus\", \"Neptune\")\n                case\
    \ \"Saturn\" => List(\"Uranus\", \"Neptune\")\n                case \"Uranus\"\
    \ => List(\"Neptune\")\n                case \"Neptune\" => List()\n         \
    \       case _ => List()\n            }\n        }\n\n        def orbitalPlanetsOfPlanet(planetName\
    \ : String) : List[String] = {\n            planetName match {\n             \
    \   case \"Mercury\" => List(\"Venus\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpyizwf1ho.scala:57:39 -----------------------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m                \e[33mcase\e[0m \e[31m\"Mercury\"\e[0m\
    \ => List(\"Venus\n\e[31m\e[31m   |\e[0m                                     \
    \  ^\e[0m\n\e[31m   |\e[0m                                       unclosed string\
    \ literal\n\e[31m\e[31m-- Error: /tmp/tmpyizwf1ho.scala:59:34 -----------------------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[31m\e[31m   |\e[0m                \
    \                  ^\e[0m\n\e[31m   |\e[0m                                 end\
    \ of statement expected but '=' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpyizwf1ho.scala:70:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m70 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E006] Not\
    \ Found Error: /tmp/tmpyizwf1ho.scala:59:4 -------------------------\e[0m\e[0m\n\
    \e[31m59 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e[35mArray\e\
    [0m[\e[35mString\e[0m]) = {\n\e[31m\e[31m   |\e[0m    ^^^\e[0m\n\e[31m   |\e[0m\
    \    Not found: Venusdef\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpyizwf1ho.scala:69:1 ---------------------\e[0m\e[0m\n\e[31m69\
    \ |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e[0m\n\e[31m   |\e[0m Found:    Unit\n\e[31m\
    \   |\e[0m Required: List[String]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n5 errors found\n"
  stdout: ''
  timestamp: 1660009817
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n       val orbits1 = mutable.ListBuffer[String]()\n      \
    \ val orbits2 = mutable.ListBuffer[String]()\n       for (e <- 1 to Planets) {\n\
    \           val planet = Planets(e)\n           if (planet.name == \"Mercury\"\
    \ && planet1.name == \"Earth\") orbits1 += planet.name \n           if (planet.name\
    \ == \"Venus\" && planet2.name == \"Earth\") orbits2 += planet.name\n       }\n\
    \       orbits1.toList.sortWith(_ < _) ::: orbits2.toList.sortWith(_ < _)\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"\
    Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp0w1_vjqf.scala:21:21 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m       \e[33mval\e[0m \e[36morbits1\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp0w1_vjqf.scala:22:21 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m       \e[33mval\e[0m \e[36morbits2\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp0w1_vjqf.scala:23:22 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m       \e[33mfor\e[0m (e <- \e[31m1\e[0m to Planets)\
    \ {\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                      Not found: Planets\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmp0w1_vjqf.scala:24:24 ------------------------\e[0m\e\
    [0m\n\e[31m24 |\e[0m           \e[33mval\e[0m \e[36mplanet\e[0m = Planets(e)\n\
    \e[31m\e[31m   |\e[0m                        ^^^^^^^\e[0m\n\e[31m   |\e[0m   \
    \                     Not found: Planets\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660009816
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        // your code here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpeii8yrsb.scala:20:64\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m    \e[33mdef\e[0m \e[36mbf\e\
    [0m(\e[36mplanet1\e[0m : \e[35mString\e[0m, \e[36mplanet2\e[0m : \e[35mString\e\
    [0m) : \e[35mList\e[0m[\e[35mString\e[0m] = {\n\e[31m\e[31m   |\e[0m         \
    \                                                       ^\e[0m\n\e[31m   |\e[0m\
    \                                                  Found:    Unit\n\e[31m   |\e\
    [0m                                                  Required: List[String]\n\e\
    [31m21 |\e[0m        \e[34m// your code here\e[0m\n\e[31m22 |\e[0m    }\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660009817
