name: HumanEval_58_common
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Return sorted unique common elements for two lists.\n    // >>> common((List[Long](1l.toLong,\
  \ 4l.toLong, 3l.toLong, 34l.toLong, 653l.toLong, 2l.toLong, 5l.toLong)), (List[Long](5l.toLong,\
  \ 7l.toLong, 1l.toLong, 5l.toLong, 9l.toLong, 653l.toLong, 121l.toLong)))\n    //\
  \ (List[Long](1l.toLong, 5l.toLong, 653l.toLong))\n    // >>> common((List[Long](5l.toLong,\
  \ 3l.toLong, 2l.toLong, 8l.toLong)), (List[Long](3l.toLong, 2l.toLong)))\n    //\
  \ (List[Long](2l.toLong, 3l.toLong))\n    def common(l1 : List[Long], l2 : List[Long])\
  \ : List[Long] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(common((List[Long](1l.toLong,\
  \ 4l.toLong, 3l.toLong, 34l.toLong, 653l.toLong, 2l.toLong, 5l.toLong)), (List[Long](5l.toLong,\
  \ 7l.toLong, 1l.toLong, 5l.toLong, 9l.toLong, 653l.toLong, 121l.toLong))).equals((List[Long](1l.toLong,\
  \ 5l.toLong, 653l.toLong))));\n    assert(common((List[Long](5l.toLong, 3l.toLong,\
  \ 2l.toLong, 8l.toLong)), (List[Long](3l.toLong, 2l.toLong))).equals((List[Long](2l.toLong,\
  \ 3l.toLong))));\n    assert(common((List[Long](4l.toLong, 3l.toLong, 2l.toLong,\
  \ 8l.toLong)), (List[Long](3l.toLong, 2l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
  \ 3l.toLong, 4l.toLong))));\n    assert(common((List[Long](4l.toLong, 3l.toLong,\
  \ 2l.toLong, 8l.toLong)), (List[Long]())).equals((List[Long]())));\n    }\n\n}\n"
completions: ["        val a = l1.toSet ++ l2.toSet\n        val b = (l1 diff l2).toSet\
    \ ++ l2.toSet\n        val c = (l1 diff l2).toSet ++ (l2 diff l1).toSet\n    \
    \    val d = (l1 diff l2).toSet ++ (l2 diff l1).toSet\n        val e = (l1 diff\
    \ l2).toSet ++ (l2 diff (l1 diff l2)).toSet\n        val f = l1.toSet ++ (l2 diff\
    \ l1).toSet\n        val g = l1.toSet ++ (l2 diff l2).toSet\n        val h = (l1\
    \ diff l2).toSet ++ (l2 diff (l1 diff l2)).toSet\n        val i = l1.toSet ++\
    \ (l2 diff (l1 diff l2)).toSet\n        val j = (l1 diff l2).toSet ++ (l2 diff\
    \ (l1 diff l2)).toSet\n        val k = (l1 diff l2).toSet ++ (l2 diff (l1 diff\
    \ l2)).toSet\n        val l = (l1 diff l2).toSet ++ (l2 diff (l1 diff l2)).toSet\n\
    \        val m = (l1 diff l2).toSet ++ (l2 diff (l1 diff l2)).toSet\n        val\
    \ n = (l1 diff l2).toSet ++ (l2 diff (l1 diff l2)).toSet\n        val o = (l1\
    \ diff l2).toSet ++ (l2 diff (l1 diff l2)).toSet\n        val p = (l1 diff l2).toSet\
    \ ++ (l2 diff (l1 diff l2)).toSet\n        val q = (l1 diff l2).toSet ++ (l2 diff\
    \ (l1 diff l2)).toSet\n        val r = (l1 diff l2).toSet ++ (l2 diff (l1 diff\
    \ l2)).toSet\n        val s = (l1 diff l2).toSet ++ (l2 diff (l1 diff l2)).toSet\n\
    \        val t = (l1 diff l2).toSet ++ (l2 diff (l1 diff l2)).toSet\n        val\
    \ u = (l1 diff l2).toSet ++ (l2 diff (l1 diff l2)).toSet\n        val v = (l1\
    \ diff l2).toSet ++ (l2 diff (l1 diff l2)).toSet\n        val w = (l1 diff l2).toSet\
    \ ++ (l2 diff (l1 diff l2)).toSet\n        val x = (l1 diff l2).toSet ++ (l2 diff\
    \ (l1 diff l2)).toSet\n", "        val unique1 = mutable.HashSet[Long]()\n   \
    \     val unique2 = mutable.HashSet[Long]()\n        val res = mutable.ArrayBuffer(l1(0))\n\
    \        l1.foreach( x => {\n            if(unique1.contains(x)) return\n    \
    \        unique1 += x\n            if(unique2.contains(x)) return\n          \
    \  unique2 += x\n            res += x\n        })\n        res ++= l2.filter(\
    \ x => !unique1.contains(x) &&  !unique2.contains(x))\n        res.sort()\n  \
    \      res", "        val set1 = new mutable.HashSet[Long](l1)\n        val set2\
    \ = new mutable.HashSet[Long](l2)\n        set1.intersect(set2)", '        l1
    zip l2 map ((a, b) => if (a == b) a else None)', "        val list1 = l1 ++ l2.filter(_\
    \ <- l1.sorted)\n        val list2 = l1.filter(_ <- list1.sorted)\n        val\
    \ result = list1 ++ list2\n        result.sortWith(_ > _)", '        l1 zip l2
    map { case (a, b) => (a max b) min a }', "        def loop(i : Int, acc : List[Long])\
    \ : List[Long] = {\n            if (i < l1.length) {\n                if (l1.get(i)\
    \ == l2.get(i)) {\n                    loop(i +1, l1.filterNot(l1.lift(_ == l2.get(i))))\
    \ ++ acc\n                } else if (l1.get(i) < l2.get(i)) {\n              \
    \      loop(i +1, acc)\n                } else {\n                    loop(i +1,\
    \ l2.filterNot(l1.lift(_ == l2.get(i)))) ++ acc\n                }\n         \
    \   } else {\n                acc\n            }\n        }\n        loop(0 ,\
    \ List[Long]())", "        var s1 =  l1.toSet.toList\n        var s2 = l2.toSet.toList\n\
    \        var r1 = s2.toList\n        var r2 = s1.toList\n        var l = s1.toList\n\
    \        var m = s1.toList\n        var r = s1.toList\n        var n = s1.toList\n\
    \        var i = s1.toList\n        var v = s1.toList\n        var p = s1.toList\n\
    \        var f = s1.toList\n        var d = s1.toList\n        var g = s1.toList\n\
    \        var h = s1.toList\n        var k = s1.toList\n        var j = s1.toList\n\
    \        while ( s1 union s2 == l1 && l1 union s2 == l2 && s1 union s2 == l2 )\
    \ {\n            if ( s1.size > s2.size ) {\n                s1 = s1.tail\n  \
    \              s2 = s2.tail\n            } else {\n                s2 = s2.tail\n\
    \                s1 = s1.tail\n            }\n        }\n        while ( s1 contains\
    \ s2 && s1 contains l2 ) {\n            s1 = s1.tail\n            l2 = l2.tail\n\
    \        }\n        while ( s1 contains s2 && l1 contains l2 ) {\n           \
    \ l = l.tail\n            s1 = s1.tail\n            l2 = l2.tail\n        }\n\
    \        while ( l1 contains s2 && l1 contains l2 ) {\n            m = m.tail\n\
    \            l1 = l1.tail\n            l2 = l2.tail\n        }\n        while\
    \ ( s1 contains s2 && l2 contains l1 ) {\n            r = r.tail\n           \
    \ s1 = s1.tail\n            l2 = l2.tail\n        }\n        while ( s1 contains\
    \ s2 && s2 contains l1 ) {\n            n = n.tail\n            s1 = s1.tail\n\
    \            s2 = s2.tail\n        }\n        while ( l1 contains s2 && l2 contains\
    \ s1 ) {\n            i = i.tail\n            l1 = l1.tail\n            s1 = s1.tail\n\
    \        }\n        while ( l1 contains s2 && s2 contains l1 ) {\n           \
    \ v = v.tail\n            l1 = l1.tail\n            s1 = s1.tail\n        }\n\
    \        while ( l1 contains s2 && l2 contains s1 ) {\n            p = p.tail\n\
    \            l1 = l1.tail\n            s1 = s1.tail\n        }\n        while\
    \ ( s1 contains s2 && l1 contains s1 ) {\n            f = f.tail\n           \
    \ l1 = l1.tail\n            s1 = s1.tail\n        }\n        while ( s1 contains\
    \ s2 && s2 contains l1 ) {\n            d = d.tail\n            l1 = l1.tail\n\
    \            s1 = s1.tail\n        }\n        while ( s1 contains s2 && l2 contains\
    \ s1 ) {\n            g = g.tail\n            l1 = l1.tail\n            s1 = s1.tail\n\
    \        }", "        val unique = l1.toSet ++ l2.toSet\n        if (unique.isEmpty)\
    \ Nil\n        else unique.toList.sort", "        val l1 = l1.toList\n       \
    \ val l2 = l2.toList\n        val unique = l1.zip(l2).filter { case (a1, b1) =>\
    \ !l2.contains(b1) && a1 != b1 }.map (_._1)\n        unique.sortWith((a, b) =>\
    \ a < b).distinct", "        //return l1 union l2\n        val newList = l1 ++\
    \ l2\n        val sorted = newList.sorted\n        val seen = mutable.HashSet[Long]()\n\
    \        val res = []\n        var i = 0\n        while (i < sorted.length) {\n\
    \            val el = sorted(i)\n            seen.add(el)\n            i += 1\n\
    \            while (i<sorted.length && el == sorted(i)) {\n                val\
    \ other = sorted(i)\n                if (!seen.contains(other)) {\n          \
    \          res += other\n                    i += 1\n                } else {\n\
    \                    break\n                }\n            }\n        }\n    \
    \    res", "        var common = l1 diff l2\n        while (l1.nonEmpty && l2.nonEmpty)\
    \ {\n            if (l1.head == l2.head) {\n                l1 += l1.head :: l1.tail\n\
    \                l2 -= l2.head\n            } else {\n                if (common.length\
    \ == 0) {\n                    common = l1 diff l2\n                }\n      \
    \          l1 -= l1.head\n                l2 += l2.head\n            }\n     \
    \   }\n        if (common.length > 0) {\n            common.reverse\n        }\
    \ else {\n            common\n        }", "        var l3 : List[Long] = Nil\n\
    \        for(a <- l1 ) {\n        for(a <- l2 ) {\n        if(l3.contains(a))\
    \ {\n            l3 = l3.filter(_ != a) // Remove all duplicates\n        } else\
    \ {\n            l3 = l3 :+ a // Add the element to the new list\n        }\n\
    \        }}\n        l3", "        val list1 = l1.toSeq\n        val list2 = l2.toSeq\n\
    \        if (list1.nonEmpty && list2.nonEmpty) {\n            list1.intersect(list2).toList\n\
    \        }\n        else {\n            list1\n        }", "        var result\
    \ = l1\n        var common = l1.filter(l1.contains(_))\n        val l = l2.filter(l2.contains(_))\n\
    \        common ++ l", "        val commonElements = mutable.Set[Long]()\n   \
    \     l1 foreach { e1 => l2 foreach { e2 => commonElements add(e1 & e2) } }\n\
    \        l1 filter { e1 => commonElements contains e1 }", "        l1.zipWithIndex.intersect(l2.zipWithIndex).\n\
    \          collect {case (x, y) => if (x == y) x else y}.\n          sorted",
  "        if (l1 == null || l2 == null) List()\n        else {\n            val l1\
    \ = l1.toSet\n            val l2 = l2.toSet\n            val intersection = (l1\
    \ diff l2)\n            l1 intersect l2\n        }", "        def isSame(s : List[Long],\
    \ t: List[Long]) : Boolean = {\n            if(!s.isEmpty) s.head == t.head\n\
    \            else true\n        }\n        val s1 = new mutable.ListBuffer[Long]\n\
    \        val s2 = new mutable.ListBuffer[Long]\n        for(i <- 0 until l1.length)\
    \ s1.append(l1(i))\n        for(i <- 0 until l2.length) s2.append(l2(i))\n   \
    \     val s1 = s1.toList.sorted\n        val s2 = s2.toList.sorted\n        if(s1.length\
    \ == s2.length) {\n            var i1 = 0\n            var i2 = 0\n          \
    \  while(!(s1(i1) == s2(i2)) && i1 < s1.length) {\n                if(i2 == s2.length)\n\
    \                    break\n                if(s1(i1) != s2(i2)) {\n         \
    \           i1 += 1\n                    i2 += 1\n                }\n        \
    \        else {\n                    i1 += 1\n                    i2 += 1\n  \
    \              }\n            }\n            if(!(i1 == s1.length && i2 == s2.length))\
    \ {\n                s1.slice(i1, s1.length-i2)\n            }\n        }\n  \
    \      else\n            List()", "        val a1 = l1.toSet\n        val a2 =\
    \ l2.toSet\n        a1 intersect a2 map { x => x }.toList", '        l1 diff l2
    filterNot (x => l2 exists y => x == y)', "        var list = l1.toSet\n      \
    \  list.addAll(l2)\n        list = list.sortWith(_ < _)\n        val list2 = list.iterator.toList\n\
    \        val list3 = list2.takeWhile(_ != l2.head)\n        val list4 = list3.drop(1)\n\
    \        val list5 = list4.iterator.toList\n        val list6 = list5.takeWhile(_\
    \ != l1.head)\n        val list7 = list6.drop(1)\n        list7.toList", "   \
    \     // Find the common elements\n        var commonElements = l1.filter(x =>\
    \ l2.contains(x))\n        // Find the unique elements\n        var uniqueElements\
    \ = l1.diff(commonElements)\n        // Return sorted unique common elements\n\
    \        commonElements.sorted", "        // Sort list before comparing it to\
    \ avoid the problem of comparing non-unique elements.\n        val l3 = (l1 ++\
    \ l2).sorted\n        // Initialize result to empty list.\n        val result\
    \ = new mutable.LinkedList[Long]()\n        // Iterate over the lists and add\
    \ elements that appear in both lists.\n        for (i <- l3.indices) {\n     \
    \       if (l3(i) == l3((i + 1).toLong)) {\n                result.add(i.toLong)\n\
    \            }\n        }\n        result.toList", "        var commonList = scala.collection.mutable.ListBuffer[Long]()\n\
    \        var i = 0\n        while (i < l1.length || i < l2.length) {\n       \
    \     if (i >= l1.length) commonList += l2.head\n            if (i >= l2.length)\
    \ commonList += l1.head\n            else {\n                if ((l1.head < l2.head)\
    \ ^ (l1.head > l2.head)) commonList += l2.head\n                else commonList\
    \ += l1.head\n            }\n            i += 1\n        }\n        commonList.sortWith(_\
    \ < _)", "        val (l1, l2) = l1 zip l2\n        val m = l1.length\n      \
    \  val n = l2.length\n        var i : Int = 0\n        var j : Int = 0\n     \
    \   val common = new mutable.HashSet[Long]\n        while (i<m && j<n) {\n   \
    \         if (l1.get(i) == l2.get(j)) {\n                common.add(l1.get(i))\n\
    \                i += 1\n                j += 1\n            } else if( l1.get(i)\
    \ < l2.get(j)) {\n                j += 1\n            } else {\n             \
    \   i += 1\n            }\n        }\n        common.toList", "        val l =\
    \ l1.distinct\n        val l2 = l2.distinct\n        if (l.isEmpty) l2\n     \
    \   else l.intersect(l2).distinct", "        // Solution 1: find all elements\
    \ that are in both lists\n        // >>> common([1, 2, 5, 8], [2, 3, 5])\n   \
    \     // (2, 3)\n        val commonSet = l1.intersect(l2).filterNot(_ == l1.head).filterNot(_\
    \ == l2.head)\n        // Solution 2: return unique elements\n        // >>> common([1,\
    \ 2, 5, 8], [2, 3, 5])\n        // (2, 3)\n        commonSet.distinct", "    \
    \    val set1 = mutable.HashSet[Long]()\n        val set2 = mutable.HashSet[Long]()\n\
    \        l1.foreach{ x => set1 += x}\n        l2.foreach{ x => set2 += x}\n  \
    \      set1.intersect(set2).toList", "        val common = l1 match {\n      \
    \      case x :: xs =>\n                val y = l2 match {\n                 \
    \   case xs :: ys =>\n                        common(xs, ys)\n               \
    \     case _ => false\n                }\n                if (y) x\n         \
    \       else false\n            case _ => false\n        }\n        if (common)\
    \ l1 else l2", "        val set1 : mutable.Set[Long] = new mutable.HashSet[Long]()\n\
    \        val set2 : mutable.Set[Long] = new mutable.HashSet[Long]()\n        l1.foreach\
    \ {\n            x =>\n            if (set1.add(x)) {\n                set2.add(x)\n\
    \            }\n        }\n        set1.diff(set2).map(x => l1.filter(_ != x)).toList",
  "        def i1(xs: Int) : Int = {\n            val n = xs.length\n            if(n\
    \ == 0)\n                0\n            else\n                xs(0).toLong * xs(1)\
    \ + i1(xs.drop(1))\n        }\n        def i2(xs: Int) : Int = {\n           \
    \ val n = xs.length\n            if(n == 0)\n                0\n            else\n\
    \                xs(0).toLong * xs(1) + i2(xs.drop(1))\n        }\n        val\
    \ a = l1.foldLeft(mutable.ArrayBuffer.empty[Long])((a, x) => if (a.isEmpty ||\
    \ a.last.compareTo(x) == 0)\n            a :+ x\n        else\n            a)\n\
    \        val b = l2.foldLeft(mutable.ArrayBuffer.empty[Long])((b, x) => if (b.isEmpty\
    \ || b.last.compareTo(x) == 0)\n            b :+ x\n        else\n           \
    \ b)\n        val ac = a.toList\n        val bc = b.toList\n        ac.flatMap{x\
    \ => bc.map{y =>\n            val xi = i1(x).toInt\n            val yi = i1(y).toInt\n\
    \            if (xi != yi)\n                (xi -> yi)\n        }.filter(_._1\
    \ != _._1).sortBy(_._1).map(_._2)}.toList", '        l1 ++ l2.filter(x => l1.contains(x))',
  "        val li : List[Long] = l1 ++ l2\n        li.foldLeft[List[Long]](List[Long]())((a,\
    \ b) => {\n            if (a contains b) {\n                a\n            } else\
    \ {\n                b::a\n            }\n        })", "        val s1 = l1 ++\
    \ l2\n        val s0 = l1 -- l2\n        val set1 = new mutable.HashSet[Long](l1)\n\
    \        val set0 = new mutable.HashSet[Long](l0)\n        s1.filter(x => set1.remove(x))\n\
    \            .filter(x => set0.remove(x))", "        val l = new HashSet(l1 ++\
    \ l2)\n        l.reverse.toList", "        val common = new mutable.ListBuffer[Long]()\n\
    \        for (a <- l1) {\n            for (b <- l2) {\n                if (a ==\
    \ b) {\n                    common += a\n                }\n            }\n  \
    \      }\n        common.distinct", '        l1 ++ l2.filterNot(_ == l1.head).distinct',
  "        val m = l1.length\n        val n = l2.length\n        val l3 = new ListBuffer[Long]()\n\
    \        var i : Int = 0\n        var j : Int = 0\n        while (i < m && j <\
    \ n) {\n            if (l1(j) < l2(m)) {\n                l3 += l1(j)\n      \
    \          i += 1\n            } else if (l1(j) > l2(m)) {\n                l3\
    \ += l2(m)\n                j += 1\n            } else {\n                l3 +=\
    \ l1(j)\n                i += 1\n                j += 1\n            }\n     \
    \   }\n        if (i < m) {\n            l3 += l1(j)\n        }\n        if (j\
    \ < n) {\n            l3 += l2(m)\n        }\n        l3.toList", "        val\
    \ sortedList1 = l1.sortWith(_ < _)\n        val sortedList2 = l2.sortWith(_ <\
    \ _)\n        if (sortedList1 == sortedList2) sortedList1\n        else sortedList1.filter(_\
    \ == sortedList2.min) ++ sortedList2.filter(_ == sortedList1.min)", "        //\
    \ Sort the two lists first\n        def compare(l1 : List[Long], l2 : List[Long])\
    \ : Int = {\n            if (l1.length == l2.length) l1 compareTo l2\n       \
    \     else (l2.length, l1.length) match {\n                case (_, 0) => -1\n\
    \                case (_, 1) => 0\n                case (x, y) => (l1.head < l2.head)\
    \ ? -1 : 1\n            }\n        }\n        l1.sortBy(compare(l1, l2))", " \
    \       val (common, other) = (l1 diff l2, l2 diff l1)\n        common ++ other",
  "        val a = {\n            val a = l1.toSet\n            val b = l2.toSet\n\
    \            a.intersect(b)\n        }\n\n        val b = {\n            val a\
    \ = l2.toSet\n            val b = l1.toSet\n            a.intersect(b)\n     \
    \   }\n        a.union(b)", "        val commonSet = mutable.HashSet[Long]()\n\
    \        l1.foreach(c => commonSet.add(c))\n        l2.foreach(c => commonSet.add(c))\n\
    \        commonSet.filter(_ != 0l).toList", '        l1 ++ l2.toSet.toList.sortWith(
    (a,b) => a > b )', "        if (l1.isEmpty) return l2\n        if (l2.isEmpty)\
    \ return l1\n        if (l1.head == l2.head) common(l1.tail, l2.tail)\n      \
    \  else common(l1, l2.tail)", "        if (l1 == null || l2 == null) return l1\n\
    \        if (l1.length == 0) return l2\n        if (l2.length == 0) return l1\n\
    \        val l1set = l1.toSet\n        val l2set = l2.toSet\n        if (l1set\
    \ intersect l2set) return l1\n        if (l1set diff l2set) return l2\n      \
    \  l1set diff l2set", "        val l3 = new mutable.HashSet[Long]()\n        l1\
    \ foreach { x => l3.add(x) }\n        l2 foreach { x => l3.add(x) }\n        l3.toList\
    \ filter (x => l2.contains(x)) sortWith { x => l1.indexOf(x) } map { x => x }.toList",
  '        l1.foldLeft(l2) ((acc, elem) => (elem :: acc).distinct)', '        if (l1.length
    <= 0) l2 else common(l2, l1.tail)', "        var ans = ListBuffer[Long]()\n  \
    \      for (x <- l1 diff l2) {\n            ans += x\n        }\n        ans.toList",
  "        val set = new mutable.HashSet[Long]()\n        l1.foreach(x => set.add(x.toLong))\n\
    \        l2.foreach(x => set.add(x.toLong))\n        set.distinct", "        val\
    \ result = new mutable.HashSet[Long]()\n        l1 foreach { x => if (result.contains(x))\
    \ x else result += x }\n        l2 foreach { x => if (result.contains(x)) x else\
    \ result += x }\n        result.sortWith(_ < _)", "        def removeIfMatched(lst\
    \ : List[Long], toRemove : List[Long]) = {\n            if (lst.size <= toRemove.size)\
    \ return lst\n            if (toRemove.size <= lst.size) return toRemove\n   \
    \         if (toRemove.isEmpty) return lst\n            if (lst.isEmpty || toRemove.isEmpty)\
    \ return toRemove\n            if (lst.toSet.intersect(toRemove.toSet).size !=\
    \ toRemove.size)\n                return removeIfMatched(lst.tail, toRemove.tail)\n\
    \            if (lst.toSet.intersect(toRemove.toSet).size == toRemove.size)\n\
    \                return removeIfMatched(lst.tail, removeIfMatched(lst.tail, toRemove.tail))\n\
    \            return removeIfMatched(lst.tail, removeIfMatched(lst.toList, toRemove.tail))\n\
    \        }\n        var common = removeIfMatched(l1, l2)\n        var commons\
    \ = Set[Long]()\n        commons ++= l1 ++ l2\n        while (l1.nonEmpty || l2.nonEmpty)\
    \ {\n            common ++= removeIfMatched(common.toList, commons.toList)\n \
    \           commons += l1.head ++ l2.head\n            common = removeIfMatched(l1.tail,\
    \ l2.tail)\n            commons ++= l1.head ++ l2.head\n        }\n        common.toList",
  "        //We use hash set so that order does not matter\n        var hSet = mutable.HashSet[Long]()\n\
    \        hSet ++= l1\n        hSet ++= l2\n        hSet.filter(x => l1.contains(x)\
    \ || l2.contains(x))", "        l1 ::: l2\n        .groupBy(x => x)\n        .mapValues(_.size)\n\
    \        .filter(_._2 > 1)\n        .keys", "        val a = l1.toSet.intersect(l2.toSet)\n\
    \        val b = l2.toSet.intersect(l1.toSet)\n        if (b.isEmpty) a\n    \
    \    else if (a.isEmpty) b\n        else a union b", "        // Sort the lists.\n\
    \        l1 = l1.sorted\n        l2 = l2.sorted\n        \n        // Return sorted\
    \ unique common elements for two lists.\n        if (l1.isEmpty) l2\n        else\
    \ if (l2.isEmpty) l1\n        else if (l1.head == l2.head) common(l1.tail, l2.tail)\n\
    \        else common(l1, l2.tail)", "        var l3 = [(l1.head + l2.head)]\n\
    \        while(l1.tail != Nil || l2.tail != Nil){\n            val m = (l1.tail.head\
    \ + l2.tail.head) max l3.head\n            if(m==0){\n                l3.remove(l3.head)\n\
    \            } else {\n                l3.append(m)\n            }\n         \
    \   l1 = l1.tail\n            l2 = l2.tail\n        }\n        if(l1.tail == Nil\
    \ && l2.tail == Nil){\n            return Nil\n        } else {\n            return\
    \ l3\n        }", "        var l1a = l1\n        var l1b = l1\n        var l2a\
    \ = l2\n        var l2b = l2\n        while (l1a.nonEmpty && l2a.nonEmpty) {\n\
    \            if (l1a(l1a.head) < l2a(l2a.head)) {\n                l1 = l1a.tail\n\
    \                l1a = l1a.head\n            } else {\n                l2 = l2a.tail\n\
    \                l2a = l2a.head\n            }\n        }\n        while (l1b.nonEmpty\
    \ && l2b.nonEmpty) {\n            if (l1b(l1b.head) < l2b(l2b.head)) {\n     \
    \           l1 = l1b\n                l1b = l1b\n            } else {\n      \
    \          l2 = l2b\n                l2b = l2b\n            }\n        }\n   \
    \     (l1a ++ l1b).distinct", "      val sortedL1 = l1.sorted\n      val sortedL2\
    \ = l2.sorted\n      val commonElementsSet = new mutable.HashSet[Long]()\n   \
    \   val commonElements = ListBuffer[Long]()\n      var i = 0\n      while (i <\
    \ sortedL1.length && i < sortedL2.length) {\n        val l1Element = sortedL1(i)\n\
    \        val l2Element = sortedL2(i)\n        if (commonElementsSet.contains(l2Element))\
    \ {\n          i += 1\n        } else {\n          commonElementsSet += l2Element\n\
    \          commonElements += l2Element\n          i += 1\n        }\n      }\n\
    \      if (i < sortedL1.length) commonElements += sortedL1(i)\n      if (i < sortedL2.length)\
    \ commonElements += sortedL2(i)\n      commonElements.toList", "        var commonList\
    \ = new ListBuffer[Long]()\n        l1.foreach(element => {\n            if (commonList.contains(element))\
    \ {\n                return\n            } else {\n                commonList\
    \ += element\n            }\n        })\n        l2.foreach(element => {\n   \
    \         if (commonList.contains(element)) {\n                return\n      \
    \      } else {\n                commonList += element\n            }\n      \
    \  })\n        commonList.distinct", "        val c1 = l1.toSet & l2.toSet\n \
    \       c1.toList", "        val num1 = l1.length\n        val num2 = l2.length\n\
    \        var common = List[Long]()\n        var i = 0\n        while (i < num1\
    \ && i < num2) {\n            if (l1.get(i) eq l2.get(i))\n                common\
    \ ::= l1.get(i)\n            else \n                i += 1\n        }\n      \
    \  if (num1 != num2) common ::= l1.last\n        common", "        val s1 = l1.sorted\n\
    \        val s2 = l2.sorted\n        val r1 = new HashSet[Long]()\n        val\
    \ r2 = new HashSet[Long]()\n        for (x <- s1) if (!r1.contains(x)) r1.add(x)\n\
    \        for (x <- s2) if (!r2.contains(x)) r2.add(x)\n        r1.toList ++ (r2.toList\
    \ diff r1).sorted", "        val c1 = l1.distinct\n        val c2 = l2.distinct\n\
    \        val u1 = c1.toSet & c2.toSet\n        if(u1.isEmpty) return List() \n\
    \        else u1.head :: common(l1.filterNot(_ == u1.head), l2.filterNot(_ ==\
    \ u1.head))", "        val l = l1.toSet ++ l2.toSet\n        l.toList.sortWith(_\
    \ < _)", "        val unique = Set[Long](l1, l2).distinct\n        unique.toList",
  "        var i : Int = 0\n        var j : Int = 1\n        var result : List[Long]\
    \ = Nil\n        var set1 : Set[Long] = Set()\n        var set2 : Set[Long] =\
    \ Set()\n\n        while (i < l1.length && j < l2.length) {\n            val x\
    \ = l1.get(i)\n            val y = l2.get(j)\n            if (set1.contains(y))\
    \ {\n                i += 1\n            } else {\n                if (set2.contains(x))\
    \ {\n                    j -= 1\n                } else {\n                  \
    \  result = result ::: List(x, y)\n                }\n                set1.add(y)\n\
    \            }\n            set2.add(x)\n        }\n\n        if (i < l1.length)\
    \ {\n            result = result ::: l1.take(i).toList\n        }\n        if\
    \ (j < l2.length) {\n            result = result ::: l2.take(j).toList\n     \
    \   }\n        result", "        var l3 = (l1.filter(!(l1.contains(_))) ++ l2.filter(!(l2.contains(_)))).toSet\n\
    \        for(a <- l1.filter(!(l1.contains(_))) ++ l2.filter(!(l2.contains(_)))\
    \ ; b <- l1.filter(!(l1.contains(_))) ++ l2.filter(!(l2.contains(_))) ; if (a\
    \ == b) l3 += a ; else l3 += b) yield l3.toList", "        var n1 = l1.size\n\
    \        var n2 = l2.size\n        var common = new ListBuffer[Long]()\n     \
    \   while (n1 >= 0 && n2 >= 0) {\n            if (l1.get(n1) == l2.get(n2)) {\n\
    \                common.append(l1.get(n1))\n                n1--\n           \
    \     n2--\n            } else if (l1.get(n1) < l2.get(n2)) {\n              \
    \  n1--\n            } else {\n                n2--\n            }\n        }\n\
    \        common.toList", "        // Use a hash set for O(n) lookups and O(n)\
    \ insertions.\n        // This is also called a perfect hash, but we assume that\
    \ all elements\n        // are unique. \n        val h1 = new mutable.HashSet[Long]()\n\
    \        val h2 = new mutable.HashSet[Long]()\n        // Add the elements in\
    \ the list1 to the hash set h1\n        l1.foreach { x => h1.add(x) }\n      \
    \  // Add the elements in the list2 to the hash set h2\n        l2.foreach { x\
    \ => h2.add(x) }\n        // Now, h1 contains all elements in both lists\n   \
    \     // And h2 contains all elements in only list1\n        // Now, we are only\
    \ left with elements that are in both lists and h1 contains all\n        // elements\
    \ that are in list2 and h2 contains all elements that are in list1\n        //\
    \ Now, sort all the elements that are in both lists and h1 and h2 \n        //\
    \ and return the sorted unique common elements\n        // This assumes that there\
    \ are no duplicate elements in list1 and list2\n        l1.toSet.intersect(l2).toList.sort",
  "        // TODO: Write me!\n        val l1 = l1.toSet\n        val l2 = l2.toSet\n\
    \        l1.intersection(l2).sort", "        var l3 = (0 until l1.length) map\
    \ (x => 0 until l2.length) map (x => new Pair(l1.get(x), l2.get(x))) toList\n\
    \        l3.sort { x => x._1._1 < x._1._2 }", "        var list : List[Long] =\
    \ Nil\n        for (i <- l1 diff l2) {\n            list = i :: list\n       \
    \ }\n        list.sortWith((x, y) => x < y)", "        val common = l1 ++ l2 diff\
    \ l1\n        common.toList.sortWith(_ > _)", "        def helper(l1 : List[Long],\
    \ l2 : List[Long], i : Int, result : List[Long]) =\n            if (i >= l1.length\
    \ && i >= l2.length) return result\n            else if (i >= l1.length) helper(l2,\
    \ l1, i + 1, result :+ l1(i))\n            else helper(l1, l2, i + 1, result :+\
    \ l1(i))\n        helper(l1, l2, 0, Nil)", "        def union(xs: List[Long],\
    \ ys: List[Long]) : List[Long] = {\n            var x : List[Long] = xs\n    \
    \        var y : List[Long] = ys\n            while(x.nonEmpty) {\n          \
    \      x ::= x.head\n                y.foreach(y.head :: _)\n            }\n \
    \           xs ::= y\n        }\n\n        def find(xs : List[Long], ys : List[Long])\
    \ : List[Long] = {\n            var x : List[Long] = xs\n            var y : List[Long]\
    \ = ys\n            var z: List[Long] = Nil\n            while(x.nonEmpty) {\n\
    \                x ::= x.head\n                y.foreach(y.head :: _)\n      \
    \          if(x.nonEmpty) {\n                    if(x.head == y.head) {\n    \
    \                    z ::= x.head\n                    }\n                }\n\
    \            }\n            xs ::= z\n        }\n\n        def findFirst(xs :\
    \ List[Long], ys : List[Long]) : List[Long] = {\n            var x : List[Long]\
    \ = xs\n            var y : List[Long] = ys\n            var z: List[Long] = Nil\n\
    \            while(x.nonEmpty) {\n                x ::= x.head\n             \
    \   y.foreach(y.head :: _)\n                if(x.nonEmpty) {\n               \
    \     if(x.head == y.head) {\n                        z ::= x.head\n         \
    \               x.drop(1).foreach(x :: _)\n                    }\n           \
    \     }\n            }\n            xs ::= z\n        }\n        if(l1.isEmpty)\
    \ {\n            return l2\n        }\n        if(l2.isEmpty) {\n            return\
    \ l1\n        }\n        val l1m = l1.groupBy(x => x).map(x => (x._1, x._2.toList))\n\
    \        val l2m = l2.groupBy(x => x).map(x => (x._1, x._2.toList))\n        val\
    \ l3 = union(l1m, l2m)\n        l3.flatten", "        var l3 = l1;\n        var\
    \ l4 = l2;\n        while (l3.nonEmpty || l4.nonEmpty) {\n            var common\
    \ = l3.find(x => !l4.exists(y => x == y)) match {\n                case None =>\
    \ l4.toList;\n                case Some(element) => element :: common;\n     \
    \       }\n            l3.remove(common);\n            l4.remove(common);\n  \
    \      }\n        l3.toList", "        if (l1.isEmpty) {\n            return l2\n\
    \        }\n        if (l2.isEmpty) {\n            return l1\n        }\n    \
    \    if (l1.head == l2.head) {\n            return common(l1.tail, l2.tail)\n\
    \        }\n        val result = new mutable.ListBuffer[Long]()\n        val commonElement\
    \ = new mutable.HashSet[Long]()\n        l1.foreach { e =>\n            commonElement.add(e)\n\
    \        }\n        l2.foreach { e =>\n            if (!commonElement.contains(e))\
    \ {\n                commonElement += e\n            }\n        }\n        result.addAll(commonElement)\n\
    \        result.toList", "        val commonSet = l1 ++ l2 diff l1 diff l2\n \
    \       commonSet.sort", "        def find(l1 : List[Long], l2 : List[Long], result\
    \ : List[Long]) : List[Long] = {\n            def findL(l1 : List[Long], l2 :\
    \ List[Long], result : List[Long]) : List[Long] = {\n                if (l1.isEmpty)\
    \ result\n                else if (l2.isEmpty) result ::: l1\n               \
    \ else if (l1.head == l2.head) findL(l1.tail, l2.tail, result ::: l1)\n      \
    \          else findL(l1, l2.tail, result ::: l2)\n            }\n           \
    \ findL(l1, l2, Nil)\n        }\n        find(l1, l2, Nil)", "        val set1\
    \ = new mutable.HashSet[Long](l1.toArray)\n        val set2 = new mutable.HashSet[Long](l2.toArray)\n\
    \        set1.retainAll(set2)\n        set1.toList", "        val s1 = l1.sortBy(_.toInt)\n\
    \        val s2 = l2.sortBy(_.toInt)\n        val intersection = s2.filter(x =>\
    \ s1.exists(y => x == y))\n        val difference = s2.filter(x => !s1.exists(y\
    \ => x == y))\n        (intersection ++ difference)", "        val result = new\
    \ mutable.ListBuffer[Long]\n        l1.foreach(x => if (l2.contains(x)) result\
    \ += x else None)\n        result.sortWith((x,y) => x.toLong > y.toLong)\n   \
    \     result.toList", "        val uniqueList1 = unique(l1)\n        val uniqueList2\
    \ = unique(l2)\n        uniqueList1.intersect(uniqueList2).toList", "        val\
    \ set1 = new HashSet[Long](l1)\n        val set2 = new HashSet[Long](l2)\n   \
    \     set1.intersect(set2)", "        val (c1, l1) = l1.sortWith(_ < _).span(_\
    \ == l2.head)\n        val (c2, l2) = l2.sortWith(_ < _).span(_ == l1.head)\n\
    \        c1.takeWhile(x => !l2.exists(y => x == y)).toList ::: c2.takeWhile(x\
    \ => !l1.exists(y => x == y)).toList", "        var a : Set[Long] = new mutable.HashSet[Long]()\n\
    \        var b : Set[Long] = new mutable.HashSet[Long]()\n        var c : Set[Long]\
    \ = new mutable.HashSet[Long]()\n        var d : Set[Long] = new mutable.HashSet[Long]()\n\
    \        var e : Set[Long] = new mutable.HashSet[Long]()\n\n        l1.foreach(x\
    \ => a.add(x))\n        l2.foreach(x => b.add(x))\n\n        for(i <- a to b )\
    \ {\n            if(!c.contains(i)) {\n                c.add(i)\n            \
    \    d += i\n            }\n        }\n\n        for(i <- b to c ) {\n       \
    \     if(!d.contains(i)) {\n                d.add(i)\n                e += i\n\
    \            }\n        }\n\n        e - (a ++ b ++ c ++ d)", "        if (l1.length\
    \ != l2.length) throw new java.lang.AssertionError(\"Not same length.\")\n   \
    \     var commonL1 : List[Long] = Nil\n        var commonL2 : List[Long] = Nil\n\
    \        var i : Int = 0\n        val max = l1.length\n        while (i < max)\
    \ {\n            val el1 = l1.get(i)\n            val el2 = l2.get(i)\n      \
    \      if (el1 != el2 && commonL1 == Nil && commonL2 == Nil) commonL1 = Nil\n\
    \            else if (el1 == el2 && commonL1 == Nil) commonL1 = el1\n        \
    \    else if (el1 == el2 && commonL2 == Nil) commonL2 = el2\n            else\
    \ if (el1 != el2 && commonL1 == Nil && commonL2 == Nil) {\n                commonL1\
    \ = List(el1)\n                commonL2 = List(el2)\n            }\n         \
    \   else commonL1 = List(el1) :: commonL1\n            commonL2 = List(el2) ::\
    \ commonL2\n            i += 1\n        }\n        if (commonL1 == Nil && commonL2\
    \ == Nil) commonL1 = Nil\n        else if (commonL1 == Nil) commonL1 = Nil\n \
    \       else if (commonL2 == Nil) commonL2 = Nil\n        else commonL1", "  \
    \      // Set l1 to a new Set (O(n), n being the number of elements in l1)\n \
    \       val set1 = new mutable.HashSet[Long]()\n        // Loop through l1 and\
    \ add elements to set1.\n        l1.foreach { elem => set1 += elem }\n       \
    \ // Loop through l2 and add elements to set2.\n        l2.foreach { elem => set1\
    \ += elem }\n        // Return sorted unique elements from set1 & set2\n     \
    \   set1.toList ++ set2.toList", "        // Using Set and intersect to get unique\
    \ common elements\n        val set1 = Set[Long](l1)\n        val set2 = Set[Long](l2)\n\
    \        val common = set1.intersect(set2)\n        val list = l1.filterNot(common\
    \ contains _)\n        val list2 = l2.filterNot(common contains _)\n        if\
    \ (list2.nonEmpty) {\n            common\n        } else {\n            list\n\
    \        }", "        val set1 = l1.toSet\n        val set2 = l2.toSet\n     \
    \   if (set1.isEmpty) set2\n        else if (set2.isEmpty) set1\n        else\
    \ set1 intersect set2", '        l1 ++ l2 filterNot (x => l1 exists (y => y ==
    x))', '        l1 ++ l2 diff l1', "        val commonList = mutable.HashSet[Long]()\n\
    \        for(elm <- l1 ++ l2) {\n            commonList += elm\n        }\n  \
    \      commonList.sortWith((l1, l2) => l1 < l2)", '        l1 ++ l2 filter { x
    => l1 contains x } filter { x => l2 contains x }', '        l1 ++ l2.distinct
    -- l1.intersect(l2)', "        val a = new mutable.ArrayBuffer[Long]\n       \
    \ val b = new mutable.ArrayBuffer[Long]\n        for(x <- l1) a.add(x)\n     \
    \   for(x <- l2) b.add(x)\n        if(a.size == 0) b\n        else if(a.toSet.size\
    \ == b.toSet.size) a.toSet\n        else common(a, b.toSet)", "        val l3\
    \ = l1.flatMap(x => l2.filter(y => x != y))\n        val l4 = l3.distinct\n  \
    \      val l5 = l3.map(x => x + (l4.count(_ == x) * l4.count(_ == x) / 2)).toList\n\
    \        l5.sortWith(_.compareTo(_) == 0)", "        val l3 = (l1 ++ l2) filterNot\
    \ (l1 contains _)\n        l3.sort", '        (l1 ++ l2) groupBy (_ % l1.size)
    mapValues (_.toList)', "        // sort them and count them\n        val l3_sorted\
    \       = l1.sorted ++ l2.sorted\n        val l3_sorted_count = l3_sorted.distinct.length\n\
    \        // get the unique items and check their frequency\n        val l3_unique\
    \ = l3_sorted.distinct.filter( x => l3_sorted_count -- l2.count( y => x == y)\
    \ )\n        // sort the unique items and count them\n        val l3_unique_sorted\
    \ = l3_unique.sorted ++ l2.sorted\n        val l3_unique_sorted_count = l3_unique_sorted.distinct.length\n\
    \        // return the unique item\n        l3_unique_sorted", "        var ret\
    \ = new ListBuffer[Long]()\n        l1.foreach {\n            _ =>\n         \
    \       ret.append(l2.indexOf(_.toLong))\n        }\n        ret.distinct", " \
    \       // Solution begins here\n        val m1 = l1.length\n        val m2 =\
    \ l2.length\n        val u1 : List[Long] = List(1l)\n        val u2 : List[Long]\
    \ = List(1l)\n        var i : Int = 0\n        var j : Int = 0\n        var k\
    \ : Int = 0\n        var flag : Boolean = false\n        var z : List[Long] =\
    \ List()\n        var t : List[Long] = List()\n        while (i<m1 && j<m2) {\n\
    \            if (l1(i) == l2(j)) {\n                if (u1.length < m1) {\n  \
    \                  u1 += l1(i)\n                    i += 1\n                }\n\
    \                if (u2.length < m2) {\n                    u2 += l2(j)\n    \
    \                j += 1\n                }\n            } else {\n           \
    \     flag = true\n                while (flag) {\n                    k = 0\n\
    \                    flag = false\n                    while (k<m1 && !u1(k))\
    \ {\n                        k += 1\n                    }\n                 \
    \   while (k<m2 && !u2(k)) {\n                        k += 1\n               \
    \     }\n                    while (i<k && j<k) {\n                        if\
    \ (l1(i) == l2(j)) {\n                            if (u1.length < k) {\n     \
    \                           u1 += l1(i)\n                                i +=\
    \ 1\n                            }\n                            if (u2.length\
    \ < k) {\n                                u2 += l2(j)\n                      \
    \          j += 1\n                            }\n                        } else\
    \ {\n                            flag = true\n                        }\n    \
    \                }\n                    if (flag) {\n                        break\n\
    \                    }\n                }\n                if (flag) {\n     \
    \               break\n                }\n            }\n        }\n        if\
    \ (u1.length == m1 && u2.length == m2) {\n            u1\n        }\n        else\
    \ {\n            u2\n        }", "        val n1 = l1.toSet\n        val n2 =\
    \ l2.toSet\n        if(n1.size == 0 || n2.size == 0) Nil\n        else if(n1 &\
    \ n2) == n1 //if both are unique then return all element\n        else l1 ++ l2\
    \ map (_ + 0) sortBy (_ % l1(0)) map (_ / l1(0)) filter (_ == l1(0)) map {_ /\
    \ l1(0)} toList", "        val commonElements = l1 ++ l2\n        val uniqueCommonElements\
    \ = commonElements.distinct\n        uniqueCommonElements", "        // find common\
    \ elements\n        var common = l1\n        common = l2 diff common\n       \
    \ // remove repeated elements from common list\n        common = common.toSet.toList\n\
    \        // sort it\n        common.sort", "        val commonSet = l1 intersect\
    \ l2\n        commonSet.sorted", "        if (l1.isEmpty) l2\n        else if\
    \ (l2.isEmpty) l1\n        else if (l1.head == l2.head) common(l1.tail, l2.tail)\n\
    \        else {\n            val common = l1 diff l2\n            val temp = l1.tail.head\
    \ :: l2.tail.head\n            (common ++ temp)\n        }", "        var result\
    \ : List[Long] = Nil\n        val set1 :Set[Long] = l1.toSet\n        val set2\
    \ :Set[Long] = l2.toSet\n        val common = set1 intersect set2\n        result\
    \ = common match {\n            case Nil => result\n            case x :: xs =>\
    \ x :: common\n        }\n        result", "        var result : List[Long] =\
    \ Nil\n        var i = 0\n        var j = 0\n        while (i < l1.length && j\
    \ < l2.length) {\n            if (l1(j) == l2(l1.length - i - 1)) {\n        \
    \        result = result :+ l1(j)\n                j += 1\n            } else\
    \ if (l2(j) == l1(l2.length - i - 1)) {\n                result = result :+ l2(j)\n\
    \                i += 1\n            } else if (l1(j) < l2(j)) {\n           \
    \     i += 1\n            } else {\n                j += 1\n            }\n  \
    \      }\n        result", "        val set1 = l1.toSet \n        val set2 = l2.toSet\n\
    \        val commonSet = set1 -- set2\n        commonSet.map(l1.indexOf(_)).filter(x\
    \ => x != -1)", "        def merge(l1 : List[Long], l2 : List[Long], acc : List[Long])\
    \ : List[Long] = {\n          if (l1.length == 0) {\n            acc ::: l2\n\
    \          } else if (l2.length == 0) {\n            acc ::: l1\n          } else\
    \ {\n            val (a1, b1, c1) = (l1.head, l2.head, l1.length)\n          \
    \  merge(l1.tail, l2.tail, acc :+ a1)\n          }\n        }\n        val unique\
    \ = new mutable.HashSet[Long]\n        merge(l1, l2, unique.toList)\n        unique.toList",
  "        val (list1, list2) = l1 zip l2\n        val list = list1 diff list2\n \
    \       list map {case i => list1 find (x => x == i) } ++ list", "        val\
    \ list = new mutable.HashSet[Long]()\n        for (x1 <- l1) list.add(x1)\n  \
    \      for (x2 <- l2) list.add(x2)\n        list.sort", '        if (l1 == l2)
    l1 else l1.toSet intersect l2.toSet', "      val n1 = l1.size\n      val n2 =\
    \ l2.size\n\n      val (i,j) =  (0 to n2).iterator\n      val u : List[Long] =\
    \ new ListBuffer[Long]\n      val v : List[Long] = new ListBuffer[Long]\n\n  \
    \    while (i<=n1 && j<=n2) {\n        if (l1.get(i) == l2.get(j)) {\n       \
    \   u ++= l1.get(i).asInstanceOf[Long]\n          v ++= l2.get(j).asInstanceOf[Long]\n\
    \          i += 1\n          j += 1\n        } else { // swap them\n         \
    \ if (j == n2) {\n            j += 1\n          } else if (i == n1) {\n      \
    \      i += 1\n          } else { // swap them\n            if (l1.get(i) < l2.get(j))\
    \ {\n              u ++= l1.get(i).asInstanceOf[Long]\n              v ++= l2.get(j).asInstanceOf[Long]\n\
    \              i += 1\n            } else {\n              u ++= l2.get(j).asInstanceOf[Long]\n\
    \              v ++= l1.get(i).asInstanceOf[Long]\n              j += 1\n    \
    \        }\n          }\n        }\n      }\n      List(u.toList.sorted).distinct",
  "        val l1unique = l1.distinct\n        val l2unique = l2.distinct\n      \
    \  val common = l1unique.intersect(l2unique)\n        l1unique.filter(x => l2unique.contains(x)).toList\
    \ ++ common :: l2unique.filter(x => l1unique.contains(x)).toList", '      l1.filter(_
    => l2.contains(_)).sorted', "        val (a1, b1) = l1.partition(elem => l2.contains(elem))\n\
    \        val (a2, b2) = l2.partition(elem => l1.contains(elem))\n        (a1 +\
    \ a2) diff (b1 + b2)", "        val l = l1.toSet ++ l2.toSet\n        l.toList",
  "        // First sort both lists lexicographically \n        l1.sortWith(_ < _)\n\
    \        l2.sortWith(_ < _)\n        // Then, check if elements in both lists\
    \ are unique\n        // For each element, check if it is in both lists.\n   \
    \     // If yes, return it.\n        // If no, add it to an initially empty list.\n\
    \        var unique = List.empty[Long]\n        for (e <- l1) {\n            if\
    \ (l2.contains(e)) {\n                unique += e\n            }\n        }\n\
    \        // Finally, return the unique list.\n        unique", '        l1.zip(l2).filter(_._1
    == _._1).map { case (x, y) => y }', "        val (list1, list2) = (l1.toSet diff\
    \ l2.toSet).unzip\n        list1.flatMap{x1 => list2.map{x2 => if (x1 == x2) List(x1)\
    \ else List()}}.toList", "        var commonElements = l1.distinct\n        commonElements\
    \ = commonElements.intersect(l2.distinct)\n        commonElements", "        var\
    \ l3 = List.empty[Long]\n        var l4 = List.empty[Long]\n        l1 match {\n\
    \            case Nil => l2\n            case _ => {\n                for(i <-\
    \ 0 until l1.length) {\n                    if((l1.contains(i) && l2.contains(i)))\
    \ {\n                        l3 += l1(i)\n                        l4 += l2(i)\n\
    \                    }\n                }\n                val l5 = l3.intersect(l4)\n\
    \                val l6 = l3.filterNot(l4.contains)\n                l3.removeAll(l4)\n\
    \                l3.removeAll(l5)\n                l3.filterNot((l6.length > 0).and(l5.length\
    \ > 0))\n            }\n        }", "        val seen = mutable.Set[Long]()\n\
    \        l1 foreach { e => if (!seen.contains(e)) seen.add(e) }\n        l2 foreach\
    \ { e => if (!seen.contains(e)) seen.add(e) }\n        seen .toList filterNot\
    \ (l1.toSet ++ l2.toSet).toList", '        l1 ++ l2.filterNot(x => l1.contains(x)).toList.sorted',
  "        var l3 = l1\n        l2 foreach {\n            x =>\n            if (l3\
    \ contains x) l3 ::= x\n            else l3 = x\n        }\n        l3", "   \
    \     val sortedL1 = l1.sortBy(x => x)\n        val sortedL2 = l2.sortBy(x =>\
    \ x)\n        val commonElements = l1.filter(x => sortedL2.contains(x))\n    \
    \    commonElements", "        def getAllNonConsecutivePairsOfTwoLists(l : List[Long],\
    \ other : List[Long]) : List[(Long, Long)] = {\n            val newL : List[(Long,\
    \ Long)] = l.toList.sortBy(l => l)\n            val newOther : List[(Long, Long)]\
    \ = other.toList.sortBy(l => l)\n            val newL : mutable.List[(Long, Long)]\
    \ =  mutable.ListBuffer[(Long, Long)]()\n            val newOther : mutable.List[(Long,\
    \ Long)] =  mutable.ListBuffer[(Long, Long)]()\n            newL.reverse.zipWithIndex\
    \ foreach { case (left, leftIndex) =>\n                newOther.reverse.zipWithIndex\
    \ foreach { case (right, rightIndex) =>\n                    if (leftIndex !=\
    \ rightIndex) None\n                    else if (!(newL.last._1 == left && newOther.last._1\
    \ == right)) None\n                    else newL += ((left, right))\n        \
    \        }\n            }\n            newL.reverse\n            newOther.reverse\n\
    \        }\n        val allPairs = getAllNonConsecutivePairsOfTwoLists(l1, l2)\n\
    \        val uniquePairs : List[(Long, Long)] = allPairs.distinct\n        uniquePairs",
  "      val set1 =  l1.toSet\n      val set2 = l2.toSet\n      val intersection =\
    \ set1 intersect set2\n      val intersection2 = set1 intersect set2\n      val\
    \ result = new ListBuffer[Long]()\n      var i = 0\n      while(i < intersection.size\
    \ || i < intersection2.size) {\n        result += if (i < intersection.size) intersection(i)\
    \ else intersection2(i)\n        i += 1\n      }\n      result.toList", "    \
    \    val commonSet = new mutable.HashSet[Long]\n        l2.foreach(commonSet.add)\n\
    \        l1.foreach(commonSet.add)\n        commonSet.filter(_.nonEmpty)", " \
    \       val l3 = l1 ++ l2\n        l3.toList.sortWith(l => l1 < l)", '        l1
    ++ l2 diff (l2 intersect l1)', "        var a1 = l1\n        var a2 = l2\n   \
    \     var b1 = a1.toSet\n        var b2 = a2.toSet\n        var common = Set()\n\
    \        while(b1.nonEmpty || b2.nonEmpty) {\n            val t = b1.head\n  \
    \          b1 -= t\n            val tt = b2.head\n            b2 -= tt\n     \
    \       if(t.equals(tt)) {\n                common += t\n                a1 +=\
    \ tt\n                a2 += tt\n            }\n        }\n        if (b1.nonEmpty\
    \ || b2.nonEmpty) common.toList\n        else a1.toList ++ a2.toList", "     \
    \   if (l1 == null && l2 == null) List()\n        else if (l1 == null && l2 !=\
    \ null) List(l2(0)) \n        else if (l1 != null && l2 == null) List(l1(0)) \n\
    \        else \n            val unique1 = new HashSet[Long](l1)\n            val\
    \ unique2 = new HashSet[Long](l2)\n            val common = unique1 & unique2\n\
    \            if (common.isEmpty) List()\n            else List(common(0))", " \
    \       if (l1.isEmpty) l2\n        else {\n            val i = l1.head\n    \
    \        l2 match {\n                case x :: xs => if (x == i) common(l1.tail,\
    \ xs) else l1 ::: common(l1, xs)\n                case Nil => Nil\n          \
    \  }\n        }", "        var res : List[Long] = Nil\n        l1 foreach { x\
    \ =>\n            val i = l2 indexOf x\n            if (i == -1) res += x\n  \
    \          else {\n                if (l1.length == l2.length) {\n           \
    \         val tmp: List = l1.slice(i + 1, l1.length)\n                    res\
    \ += l1.slice(i + 1, l1.length).find(x => x == tmp(0))\n                } else\
    \ res += l1.slice(i + 1, l1.length - 1).find(x => x == l2(i - 1))\n          \
    \  }\n        }\n        res", "        val u1 = u(l1)\n        val u2 = u(l2)\n\
    \        val intersection = u1.intersect(u2)\n        intersection.sortBy(identity)",
  "        val (min1n, min1s) = l1.partition(_ < l1(0))\n        val (max1n, max1s)\
    \ = l1.partition(_ > l1(l1.length-1))\n        val (min2n, min2s) = l2.partition(_\
    \ < l2(0))\n        val (max2n, max2s) = l2.partition(_ > l2(l2.length-1))\n \
    \       (min1n zip max1n) diff (min2n zip max2n)", "        val set1 = new mutable.HashSet[Long]()\n\
    \        val set2 = new mutable.HashSet[Long]()\n        l1.foreach {\n      \
    \      x => set1 += x\n        }\n        l2.foreach {\n            x => set2\
    \ += x\n        }\n        set1.diff(set2)", "        var l : List[Long] = l1.toList\
    \ ++ l2.toList\n        l = l.toSet.toList", "        if (l1 == null || l2 ==\
    \ null) return null\n        if (l1 contains l2) return l1\n        var l1 = l1.sorted\
    \ \n        var l2 = l2.sorted \n        var result = new mutable.HashSet[Long]()\n\
    \        while (true) {\n            var next = (l1.head min l2.head) match {\n\
    \                case null => break\n                case n1 => if (n1 > n2) l1.remove(n1);\
    \ else l2.remove(n2)\n            }\n            result += next\n        }\n \
    \       result sorted", "        var commonElements : List[Long] = Nil\n     \
    \   if (l1.length >= l2.length) {\n            commonElements = l1.filter( _ ==\
    \ l2.head ).distinct\n        }\n        if (l1.length < l2.length) {\n      \
    \      commonElements = l2.filter( _ == l1.head ).distinct\n        }\n      \
    \  if (commonElements.length > 0) {\n            return commonElements\n     \
    \   }\n        else {\n            return common(l2, l1)\n        }", "      \
    \  l1 diff l2 map {\n            case elem => elem\n        }.toList", "     \
    \   def u(n1 : Long, n2 : Long, u : mutable.Set[Long] = mutable.Set()) : Boolean\
    \ = { if (n1 != n2) { if (u(n1, n2) && n1 < n2) u(n1, n2) else u(n2, n1) } else\
    \ true }\n        def u(n1 : Long, n2 : Long) : Boolean = { if (u(n1, n2)) u(n1,\
    \ n2) else false }\n        u(l1.head, l2.head).foreach(u(_, _))", '        l1.toSet
    intersect l2.toSet.toList', "        val u1 = new mutable.HashSet[Long]()\n  \
    \      val u2 = new mutable.HashSet[Long]()\n        for (i <- l1) {\n       \
    \     u1 += i\n        }\n        for (j <- l2) {\n            u2 += j\n     \
    \   }\n        if (u1.size == 0 || u2.size == 0)\n            return l1\n    \
    \    else if (u1 union u2 == u1)\n            return l1\n        else\n      \
    \      return l2", "        var commonElems1 : List[Long] = Nil\n        var commonElems2\
    \ : List[Long] = Nil\n        var j = 0\n        val n = l1.size\n        val\
    \ m = l2.size\n        while (j < n && j < m) {\n            if (l1(j) == l2(j))\
    \ {\n                commonElems1 ::= l1(j)\n                commonElems2 ::=\
    \ l2(j)\n                j += 1\n            }\n            else if (l1(j) < l2(j))\
    \ {\n                commonElems1 ::= l1(j)\n                j += 1\n        \
    \    }\n            else {\n                commonElems2 ::= l2(j)\n         \
    \       j += 1\n            }\n        }\n        commonElems1 ::= l1(j) :: commonElems1\n\
    \        commonElems2 ::= l2(j) :: commonElems2\n        commonElems1 sortBy (_\
    \ < _) reverse ::: commonElems2 sortBy (_ < _) reverse", "        var common =\
    \ mutable.HashSet[Long]()\n        l2.foreach{\n            c => common += c\n\
    \        }\n        l1.foreach{\n            c => common -= c\n        }\n   \
    \     common.sortWith(_.compareTo(_) < 0)", '        l1 ::: (l2 -- l1).distinct',
  '        l1.filter(_ == l2.head).distinct', "        val lim = Math.min(l1.length,\
    \ l2.length)\n        var li : Int = l1.length\n        var lj : Int = l2.length\n\
    \        var lc = 0\n        if (l1.length < l2.length) lc = 1\n        else lc\
    \ = -1\n        val res : List[Long] = new Array[Long](lim)\n        var i = 0\n\
    \        while (i < lim) {\n            val a = l1.apply(i).asInstanceOf[Long]\n\
    \            val b = l2.apply(i).asInstanceOf[Long]\n            if (a == b) res(i)\
    \ = a\n            else if (lc < 0) res(i) = b\n            else if ((a > b) ||\
    \ ((b < 0) && (a < 0))) res(i) = a\n            else if (lc > 0) res(i) = b\n\
    \            else {\n                val j : Int = i - 1\n                val\
    \ k : Int = i + 1\n                while (j >= 0 && k < lim && a.equals(l1.apply(j))\
    \ && b.equals(l2.apply(k))) {\n                    res(j)++res(k)\n          \
    \          j--; k++\n                }\n            }\n            i += 1\n  \
    \      }\n        res", "        val l3 = (l1, l2) match {\n            case (x\
    \ :: xs, _) => (x :: xs, x :: xs)\n            case (_ :: xs, y :: ys) => ys intersect\
    \ xs\n        }\n        l3.head", '        l1 ++ l2 filterNot (x => l1 contains
    x) -> l1 filter (x => l2 contains x) sortBy (_.hashCode)', "        val uList\
    \ = mutable.Set.empty[Long]\n        val vList = mutable.Set.empty[Long]\n\n \
    \       l1.foreach { elem => uList += elem }\n        l2.foreach { elem => vList\
    \ += elem }\n\n        uList intersect vList", "        val lis = mutable.ListBuffer.empty[Long]\n\
    \        val lis2 = mutable.ListBuffer.empty[Long]\n        l1 foreach { e =>\
    \ lis += e}\n        l2 foreach { e => lis2 += e}\n        lis.filter(e => lis2.contains(e)).sortWith((e1,\
    \ e2) => e1 compare e2)", "        // Store the unique items in one list.\n  \
    \      val unique = l1 diff l2\n\n        // Compare each item to other items\
    \ in l1 and l2.\n        unique foreach { element =>\n            val i1Match\
    \ = l1 find { x => x == element }\n            val i2Match = l2 find { x => x\
    \ == element }\n\n            // If either item is unique, add it to the list.\n\
    \            if (i1Match != null) unique += element\n            if (i2Match !=\
    \ null) unique += element\n        }\n\n        // Sort the list.\n        unique.sort",
  "        if (l1 == null || l2 == null) return null\n        if (l1.isEmpty) return\
    \ l2\n        if (l2.isEmpty) return l1\n        if (l1.head==l2.head) return\
    \ common(l1.tail, l2.tail)\n        common(l1, l2.tail)", "        var l3 = l1\
    \ ++ l2\n        l3.sortWith(Ordering[Long].reverse)\n        l3", "        //\
    \ The first list is the shorter, so we sort the list before comparing them.\n\
    \        val sortedL1 = l1.sortBy(l => l)\n        val sortedL2 = l2.sortBy(l\
    \ => l)\n        // Iterate through the first list and see if any of the elements\
    \ are in the second list.\n        var commonElems = sortedL1.iterator\n     \
    \   while (!commonElems.hasNext || commonElems.next.compareTo(sortedL2.next) <\
    \ 0) {\n            val elem = commonElems.next\n            if (!sortedL2.contains(elem))\n\
    \                commonElems = commonElems.next\n        }\n        // Now that\
    \ we have exhausted both lists, we know that any elements that are not in the\
    \ second list are in the first list.\n        commonElems.next.toList", "    \
    \    def f1(x : (Long, Long)) = x match {\n            case (x , y ) if x < y\
    \ => x\n            case (x , y ) => y\n            case _ => x\n        }\n \
    \       def f2(x : Long) = x match {\n            case x if x < 0 => x\n     \
    \       case x => 0\n        }\n        val l3 = l1 ++ l2\n        val ll = l3.sorted\n\
    \        ll.foldLeft((0 , ll)){\n            case (acc, x) => f1(acc) match {\n\
    \                case (acc, y) if acc > 0 && f2(acc) < f2(y) => acc :: f1(y)\n\
    \                case (acc, y) if acc > 0 && f2(acc) > f2(y) => acc :: y\n   \
    \             case (acc, y) => acc :: y\n            }\n        }.toList", " \
    \       val result = new ArrayList[Long]()\n        l1.foldLeft(result) { case\
    \ (acc, x) => if (l2.contains(x)) acc :+ x else acc }", '        l1 ++ l2 filterNot
    (l1.contains)', "        var c = 0\n        var l = l1.head \n        var u =\
    \ l2.head\n        var ret: List[Long] = Nil\n        while (l != Null && u !=\
    \ Null) {\n            if (l < u) {\n                c += 1\n                l\
    \ += l1.tail\n                u += l2.tail\n            }\n            else {\n\
    \                c += 1\n                l += l1.tail\n                u += l2.tail\n\
    \            }\n        }\n        ret :+ l1.head + l2.head - c", "        var\
    \ i : Int = 0\n        var j : Int = 0\n        var a : List[Long] = null\n  \
    \      var b : List[Long] = null\n        while(i < l1.length && j < l2.length)\
    \ {\n            if (l1.get(i) == l2.get(j))\n                a += l1.get(i)\n\
    \            else\n                b += l1.get(i)\n            i += 1\n      \
    \      j += 1\n        }\n        if (i == l1.length && j == l2.length)\n    \
    \        a\n        else\n            b", "        // This can be done more efficiently\
    \ by sorting both lists once, finding the\n        // intersection, and then sorting,\
    \ but this is more readable for demonstration.\n        val set1 = l1 diff l2\n\
    \        val set2 = l2 diff l1\n        val common = set1 intersect set2\n   \
    \     common.sort", "        val lc = l1.zip(l2).filter { case(a,b) => a == b}.map\
    \ { case(a,b) => a}.toList\n        lc.sort", "        var common = Set.empty[Long]\n\
    \        l1.foreach{\n            if (l2.contains(_))\n                common\
    \ += _\n        }\n        common.sorted() // Sorted for consistency.", "    \
    \    def isElementNotInList(l1 : List[Long], l2 : List[Long], element : Long)\
    \ : Boolean = {\n            if(!l1.contains(element))\n                return\
    \ false\n            if(!l2.contains(element))\n                return false\n\
    \            if(l1.size == 0)\n                return true\n            else\n\
    \                l2.size != 0\n        }\n        l1.toSet ++ l2.toSet filterNot\
    \ (e => isElementNotInList(l1, l2, e)).sort", "        l1 foreach { e =>\n   \
    \         l2 foreach { e2 =>\n                if  (e2 == e) yield e\n        \
    \    }\n        }\n        l1.toList", "        // The first list should be the\
    \ shortest.\n        if (l1.length < l2.length)\n            l2 ::: l1\n     \
    \   else\n            l1 ::: l2", "        var commonList = ListBuffer[Long]()\n\
    \        val set1 = l1.toSet\n        val set2 = l2.toSet\n        commonList\
    \ ++= set1 diff set2\n        set1 diff set2", "        val common = l1.toSet.intersect(l2.toSet)\n\
    \        val unique = l1.toSet.union(common)\n        unique.toList", "      \
    \  val hashSet = new mutable.HashSet[Long]\n        l2.foreach { x => hashSet.add(x);\
    \ hashSet.size }\n        l1.foreach { x => if (hashSet.contains(x)) hashSet.remove(x)\
    \ }\n        hashSet.toList", "        var list : List[Long] = Nil\n        for\
    \ (a1 <- l1 diff l2; a2 <- l2 diff l1; a <- List(a1, a2)) yield {\n          \
    \  if (list.length != 0) list = list ++ List(a)\n            else list = List(a)\n\
    \        }\n        list", "        l1.toStream.zip(l2.toStream)\n           \
    \     .collect { case ((x, y), z) if (x == y) => (x, y) }\n                .sortWith(_._1\
    \ > _._1)\n                .map(_._2)", "        val s1 = l1.sort\n        val\
    \ s2 = l2.sort\n        val s3 = ListBuffer.empty[Long]\n        val s4 = ListBuffer.empty[Long]\n\
    \        while (!s1.isEmpty) {\n            val a = s1.head\n            s3 +=\
    \ a\n            while (!s2.contains(a)) {\n                if (s1.head == s2.head)\
    \ {\n                    s4 += s1.head\n                    s2.remove(0)\n   \
    \             } else {\n                    s1.remove(0)\n                }\n\
    \            }\n        }\n        List((s3 diff s4).distinct)", "        //var\
    \ lst = List[Long]()\n        //var ltr = List[Long]()\n        var j = 0\n  \
    \      for((i, a) <- l1.zipWithIndex) yield {\n            var b = l2.subList(i,l2.length)\n\
    \            if(a ++ b == l2) j+=1\n            else if(a ++ b != l2) lst += a.toList\n\
    \            else if (a ++ b == l2) lst += b.toList\n            else ltr += a.toList\n\
    \        }\n        //if(lst.size != ltr.size) lst ++ ltr\n        //else ltr\n\
    \        ltr.toList", "        // Remove common elements.\n        // >>> common((List[Long](5l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong)), (List[Long](3l.toLong, 2l.toLong)))\n   \
    \     // (List[Long](2l.toLong, 3l.toLong))\n        val r = l1.toSet.intersect(l2.toSet)\n\
    \        r.reverse", "        val a1 = l1\n        val a2 = l2\n        val s\
    \ = a1.distinct.toList\n        val t = a2.distinct.toList\n        val c = s.intersect(t)\n\
    \        val list = new ListBuffer[Long]()\n        for (item <- a1) {\n     \
    \       list.+=item\n        }\n        for (item <- a2) {\n            list.+=item\n\
    \        }\n        list.filter((item) => list.contains(item))", "        def\
    \ loop(list1 : List[Long], list2 : List[Long], result : List[Long], cnt : Int)\
    \ : List[Long] = {\n            if (list1.isEmpty) {\n                result ++\
    \ list2\n            } else if (list2.isEmpty) {\n                result ++ list1\n\
    \            } else if (list1.head._1 == list2.head._1) {\n                result\
    \ ++ loop(list1.tail, list2.tail, result :+ list1.head._1, cnt + 1)\n        \
    \    } else if (list1.head._1 > list2.head._1) {\n                loop(list1,\
    \ list2.tail, result :+ list2.head._1, cnt + 1)\n            } else {\n      \
    \          loop(list1.tail, list2, result :+ list1.head._1, cnt + 1)\n       \
    \     }\n        }\n        loop(l1, l2, Nil, 0)", "        val c1 = l1.toSet\n\
    \        val c2 = l2.toSet\n        c1 intersect c2", "        val l3 = l1 ++\
    \ l2\n        val l4 = l3.groupBy(x => x).mapValues(_.length).toList.sortBy(-_._2)\n\
    \        val l5 = l4.map(_._1).distinct\n        l5", "        def common(acc\
    \ : List[Long], l2 : List[Long]) : List[Long] = {\n            val l1 = acc.toList\n\
    \            val l2 = l2.toList\n            val common = l1 diff l2\n       \
    \     if (common.isEmpty)\n                acc\n            else\n           \
    \     common(common ::: acc, l2)\n        }\n        common(List(), l2)", '      l1
    diff l2', "        val set1 = new HashSet[Long]()\n        val set2 = new HashSet[Long]()\n\
    \n        l2.foreach((x) => set1 += x)\n        l1.foreach((x) => set2 += x)\n\
    \n        set1.toList ++ set2.toList", "        val (l1, l2) = l1 ++ l2.sortBy(_.hashCode)\n\
    \        val l = l1.toSet + l2.toSet\n        l.toList.sortBy(_.hashCode)", '        l1
    diff l2 filterNot (_ => l1.contains(l2))', "        // Create two mutable sets\
    \ to hold sorted unique elements.\n        // This requires O(nlogn) time and\
    \ O(n) extra space.\n        val s1 = new mutable.TreeSet[Long]\n        val s2\
    \ = new mutable.TreeSet[Long]\n        l2.foreach { x => s1.add(x.toLong); s2.add(x)\
    \ }\n        l1.foreach { x => if (!s2.contains(x.toLong)) s2.add(x); s1.remove(x)\
    \ }\n        s2.toList.sort", "        var set = new mutable.HashSet[Long]()\n\
    \        set.add(l1(0))\n        set.add(l1(1))\n        set.add(l2(1))\n    \
    \    set.add(l2(0))\n        set.filter{ elem => l1.contains(elem) && l2.contains(elem)\
    \ }.toList", "        var l3 = mutable.Set[Long]()\n        l2.foreach(l1 => l3\
    \ = l3 + (l1 :: l3))\n        l3.toList", "        val set1 = Set[Long]()\n  \
    \      val set2 = Set[Long]()\n        l1 foreach { x => set1 += x }\n       \
    \ l2 foreach { x => set2 += x }\n        set1 intersect set2", "        var list1\
    \ = l1\n        var list2 = l2\n        var commonList = scala.collection.mutable.ListBuffer.empty[Long]\n\
    \        var count1 = list1.size\n        var count2 = list2.size\n        while\
    \ ( count1 > 0 && count2 > 0) {\n            var smallest = ( list1.min() < (list2.min()\
    \ ))\n            if( smallest != commonList.contains(smallest)) {\n         \
    \       commonList += smallest\n                list1 -= smallest\n          \
    \      count1 -= 1\n                list2 -= smallest\n                count2\
    \ -= 1\n            } else {\n                smallest = ( list2.min() < (list1.min()\
    \ ))\n                if( smallest != commonList.contains(smallest)) {\n     \
    \               commonList += smallest\n                    list2 -= smallest\n\
    \                    count2 -= 1\n                } else {\n                 \
    \   smallest = ( list1.min() < (list2.min() ))\n                    if( smallest\
    \ != commonList.contains(smallest)) {\n                        commonList += smallest\n\
    \                        list1 -= smallest\n                        count1 -=\
    \ 1\n                    }\n                }\n            }\n        }\n    \
    \    commonList ++ list1 ++ list2", "        var result : List[Long] = Nil\n \
    \       val list1 = l1 sortBy (_ => 1) //sort ascending\n        val list2 = l2\
    \ sortBy (_ => 1) //sort ascending\n        var i = 0\n        while (i < list1.length\
    \ && i < list2.length) {\n            if (list1(i) == list2(i)) {\n          \
    \      result += list1(i)\n                i += 1\n            } else if (list1(i)\
    \ < list2(i)) {\n                i += 1\n            } else {\n              \
    \  i += 1\n            }\n        }\n        while ((i < list1.length) || (i <\
    \ list2.length)) {\n            if (list1.length <= i) {\n                break\n\
    \            }\n            if (list2.length <= i) {\n                break\n\
    \            }\n            if (list1(i) > list2(i)) {\n                result\
    \ += list1(i)\n                i += 1\n            } else {\n                i\
    \ += 1\n            }\n        }\n        result", "        def getCommon(l1 :\
    \ List[Long], l2 : List[Long]) : List[Long] = l1 ++ l2 filterNot {\n         \
    \   case nd if l2.contains(nd) => false\n            case nd => true\n       \
    \ }\n        val li1 =  l1 toList toSeq\n        val li2 =  l2 toList toSeq\n\
    \        li1 ++ li2 filterNot {\n            case nd if li1.contains(nd) => false\n\
    \            case nd => true\n        }", "        var unique1 = l1.toSet\n  \
    \      var unique2 = l2.toSet\n        unique1 -- unique2", "        if (l1 ==\
    \ null || l2 == null) {\n            Nil\n        }\n        else {\n        \
    \    val set1 : mutable.Set[Long] = mutable.Set.empty[Long]\n            val set2\
    \ : mutable.Set[Long] = mutable.Set.empty[Long]\n\n            l1.foreach(x =>\
    \ set1 += x)\n\n            l2.foreach(x => set2 += x)\n\n            set1 diff\
    \ set2\n        }"]
stop_tokens:
- "\n    }\n"
