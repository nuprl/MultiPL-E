language: scala
name: HumanEval_109_move_one_ball
results:
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val size = arr.size\n\
    \        val sortedList = arr.sortWith(_.compare(arr(0)))\n        val shiftedList\
    \ = new mutable.ArrayList[Long]()\n        for(i <- 1 to size) {\n           \
    \ shiftedList.add(0, arr(i))\n        }\n        val shiftCount = sortedList.size\
    \ - size - 1\n        val shift = shiftCount % size\n        if (shiftCount ==\
    \ 0 || shiftCount == size) {\n            if (sortedList.equals(shiftedList))\
    \ {\n                return true\n            }\n            else {\n        \
    \        return false\n            }\n        }\n        val newSortedList = mutable.ArrayList[Long]()\n\
    \        for(i <- 1 to size) {\n            newSortedList.add(shiftedList(i).asInstanceOf[Long])\n\
    \        }\n        val newSortedListSize = newSortedList.size\n        val newShift\
    \ = newSortedListSize % size\n        if (newSortedListSize == 0 || newSortedListSize\
    \ == size || newShift > 0 ) {\n            moveOneBall(newSortedList.asInstanceOf[List[Long]])\n\
    \        }\n        else {\n            moveOneBall(newSortedList.asInstanceOf[List[Long]].init.reverse)\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E086] Syntax Error: /tmp/tmpr13ruxpx.scala:27:38 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36msortedList\e[0m = arr.sortWith(_.compare(arr(\e\
    [31m0\e[0m)))\n\e[31m\e[31m   |\e[0m                                      ^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                 Wrong number of parameters,\
    \ expected: 2\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpr13ruxpx.scala:28:30\
    \ ------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e\
    [36mshiftedList\e[0m = \e[33mnew\e[0m mutable.ArrayList[\e[35mLong\e[0m]()\n\e\
    [31m\e[31m   |\e[0m                              ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                              Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpr13ruxpx.scala:42:28 ------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m        \e[33mval\e[0m \e[36mnewSortedList\e[0m = mutable.ArrayList[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                            ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                            Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1660009764
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val len = arr.length\n\
    \        val maxLen = len\n        val arr2 = arr.map(_ % maxLen).toArray\n  \
    \      var arr3 = Array.empty[Long]\n        var j = 0\n        while (j != maxLen\
    \ - 1) {\n            arr3 = arr2 ++ arr3\n            j += 1\n        }\n   \
    \     arr3 ++ arr2.toList\n        arr.toList.sorted.toList == arr3.toList\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpgd4wudj5.scala:39)\n\tat Problem.main(tmpgd4wudj5.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009770
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        require(arr.length\
    \ == arr.distinct.length)\n        require(arr.forall(elem => elem > 0))\n   \
    \     require(arr.forall(elem => !arr.contains(elem - 1)))\n        // Use a recursive\
    \ function to solve the problem. \n        // Keep track of which elements have\
    \ been accessed and which not. \n        // If the element has not yet been accessed,\
    \ return the element as the answer. \n        // If the element has been accessed\
    \ then check if there are any elements left. \n        // If there are elements\
    \ left, call the function recursively with the remaining elements.\n        val\
    \ accessed: mutable.Set[Long] = mutable.Set.empty[Long]\n        val accessedButNotSoFar:\
    \ mutable.Set[Long] = mutable.Set.empty[Long]\n        val notSoFar: mutable.Set[Long]\
    \ = mutable.Set.empty[Long]\n        def recurse(a: mutable.Set[Long], b : mutable.Set[Long],\
    \ c : mutable.Set[Long]): Boolean = {\n            a += b(0)\n            c +=\
    \ b(0)\n            val l = arr.filter(_ != b(0))\n            if (a.isEmpty ||\
    \ c.isEmpty) {\n                true\n            } else {\n                val\
    \ notA = notSoFar.filter(_ != b(0))\n                val notC = notSoFar.filter(_\
    \ != b(0))\n                if (l.isEmpty && notA.isEmpty && notC.isEmpty) {\n\
    \                    true\n                } else {\n                    if (a.isEmpty\
    \ && notA.isEmpty) {\n                        false\n                    } else\
    \ if (c.isEmpty && notC.isEmpty) {\n                        false\n          \
    \          } else {\n                        recurse(a, notA, notC)\n        \
    \            }\n                }\n            }\n        }\n        recurse(accessed,\
    \ accessedButNotSoFar, notSoFar)\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp2xh9jiko.scala:34:22 ------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36maccessed\e[0m: mutable.Set[\e\
    [35mLong\e[0m] = mutable.Set.empty[\e[35mLong\e[0m]\n\e[31m\e[31m   |\e[0m   \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                      Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp2xh9jiko.scala:34:42\
    \ ------------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e\
    [36maccessed\e[0m: mutable.Set[\e[35mLong\e[0m] = mutable.Set.empty[\e[35mLong\e\
    [0m]\n\e[31m\e[31m   |\e[0m                                          ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                          Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp2xh9jiko.scala:35:33\
    \ ------------------------\e[0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e\
    [36maccessedButNotSoFar\e[0m: mutable.Set[\e[35mLong\e[0m] = mutable.Set.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                                 ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                 Not found: mutable\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp2xh9jiko.scala:35:53 ------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e[36maccessedButNotSoFar\e[0m:\
    \ mutable.Set[\e[35mLong\e[0m] = mutable.Set.empty[\e[35mLong\e[0m]\n\e[31m\e\
    [31m   |\e[0m                                                     ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp2xh9jiko.scala:36:22\
    \ ------------------------\e[0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e\
    [36mnotSoFar\e[0m: mutable.Set[\e[35mLong\e[0m] = mutable.Set.empty[\e[35mLong\e\
    [0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31"
  stdout: ''
  timestamp: 1660009764
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val counts = mutable.HashMap[Long,\
    \ Int]()\n        for (el <- arr) {\n            counts.put(el, 1)\n        }\n\
    \        var i = 0\n        val max = (arr.size << 1) >> 1\n        while (i <\
    \ max) {\n            // If an element with value i is found in the counts map,\
    \ then we can\n            // safely remove it from the counts map.\n        \
    \    if (counts.contains(i)) {\n                val count = counts(i)\n      \
    \          counts.remove(count)\n                count -= 1\n                if\
    \ (count == 0) return true\n            }\n            i += 1\n        }\n   \
    \     return false\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpgx15c_gb.scala:26:21 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mcounts\e[0m = mutable.HashMap[\e\
    [35mLong\e[0m, \e[35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660009764
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        // Initialize a\
    \ list to store the original list elements.\n        var list = arr.toList\n \
    \       // Iterate through original list to perform right shift operation on each\n\
    \        // element.\n        for (i<- 0 until list.length)\n            // Perform\
    \ right shift operation on the current element.\n            (list ::= (list :::)).headOption\
    \ match {\n                // If the number of right shift operations performed\
    \ on the\n                // current element is equal to the original list length\
    \ then\n                // return true else return false.\n                case\
    \ None => false\n                case Some(x) =>\n                    val right\
    \ = list.size - i\n                    // Perform n right shift operations on\
    \ the current element.\n                    (list ::= (list :::)).tailOption match\
    \ {\n                        // If number of right shift operations on the current\
    \ element\n                        // is equal to the original list length then\
    \ return false else return true.\n                        case None => false\n\
    \                        case Some(x) =>\n                            val n =\
    \ right - x\n                            // Perform n-1 right shift operations.\n\
    \                            (list ::= (list :::)).tailOption match {\n      \
    \                          // If number of right shift operations on the current\
    \ element\n                                // is equal to the original list length\
    \ then return false else return true.\n                                case None\
    \ => false\n                                case Some(x) =>\n                \
    \                    val n1 = right - x\n                                    //\
    \ Perform n-2 right shift operations.\n                                    (list\
    \ ::= (list :::)).tailOption match {\n                                       \
    \ // If number of right shift operations on the current element\n            \
    \                            // is equal to the original list length then return\
    \ false else return true.\n                                        case None =>\
    \ false\n                                        case Some(x) =>\n           \
    \                                 val n2 = right - x\n                       \
    \                     // Perform n-1 right shift operations.\n               \
    \                             (list ::= (list :::)).tailOption match {\n     \
    \                                           case None => false\n             \
    \                                   case Some(x) =>\n                        \
    \                            val n3 = right - x\n                            \
    \                        // Perform n-2 right shift operations.\n            \
    \                                        (list ::= (list :::)).tailOption match\
    \ {\n                                                        // If number of right\
    \ shift operations on the current element\n                                  \
    \                      // is equal to the original list length then return false\
    \ else return true.\n                                                        case\
    \ None => false\n                                                        case\
    \ Some(x) =>\n                                                            val\
    \ n4 = right - x\n                                                           \
    \ // Perform n-1 right shift operations.\n                                   \
    \                         (list ::= (list :::)).tailOption match {\n         \
    \                                                       // If number of right\
    \ shift operations on the current element\n                                  \
    \                              // is equal to the original list length then return\
    \ false else return true.\n                                                  \
    \              case None => false\n                                          \
    \                      case Some(x) =>\n                                     \
    \                               val n5 = right - x\n                         \
    \                                           // Perform n-2 right shift \n    }\n\
    \    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmplwvz1skl.scala:32:31 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m            (list ::= (list :::)).headOption \e[33mmatch\e\
    [0m {\n\e[31m\e[31m   |\e[0m                               ^\e[0m\n\e[31m   |\e\
    [0m                               expression expected but \e[31m')'\e[0m found\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmplwvz1skl.scala:40:39\
    \ ---------------------------\e[0m\e[0m\n\e[31m40 |\e[0m                    (list\
    \ ::= (list :::)).tailOption \e[33mmatch\e[0m {\n\e[31m\e[31m   |\e[0m       \
    \                                ^\e[0m\n\e[31m   |\e[0m                     \
    \                  expression expected but \e[31m')'\e[0m found\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E018] Syntax Error: /tmp/tmplwvz1skl.scala:47:47 ---------------------------\e\
    [0m\e[0m\n\e[31m47 |\e[0m                            (list ::= (list :::)).tailOption\
    \ \e[33mmatch\e[0m {\n\e[31m\e[31m   |\e[0m                                  \
    \             ^\e[0m\n\e[31m   |\e[0m                                       expression\
    \ expected but \e[31m')'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmplwvz1skl.scala:54:55 ---------------------------\e[0m\e[0m\n\e[31m54\
    \ |\e[0m                                    (list ::= (list :::)).tailOption \e\
    [33mmatch\e[0m {\n\e[31m\e[31m   |\e[0m                                      \
    \                 ^\e[0m\n\e[31m   |\e[0m                                    \
    \   expression expected but \e[31m')'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E018] Syntax Error: /tmp/tmplwvz1skl.scala:61:63 ---------------------------\e\
    [0m\e[0m\n\e[31m61 |\e[0m                                            (list ::=\
    \ (list :::)).tailOption \e[33mmatch\e[0m {\n\e[31m\e[31m   |\e[0m           \
    \                                                    ^\e[0m\n\e[31m   |\e[0m \
    \     "
  stdout: ''
  timestamp: 1660009770
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        if(arr.isEmpty)\n\
    \            return true\n        var left = 0\n        var right = arr.length\
    \ - 1\n        var flag = true\n        while(left < right){\n            while(left\
    \ < right && arr(left) < arr(left+1))\n                left+=1\n            while(left\
    \ < right && arr(right) > arr(left))\n                right-=1\n            if((left\
    \ < right) && !(left == right && arr(left) >= arr(right))){\n                arr.swap(left,right)\n\
    \                left+=1\n                right-=1\n            } else{\n    \
    \            flag = false\n                right+=1\n                left-=1\n\
    \            }\n        }\n        arr(0) = 0\n        return flag\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp3ydvfc6e.scala:37:20 ------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m                arr.swap(left,right)\n\e[31m\e[31m  \
    \ |\e[0m                ^^^^^^^^\e[0m\n\e[31m   |\e[0m        value swap is not\
    \ a member of List[Long] - did you mean arr.map?\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmp3ydvfc6e.scala:46:8 -------------------------\e[0m\e[0m\n\e[31m46\
    \ |\e[0m        arr(\e[31m0\e[0m) = \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m      \
    \  ^^^\e[0m\n\e[31m   |\e[0m  value update is not a member of List[Long] - did\
    \ you mean arr.updated?\n2 errors found\n"
  stdout: ''
  timestamp: 1660009769
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        if (arr.isEmpty)\
    \ true\n        else {\n            var newList = arr.toList\n            var\
    \ index = 0\n            val len = newList.length\n            var i = 0\n   \
    \         var found = false\n\n            while (i < len) {\n               \
    \ var found = false\n\n                while (i < len && arr(i) <= newList(i))\
    \ {\n                    newList(i) = newList(i) + 1\n                    i +=\
    \ 1\n                    found = true\n                }\n\n                if\
    \ (!found)\n                    break\n            }\n\n            val isSorted\
    \ = newList == arr.toList\n            if (isSorted)\n                true\n \
    \           else\n                moveOneBall(newList)\n        }\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp5yi3grm0.scala:38:20 ------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m                    newList(i) = newList(i) + \e[31m1\e\
    [0m\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ update is not a member of List[Long] - did you mean List[Long].updated?\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmp5yi3grm0.scala:44:20 ------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m                    break\n\e[31m\e[31m   |\e[0m    \
    \                ^^^^^\e[0m\n\e[31m   |\e[0m                    Not found: break\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660009767
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        if(arr.isEmpty)\
    \ {\n            true\n        } else {\n            var last = 0L\n         \
    \   var first = 0L\n            var found = false\n            var result = true\n\
    \            var list: mutable.WrappedArray[Long] = arr.toList\n            while(!found)\
    \ {\n                last = (last + list(0)) % arr.length\n                first\
    \ = first\n                val temp = list.drop(1)\n                list.drop(1).push(last)\n\
    \                list.prepend(first)\n                if(list.last > list(0))\n\
    \                    found = true\n            }\n            result\n       \
    \ }\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpfqob1p7m.scala:33:22 ------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m            \e[33mvar\e[0m \e[36mlist\e[0m: mutable.WrappedArray[\e\
    [35mLong\e[0m] = arr.toList\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660009764
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        if (arr.isEmpty)\n\
    \            return true\n        var arrIndex = -1\n        var lastIndex = arr.length\
    \ - 1\n        var index = 0\n        while (arrIndex != lastIndex) {\n      \
    \      if (arr[arrIndex] < arr[lastIndex]) {\n                lastIndex = arrIndex\n\
    \            } else {\n                arrIndex += 1\n            }\n        }\n\
    \        arrIndex = lastIndex\n        var count = 0\n        while (arrIndex\
    \ != 0) {\n            if (arr[arrIndex] < arr[arrIndex - 1]) {\n            \
    \    arrIndex -= 1\n            } else {\n                count += 1\n       \
    \     }\n        }\n        if (count == 0)\n            return true\n       \
    \ val temp = arr\n        temp.zipWithIndex.foreach { case (elem, index) =>\n\
    \            if (index == arrIndex - 1) {\n                arr.update(index, (elem\
    \ + temp(arrIndex + 1)).asInstanceOf[Long])\n            }\n        }\n      \
    \  return arr.forall(elem => elem == 0)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmptqvyirkh.scala:32:20 ------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m            \e[33mif\e[0m (arr[\e[35marrIndex\e[0m] <\
    \ arr[\e[35mlastIndex\e[0m]) {\n\e[31m\e[31m   |\e[0m                    ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                    Not found: type arrIndex\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmptqvyirkh.scala:41:20 ------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m            \e[33mif\e[0m (arr[\e[35marrIndex\e[0m] <\
    \ arr[\e[35marrIndex\e[0m \e[35m-\e[0m \e[31m1\e[0m]) {\n\e[31m\e[31m   |\e[0m\
    \                    ^^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ type arrIndex\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmptqvyirkh.scala:52:20\
    \ ------------------------\e[0m\e[0m\n\e[31m52 |\e[0m                arr.update(index,\
    \ (elem + temp(arrIndex + \e[31m1\e[0m)).asInstanceOf[\e[35mLong\e[0m])\n\e[31m\e\
    [31m   |\e[0m                ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  value update is\
    \ not a member of List[Long] - did you mean arr.updated?\n3 errors found\n"
  stdout: ''
  timestamp: 1660009768
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        def find(index :\
    \ Long, arr : List[Long]) : Boolean = arr(index) match {\n            case 1l\
    \ => index == 0\n            case 2l => find(index - 1, arr)\n            case\
    \ 3l => find(index - 2, arr) && find(index - 1, arr)\n            case _ => false\n\
    \        }\n        def findAndShift(index : Long, arr : List[Long]) : Boolean\
    \ = arr(index) match {\n            case 1l => index == 0\n            case 2l\
    \ => findAndShift(index - 1, arr)\n            case 3l => {\n                val\
    \ temp = arr(index - 1)\n                arr(index - 1) = arr(index)\n       \
    \         arr(index) = temp\n                index\n            }\n          \
    \  case _ => false\n        }\n        if (arr.isEmpty) true\n        else {\n\
    \            val length = arr.size\n            val index = length - 1\n     \
    \       if (find(index, arr)) true\n            else findAndShift(index, arr)\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpblqbjwrn.scala:26:65\
    \ --------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mdef\e[0m \e[36mfind\e\
    [0m(\e[36mindex\e[0m : \e[35mLong\e[0m, \e[36marr\e[0m : \e[35mList\e[0m[\e[35mLong\e\
    [0m]) : \e[35mBoolean\e[0m = arr(index) \e[33mmatch\e[0m {\n\e[31m\e[31m   |\e\
    [0m                                                                 ^^^^^\e[0m\n\
    \e[31m   |\e[0m                                                Found:    (index\
    \ : Long)\n\e[31m   |\e[0m                                                Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpblqbjwrn.scala:32:73\
    \ --------------------\e[0m\e[0m\n\e[31m32 |\e[0m        \e[33mdef\e[0m \e[36mfindAndShift\e\
    [0m(\e[36mindex\e[0m : \e[35mLong\e[0m, \e[36marr\e[0m : \e[35mList\e[0m[\e[35mLong\e\
    [0m]) : \e[35mBoolean\e[0m = arr(index) \e[33mmatch\e[0m {\n\e[31m\e[31m   |\e\
    [0m                                                                         ^^^^^\e\
    [0m\n\e[31m   |\e[0m                                                Found:   \
    \ (index : Long)\n\e[31m   |\e[0m                                            \
    \    Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpblqbjwrn.scala:36:31\
    \ --------------------\e[0m\e[0m\n\e[31m36 |\e[0m                \e[33mval\e[0m\
    \ \e[36mtemp\e[0m = arr(index - \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m         \
    \                      ^^^^^^^^^\e[0m\n\e[31m   |\e[0m                       \
    \        Found:    Long\n\e[31m   |\e[0m                               Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpblqbjwrn.scala:37:16\
    \ ------------------------\e[0m\e[0m\n\e[31m37 |\e[0m                arr(index\
    \ - \e[31m1\e[0m) = arr(index)\n\e[31m\e[31m   |\e[0m                ^^^\e[0m\n\
    \e[31m   |\e[0m  value update is not a member of List[Long] - did you mean arr.updated?\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpblqbjwrn.sc"
  stdout: ''
  timestamp: 1660009769
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val s = arr.head\
    \ + arr.last\n        val l = arr.last\n        val r = arr.head\n        val\
    \ r = arr.last\n        val l = arr.head\n        val r = arr.last\n        val\
    \ r = arr.head\n        val l = arr.last\n        val l = arr.last\n        val\
    \ r = arr.head\n        val r = arr.last\n        val l = arr.head\n        val\
    \ l = arr.last\n        val r = arr.head\n        val r = arr.last\n        val\
    \ l = arr.head\n        val l = arr.last\n        val l = arr.head\n        val\
    \ l = arr.last\n        val r = arr.head\n        val r = arr.last\n        val\
    \ r = arr.head\n        val r = arr.last\n        val l = arr.head\n        val\
    \ r = arr.last\n        val l = arr.head\n        val l = arr.last\n        val\
    \ r = arr.head\n        val r = arr.last\n        val r = arr.head\n        val\
    \ r = arr.last\n        val l = arr.head\n        val l = arr.last\n        val\
    \ l = arr.head\n        val r = arr.last\n        val l = arr.head\n        val\
    \ r = arr.last\n        val r = arr.head\n        val r = arr.last\n        val\
    \ r = arr.head\n        val r = arr.last\n        val l = arr.head\n        val\
    \ l = arr.last\n        val l = arr.head\n        val r = arr.last\n        val\
    \ r = arr.head\n        val r = arr.last\n        val r = arr.head\n        val\
    \ r = arr.last\n        val r = arr.head\n        val r = arr.last\n        val\
    \ r = arr.head\n        val r = arr.last\n        val r = arr.head\n        val\
    \ r = arr.last\n        val r = arr.head\n        val r = arr.last\n        val\
    \ r = arr.head\n        val r = arr.last\n        val r = arr.head\n        val\
    \ r = arr.last\n        val r = arr.head\n        val r = arr.last\n        val\
    \ r = arr.head\n        val r = arr.last\n        val r = arr.head\n        val\
    \ r = arr.last\n        val r = arr.head\n        val r = arr.last\n        val\
    \ r = arr.head\n        val r = arr.last\n        val r = arr.head\n        val\
    \ r = arr.last\n        val r = arr.head\n        val r = arr.last\n        val\
    \ r = arr.head\n        val r = arr.last\n        val r = arr.head\n        val\
    \ r = arr.last\n        val r = arr.head\n        val r = arr.last\n        val\
    \ r = arr.head\n        val r = arr.last\n        val r = arr.head\n        val\
    \ r = arr.last\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpd562c3el.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = arr.last\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mr is already defined\
    \ as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpd562c3el.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36ml\e[0m = arr.head\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0ml is already defined\
    \ as \e[33mvalue\e[0m \e[35ml\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpd562c3el.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = arr.last\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mr is already defined\
    \ as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpd562c3el.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = arr.head\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mr is already defined\
    \ as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpd562c3el.scala:33:12 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36ml\e[0m = arr.last\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0ml is already defined\
    \ as \e[33mvalue\e[0m \e[35ml\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpd562c3el.scala:34:12 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m "
  stdout: ''
  timestamp: 1660009767
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        if(arr.isEmpty)\
    \ {\n            return true\n        }\n\n        var shiftCount = 0\n\n    \
    \    for(i <- arr.indices) {\n            val tempArr = arr\n            tempArr(i)\
    \ = tempArr(i) - 1\n            if(moveOneBall(tempArr)) {\n                shiftCount\
    \ += 1\n            }\n        }\n\n        return shiftCount <= 1\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp8pb9vpp4.scala:34:12 ------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m            tempArr(i) = tempArr(i) - \e[31m1\e[0m\n\e\
    [31m\e[31m   |\e[0m            ^^^^^^^\e[0m\n\e[31m   |\e[0mvalue update is not\
    \ a member of List[Long] - did you mean tempArr.updated?\n1 error found\n"
  stdout: ''
  timestamp: 1660009767
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.length\n\
    \        var i = n-1\n        var j = n-1\n        var k = 0\n        var flag\
    \ = true\n        while(i < j)\n        {\n            k = i\n            j =\
    \ k-1\n            while(arr(k) == arr(k-1))\n            {\n                k\
    \ = k-1\n            }\n            i = k+1\n            if(k > 0)\n         \
    \   {\n                val temp = arr(i)\n                arr(i) = arr(j)\n  \
    \              arr(j) = temp\n                k = k-1\n            }\n       \
    \     else\n            {\n                flag = false\n                break\n\
    \            }\n        }\n        return flag\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpi3lvfuwq.scala:43:16 ------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m                arr(i) = arr(j)\n\e[31m\e[31m   |\e[0m\
    \                ^^^\e[0m\n\e[31m   |\e[0m  value update is not a member of List[Long]\
    \ - did you mean arr.updated?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpi3lvfuwq.scala:44:16\
    \ ------------------------\e[0m\e[0m\n\e[31m44 |\e[0m                arr(j) =\
    \ temp\n\e[31m\e[31m   |\e[0m                ^^^\e[0m\n\e[31m   |\e[0m  value\
    \ update is not a member of List[Long] - did you mean arr.updated?\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpi3lvfuwq.scala:50:16 ------------------------\e\
    [0m\e[0m\n\e[31m50 |\e[0m                break\n\e[31m\e[31m   |\e[0m        \
    \        ^^^^^\e[0m\n\e[31m   |\e[0m                Not found: break\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1660009769
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        if(arr.isEmpty)\
    \ {\n            true\n        } else {\n            val arr = arr.toArray\n \
    \           val len = arr.length\n            val result = new Array[Long](len)\n\
    \            var i = 0\n            for(j <- 0 until len) {\n                //\
    \ shift the array to the right\n                val right = arr.length - 1 - j\n\
    \                val left = j\n                val right = right + i\n       \
    \         // shift value at left to the right\n                for(k <- left to\
    \ right) {\n                    result(k) = arr(k)\n                }\n      \
    \          // shift the value at right to left\n                for(k <- right\
    \ to left) {\n                    result(k) = arr(k)\n                }\n    \
    \            i += 1\n            }\n            true\n        }\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpbxlk52lg.scala:29:22 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m            \e[33mval\e[0m \e[36marr\e[0m = arr.toArray\n\
    \e[31m\e[31m   |\e[0m                      ^\e[0m\n\e[31m   |\e[0m           \
    \           Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660009764
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        if(arr.length ==\
    \ 0) return true\n        val newList: mutable.MutableList[Long] = arr.toMutableList\n\
    \        val startIndex = newList.size + 1\n        val endIndex = startIndex\
    \ - 1\n        newList.add(0)\n        var i = 0\n        while(i < endIndex)\
    \ {\n            val left = newList.get(i)\n            val right = newList.get(i\
    \ + 1)\n            if(right < left) \n                newList.set(i, right)\n\
    \            else\n                newList.set(i, left)\n            newList.set(i\
    \ + 1, 0)\n            i +=1\n        }\n        if(newList.size == arr.size)\n\
    \            return true\n        else\n            return false\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp7aghupa6.scala:27:21 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mnewList\e[0m: mutable.MutableList[\e\
    [35mLong\e[0m] = arr.toMutableList\n\e[31m\e[31m   |\e[0m                    \
    \ ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found: mutable\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp7aghupa6.scala:27:53 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mnewList\e[0m: mutable.MutableList[\e\
    [35mLong\e[0m] = arr.toMutableList\n\e[31m\e[31m   |\e[0m                    \
    \                             ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        \
    \               value toMutableList is not a member of List[Long]\n2 errors found\n"
  stdout: ''
  timestamp: 1660009768
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        if(arr.isEmpty)\
    \ return true\n        val N = arr.size\n        val A = arr.toArray\n       \
    \ var i = 0\n        while(i != N) {\n            if(A(i) > A(i-1)) swap(i, i-1)\n\
    \            else i += 1\n        }\n        return moveOneBall(arr)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpx1_vvwoo.scala:31:30 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m            \e[33mif\e[0m(A(i) > A(i-\e[31m1\e[0m)) swap(i,\
    \ i-\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m                              ^^^^\e[0m\n\
    \e[31m   |\e[0m                              Not found: swap\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660009764
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val newArr = arr.toList.sortWith(_\
    \ < _)\n        var counter = 0\n        for (i <- 0 until newArr.length) {\n\
    \            if (newArr(i) == newArr.last)\n                counter = counter\
    \ + 1\n            if (counter == newArr.length - 1) \n                return\
    \ true\n        }\n        false\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp92k9jr42.scala:37)\n\tat Problem.main(tmp92k9jr42.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009770
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        var lastInArray\
    \ = 0\n        var leftArr = arr.filter(_ != lastInArray)\n        var rightArr\
    \ = arr.filter(_ != lastInArray)\n        val sortedList = arr.sortWith(_ < _)\n\
    \        var leftArr = leftArr.reverse\n        var rightArr = rightArr.reverse\n\
    \        var leftArrLast = 0l\n        var rightArrLast = 0l\n        for(i <-\
    \ 1 to arr.size - 1) {\n            leftArrLast = leftArr.get(i)\n           \
    \ rightArrLast = rightArr.get(i)\n            leftArrLast = (leftArrLast >> 1L)\
    \ >>> 1L\n            rightArrLast = (rightArrLast >> 1L) >>> 1L\n           \
    \ if (leftArrLast == rightArrLast) {\n                leftArr = leftArr.drop(i\
    \ + 1)\n                rightArr = rightArr.drop(i + 1)\n            } else {\n\
    \                leftArr = leftArr.drop(i)\n                rightArr = rightArr.drop(i)\n\
    \            }\n        }\n        for(i <- 0 to (arr.size - 1)) {\n         \
    \   if (leftArr.get(i) != leftArrLast) {\n                return false\n     \
    \       }\n        }\n        return true\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpmj0f7_e8.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mvar\e[0m \e[36mleftArr\e[0m = leftArr.reverse\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mleftArr is already defined as \e[33mvariable\e[0m \e[35mleftArr\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpmj0f7_e8.scala:31:12 ---------------------------\e[0m\e[0m\n\e[31m31\
    \ |\e[0m        \e[33mvar\e[0m \e[36mrightArr\e[0m = rightArr.reverse\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mrightArr\
    \ is already defined as \e[33mvariable\e[0m \e[35mrightArr\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpmj0f7_e8.scala:35:34\
    \ ------------------------\e[0m\e[0m\n\e[31m35 |\e[0m            leftArrLast =\
    \ leftArr.get(i)\n\e[31m\e[31m   |\e[0m                          ^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m  value get is not a member of List[Long] - did you mean List[Long].seq?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpmj0f7_e8.scala:36:36 ------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m            rightArrLast = rightArr.get(i)\n\e[31m\e\
    [31m   |\e[0m                           ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ get is not a member of List[Long], but could be made available as an extension\
    \ method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might\
    \ fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.seq\
    \ AsJavaList\n\e[31m   |\e[0m  import collection.convert.ImplicitConversionsToJava.seq\
    \ AsJavaList\n\e[31m   |\e[0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpmj0f7_e8.scala:48:24\
    \ ------------------------\e[0m\e[0m\n\e[31m48 |\e[0m            \e[33mif\e[0m\
    \ (leftArr.get(i) != leftArrLast) {\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue get is not a member of List[Long], but could be made\
    \ available as an"
  stdout: ''
  timestamp: 1660009770
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        var count = 0\n\
    \        var temp = 0\n        val a = arr.toIterator\n        while (!a.isEmpty)\
    \ {\n            if (a.head < temp) {\n                temp = a.head\n       \
    \         count += 1\n                a.next = Array()\n                a.next\
    \ += temp\n            } else {\n                a.next += a.head\n          \
    \      a.head = a.next.last\n                a.next -= temp\n                count\
    \ = 0\n            }\n        }\n        return count == 0\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp2grks3qt.scala:30:18 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m            \e[33mif\e[0m (a.head < temp) {\n\e[31m\e\
    [31m   |\e[0m                ^^^^^^\e[0m\n\e[31m   |\e[0m     value head is not\
    \ a member of Iterator[Long] - did you mean a.find?\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmp2grks3qt.scala:31:25 ------------------------\e[0m\e[0m\n\
    \e[31m31 |\e[0m                temp = a.head\n\e[31m\e[31m   |\e[0m          \
    \             ^^^^^^\e[0m\n\e[31m   |\e[0m     value head is not a member of Iterator[Long]\
    \ - did you mean a.find?\n\e[31m\e[31m-- Error: /tmp/tmp2grks3qt.scala:33:32 -----------------------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m                a.next = Array()\n\e[31m\e[31m   |\e\
    [0m                                ^\e[0m\n\e[31m   |\e[0m                   \
    \             No ClassTag available for T\n\e[31m   |\e[0m\n\e[31m   |\e[0m  \
    \                              where:    T is a type variable\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmp2grks3qt.scala:34:23 ------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m                a.next += temp\n\e[31m\e[31m   |\e[0m\
    \                ^^^^^^^^^\e[0m\n\e[31m   |\e[0m                value += is not\
    \ a member of Long - did you mean Long.!=?\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmp2grks3qt.scala:36:23 ------------------------\e[0m\e[0m\n\e[31m36 |\e\
    [0m                a.next += a.head\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                value += is not a member of Long - did you\
    \ mean Long.!=?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp2grks3qt.scala:36:28\
    \ ------------------------\e[0m\e[0m\n\e[31m36 |\e[0m                a.next +=\
    \ a.head\n\e[31m\e[31m   |\e[0m                          ^^^^^^\e[0m\n\e[31m \
    \  |\e[0m     value head is not a member of Iterator[Long] - did you mean a.find?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp2grks3qt.scala:37:18 ------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m                a.head = a.next.last\n\e[31m\e[31m  \
    \ |\e[0m                ^^^^^^\e[0m\n\e[31m   |\e[0m     value head is not a member\
    \ of Iterator[Long] - did you mean a.fin"
  stdout: ''
  timestamp: 1660009768
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        if (arr.isEmpty)\
    \ return true\n        val head = arr(0)\n        val tail = arr.tail\n      \
    \  if (tail.isEmpty) return true\n        val mid = tail.head\n        val tailtail\
    \ = tail.tail\n        val midmid = tailtail.head\n        var left = 0\n    \
    \    var right = arr.length-1\n        while (left < right) {\n            var\
    \ mid = midmid\n            while (true) {\n                val mid1 = mid + mid\n\
    \                if (mid1 == 0) return false\n                val mid2 = mid -\
    \ mid1\n                if (mid2 > 0) mid = mid2\n                else mid = mid\
    \ - 1\n            }\n            val mid1 = midmid\n            while (true)\
    \ {\n                val mid2 = mid - mid1\n                if (mid2 == 0) return\
    \ false\n                val mid1 = mid - mid2\n                if (mid1 > 0)\
    \ mid = mid1\n                else mid = mid + 1\n            }\n            if\
    \ (mid1 > midmid) {\n                left = left + 1\n                mid = midmid\n\
    \            } else if (mid1 < midmid) {\n                right = right - 1\n\
    \                mid = midmid\n            } else {\n                left = left\
    \ + 1;\n                right = right - 1\n            }\n        }\n        return\
    \ true\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpnlrwdh6u.scala:48:33 ---------------------------\e\
    [0m\e[0m\n\e[31m48 |\e[0m                \e[33mval\e[0m \e[36mmid1\e[0m = mid\
    \ - mid2\n\e[31m\e[31m   |\e[0m                                 ^\e[0m\n\e[31m\
    \   |\e[0m                                 Recursive \e[33mvalue\e[0m \e[35mmid2\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009764
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val l = arr.length\n\
    \        if (l == 0) {\n            true\n        }\n        val rightShiftCount\
    \ = l - 1\n        var rightShiftCount = 1\n        for (i <- 1 to rightShiftCount)\
    \ {\n            val leftShiftCount = rightShiftCount - i\n            if (arr(leftShiftCount).compareTo(arr(leftShiftCount\
    \ + 1)) >= 0) {\n                val temp = arr(leftShiftCount)\n            \
    \    arr(leftShiftCount) = arr(leftShiftCount + 1)\n                arr(leftShiftCount\
    \ + 1) = temp\n            }\n            rightShiftCount -= 1\n        }\n  \
    \      return false\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmprez47rlq.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mvar\e[0m \e[36mrightShiftCount\e[0m = \e\
    [31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mrightShiftCount is already defined as \e[33mvalue\e[0m \e[35mrightShiftCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmprez47rlq.scala:36:16 ------------------------\e[0m\e[0m\n\
    \e[31m36 |\e[0m                arr(leftShiftCount) = arr(leftShiftCount + \e[31m1\e\
    [0m)\n\e[31m\e[31m   |\e[0m                ^^^\e[0m\n\e[31m   |\e[0m  value update\
    \ is not a member of List[Long] - did you mean arr.updated?\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmprez47rlq.scala:37:16 ------------------------\e[0m\e\
    [0m\n\e[31m37 |\e[0m                arr(leftShiftCount + \e[31m1\e[0m) = temp\n\
    \e[31m\e[31m   |\e[0m                ^^^\e[0m\n\e[31m   |\e[0m  value update is\
    \ not a member of List[Long] - did you mean arr.updated?\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmprez47rlq.scala:39:28 ------------------------\e[0m\e\
    [0m\n\e[31m39 |\e[0m            rightShiftCount -= \e[31m1\e[0m\n\e[31m\e[31m\
    \   |\e[0m            ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m      value -= is\
    \ not a member of Int - did you mean rightShiftCount.!=?\n\e[33m\e[33m-- [E129]\
    \ Potential Issue Warning: /tmp/tmprez47rlq.scala:28:12 ----------------\e[0m\e\
    [0m\n\e[33m28 |\e[0m            \e[31mtrue\e[0m\n\e[33m\e[33m   |\e[0m       \
    \     ^^^^\e[0m\n\e[33m   |\e[0mA pure expression does nothing in statement position;\
    \ you may be omitting necessary parentheses\n\e[33m   |\e[0m\n\e[33m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 warning found\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1660009770
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        var max = 0L\n \
    \       var min = arr.head\n        var count = 1\n        var flag = true\n \
    \       var temp = 0\n        var moved = 0\n\n        while(count < arr.size)\
    \ {\n            if(arr(count) > max)\n                max = arr(count)\n    \
    \        count += 1\n        }\n\n        while(count < arr.size) {\n        \
    \    if(arr(count) < min)\n                min = arr(count)\n            count\
    \ += 1\n        }\n\n        if(count != arr.size)\n            return false\n\
    \n        while(count < arr.size) {\n            if(arr(count) == max) {\n   \
    \             count += 1\n                flag &= arr.head >= arr.tail\n     \
    \       }\n\n            if(arr(count) == min) {\n                count += 1\n\
    \                flag &= arr.head <= arr.tail\n            }\n\n            if(arr(count)\
    \ > max)\n                temp = arr(count)\n            count += 1\n        }\n\
    \n        if(flag)\n            return true\n\n        while(count < arr.size)\
    \ {\n            if(arr(count) == max) {\n                count += 1\n       \
    \         flag &= arr.head <= arr.tail\n            }\n\n            if(arr(count)\
    \ == min) {\n                count += 1\n                flag &= arr.head >= arr.tail\n\
    \            }\n\n            if(arr(count) < max)\n                temp = arr(count)\n\
    \            count += 1\n        }\n\n        return flag\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmppmm0_xgj.scala:51:21 ------------------------\e\
    [0m\e[0m\n\e[31m51 |\e[0m                flag &= arr.head >= arr.tail\n\e[31m\e\
    [31m   |\e[0m                ^^^^^^^\e[0m\n\e[31m   |\e[0m          value &= is\
    \ not a member of Boolean - did you mean Boolean.!=?\n\e[31m\e[31m-- [E134] Type\
    \ Error: /tmp/tmppmm0_xgj.scala:51:33 -----------------------------\e[0m\e[0m\n\
    \e[31m51 |\e[0m                flag &= arr.head >= arr.tail\n\e[31m\e[31m   |\e\
    [0m                        ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded\
    \ alternatives of \e[33mmethod\e[0m \e[35m>=\e[0m in \e[33mclass\e[0m \e[35mLong\e\
    [0m with types\n\e[31m   |\e[0m (x: Double): Boolean\n\e[31m   |\e[0m (x: Float):\
    \ Boolean\n\e[31m   |\e[0m (x: Long): Boolean\n\e[31m   |\e[0m (x: Int): Boolean\n\
    \e[31m   |\e[0m (x: Char): Boolean\n\e[31m   |\e[0m (x: Short): Boolean\n\e[31m\
    \   |\e[0m (x: Byte): Boolean\n\e[31m   |\e[0mmatch arguments ((arr.tail : =>\
    \ List[Long @uncheckedVariance]))\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmppmm0_xgj.scala:56:21\
    \ ------------------------\e[0m\e[0m\n\e[31m56 |\e[0m                flag &= arr.head\
    \ <= arr.tail\n\e[31m\e[31m   |\e[0m                ^^^^^^^\e[0m\n\e[31m   |\e\
    [0m          value &= is not a member of Boolean - did you mean Boolean.!=?\n\e\
    [31m\e[31m-- [E134] Type Error: /tmp/tmppmm0_xgj.scala:56:33 -----------------------------\e\
    [0m\e[0m\n\e[31m56 |\e[0m                flag &= arr.head <= arr.tail\n\e[31m\e\
    [31m   |\e[0m                        ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of\
    \ the overloaded alternatives of \e[33mmethod\e[0m \e[35m<=\e[0m in \e[33mclass\e\
    [0m \e[35mLong\e[0m with types\n\e[31m   |\e[0m (x: Double): Boolean\n\e[31m \
    \  |\e[0m (x: Float): Boolean\n\e[31m   |\e[0m (x: Long): Boolean\n\e[31m   |\e\
    [0m (x: Int): Boolean\n\e[31m   |\e[0m (x: Char): Boolean\n\e[31m   |\e[0m (x:\
    \ Short): Boolean\n\e[31m   |\e[0m (x: Byte): Boolean\n\e[31m   |\e[0mmatch arguments\
    \ ((arr.tail : => List[Long @uncheckedVariance]))\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmppmm0_xgj.scala:60:26 --------------------\e[0m\e[0m\n\
    \e[31m60 |\e[0m                temp = arr(count)\n\e[31m\e[31m   |\e[0m      \
    \  "
  stdout: ''
  timestamp: 1660009770
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val result = arr.reverse.tail.equals(arr.reverse.head)\n\
    \        arr.reverse.head == 0\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpyqbwlgwa.scala:30)\n\tat Problem.main(tmpyqbwlgwa.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009770
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        if (arr.isEmpty)\
    \ return true\n        val shifts = mutable.ListBuffer.empty[Int]\n        //\
    \ Perform N right shift operations\n        for (i <- 0 until arr.length - 1)\
    \ {\n            shifts += i \n        }\n        // Check if the list is in decreasing\
    \ order\n        if (arr.toList.sortWith(_ < _) == arr.reverse) \n        \treturn\
    \ true\n        \n        // Move the last element to the first position\n   \
    \     val last = arr.last\n        val result = arr.filter(_ != last).concat(last)\n\
    \        val shifts = shifts.filter(_ != arr.length)\n        \n        // Move\
    \ the elements to the start of the array\n        for (i <- 0 until shifts.size)\
    \ {\n            arr(shifts(i)+(last.asInstanceOf[Long])) = arr(shifts(i))\n \
    \       }\n        \n        moveOneBall(result)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpejj2q62w.scala:39:12 ---------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m \e[36mshifts\e[0m = shifts.filter(_\
    \ != arr.length)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mshifts is already defined as \e[33mvalue\e[0m \e[35mshifts\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E006] Not\
    \ Found Error: /tmp/tmpejj2q62w.scala:27:21 ------------------------\e[0m\e[0m\n\
    \e[31m27 |\e[0m        \e[33mval\e[0m \e[36mshifts\e[0m = mutable.ListBuffer.empty[\e\
    [35mInt\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpejj2q62w.scala:38:50 --------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = arr.filter(_\
    \ != last).concat(last)\n\e[31m\e[31m   |\e[0m                               \
    \                   ^^^^\e[0m\n\e[31m   |\e[0m                               \
    \             Found:    (last : Long)\n\e[31m   |\e[0m                       \
    \                     Required: IterableOnce[Long]\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpejj2q62w.scala:43:12 ------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m            arr(shifts(i)+(last.asInstanceOf[\e[35mLong\e\
    [0m])) = arr(shifts(i))\n\e[31m\e[31m   |\e[0m            ^^^\e[0m\n\e[31m   |\e\
    [0m  value update is not a member of List[Long] - did you mean arr.updated?\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1660009777
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        if(arr.isEmpty)\
    \ return true\n        var resultIndex = 0\n        for(i<-0 until arr.length)\
    \ {\n            arr(i) <<= 1\n            val leftMostElem = arr(i)\n       \
    \     if(leftMostElem == 1) {\n                if(resultIndex + 1 < arr.length)\
    \ {\n                    arr(resultIndex+1) -= 1\n                }\n        \
    \        arr(resultIndex) -= 1\n                resultIndex += 1\n           \
    \ }\n        }\n        if(arr.length == resultIndex) return true\n        return\
    \ false\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp4vw8vj2p.scala:29:19 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m            arr(i) <<= \e[31m1\e[0m\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value <<= is not a\
    \ member of Long - did you mean Long.<<?\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmp4vw8vj2p.scala:33:39 ------------------------\e[0m\e[0m\n\e[31m33 |\e\
    [0m                    arr(resultIndex+\e[31m1\e[0m) -= \e[31m1\e[0m\n\e[31m\e\
    [31m   |\e[0m                    ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \               value -= is not a member of Long - did you mean Long.!=?\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp4vw8vj2p.scala:35:33 ------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m                arr(resultIndex) -= \e[31m1\e[0m\n\e\
    [31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \               value -= is not a member of Long - did you mean Long.!=?\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660009779
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        var flag = false\n\
    \        val arr = arr.toList\n        if(arr.isEmpty)\n            return true\n\
    \        var pos = arr.size - 1\n        var last = 0\n        while(pos >=0){\n\
    \            if(arr(pos)<last){\n                last = arr(pos)\n           \
    \ }\n            pos = pos - 1\n        }\n        val rem = arr.drop(last+1)\n\
    \        val rest = arr.take(last+1)\n        flag = moveOneBall(rest)\n     \
    \   if(!flag)\n            flag = moveOneBall(rem)\n        flag\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpx5vtqe2h.scala:27:18 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660009772
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val l1 = arr.reverse\n\
    \        val l2 = l1.reverse\n        l1.length <= arr(arr.length-1) \n      \
    \          || l2.length <= arr(arr.length-1)\n                || l1.sum - l2.sum\
    \ == arr(arr.length-1)\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpiznmbdgg.scala:33)\n\tat Problem.main(tmpiznmbdgg.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009779
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.length\n\
    \        if (n == 0) true\n        else {\n            val newArr = Array[Long]()\n\
    \            var j = 0\n            var k = 0\n            var i = 1\n       \
    \     while (i < n) {\n                newArr :+= arr(j)\n                j +=\
    \ 1\n                k += 1\n                i += 1\n            }\n         \
    \   val arr = newArr\n            if (k > 0) {\n                var j = 0\n  \
    \              var k = 0\n                var i = 1\n                while (i\
    \ < n) {\n                    newArr :+= arr(j)\n                    j += 1\n\
    \                    k += 1\n                    i += 1\n                }\n \
    \               val arr = newArr\n                if (k > 1) {\n             \
    \       var j = 0\n                    var k = 0\n                    var i =\
    \ 1\n                    while (i < n) {\n                        newArr :+= arr(j)\n\
    \                        j += 1\n                        k += 1\n            \
    \            i += 1\n                    }\n                    val arr = newArr\n\
    \                    if (k > 2) {\n                        var j = 0\n       \
    \                 var k = 0\n                        var i = 1\n             \
    \           while (i < n) {\n                            newArr :+= arr(j)\n \
    \                           j += 1\n                            k += 1\n     \
    \                       i += 1\n                        }\n                  \
    \      val arr = newArr\n                        if (k > 3) {\n              \
    \              var j = 0\n                            var k = 0\n            \
    \                var i = 1\n                            while (i < n) {\n    \
    \                            newArr :+= arr(j)\n                             \
    \   j += 1\n                                k += 1\n                         \
    \       i += 1\n                            }\n                            val\
    \ arr = newArr\n                            if (k > 4) {\n                   \
    \             var j = 0\n                                var k = 0\n         \
    \                       var i = 1\n                                while (i <\
    \ n) {\n                                    newArr :+= arr(j)\n              \
    \                      j += 1\n                                    k += 1\n  \
    \                                  i += 1\n                                }\n\
    \                                val arr = newArr\n                          \
    \      if (k > 5) {\n                                    var j = 0\n         \
    \                           var k = 0\n                                    var\
    \ i = 1\n                                    while (i < n) {\n               \
    \                         newArr :+= arr(j)\n                                \
    \        j += 1\n                                        k += 1\n            \
    \                            i += 1\n                                    }\n \
    \                                   val arr = newArr\n                       \
    \             if (k > 6) {\n                                        var j = 0\n\
    \                                        var k = 0\n                         \
    \               var i = 1\n                                        while (i <\
    \ n) {\n                                            newArr :+= arr(j)\n      \
    \                                      j += 1\n                              \
    \              k += 1\n                                            i += 1\n  \
    \                                      }\n                                   \
    \     val arr = newArr\n                                        if (k > 7) {\n\
    \                                            var j = 0\n                     \
    \                       var k = 0\n                                          \
    \  var i = 1\n                                            while (i < n) {\n  \
    \                                              newArr :+= arr(j)\n           \
    \                                     j += 1\n                               \
    \                 k += 1\n                                                i +=\
    \ 1\n                                            }\n                         \
    \                   val arr = newArr\n                                       \
    \     if (k > 8) {\n                                \n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpmdy8ajj_.scala:140:0 ---------------------------\e\
    [0m\e[0m\n\e[31m140 |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m'}'\
    \ expected, but eof found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpmdy8ajj_.scala:34:23\
    \ ------------------------\e[0m\e[0m\n\e[31m34 |\e[0m                newArr :+=\
    \ arr(j)\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                value :+= is not a member of Array[Long]\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpmdy8ajj_.scala:45:27 ------------------------\e[0m\e\
    [0m\n\e[31m45 |\e[0m                    newArr :+= arr(j)\n\e[31m\e[31m   |\e\
    [0m                    ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                    value\
    \ :+= is not a member of Array[Long]\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpmdy8ajj_.scala:56:31\
    \ ------------------------\e[0m\e[0m\n\e[31m56 |\e[0m                        newArr\
    \ :+= arr(j)\n\e[31m\e[31m   |\e[0m                        ^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                        value :+= is not a member of Array[Long]\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpmdy8ajj_.scala:67:35 ------------------------\e\
    [0m\e[0m\n\e[31m67 |\e[0m                            newArr :+= arr(j)\n\e[31m\e\
    [31m   |\e[0m                            ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                        value :+= is not a member of Array[Long]\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpmdy8ajj_.scala:78:39 ------------------------\e\
    [0m\e[0m\n\e[31m78 |\e[0m                                newArr :+= arr(j)\n\e\
    [31m\e[31m   |\e[0m                                ^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                                value :+= is not a member of Array[Long]\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpmdy8ajj_.scala:89:43 ------------------------\e\
    [0m\e[0m\n\e[31m89 |\e[0m                                    newArr :+= arr(j)\n\
    \e[31m\e[31m   |\e[0m                                    ^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                                value :+= is not a member of Array[Long]\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpmdy8ajj_.scala:100:47 -----------------------\e\
    [0m\e[0m\n\e["
  stdout: ''
  timestamp: 1660009780
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        // Use a var to\
    \ check if we have successfully achieved the non-decreasing order\n        var\
    \ hasNonDecreasingOrder = false\n        // For all the elements in the list\n\
    \        for (elem <- arr) {\n            // If the element is the bigger than\
    \ the current biggest element then\n            // we keep it in the current position\n\
    \            if (elem > arr.max)\n                arr.insert(arr.size, elem)\n\
    \            // If not then we remove the element from the current position\n\
    \            else {\n                // We need to check if the element is the\
    \ bigger than the maximum element\n                // and if yes, then we need\
    \ to check if we can move that element to \n                // the right and if\
    \ not then we skip that element\n                if (elem > arr.max && arr.max\
    \ < arr.max)\n                    arr.insert(arr.size, elem)\n               \
    \ // If not then we cannot move that element in the right direction\n        \
    \        else {\n                    hasNonDecreasingOrder = true\n          \
    \          arr.remove(arr.size - 1)\n                }\n            }\n      \
    \  }\n        return !hasNonDecreasingOrder\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpf01keiup.scala:33:20 ------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m                arr.insert(arr.size, elem)\n\e[31m\e\
    [31m   |\e[0m                ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m     value insert\
    \ is not a member of List[Long] - did you mean arr.init?\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpf01keiup.scala:40:24 ------------------------\e[0m\e\
    [0m\n\e[31m40 |\e[0m                    arr.insert(arr.size, elem)\n\e[31m\e[31m\
    \   |\e[0m                    ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m     value insert\
    \ is not a member of List[Long] - did you mean arr.init?\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpf01keiup.scala:44:24 ------------------------\e[0m\e\
    [0m\n\e[31m44 |\e[0m                    arr.remove(arr.size - \e[31m1\e[0m)\n\e\
    [31m\e[31m   |\e[0m                    ^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue remove\
    \ is not a member of List[Long], but could be made available as an extension method.\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might fix the problem:\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.seq\
    \ AsJavaList\n\e[31m   |\e[0m  import collection.convert.ImplicitConversionsToJava.seq\
    \ AsJavaList\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.collection\
    \ asJava\n\e[31m   |\e[0m  import collection.convert.ImplicitConversionsToJava.collection\
    \ asJava\n\e[31m   |\e[0m\n3 errors found\n"
  stdout: ''
  timestamp: 1660009779
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val result = arr.isEmpty\n\
    \        if(result) true else false\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpoo19_z5m.scala:30)\n\tat Problem.main(tmpoo19_z5m.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009780
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = (arr.length.toLong\
    \ / 2).toInt\n        var i = 0\n        var j = 0\n        var last = 0\n   \
    \     var min = arr(0)\n\n        var flag = true\n        while ((i <= arr.length.toLong\
    \ / 2) && (flag == true)) {\n            flag = false\n            if (arr(i)\
    \ > min) {\n                last = (i - 1).toInt\n                j = (i + 1)\
    \ % arr.length.toInt\n                while ((j <= arr.length.toLong / 2) && (flag\
    \ == true)) {\n                    if (arr(j) > min) {\n                     \
    \   if (arr(i) - arr(j) < 0) {\n                            last = j\n       \
    \                 }\n                        j = (j + 1) % arr.length.toInt\n\
    \                        flag = true\n                    } else {\n         \
    \               flag = false\n                    }\n                }\n     \
    \           min = arr(j)\n                i = last\n            }\n          \
    \  i += 1\n        }\n        if (min < arr(0)) {\n            true\n        }\
    \ else {\n            false\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpibz3e2ex.scala:61)\n\tat Problem.main(tmpibz3e2ex.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009781
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val sorted = arr.sort\n\
    \        val n = arr.size\n        if (sorted == arr) true\n        else {\n \
    \           val left = 0\n            var right = 0\n            var count = 0\n\
    \            for (i <- 1 to n-1){\n                left = right \n           \
    \     right = left + sorted[left] - sorted[right]\n                count = count\
    \ + 1\n                if (right >= n)\n                    right = left + 1\n\
    \            }\n            count < n\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp_iwutom7.scala:26:25 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36msorted\e[0m = arr.sort\n\
    \e[31m\e[31m   |\e[0m                     ^^^^^^^^\e[0m\n\e[31m   |\e[0m     value\
    \ sort is not a member of List[Long] - did you mean arr.sortBy?\n\e[31m\e[31m--\
    \ [E052] Type Error: /tmp/tmp_iwutom7.scala:34:21 -----------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m                left = right \n\e[31m\e[31m   |\e[0m\
    \                ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                Reassignment\
    \ to val left\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp_iwutom7.scala:35:38\
    \ ------------------------\e[0m\e[0m\n\e[31m35 |\e[0m                right = left\
    \ + sorted[\e[35mleft\e[0m] - sorted[\e[35mright\e[0m]\n\e[31m\e[31m   |\e[0m\
    \                                      ^^^^\e[0m\n\e[31m   |\e[0m            \
    \                          Not found: type left\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660009781
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val arrLength =\
    \ arr.length\n        if (arrLength == 0) true\n        else if (!arr(arrLength\
    \ - 1).equals(arr(0))) {\n            val tmpArr : List[Long] = arr.sortBy(_.toLong).reverse\n\
    \            if (moveOneBall(tmpArr)) {\n                val resArr : List[Long]\
    \ = tmpArr.map(x => arr(arrLength - x - 1))\n                val resArrLength\
    \ = resArr.length\n                if (resArrLength > 0)\n                   \
    \ moveOneBall(resArr)\n                else\n                    false\n     \
    \       } else false\n        } else false\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp81rqoxda.scala:31:62\
    \ --------------------\e[0m\e[0m\n\e[31m31 |\e[0m                \e[33mval\e[0m\
    \ \e[36mresArr\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m] = tmpArr.map(\e[36mx\e\
    [0m => arr(arrLength - x - \e[31m1\e[0m))\n\e[31m\e[31m   |\e[0m             \
    \                                                 ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                                                          Found:   \
    \ Long\n\e[31m   |\e[0m                                                      \
    \    Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009780
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        // We need to store\
    \ each time we perform a right shift, so that we can\n        // check how many\
    \ times a right shift is performed.\n        var shiftCount = 0\n\n        //\
    \ We can only move the element on arr[0] because arr[1] is\n        // always\
    \ less than arr[0].\n        val x = arr(0)\n        // The new value is x + (arr(1)\
    \ >> (shiftCount - 1)).\n        // We are assuming here that arr[1] < arr[0]\
    \ which is the case for\n        // arr[1], arr[2], ..., arr[N].\n        val\
    \ y = x + (arr(1) >> (shiftCount - 1))\n\n        // If the new value is greater\
    \ than arr[0], then we can't get a non-\n        // decreasing order.\n      \
    \  if (y < arr(0)) false else true\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpxsgxe7wd.scala:45)\n\tat Problem.main(tmpxsgxe7wd.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009781
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val N : Int = arr.length\n\
    \        val numMoves : Int = (math.pow(2,N)).floor\n        val numMovesInner\
    \ = math.pow(2,N-1)\n        val listInner : MutableList[Long] = MutableList.empty\n\
    \        val list : MutableList[Long] = MutableList.empty\n        val move :\
    \ Int = math.pow(2,numMoves).ceil.toInt\n        var listIsEmpty : Boolean = true\n\
    \n        for(i <- 1 to numMovesInner){\n            val rightShift : Long = math.pow(2,i)\n\
    \            val numShift : Int = rightShift.toInt\n            var listIsEmpty\
    \ : Boolean = true\n            val shift : Long = math.pow(2,i)\n           \
    \ val listCopy = arr.toList\n\n            for(j <- 1 to numMovesInner - i){\n\
    \                listCopy = listCopy.tail\n                val index = math.pow(2,j).toInt\n\
    \                if(listCopy.isEmpty){\n                    listIsEmpty = false\n\
    \                    break\n                }\n                val left = listCopy.head\n\
    \                listCopy = listCopy.tail\n                listCopy = listCopy\
    \ :+ left.toLong\n\n                val right = listCopy.last\n              \
    \  listCopy = listCopy :+ right.toLong\n            }\n\n            if(listIsEmpty){\n\
    \                return true\n            }\n            list = list :+ arr.head\n\
    \            arr = arr.tail\n        }\n        if(list.isEmpty){\n          \
    \  return true\n        }\n        list = list :+ arr.head\n        arr = arr.tail\n\
    \        return false\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp2gi9uk1k.scala:27:45\
    \ --------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mnumMoves\e\
    [0m : \e[35mInt\e[0m = (math.pow(\e[31m2\e[0m,N)).floor\n\e[31m\e[31m   |\e[0m\
    \                             ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                         Found:    Double\n\e[31m   |\e[0m                  \
    \           Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp2gi9uk1k.scala:29:24 ------------------------\e[0m\e[0m\n\e[31m29 |\e\
    [0m        \e[33mval\e[0m \e[36mlistInner\e[0m : \e[35mMutableList\e[0m[\e[35mLong\e\
    [0m] = MutableList.empty\n\e[31m\e[31m   |\e[0m                        ^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                        Not found: type MutableList\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp2gi9uk1k.scala:29:44 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mlistInner\e[0m : \e[35mMutableList\e\
    [0m[\e[35mLong\e[0m] = MutableList.empty\n\e[31m\e[31m   |\e[0m              \
    \                              ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m             \
    \                               Not found: MutableList\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp2gi9uk1k.scala:30:19 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mlist\e[0m : \e[35mMutableList\e\
    [0m[\e[35mLong\e[0m] = MutableList.empty\n\e[31m\e[31m   |\e[0m              \
    \     ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                   Not found: type MutableList\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp2gi9uk1k.scala:30:39\
    \ ------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e\
    [36mlist\e[0m : \e[35mMutableList\e[0m[\e[35mLong\e[0m] = MutableList.empty\n\e\
    [31m\e[31m   |\e[0m                                       ^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0"
  stdout: ''
  timestamp: 1660009782
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        if( arr.isEmpty){\n\
    \            true\n        } else {\n            val count = (arr.head :: 0 ::\
    \ Nil).length\n            val count1 = (arr.tail.head :: 0 :: Nil).length\n \
    \           if( count != count1 ){\n                false\n            } else\
    \ {\n                val newList = arr.head :: arr.tail\n                val newList\
    \ = newList.sortWith( (a,b) => b - a)\n                if( arr.head == newList.head){\n\
    \                    moveOneBall(newList.tail)\n                } else {\n   \
    \                 false\n                }\n            }\n        }\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpf9wt7hpj.scala:35:20 ---------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m                \e[33mval\e[0m \e[36mnewList\e[0m = newList.sortWith(\
    \ (\e[36ma\e[0m,\e[36mb\e[0m) => b - a)\n\e[31m\e[31m   |\e[0m               \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mnewList\
    \ is already defined as \e[33mvalue\e[0m \e[35mnewList\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n1 error found\n"
  stdout: ''
  timestamp: 1660009778
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        if (arr.isEmpty)\
    \ {\n            true\n        } else {\n            var count = 0\n         \
    \   var left = 0\n            var right = arr.size - 1\n            while (count\
    \ != arr.size) {\n                while (left <= right) {\n                  \
    \  if (arr.size > right) {\n                        arr.swap(right, left)\n  \
    \                      count += 1\n                        left += 1\n       \
    \                 right -= 1\n                    } else {\n                 \
    \       return false\n                    }\n                }\n             \
    \   left += 1\n                right -= 1\n            }\n            return true\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmptdwdxpw3.scala:35:28 ------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m                        arr.swap(right, left)\n\e[31m\e\
    [31m   |\e[0m                        ^^^^^^^^\e[0m\n\e[31m   |\e[0m        value\
    \ swap is not a member of List[Long] - did you mean arr.map?\n1 error found\n"
  stdout: ''
  timestamp: 1660009781
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val maxIndex = arr.size\n\
    \        var shiftCount = 0\n        // If list is empty then return true\n  \
    \      if(arr.isEmpty) true\n\n        for(index <- 1 to maxIndex) {\n       \
    \     val leftmost = math.max(arr(index), 1)\n            val rightmost = math.min(arr(index),\
    \ maxIndex)\n\n            // If any element is less than left most and greater\
    \ than rightmost then\n            // there is no possible way. Return false\n\
    \            if(arr(index) < leftmost && arr(index) > rightmost) false\n     \
    \       else {\n                // If any element is equal to left most then there\
    \ are two possibilities:\n                // 1. There is only one element to move.\
    \ \n                // 2. All elements are left most then the list is sorted.\n\
    \                if(arr(index) == leftmost) {\n                    if(shiftCount\
    \ == 0) {\n                        // If there is only one element to move then\
    \ there is only one possibility\n                        // i.e. either element\
    \ is moved to 0th position or\n                        // all the elements are\
    \ moved to 0th position.\n                        if(shiftIndex == 0) true\n \
    \                       else false\n                    } else true\n        \
    \        }\n\n                // If any element is equal to right most then\n\
    \                // there are three possibilities:\n                // 1. There\
    \ is only one element to move.\n                // 2. All elements are left most\
    \ then the list is sorted.\n                // 3. All elements are moved to rightmost\
    \ position.\n                if(arr(index) == rightmost) {\n                 \
    \   if(shiftCount == 0) {\n                        // If there is only one element\
    \ to move then there is only one possibility\n                        // i.e.\
    \ either element is moved to 0th position or\n                        // all the\
    \ elements are moved to rightmost position.\n                        if(shiftIndex\
    \ == maxIndex - 1) true\n                        else false\n                \
    \    } else true\n                }\n\n                // Else the element is\
    \ not greater than leftmost or less than rightmost\n                // then there\
    \ is a possibility to move this element to 0th position\n                else\
    \ {\n                    val shiftIndex = math.min(index - 1, maxIndex - shiftCount)\n\
    \n                    // If shiftIndex is greater than index - 1 then there are\
    \ two possibilities:\n                    // 1. Element is already at 0th position\
    \ and there is no way to move it to\n                    //    0th position.\n\
    \                    // 2. All elements are moved to 0th position.\n         \
    \           if(shiftIndex > index - 1) {\n                        if(shiftCount\
    \ == 0) true\n                        else false\n                    }\n\n  \
    \                  // If shiftIndex is less than index - 1 then there are three\
    \ possibilities:\n                    // 1. All elements are moved to 0th position.\n\
    \                    // 2. Element is already at 0th position and there is no\
    \ way to move it to\n                    //    0th position.\n               \
    \     // 3. All elements are moved to rightmost position.\n                  \
    \  else {\n                        if(shiftCount == 0) \n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpdnb4b7zm.scala:88:4 ----------------------------\e\
    [0m\e[0m\n\e[31m88 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    'then' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpdnb4b7zm.scala:98:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m98 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E006] Not\
    \ Found Error: /tmp/tmpdnb4b7zm.scala:47:27 ------------------------\e[0m\e[0m\n\
    \e[31m47 |\e[0m                        \e[33mif\e[0m(shiftIndex == \e[31m0\e[0m)\
    \ \e[31mtrue\e[0m\n\e[31m\e[31m   |\e[0m                           ^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                           Not found: shiftIndex\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpdnb4b7zm.scala:62:27 ------------------------\e\
    [0m\e[0m\n\e[31m62 |\e[0m                        \e[33mif\e[0m(shiftIndex == maxIndex\
    \ - \e[31m1\e[0m) \e[31mtrue\e[0m\n\e[31m\e[31m   |\e[0m                     \
    \      ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                           Not found: shiftIndex\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[33m\e[33m-- Warning: /tmp/tmpdnb4b7zm.scala:89:4 ----------------------------------------\e\
    [0m\e[0m\n\e[33m89 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m\
    \   |\e[0m    Line is indented too far to the left, or a `}` is missing\n\e[33m\e\
    [33m-- [E129] Potential Issue Warning: /tmp/tmpdnb4b7zm.scala:29:24 ----------------\e\
    [0m\e[0m\n\e[33m29 |\e[0m        \e[33mif\e[0m(arr.isEmpty) \e[31mtrue\e[0m\n\e\
    [33m\e[33m   |\e[0m                        ^^^^\e[0m\n\e[33m   |\e[0mA pure expression\
    \ does nothing in statement position; you may be omitting necessary parentheses\n\
    \e[33m   |\e[0m\n\e[33m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[33m\e[33m-- [E129] Potential Issue Warning: /tmp/tmpdnb4b7zm.scala:47:44\
    \ ----------------\e[0m\e[0m\n\e[33m47 |\e[0m                        \e[33mif\e\
    [0m(shiftIndex == \e["
  stdout: ''
  timestamp: 1660009779
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val numElem = arr.size\n\
    \        val numToShift = math.ceil(numElem / 2)\n        for (i = arr.size -\
    \ 1; i > numToShift; i--) {\n            val leftToShift = numElem - i\n     \
    \       val rightToShift = numToShift - i\n            val rightToLeftShift =\
    \ arr.take(rightToShift) ++ arr.drop(leftToShift)\n            arr(rightToShift)\
    \ match {\n                case x if (x == 0) => arr(i) = x\n                case\
    \ _ => arr(i) = arr.min\n            }\n        }\n        numElem == arr.size\
    \ && arr.forall(x => x == 0)\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpkbsg35ek.scala:28:15 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mfor\e[0m (i = arr.size - \e[31m1\e[0m;\
    \ i > numToShift; i--) {\n\e[31m\e[31m   |\e[0m               ^\e[0m\n\e[31m \
    \  |\e[0m               ')' expected, but '=' found\n\e[31m\e[31m-- [E040] Syntax\
    \ Error: /tmp/tmpkbsg35ek.scala:28:45 ---------------------------\e[0m\e[0m\n\e\
    [31m28 |\e[0m        \e[33mfor\e[0m (i = arr.size - \e[31m1\e[0m; i > numToShift;\
    \ i--) {\n\e[31m\e[31m   |\e[0m                                             ^\e\
    [0m\n\e[31m   |\e[0m                                            '<-' expected,\
    \ but ';' found\n\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpkbsg35ek.scala:28:50\
    \ ---------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mfor\e[0m\
    \ (i = arr.size - \e[31m1\e[0m; i > numToShift; i--) {\n\e[31m\e[31m   |\e[0m\
    \                                                  ^\e[0m\n\e[31m   |\e[0m   \
    \                                               pattern expected\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpkbsg35ek.scala:28:29 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mfor\e[0m (i = arr.size - \e[31m1\e[0m;\
    \ i > numToShift; i--) {\n\e[31m\e[31m   |\e[0m                             ^\e\
    [0m\n\e[31m   |\e[0mvalue foreach is not a member of Null, but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import Option.option2Iterable\n\
    \e[31m   |\e[0m  import collection.LazyZip2.lazyZip2ToIterable\n\e[31m   |\e[0m\
    \  import collection.LazyZip3.lazyZip3ToIterable\n\e[31m   |\e[0m  import collection.LazyZip4.lazyZip4ToIterable\n\
    \e[31m   |\e[0m  import collection.convert.ImplicitConversions.list asScalaBuffer\n\
    \e[31m   |\e[0m  import collection.convert.ImplicitConversions.properties AsScalaMap\n\
    \e[31m   |\e[0m  import collection.convert.ImplicitConversions.enumeration AsScalaIterator\n\
    \e[31m   |\e[0m  import collection.convert.ImplicitConversions.iterator asScala\n\
    \e[31m   |\e[0"
  stdout: ''
  timestamp: 1660009783
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        if(arr.length ==\
    \ 0) return true\n        var i : Int = 0\n        while(i < arr.length-1) {\n\
    \            if(arr(i) <= arr(i+1)) {\n                arr(i) := arr(i+1)\n  \
    \              arr(i+1) := 0\n            } else {\n                i+=1\n   \
    \         }\n        }\n        if(arr(i) == 0) {\n            i+=1\n        }\n\
    \        if(arr(i) == 0) {\n            i+=1\n        }\n        if(arr(i) ==\
    \ 0) {\n            i+=1\n        }\n        if(arr(i) == 0) {\n            i+=1\n\
    \        }\n        if(arr(i) == 0) {\n            i+=1\n        }\n        if(arr(i)\
    \ == 0) {\n            i+=1\n        }\n        if(arr(i) == 0) {\n          \
    \  i+=1\n        }\n        if(arr(i) == 0) {\n            i+=1\n        }\n \
    \       if(arr(i) == 0) {\n            i+=1\n        }\n        if(arr(i) == 0)\
    \ {\n            i+=1\n        }\n        if(arr(i) == 0) {\n            i+=1\n\
    \        }\n        if(arr(i) == 0) {\n            i+=1\n        }\n        if(arr(i)\
    \ == 0) {\n            i+=1\n        }\n        if(arr(i) == 0) {\n          \
    \  i+=1\n        }\n        if(arr(i) == 0) {\n            i+=1\n        }\n \
    \       if(arr(i) == 0) {\n            i+=1\n        }\n        if(arr(i) == 0)\
    \ {\n            i+=1\n        }\n        if(arr(i) == 0) {\n            i+=1\n\
    \        }\n        if(arr(i) == 0) {\n            i+=1\n        }\n        if(arr(i)\
    \ == 0) {\n            i+=1\n        }\n        if(arr(i) == 0) {\n          \
    \  i+=1\n        }\n        if(arr(i) == 0) {\n            i+=1\n        }\n \
    \       if(arr(i) == 0) {\n            i+=1\n        }\n        if(arr(i) == 0)\
    \ {\n            i+=1\n        }\n        if(arr(i) == 0) {\n            i+=1\n\
    \        }\n        if(arr(i) == 0) {\n            i+=1\n        }\n        if(arr(i)\
    \ == 0) {\n            i+=1\n        }\n        if(arr(i) == 0) {\n          \
    \  i+=1\n        }\n        if(arr(i) == 0) {\n            i+=1\n        }\n \
    \       if(arr(i) == 0) {\n            i+=1\n        }\n        if(arr(i) == 0)\
    \ {\n            i+=1\n        }\n        if(arr(i) == 0) {\n            i+=1\n\
    \        }\n        if(arr(i) == 0) {\n            i+=1\n        }\n        if(arr(i)\
    \ == 0) {\n            i+=1\n        }\n        if(arr(i) == 0) {\n          \
    \  i+=1\n        }\n        if(arr(i) == 0) {\n            i+=1\n        }\n \
    \       if(arr(i) == 0) {\n            i+=1\n        }\n        if(arr(i) == 0)\
    \ {\n            i+=1\n        }\n\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpwrqztgt8.scala:30:23 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m                arr(i) := arr(i+\e[31m1\e[0m)\n\e[31m\e\
    [31m   |\e[0m                ^^^^^^^^^\e[0m\n\e[31m   |\e[0m                value\
    \ := is not a member of Long - did you mean Long.!=?\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmpwrqztgt8.scala:31:25 ------------------------\e[0m\e[0m\n\
    \e[31m31 |\e[0m                arr(i+\e[31m1\e[0m) := \e[31m0\e[0m\n\e[31m\e[31m\
    \   |\e[0m                ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                value\
    \ := is not a member of Long - did you mean Long.!=?\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmpwrqztgt8.scala:147:8 --------------------\e[0m\e[0m\n\
    \e[31m147 |\e[0m        \e[33mif\e[0m(arr(i) == \e[31m0\e[0m) {\n\e[31m\e[31m\
    \    |\e[0m        ^\e[0m\n\e[31m    |\e[0m        Found:    Unit\n\e[31m    |\e\
    [0m        Required: Boolean\n\e[31m    |\e[0m        Maybe you are missing an\
    \ else part for the conditional?\n\e[31m148 |\e[0m            i+=\e[31m1\e[0m\n\
    \e[31m149 |\e[0m        }\n\e[31m    |\e[0m\n\e[31m    |\e[0m longer explanation\
    \ available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660009783
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val s = arr\n  \
    \      var c = s.tail\n        var i = s.head\n\n        // Performs Right shift\
    \ operations based on the size of the list\n        while (i.isDefined) {\n  \
    \          i = s.tail \n            c = c ::: List(i.head) \n        }\n\n   \
    \     // If any element is equal to 0, then it is possible\n        var isPossible\
    \ = c.nonEmpty\n        for (c <- c) {\n            if (c == 0)\n            \
    \    isPossible = false\n        }\n        isPossible\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp1q84x6du.scala:31:17 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mwhile\e[0m (i.isDefined) {\n\e[31m\e[31m\
    \   |\e[0m               ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m               value\
    \ isDefined is not a member of Long\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmp1q84x6du.scala:32:18 --------------------\e[0m\e[0m\n\e[31m32 |\e[0m\
    \            i = s.tail \n\e[31m\e[31m   |\e[0m                ^^^^^^\e[0m\n\e\
    [31m   |\e[0m                Found:    List[Long @uncheckedVariance]\n\e[31m \
    \  |\e[0m                Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp1q84x6du.scala:33:29 ------------------------\e[0m\e\
    [0m\n\e[31m33 |\e[0m            c = c ::: List(i.head) \n\e[31m\e[31m   |\e[0m\
    \                           ^^^^^^\e[0m\n\e[31m   |\e[0m                     \
    \      value head is not a member of Long\n3 errors found\n"
  stdout: ''
  timestamp: 1660009784
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        if(arr.isEmpty)\
    \ true\n        else if(!arr.exists(_ < 0)) false // If any element is negative,\
    \ return false.\n        else {\n            val a = arr.toSet\n            val\
    \ d = a.toList\n            val k = d.toArray\n            val x = k(0)\n    \
    \        val l = k.length - 1\n            val r = x - 1\n            val w =\
    \ k.toArray\n            val y = w.length - 1\n            val z = w(0)\n    \
    \        val n = w(y)\n            var m = x + y - 1\n            while(m > 1)\
    \ {\n                val j = m\n                m(j) = m(j-1)\n              \
    \  m = m - 1\n            }\n            while(n > 1) {\n                var i\
    \ = n\n                n = n - 1\n                if(i == 0 || i == y) i = 0\n\
    \                else {\n                    i = i-1\n                    val\
    \ j = i\n                    m(j) = m(j-1)\n                }\n            }\n\
    \            m = x + y\n            n = x\n            while(m > 1) {\n      \
    \          var i = m\n                m = m - 1\n                if(i == 0 ||\
    \ i == y) i = 0\n                else {\n                    i = i-1\n       \
    \             val j = i\n                    m(j) = m(j-1)\n                }\n\
    \            }\n            val isSorted = true\n            for(i <- 1 until\
    \ d) {\n                isSorted = isSorted && (i <= r)\n            }\n     \
    \       return isSorted\n        }\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpshwb_ccs.scala:42:16 ------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m                m(j) = m(j-\e[31m1\e[0m)\n\e[31m\e[31m\
    \   |\e[0m                ^\e[0m\n\e[31m   |\e[0m                value update\
    \ is not a member of Long\n\e[31m\e[31m-- [E050] Type Error: /tmp/tmpshwb_ccs.scala:42:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m42 |\e[0m                m(j)\
    \ = m(j-\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m                       ^\e[0m\n\e\
    [31m   |\e[0m                       \e[33mvariable\e[0m \e[35mm\e[0m does not\
    \ take parameters\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmpshwb_ccs.scala:47:18\
    \ -----------------------------\e[0m\e[0m\n\e[31m47 |\e[0m                n =\
    \ n - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                Reassignment to val n\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpshwb_ccs.scala:52:20 ------------------------\e\
    [0m\e[0m\n\e[31m52 |\e[0m                    m(j) = m(j-\e[31m1\e[0m)\n\e[31m\e\
    [31m   |\e[0m                    ^\e[0m\n\e[31m   |\e[0m                    value\
    \ update is not a member of Long\n\e[31m\e[31m-- [E050] Type Error: /tmp/tmpshwb_ccs.scala:52:27\
    \ -----------------------------\e[0m\e[0m\n\e[31m52 |\e[0m                   \
    \ m(j) = m(j-\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m                           ^\e\
    [0m\n\e[31m   |\e[0m                           \e[33mvariable\e[0m \e[35mm\e[0m\
    \ does not take parameters\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E052] Type Error:\
    \ /tmp/tmpshwb_ccs.scala:56:14 -----------------------------\e[0m\e[0m\n\e[31m56\
    \ |\e[0m            n = x\n\e[31m\e[31m   |\e[0m            ^^^^^\e[0m\n\e[31m\
    \   |\e[0m            Reassignment to val n\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpshwb_ccs.scala:64:20 ------------------------\e\
    [0m\e[0m\n\e[31m64 |\e[0m       "
  stdout: ''
  timestamp: 1660009784
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val N = arr.size\n\
    \        val m = math.max(arr.max)\n        var issorted = false\n        var\
    \ j = 0\n        for (i <- 0 until N){\n            if (arr(i) < m) j += 1\n \
    \           else if (arr(i) > m) issorted = true\n            else if (arr(i)\
    \ == m) issorted = true\n            if (j == N) issorted = true\n        }\n\
    \        if (issorted) true\n        else false\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmp03lpzvmk.scala:27:21 -----------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mm\e[0m = math.max(arr.max)\n\
    \e[31m\e[31m   |\e[0m                ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmax\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments (Long)\n1 error found\n"
  stdout: ''
  timestamp: 1660009781
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val leftArr = arr.copy\n\
    \        val rightArr = arr.copy\n        val isFirst = true\n        val isRightShift\
    \ = true\n\n        for (i <- 1 to arr.size) {\n            val temp = leftArr(i-1)\n\
    \            leftArr(i-1) = leftArr(i)\n            leftArr(i) = temp\n\n    \
    \        if (isRightShift) {\n                rightArr(i) = rightArr(i-1)\n  \
    \              rightArr(i-1) = temp\n            } else {\n                rightArr(i-1)\
    \ = rightArr(i)\n                rightArr(i) = temp\n            }\n\n       \
    \     isRightShift = !isRightShift\n\n            if (isFirst) {\n           \
    \     isFirst = !isFirst\n            } else {\n                leftArr(0) = leftArr(arr.size\
    \ - 1)\n                rightArr(0) = rightArr(arr.size - 1)\n            }\n\
    \        }\n\n        if (!isFirst)\n            return false\n\n        var i\
    \ = 0\n        val isRightShift = true\n        val arr2 = arr.copy\n\n      \
    \  for (i <- 1 to arr.size) {\n            if (arr(i) < arr2(arr.size - 1)) {\n\
    \                arr2(i) = 0l\n                isRightShift = !isRightShift\n\
    \            }\n\n            if (isRightShift) {\n                arr2(i) = arr2(i-1)\n\
    \                arr2(i-1) = 0l\n            } else {\n                arr2(i-1)\
    \ = arr2(i)\n                arr2(i) = arr2(i-1)\n            }\n        }\n\n\
    \        leftArr.zip(rightArr).forall { case (l, r) => l < r }\n\n        return\
    \ true\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmphyvhd9it.scala:58:12 ---------------------------\e\
    [0m\e[0m\n\e[31m58 |\e[0m        \e[33mval\e[0m \e[36misRightShift\e[0m = \e[31mtrue\e\
    [0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0misRightShift\
    \ is already defined as \e[33mvalue\e[0m \e[35misRightShift\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmphyvhd9it.scala:26:26\
    \ ------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e\
    [36mleftArr\e[0m = arr.copy\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m       value copy is not a member of List[Long] - did you\
    \ mean arr.coll?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmphyvhd9it.scala:27:27\
    \ ------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e\
    [36mrightArr\e[0m = arr.copy\n\e[31m\e[31m   |\e[0m                       ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m       value copy is not a member of List[Long] - did you\
    \ mean arr.coll?\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmphyvhd9it.scala:44:25\
    \ -----------------------------\e[0m\e[0m\n\e[31m44 |\e[0m            isRightShift\
    \ = !isRightShift\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m            Reassignment to val isRightShift\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E052] Type Error: /tmp/tmphyvhd9it.scala:47:24 -----------------------------\e\
    [0m\e[0m\n\e[31m47 |\e[0m                isFirst = !isFirst\n\e[31m\e[31m   |\e\
    [0m                ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                Reassignment\
    \ to val isFirst\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmphyvhd9it.scala:59:23\
    \ ------------------------\e[0m\e[0m\n\e[31m59 |\e[0m        \e[33mval\e[0m \e\
    [36marr2\e[0m = arr.copy\n\e[31m\e[31m   |\e[0m                   ^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m       value copy is not a member of List[Long] - did you mean\
    \ arr.coll?\n\e[31m\e[31m-- "
  stdout: ''
  timestamp: 1660009784
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        if (arr.isEmpty)\
    \ true\n        else {\n            val first = arr.head\n            val last\
    \ = arr.last\n            val newArr = arr.tail\n\n            val newFirst =\
    \ first.toLong\n            val newLast = last.toLong\n            val newNewArr\
    \ = newArr.map(_.toLong)\n\n            val diffToFirst = newLast - newFirst\n\
    \            val diffToLast = newFirst - newLast\n            val diffToNewArr\
    \ = newNewArr.map(_.toLong).sum\n\n            val maxDiff = Math.max(diffToFirst,\
    \ diffToLast)\n\n            if (diffToNewArr == maxDiff) moveOneBall(newNewArr)\
    \ else false\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmprr6rlo39.scala:46)\n\tat Problem.main(tmprr6rlo39.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009786
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        if (arr.isEmpty)\
    \ true\n        else {\n            val arrLen = arr.size\n            val sortedList\
    \ = arr.sortWith( (x,y) => y-x )\n            val firstIndex = 0\n           \
    \ val lastIndex = arrLen - 1\n            var lastVal = sortedList(lastIndex)\n\
    \            var isFirst = true\n            var shiftCount = 1\n            for\
    \ (i <- 0 to arrLen - 1 until (arrLen - lastIndex)) {\n                if (sortedList(i)\
    \ <= lastVal) {\n                    lastVal = sortedList(i)\n               \
    \     if (!isFirst) {\n                        shiftCount += 1\n             \
    \       }\n                    if (shiftCount > 1) {\n                       \
    \ return false\n                    }\n                    shiftCount = 1\n  \
    \              }\n                isFirst = false\n            }\n           \
    \ val newArray = arr.init.toArray\n            newArray(0) = sortedList(firstIndex)\n\
    \            newArray.update(1,lastVal)\n            newArray\n        }\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5_yf2vmg.scala:29:52\
    \ --------------------\e[0m\e[0m\n\e[31m29 |\e[0m            \e[33mval\e[0m \e\
    [36msortedList\e[0m = arr.sortWith( (\e[36mx\e[0m,\e[36my\e[0m) => y-x )\n\e[31m\e\
    [31m   |\e[0m                                                    ^^^\e[0m\n\e\
    [31m   |\e[0m                                                    Found:    Long\n\
    \e[31m   |\e[0m                                                    Required: Boolean\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp5_yf2vmg.scala:35:38\
    \ ------------------------\e[0m\e[0m\n\e[31m35 |\e[0m            \e[33mfor\e[0m\
    \ (i <- \e[31m0\e[0m to arrLen - \e[31m1\e[0m until (arrLen - lastIndex)) {\n\e\
    [31m\e[31m   |\e[0m                      ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0mvalue until is not a member of scala.collection.immutable.Range.Inclusive\
    \ - did you mean Inclusive.unzip?\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmp5_yf2vmg.scala:51:12 --------------------\e[0m\e[0m\n\e[31m51 |\e[0m\
    \            newArray\n\e[31m\e[31m   |\e[0m            ^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m            Found:    (newArray : Array[Long])\n\e[31m   |\e[0m    \
    \        Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660009784
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val m = arr.last\n\
    \        var j = arr.length - 1\n        var k = arr.head - 2\n        while(k\
    \ >= 0) {\n            if(arr(k) > arr(j)) {\n                val temp = arr(j)\n\
    \                arr(j) = arr(k)\n                arr(k) = temp\n            }\n\
    \            j = k\n            k -= 1\n        }\n        arr.head == m\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmplwj15khz.scala:30:19\
    \ --------------------\e[0m\e[0m\n\e[31m30 |\e[0m            \e[33mif\e[0m(arr(k)\
    \ > arr(j)) {\n\e[31m\e[31m   |\e[0m                   ^\e[0m\n\e[31m   |\e[0m\
    \                   Found:    (k : Long)\n\e[31m   |\e[0m                   Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmplwj15khz.scala:32:16\
    \ ------------------------\e[0m\e[0m\n\e[31m32 |\e[0m                arr(j) =\
    \ arr(k)\n\e[31m\e[31m   |\e[0m                ^^^\e[0m\n\e[31m   |\e[0m  value\
    \ update is not a member of List[Long] - did you mean arr.updated?\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmplwj15khz.scala:32:29 --------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m                arr(j) = arr(k)\n\e[31m\e[31m   |\e[0m\
    \                             ^\e[0m\n\e[31m   |\e[0m                        \
    \     Found:    (k : Long)\n\e[31m   |\e[0m                             Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmplwj15khz.scala:33:16\
    \ ------------------------\e[0m\e[0m\n\e[31m33 |\e[0m                arr(k) =\
    \ temp\n\e[31m\e[31m   |\e[0m                ^^^\e[0m\n\e[31m   |\e[0m  value\
    \ update is not a member of List[Long] - did you mean arr.updated?\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmplwj15khz.scala:35:16 --------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m            j = k\n\e[31m\e[31m   |\e[0m            \
    \    ^\e[0m\n\e[31m   |\e[0m                Found:    (k : Long)\n\e[31m   |\e\
    [0m                Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n5 errors found\n"
  stdout: ''
  timestamp: 1660009786
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        if(arr.isEmpty)\
    \ true\n        var shiftCounter = 0\n        while(true) {\n            arr.zip(arr.reverse).map(x\
    \ => (x._1 - x._2).abs).takeWhile(x => x > 0).foreach { x =>\n               \
    \ shiftCounter += 1\n                val tmpArr = List(x-1, x-2, x-3, x-4, x-5,\
    \ x-6, x-7)\n                val tmpArr2 = List(x-1, x-2, x-3, x-4, x-5, x-6,\
    \ x-7)\n                val tmpArr3 = List(x-1, x-2, x-3, x-4, x-5, x-6, x-7)\n\
    \                val tmpArr4 = List(x-1, x-2, x-3, x-4, x-5, x-6, x-7)\n     \
    \           val tmpArr5 = List(x-1, x-2, x-3, x-4, x-5, x-6, x-7)\n          \
    \      val tmpArr6 = List(x-1, x-2, x-3, x-4, x-5, x-6, x-7)\n               \
    \ val tmpArr7 = List(x-1, x-2, x-3, x-4, x-5, x-6, x-7)\n                val tmpArr8\
    \ = List(x-1, x-2, x-3, x-4, x-5, x-6, x-7)\n                val tmpArr9 = List(x-1,\
    \ x-2, x-3, x-4, x-5, x-6, x-7)\n                val tmpArr10 = List(x-1, x-2,\
    \ x-3, x-4, x-5, x-6, x-7)\n                val tmpArr11 = List(x-1, x-2, x-3,\
    \ x-4, x-5, x-6, x-7)\n                val tmpArr12 = List(x-1, x-2, x-3, x-4,\
    \ x-5, x-6, x-7)\n                val tmpArr13 = List(x-1, x-2, x-3, x-4, x-5,\
    \ x-6, x-7)\n                val tmpArr14 = List(x-1, x-2, x-3, x-4, x-5, x-6,\
    \ x-7)\n                val tmpArr15 = List(x-1, x-2, x-3, x-4, x-5, x-6, x-7)\n\
    \                val tmpArr16 = List(x-1, x-2, x-3, x-4, x-5, x-6, x-7)\n    \
    \            val tmpArr17 = List(x-1, x-2, x-3, x-4, x-5, x-6, x-7)\n        \
    \        val tmpArr18 = List(x-1, x-2, x-3, x-4, x-5, x-6, x-7)\n            \
    \    val tmpArr19 = List(x-1, x-2, x-3, x-4, x-5, x-6, x-7)\n                val\
    \ tmpArr20 = List(x-1, x-2, x-3, x-4, x-5, x-6, x-7)\n                val tmpArr21\
    \ = List(x-1, x-2, x-3, x-4, x-5, x-6, x-7)\n                val tmpArr22 = List(x-1,\
    \ x-2, \n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp_j5f7deg.scala:53:4 ----------------------------\e\
    [0m\e[0m\n\e[31m53 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp_j5f7deg.scala:63:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m63 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[33m\e[33m-- Warning:\
    \ /tmp/tmp_j5f7deg.scala:54:4 ----------------------------------------\e[0m\e\
    [0m\n\e[33m54 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e[35mArray\e\
    [0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m   |\e[0m\
    \    Line is indented too far to the left, or a `}` is missing\n\e[33m\e[33m--\
    \ [E129] Potential Issue Warning: /tmp/tmp_j5f7deg.scala:26:24 ----------------\e\
    [0m\e[0m\n\e[33m26 |\e[0m        \e[33mif\e[0m(arr.isEmpty) \e[31mtrue\e[0m\n\e\
    [33m\e[33m   |\e[0m                        ^^^^\e[0m\n\e[33m   |\e[0mA pure expression\
    \ does nothing in statement position; you may be omitting necessary parentheses\n\
    \e[33m   |\e[0m\n\e[33m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n2 warnings found\n2 errors found\n"
  stdout: ''
  timestamp: 1660009787
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        arr.size != 0 &&\
    \ (arr.head + 1) < arr.last\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp2t8ihbho.scala:29)\n\tat Problem.main(tmp2t8ihbho.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009792
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        var rightShiftCount\
    \ : Int = arr.size\n        while(rightShiftCount > 0) {\n            rightShiftCount\
    \ -= 1\n            val rightShiftOperation = RightShift(arr(0), rightShiftCount)\n\
    \            arr = RightShift(RightShift(arr, 1), rightShiftCount)\n         \
    \   if(!arr(0).compare(rightShiftOperation)){\n                return false\n\
    \            }\n            val lastIndex = arr.size - 1\n            if(lastIndex\
    \ == 0) {\n                return true\n            }\n            val lastElement\
    \ = arr(lastIndex)\n            val index = lastIndex - 1\n            arr(index)\
    \ = arr(lastIndex + 1)\n            arr(lastIndex + 1) = lastElement\n       \
    \ }\n        true\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpithqnfi4.scala:29:38 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m            \e[33mval\e[0m \e[36mrightShiftOperation\e\
    [0m = RightShift(arr(\e[31m0\e[0m), rightShiftCount)\n\e[31m\e[31m   |\e[0m  \
    \                                    ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        \
    \                              Not found: RightShift\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpithqnfi4.scala:30:18 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m            arr = RightShift(RightShift(arr, \e[31m1\e\
    [0m), rightShiftCount)\n\e[31m\e[31m   |\e[0m                  ^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                  Not found: RightShift\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpithqnfi4.scala:30:29 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m            arr = RightShift(RightShift(arr, \e[31m1\e\
    [0m), rightShiftCount)\n\e[31m\e[31m   |\e[0m                             ^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                             Not found: RightShift\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpithqnfi4.scala:31:15 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m            \e[33mif\e[0m(!arr(\e[31m0\e[0m).compare(rightShiftOperation)){\n\
    \e[31m\e[31m   |\e[0m               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m        value unary_! is not a member of Int - did you mean Int.unary_+?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpithqnfi4.scala:40:12 ------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m            arr(index) = arr(lastIndex + \e[31m1\e[0m)\n\
    \e[31m\e[31m   |\e[0m            ^^^\e[0m\n\e[31m   |\e[0m  value update is not\
    \ a member of List[Long] - did you mean arr.updated?\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmpithqnfi4.scala:41:12 ------------------------\e[0m\e[0m\n\
    \e[31m41 |\e[0m            arr(lastIndex + \e[31m1\e[0m) = lastElement\n\e[31m\e\
    [31m   |\e[0m      "
  stdout: ''
  timestamp: 1660009790
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        if(arr.isEmpty)\n\
    \            return true\n        val result = arr.map{x => x :: Nil}\n      \
    \  var shift :Int = 0\n        while(true) {\n            if(arr.size > 1){\n\
    \                var lastElement = result.last\n                var lastIndex\
    \ = lastElement.size - 1\n                val temp = lastElement.drop(lastIndex)\n\
    \                lastElement = lastElement.toList :+ lastElement(0)\n        \
    \        lastIndex = temp.size-1\n                lastElement.insert(0,lastElement(0))\n\
    \                lastElement.drop(lastIndex).foreach(x => x.size -= 1)\n     \
    \           lastElement(0) = lastElement(0)\n                lastElement.drop(lastIndex).foreach(x\
    \ => x.size += 1)\n                shift = lastIndex\n            }\n        \
    \    arr.tail.foreach(x => x.size += shift)\n            if(arr.head.toString.compareTo(arr.last.toString.reverse)\
    \ == 0)\n                return true\n            if(arr.isEmpty)\n          \
    \      return false\n            result.foreach(x => x.size -= shift)\n      \
    \  }\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp909vybj7.scala:37:28 ------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m                lastElement.insert(\e[31m0\e[0m,lastElement(\e\
    [31m0\e[0m))\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mvalue insert is not a member of List[Long] - did you mean List[Long].init?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp909vybj7.scala:38:59 ------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m                lastElement.drop(lastIndex).foreach(\e\
    [36mx\e[0m => x.size -= \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m                 \
    \                                        ^^^^^^\e[0m\n\e[31m   |\e[0m        \
    \                              value size is not a member of Long\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmp909vybj7.scala:39:16 ------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m                lastElement(\e[31m0\e[0m) = lastElement(\e\
    [31m0\e[0m)\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mvalue update is not a member of List[Long] - did you mean List[Long].updated?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp909vybj7.scala:40:59 ------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m                lastElement.drop(lastIndex).foreach(\e\
    [36mx\e[0m => x.size += \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m                 \
    \                                        ^^^^^^\e[0m\n\e[31m   |\e[0m        \
    \                              value size is not a member of Long\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmp909vybj7.scala:43:36 ------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m            arr.tail.foreach(\e[36mx\e[0m => x.size +=\
    \ shift)\n\e[31m\e[31m   |\e[0m                                  ^^^^^^\e[0m\n\
    \e[31m   |\e[0m                   value size is not a member of Long @uncheckedVariance\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp909vybj7.scala:48:39 ------------------------\e\
    [0m\e[0m\n\e[31m48 |\e[0m            result.foreach(\e[36mx\e[0m => x.size -=\
    \ shift)\n\e[31m\e[31m   |\e[0m                                ^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                  value -= is not a member of Int - did you mean\
    \ Int.!=?\n6 errors found\n"
  stdout: ''
  timestamp: 1660009793
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val arr = arr.toList\n\
    \        val lastIndex = arr.last\n        val currIndex = arr(0)\n        val\
    \ nums = arr.drop(1)\n        val shifts = nums.map(num => (num, currIndex))\n\
    \        def println(msg: String) = println(currIndex + msg)\n        val printlns\
    \ = println.map(x => x.toString)\n        var result = true\n        for(x <-\
    \ 0 until shifts.size)\n            if(!(shifts(x).get._2 <= currIndex)) {\n \
    \               currIndex = (shifts(x).get._2)\n                result = false\n\
    \            }\n        if(arr.isEmpty) {\n            printlns(\"The given list\
    \ is empty\")\n        } else {\n            printlns(\"The given list is not\
    \ non-decreasing order\")\n        }\n        result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp8k1hxldh.scala:26:18 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E044] Cyclic Error: /tmp/tmp8k1hxldh.scala:31:35 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mdef\e[0m \e[36mprintln\e[0m(\e[36mmsg\e\
    [0m: \e[35mString\e[0m) = println(currIndex + msg)\n\e[31m\e[31m   |\e[0m    \
    \                               ^\e[0m\n\e[31m   |\e[0m                Overloaded\
    \ or recursive \e[33mmethod\e[0m \e[35mprintln\e[0m needs return type\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E052] Type Error: /tmp/tmp8k1hxldh.scala:36:26 -----------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m                currIndex = (shifts(x).get._2)\n\e[31m\e\
    [31m   |\e[0m                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                Reassignment to val currIndex\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660009788
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val size = arr.size\n\
    \        val arr = arr\n        var i = 0\n        var j = size - 1\n        var\
    \ k = size\n        var m = size - 1\n        while (k > i) {\n            if\
    \ (arr(i) <= arr(i + 1)) {\n                var j = j + 1\n                arr(i)\
    \ = arr(i + 1)\n                arr(i + 1) = arr(j)\n                arr(j) =\
    \ arr(j)\n                i = i + 1\n                j = j - 1\n             \
    \   k = k - 1\n                m = m - 1\n            } else {\n             \
    \   i = i + 1\n                k = k - 1\n            }\n        }\n        if\
    \ (arr.isEmpty) {\n            return true\n        }\n        return false\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpy3sjgrim.scala:27:18 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr\n\e[31m\e\
    [31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                  Recursive\
    \ \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E045] Cyclic Error: /tmp/tmpy3sjgrim.scala:34:24 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m                \e[33mvar\e[0m \e[36mj\e[0m = j + \e\
    [31m1\e[0m\n\e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e\
    [0m                        Recursive \e[33mvariable\e[0m \e[35mj\e[0m needs type\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660009787
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        if( arr.isEmpty)\n\
    \            return true\n        val n = arr.size\n        // Find the position\
    \ of the last element of the list\n        // We will perform right shift operation\
    \ on it\n        // Find the position of the last element of the list\n      \
    \  val pos = (n-1).toInt\n        // Perform a right shift operation on that last\
    \ element\n        // Perform a right shift operation on that last element\n \
    \       val right = arr.apply(pos) \n        // Perform a right shift operation\
    \ on that last element\n        val left = arr.apply(pos-1)\n        val result\
    \ = right < left\n        // If result returns true then return true else return\
    \ false\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpen782f2p.scala:43)\n\tat Problem.main(tmpen782f2p.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009795
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val arr = arr.toList\n\
    \        var flag = 0\n        var i = 0\n        var j = 0\n        var k = 0\n\
    \        var temp = 0\n        while(i < arr.length){\n            if(arr(i) >\
    \ arr(j)){\n                flag = 0\n            }\n            if(arr(i) > arr(k)){\n\
    \                temp = arr(k)\n                arr(k) = arr(i)\n            \
    \    arr(i) = temp\n                k = k - 1\n                j = j + 1\n   \
    \         }\n            i = i + 1\n        }\n        if(flag == 0){\n      \
    \      flag = 1\n        }\n        if(flag == 1){\n            return true\n\
    \        }\n        return false\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp41pcqfr4.scala:26:18 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660009788
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        if(arr.isEmpty)\n\
    \            true\n        else if(arr.head==0)\n            true\n        else\
    \ {\n            val lst = arr\n            lst.sortWith(_<_)\n            val\
    \ lst_size = lst.size\n            val last_element = lst.last\n            val\
    \ arr_size = arr.size\n            val last_element_index = arr.indexOf(last_element)\n\
    \            val max_shift = math.min(arr_size-1,lst_size-last_element_index)\n\
    \            val max_shiftInArr = max_shift - 1\n            for(i <- 1 to max_shiftInArr)\
    \ {\n                lst.tail.foreach(x => arr.insert(x, i))\n               \
    \ arr.remove(last_element_index+i)\n                arr.insert(0,0)\n        \
    \        lst.tail.foreach(x => arr.insert(x, i+1))\n                lst.clear()\n\
    \                lst.foreach(x => arr.insert(x, 0))\n            }\n         \
    \   arr.lastOption.contains(last_element)\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpwtzls5e3.scala:40:42 ------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m                lst.tail.foreach(\e[36mx\e[0m => arr.insert(x,\
    \ i))\n\e[31m\e[31m   |\e[0m                                      ^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m     value insert is not a member of List[Long] - did you\
    \ mean arr.init?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpwtzls5e3.scala:41:20\
    \ ------------------------\e[0m\e[0m\n\e[31m41 |\e[0m                arr.remove(last_element_index+i)\n\
    \e[31m\e[31m   |\e[0m                ^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue remove\
    \ is not a member of List[Long], but could be made available as an extension method.\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might fix the problem:\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.seq\
    \ AsJavaList\n\e[31m   |\e[0m  import collection.convert.ImplicitConversionsToJava.seq\
    \ AsJavaList\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.collection\
    \ asJava\n\e[31m   |\e[0m  import collection.convert.ImplicitConversionsToJava.collection\
    \ asJava\n\e[31m   |\e[0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpwtzls5e3.scala:42:20\
    \ ------------------------\e[0m\e[0m\n\e[31m42 |\e[0m                arr.insert(\e\
    [31m0\e[0m,\e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m     value insert is not a member of List[Long] - did you mean\
    \ arr.init?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpwtzls5e3.scala:43:42\
    \ ------------------------\e[0m\e[0m\n\e[31m43 |\e[0m                lst.tail.foreach(\e\
    [36mx\e[0m => arr.insert(x, i+\e[31m1\e[0m))\n\e[31m\e[31m   |\e[0m          \
    \                            ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m     value insert\
    \ is not a member of List[Long] - did you mean arr.init?\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpwtzls5e3.scala:44:20 ------------------------\e[0m\e\
    [0m\n\e[31m44 |\e[0m                lst.clear()\n\e[31m\e[31m   |\e[0m       \
    \         ^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue clear is not a member of List[Long],\
    \ but could be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mO"
  stdout: ''
  timestamp: 1660009795
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        if (arr.isEmpty)\
    \ {\n            true\n        } else {\n            var counter = 0\n       \
    \     var temp = 0\n            var shiftCount = 0\n            var newArr: List[Long]\
    \ = Nil\n            while (counter < arr.length) {\n                temp = arr(counter)\n\
    \                counter = counter + 1\n                if (shiftCount == 0) {\n\
    \                    newArr += temp.toLong\n                } else {\n       \
    \             newArr += temp.toLong\n                    if (shiftCount == 1)\
    \ {\n                        newArr += temp.toLong\n                    } else\
    \ if (shiftCount == 2) {\n                        newArr += temp.toLong\n    \
    \                    newArr += temp.toLong\n                    }\n          \
    \      }\n                shiftCount = shiftCount + 1\n            }\n       \
    \     val set = new mutable.HashSet[Long](newArr)\n            val sortedArr2\
    \ = newArr.sort\n            val sortedArr = sortedArr2.reverse\n            if\
    \ (set.size == sortedArr.size) {\n                true\n            } else {\n\
    \                false\n            }\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpciaqtias.scala:34:26\
    \ --------------------\e[0m\e[0m\n\e[31m34 |\e[0m                temp = arr(counter)\n\
    \e[31m\e[31m   |\e[0m                       ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                       Found:    Long\n\e[31m   |\e[0m                      \
    \ Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpciaqtias.scala:37:27\
    \ ------------------------\e[0m\e[0m\n\e[31m37 |\e[0m                    newArr\
    \ += temp.toLong\n\e[31m\e[31m   |\e[0m                    ^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m    value += is not a member of List[Long] - did you mean List[Long].!=?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpciaqtias.scala:39:27 ------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m                    newArr += temp.toLong\n\e[31m\e[31m\
    \   |\e[0m                    ^^^^^^^^^\e[0m\n\e[31m   |\e[0m    value += is not\
    \ a member of List[Long] - did you mean List[Long].!=?\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpciaqtias.scala:41:31 ------------------------\e[0m\e\
    [0m\n\e[31m41 |\e[0m                        newArr += temp.toLong\n\e[31m\e[31m\
    \   |\e[0m                        ^^^^^^^^^\e[0m\n\e[31m   |\e[0m    value +=\
    \ is not a member of List[Long] - did you mean List[Long].!=?\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpciaqtias.scala:43:31 ------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m                        newArr += temp.toLong\n\e[31m\e\
    [31m   |\e[0m                        ^^^^^^^^^\e[0m\n\e[31m   |\e[0m    value\
    \ += is not a member of List[Long] - did you mean List[Long].!=?\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpciaqtias.scala:44:31 ------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m                        newArr += temp.toLong\n\e[31m\e\
    [31m   |\e[0m                        ^^^^^^^^^\e[0m\n\e[31m   |\e[0m    value\
    \ += is not a member of List[Long] - did you mean List[Long].!=?\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpciaqtias.scala:49:26 ------------------------\e\
    [0m\e[0m\n\e[31m49 |\e[0m            \e[33mval\e[0m \e[36mset\e[0m = \e[33mnew\e\
    [0m muta"
  stdout: ''
  timestamp: 1660009795
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n       val result = mutable.Stack[Long]()\n\
    \       var last = -1\n       for ( i <- arr.indices) {\n          last = Math.max(last,\
    \ arr(i))\n          result += arr(i).rightShift()\n       }\n       if (arr.isEmpty)\
    \ true\n       else moveOneBall(result)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpk30ha1fs.scala:26:20 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m       \e[33mval\e[0m \e[36mresult\e[0m = mutable.Stack[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpk30ha1fs.scala:29:35 --------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m          last = Math.max(last, arr(i))\n\e[31m\e[31m\
    \   |\e[0m                                ^^^^^^\e[0m\n\e[31m   |\e[0m       \
    \                         Found:    Long\n\e[31m   |\e[0m                    \
    \            Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660009793
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = (arr.length\
    \ >> 1)\n        var i = 0\n        var j = 0\n        while (i < n) {\n     \
    \       val swap = arr(i)\n            arr(i) = arr(j)\n            arr(j) = swap\n\
    \            i += 1 \n            j += 1 \n        }\n        arr.length <= n\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp77yokcy0.scala:31:12 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m            arr(i) = arr(j)\n\e[31m\e[31m   |\e[0m  \
    \          ^^^\e[0m\n\e[31m   |\e[0m  value update is not a member of List[Long]\
    \ - did you mean arr.updated?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp77yokcy0.scala:32:12\
    \ ------------------------\e[0m\e[0m\n\e[31m32 |\e[0m            arr(j) = swap\n\
    \e[31m\e[31m   |\e[0m            ^^^\e[0m\n\e[31m   |\e[0m  value update is not\
    \ a member of List[Long] - did you mean arr.updated?\n2 errors found\n"
  stdout: ''
  timestamp: 1660009795
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        if(arr.isEmpty)\
    \ true\n        else if(arr(0) > arr(1)) moveOneBall(arr.tail, arr)\n        else\
    \ moveOneBall(arr.tail, arr.head::arr)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpgfc3pkzj.scala:27:45\
    \ --------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33melse\e[0m \e[33mif\e\
    [0m(arr(\e[31m0\e[0m) > arr(\e[31m1\e[0m)) moveOneBall(arr.tail, arr)\n\e[31m\e\
    [31m   |\e[0m                                             ^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                      Found:    \e[1m\e[31m(\e\
    [0mList[Long\e[1m\e[31m]\e[0m\e[1m\e[31m,\e[0m\e[1m\e[31m \e[0m\e[1m\e[31mList\e\
    [0m\e[1m\e[31m[\e[0m\e[1m\e[31mLong\e[0m]\e[1m\e[31m)\e[0m\n\e[31m   |\e[0m  \
    \                                    Required: List[Long]\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpgfc3pkzj.scala:28:25 --------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33melse\e[0m moveOneBall(arr.tail, arr.head::arr)\n\
    \e[31m\e[31m   |\e[0m                         ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                         Found:    \e[1m\e[31m(\e[0mList[Long\e[1m\e\
    [31m]\e[0m\e[1m\e[31m,\e[0m\e[1m\e[31m \e[0m\e[1m\e[31mList\e[0m\e[1m\e[31m[\e\
    [0m\e[1m\e[31mLong\e[0m]\e[1m\e[31m)\e[0m\n\e[31m   |\e[0m                   \
    \      Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660009794
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        require(arr.isEmpty\
    \ || arr.nonEmpty)\n        if (arr.isEmpty) true else arr.sortRight.head == arr(0)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmppkz3c0br.scala:27:39 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mif\e[0m (arr.isEmpty) \e[31mtrue\e[0m \e\
    [33melse\e[0m arr.sortRight.head == arr(\e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m \
    \                                  ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue sortRight\
    \ is not a member of List[Long] - did you mean arr.foldRight?\n1 error found\n"
  stdout: ''
  timestamp: 1660009794
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val N = (arr.head\
    \ + arr.tail).hashCode\n        val numOfRightShift = 2\n        val currentMax\
    \ = arr.max\n        var currentMin = arr.min\n        // check all elements is\
    \ sorted or not\n        for (i = 1 until N) {\n            // check all elements\
    \ is sorted in increasing order or not\n            currentMax = (arr.max).compareTo((arr.min))\n\
    \            if (currentMax == 0)\n                return true\n            currentMin\
    \ = (arr.min).compareTo((arr.max))\n            // check right shift operation\
    \ is performed or not\n            if (numOfRightShift > currentMax) {\n     \
    \           numOfRightShift -= 1\n                val tmp = currentMin\n     \
    \           currentMin = arr.min\n                arr.min = tmp\n            \
    \    val tmp = currentMax\n                currentMax = arr.max\n            \
    \    arr.max = tmp\n            }\n        }\n        return false\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp0d0t4_og.scala:31:15 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mfor\e[0m (i = \e[31m1\e[0m until N) {\n\
    \e[31m\e[31m   |\e[0m               ^\e[0m\n\e[31m   |\e[0m               ')'\
    \ expected, but '=' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp0d0t4_og.scala:31:28\
    \ ---------------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mfor\e[0m\
    \ (i = \e[31m1\e[0m until N) {\n\e[31m\e[31m   |\e[0m                        \
    \    ^\e[0m\n\e[31m   |\e[0m                            '<-' expected, but '{'\
    \ found\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmp0d0t4_og.scala:26:26 -----------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mN\e[0m = (arr.head + arr.tail).hashCode\n\
    \e[31m\e[31m   |\e[0m                 ^^^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of\
    \ the overloaded alternatives of \e[33mmethod\e[0m \e[35m+\e[0m in \e[33mclass\e\
    [0m \e[35mLong\e[0m with types\n\e[31m   |\e[0m (x: Double): Double\n\e[31m  \
    \ |\e[0m (x: Float): Float\n\e[31m   |\e[0m (x: Long): Long\n\e[31m   |\e[0m (x:\
    \ Int): Long\n\e[31m   |\e[0m (x: Char): Long\n\e[31m   |\e[0m (x: Short): Long\n\
    \e[31m   |\e[0m (x: Byte): Long\n\e[31m   |\e[0m (x: String): String\n\e[31m \
    \  |\e[0mmatch arguments ((arr.tail : => List[Long @uncheckedVariance]))\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp0d0t4_og.scala:47:9 -------------------------\e\
    [0m\e[0m\n\e[31m47 |\e[0m        }\n\e[31m\e[31m   |\e[0m         ^\e[0m\n\e[31m\
    \   |\e[0mvalue foreach is not a member of Null, but could be made available as\
    \ an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports\
    \ might fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import Option.option2Iterable\n\
    \e[31m   |\e[0m  import collection.LazyZip2.lazyZip2ToIterable\n\e[31m   |\e[0m\
    \  import collection.LazyZip3.lazyZip3ToIterable\n\e[31m   |\e[0m  import collection.LazyZip4.lazyZip4ToIterable\n\
    \e[31m   |\e[0m  import collection.convert.ImplicitConversions.list asScalaBuffer\n\
    \e[31m   |\e[0m  import collection.convert.ImplicitConversions.properties AsScalaMap\n\
    \e[31m   |\e[0m  import collection.convert.ImplicitConversions.enumeration AsScalaIterator\n\
    \e[3"
  stdout: ''
  timestamp: 1660009797
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val size = arr.size\n\
    \        val count = size -1\n        val flag = for(i <- 0 until count) yield\
    \ {\n            val temp = arr(i)\n            arr.updated(i, arr(i+1))\n   \
    \         arr.updated(i+1, temp)\n        }\n        val ans = flag\n        if(!ans.isEmpty\
    \ && ans.size == size) {\n            var temp = 0\n            for(i <- 0 until\
    \ count) {\n                if(arr(i) != temp) {\n                    return true\n\
    \                }\n                temp = arr(i + 1)\n            }\n       \
    \ }\n        return false\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp67soi8sq.scala:40:26\
    \ --------------------\e[0m\e[0m\n\e[31m40 |\e[0m                temp = arr(i\
    \ + \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m                       ^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                       Found:    Long\n\e[31m   |\e[0m        \
    \               Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009796
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val l = arr.length\n\
    \        var max = 0\n        var shift = 0\n        var count = 1\n        val\
    \ arr = arr.reverse\n        var a = arr.head\n        var b = arr.head\n\n  \
    \      arr.foreach { x => if (x < a && x > b) max = max else max = x }\n     \
    \   if (max != arr.head) false\n        arr.foreach { x =>\n            if (x\
    \ > max) shift += 1\n            else shift -= 1\n            if (shift < 0) return\
    \ false\n            if (shift == 0) a = x\n        }\n        true\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpyxxa46ao.scala:30:18 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.reverse\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [33m\e[33m-- [E129] Potential Issue Warning: /tmp/tmpyxxa46ao.scala:35:29 ----------------\e\
    [0m\e[0m\n\e[33m35 |\e[0m        \e[33mif\e[0m (max != arr.head) \e[31mfalse\e\
    [0m\n\e[33m\e[33m   |\e[0m                             ^^^^^\e[0m\n\e[33m   |\e\
    [0mA pure expression does nothing in statement position; you may be omitting necessary\
    \ parentheses\n\e[33m   |\e[0m\n\e[33m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 warning found\n1 error found\n"
  stdout: ''
  timestamp: 1660009792
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n      val size = arr.size\n\
    \      val arr = arr.toList\n      val head = arr(0)\n      val rest = arr.tail\n\
    \      val lastElement = rest.reverse\n      val size = rest.size\n      val arr\
    \ = rest.toList\n      val headList = arr.toList\n      val arr1 = arr.toList\n\
    \      val headTail = arr1.tail\n      val arr2 = arr1.toList\n      val arr1Tail\
    \ = arr2.tail\n      val arr3 = arr2.toList\n      val headTailTail = arr3.tail\n\
    \      val arr4 = arr3.toList\n      val arr3Tail = arr4.tail\n      val arr5=\
    \ arr4.toList\n      val headTailTailTail = arr5.tail\n      val arr6 = arr5.toList\n\
    \      val arr4Tail = arr6.toList\n      val arr6Tail = arr4Tail.toList\n    \
    \  val headTailTailTailTail = arr6Tail.toList\n      val arr7= arr6.toList\n \
    \     val arr6TailTail = arr7.toList\n      val headTailTailTailTailTail = arr6TailTail.toList\n\
    \      val arr8= arr6Tail.toList\n      val arr6TailTailTail = arr8.toList\n \
    \     val headTailTailTailTailTailTail = arr6TailTailTail.toList\n      val arr9=\
    \ arr6TailTail.toList\n      val arr6TailTailTailTail = arr9.toList\n      val\
    \ headTailTailTailTailTailTailTail = arr6TailTailTailTail.toList\n      val arr10=\
    \ arr6TailTailTail.toList\n      val arr6TailTailTailTailTail = arr10.toList\n\
    \      val headTailTailTailTailTailTailTail = arr6TailTailTailTailTail.toList\n\
    \      val arr11= arr6TailTailTailTail.toList\n      val arr6TailTailTailTailTailTail\
    \ = arr11.toList\n      val headTailTailTailTailTailTailTailTail = arr6TailTailTailTailTailTail.toList\n\
    \      val arr12= arr6TailTailTailTailTail.toList\n      val arr6TailTailTailTailTailTailTail\
    \ = arr12.toList\n      val headTailTailTailTailTailTailTailTailTail = arr6TailTailTailTailTailTailTailTail.toList\n\
    \      val arr13= arr6TailTailTailTailTail.toList\n      val arr6TailTailTailTailTailTailTailTail\
    \ = arr13\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp83bv_z9_.scala:31:10 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m      \e[33mval\e[0m \e[36msize\e[0m = rest.size\n\e\
    [31m\e[31m   |\e[0m      ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0msize is already\
    \ defined as \e[33mvalue\e[0m \e[35msize\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp83bv_z9_.scala:32:10 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m      \e[33mval\e[0m \e[36marr\e[0m = rest.toList\n\e\
    [31m\e[31m   |\e[0m      ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp83bv_z9_.scala:59:10 ---------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m      \e[33mval\e[0m \e[36mheadTailTailTailTailTailTailTail\e\
    [0m = arr6TailTailTailTailTail.toList\n\e[31m\e[31m   |\e[0m      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mheadTailTailTailTailTailTailTail is already defined as \e\
    [33mvalue\e[0m \e[35mheadTailTailTailTailTailTailTail\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp83bv_z9_.scala:27:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m27 |\e[0m      \e[33mval\e[0m \e\
    [36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m                ^\e[0m\n\e[31m\
    \   |\e[0m                Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp83bv_z9_.scala:68:5\
    \ ---------------------\e[0m\e[0m\n\e[31m68 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n5 errors found\n"
  stdout: ''
  timestamp: 1660009796
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        var newList = ListBuffer.empty[Long]\n\
    \        var i = 0\n        while(i < arr.size){\n            newList += arr(i)\n\
    \            i ++= 1 // we increase i by 1 before performing right shift\n   \
    \     }\n        var j = 0\n        var k = arr.size - 1\n        while(j < arr.size){\n\
    \            val temp = newList(k)\n            newList += temp\n            k\
    \ -= 1\n            j += 1\n        }\n        newList += arr(k)\n        val\
    \ unique = newList.distinct\n        unique.toList.forall{x => x != arr(k)}\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpzyadgk49.scala:30:14 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m            i ++= \e[31m1\e[0m \e[34m// we increase i\
    \ by 1 before performing right shift\e[0m\n\e[31m\e[31m   |\e[0m            ^^^^^\e\
    [0m\n\e[31m   |\e[0m            value ++= is not a member of Int\n1 error found\n"
  stdout: ''
  timestamp: 1660009797
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        var count = 0\n\
    \        var lastElement = 0\n        var lastElementCount = 0\n        var lastElementCountCheck\
    \ = 0\n        var lastElement2 = -1\n        var lastElement2Count = 0\n    \
    \    var lastElement2CountCheck = 0\n        var lastElement3 = -1\n        var\
    \ lastElement3Count = 0\n        var lastElement3CountCheck = 0\n        while(count\
    \ < arr.length) {\n            if(count == 0) {\n                lastElement =\
    \ arr(count)\n                lastElementCount = lastElement\n               \
    \ lastElementCountCheck = lastElement\n                lastElement2 = -1\n   \
    \             lastElement2Count = 0\n                lastElement2CountCheck =\
    \ 0\n                lastElement3 = -1\n                lastElement3Count = 0\n\
    \                lastElement3CountCheck = 0\n            }\n            if(count\
    \ % 2 == 0) {\n                if(lastElementCount < arr(count)) {\n         \
    \           lastElement2 = arr(count)\n                    lastElement2Count =\
    \ lastElement2\n                    lastElement2CountCheck = lastElement2\n  \
    \                  lastElement3 = -1\n                    lastElement3Count =\
    \ 0\n                    lastElement3CountCheck = 0\n                }\n     \
    \           if(lastElementCountCheck < lastElementCount) {\n                 \
    \   lastElement2 = lastElement2Count\n                    lastElement2Count =\
    \ lastElement2\n                    lastElement2CountCheck = lastElement2\n  \
    \                  lastElement3 = -1\n                    lastElement3Count =\
    \ 0\n                    lastElement3CountCheck = 0\n                }\n     \
    \           lastElement = lastElement2\n                lastElementCount = lastElement2\n\
    \                lastElementCountCheck = lastElement2\n                lastElement2\
    \ = -1\n                lastElement2Count = 0\n                lastElement2CountCheck\
    \ = 0\n            } else {\n                if(lastElementCount < arr(count))\
    \ {\n                    lastElement3 = arr(count)\n                    lastElement3Count\
    \ = lastElement3\n                    lastElement3CountCheck = lastElement3\n\
    \                    lastElement2 = -1\n                    lastElement2Count\
    \ = 0\n                    lastElement2CountCheck = 0\n                    lastElement3\
    \ = -1\n                    lastElement3Count = 0\n                    lastElement3CountCheck\
    \ = 0\n                }\n                if(lastElementCountCheck < lastElementCount)\
    \ {\n                    lastElement3 = lastElement3Count\n                  \
    \  lastElement3Count = lastElement3\n                    lastElement3CountCheck\
    \ = lastElement3\n                    lastElement2 = -1\n                    lastElement2Count\
    \ = 0\n                    lastElement2CountCheck = 0\n                    lastElement3\
    \ = -1\n                    lastElement3Count = 0\n                    lastElement3CountCheck\
    \ = 0\n                }\n                lastElement = lastElement3\n       \
    \         lastElementCount = lastElement3\n                lastElementCountCheck\
    \ = lastElement3\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpl_74fl1x.scala:107:0 ---------------------------\e\
    [0m\e[0m\n\e[31m107 |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m'}'\
    \ expected, but eof found\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpl_74fl1x.scala:38:33\
    \ --------------------\e[0m\e[0m\n\e[31m38 |\e[0m                lastElement =\
    \ arr(count)\n\e[31m\e[31m   |\e[0m                              ^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                              Found:    Long\n\e[31m   |\e\
    [0m                              Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpl_74fl1x.scala:50:38 --------------------\e\
    [0m\e[0m\n\e[31m50 |\e[0m                    lastElement2 = arr(count)\n\e[31m\e\
    [31m   |\e[0m                                   ^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                                   Found:    Long\n\e[31m   |\e[0m        \
    \                           Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpl_74fl1x.scala:73:38 --------------------\e[0m\e\
    [0m\n\e[31m73 |\e[0m                    lastElement3 = arr(count)\n\e[31m\e[31m\
    \   |\e[0m                                   ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                                   Found:    Long\n\e[31m   |\e[0m          \
    \                         Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[33m\e[33m-- Warning:\
    \ /tmp/tmpl_74fl1x.scala:98:4 ----------------------------------------\e[0m\e\
    [0m\n\e[33m98 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e[35mArray\e\
    [0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m   |\e[0m\
    \    Line is indented too far to the left, or a `}` is missing\n1 warning found\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1660009797
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val N = arr.length\n\
    \        if(N == 0) true else {\n            val left = arr.head\n           \
    \ val right = arr.last\n            val sortedLeft = new Array[Long](N - 1).fill(left.toLong)\n\
    \            val sortedRight = new Array[Long](N - 1).fill(right.toLong)\n   \
    \         val list = new Array[Long](N).fill(N.toLong)\n            val results\
    \ = new Array[Boolean](N)\n            for(i <- 0 to N-1) results(i) = false\n\
    \            for(i=N-1 to 0 by -1) {\n                list(i) = arr(i)\n     \
    \           val tempLeft = new Array[Long](N - 1).fill(left.toLong)\n        \
    \        val tempRight = new Array[Long](N - 1).fill(right.toLong)\n         \
    \       for(j <- 0 to N-1){\n                    if(j == i) { \n             \
    \           results(j) = true\n                        sortedRight(j) = N.toLong\n\
    \                        sortedLeft(j) = left.toLong\n                    } else\
    \ if(j > i){\n                        val temp = list(i-1)\n                 \
    \       list(i-1) = list(j)\n                        list(j) = temp\n        \
    \                val tempLeft = new Array[Long](N - 1).fill(left.toLong)\n   \
    \                     val tempRight = new Array[Long](N - 1).fill(right.toLong)\n\
    \                        for(k <- 0 to N-1){\n                            if(k\
    \ > j && k <= i){\n                                if(k > i) {\n             \
    \                       sortedRight(k) = tempRight(k)\n                      \
    \          }\n                                if(k <= j) {\n                 \
    \                   sortedLeft(k) = tempLeft(k)\n                            \
    \    }\n                                if(k > j && k <= i) {\n              \
    \                      val temp = list(i-1)\n                                \
    \    list(i-1) = list(i-2)\n                                    list(i-2) = temp\n\
    \                                    val tempLeft = new Array[Long](N - 1).fill(left.toLong)\n\
    \                                    val tempRight = new Array[Long](N - 1).fill(right.toLong)\n\
    \                                    for(l <- 0 to N-1){\n                   \
    \                     if(l > j && l <= i) {\n                                \
    \            sortedRight(l) = tempRight(l)\n                                 \
    \           sortedLeft(l) = tempLeft(l)\n                                    \
    \        tempLeft(l) = 0l\n                                            tempRight(l)\
    \ = 0l\n                                        }\n                          \
    \          }\n                                }\n                            }\n\
    \                        }\n                    }\n                }\n       \
    \     }\n            if(results.toList.mkString.equals(List(N.toLong, left.toLong,\
    \ right.toLong).sortedWith(_ < _))) true else false\n        }\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpsyiy5iu2.scala:35:17 ---------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m            \e[33mfor\e[0m(i=N-\e[31m1\e[0m to \e[31m0\e\
    [0m by -\e[31m1\e[0m) {\n\e[31m\e[31m   |\e[0m                 ^\e[0m\n\e[31m\
    \   |\e[0m                 ')' expected, but '=' found\n\e[31m\e[31m-- [E040]\
    \ Syntax Error: /tmp/tmpsyiy5iu2.scala:35:34 ---------------------------\e[0m\e\
    [0m\n\e[31m35 |\e[0m            \e[33mfor\e[0m(i=N-\e[31m1\e[0m to \e[31m0\e[0m\
    \ by -\e[31m1\e[0m) {\n\e[31m\e[31m   |\e[0m                                 \
    \ ^\e[0m\n\e[31m   |\e[0m                                  '<-' expected, but\
    \ '{' found\n\e[31m\e[31m-- [E020] Syntax Error: /tmp/tmpsyiy5iu2.scala:78:108\
    \ --------------------------\e[0m\e[0m\n\e[31m78 |\e[0m            \e[33mif\e\
    [0m(results.toList.mkString.equals(List(N.toLong, left.toLong, right.toLong).sortedWith(_\
    \ < _))) \e[31mtrue\e[0m \e[33melse\e[0m \e[31mfalse\e[0m\n\e[31m\e[31m   |\e\
    [0m                                                                          \
    \                                  ^^^^\e[0m\n\e[31m   |\e[0m                \
    \                                    \e[33myield\e[0m or \e[33mdo\e[0m expected\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpsyiy5iu2.scala:30:52\
    \ ------------------------\e[0m\e[0m\n\e[31m30 |\e[0m            \e[33mval\e[0m\
    \ \e[36msortedLeft\e[0m = \e[33mnew\e[0m \e[35mArray\e[0m[\e[35mLong\e[0m](N -\
    \ \e[31m1\e[0m).fill(left.toLong)\n\e[31m\e[31m   |\e[0m                     \
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                   \
    \          value fill is not a member of Array[Long]\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmpsyiy5iu2.scala:31:53 ------------------------\e[0m\e[0m\n\
    \e[31m31 |\e[0m            \e[33mval\e[0m \e[36msortedRight\e[0m = \e[33mnew\e\
    [0m \e[35mArray\e[0m[\e[35mLong\e[0m](N - \e[31m1\e[0m).fill(right.toLong)\n\e\
    [31m\e[31m   |\e[0m                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                              value fill is not a member of\
    \ Array[Long]\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmps"
  stdout: ''
  timestamp: 1660009799
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val count = new\
    \ scala.collection.mutable.HashMap[Long, Int]\n        for (i <- arr.indices)\
    \ {\n            count.update(arr(i), count.getOrElse(arr(i), 0) + 1l)\n     \
    \   }\n        for (i <- 1 to count.getOrElse(arr(0), 0).toInt) {\n          \
    \  if (count.getOrElse(arr(arr.size - i), 0) > count.getOrElse(arr(arr.size -\
    \ i - 1), 0)) {\n                val temp = arr(i)\n                arr(i) = arr(arr.size\
    \ - i)\n                arr(arr.size - i) = temp\n            }\n        }\n \
    \       arr(0) = 0\n        arr(arr.size - 1) = 0\n        if (arr.size != 0)\
    \ (count.getOrElse(arr(0), 0) > count.getOrElse(arr(arr.size - 1), 0)) else true\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpupg1v_jv.scala:28:33\
    \ --------------------\e[0m\e[0m\n\e[31m28 |\e[0m            count.update(arr(i),\
    \ count.getOrElse(arr(i), \e[31m0\e[0m) + \e[31m1l\e[0m)\n\e[31m\e[31m   |\e[0m\
    \                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                                 Found:    Long\n\e[31m   |\e[0m   \
    \                              Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpupg1v_jv.scala:33:16 ------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m                arr(i) = arr(arr.size - i)\n\e[31m\e\
    [31m   |\e[0m                ^^^\e[0m\n\e[31m   |\e[0m  value update is not a\
    \ member of List[Long] - did you mean arr.updated?\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmpupg1v_jv.scala:34:16 ------------------------\e[0m\e[0m\n\
    \e[31m34 |\e[0m                arr(arr.size - i) = temp\n\e[31m\e[31m   |\e[0m\
    \                ^^^\e[0m\n\e[31m   |\e[0m  value update is not a member of List[Long]\
    \ - did you mean arr.updated?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpupg1v_jv.scala:37:8\
    \ -------------------------\e[0m\e[0m\n\e[31m37 |\e[0m        arr(\e[31m0\e[0m)\
    \ = \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m        ^^^\e[0m\n\e[31m   |\e[0m  value\
    \ update is not a member of List[Long] - did you mean arr.updated?\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpupg1v_jv.scala:38:8 -------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m        arr(arr.size - \e[31m1\e[0m) = \e[31m0\e[0m\n\
    \e[31m\e[31m   |\e[0m        ^^^\e[0m\n\e[31m   |\e[0m  value update is not a\
    \ member of List[Long] - did you mean arr.updated?\n5 errors found\n"
  stdout: ''
  timestamp: 1660009800
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        if(arr.isEmpty)\
    \ true\n        else {\n            var i = 0\n            var j = 0\n       \
    \     for(i <- 1 to arr.length) {\n                j = 0\n                while(j\
    \ < arr.length && arr(i) > arr(j)) {\n                    j++\n              \
    \  }\n                if((j - i) > 1) break\n                arr(j) = arr(j)\n\
    \                arr(i) = arr(i)\n                i = j\n            }\n     \
    \       return arr.nonEmpty && moveOneBall(arr.init)\n        }\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpd6i8t_gn.scala:33:23 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m                    j++\n\e[31m\e[31m   |\e[0m      \
    \                 ^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpd6i8t_gn.scala:35:32 ------------------------\e[0m\e[0m\n\e[31m35 |\e\
    [0m                \e[33mif\e[0m((j - i) > \e[31m1\e[0m) break\n\e[31m\e[31m \
    \  |\e[0m                                ^^^^^\e[0m\n\e[31m   |\e[0m         \
    \                       Not found: break\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpd6i8t_gn.scala:36:16 ------------------------\e[0m\e\
    [0m\n\e[31m36 |\e[0m                arr(j) = arr(j)\n\e[31m\e[31m   |\e[0m   \
    \             ^^^\e[0m\n\e[31m   |\e[0m  value update is not a member of List[Long]\
    \ - did you mean arr.updated?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpd6i8t_gn.scala:37:16\
    \ ------------------------\e[0m\e[0m\n\e[31m37 |\e[0m                arr(i) =\
    \ arr(i)\n\e[31m\e[31m   |\e[0m                ^^^\e[0m\n\e[31m   |\e[0m  value\
    \ update is not a member of List[Long] - did you mean arr.updated?\n\e[31m\e[31m--\
    \ [E052] Type Error: /tmp/tmpd6i8t_gn.scala:38:18 -----------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m                i = j\n\e[31m\e[31m   |\e[0m        \
    \        ^^^^^\e[0m\n\e[31m   |\e[0m                Reassignment to val i\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n5 errors found\n"
  stdout: ''
  timestamp: 1660009799
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val sorted = arr.toList\n\
    \        val sortedSet = sorted.toSet\n        val sortedSize = new scala.collection.mutable.HashSet[Long]()\n\
    \        val lastSorted = 0\n        val found = new scala.collection.mutable.HashSet[Long]()\n\
    \        for(i <- sorted.size) {\n            val nextSorted = i + 1\n       \
    \     val nextSortedSize = sorted.size - i\n            val nextLastSortedSize\
    \ = lastSorted + nextSortedSize\n            if(lastSorted < nextLastSortedSize)\
    \ {\n                sortedSize += nextSortedSize\n                found.add(nextSorted)\n\
    \            } else {\n                val nextLastSorted = lastSorted + nextSortedSize\n\
    \                if(!found.contains(nextLastSorted)) {\n                    val\
    \ j = nextSorted - 1\n                    while(!found.contains(j)) {\n      \
    \                  sortedSize += sorted.size - j\n                        found.add(j)\n\
    \                        j -= 1\n                    }\n                    val\
    \ k = j + 1\n                    while(!found.contains(k)) {\n               \
    \         sortedSize += sorted.size - k\n                        found.add(k)\n\
    \                        k += 1\n                    }\n                    val\
    \ k = nextLastSorted\n                    while(!found.contains(k)) {\n      \
    \                  sortedSize += nextSortedSize\n                        found.add(k)\n\
    \                        k += 1\n                    }\n                    val\
    \ j = nextSorted + 1\n                    while(!found.contains(j)) {\n      \
    \                  sortedSize += nextSortedSize\n                        found.add(j)\n\
    \                        j += 1\n                    }\n                    if(sortedSize\
    \ < nextSortedSize) {\n                        lastSorted = nextLastSorted\n \
    \                   }\n                }\n            }\n        }\n        val\
    \ listSize = new scala.collection.mutable.HashSet[Long]()\n        for(i <- sorted.size)\
    \ {\n            listSize += sorted.size - i\n        }\n        val listSizeMax\
    \ = listSize.max\n        val listSizeMin = listSize.min\n        val listSizeDifference\
    \ = listSizeMax - listSizeMin\n        val sortedDifference = sortedSize.max -\
    \ sortedSize.min\n        val totalDifference = sortedDifference * sortedSize.size\
    \ / listSize\n        return ((sortedDifference == 0) && (listSizeDifference ==\
    \ 0) && (totalDifference == 0))\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpo5dutshi.scala:31:17 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mfor\e[0m(i <- sorted.size) {\n\e[31m\e\
    [31m   |\e[0m                 ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m              \
    \   value foreach is not a member of Int\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpo5dutshi.scala:72:17 ------------------------\e[0m\e[0m\n\e[31m72 |\e\
    [0m        \e[33mfor\e[0m(i <- sorted.size) {\n\e[31m\e[31m   |\e[0m         \
    \        ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                 value foreach is not\
    \ a member of Int\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpo5dutshi.scala:79:65\
    \ -----------------------------\e[0m\e[0m\n\e[31m79 |\e[0m        \e[33mval\e\
    [0m \e[36mtotalDifference\e[0m = sortedDifference * sortedSize.size / listSize\n\
    \e[31m\e[31m   |\e[0m                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e\
    [35m/\e[0m in \e[33mclass\e[0m \e[35mLong\e[0m with types\n\e[31m   |\e[0m (x:\
    \ Double): Double\n\e[31m   |\e[0m (x: Float): Float\n\e[31m   |\e[0m (x: Long):\
    \ Long\n\e[31m   |\e[0m (x: Int): Long\n\e[31m   |\e[0m (x: Char): Long\n\e[31m\
    \   |\e[0m (x: Short): Long\n\e[31m   |\e[0m (x: Byte): Long\n\e[31m   |\e[0mmatch\
    \ arguments ((listSize : scala.collection.mutable.HashSet[Long]))\n3 errors found\n"
  stdout: ''
  timestamp: 1660009801
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val l = arr.last\n\
    \        val result = arr\n        var left = 2\n        while (left != 0) {\n\
    \            arr = (l :: arr)\n            left -= 1\n        }\n        if (l\
    \ < arr.last) false\n        else true\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmpk5hal3b6.scala:30:16 -----------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m            arr = (l :: arr)\n\e[31m\e[31m   |\e[0m \
    \           ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            Reassignment to\
    \ val arr\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009798
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        if(arr.isEmpty)\
    \ {\n            return true\n        }\n\n        val arr = arr.toList\n    \
    \    var leftCount = arr.size\n        var rightCount = arr.size - 1\n       \
    \ var trueCount = leftCount - rightCount\n\n        // If either left or right\
    \ pointer is at its limit, return false\n        if(leftCount == 0 || rightCount\
    \ == 0) {\n            return false\n        }\n\n        // If all elements are\
    \ equal, return true\n        if(leftCount == rightCount) {\n            arr.head\
    \ <= arr.last\n        }\n\n        while(trueCount > 0) {\n            // If\
    \ right pointer has reached its limit, return true\n            if(rightCount\
    \ == 0) {\n                return true\n            }\n\n            // Left pointer\
    \ increments one more time\n            leftCount -= 1\n            rightCount\
    \ -= 1\n\n            if(arr(leftCount) > arr(rightCount)) {\n               \
    \ // If right pointer is smaller than left, swap them and increment right pointer\n\
    \                val temp = arr(rightCount)\n                arr(rightCount) =\
    \ arr(leftCount)\n                arr(leftCount) = temp\n                rightCount\
    \ += 1\n                trueCount += 1\n            }\n        }\n        return\
    \ false\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpbhneqv8m.scala:30:18 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660009797
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val N = arr.size\n\
    \        if(N==0) true\n        else {\n            val list = arr.toSet\n   \
    \         val size = list.size\n            val right = list.size - 1\n      \
    \      val left = N - right\n            val result = moveOneBall(arr, size, left,\
    \ right)\n            if (result) true\n            else false\n        }\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5uvh7i79.scala:33:37\
    \ --------------------\e[0m\e[0m\n\e[31m33 |\e[0m            \e[33mval\e[0m \e\
    [36mresult\e[0m = moveOneBall(arr, size, left, right)\n\e[31m\e[31m   |\e[0m \
    \                                    ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                                   Found:    \e[1m\e[31m(\e[0mList[Long]\e\
    [1m\e[31m,\e[0m\e[1m\e[31m \e[0m\e[1m\e[31mInt\e[0m\e[1m\e[31m,\e[0m\e[1m\e[31m\
    \ \e[0m\e[1m\e[31mInt\e[0m\e[1m\e[31m,\e[0m\e[1m\e[31m \e[0m\e[1m\e[31mInt\e[0m\e\
    [1m\e[31m)\e[0m\n\e[31m   |\e[0m                                   Required: List[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009801
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val sortedArr =\
    \ arr.sortWith(_ < _)\n        if(arr.isEmpty) true\n        else if(sortedArr.last<0)\
    \ true\n        else if((sortedArr.last+1)<0) true\n        else arr.last+1 !=\
    \ sortedArr.last+1\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpcne48987.scala:35)\n\tat Problem.main(tmpcne48987.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009805
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val left = new mutable.ListBuffer[Long]()\n\
    \        val right = new mutable.ListBuffer[Long]()\n        val index = 0\n \
    \       for (i <- arr.indices) {\n            if (i <= (arr.size - 1)) {\n   \
    \             val j = math.min(arr.size, i)\n                val k = 0\n     \
    \           var leftTemp = 0l\n                var rightTemp = 0l\n          \
    \      for (x <- j to i) {\n                    leftTemp += arr(x)\n         \
    \           rightTemp += arr(x + 1)\n                }\n                left.append(leftTemp)\n\
    \                right.append(rightTemp)\n            } else {\n             \
    \   val j = (i - 1)\n                val k = i - 1\n                var leftTemp\
    \ = 0l\n                var rightTemp = 0l\n                for (x <- j to i)\
    \ {\n                    leftTemp += arr(x)\n                    rightTemp +=\
    \ arr(x + 1)\n                }\n                left.append(leftTemp)\n     \
    \           right.append(rightTemp)\n            }\n        }\n        for (i\
    \ <- 0 until arr.size) {\n            val j = (left.size - 1)\n            val\
    \ k = left.size - 1\n            val leftTemp = 0l\n            val rightTemp\
    \ = 0l\n            for (x <- j to i) {\n                leftTemp += arr(x)\n\
    \                rightTemp += arr(x + 1)\n            }\n            left.remove(j)\n\
    \            right.remove(k)\n            if (math.abs(arr(i) - leftTemp) + math.abs(arr(i)\
    \ - rightTemp) < 0.01) {\n                return true\n            }\n       \
    \ }\n        return false\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp5w046aeg.scala:26:23 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mleft\e[0m = \e[33mnew\e\
    [0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m             \
    \          ^^^^^^^\e[0m\n\e[31m   |\e[0m                       Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp5w046aeg.scala:27:24\
    \ ------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e\
    [36mright\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e\
    [31m   |\e[0m                        ^^^^^^^\e[0m\n\e[31m   |\e[0m           \
    \             Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660009801
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        // Solution 1: Count\
    \ the number of right shifts performed on the list \n        // to check if the\
    \ given list can be sorted by performing right shifts \n        // only once.\n\
    \        var shiftCount : Int = 1\n        var sum : Long = 0\n        for(i <-\
    \ 0 until arr.size){\n            if(arr(i) < (sum + arr(i-1))){\n           \
    \     shiftCount += 1\n            }\n            sum += arr(i)\n        }\n \
    \       if(shiftCount == 1){\n            return true\n        }else{\n      \
    \      return false\n        }\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: -1\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:115)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.moveOneBall$$anonfun$1(tmptmnqtpb0.scala:32)\n\tat scala.runtime.java8.JFunction1$mcVI$sp.apply(JFunction1$mcVI$sp.scala:18)\n\
    \tat scala.collection.immutable.Range.foreach(Range.scala:190)\n\tat Problem$.moveOneBall(tmptmnqtpb0.scala:36)\n\
    \tat Problem$.main(tmptmnqtpb0.scala:44)\n\tat Problem.main(tmptmnqtpb0.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009808
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val m = arr.length\n\
    \        if (m <= 0) return true\n        val l = arr.head\n        val n = arr.last\n\
    \        if (n == n-1) return moveOneBall(arr.drop(1)) && moveOneBall(arr.take(arr.length-1))\n\
    \        val r = List(l)\n        val l1 = arr.drop(1)\n        var l2 = arr.take(arr.length-1)\n\
    \        val m = l2.length\n        var k = l2.head\n        var i = 0\n     \
    \   for (i <- m until (l2.head - 1)) {\n            k <- (l2 drop (i-1)).head\n\
    \            if (l < k) r = r::l\n            if (l > k) r ::= l::l2\n       \
    \ }\n        if (r == r::l1) return true\n        else return false\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpqbqrx4d6.scala:38:14 -----------------------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m            k <- (l2 drop (i-\e[31m1\e[0m)).head\n\e\
    [31m\e[31m   |\e[0m              ^^\e[0m\n\e[31m   |\e[0m              end of\
    \ statement expected but '<-' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpqbqrx4d6.scala:34:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m\
    \ \e[36mm\e[0m = l2.length\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mm is already defined as \e[33mvalue\e[0m \e[35mm\e[0m\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpqbqrx4d6.scala:37:27 --------------------\e[0m\e[0m\n\e[31m37\
    \ |\e[0m        \e[33mfor\e[0m (i <- m until (l2.head - \e[31m1\e[0m)) {\n\e[31m\e\
    [31m   |\e[0m                           ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                       Found:    Long\n\e[31m   |\e[0m                      \
    \     Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpqbqrx4d6.scala:39:28\
    \ ------------------------\e[0m\e[0m\n\e[31m39 |\e[0m            \e[33mif\e[0m\
    \ (l < k) r = r::l\n\e[31m\e[31m   |\e[0m                            ^^^\e[0m\n\
    \e[31m   |\e[0m                            value :: is not a member of Long\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpqbqrx4d6.scala:40:25 ------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m            \e[33mif\e[0m (l > k) r ::= l::l2\n\e[31m\e\
    [31m   |\e[0m                       ^^^^^\e[0m\n\e[31m   |\e[0m            value\
    \ ::= is not a member of List[Long] - did you mean r.::?\n5 errors found\n"
  stdout: ''
  timestamp: 1660009807
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        arr.length match\
    \ {\n            case 1 => true\n            case _ => {\n                val\
    \ n = arr.length\n                val m = n - 1\n                val newArr =\
    \ arr.map(x => x+1)\n                val newArr_copy = newArr.toSeq.sortBy(x =>\
    \ x).reverse\n                arr.head match {\n                    case 1 =>\
    \ true\n                    case _ => {\n                        val r = newArr_copy.last\n\
    \                        val l = newArr_copy.head\n                        val\
    \ newArr = newArr_copy.drop(1).take(n - 1).reverse.head +\n                  \
    \                newArr_copy.drop(1).drop(1).take(n - 2).reverse.head +\n    \
    \                              newArr_copy.drop(1).drop(2).take(n - 3).reverse.head\
    \ +\n                                  newArr_copy.drop(1).drop(3).take(n - 4).reverse.head\
    \ +\n                                  newArr_copy.drop(1).drop(4).take(n - 5).reverse.head\
    \ +\n                                  newArr_copy.drop(1).drop(5).take(n - 6).reverse.head\
    \ +\n                                  newArr_copy.drop(1).drop(6).take(n - 7).reverse.head\
    \ +\n                                  newArr_copy.drop(1).drop(7).take(n - 8).reverse.head\
    \ +\n                                  newArr_copy.drop(1).drop(8).take(n - 9).reverse.head\
    \ +\n                                  newArr_copy.drop(1).drop(9).take(n - 10).reverse.head\
    \ +\n                                  newArr_copy.drop(1).drop(10).take(n - 11).reverse.head\
    \ +\n                                  newArr_copy.drop(1).drop(11).take(n - 12).reverse.head\
    \ +\n                                  newArr_copy.drop(1).drop(12).take(n - 13).reverse.head\
    \ +\n                                  newArr_copy.drop(1).drop(13).take(n - 14).reverse.head\
    \ +\n                                  newArr_copy.drop(1).drop(14).take(n - 15).reverse.head\
    \ +\n                                  newArr_copy.drop(1).drop(15).take(n - 16).reverse.head\
    \ +\n                                  newArr_copy.drop(1).drop(16).take(n - 17).reverse.head\
    \ +\n                                  newArr_copy.drop(1).drop(17).take(n - 18).reverse.head\
    \ +\n                                  newArr_copy.drop(1).drop(18).take(n - 19).reverse.head\
    \ +\n                                  newArr_copy.drop(1).drop(\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmprmym5zto.scala:57:59 ---------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m                                  newArr_copy.drop(\e\
    [31m1\e[0m).drop(\n\e[31m\e[31m   |\e[0m                                     \
    \                      ^\e[0m\n\e[31m   |\e[0m                               \
    \        expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E040] Syntax Error: /tmp/tmprmym5zto.scala:68:0 ----------------------------\e\
    [0m\e[0m\n\e[31m68 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmprmym5zto.scala:56:89\
    \ -----------------------------\e[0m\e[0m\n\e[31m38 |\e[0m                   \
    \     \e[33mval\e[0m \e[36mnewArr\e[0m = newArr_copy.drop(\e[31m1\e[0m).take(n\
    \ - \e[31m1\e[0m).reverse.head +\n\e[31m39 |\e[0m                            \
    \      newArr_copy.drop(\e[31m1\e[0m).drop(\e[31m1\e[0m).take(n - \e[31m2\e[0m).reverse.head\
    \ +\n\e[31m40 |\e[0m                                  newArr_copy.drop(\e[31m1\e\
    [0m).drop(\e[31m2\e[0m).take(n - \e[31m3\e[0m).reverse.head +\n\e[31m41 |\e[0m\
    \                                  newArr_copy.drop(\e[31m1\e[0m).drop(\e[31m3\e\
    [0m).take(n - \e[31m4\e[0m).reverse.head +\n\e[31m42 |\e[0m                  \
    \                newArr_copy.drop(\e[31m1\e[0m).drop(\e[31m4\e[0m).take(n - \e\
    [31m5\e[0m).reverse.head +\n\e[31m43 |\e[0m                                  newArr_copy.drop(\e\
    [31m1\e[0m).drop(\e[31m5\e[0m).take(n - \e[31m6\e[0m).reverse.head +\n\e[31m44\
    \ |\e[0m                                  newArr_copy.drop(\e[31m1\e[0m).drop(\e\
    [31m6\e[0m).take(n - \e[31m7\e[0m).reverse.head +\n\e[31m45 |\e[0m           \
    \                       newArr_copy.drop(\e[31m1\e[0m).drop(\e[31m7\e[0m).take(n\
    \ - \e[31m8\e[0m).reverse.head +\n\e[31m46 |\e[0m                            \
    \      newArr_copy.drop(\e[31m1\e[0m).drop(\e[31m8\e[0m).take(n - \e[31m9\e[0m).reverse.head\
    \ +\n\e[31m47 |\e[0m                                  newArr_copy.drop(\e[31m1\e\
    [0m).drop(\e[31m9\e[0m).take(n - \e[31m10\e[0m).reverse.head +\n\e[31m48 |\e[0m\
    \                "
  stdout: ''
  timestamp: 1660009808
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        if( arr.isEmpty)\
    \ {\n            return true\n        }\n        var flag = arr.tail.head == 0\n\
    \        for( i <- 1 to arr.size) {\n            if( flag) {\n               \
    \ arr.tail.tail.head = 0\n            } else {\n                arr.tail.tail.head\
    \ = arr.tail.tail.head + 1\n            }\n            flag = !flag\n        }\n\
    \        arr match {\n            case Nil    => true\n            case _ => false\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmp2g2ntv_8.scala:32:35 -----------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m                arr.tail.tail.head = \e[31m0\e[0m\n\e\
    [31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                Reassignment to val head\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E052]\
    \ Type Error: /tmp/tmp2g2ntv_8.scala:34:35 -----------------------------\e[0m\e\
    [0m\n\e[31m34 |\e[0m                arr.tail.tail.head = arr.tail.tail.head +\
    \ \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                Reassignment to val head\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660009802
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.length\n\
    \        val l = arr.head\n        val max = (arr.max / 2).toLong\n        val\
    \ result = max\n        var i = 1\n        while (i <= n) {\n            var j\
    \ = 0\n            while (j <= max) {\n                if (arr(i) < arr(max -\
    \ j)) {\n                    j++\n                } else {\n                 \
    \   arr(max - j) ::= arr(i)\n                    i += 1\n                    result\
    \ = max\n                    break\n                }\n            }\n       \
    \     max -= 1\n            i -= 1\n        }\n        arr.head = 0\n        arr.last\
    \ = 1\n        result > 0\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp7il7aoyw.scala:35:23 ---------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m                    j++\n\e[31m\e[31m   |\e[0m      \
    \                 ^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp7il7aoyw.scala:34:33 --------------------\e[0m\e[0m\n\e[31m34\
    \ |\e[0m                \e[33mif\e[0m (arr(i) < arr(max - j)) {\n\e[31m\e[31m\
    \   |\e[0m                                 ^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                            Found:    Long\n\e[31m   |\e[0m                 \
    \                Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp7il7aoyw.scala:37:24 --------------------\e[0m\e[0m\n\e[31m37\
    \ |\e[0m                    arr(max - j) ::= arr(i)\n\e[31m\e[31m   |\e[0m   \
    \                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                        Found:\
    \    Long\n\e[31m   |\e[0m                        Required: Int\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E052] Type Error: /tmp/tmp7il7aoyw.scala:39:27 -----------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m                    result = max\n\e[31m\e[31m   |\e\
    [0m                    ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                    Reassignment\
    \ to val result\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp7il7aoyw.scala:40:20\
    \ ------------------------\e[0m\e[0m\n\e[31m40 |\e[0m                    break\n\
    \e[31m\e[31m   |\e[0m                    ^^^^^\e[0m\n\e[31m   |\e[0m         \
    \           Not found: break\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmp7il7aoyw.scala:43:16 ------------------------\e[0m\e[0m\n\e[31m43 |\e\
    [0m            max -= \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m            ^^^^^^\e\
    [0m\n\e[31"
  stdout: ''
  timestamp: 1660009807
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val length = arr.length\n\
    \        val res = arr.drop(1).take(length).reverse\n        res.reverse.tail\
    \ == arr.take(length-1) && res.reverse == arr\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpufq9cclz.scala:31)\n\tat Problem.main(tmpufq9cclz.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009808
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        var tempArr : List[Long]\
    \ = arr\n        var i : Long = 0\n        var temp : Long = 0\n        while\
    \ (i < arr.length) {\n            temp = tempArr(i)\n            i +=1\n     \
    \       if (temp < tempArr(i)) {\n                tempArr.swap(i, arr.length)\n\
    \                arr.length +=1\n            }\n        }\n        return tempArr(0)==0\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpuworesmv.scala:30:27\
    \ --------------------\e[0m\e[0m\n\e[31m30 |\e[0m            temp = tempArr(i)\n\
    \e[31m\e[31m   |\e[0m                           ^\e[0m\n\e[31m   |\e[0m      \
    \                     Found:    (i : Long)\n\e[31m   |\e[0m                  \
    \         Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpuworesmv.scala:32:31\
    \ --------------------\e[0m\e[0m\n\e[31m32 |\e[0m            \e[33mif\e[0m (temp\
    \ < tempArr(i)) {\n\e[31m\e[31m   |\e[0m                               ^\e[0m\n\
    \e[31m   |\e[0m                               Found:    (i : Long)\n\e[31m   |\e\
    [0m                               Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpuworesmv.scala:33:24 ------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m                tempArr.swap(i, arr.length)\n\e[31m\e\
    [31m   |\e[0m                ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m value swap is\
    \ not a member of List[Long] - did you mean List[Long].map?\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpuworesmv.scala:34:27 ------------------------\e[0m\e\
    [0m\n\e[31m34 |\e[0m                arr.length +=\e[31m1\e[0m\n\e[31m\e[31m  \
    \ |\e[0m                ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                value\
    \ += is not a member of Int - did you mean Int.!=?\n4 errors found\n"
  stdout: ''
  timestamp: 1660009809
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        if(arr.isEmpty)\
    \ {\n            true\n        } else {\n            val leftSet = arr.head -\
    \ arr\n            val rightSet = arr.last - arr\n            val result = if\
    \ (leftSet.productElement(1l) > rightSet.productElement(1l)) leftSet.toList else\
    \ rightSet.toList\n            result.head + result.last == arr.head + arr.last\
    \ && moveOneBall(arr.tail)\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpns7f0u9c.scala:29:35 -----------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m            \e[33mval\e[0m \e[36mleftSet\e[0m = arr.head\
    \ - arr\n\e[31m\e[31m   |\e[0m                          ^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e[35m-\e[0m\
    \ in \e[33mclass\e[0m \e[35mLong\e[0m with types\n\e[31m   |\e[0m (x: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float): Float\n\e[31m   |\e[0m (x: Long): Long\n\
    \e[31m   |\e[0m (x: Int): Long\n\e[31m   |\e[0m (x: Char): Long\n\e[31m   |\e\
    [0m (x: Short): Long\n\e[31m   |\e[0m (x: Byte): Long\n\e[31m   |\e[0mmatch arguments\
    \ ((arr : List[Long]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpns7f0u9c.scala:30:36\
    \ -----------------------------\e[0m\e[0m\n\e[31m30 |\e[0m            \e[33mval\e\
    [0m \e[36mrightSet\e[0m = arr.last - arr\n\e[31m\e[31m   |\e[0m              \
    \             ^^^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives\
    \ of \e[33mmethod\e[0m \e[35m-\e[0m in \e[33mclass\e[0m \e[35mLong\e[0m with types\n\
    \e[31m   |\e[0m (x: Double): Double\n\e[31m   |\e[0m (x: Float): Float\n\e[31m\
    \   |\e[0m (x: Long): Long\n\e[31m   |\e[0m (x: Int): Long\n\e[31m   |\e[0m (x:\
    \ Char): Long\n\e[31m   |\e[0m (x: Short): Long\n\e[31m   |\e[0m (x: Byte): Long\n\
    \e[31m   |\e[0mmatch arguments ((arr : List[Long]))\n2 errors found\n"
  stdout: ''
  timestamp: 1660009805
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        if(arr.length ==\
    \ 1) true\n        else {\n            val first = arr.head\n            var rest\
    \ = arr.tail\n            while(true) {\n                if(rest >= first) {\n\
    \                    rest -= 1\n                    arr -= 1\n               \
    \ } else {\n                    return false\n                }\n            }\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpj7n9dgdd.scala:31:24 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m                \e[33mif\e[0m(rest >= first) {\n\e[31m\e\
    [31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m   |\e[0mvalue >= is not a\
    \ member of List[Long], but could be made available as an extension method.\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might make progress\
    \ towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Ordered.orderingToOrdered\n\
    \e[31m   |\e[0m  import math.Ordering.Implicits.infixOrderingOps\n\e[31m   |\e\
    [0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpj7n9dgdd.scala:32:25 ------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m                    rest -= \e[31m1\e[0m\n\e[31m\e[31m\
    \   |\e[0m                    ^^^^^^^\e[0m\n\e[31m   |\e[0m    value -= is not\
    \ a member of List[Long] - did you mean List[Long].!=?\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpj7n9dgdd.scala:33:24 ------------------------\e[0m\e\
    [0m\n\e[31m33 |\e[0m                    arr -= \e[31m1\e[0m\n\e[31m\e[31m   |\e\
    [0m                    ^^^^^^\e[0m\n\e[31m   |\e[0m           value -= is not\
    \ a member of List[Long] - did you mean arr.!=?\n3 errors found\n"
  stdout: ''
  timestamp: 1660009810
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        var sortedIndex\
    \ = 0\n        for {\n            currentIndex <- arr.indexOf(0)\n           \
    \ sortedIndex <- currentIndex + 1\n        } yield {\n            if (sortedIndex\
    \ - 1 <= arr.lastIndex) {\n                arr.updated(sortedIndex, arr(sortedIndex\
    \ - 1))\n                return true\n            }\n            arr.updated(sortedIndex,\
    \ arr(0))\n            return false\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp7hn2dsad.scala:28:28 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m            currentIndex <- arr.indexOf(\e[31m0\e[0m)\n\
    \e[31m\e[31m   |\e[0m                            ^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0m                            value flatMap is not a member of Int\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660009809
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        if(arr.isEmpty)\
    \ true\n        else {\n            // Keep track of elements already visited\
    \ and their current position in arr\n            val visitedSet = scala.collection.mutable.HashSet[Long]()\n\
    \            var posCount = 0\n            var currentPosition = 0\n         \
    \   // Keep track of elements that have already been visited and their current\
    \ position in arr\n            var newPosition = 0\n            // Keep track\
    \ of the number of times right shift operation is performed on a list\n      \
    \      var shiftCount = 0\n            while(shiftCount < arr.size) {\n      \
    \          val pos = arr.indexOf(currentPosition)\n                if(pos < 0)\
    \ return false\n                if(visitedSet(pos - posCount) && visitedSet(pos\
    \ - posCount) < arr.size) {\n                    newPosition = pos\n         \
    \           shiftCount++\n                } else if(!visitedSet(pos - posCount))\
    \ {\n                    newPosition = pos\n                    visitedSet(pos\
    \ - posCount) = currentPosition\n                }\n                currentPosition\
    \ = pos\n                posCount = posCount + 1\n            }\n            currentPosition\
    \ = arr.indexOf(newPosition)\n            if(currentPosition < 0) return false\n\
    \            if(visitedSet(currentPosition - posCount) && visitedSet(currentPosition\
    \ - posCount) < arr.size) {\n                newPosition = currentPosition\n \
    \               shiftCount++\n            }\n            if(shiftCount >= arr.size)\
    \ true\n            else {\n                visitedSet(currentPosition - posCount)\
    \ = currentPosition\n                shiftCount = shiftCount + 1\n           \
    \     moveOneBall(arr.drop(currentPosition + 1).take(currentPosition - posCount).toList\
    \ ++ arr.take(currentPosition + 1).drop(currentPosition - posCount))\n       \
    \     }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpfm5qeh16.scala:41:32 ---------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m                    shiftCount++\n\e[31m\e[31m   |\e\
    [0m                                ^\e[0m\n\e[31m   |\e[0m                   \
    \             expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E018] Syntax Error: /tmp/tmpfm5qeh16.scala:53:28 ---------------------------\e\
    [0m\e[0m\n\e[31m53 |\e[0m                shiftCount++\n\e[31m\e[31m   |\e[0m \
    \                           ^\e[0m\n\e[31m   |\e[0m                          \
    \  expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpfm5qeh16.scala:39:82 --------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m                \e[33mif\e[0m(visitedSet(pos - posCount)\
    \ && visitedSet(pos - posCount) < arr.size) {\n\e[31m\e[31m   |\e[0m         \
    \                                                                     ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                                       Found:\
    \    Int\n\e[31m   |\e[0m                                                    \
    \   Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpfm5qeh16.scala:44:49\
    \ --------------------\e[0m\e[0m\n\e[31m44 |\e[0m                    visitedSet(pos\
    \ - posCount) = currentPosition\n\e[31m\e[31m   |\e[0m                       \
    \                          ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m             \
    \                          Found:    (currentPosition : Int)\n\e[31m   |\e[0m\
    \                                       Required: Boolean\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpfm5qeh16.scala:51:102 -------------------\e\
    [0m\e[0m\n\e[31m51 |\e[0m            \e[33mif\e[0m(visitedSet(currentPosition\
    \ - posCount) && visitedSet(currentPosition - posCount) < arr"
  stdout: ''
  timestamp: 1660009809
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        if(arr.isEmpty ||\
    \ arr.size == 1) return true\n        val len = arr.length\n        val maxIdx\
    \ = len-1\n        var j = 0\n        val result = mutable.ArrayBuffer(0)\n  \
    \      for(i <- 1 to len){\n            val num = arr(i)\n            val last\
    \ = arr(maxIdx-i)\n            val diff = num-last\n            if(diff > 0) {\n\
    \                result.+=(num+last)\n            }\n        }\n        if(result.forall(x\
    \ => x>0)) true else false\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\
    \ == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong, 10l.toLong,\
    \ 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpsg19h8kt.scala:30:21 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ArrayBuffer(\e\
    [31m0\e[0m)\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009806
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        if(arr.isEmpty)\
    \ true\n        else {\n            val first = arr.head\n            val last\
    \ = arr.last\n            val count = arr.size\n\n            val first = arr.head\n\
    \            val last = arr.last\n            val count = arr.size\n\n       \
    \     val first = arr.head\n            val last = arr.last\n            val count\
    \ = arr.size\n\n            val first = arr.head\n            val last = arr.last\n\
    \            val count = arr.size\n\n            val first = arr.head\n      \
    \      val last = arr.last\n            val count = arr.size\n            val\
    \ first = arr.head\n            val last = arr.last\n            val count = arr.size\n\
    \            val first = arr.head\n            val last = arr.last\n         \
    \   val count = arr.size\n            val first = arr.head\n            val last\
    \ = arr.last\n            val count = arr.size\n            val first = arr.head\n\
    \            val last = arr.last\n            val count = arr.size\n         \
    \   val first = arr.head\n            val last = arr.last\n            val count\
    \ = arr.size\n            val first = arr.head\n            val last = arr.last\n\
    \            val count = arr.size\n            val first = arr.head\n        \
    \    val last = arr.last\n            val count = arr.size\n            val first\
    \ = arr.head\n            val last = arr.last\n            val count = arr.size\n\
    \            val first = arr.head\n            val last = arr.last\n         \
    \   val count = arr.size\n            val first = arr.head\n            val last\
    \ = arr.last\n            val count = arr.size\n            val first = arr.head\n\
    \            val last = arr.last\n            val count = arr.size\n         \
    \   val first = arr.head\n            val last = arr.last\n            val count\
    \ = arr.size\n            val first = arr.head\n            val last = arr.last\n\
    \            val count = arr.size\n            val first = arr.head\n        \
    \    val last = arr.last\n            val count = arr.size\n            val first\
    \ = arr.head\n            val last = arr.last\n            val count = arr.size\n\
    \            val first = arr.head\n            val last = arr.last\n         \
    \   val count = arr.size\n            val first = arr.head\n            val last\
    \ = arr.last\n            val count = arr.size\n            val first = arr.head\n\
    \            val last = arr.last\n            val count = arr.size\n         \
    \   val first = arr.head\n            val last = arr.last\n            val count\
    \ = arr.size\n            val first = arr.head\n            val last = arr.last\n\
    \            val count = arr.size\n            val first = arr.head\n        \
    \    val last = arr.last\n            val count = arr.size\n            val first\
    \ = arr.head\n            val last = arr.last\n            val count = arr.size\n\
    \            val first = arr.head\n            val last = arr.last\n         \
    \   val count = arr.size\n\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\
    \ == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong, 10l.toLong,\
    \ 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpvc7nut66.scala:127:0 ---------------------------\e\
    [0m\e[0m\n\e[31m127 |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m'}'\
    \ expected, but eof found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpvc7nut66.scala:32:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m32 |\e[0m            \e[33mval\e\
    [0m \e[36mfirst\e[0m = arr.head\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mfirst is already defined as \e[33mvalue\e[0m \e[35mfirst\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpvc7nut66.scala:33:16 ---------------------------\e[0m\e[0m\n\e\
    [31m33 |\e[0m            \e[33mval\e[0m \e[36mlast\e[0m = arr.last\n\e[31m\e[31m\
    \   |\e[0m            ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mlast is already\
    \ defined as \e[33mvalue\e[0m \e[35mlast\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpvc7nut66.scala:34:16 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m            \e[33mval\e[0m \e[36mcount\e[0m = arr.size\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mcount\
    \ is already defined as \e[33mvalue\e[0m \e[35mcount\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpvc7nut66.scala:36:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m36 |\e[0m            \e[33mval\e\
    [0m \e[36mfirst\e[0m = arr.head\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mfirst is already defined as \e[33mvalue\e[0m \e[35mfirst\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpvc7nut66.scala:37:16 ---------------------------\e[0m\e[0m\n\e\
    [31m37 |\e[0m            \e[33mval\e[0m \e[36mlast\e[0m = arr.last\n\e[31m\e[31m\
    \   |\e[0m            ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mlast is alread"
  stdout: ''
  timestamp: 1660009811
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        var index : Int\
    \ = 0\n        var cnt : Int = 0\n        while ( index < arr.length && cnt <\
    \ arr.length ) {\n            if( arr(index) < arr(index+1) ) {\n            \
    \    arr(index) = arr(index + 1)\n                arr(index + 1) = 0\n       \
    \         index += 2\n                cnt += 1\n            } else {\n       \
    \         index += 1 \n            }\n        }\n        if( index == arr.length\
    \ ) {\n            return true\n        } else {\n            return false\n \
    \       }\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpujfou5pe.scala:30:16 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m                arr(index) = arr(index + \e[31m1\e[0m)\n\
    \e[31m\e[31m   |\e[0m                ^^^\e[0m\n\e[31m   |\e[0m  value update is\
    \ not a member of List[Long] - did you mean arr.updated?\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpujfou5pe.scala:31:16 ------------------------\e[0m\e\
    [0m\n\e[31m31 |\e[0m                arr(index + \e[31m1\e[0m) = \e[31m0\e[0m\n\
    \e[31m\e[31m   |\e[0m                ^^^\e[0m\n\e[31m   |\e[0m  value update is\
    \ not a member of List[Long] - did you mean arr.updated?\n2 errors found\n"
  stdout: ''
  timestamp: 1660009810
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.size\n\
    \        var i = 0\n        while (i < n) {\n            val temp = arr(i)\n \
    \           if (i == 0) {\n                i += 1\n            } else if (temp\
    \ > arr(i-1)) {\n                val temp = arr(i)\n                arr.apply(i)\
    \ = arr(i-1)\n                arr(i-1) = temp\n                i -= 1\n      \
    \      }\n            i += 1\n        }\n        arr.size == 0\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpy8o102lj.scala:34:16 ------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m                arr.apply(i) = arr(i-\e[31m1\e[0m)\n\e\
    [31m\e[31m   |\e[0m                ^^^^^^^^^\e[0m\n\e[31m   |\e[0m           \
    \     value update is not a member of Int => Long\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmpy8o102lj.scala:35:16 ------------------------\e[0m\e[0m\n\e[31m35\
    \ |\e[0m                arr(i-\e[31m1\e[0m) = temp\n\e[31m\e[31m   |\e[0m    \
    \            ^^^\e[0m\n\e[31m   |\e[0m  value update is not a member of List[Long]\
    \ - did you mean arr.updated?\n2 errors found\n"
  stdout: ''
  timestamp: 1660009810
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val len = arr.length\n\
    \        if (len == 0) {\n            return true\n        }\n        val shiftCount\
    \ = arr.head.toLong / arr.tail.head.toLong\n        val result = new mutable.ArrayList\n\
    \        for (i <- 1 to len) {\n            val tmp = arr(i)\n            val\
    \ cur = arr(i - 1).longValue\n            val diff = cur - tmp\n            if\
    \ (diff < shiftCount) {\n                if (i - 1 >= arr.head.toLong) {\n   \
    \                 result.add(tmp)\n                }\n            } else {\n \
    \               if (i - 1 < arr.head.toLong) {\n                    result.add(tmp)\n\
    \                }\n            }\n        }\n        if (result.size == len)\
    \ {\n            return true\n        } else {\n            return false\n   \
    \     }\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpxyjs68qk.scala:31:25 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m mutable.ArrayList\n\e[31m\e[31m   |\e[0m                         ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                         Not found: mutable\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660009807
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        if (arr.isEmpty)\
    \ true\n        else {\n            var isSortedList = true\n            for (i\
    \ <- arr.indices) {\n                isSortedList = arr.tail.head >= arr.head\n\
    \                if (isSortedList) break\n            }\n            if (isSortedList)\
    \ return true\n            else return false\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp7vy0lmf9.scala:31:34 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m                \e[33mif\e[0m (isSortedList) break\n\e\
    [31m\e[31m   |\e[0m                                  ^^^^^\e[0m\n\e[31m   |\e\
    [0m                                  Not found: break\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660009808
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val arrSize = arr.length\n\
    \        var result = true\n        var rightShiftNum = 2\n        val result\
    \ = new mutable.ArrayBuffer[Boolean]()\n        while(arr.isEmpty == false){\n\
    \            val newArr = arr.takeRight(arrSize)\n            result &= moveOneBallHelper(newArr,\
    \ rightShiftNum, result)\n            arr ++ newArr\n            rightShiftNum\
    \ += 1\n        }\n        return result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp391h6cku.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m mutable.ArrayBuffer[\e[35mBoolean\e[0m]()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mresult is already defined as \e[33mvariable\e[0m \e[35mresult\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmp391h6cku.scala:32:19 ------------------------\e[0m\e[0m\n\
    \e[31m32 |\e[0m            result &= moveOneBallHelper(newArr, rightShiftNum,\
    \ result)\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \        value &= is not a member of Boolean - did you mean Boolean.!=?\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp391h6cku.scala:32:22 ------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m            result &= moveOneBallHelper(newArr, rightShiftNum,\
    \ result)\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                      Not found: moveOneBallHelper\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1660009812
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val arrList = new\
    \ mutable.ListBuffer[Long]()\n        arrList += arr(1)\n        for (i<-1 to\
    \ arr.size) {\n            arrList += arr(i+1)\n        }\n        arrList.sortWith((x:Long,y:Long)\
    \ => x > y)\n        if(arrList.isEmpty || arr(0) != 0)\n            true\n  \
    \      else\n            false\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpjhycyfo3.scala:26:26 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36marrList\e[0m = \e[33mnew\e\
    [0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m             \
    \             ^^^^^^^\e[0m\n\e[31m   |\e[0m                          Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009809
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        if(arr.isEmpty)\n\
    \            return true\n        val maxIndex: Int = arr.length - 1\n       \
    \ val maxValue = arr(maxIndex)\n        for(i <- 1 to maxIndex) \n           \
    \ arr(i) >>>= arr(i)\n        arr(0) <<< maxValue\n        val reverseList = List(reverse(arr))\n\
    \        if(reverseList.sorted == arr)\n            true\n        else\n     \
    \       false\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpzbwgsgr_.scala:31:19 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m            arr(i) >>>= arr(i)\n\e[31m\e[31m   |\e[0m\
    \            ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value >>>= is not a\
    \ member of Long - did you mean Long.>>>?\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpzbwgsgr_.scala:32:15 ------------------------\e[0m\e[0m\n\e[31m32 |\e\
    [0m        arr(\e[31m0\e[0m) <<< maxValue\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        value <<< is not a member of Long - did you mean Long.<<?\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpzbwgsgr_.scala:33:31 ------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mreverseList\e[0m = List(reverse(arr))\n\
    \e[31m\e[31m   |\e[0m                               ^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                               Not found: reverse\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- Error: /tmp/tmpzbwgsgr_.scala:34:29 -----------------------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mif\e[0m(reverseList.sorted == arr)\n\e\
    [31m\e[31m   |\e[0m                             ^\e[0m\n\e[31m   |\e[0mambiguous\
    \ given instances: both \e[33mobject\e[0m \e[35mByte\e[0m in \e[33mobject\e[0m\
    \ \e[35mOrdering\e[0m and \e[33mobject\e[0m \e[35mBigDecimal\e[0m in \e[33mobject\e\
    [0m \e[35mOrdering\e[0m match type Ordering[B] of parameter ord of \e[33mmethod\e\
    [0m \e[35msorted\e[0m in \e[33mtrait\e[0m \e[35mStrictOptimizedSeqOps\e[0m\n4\
    \ errors found\n"
  stdout: ''
  timestamp: 1660009815
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        require(arr.nonEmpty)\n\
    \        var rightmost = arr.last\n        var leftmost = arr.head\n        for(i\
    \ <- 0 until arr.length){\n            val temp = rightmost\n            rightmost\
    \ = leftmost\n            leftmost = temp\n        }\n        leftmost == arr.last\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpnlxvy7gc.scala:40)\n\tat Problem.main(tmpnlxvy7gc.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009816
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        require(arr.nonEmpty)\n\
    \        val arr2 = arr.copy\n        val newArr = arr2.foldRight(arr2.head)(\
    \ (acc,x) =>{\n            val temp = acc\n            val index = acc.indexWhere(x\
    \ => x > temp)\n            val temp = temp - x\n            val temp2 = acc.take(index)\
    \ ++ temp\n            val temp3 = acc.drop(index) ++ temp2\n            val temp4\
    \ = acc ++ temp3\n            val temp5 = temp4.drop(index + 1)\n            return\
    \ temp5\n        })\n        newArr == arr\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmppkvz3odl.scala:27:23 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36marr2\e[0m = arr.copy\n\e\
    [31m\e[31m   |\e[0m                   ^^^^^^^^\e[0m\n\e[31m   |\e[0m       value\
    \ copy is not a member of List[Long] - did you mean arr.coll?\n1 error found\n"
  stdout: ''
  timestamp: 1660009813
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        def rightShift(arr:\
    \ List[Long], shift: Long) : List[Long] = {\n            if (shift == arr.length){\n\
    \                arr.toList\n            }else {\n                val temp = arr.takeRight(arr.length\
    \ -1)\n                val newArr = temp::temp\n                rightShift(newArr,shift+1)\n\
    \            }\n        }\n        if (arr.isEmpty){\n            true\n     \
    \   }else {\n            val shifts = arr.toList\n            val shiftsCount\
    \ = shifts.takeRight(shifts.length-1).toList\n            val shiftedList = shifts.tail\n\
    \            val shiftsCount = shiftsCount.takeRight(shiftsCount.length-1).toList\n\
    \            val shiftsCount = shiftsCount.toList\n            val shifts = shifts.toList\n\
    \            val newArr = rightShift(shiftedList,shiftsCount.last)\n         \
    \   if (newArr == arr){\n                true\n            }else {\n         \
    \       false\n            }\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpqsl5qzos.scala:32:27\
    \ --------------------\e[0m\e[0m\n\e[31m32 |\e[0m                rightShift(newArr,shift+\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m                           ^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                           Found:    (newArr : List[Matchable])\n\e\
    [31m   |\e[0m                           Required: List[Long]\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E161] Naming Error: /tmp/tmpqsl5qzos.scala:41:16 ---------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m            \e[33mval\e[0m \e[36mshiftsCount\e[0m = shiftsCount.takeRight(shiftsCount.length-\e\
    [31m1\e[0m).toList\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mshiftsCount is already defined as \e[33mvalue\e[0m \e[35mshiftsCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpqsl5qzos.scala:42:16 ---------------------------\e[0m\e[0m\n\e\
    [31m42 |\e[0m            \e[33mval\e[0m \e[36mshiftsCount\e[0m = shiftsCount.toList\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mshiftsCount is already defined as \e[33mvalue\e[0m \e[35mshiftsCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpqsl5qzos.scala:43:16 ---------------------------\e[0m\e[0m\n\e\
    [31m43 |\e[0m            \e[33mval\e[0m \e[36mshifts\e[0m = shifts.toList\n\e\
    [31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mshifts\
    \ is already defined as \e[33mvalue\e[0m \e[35mshifts\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n4 errors found\n"
  stdout: ''
  timestamp: 1660009814
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        // Write your code\
    \ here\n        val arr2 = arr match {\n            case Nil => List() \n    \
    \        case x::xs => ArrayBuffer(x)\n        }\n        val arr = arr2 map {\
    \ x => x.toLong }\n        var res = false\n        for (i <- 0 until arr.length)\
    \ {\n            val n = arr.length - i\n            if (n > 1) {\n          \
    \      val lastElem = arr(n-1)\n                val firstElem = arr(n)\n     \
    \           arr(n) = lastElem\n                arr(n-1) = firstElem\n        \
    \    }\n        }\n        res = arr.forall(x => x >= 0)\n        res\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp176djtei.scala:31:18 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr2 map { \e\
    [36mx\e[0m => x.toLong }\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m\
    \   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr2\e[0m needs type\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp176djtei.scala:29:38\
    \ ------------------------\e[0m\e[0m\n\e[31m29 |\e[0m            \e[33mcase\e\
    [0m x::xs => ArrayBuffer(x)\n\e[31m\e[31m   |\e[0m                           \
    \           ^\e[0m\n\e[31m   |\e[0m                                      Not found:\
    \ x\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660009815
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.length\n\
    \        var j = 0\n        while(j < n) {\n            val x = arr(j)\n     \
    \       while(j > 0 && x > arr(j-1)) arr(j) <- arr(j-1)\n            arr(j) <-\
    \ x\n            j += 1\n        }\n        true\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpmbirad7i.scala:30:48 -----------------------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m            \e[33mwhile\e[0m(j > \e[31m0\e[0m && x >\
    \ arr(j-\e[31m1\e[0m)) arr(j) <- arr(j-\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \                                              ^^\e[0m\n\e[31m   |\e[0m      \
    \                          end of statement expected but '<-' found\n\e[31m\e\
    [31m-- Error: /tmp/tmpmbirad7i.scala:31:19 -----------------------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m            arr(j) <- x\n\e[31m\e[31m   |\e[0m      \
    \             ^^\e[0m\n\e[31m   |\e[0m                   end of statement expected\
    \ but '<-' found\n2 errors found\n"
  stdout: ''
  timestamp: 1660009814
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val leftRotate :\
    \ (List[Long], Int) => List[Long] = (arr, k) => {\n            val list1 = arr.init\n\
    \            val list2 = arr.drop(k).reverse\n            val list3 = list1 ++\
    \ list2\n            list3\n        }\n        val rightRotate : (List[Long],\
    \ Int) => List[Long] = (arr, k) => {\n            val list1 = arr.init.reverse\n\
    \            val list2 = arr.drop(k)\n            val list3 = list1 ++ list2\n\
    \            list3\n        }\n        val mergeList : (List[Long], List[Long])\
    \ => List[Long] = (arr, list) => {\n            val list1 = arr.init\n       \
    \     val list2 = list.init\n            val list3 = list1 ++ list2\n        \
    \    list3\n        }\n        var a = 0\n        var b = 0\n        var c = arr.size\n\
    \        var d = 0\n        while (a < c) {\n            d = (a*2) + b\n     \
    \       if (d < c && a < (c - d) && b < (c - d) && d < c) {\n                println(mergeList(arr.init,\
    \ arr.drop(d + 1).reverse))\n                println(mergeList(arr.drop(d + 1).reverse,\
    \ arr.init.reverse))\n                println(mergeList(arr.drop(d + 1).reverse,\
    \ arr.drop(d + 1).reverse))\n                println(mergeList(arr.drop(d + 1).reverse,\
    \ arr.drop(d + 1).reverse))\n                println(mergeList(arr.drop(d + 1).reverse,\
    \ arr.init.reverse))\n                a = a + 1\n                b = b + 1\n \
    \               c = c\n            } else {\n                println(mergeList(arr.init,\
    \ arr.drop(d + 1).reverse))\n                a = a + 1\n                b = b\
    \ + 1\n                c = c\n            }\n        }\n        return true\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.UnsupportedOperationException: init of empty list\n\tat scala.collection.immutable.Nil$.init(List.scala:666)\n\
    \tat scala.collection.immutable.Nil$.init(List.scala:661)\n\tat Problem$.$anonfun$3(tmpl0j0owwh.scala:40)\n\
    \tat Problem$.moveOneBall(tmpl0j0owwh.scala:60)\n\tat Problem$.main(tmpl0j0owwh.scala:69)\n\
    \tat Problem.main(tmpl0j0owwh.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: 'List(3, 4, 5, 2, 1, 5)

    List(2, 1, 5, 1, 5, 4)

    List(2, 1, 5, 2, 1, 5)

    List(2, 1, 5, 2, 1, 5)

    List(2, 1, 5, 1, 5, 4)

    List(3, 4, 5)

    List(1, 5, 4)

    List()

    List()

    List(1, 5, 4)

    '
  timestamp: 1660009820
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val resultSet =\
    \ arr.filter(_ != 0l)\n        if (arr.isEmpty)\n            true\n        else\
    \ {\n            val newArray = arr.filter(_ != 0l)\n            var newSize =\
    \ 0\n            val lastElement = arr.last\n            while (newSize != arr.size)\
    \ {\n                val newElement = newArray.head\n                val newLastElement\
    \ = newArray.reverse.head\n                newArray = newArray.drop(1)\n     \
    \           newSize -= 1\n                val currentElement = arr.last\n    \
    \            if ((newLastElement - currentElement) > 0) {\n                  \
    \  newArray :+ lastElement\n                    newSize += 1\n               \
    \ }\n            }\n            resultSet == newArray\n        }\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmpqfrxo2ne.scala:36:25 -----------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m                newArray = newArray.drop(\e[31m1\e[0m)\n\
    \e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                Reassignment to val newArray\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660009817
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        if(arr.isEmpty)\n\
    \            return true\n        var i = 0\n        var j = arr.size - 1\n  \
    \      while(i < j)\n        {\n            // Perform right shift operation only\
    \ when we have more than 1 element in the array.\n            if(arr.size > (i+1)\
    \ && arr.size < (j+1))\n            {\n                // Perform right shift\
    \ operation only when we have 2 elements in the array.\n                if(arr.size\
    \ > (i+2) && (j+1) == arr.size)\n                {\n                    arr =\
    \  arr.map(_.toLong)\n                    val x = arr(i)\n                   \
    \ val y = arr(i+1)\n                    val z = arr(i+2)\n                   \
    \ val w = arr(j)\n                    val z = arr(j+1)\n                    val\
    \ w = arr(j+2)\n                    val x = arr(i)\n                    val y\
    \ = arr(i+1)\n                    val z = arr(i+2)\n                    val w\
    \ = arr(j)\n                    val z = arr(j+1)\n                    val w =\
    \ arr(j+2)\n                    val x = arr(i)\n                    val y = arr(i+1)\n\
    \                    val z = arr(i+2)\n                    val w = arr(j)\n  \
    \                  val z = arr(j+1)\n                    val w = arr(j+2)\n  \
    \                  val x = arr(i)\n                    val y = arr(i+1)\n    \
    \                val z = arr(i+2)\n                    val w = arr(j)\n      \
    \              val z = arr(j+1)\n                    val w = arr(j+2)\n      \
    \              val x = arr(i)\n                    val y = arr(i+1)\n        \
    \            val z = arr(i+2)\n                    val w = arr(j)\n          \
    \          val z = arr(j+1)\n                    val w = arr(j+2)\n          \
    \          val x = arr(i)\n                    val y = arr(i+1)\n            \
    \        val z = arr(i+2)\n                    val w = arr(j)\n              \
    \      val z = arr(j+1)\n                    val w = arr(j+2)\n              \
    \      val x = arr(i)\n                    val y = arr(i+1)\n                \
    \    val z = arr(i+2)\n                    val w = arr(j)\n                  \
    \  val z = arr(j+1)\n                    val w = arr(j+2)\n                  \
    \  val x = arr(i)\n                    val y = arr(i+1)\n                    val\
    \ z = arr(i+2)\n                    val w = arr(j)\n                    val z\
    \ = arr(j+1)\n                    val w = arr(j+2)\n                    val x\
    \ = arr(i)\n                    val y = arr(i+1)\n                    val z =\
    \ arr(i+2)\n                    val w = arr(j)\n                    val z = arr(j+1)\n\
    \                    val w = arr(j+2)\n                    val x = arr(i)\n  \
    \                  val y = arr(i+1)\n                    \n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmptwyo5y4n.scala:106:0 ---------------------------\e\
    [0m\e[0m\n\e[31m106 |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m'}'\
    \ expected, but eof found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmptwyo5y4n.scala:43:24\
    \ ---------------------------\e[0m\e[0m\n\e[31m43 |\e[0m                    \e\
    [33mval\e[0m \e[36mz\e[0m = arr(j+\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m       \
    \             ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mz is already defined as \e\
    [33mvalue\e[0m \e[35mz\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmptwyo5y4n.scala:44:24 ---------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m                    \e[33mval\e[0m \e[36mw\e[0m = arr(j+\e\
    [31m2\e[0m)\n\e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mw is already defined as \e[33mvalue\e[0m \e[35mw\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmptwyo5y4n.scala:45:24\
    \ ---------------------------\e[0m\e[0m\n\e[31m45 |\e[0m                    \e\
    [33mval\e[0m \e[36mx\e[0m = arr(i)\n\e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mx is already defined as \e[33mvalue\e[0m \e[35mx\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmptwyo5y4n.scala:46:24 ---------------------------\e[0m\e[0m\n\e[31m46\
    \ |\e[0m                    \e[33mval\e[0m \e[36my\e[0m = arr(i+\e[31m1\e[0m)\n\
    \e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0my\
    \ is already defined as \e[33mvalue\e[0m \e[35my\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmptwyo5y4n.scala:47:24\
    \ ---------------------------\e[0m\e[0m\n\e[31m47 |\e[0m                    \e\
    [33mval\e[0m \e[36mz\e[0m = arr(i+\e[31m2\e[0m)\n\e[31m\e[31m   |\e[0m       \
    \             ^^"
  stdout: ''
  timestamp: 1660009818
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.length\n\
    \        val arr1 = arr.toArray\n        val m = arr1.length\n        val arr2\
    \ = new Array[m]\n        var i : Int = 0\n        var j : Int = 0\n        var\
    \ k = n - 1\n        while (i < n && j < m) {\n            val x = arr2(i)\n \
    \           val y = arr1(j)\n            if (x < y) {\n                arr2(k)\
    \ = y\n                arr1(j) = x\n                k = j - 1\n              \
    \  j += 1\n            }\n            i += 1\n        }\n        var count = 0\n\
    \        val result = new Array[Boolean](m)\n        var i : Int = 0\n       \
    \ while (i < m) {\n            var isTrue = false\n            while (j < n &&\
    \ !isTrue) {\n                if (arr2(j) < arr1(i)) {\n                    arr2(k)\
    \ = arr1(j)\n                    arr1(j) = arr2(i)\n                    isTrue\
    \ = true\n                    k = j\n                    j += 1\n            \
    \    }\n                j += 1\n            }\n            result(i) = isTrue\n\
    \            i += 1\n        }\n        result.foreach(x => count = x + count)\n\
    \        return count == n\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\
    \ == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong, 10l.toLong,\
    \ 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpq6vt85z3.scala:46:12 ---------------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m        \e[33mvar\e[0m \e[36mi\e[0m : \e[35mInt\e[0m\
    \ = \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0mi is already defined as \e[33mvariable\e[0m \e[35mi\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq6vt85z3.scala:29:29\
    \ ------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e\
    [36marr2\e[0m = \e[33mnew\e[0m \e[35mArray\e[0m[\e[35mm\e[0m]\n\e[31m\e[31m  \
    \ |\e[0m                             ^\e[0m\n\e[31m   |\e[0m                 \
    \            Not found: type m\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpq6vt85z3.scala:62:38 ------------------------\e[0m\e[0m\n\e[31m62 |\e\
    [0m        result.foreach(\e[36mx\e[0m => count = x + count)\n\e[31m\e[31m   |\e\
    [0m                                    ^^^\e[0m\n\e[31m   |\e[0mvalue + is not\
    \ a member of Boolean, but could be made available as an extension method.\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might make progress\
    \ towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660009822
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        if(arr.isEmpty)\n\
    \            return true\n        var i = 0\n        var shift = 0\n        while(i\
    \ < arr.length) {\n            shift = i * 2\n            if(!arr.exists(x =>\
    \ x < arr(shift))) {\n                arr(shift) = arr(i)\n                arr(i)\
    \ = arr(shift)\n                i = i + 1\n            }\n        }\n        return\
    \ true\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpxwmpi3ti.scala:33:16 ------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m                arr(shift) = arr(i)\n\e[31m\e[31m   |\e\
    [0m                ^^^\e[0m\n\e[31m   |\e[0m  value update is not a member of\
    \ List[Long] - did you mean arr.updated?\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpxwmpi3ti.scala:34:16 ------------------------\e[0m\e[0m\n\e[31m34 |\e\
    [0m                arr(i) = arr(shift)\n\e[31m\e[31m   |\e[0m                ^^^\e\
    [0m\n\e[31m   |\e[0m  value update is not a member of List[Long] - did you mean\
    \ arr.updated?\n2 errors found\n"
  stdout: ''
  timestamp: 1660009821
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        if (arr.isEmpty)\
    \ true else false\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmptzd0ukjm.scala:29)\n\tat Problem.main(tmptzd0ukjm.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009823
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        if (arr.isEmpty)\
    \ true\n        else {\n            var shiftCount = arr.tail.head\n         \
    \   val result = (0 until arr.size)\n                .map (i => arr(i) >> (shiftCount\
    \ - 1))\n                .zipWithIndex\n                .foldLeft((List[Long](),\
    \ 0l)) {\n                    case ((curList, i), (curValue, j)) =>\n        \
    \                if (i == j) {\n                            (curList :+ curValue,\
    \ j)\n                        } else {\n                            ((curList\
    \ :+ curValue), j)\n                        }\n                }\n           \
    \ (result._1.sorted == result._2)\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmptky0hv55.scala:40:13 -----------------------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m            (result._1.sorted == result._2)\n\e[31m\e\
    [31m   |\e[0m             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \    Values of types List[Long] and Long cannot be compared with == or !=\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660009821
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val ans = arr.count(x\
    \ => x >= 0) == 0 && arr.isEmpty == false\n        ans\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp9ucq1i_v.scala:30)\n\tat Problem.main(tmp9ucq1i_v.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009823
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        // Write your code\
    \ here\n        // Write your code here\n        \n        if(arr.isEmpty)\n \
    \           return true\n        \n        var i = 0\n        var j = arr.length-1\n\
    \        var k = 0\n        while(i < j){\n            if(arr(i) > arr(k)){\n\
    \                arr(i) -= 1\n                for(j <- i+1 to k-1)\n         \
    \           arr(j) = arr(j+1)\n                arr(k) += 1\n                for(i\
    \ <- k+1 to j)\n                    arr(i) = arr(i-1)\n            }\n       \
    \     i += 1\n            k += 1\n        }\n        \n        return false\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpr3wtj5f7.scala:37:23 ------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m                arr(i) -= \e[31m1\e[0m\n\e[31m\e[31m\
    \   |\e[0m                ^^^^^^^^^\e[0m\n\e[31m   |\e[0m                value\
    \ -= is not a member of Long - did you mean Long.!=?\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmpr3wtj5f7.scala:39:20 ------------------------\e[0m\e[0m\n\
    \e[31m39 |\e[0m                    arr(j) = arr(j+\e[31m1\e[0m)\n\e[31m\e[31m\
    \   |\e[0m                    ^^^\e[0m\n\e[31m   |\e[0m  value update is not a\
    \ member of List[Long] - did you mean arr.updated?\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmpr3wtj5f7.scala:40:23 ------------------------\e[0m\e[0m\n\
    \e[31m40 |\e[0m                arr(k) += \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m \
    \               ^^^^^^^^^\e[0m\n\e[31m   |\e[0m                value += is not\
    \ a member of Long - did you mean Long.!=?\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpr3wtj5f7.scala:42:20 ------------------------\e[0m\e[0m\n\e[31m42 |\e\
    [0m                    arr(i) = arr(i-\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^\e[0m\n\e[31m   |\e[0m  value update is not a member of List[Long]\
    \ - did you mean arr.updated?\n4 errors found\n"
  stdout: ''
  timestamp: 1660009822
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        // To store the\
    \ current state of the list\n        var current = 0\n        // To store the\
    \ current number from current position\n        var current = arr(current)\n \
    \       // To store the current state\n        var currentState = true\n\n   \
    \     // For each element of the list\n        for(i <- 0 to arr.length - 1) {\n\
    \            // If the current position isn't equal to the current number\n  \
    \          if(arr(i) != current) {\n                // Change current state\n\
    \                currentState = false\n                // Change the current number\n\
    \                current = arr(i)\n                // Change the current position\n\
    \                current = arr(current)\n            }\n        }\n        currentState\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpobi415ph.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mvar\e[0m \e[36mcurrent\e[0m = arr(current)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mcurrent\
    \ is already defined as \e[33mvariable\e[0m \e[35mcurrent\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpobi415ph.scala:40:29\
    \ --------------------\e[0m\e[0m\n\e[31m40 |\e[0m                current = arr(i)\n\
    \e[31m\e[31m   |\e[0m                          ^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                        Found:    Long\n\e[31m   |\e[0m                     \
    \     Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpobi415ph.scala:42:29\
    \ --------------------\e[0m\e[0m\n\e[31m42 |\e[0m                current = arr(current)\n\
    \e[31m\e[31m   |\e[0m                          ^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                          Found:    Long\n\e[31m   |\e[0m                 \
    \         Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660009822
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        var flag = true\n\
    \        var tempList : List[Long] = ListBuffer.empty[Long]\n        for(a <-\
    \ arr){\n            if(a>0){\n                var flag = true\n             \
    \   for(a <- arr){\n                    if(a>0){\n                        temp\
    \ = temp + a.toLong\n                    }else if(a<=0){\n                   \
    \     tempList = tempList ::: a\n                        temp = temp + a.toLong\n\
    \                        flag = false\n                    }\n               \
    \ }\n                if(flag){\n                    tempList = tempList ::: a\n\
    \                }\n            }\n        }\n        if(arr.isEmpty){\n     \
    \       flag = true\n        }else {\n            flag = false\n        }\n  \
    \      return flag\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpqjpn5mid.scala:27:52\
    \ --------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mvar\e[0m \e[36mtempList\e\
    [0m : \e[35mList\e[0m[\e[35mLong\e[0m] = ListBuffer.empty[\e[35mLong\e[0m]\n\e\
    [31m\e[31m   |\e[0m                                    ^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                     Found:    scala.collection.mutable.ListBuffer[Long]\n\
    \e[31m   |\e[0m                     Required: List[Long]\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpqjpn5mid.scala:33:24 ------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m                        temp = temp + a.toLong\n\e[31m\e\
    [31m   |\e[0m                        ^^^^\e[0m\n\e[31m   |\e[0m              \
    \          Not found: temp\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpqjpn5mid.scala:33:31 ------------------------\e[0m\e[0m\n\e[31m33 |\e\
    [0m                        temp = temp + a.toLong\n\e[31m\e[31m   |\e[0m     \
    \                          ^^^^\e[0m\n\e[31m   |\e[0m                        \
    \       Not found: temp\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpqjpn5mid.scala:35:44\
    \ ------------------------\e[0m\e[0m\n\e[31m35 |\e[0m                        tempList\
    \ = tempList ::: a\n\e[31m\e[31m   |\e[0m                                    \
    \        ^^^^^\e[0m\n\e[31m   |\e[0m                                       value\
    \ ::: is not a member of Long\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpqjpn5mid.scala:36:24\
    \ ------------------------\e[0m\e[0m\n\e[31m36 |\e[0m                        temp\
    \ = temp + a.toLong\n\e[31m\e[31m   |\e[0m                        ^^^^\e[0m\n\e\
    [31m   |\e[0m                        Not found: temp\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpqjpn5mid.scala:36:31 ------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m                       "
  stdout: ''
  timestamp: 1660009823
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        // Your code here\n\
    \        val newList = arr.dropRight(1) // remove last element and put it to first\
    \ position\n        val newList2 = newList.map( x => ((x-1).toLong, x))\n    \
    \    val newList3 = newList.sortBy(_._1).reverse.map {\n            case (v, x)\
    \ => (v, x)\n        }\n        if(newList3.isEmpty) {\n            true\n   \
    \     } else {\n            if(!newList2.forall(newList3 contains _)){\n     \
    \           false\n            } else {\n                val x = newList2.reduceLeft(_._2).last._1\n\
    \                newList2 filter { case (v, x) => v == x }.isEmpty || moveOneBall(newList2\
    \ filter { case (v, x) => v == x })\n            }\n        }\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp1hpnbkjh.scala:29:40 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mnewList3\e[0m = newList.sortBy(_._1).reverse.map\
    \ {\n\e[31m\e[31m   |\e[0m                                      ^^^^\e[0m\n\e\
    [31m   |\e[0m                                      value _1 is not a member of\
    \ Long\n\e[31m\e[31m-- Error: /tmp/tmp1hpnbkjh.scala:29:43 -----------------------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mnewList3\e[0m = newList.sortBy(_._1).reverse.map\
    \ {\n\e[31m\e[31m   |\e[0m                                           ^\e[0m\n\e\
    [31m   |\e[0mambiguous given instances: both \e[33mobject\e[0m \e[35mByte\e[0m\
    \ in \e[33mobject\e[0m \e[35mOrdering\e[0m and \e[33mobject\e[0m \e[35mDeprecatedFloatOrdering\e\
    [0m in \e[33mobject\e[0m \e[35mOrdering\e[0m match type Ordering[B] of parameter\
    \ ord of \e[33mmethod\e[0m \e[35msortBy\e[0m in \e[33mtrait\e[0m \e[35mSeqOps\e\
    [0m\n\e[31m\e[31m-- [E086] Syntax Error: /tmp/tmp1hpnbkjh.scala:38:44 ---------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m                \e[33mval\e[0m \e[36mx\e[0m = newList2.reduceLeft(_._2).last._1\n\
    \e[31m\e[31m   |\e[0m                                            ^^^^\e[0m\n\e\
    [31m   |\e[0m                                 Wrong number of parameters, expected:\
    \ 2\n\e[31m\e[31m-- [E081] Type Error: /tmp/tmp1hpnbkjh.scala:39:34 -----------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m                newList2 filter { \e[33mcase\e[0m (v,\
    \ x) => v == x }.isEmpty || moveOneBall(newList2 filter { \e[33mcase\e[0m (v,\
    \ x) => v == x })\n\e[31m\e[31m   |\e[0m                                  ^\e\
    [0m\n\e[31m   |\e[0m   Missing parameter type\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \   I could not infer the type of the parameter x$1 of expanded function:\n\e\
    [31m   |\e[0m   x$1 => \n\e[31m   |\e[0m     x$1\e[33m match \e[0m\n\e[31m   |\e\
    [0m       {\n\e[31m   |\e[0m         \e[33mcase \e[0m(v, x) => \n\e[31m   |\e\
    [0m           v == x\n\e[31m   |\e[0m       }.\n\e[31m\e[31m-- [E006] Not Found\
    \ Error: /tmp/tmp1hpnbkjh.scala:39:49 ------------------------\e[0m\e[0m\n\e[31m39\
    \ |\e[0m                newList2 filter { \e[33mcase\e[0m (v, "
  stdout: ''
  timestamp: 1660009822
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        if (arr.isEmpty)\
    \ {\n            true\n        } else {\n            val arr = arr.toList\n  \
    \          val n = arr.size\n            val sortedArr : List[Long] = arr sortBy\
    \ (_ < arr(0) )\n            val sorted = sortedArr.take(n)\n            val n\
    \ = arr.size - n\n            val result = sortedArr diff sorted\n           \
    \ if (n == 1) {\n                true\n            } else {\n                moveOneBall(result)\n\
    \            }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpzugqe0_9.scala:33:16 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m            \e[33mval\e[0m \e[36mn\e[0m = arr.size -\
    \ n\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mn is already defined as \e[33mvalue\e[0m \e[35mn\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpzugqe0_9.scala:29:22\
    \ ---------------------------\e[0m\e[0m\n\e[31m29 |\e[0m            \e[33mval\e\
    [0m \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m                      ^\e\
    [0m\n\e[31m   |\e[0m                      Recursive \e[33mvalue\e[0m \e[35marr\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660009817
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        var result: List[Long]\
    \ = Nil\n        var counts: mutable.Map[Long, Long] = mutable.HashMap.empty\n\
    \        for (x <- arr) {\n            counts.put(x, counts.getOrElse(x, 0L) +\
    \ 1L) // counts stores the number of right shift operation\n            if (counts.get(x)\
    \ != 1L) result += (x,)\n            else result += (x,)\n        }\n        result\
    \ = result.tail\n\n        // We need all elements from the array to be sorted\
    \ from min to max\n        // and no element is repeated more than once\n    \
    \    val uniqueElements = result.groupBy(_._1).filter(_._2.size == 1).toSeq.keys\n\
    \        for (x<-uniqueElements)\n            if ((result(x-1) != result(x)).toLong\
    \ == 0) \n                return false // No need to shift because element is\
    \ already sorted\n\n        result = result.drop(uniqueElements.length)\n    \
    \    result = result.take(uniqueElements.length)\n        true\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmptbuhnqt3.scala:30:50 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m            \e[33mif\e[0m (counts.get(x) != \e[31m1L\e\
    [0m) result += (x,)\n\e[31m\e[31m   |\e[0m                                   \
    \               ^\e[0m\n\e[31m   |\e[0m                                      \
    \ expression expected but \e[31m')'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E018] Syntax Error: /tmp/tmptbuhnqt3.scala:31:30 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m            \e[33melse\e[0m result += (x,)\n\e[31m\e\
    [31m   |\e[0m                              ^\e[0m\n\e[31m   |\e[0m           \
    \                   expression expected but \e[31m')'\e[0m found\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmptbuhnqt3.scala:27:20 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mvar\e[0m \e[36mcounts\e[0m: mutable.Map[\e\
    [35mLong\e[0m, \e[35mLong\e[0m] = mutable.HashMap.empty\n\e[31m\e[31m   |\e[0m\
    \                    ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmptbuhnqt3.scala:27:46\
    \ ------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mvar\e[0m \e\
    [36mcounts\e[0m: mutable.Map[\e[35mLong\e[0m, \e[35mLong\e[0m] = mutable.HashMap.empty\n\
    \e[31m\e[31m   |\e[0m                                              ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                              Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmptbuhnqt3.scala:30:44\
    \ ------------------------\e[0m\e[0m\n\e[31m30 |\e[0m            \e[33mif\e[0m\
    \ (counts.get(x) != \e[31m1L\e[0m) result += (x,)\n\e[31m\e[31m   |\e[0m     \
    \                                ^^^^^^^^^\e[0m\n\e[31m   |\e[0m    value += is\
    \ not a member of List[Long] - did you mean List[Long].!=?\n\e[31m\e[31m-- [E008]\
    \ Not Fou"
  stdout: ''
  timestamp: 1660009823
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        var count = 0\n\
    \        var j = 0\n        var flag = true\n        val listSize = arr.size\n\
    \        if(listSize == 0) {\n            flag = true\n        } else {\n    \
    \        while(j < listSize) {\n                if(arr(j) < arr(j+1)) {\n    \
    \                arr(j) = arr(j)\n                    arr(j+1) = arr(j+1)\n  \
    \                  count = count + 1\n                    if(count > listSize)\
    \ {\n                        flag = false\n                        break\n   \
    \                 }\n                } else {\n                    j = (j + 1)\n\
    \                }\n                j = (j + 1)\n            }\n        }\n  \
    \      return flag\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpnd9z_2x8.scala:35:20 ------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m                    arr(j) = arr(j)\n\e[31m\e[31m   |\e\
    [0m                    ^^^\e[0m\n\e[31m   |\e[0m  value update is not a member\
    \ of List[Long] - did you mean arr.updated?\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpnd9z_2x8.scala:36:20 ------------------------\e[0m\e[0m\n\e[31m36 |\e\
    [0m                    arr(j+\e[31m1\e[0m) = arr(j+\e[31m1\e[0m)\n\e[31m\e[31m\
    \   |\e[0m                    ^^^\e[0m\n\e[31m   |\e[0m  value update is not a\
    \ member of List[Long] - did you mean arr.updated?\n\e[31m\e[31m-- [E006] Not\
    \ Found Error: /tmp/tmpnd9z_2x8.scala:40:24 ------------------------\e[0m\e[0m\n\
    \e[31m40 |\e[0m                        break\n\e[31m\e[31m   |\e[0m          \
    \              ^^^^^\e[0m\n\e[31m   |\e[0m                        Not found: break\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660009823
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        if(arr.isEmpty)\
    \ true\n        else moveOneBall(arr.take(arr.size-1)) +&& moveOneBall(arr.drop(1))\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp5znv4s9x.scala:27:47 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33melse\e[0m moveOneBall(arr.take(arr.size-\e\
    [31m1\e[0m)) +&& moveOneBall(arr.drop(\e[31m1\e[0m))\n\e[31m\e[31m   |\e[0m  \
    \           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \   value +&& is not a member of Boolean - did you mean Boolean.&&?\n1 error found\n"
  stdout: ''
  timestamp: 1660009823
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        // TODO: Your code\
    \ goes here\n        if(arr.isEmpty) \n            true\n        else\n      \
    \      false\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpodjpa380.scala:33)\n\tat Problem.main(tmpodjpa380.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009825
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val result = (arr\
    \ match {\n            case Nil => true\n            case head :: tail => {\n\
    \                var left = 0\n                var right = arr.length-1\n    \
    \            var flag = true\n                var temp = head\n\n            \
    \    while(left < right) {\n                    while(left < right && arr(left)\
    \ > temp) {\n                        left += 1\n                    }\n      \
    \              while(left < right && arr(right) < temp) {\n                  \
    \      right -= 1\n                    }\n                    if (left >= right)\
    \ {\n                        flag = false\n                        break\n   \
    \                 } else {\n                        arr(left) = arr(left)+1\n\
    \                        arr(right) = arr(right-1)\n                        left\
    \ += 1\n                        right -= 1\n                        temp = arr(left)+arr(right)\n\
    \                    }\n                }\n                arr(0) = 0\n      \
    \          arr(arr.length-1) = temp\n                flag\n            }\n   \
    \     }) \n        println(result)\n        result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp6oucltg6.scala:43:24 ------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m                        break\n\e[31m\e[31m   |\e[0m\
    \                        ^^^^^\e[0m\n\e[31m   |\e[0m                        Not\
    \ found: break\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp6oucltg6.scala:45:24\
    \ ------------------------\e[0m\e[0m\n\e[31m45 |\e[0m                        arr(left)\
    \ = arr(left)+\e[31m1\e[0m\n\e[31m\e[31m   |\e[0m                        ^^^\e\
    [0m\n\e[31m   |\e[0m  value update is not a member of List[Long] - did you mean\
    \ arr.updated?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp6oucltg6.scala:46:24\
    \ ------------------------\e[0m\e[0m\n\e[31m46 |\e[0m                        arr(right)\
    \ = arr(right-\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m                        ^^^\e\
    [0m\n\e[31m   |\e[0m  value update is not a member of List[Long] - did you mean\
    \ arr.updated?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp6oucltg6.scala:52:16\
    \ ------------------------\e[0m\e[0m\n\e[31m52 |\e[0m                arr(\e[31m0\e\
    [0m) = \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m                ^^^\e[0m\n\e[31m   |\e\
    [0m  value update is not a member of List[Long] - did you mean arr.updated?\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmp6oucltg6.scala:53:16 ------------------------\e\
    [0m\e[0m\n\e[31m53 |\e[0m                arr(arr.length-\e[31m1\e[0m) = temp\n\
    \e[31m\e[31m   |\e[0m                ^^^\e[0m\n\e[31m   |\e[0m  value update is\
    \ not a member of List[Long] - did you mean arr.updated?\n5 errors found\n"
  stdout: ''
  timestamp: 1660009827
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        if (arr.isEmpty)\
    \ true\n        else arr.tail.tail.tail.tail.tail.head < arr.head && moveOneBall(arr.tail)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.util.NoSuchElementException: head of empty list\n\tat scala.collection.immutable.Nil$.head(List.scala:662)\n\
    \tat scala.collection.immutable.Nil$.head(List.scala:661)\n\tat Problem$.moveOneBall(tmp59qyvvzr.scala:27)\n\
    \tat Problem$.main(tmp59qyvvzr.scala:30)\n\tat Problem.main(tmp59qyvvzr.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009827
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val arr = arr.sort\n\
    \        val n = arr.length\n        val first = arr.head\n        if (arr.isEmpty)\
    \ {\n            true\n        }\n        else {\n            for (i <- 0 until\
    \ n-1) {\n                if ((arr(i) >> 1) > first) {\n                    return\
    \ false\n                }\n            }\n            return true\n        }\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp9w9624h6.scala:26:18 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sort\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660009823
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val arr = arr.sorted\n\
    \        val first = arr.head\n        val last = arr.last\n\n        // For the\
    \ last element\n        if((arr.last)%2==0){\n            arr.insert(0,last)\n\
    \            arr.sort\n            val second=arr.head\n            val first1\
    \ = arr.last\n            val last1=arr.last\n            if((arr.last)==first1)\n\
    \                return true\n            else if((arr.last)==last1)\n       \
    \         return false\n            else\n                moveOneBall(arr)\n \
    \       }\n        // For the first\n        else{\n            arr.insert(0,first)\n\
    \            arr.sort\n            val first1 = arr.head\n            val last1\
    \ = arr.last\n            if((arr.last)==first1)\n                return false\n\
    \            else if((arr.last)==last1)\n                return true\n       \
    \     else\n                moveOneBall(arr)\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmplwey_3ur.scala:26:18 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sorted\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660009823
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        if (arr.isEmpty)\
    \ {\n            true\n        }\n        else {\n            var l = 1\n    \
    \        var i = 2\n            var d = 1\n            var j = arr.length - 1\n\
    \            var k = arr(j)\n            var tmp : Long = 0\n            var flag\
    \ : Boolean = true\n            while (i <= j) {\n                while (k !=\
    \ arr(i)) {\n                    d += 1\n                    i += 1\n        \
    \        }\n                while (arr(i) != arr(l)) {\n                    l\
    \ += 1\n                    i += 1\n                }\n                if (d >\
    \ i) {\n                    flag =  false\n                }\n               \
    \ tmp += 1\n                arr(l) = tmp\n                l += 1\n           \
    \     i -= 1\n                j -= 1\n                k -= 1\n               \
    \ d -= 1\n            }\n            if (flag) {\n                true\n     \
    \       }\n            else {\n                false\n            }\n        }\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp1kyzevi8.scala:50:16 ------------------------\e\
    [0m\e[0m\n\e[31m50 |\e[0m                arr(l) = tmp\n\e[31m\e[31m   |\e[0m \
    \               ^^^\e[0m\n\e[31m   |\e[0m  value update is not a member of List[Long]\
    \ - did you mean arr.updated?\n1 error found\n"
  stdout: ''
  timestamp: 1660009827
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.length\n\
    \        if( n==0 ){\n            return true\n        }\n        if( n==1 ){\n\
    \            return false\n        }\n        val sortedArr = arr.sort\n     \
    \   if( arr(n-1) == sortedArr(n-1) && arr(n-2) == sortedArr(n-2) ){\n        \
    \    if( arr(n-1) == sortedArr(n-1) ){\n                if( arr(n-2) == sortedArr(n-2)\
    \ ){\n                    if( arr(n-3) == sortedArr(n-3) ){\n                \
    \        if( arr(n-4) == sortedArr(n-4) ){\n                            if( arr(n-5)\
    \ == sortedArr(n-5) ){\n                                if( arr(n-6) == sortedArr(n-6)\
    \ ){\n                                    return true\n                      \
    \          }\n                            }\n                        }\n     \
    \               }\n                }\n            }\n        }\n        return\
    \ false\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpwjg0chts.scala:33:28 ------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36msortedArr\e[0m = arr.sort\n\
    \e[31m\e[31m   |\e[0m                        ^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \   value sort is not a member of List[Long] - did you mean arr.sortBy?\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660009829
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        require(arr.length\
    \ == arr.distinct && arr.length <= 100000, \n                \"The given list\
    \ 'arr' must have unique elements and have less than or equal to 10,000 elements\"\
    )\n        val newArr = arr.takeRight(1)\n        val newArr = newArr ++ newArr.tail\n\
    \        val newArr = newArr ++ newArr.tail\n        val newArr = newArr ++ newArr.tail\n\
    \        val newArr = newArr ++ newArr.tail\n        val newArr = newArr ++ newArr.tail\n\
    \        val newArr = newArr ++ newArr.tail\n        val newArr = newArr ++ newArr.tail\n\
    \        val newArr = newArr ++ newArr.tail\n        val newArr = newArr ++ newArr.tail\n\
    \        val newArr = newArr ++ newArr.tail\n        val newArr = newArr ++ newArr.tail\n\
    \        val newArr = newArr ++ newArr.tail\n        val newArr = newArr ++ newArr.tail\n\
    \        val newArr = newArr ++ newArr.tail\n        val newArr = newArr ++ newArr.tail\n\
    \        val newArr = newArr ++ newArr.tail\n        val newArr = newArr ++ newArr.tail\n\
    \        val newArr = newArr ++ newArr.tail\n        val newArr = newArr ++ newArr.tail\n\
    \        val newArr = newArr ++ newArr.tail\n        val newArr = newArr ++ newArr.tail\n\
    \        val newArr = newArr ++ newArr.tail\n        val newArr = newArr ++ newArr.tail\n\
    \        val newArr = newArr ++ newArr.tail\n        val newArr = newArr ++ newArr.tail\n\
    \        val newArr = newArr ++ newArr.tail\n        val newArr = newArr ++ newArr.tail\n\
    \        val newArr = newArr ++ newArr.tail\n        val newArr = newArr ++ newArr.tail\n\
    \        val newArr = newArr ++ newArr.tail\n        val newArr = newArr ++ newArr.tail\n\
    \        val newArr = newArr ++ newArr.tail\n        val newArr = newArr ++ newArr.tail\n\
    \        val newArr = \n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpuwqncnt2.scala:62:20 ---------------------------\e\
    [0m\e[0m\n\e[31m62 |\e[0m        \e[33mval\e[0m \e[36mnewArr\e[0m = \n\e[31m\e\
    [31m   |\e[0m                    ^\e[0m\n\e[31m   |\e[0m                    expression\
    \ expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpuwqncnt2.scala:29:12 ---------------------------\e[0m\e[0m\n\e[31m29\
    \ |\e[0m        \e[33mval\e[0m \e[36mnewArr\e[0m = newArr ++ newArr.tail\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mnewArr\
    \ is already defined as \e[33mvalue\e[0m \e[35mnewArr\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpuwqncnt2.scala:30:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m\
    \ \e[36mnewArr\e[0m = newArr ++ newArr.tail\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mnewArr is already defined as \e[33mvalue\e[0m \e[35mnewArr\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpuwqncnt2.scala:31:12 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m        \e[33mval\e[0m \e[36mnewArr\e[0m = newArr ++ newArr.tail\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0mnewArr is already defined as \e[33mvalue\e[0m \e[35mnewArr\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpuwqncnt2.scala:32:12 ---------------------------\e[0m\e[0m\n\e[31m32\
    \ |\e[0m        \e[33mval\e[0m \e[36mnewArr\e[0m = newArr ++ newArr.tail\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mnewArr\
    \ is already defined as \e[33mvalue\e[0m \e[35mnewArr\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same gr"
  stdout: ''
  timestamp: 1660009830
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val len = arr.length\n\
    \        if(len == 1){\n            return true\n        }\n        val sorted\
    \ = arr.sortBy(x => x)\n        val leftShiftOperation = arr(0) >> 1\n       \
    \ val rightShiftOperation = arr(len - 1) >> 1\n        val shifted = sorted.zip(arr).map\
    \ { case (a,b) => b shl 1 orElse a}\n        return shifted.forall(x => x == leftShiftOperation\
    \ || x == rightShiftOperation)\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpaow9034v.scala:33:60 ------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mshifted\e[0m = sorted.zip(arr).map\
    \ { \e[33mcase\e[0m (a,b) => b shl \e[31m1\e[0m orElse a}\n\e[31m\e[31m   |\e\
    [0m                                                          ^^^^^\e[0m\n\e[31m\
    \   |\e[0m                                       value shl is not a member of\
    \ Long\n1 error found\n"
  stdout: ''
  timestamp: 1660009830
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        var i = 0\n    \
    \    val len = arr.length\n        if(arr.isEmpty) true\n        else {\n    \
    \        val res = ArrayBuffer(arr.length)\n            val arr = arr.toBuffer\n\
    \            val stack = ArrayBuffer(arr.length-1)\n            while(i < len)\
    \ {\n                if(stack.length > 0 && stack(0)==i) {\n                 \
    \   val value = arr(i)\n                    val temp = arr(i)\n              \
    \      arr(i) = arr(stack(0))\n                    arr(stack(0)) = value\n   \
    \                 stack = stack.drop(1)\n                }\n                else\
    \ {\n                    arr(i) = arr(stack(0))\n                    stack = stack.drop(1)\n\
    \                }\n                i += 1\n            }\n            arr.toList\
    \ == res.toList\n        }\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\
    \ == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong, 10l.toLong,\
    \ 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpviqnnjtb.scala:31:22 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m            \e[33mval\e[0m \e[36marr\e[0m = arr.toBuffer\n\
    \e[31m\e[31m   |\e[0m                      ^\e[0m\n\e[31m   |\e[0m           \
    \           Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E052] Type Error: /tmp/tmpviqnnjtb.scala:39:26 -----------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m                    stack = stack.drop(\e[31m1\e[0m)\n\
    \e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                    Reassignment to val stack\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E052] Type Error: /tmp/tmpviqnnjtb.scala:43:26 -----------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m                    stack = stack.drop(\e[31m1\e[0m)\n\
    \e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                    Reassignment to val stack\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660009828
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        if (arr.isEmpty)\
    \ true else moveOneBall(arr.tail, arr.head, 0)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp8q1z81xu.scala:26:47\
    \ --------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mif\e[0m (arr.isEmpty)\
    \ \e[31mtrue\e[0m \e[33melse\e[0m moveOneBall(arr.tail, arr.head, \e[31m0\e[0m)\n\
    \e[31m\e[31m   |\e[0m                                               ^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                       Found:    \e[1m\e[31m(\e\
    [0mList[Long]\e[1m\e[31m,\e[0m\e[1m\e[31m \e[0m\e[1m\e[31mLong\e[0m\e[1m\e[31m,\e\
    [0m\e[1m\e[31m \e[0m\e[1m\e[31mInt\e[0m\e[1m\e[31m)\e[0m\n\e[31m   |\e[0m    \
    \                                   Required: List[Long]\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660009833
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val newArr : List[Long]\
    \ = new Array[Long](arr.size)\n        var i = 0\n        for(a <- arr) {\n  \
    \        newArr(i) = a\n          i = i + 1\n        }\n        if(i == 0) return\
    \ true\n        var j = 0\n        while(i < arr.size) {\n          val left =\
    \ newArr.take(i).sortBy(_ < _)\n          val right = newArr.drop(i).sortBy(_\
    \ > _)\n          for(k <- left.indices) {\n            newArr(k) = left(k)\n\
    \          }\n          for(k <- right.indices) {\n            newArr(k + arr.size)\
    \ = right(k)\n          }\n          i = i + 1\n          j = j + 1\n        }\n\
    \        if(j == arr.size) return true\n        return false\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4rmj2z24.scala:26:34\
    \ --------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mnewArr\e\
    [0m : \e[35mList\e[0m[\e[35mLong\e[0m] = \e[33mnew\e[0m \e[35mArray\e[0m[\e[35mLong\e\
    [0m](arr.size)\n\e[31m\e[31m   |\e[0m                                  ^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Found:    \e[1m\e[31mArray\e\
    [0m[Long]\n\e[31m   |\e[0m                                  Required: \e[1m\e\
    [32mList\e[0m[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp4rmj2z24.scala:29:10\
    \ ------------------------\e[0m\e[0m\n\e[31m29 |\e[0m          newArr(i) = a\n\
    \e[31m\e[31m   |\e[0m          ^^^^^^\e[0m\n\e[31m   |\e[0mvalue update is not\
    \ a member of List[Long] - did you mean newArr.updated?\n\e[31m\e[31m-- [E086]\
    \ Syntax Error: /tmp/tmp4rmj2z24.scala:35:43 ---------------------------\e[0m\e\
    [0m\n\e[31m35 |\e[0m          \e[33mval\e[0m \e[36mleft\e[0m = newArr.take(i).sortBy(_\
    \ < _)\n\e[31m\e[31m   |\e[0m                                           ^^^^^\e\
    [0m\n\e[31m   |\e[0m                                 Wrong number of parameters,\
    \ expected: 1\n\e[31m\e[31m-- Error: /tmp/tmp4rmj2z24.scala:35:49 -----------------------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m          \e[33mval\e[0m \e[36mleft\e[0m = newArr.take(i).sortBy(_\
    \ < _)\n\e[31m\e[31m   |\e[0m                                                \
    \ ^\e[0m\n\e[31m   |\e[0mambiguous given instances: both \e[33mobject\e[0m \e\
    [35mByte\e[0m in \e[33mobject\e[0m \e[35mOrdering\e[0m and \e[33mobject\e[0m \e\
    [35mChar\e[0m in \e[33mobject\e[0m \e[35mOrdering\e[0m match type Ordering[B]\
    \ of parameter ord of \e[33mmethod\e[0m \e[35msortBy\e[0m in \e[33mtrait\e[0m\
    \ \e[35mSeqOps\e[0m\n\e[31m\e[31m-- [E086] Syntax Error: /tmp/tmp4rmj2z24.scala:36:44\
    \ ---------------------------\e[0m\e[0m\n\e[31m36 |\e[0m          \e[33mval\e\
    [0m \e[36mright\e[0m = newArr.drop(i).sortBy(_ > _)\n\e[31m\e[31m   |\e[0m   \
    \                                         ^^^^^\e[0m\n\e[31m   |\e[0m        \
    \                         Wrong number of parameters, expected:"
  stdout: ''
  timestamp: 1660009834
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val size = arr.size\n\
    \        if(arr(size-1) > arr(0))\n            return false\n        val max =\
    \ arr(size-2)\n        val min = arr(size-1)\n        val newList = arr.map(x\
    \ => {\n            x match {\n                case 1l => 1l\n               \
    \ case _ => max\n            }\n        })\n        val newSize = newList.size\n\
    \        newList(newSize-size) = min\n        val newArr = newList.toList\n  \
    \      val temp = newArr.drop(size-1)\n        newArr.update(0, temp)\n      \
    \  newArr.update(1, arr(0))\n        val newSize = newArr.size\n        newArr(newSize-size)\
    \ = max\n        return newArr.sorted == arr\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp9iua_ljm.scala:43:12 ---------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m        \e[33mval\e[0m \e[36mnewSize\e[0m = newArr.size\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mnewSize\
    \ is already defined as \e[33mvalue\e[0m \e[35mnewSize\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp9iua_ljm.scala:38:8\
    \ -------------------------\e[0m\e[0m\n\e[31m38 |\e[0m        newList(newSize-size)\
    \ = min\n\e[31m\e[31m   |\e[0m        ^^^^^^^\e[0m\n\e[31m   |\e[0mvalue update\
    \ is not a member of List[Long] - did you mean newList.updated?\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmp9iua_ljm.scala:41:15 ------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m        newArr.update(\e[31m0\e[0m, temp)\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue update is not a member\
    \ of List[Long] - did you mean newArr.updated?\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmp9iua_ljm.scala:42:15 ------------------------\e[0m\e[0m\n\e[31m42\
    \ |\e[0m        newArr.update(\e[31m1\e[0m, arr(\e[31m0\e[0m))\n\e[31m\e[31m \
    \  |\e[0m        ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue update is not a member\
    \ of List[Long] - did you mean newArr.updated?\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmp9iua_ljm.scala:44:8 -------------------------\e[0m\e[0m\n\e[31m44\
    \ |\e[0m        newArr(newSize-size) = max\n\e[31m\e[31m   |\e[0m        ^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue update is not a member of List[Long] - did you mean\
    \ newArr.updated?\n5 errors found\n"
  stdout: ''
  timestamp: 1660009834
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n      val n = arr.size\n\
    \      if (arr.isEmpty) true\n      if (n == 1) false\n      val mid = n/2\n \
    \     val midInd = arr.indexWhere(x => x == mid)\n      val rightInd = midInd\
    \ - 2\n      val rightVal = arr(rightInd)\n      val leftVal = arr(midInd+1)\n\
    \      if (rightVal == leftVal) moveOneBall(arr.tail)\n      else (arr(leftInd+1)\
    \ == rightVal) && moveOneBall(arr.tail)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpyiyoqgo1.scala:35:16 ------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m      \e[33melse\e[0m (arr(leftInd+\e[31m1\e[0m) == rightVal)\
    \ && moveOneBall(arr.tail)\n\e[31m\e[31m   |\e[0m                ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                Not found: leftInd\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[33m\e[33m--\
    \ [E129] Potential Issue Warning: /tmp/tmpyiyoqgo1.scala:27:23 ----------------\e\
    [0m\e[0m\n\e[33m27 |\e[0m      \e[33mif\e[0m (arr.isEmpty) \e[31mtrue\e[0m\n\e\
    [33m\e[33m   |\e[0m                       ^^^^\e[0m\n\e[33m   |\e[0mA pure expression\
    \ does nothing in statement position; you may be omitting necessary parentheses\n\
    \e[33m   |\e[0m\n\e[33m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[33m\e[33m-- [E129] Potential Issue Warning: /tmp/tmpyiyoqgo1.scala:28:18\
    \ ----------------\e[0m\e[0m\n\e[33m28 |\e[0m      \e[33mif\e[0m (n == \e[31m1\e\
    [0m) \e[31mfalse\e[0m\n\e[33m\e[33m   |\e[0m                  ^^^^^\e[0m\n\e[33m\
    \   |\e[0mA pure expression does nothing in statement position; you may be omitting\
    \ necessary parentheses\n\e[33m   |\e[0m\n\e[33m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 warnings found\n1 error found\n"
  stdout: ''
  timestamp: 1660009830
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val l1 = arr.size\
    \ \n        val count = 1\n        val arr2 = arr.toStream\n        val arr3 =\
    \ arr2.scanLeft(arr2(0)) (_+_)\n        arr3.drop(arr3.size).foreach(x => arr3.drop(arr3.size-count).take(count++).foreach(y\
    \ => arr3.insert(arr3.size-count,y)))\n        arr3.size < l1\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpu85177z_.scala:30:81 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        arr3.drop(arr3.size).foreach(\e[36mx\e[0m =>\
    \ arr3.drop(arr3.size-count).take(count++).foreach(\e[36my\e[0m => arr3.insert(arr3.size-count,y)))\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                         ^\e[0m\n\e[31m   |\e[0m                            \
    \           expression expected but \e[31m')'\e[0m found\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpu85177z_.scala:30:101 -----------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        arr3.drop(arr3.size).foreach(\e[36mx\e[0m =>\
    \ arr3.drop(arr3.size-count).take(count++).foreach(\e[36my\e[0m => arr3.insert(arr3.size-count,y)))\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                        ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  value\
    \ insert is not a member of Stream[Long] - did you mean arr3.init?\n2 errors found\n"
  stdout: ''
  timestamp: 1660009833
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        // Write your code\
    \ here\n        if (arr.isEmpty) {\n            return true\n        }\n     \
    \   val first = arr.head\n        val right = arr.tail\n        if (first > last)\
    \ {\n            return false\n        }\n        val mid = right min (right.last)\n\
    \        if (mid > first) {\n            return false\n        }\n        val\
    \ left = right.filter(_ < mid)\n        if (left.isEmpty) {\n            false\n\
    \        } else {\n            val midLeft = left.head\n            val midRight\
    \ = right.filter(_ < midLeft)\n            if (midRight.size > left.size) {\n\
    \                moveOneBall(midRight)\n            } else {\n               \
    \ moveOneBall(left.tail)\n            }\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpp9kjmajr.scala:32:20 ------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mif\e[0m (first > last) {\n\e[31m\e[31m\
    \   |\e[0m                    ^^^^\e[0m\n\e[31m   |\e[0m                    Not\
    \ found: last\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpp9kjmajr.scala:35:35\
    \ --------------------\e[0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e[36mmid\e\
    [0m = right min (right.last)\n\e[31m\e[31m   |\e[0m                          \
    \   ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                             Found:    Long\n\
    \e[31m   |\e[0m                             Required: Ordering[Long]\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660009834
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val len = arr.length\n\
    \        if (len == 0) true\n        else {\n            var i = 1\n         \
    \   var j = 0\n            var k = 0\n            var flag = false\n         \
    \   var temp = 0\n            while (i <= len) {\n                flag = true\n\
    \                while (j < len) {\n                    if (arr(i) > arr(j)) {\n\
    \                        temp = arr(i)\n                        arr(i) = arr(j)\n\
    \                        arr(j) = temp\n                        flag = false\n\
    \                    }\n                    j++\n                }\n         \
    \       k++\n                if (k > len) break\n                i += 1\n    \
    \            j = 0\n                k = 0\n            }\n            if (flag)\
    \ return true\n            else return false\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpclzzdk97.scala:43:23 ---------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m                    j++\n\e[31m\e[31m   |\e[0m      \
    \                 ^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmpclzzdk97.scala:45:19 ---------------------------\e[0m\e[0m\n\e[31m45\
    \ |\e[0m                k++\n\e[31m\e[31m   |\e[0m                   ^\e[0m\n\e\
    [31m   |\e[0m                   expression expected but \e[31mif\e[0m found\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpclzzdk97.scala:38:34\
    \ --------------------\e[0m\e[0m\n\e[31m38 |\e[0m                        temp\
    \ = arr(i)\n\e[31m\e[31m   |\e[0m                               ^^^^^^\e[0m\n\e\
    [31m   |\e[0m                               Found:    Long\n\e[31m   |\e[0m  \
    \                             Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpclzzdk97.scala:39:24 ------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m                        arr(i) = arr(j)\n\e[31m\e[31m\
    \   |\e[0m                        ^^^\e[0m\n\e[31m   |\e[0m  value update is not\
    \ a member of List[Long] - did you mean arr.updated?\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmpclzzdk97.scala:40:24 ------------------------\e[0m\e[0m\n\
    \e[31m40 |\e[0m                        arr(j) = temp\n\e[31m\e[31m   |\e[0m  \
    \                      ^^^\e[0m\n\e[31m   |\e[0m  value update is not a member\
    \ of List[Long] - did you mean arr.updated?\n5 errors found\n"
  stdout: ''
  timestamp: 1660009834
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val arr1 = arr\n\
    \        var cnt = 0\n        var result = true\n        while(arr1.length>0)\
    \ {\n            if (cnt > 0)\n                arr1(arr1.length-1) = (arr1(arr1.length-1)\
    \ + arr1(0))\n            cnt += 1\n            if (arr1(0) > arr1(1)) {\n   \
    \             arr1.remove(arr1(0))\n                arr1.remove(arr1(1))\n   \
    \             arr1.remove(arr1(2))\n                arr1.remove(arr1(3))\n   \
    \             arr1.remove(arr1(4))\n            }\n        }\n        result\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpaom61zbt.scala:31:16 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m                arr1(arr1.length-\e[31m1\e[0m) = (arr1(arr1.length-\e\
    [31m1\e[0m) + arr1(\e[31m0\e[0m))\n\e[31m\e[31m   |\e[0m                ^^^^\e\
    [0m\n\e[31m   |\e[0m value update is not a member of List[Long] - did you mean\
    \ arr1.updated?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpaom61zbt.scala:34:21\
    \ ------------------------\e[0m\e[0m\n\e[31m34 |\e[0m                arr1.remove(arr1(\e\
    [31m0\e[0m))\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0mvalue remove is not a member of List[Long], but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.seq\
    \ AsJavaList\n\e[31m   |\e[0m  import collection.convert.ImplicitConversionsToJava.seq\
    \ AsJavaList\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.collection\
    \ asJava\n\e[31m   |\e[0m  import collection.convert.ImplicitConversionsToJava.collection\
    \ asJava\n\e[31m   |\e[0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpaom61zbt.scala:35:21\
    \ ------------------------\e[0m\e[0m\n\e[31m35 |\e[0m                arr1.remove(arr1(\e\
    [31m1\e[0m))\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0mvalue remove is not a member of List[Long], but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.seq\
    \ AsJavaList\n\e[31m   |\e[0m  import collection.convert.ImplicitConversionsToJava.seq\
    \ AsJavaList\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.collection\
    \ asJava\n\e[31m   |\e[0m  import collection.convert.ImplicitConversionsToJava.collection\
    \ asJava\n\e[31m   |\e[0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpaom61zbt.scala:36:21\
    \ ------------------------\e[0m\e[0m\n\e[31m36 |\e[0m                arr1.remove(arr1(\e\
    [31m2\e[0m))\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e"
  stdout: ''
  timestamp: 1660009838
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        if(arr.isEmpty)\n\
    \            return true\n        \n        val arr = arr.sortBy(_.toLong)\n \
    \       val right = arr.size - 1\n        val left = arr.size \n        val leftSize\
    \ = arr.size - 1\n        val rightSize = arr.size\n        val shifts = leftSize\
    \ * rightSize\n        var index = 0\n        var result = true\n        \n  \
    \      for(i <- 0 until arr.size) {\n            val currentIndex = index\n  \
    \          val currentValue = arr(currentIndex.toLong)\n            val currentShift\
    \ = shifts\n            \n            if(currentValue < arr(currentIndex + 1))\n\
    \                return false\n            \n            val tempRight = arr(currentIndex\
    \ + 1)\n            val tempLeft = arr(currentIndex - 1)\n            \n     \
    \       if(currentShift <= tempLeft && currentShift <= tempRight) {\n        \
    \        val temp = currentValue\n                val temp1 = tempRight\n    \
    \            val temp2 = tempLeft\n                \n                arr = arr.updated(currentIndex\
    \ + 1, temp2)\n                arr = arr.updated(currentIndex - 1, temp)\n   \
    \             \n                right--\n                left--\n            \
    \    shifts--\n            }\n            \n            index = currentIndex\n\
    \        }\n        \n        rightSize -= 1\n        leftSize -= 1\n        \n\
    \        if(arr.size == rightSize) {\n            val temp = arr(right.toLong)\n\
    \            arr = arr.updated(right.toLong, temp - 1)\n            rightSize\
    \ -= 1\n        }\n        \n        if(arr.size == leftSize) {\n            val\
    \ temp = arr(left.toLong)\n            arr = arr.updated(left.toLong, temp + 1)\n\
    \            leftSize -= 1\n        }\n        \n        for(i <- 0 until arr.size)\
    \ {\n            val currentIndex = index\n            val currentValue = arr(currentIndex.toLong)\n\
    \            \n            index = currentIndex + 1\n            \n          \
    \  val tempRight = arr(currentIndex + 1)\n            val tempLeft = arr(currentIndex\
    \ - 1)\n            \n            if(currentValue == tempRight)\n            \
    \    arr = arr.updated(index, tempLeft)\n            \n            if(currentValue\
    \ == tempLeft)\n                arr = arr.updated(index, tempRight)\n        \
    \    \n            if((tempLeft == currentValue) && (tempRight == currentValue))\n\
    \                result = false\n        }\n        \n        result\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpkzk0i_59.scala:59:24 ---------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m                shifts--\n\e[31m\e[31m   |\e[0m     \
    \                   ^\e[0m\n\e[31m   |\e[0m                        expression\
    \ expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmpkzk0i_59.scala:29:18 ---------------------------\e[0m\e[0m\n\e[31m29\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(_.toLong)\n\e[31m\e\
    [31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                  Recursive\
    \ \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E052] Type Error: /tmp/tmpkzk0i_59.scala:54:20 -----------------------------\e\
    [0m\e[0m\n\e[31m54 |\e[0m                arr = arr.updated(currentIndex + \e[31m1\e\
    [0m, temp2)\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                Reassignment to val arr\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E052] Type Error: /tmp/tmpkzk0i_59.scala:55:20 -----------------------------\e\
    [0m\e[0m\n\e[31m55 |\e[0m                arr = arr.updated(currentIndex - \e[31m1\e\
    [0m, temp)\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                Reassignment to val arr\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E052] Type Error: /tmp/tmpkzk0i_59.scala:70:16 -----------------------------\e\
    [0m\e[0m\n\e[31m70 |\e[0m            arr = arr.updated(right.toLong, temp - \e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m            Reassignment to val arr\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E052] Type Error: /tmp/tmpkzk0i_59.scala:76:16 -----------------------------\e\
    [0m\e[0m\n\e[31m76 |\e[0m            ar"
  stdout: ''
  timestamp: 1660009831
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.size\n\
    \        var flag = true\n        val arr1 = mutable.ArrayBuffer(arr.head.asInstanceOf[Long])\n\
    \        val arr = arr.tail\n        for (i <- 1 until n) {\n            val temp\
    \ = arr(i)\n            arr1.append(temp)\n            arr.remove(i)\n       \
    \     arr.add(temp.asInstanceOf[Long])\n        }\n        val first = arr1.reverse.last\n\
    \        val rearrangedArr1 = arr1.reverse\n        val rearrangedArr = rearrangedArr1.reverse\n\
    \        val rearrangedArr1 = rearrangedArr1.reverse\n        val rearrangedArr1\
    \ = rearrangedArr1.reverse\n        val rearrangedArr1 = rearrangedArr1.reverse\n\
    \        val rearrangedArr1 = rearrangedArr1.reverse\n        val rearrangedArr1\
    \ = rearrangedArr1.reverse\n        val rearrangedArr1 = rearrangedArr1.reverse\n\
    \        val rearrangedArr1 = rearrangedArr1.reverse\n        val rearrangedArr1\
    \ = rearrangedArr1.reverse\n        val rearrangedArr1 = rearrangedArr1.reverse\n\
    \        val rearrangedArr1 = rearrangedArr1.reverse\n        val rearrangedArr1\
    \ = rearrangedArr1.reverse\n        val rearrangedArr1 = rearrangedArr1.reverse\n\
    \        val rearrangedArr1 = rearrangedArr1.reverse\n        val rearrangedArr1\
    \ = rearrangedArr1.reverse\n        val rearrangedArr1 = rearrangedArr1.reverse\n\
    \        val rearrangedArr1 = rearrangedArr1.reverse\n        val rearrangedArr1\
    \ = rearrangedArr1.reverse\n        val rearrangedArr1 = rearrangedArr1.reverse\n\
    \        val rearrangedArr1 = rearrangedArr1.reverse\n        val rearrangedArr1\
    \ = rearrangedArr1.reverse\n        val rearrangedArr1 = rearrangedArr1.reverse\n\
    \        val rearrangedArr1 = rearrangedArr1.reverse\n        val rearrangedArr1\
    \ = rearrangedArr1.reverse\n        val rearrangedArr1 = rearrangedArr1.reverse\n\
    \        val rearrangedArr1 = rearrangedArr1.reverse\n        val rearrange\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpx06w9805.scala:65:4 ----------------------------\e\
    [0m\e[0m\n\e[31m65 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpx06w9805.scala:39:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m\
    \ \e[36mrearrangedArr1\e[0m = rearrangedArr1.reverse\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mrearrangedArr1\
    \ is already defined as \e[33mvalue\e[0m \e[35mrearrangedArr1\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpx06w9805.scala:40:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m40 |\e[0m        \e[33mval\e[0m\
    \ \e[36mrearrangedArr1\e[0m = rearrangedArr1.reverse\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mrearrangedArr1\
    \ is already defined as \e[33mvalue\e[0m \e[35mrearrangedArr1\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpx06w9805.scala:41:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m41 |\e[0m        \e[33mval\e[0m\
    \ \e[36mrearrangedArr1\e[0m = rearrangedArr1.reverse\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mrearrangedArr1\
    \ is already defined as \e[33mvalue\e[0m \e[35mrearrangedArr1\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpx06w9805.scala:42:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m42 |\e[0m        \e[33mval\e[0m\
    \ \e[36mrearrangedArr1\e[0m = rearrangedArr1.reverse\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mrearrangedArr1\
    \ is already defined as \e[33mvalue\e[0m \e[35mrearrangedArr1\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m"
  stdout: ''
  timestamp: 1660009835
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val unique = mutable.HashSet[Long]()\n\
    \        val max = 0\n        // check all number in array if exist in unique\
    \ set then return false\n        for ( i <- 0 until arr.size ) unique += arr(i)\n\
    \        // check max number if exist in unique set then return false\n      \
    \  if ( unique contains max )\n            return false\n        // check max\
    \ number if exist in unique set then return false\n        if ( unique contains\
    \ max )\n            return false\n        val min = arr.toList.sorted\n     \
    \   // if array is empty then return true\n        if ( arr.length == 0 )\n  \
    \          return true\n        \n        // check array and shift one by one\
    \ \n        arr.toList.map( x => x match {\n            case x if x == max =>\
    \ max\n            case x if x == min => min\n            case x => x\n      \
    \  }).toList\n        .foldLeft[List[Long]](List[Long]())( _ ++ _)\n        .size\
    \ == arr.length\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpsumqnvit.scala:26:21 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36munique\e[0m = mutable.HashSet[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ Error: /tmp/tmpsumqnvit.scala:44:22 -----------------------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m            \e[33mcase\e[0m x \e[33mif\e[0m x == min\
    \ => min\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m    Values of types Long and List[Long] cannot be compared with == or !=\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpsumqnvit.scala:47:50 --------------------\e\
    [0m\e[0m\n\e[31m47 |\e[0m        .foldLeft[List[Long]](List[Long]())( _ ++ _)\n\
    \e[31m\e[31m   |\e[0m                                                  ^\e[0m\n\
    \e[31m   |\e[0m                                            Found:    (_$2 : Matchable)\n\
    \e[31m   |\e[0m                                            Required: IterableOnce[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660009836
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        if(arr.isEmpty)\n\
    \            return true\n        if(arr.head == arr.last)\n            return\
    \ false\n        val size = arr.size\n        val arr = arr.filter(_ != arr.head)\n\
    \        val head = 0\n        val last = (size - 1).toLong\n        val result\
    \ = scala.util.Try{\n            val res = arr.map {\n                case x if\
    \ x != arr.head =>\n                    val y = x - 1\n                    if(y\
    \ < 0) (arr.head + y).toLong else if (y > last) (y - last).toLong else (arr.head\
    \ + y).toLong\n            }\n            val temp =res.toList\n            val\
    \ sorted = temp.sortBy(x => x)\n            val temp2 = res.toList - sorted\n\
    \            val sorted2 = temp2.sortBy(x => x)\n            if(temp == sorted)\n\
    \                true\n            else if(temp2 == sorted2)\n               \
    \ false\n            else moveOneBall(res.toList)\n        }\n        result.trySuccess(_\
    \ => true)\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpc2jlqk0v.scala:31:18 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.filter(_\
    \ != arr.head)\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m\
    \                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpc2jlqk0v.scala:50:15 ------------------------\e\
    [0m\e[0m\n\e[31m50 |\e[0m        result.trySuccess(_ => \e[31mtrue\e[0m)\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue trySuccess is\
    \ not a member of scala.util.Try[Boolean] - did you mean result.isSuccess?\n2\
    \ errors found\n"
  stdout: ''
  timestamp: 1660009835
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        if (arr.isEmpty)\
    \ {\n            true\n        }\n        val r = new Array[Long](arr.length)\n\
    \        val stack = new mutable.Stack[Long]()\n        for (i <- arr.indices)\
    \ {\n            r.updated(i, arr(i))\n            stack += arr(i)\n        }\n\
    \        while (stack.size > 0) {\n            val top = stack.pop()\n       \
    \     val newTop = (top << 1) + top\n            val isExist = r.contains(newTop)\n\
    \            if (!isExist) {\n                r.updated(newTop, top)\n       \
    \     }\n            stack += top\n        }\n        if (r.size != arr.size)\
    \ {\n            false\n        } else {\n            true\n        }\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpfsitfs1r.scala:30:24 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = \e[33mnew\e\
    [0m mutable.Stack[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                  \
    \      ^^^^^^^\e[0m\n\e[31m   |\e[0m                        Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[33m\e[33m-- [E129] Potential Issue Warning: /tmp/tmpfsitfs1r.scala:27:12\
    \ ----------------\e[0m\e[0m\n\e[33m27 |\e[0m            \e[31mtrue\e[0m\n\e[33m\e\
    [33m   |\e[0m            ^^^^\e[0m\n\e[33m   |\e[0mA pure expression does nothing\
    \ in statement position; you may be omitting necessary parentheses\n\e[33m   |\e\
    [0m\n\e[33m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 warning found\n1 error found\n"
  stdout: ''
  timestamp: 1660009832
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        var ans : Boolean\
    \ = true \n        if (arr.isEmpty) {\n            return true \n        }\n \
    \       for (i<- arr.indices) {\n            val index = arr.length - i - 1 \n\
    \            val arr = arr.remove(index)\n            if (arr > 0) {\n       \
    \         val arr1 = arr :: arr.remove(0)\n                ans = moveOneBall(arr1)\
    \ \n            } else {\n                val arr1 = arr.toList.sorted.reverse.tail\n\
    \                ans = moveOneBall(arr1) \n            }\n        }\n        return\
    \ ans\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpj89xk48j.scala:32:22 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m            \e[33mval\e[0m \e[36marr\e[0m = arr.remove(index)\n\
    \e[31m\e[31m   |\e[0m                      ^\e[0m\n\e[31m   |\e[0m           \
    \           Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660009832
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val list = new mutable.PriorityQueue[Long]()\n\
    \        val m = arr.length\n        if (m == 0) {\n            return true\n\
    \        } else {\n            for (x <- arr) {\n                if (list.size\
    \ < m) {\n                    list += x\n                }\n            }\n  \
    \          if (list.size < m) {\n                return false\n            } else\
    \ {\n                val temp: Long = list.dequeue\n                val rest:\
    \ Long = list.dequeue\n                val rest1 = (rest % m).toLong\n       \
    \         val rest2 = (rest - rest1).toLong\n                list.dequeue += 1\n\
    \                list.dequeue += 1\n                list.enqueue(temp + rest1)\n\
    \                list.enqueue(rest2)\n                list.enqueue(rest1)\n  \
    \              list.enqueue(rest)\n                list.enqueue(rest + 1)\n  \
    \              list.enqueue(rest + 2)\n                return moveOneBall(arr)\n\
    \            }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpvcse2xs8.scala:26:23 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mlist\e[0m = \e[33mnew\e\
    [0m mutable.PriorityQueue[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m          \
    \             ^^^^^^^\e[0m\n\e[31m   |\e[0m                       Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009832
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.size\n\
    \        val sortedList = arr.sortBy(-_)\n        val sum = (0 until sortedList.length).sum\n\
    \        val numOfRightShifts = arr.length\n        val result = sum - numOfRightShifts\n\
    \        sum == result\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmps9pjwshb.scala:34)\n\tat Problem.main(tmps9pjwshb.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009840
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        if(arr.isEmpty)\
    \ {\n            true\n        } else {\n            val newList = arr.map(x =>\
    \ x.toLong).reverse\n            val sortedList = newList.foldLeft(newList)( (acc,\
    \ x) => \n                if(acc < x) acc else acc.shiftRight(x-acc.last)) \n\
    \            if(sortedList.forall(x <= y=> x < y) &&  sortedList.forall(y >= x=>\
    \ y < x)) {\n                true\n            } else {\n                false\n\
    \            }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpwy6n03b3.scala:32:35 -----------------------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m            \e[33mif\e[0m(sortedList.forall(x <= y=>\
    \ x < y) &&  sortedList.forall(y >= x=> y < x)) {\n\e[31m\e[31m   |\e[0m     \
    \                            ^^^^^^\e[0m\n\e[31m   |\e[0m                    \
    \             not a legal formal parameter\n\e[31m\e[31m-- Error: /tmp/tmpwy6n03b3.scala:32:73\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m32 |\e[0m       \
    \     \e[33mif\e[0m(sortedList.forall(x <= y=> x < y) &&  sortedList.forall(y\
    \ >= x=> y < x)) {\n\e[31m\e[31m   |\e[0m                                    \
    \                                   ^^^^^^\e[0m\n\e[31m   |\e[0m             \
    \                               not a legal formal parameter\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpwy6n03b3.scala:31:23 ------------------------\e[0m\e\
    [0m\n\e[31m31 |\e[0m                \e[33mif\e[0m(acc < x) acc \e[33melse\e[0m\
    \ acc.shiftRight(x-acc.last)) \n\e[31m\e[31m   |\e[0m                   ^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue < is not a member of List[Long], but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m  import math.Ordered.orderingToOrdered\n\e[31m   |\e[0m  import\
    \ math.Ordering.Implicits.infixOrderingOps\n\e[31m   |\e[0m\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpwy6n03b3.scala:31:41 ------------------------\e[0m\e\
    [0m\n\e[31m31 |\e[0m                \e[33mif\e[0m(acc < x) acc \e[33melse\e[0m\
    \ acc.shiftRight(x-acc.last)) \n\e[31m\e[31m   |\e[0m                        \
    \             ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                          value\
    \ shiftRight is not a member of List[Long]\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpwy6n03b3.scala:32:42 ------------------------\e[0m\e[0m\n\e[31m32 |\e\
    [0m            \e[33mif\e[0m(sortedList.forall(x <= y=> x < y) &&  sortedList.forall(y\
    \ >= x=> y < x)) {\n\e[31m\e[31m   |\e[0m                                    \
    \      ^\e[0m\n\e[31m   |\e[0m                                          Not found:\
    \ x\n\e[31m  "
  stdout: ''
  timestamp: 1660009842
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        if(arr.isEmpty)\
    \ {\n            true\n        } else {\n            var count = 1\n         \
    \   var cur = arr.head\n            var temp = 0\n            while(count <= arr.size)\
    \ {\n                cur = cur.rightShift\n                temp = temp.rightShift\n\
    \                count += 1\n            }\n            if(cur.equals(temp)) {\n\
    \                true\n            } else {\n                false\n         \
    \   }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp5wdj_2ud.scala:33:26 ------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m                cur = cur.rightShift\n\e[31m\e[31m  \
    \ |\e[0m                      ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m           \
    \           value rightShift is not a member of Long\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmp5wdj_2ud.scala:34:28 ------------------------\e[0m\e[0m\n\
    \e[31m34 |\e[0m                temp = temp.rightShift\n\e[31m\e[31m   |\e[0m \
    \                      ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                 \
    \      value rightShift is not a member of Int\n2 errors found\n"
  stdout: ''
  timestamp: 1660009841
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        if(arr.isEmpty)\
    \ true\n        else {\n            val n = arr.length\n            val newArr\
    \ = arr.zipWithIndex.sortBy(_._1)\n            val newArrSize = newArr.length\n\
    \            val minValue = newArr(0)._1\n            val maxValue = newArr(newArrSize\
    \ - 1)._1\n            val newMaxValue = maxValue + 1\n            newArr.foreach{x\
    \ => arr(x._2) = x._1}\n            newArr.foreach { x => arr(x._2) = x._1 }\n\
    \            val newMinValue = minValue - 1\n            val newMinIndex = newArr.indexWhere(_._1\
    \ < newMinValue)\n            val newMaxIndex = newArr.indexWhere(_._1 >= newMaxValue)\n\
    \            val shiftIndex = newMinIndex\n            var temp = 0\n        \
    \    while(shiftIndex >= 0 && (temp < newArrSize)) {\n                val temp\
    \ = newArr.tail(shiftIndex).foldLeft(0)((acc, x) => acc + (x - arr[x._2] - 1))\n\
    \                if(temp == 0) shiftIndex = shiftIndex - 1\n                else\
    \ shiftIndex = shiftIndex - temp\n            }\n            val result = newArr(0).toLong\
    \ >= newArr(n-1).toLong\n            if(!result) moveOneBall(newArr)\n       \
    \     else result\n        }\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmplzz610c1.scala:34:32 ------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m            newArr.foreach{\e[36mx\e[0m => arr(x._2)\
    \ = x._1}\n\e[31m\e[31m   |\e[0m                                ^^^\e[0m\n\e[31m\
    \   |\e[0m  value update is not a member of List[Long] - did you mean arr.updated?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmplzz610c1.scala:35:34 ------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m            newArr.foreach { \e[36mx\e[0m => arr(x._2)\
    \ = x._1 }\n\e[31m\e[31m   |\e[0m                                  ^^^\e[0m\n\e\
    [31m   |\e[0m  value update is not a member of List[Long] - did you mean arr.updated?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmplzz610c1.scala:42:51 ------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m                \e[33mval\e[0m \e[36mtemp\e[0m = newArr.tail(shiftIndex).foldLeft(\e\
    [31m0\e[0m)((\e[36macc\e[0m, \e[36mx\e[0m) => acc + (x - arr[x._2] - \e[31m1\e\
    [0m))\n\e[31m\e[31m   |\e[0m                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                           value foldLeft is not a member\
    \ of (Long, Int)\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmplzz610c1.scala:43:41\
    \ -----------------------------\e[0m\e[0m\n\e[31m43 |\e[0m                \e[33mif\e\
    [0m(temp == \e[31m0\e[0m) shiftIndex = shiftIndex - \e[31m1\e[0m\n\e[31m\e[31m\
    \   |\e[0m                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                              Reassignment to val shiftIndex\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E052] Type Error: /tmp/tmplzz610c1.scala:44:32 -----------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m                \e[33melse\e[0m shiftIndex = shiftIndex\
    \ - temp\n\e[31m\e[31m   |\e[0m                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                     Reassignment to val shiftIndex\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmplzz610c1.scala:46:35 ------------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m            \e[33mval\e[0m \e"
  stdout: ''
  timestamp: 1660009843
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n      val arr = arr.toArray\n\
    \      // The list is empty or contains only one element\n      if (arr.length\
    \ == 0 || arr.length == 1) return true\n      val len = arr.length\n      val\
    \ shift = len - 2\n      val maxDiff = arr.zip(arr ++ Array(arr(shift)))\n   \
    \     .toMap\n          .keys\n          .diffUsing(compare(_, _))\n         \
    \ .maxBy(_._1)\n          .map(k => (k._2, k._1)).getOrElse((-Int.MaxValue, Int.MaxValue))\n\
    \          ._1\n          ._2\n          ._1\n          ._2\n          if (maxDiff\
    \ != shift) return false\n      val minDiff = arr.zip(arr ++ Array(arr(shift)))\n\
    \        .toMap\n          .keys\n          .diffUsing(compare(_, _))\n      \
    \    .minBy(_._1)\n          .map(k => (k._2, k._1)).getOrElse((Int.MaxValue,\
    \ Int.MinValue))\n          ._1\n          ._2\n          ._1\n          ._2\n\
    \          if (minDiff != shift) return false\n      true\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpg3s8wx9w.scala:26:16 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m      \e[33mval\e[0m \e[36marr\e[0m = arr.toArray\n\e\
    [31m\e[31m   |\e[0m                ^\e[0m\n\e[31m   |\e[0m                Recursive\
    \ \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009837
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        var i = 1\n    \
    \    var lastElem = arr(0)\n        var flag = true\n        for (x <- arr) {\n\
    \            if (x != lastElem) {\n                lastElem = x\n            \
    \    i = 0\n            } else {\n                i += 1\n            }\n    \
    \        if (i > arr.size - 1) {\n                flag = false\n             \
    \   break\n            }\n        }\n        flag\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmph6ydcb0m.scala:38:16 ------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m                break\n\e[31m\e[31m   |\e[0m        \
    \        ^^^^^\e[0m\n\e[31m   |\e[0m                Not found: break\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660009838
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        if (arr.isEmpty)\
    \ {\n            return true\n        }\n        var flag = true\n        var\
    \ prev = 0\n        var curr = 0\n        var temp = 0\n        for (i <- arr.indices)\
    \ {\n            prev = arr(i)\n            curr = arr(i+1)\n            if (curr\
    \ > prev) {\n                temp = prev\n                prev = curr\n      \
    \          curr = temp\n            }\n        }\n        arr.updated(0, curr)\n\
    \        for (i <- arr.indices) {\n            prev = arr(i)\n            if (flag)\
    \ {\n                arr.updated(i, prev)\n            }\n            else {\n\
    \                arr.updated(i, curr)\n            }\n            flag = !flag\n\
    \        }\n        return true\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpwhd9788m.scala:34:22\
    \ --------------------\e[0m\e[0m\n\e[31m34 |\e[0m            prev = arr(i)\n\e\
    [31m\e[31m   |\e[0m                   ^^^^^^\e[0m\n\e[31m   |\e[0m           \
    \        Found:    Long\n\e[31m   |\e[0m                   Required: Int\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpwhd9788m.scala:35:22 --------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m            curr = arr(i+\e[31m1\e[0m)\n\e[31m\e[31m\
    \   |\e[0m                   ^^^^^^^^\e[0m\n\e[31m   |\e[0m                  \
    \ Found:    Long\n\e[31m   |\e[0m                   Required: Int\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpwhd9788m.scala:44:22 --------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m            prev = arr(i)\n\e[31m\e[31m   |\e[0m    \
    \               ^^^^^^\e[0m\n\e[31m   |\e[0m                   Found:    Long\n\
    \e[31m   |\e[0m                   Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660009843
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n      val listCopy = arr.toList\n\
    \      var i = 0\n      val result = (1 to arr.length).map { x =>\n        if\
    \ (i < (arr.length)) {\n          val tempList = arr.toList.slice(i)\n       \
    \   val tempListCopy = tempList.toList\n          tempListCopy.rightShift()\n\
    \          tempListCopy.foreach { x =>\n            tempList.remove(x)\n     \
    \     }\n          listCopy.insert(i, tempListCopy.toLong)\n          i += 1\n\
    \          true\n        } else {\n          listCopy.foreach { x =>\n       \
    \     tempList.remove(x)\n          }\n          false\n        }\n      }\n \
    \     result\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp3huq46j8.scala:30:41 -----------------------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m          \e[33mval\e[0m \e[36mtempList\e[0m = arr.toList.slice(i)\n\
    \e[31m\e[31m   |\e[0m                         ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mmissing argument for parameter until of \e[33mmethod\e[0m \e[35mslice\e\
    [0m in \e[33mclass\e[0m \e[35mList\e[0m: (from: Int, until: Int): List[Long]\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp3huq46j8.scala:36:19 ------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m          listCopy.insert(i, tempListCopy.toLong)\n\e\
    [31m\e[31m   |\e[0m          ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue insert\
    \ is not a member of List[Long] - did you mean listCopy.init?\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp3huq46j8.scala:41:12 ------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m            tempList.remove(x)\n\e[31m\e[31m   |\e[0m\
    \            ^^^^^^^^\e[0m\n\e[31m   |\e[0m            Not found: tempList\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp3huq46j8.scala:46:6\
    \ ---------------------\e[0m\e[0m\n\e[31m46 |\e[0m      result\n\e[31m\e[31m \
    \  |\e[0m      ^^^^^^\e[0m\n\e[31m   |\e[0m      Found:    (result : IndexedSeq[Boolean])\n\
    \e[31m   |\e[0m      Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660009843
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val a = arr.toList\n\
    \        val n = arr.length\n        val b = List(0)\n        val c = a.indices.toList\n\
    \        val d = c.length - 1\n        var e : Boolean = true\n        var j :\
    \ Int = 0\n        while(e && j < d) {\n            while(j >= 0) {\n        \
    \        b += a(c.apply(j))\n                j -= 1\n            }\n         \
    \   val tempList : mutable.ListBuffer[Long] = ListBuffer()\n            for(i\
    \ <- 0 until b.length) tempList += b(i)\n            val temp = tempList.toList\n\
    \            if(temp.distinct.size == 0) {\n                e = false\n      \
    \          break\n            }\n            if(tempList(temp.size - 1) == 0)\
    \ {\n                tempList = tempList.dropRight(1)\n                tempList\
    \ += temp(0)\n                j = 0\n            } else {\n                tempList\
    \ += temp(0)\n                j = 0\n            }\n        }\n        if(!e)\
    \ {\n            true\n        } else {\n            false\n        }\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp4u0x6kqm.scala:35:18 ------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m                b += a(c.apply(j))\n\e[31m\e[31m   |\e\
    [0m                ^^^^\e[0m\n\e[31m   |\e[0m              value += is not a member\
    \ of List[Int] - did you mean b.!=?\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp4u0x6kqm.scala:38:27\
    \ ------------------------\e[0m\e[0m\n\e[31m38 |\e[0m            \e[33mval\e[0m\
    \ \e[36mtempList\e[0m : mutable.ListBuffer[\e[35mLong\e[0m] = ListBuffer()\n\e\
    [31m\e[31m   |\e[0m                           ^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                         Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp4u0x6kqm.scala:43:16 ------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m                break\n\e[31m\e[31m   |\e[0m        \
    \        ^^^^^\e[0m\n\e[31m   |\e[0m                Not found: break\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E052] Type Error: /tmp/tmp4u0x6kqm.scala:46:25 -----------------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m                tempList = tempList.dropRight(\e[31m1\e\
    [0m)\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                Reassignment to val tempList\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1660009842
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n      val sortedList = arr.toList.sortWith(_\
    \ < _) \n      val firstListSize = sortedList.head\n      val lastListSize = arr.last\n\
    \      if(firstListSize < lastListSize) {\n        val lastListIndex =arr.lastIndex\n\
    \        var lastListIndex = lastListIndex - 1\n        val lastListElement =\
    \ arr(lastListIndex).asInstanceOf[Long]\n        val firstListElement = arr(firstListIndex).asInstanceOf[Long]\n\
    \        if(lastListElement > firstListElement) {\n          val temp = lastListIndex\n\
    \          lastListIndex = firstListIndex\n          firstListIndex = temp\n \
    \         val temp = lastListElement\n          lastListElement = firstListElement\n\
    \          firstListElement = temp\n        }\n      }\n      sortedList.head\
    \ < sortedList(sortedList.size-1)\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp59xxcs9m.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mvar\e[0m \e[36mlastListIndex\e[0m = lastListIndex\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mlastListIndex is already defined as \e[33mvalue\e[0m \e[35mlastListIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmp59xxcs9m.scala:30:31 ------------------------\e[0m\e[0m\n\
    \e[31m30 |\e[0m        \e[33mval\e[0m \e[36mlastListIndex\e[0m =arr.lastIndex\n\
    \e[31m\e[31m   |\e[0m                           ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mvalue lastIndex is not a member of List[Long] - did you mean arr.lastIndexOf?\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp59xxcs9m.scala:33:35 ------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mfirstListElement\e[0m =\
    \ arr(firstListIndex).asInstanceOf[\e[35mLong\e[0m]\n\e[31m\e[31m   |\e[0m   \
    \                                ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        \
    \                           Not found: firstListIndex\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp59xxcs9m.scala:38:14 ---------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m          \e[33mval\e[0m \e[36mtemp\e[0m = lastListElement\n\
    \e[31m\e[31m   |\e[0m          ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mtemp\
    \ is already defined as \e[33mvalue\e[0m \e[35mtemp\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp59xxcs9m.scala:36:26\
    \ ------------------------\e[0m\e[0m\n\e[31m36 |\e[0m          lastListIndex =\
    \ firstListIndex\n\e[31m\e[31m   |\e[0m                          ^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                          Not found: firstListIndex\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tm"
  stdout: ''
  timestamp: 1660009843
- exit_code: -1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        if (arr.isEmpty)\
    \ true\n        else { \n            // If we have two elements in the list then\
    \ we can do one right shift and one left shift\n            val leftArr = arr.drop(1).reverse\n\
    \            val rightArr = arr.take(1).reverse\n            if (leftArr == rightArr)\
    \ moveOneBall(leftArr) && moveOneBall(rightArr)\n            else\n          \
    \      moveOneBall(leftArr) && moveOneBall(rightArr)\n        }\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1660009849
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        var shift : Long\
    \ = 0\n        while (arr.nonEmpty) {\n            arr.tail.foreach(x => shift\
    \ += x)\n            if (arr(0) - shift <= 0)\n                return false\n\
    \            shift -= arr(0)\n            arr.remove(arr.head) // move last element\
    \ to the beginning of the list\n            arr += arr.head // append the element\
    \ at the start of the list\n        }\n        true\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpt30twi11.scala:32:16 ------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m            arr.remove(arr.head) \e[34m// move last element\
    \ to the beginning of the list\e[0m\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m   value remove is not a member of List[Long] - did you mean\
    \ arr.reduce?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpt30twi11.scala:33:16\
    \ ------------------------\e[0m\e[0m\n\e[31m33 |\e[0m            arr += arr.head\
    \ \e[34m// append the element at the start of the list\e[0m\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^\e[0m\n\e[31m   |\e[0m           value += is not a member\
    \ of List[Long] - did you mean arr.!=?\n2 errors found\n"
  stdout: ''
  timestamp: 1660009845
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        if((arr.isEmpty)\
    \ == true)\n            return true\n        val arr = arr.sortWith(compare)\n\
    \        val left = 0\n        val right = arr.length - 1\n        var isSorted\
    \ = true\n        while(left < right) {\n            isSorted = true\n       \
    \     while(isSorted == true && left < right && (arr.head < arr.last)) {\n   \
    \             val temp = arr.head\n                arr.head = arr.last\n     \
    \           arr.last = temp\n                left += 1\n                isSorted\
    \ = false\n            }\n            while(isSorted == true && left < right &&\
    \ (arr.last > arr.head)) {\n                val temp = arr.last\n            \
    \    arr.last = arr.head\n                arr.head = temp\n                right\
    \ -= 1\n                isSorted = false\n            }\n        }\n        return\
    \ isSorted\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpxxici9d4.scala:28:18 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortWith(compare)\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpxxici9d4.scala:38:21 ------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m                left += \e[31m1\e[0m\n\e[31m\e[31m  \
    \ |\e[0m                ^^^^^^^\e[0m\n\e[31m   |\e[0m                value +=\
    \ is not a member of Int - did you mean left.!=?\n2 errors found\n"
  stdout: ''
  timestamp: 1660009844
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val stack = scala.collection.mutable.Stack[Int]()\n\
    \        for(i <- 1 to n)\n        {\n            stack push i\n            val\
    \ first = arr(1)\n            val last = arr(n)\n            val temp = arr\n\
    \            arr.remove(1)\n            arr.insert(1, first)\n            for(j\
    \ <- 2 to n)\n            {\n                if(arr(j) > last)\n             \
    \   {\n                    arr.remove(j)\n                    arr.insert(j, arr(j-1))\n\
    \                }\n                else if(arr(j) < first)\n                {\n\
    \                    arr.remove(j)\n                    arr.insert(j, arr(j+1))\n\
    \                }\n                else\n                {\n                \
    \    arr.remove(j)\n                }\n            }\n            arr.remove(n)\n\
    \            arr.insert(0, temp(0))\n            arr.remove(0)\n        }\n  \
    \      stack.empty\n        arr.isEmpty\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpe8r_iucx.scala:27:18 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660009843
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.length\n\
    \        if (n == 0) true\n        else { \n            val counts = arr.count(_\
    \ < 0)\n            val maxI = arr.lastIndex\n            val maxJ = arr.lastIndex\
    \ - 1\n            if (maxI == -1 || maxJ == -1) return false\n            val\
    \ j = counts - 1\n            if (maxI + 1 == maxJ) arr(maxI) <- arr(0)\n    \
    \        else if (j < 0) arr(maxJ) <- arr(0)\n            else arr(maxI) <- arr(maxJ)\n\
    \            moveOneBall(arr.tail)\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpkecobpsb.scala:34:44 -----------------------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m            \e[33mif\e[0m (maxI + \e[31m1\e[0m == maxJ)\
    \ arr(maxI) <- arr(\e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m                      \
    \                      ^^\e[0m\n\e[31m   |\e[0m                              \
    \  end of statement expected but '<-' found\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpkecobpsb.scala:30:27 ------------------------\e[0m\e[0m\n\e[31m30 |\e\
    [0m            \e[33mval\e[0m \e[36mmaxI\e[0m = arr.lastIndex\n\e[31m\e[31m  \
    \ |\e[0m                       ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue lastIndex\
    \ is not a member of List[Long] - did you mean arr.lastIndexOf?\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpkecobpsb.scala:31:27 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m            \e[33mval\e[0m \e[36mmaxJ\e[0m = arr.lastIndex\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m                       ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue lastIndex is not a member of List[Long] - did you mean\
    \ arr.lastIndexOf?\n3 errors found\n"
  stdout: ''
  timestamp: 1660009846
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        var shift : Int\
    \ = 0\n        var sortedArr: List[Long] = arr.toList.sorted\n        var flag\
    \ : Boolean = false\n        while (true) {\n            shift += 1\n        \
    \    // Move the previous element to 0th index if shift is 1\n            if (shift\
    \ == 1) {\n                sortedArr(0) = arr.last\n                arr.last =\
    \ 0\n            }\n            // Shift the last element of the list to the 0th\
    \ position if shift is 2\n            if (shift == 2) {\n                val tempArr\
    \ = arr.last\n                val tempSortedArr = arr.last.toList\n          \
    \      arr.last = 0\n                arr.insert(0, tempArr)\n                arr.toList\
    \ = tempSortedArr\n            }\n            // Reverse the list if the shift\
    \ is greater than 2\n            if (shift > 2) arr = arr.reverse\n          \
    \  // Check if it is possible to get the list in non-decreasing order\n      \
    \      if (arr.toList.sorted < sortedArr) {\n                sortedArr = arr.toList.sorted\n\
    \                flag = true\n                println(sortedArr)\n           \
    \     println(arr.toList)\n            }\n            else false\n        }\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpq669mu86.scala:33:16 ------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m                sortedArr(\e[31m0\e[0m) = arr.last\n\e\
    [31m\e[31m   |\e[0m                ^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue update\
    \ is not a member of List[Long] - did you mean List[Long].updated?\n\e[31m\e[31m--\
    \ [E052] Type Error: /tmp/tmpq669mu86.scala:34:25 -----------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m                arr.last = \e[31m0\e[0m\n\e[31m\e[31m\
    \   |\e[0m                ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                Reassignment\
    \ to val last\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpq669mu86.scala:39:45\
    \ ------------------------\e[0m\e[0m\n\e[31m39 |\e[0m                \e[33mval\e\
    [0m \e[36mtempSortedArr\e[0m = arr.last.toList\n\e[31m\e[31m   |\e[0m        \
    \                            ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m         value\
    \ toList is not a member of Long - did you mean Long.toInt?\n\e[31m\e[31m-- [E052]\
    \ Type Error: /tmp/tmpq669mu86.scala:40:25 -----------------------------\e[0m\e\
    [0m\n\e[31m40 |\e[0m                arr.last = \e[31m0\e[0m\n\e[31m\e[31m   |\e\
    [0m                ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                Reassignment\
    \ to val last\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpq669mu86.scala:41:20\
    \ ------------------------\e[0m\e[0m\n\e[31m41 |\e[0m                arr.insert(\e\
    [31m0\e[0m, tempArr)\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m     value insert is not a member of List[Long] - did you mean arr.init?\n\
    \e[31m\e[31m-- [E052] Type Error: /tmp/tmpq669mu86.scala:42:27 -----------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m                arr.toList = tempSortedArr\n\e[31m\e\
    [31m   |\e[0m                ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                Reassignment to val toList\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E052] Type Error: /tmp/tmpq669mu86.scala:45:31 "
  stdout: ''
  timestamp: 1660009849
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        var rightShift :\
    \ Boolean = false\n        val result = arr.foldLeft(false)((accum, cur) => {\n\
    \            if (rightShift) {\n                if (accum) accum = false\n   \
    \             else cur.toLong\n            } else {\n                if (accum)\
    \ accum = cur.toLong\n                else false\n            }\n        })\n\
    \        rightShift = true\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmp1gqtegur.scala:29:33 -----------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m                \e[33mif\e[0m (accum) accum = \e[31mfalse\e\
    [0m\n\e[31m\e[31m   |\e[0m                           ^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                           Reassignment to val accum\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp1gqtegur.scala:30:25 --------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m                \e[33melse\e[0m cur.toLong\n\e[31m\e\
    [31m   |\e[0m                     ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m           \
    \          Found:    Long\n\e[31m   |\e[0m                     Required: Boolean\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp1gqtegur.scala:32:39\
    \ --------------------\e[0m\e[0m\n\e[31m32 |\e[0m                \e[33mif\e[0m\
    \ (accum) accum = cur.toLong\n\e[31m\e[31m   |\e[0m                          \
    \         ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                                   Found:\
    \    Long\n\e[31m   |\e[0m                                   Required: Boolean\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660009848
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        if(arr.isEmpty)\n\
    \            true\n        else{\n            var shiftCount = 0\n           \
    \ for(i <- 0 until arr.size){\n                if(shiftCount == 0){\n        \
    \            arr(i) += 1\n                }else{\n                    arr(i) -=\
    \ 1\n                    shiftCount += 1\n                }\n            }\n \
    \           if(arr.last > 0){\n                shiftCount += 1\n            }\n\
    \            arr.take(shiftCount).forall(element => element > 0)\n        }\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp6vhflnzi.scala:32:27 ------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m                    arr(i) += \e[31m1\e[0m\n\e[31m\e\
    [31m   |\e[0m                    ^^^^^^^^^\e[0m\n\e[31m   |\e[0m             \
    \   value += is not a member of Long - did you mean Long.!=?\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp6vhflnzi.scala:34:27 ------------------------\e[0m\e\
    [0m\n\e[31m34 |\e[0m                    arr(i) -= \e[31m1\e[0m\n\e[31m\e[31m \
    \  |\e[0m                    ^^^^^^^^^\e[0m\n\e[31m   |\e[0m                value\
    \ -= is not a member of Long - did you mean Long.!=?\n2 errors found\n"
  stdout: ''
  timestamp: 1660009848
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val countArray =\
    \ new Array[Long](arr.size)\n        val leftArray = new Array[Long](arr.size)\n\
    \        val rightArray = new Array[Long](arr.size)\n        val tempArray = new\
    \ Array[Long](arr.size)\n        val arr1 = arr.toArray\n        val arr2 = arr.toArray\n\
    \        for(i <- 0 until arr1.size) {\n            if(arr1(i) != arr1(0)) {\n\
    \                countArray(i) = 0\n                leftArray(i) = arr1(i)\n \
    \               rightArray(i) = arr1(i-1)\n                tempArray(i) = 0\n\
    \            }\n            else if(arr1(i) == arr1(0)) {\n                countArray(i)\
    \ = 1\n                leftArray(i) = arr2(i)\n                rightArray(i) =\
    \ arr2(i-1)\n                tempArray(i) = 0\n            }\n            else\
    \ if(arr1(i) <= arr1(0)) {\n                countArray(i) = 0\n              \
    \  leftArray(i) = arr1(i)\n                rightArray(i) = arr1(i-1)\n       \
    \         tempArray(i) = 0\n            }\n            else {\n              \
    \  countArray(i) = 1\n                leftArray(i) = arr2(i)\n               \
    \ rightArray(i) = arr2(i-1)\n                tempArray(i) = 0\n            }\n\
    \        }\n        for(i <- 0 until tempArray.length) {\n            if(countArray(i)\
    \ == 1) {\n                if(tempArray(i) == 0) {\n                    arr2(i)\
    \ = leftArray(i)\n                }\n                else if(tempArray(i) == 1)\
    \ {\n                    arr2(i) = rightArray(i)\n                }\n        \
    \        else {\n                    arr2(i) = arr1(i)\n                }\n  \
    \          }\n            else if(countArray(i) == 0) {\n                arr2(i)\
    \ = 0\n            }\n            else {\n                arr2(i) = 0\n      \
    \      }\n        }\n        for(i <- 0 until arr1.size) {\n            if(arr1(i)\
    \ != arr1(0)) {\n                arr1(i) = arr2(i)\n            }\n        }\n\
    \        if(arr1(0).equals(0)) {\n            return true\n        }\n       \
    \ else {\n            return false\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index -1 out of bounds for length\
    \ 5\n\tat Problem$.moveOneBall$$anonfun$1(tmp47c6zdap.scala:42)\n\tat scala.runtime.java8.JFunction1$mcVI$sp.apply(JFunction1$mcVI$sp.scala:18)\n\
    \tat scala.collection.immutable.Range.foreach(Range.scala:190)\n\tat Problem$.moveOneBall(tmp47c6zdap.scala:57)\n\
    \tat Problem$.main(tmp47c6zdap.scala:90)\n\tat Problem.main(tmp47c6zdap.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009850
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        if(arr.isEmpty)\
    \ return true\n        if(arr.head.toInt - 1 == arr.last.toInt) return false\n\
    \        \n        // Create mutable data structure which will store last element\
    \ of given list\n        val l = mutable.ListBuffer[Long](arr.last)\n        var\
    \ i = arr.size - 1\n        \n        // Perform right shift operation on last\
    \ element of given list untill it reaches\n        // 0th index. \n        while(i\
    \ > 0) {\n            val value = arr.delete(i)\n            l.insert(0, value)\n\
    \            i -= 1\n        }\n        \n        // Compare the list l with arr\n\
    \        if(arr == l) return true\n        \n        // If not true, then it is\
    \ impossible to get non-decreasing order for the\n        // given list\n    \
    \    return false\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp17j_fyv4.scala:30:16 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36ml\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m](arr.last)\n\e[31m\e[31m   |\e[0m                ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmp17j_fyv4.scala:36:28 ------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m            \e[33mval\e[0m \e[36mvalue\e[0m = arr.delete(i)\n\
    \e[31m\e[31m   |\e[0m                        ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                        value delete is not a member of List[Long]\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660009848
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n       var index = 0\n \
    \      var cur = arr(index)\n       var isRightShifted = false\n       var newList\
    \ = new ArrayList[Long]()\n       while(index < arr.size){\n           if(isRightShifted){\n\
    \              newList.add(cur)\n              index+=1\n              cur = arr(index)\n\
    \           }else{\n               if(cur > arr(index-1)){\n                 \
    \  index+=1\n                   cur = arr(index)\n               }else{\n    \
    \               cur >>= 1;\n                   isRightShifted = true\n       \
    \        }\n           }\n       }\n       if(index == 0)\n          true\n  \
    \     else\n          false\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpknv_bp3l.scala:29:25 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m       \e[33mvar\e[0m \e[36mnewList\e[0m = \e[33mnew\e\
    [0m \e[35mArrayList\e[0m[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m           \
    \              ^^^^^^^^^\e[0m\n\e[31m   |\e[0m                         Not found:\
    \ type ArrayList\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009846
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        if (arr.size ==\
    \ 0) return true\n        val len = arr.size\n        val last = arr.last\n  \
    \      val cur = arr.head\n        val rem = len - arr.size\n        val result\
    \ = (len - 1) * rem + 1\n        val arr = new Array[Long](result)\n        var\
    \ start = 0\n        var end = 0\n        while (end < arr.size) {\n         \
    \   start += 1\n            if (cur < last) {\n                arr(end) = last\n\
    \                end += 1\n            } else {\n                arr(end) = cur\n\
    \                end += 1\n            }\n        }\n        if (arr.equals(arr.reverse))\
    \ true else false\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpo7ia6ked.scala:27:18 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mlen\e[0m = arr.size\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660009846
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        if (arr.isEmpty)\n\
    \            return true\n        var len = arr.size\n        for (i <- 0 until\
    \ len-1) {\n            if (arr(i) < arr(i+1)) {\n                val temp = arr(i)\n\
    \                arr(i) = (arr(i) + 1)\n                arr(i+1) = temp\n    \
    \        }\n        }\n        val n = arr.last\n        arr(0) = arr(len)\n \
    \       arr.dropRight(1)\n        if (arr.last > n) {\n            val p = arr.last\
    \ - 1\n            arr(arr.length-1) = arr(p)\n            arr.last = p\n    \
    \        return moveOneBall(arr)\n        }\n        return false\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp9j_14foa.scala:32:16 ------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m                arr(i) = (arr(i) + \e[31m1\e[0m)\n\e\
    [31m\e[31m   |\e[0m                ^^^\e[0m\n\e[31m   |\e[0m  value update is\
    \ not a member of List[Long] - did you mean arr.updated?\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp9j_14foa.scala:33:16 ------------------------\e[0m\e\
    [0m\n\e[31m33 |\e[0m                arr(i+\e[31m1\e[0m) = temp\n\e[31m\e[31m \
    \  |\e[0m                ^^^\e[0m\n\e[31m   |\e[0m  value update is not a member\
    \ of List[Long] - did you mean arr.updated?\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmp9j_14foa.scala:37:8 -------------------------\e[0m\e[0m\n\e[31m37 |\e\
    [0m        arr(\e[31m0\e[0m) = arr(len)\n\e[31m\e[31m   |\e[0m        ^^^\e[0m\n\
    \e[31m   |\e[0m  value update is not a member of List[Long] - did you mean arr.updated?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp9j_14foa.scala:41:12 ------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m            arr(arr.length-\e[31m1\e[0m) = arr(p)\n\e\
    [31m\e[31m   |\e[0m            ^^^\e[0m\n\e[31m   |\e[0m  value update is not\
    \ a member of List[Long] - did you mean arr.updated?\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmp9j_14foa.scala:41:36 --------------------\e[0m\e[0m\n\
    \e[31m41 |\e[0m            arr(arr.length-\e[31m1\e[0m) = arr(p)\n\e[31m\e[31m\
    \   |\e[0m                                    ^\e[0m\n\e[31m   |\e[0m        \
    \                            Found:    (p : Long)\n\e[31m   |\e[0m           \
    \                         Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E052]\
    \ Type Error: /tmp/tmp9j_14foa.scala:42:21 -----------------------------\e[0m\e\
    [0m\n\e[31m42 |\e[0m            arr.last = p\n\e[31m\e[31m   |\e[0m          \
    \  ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            Reassignment to val last\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n6 errors found\n"
  stdout: ''
  timestamp: 1660009851
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.size\n\
    \        if(n < 2) true\n        else {\n            val sorted = arr.sortBy(_)\n\
    \            val lastElemIndex = n\n            val isSorted = arr.zip(sorted).forall(x\
    \ => x._2 < x._1)\n            if(isSorted) true\n            else\n         \
    \   if(n == 1) true\n            else {\n                val firstElemIndex =\
    \ n-2\n                val isSorted = arr.zip(sorted.reverse).forall(x => x._2\
    \ < x._1)\n                if(isSorted) true\n                else false\n   \
    \         }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpi982gxy4.scala:29:38 -----------------------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m            \e[33mval\e[0m \e[36msorted\e[0m = arr.sortBy(_)\n\
    \e[31m\e[31m   |\e[0m                                      ^\e[0m\n\e[31m   |\e\
    [0mNo implicit Ordering defined for Any..\n\e[31m   |\e[0mI found:\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m    scala.math.Ordering.comparatorToOrdering[\e[35mAny\e[0m](\n\
    \e[31m   |\e[0m      /* missing */summon[java.util.Comparator[Any]]\n\e[31m  \
    \ |\e[0m    )\n\e[31m   |\e[0m\n\e[31m   |\e[0mBut no implicit values were found\
    \ that match type java.util.Comparator[Any].\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmpi982gxy4.scala:31:60 ------------------------\e[0m\e[0m\n\e[31m31\
    \ |\e[0m            \e[33mval\e[0m \e[36misSorted\e[0m = arr.zip(sorted).forall(\e\
    [36mx\e[0m => x._2 < x._1)\n\e[31m\e[31m   |\e[0m                            \
    \                           ^^^^^^\e[0m\n\e[31m   |\e[0mvalue < is not a member\
    \ of Nothing, but could be made available as an extension method.\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mOne of the following imports might fix the problem:\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m  import Byte.byte2double\n\e[31m   |\e[0m  import\
    \ Byte.byte2float\n\e[31m   |\e[0m  import Byte.byte2int\n\e[31m   |\e[0m  import\
    \ Byte.byte2long\n\e[31m   |\e[0m  import Byte.byte2short\n\e[31m   |\e[0m  import\
    \ Char.char2double\n\e[31m   |\e[0m  import Char.char2float\n\e[31m   |\e[0m \
    \ import Char.char2int\n\e[31m   |\e[0m  import Char.char2long\n\e[31m   |\e[0m\
    \  import concurrent.duration.Deadline.DeadlineIsOrdered.mkOrderingOps\n\e[31m\
    \   |\e[0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpi982gxy4.scala:37:72\
    \ ------------------------\e[0m\e[0m\n\e[31m37 |\e[0m                \e[33mval\e\
    [0m \e[36misSorted\e[0m = arr.zip(sorted.reverse).forall(\e[36mx\e[0m => x._2\
    \ < x._1)\n\e[31m\e[31m   |\e[0m                                             \
    \                      ^^^^^^\e[0m\n\e[31m   |\e[0mvalue < is not a member of\
    \ Nothing, but could be made available as an extension method.\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mOne of the following imports might fix the problem:\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m  import Byte.byte2double"
  stdout: ''
  timestamp: 1660009854
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.length\n\
    \        val nums = mutable.Buffer.empty[Long]\n        val index = 0\n      \
    \  val left = n - 1\n        val right = n - 1\n        while (index >= 0 && left\
    \ > 0 || right > 0 && right <= left) {\n            if (left > 0) {\n        \
    \        nums += arr(left-1).toLong\n                left -= 1\n            }\n\
    \            if (right > 0 && right <= left) {\n                nums += arr(right).toLong\n\
    \                right -= 1\n            }\n            if (right <= left) {\n\
    \                left -= 1\n            }\n            if (index >= 0) {\n   \
    \             nums += arr(index).toLong\n                index += 1\n        \
    \    }\n        }\n        val res = nums.toList\n        val newList = res.reverse\n\
    \        if (newList.length > 0 && newList.head == res.head) {\n            return\
    \ true\n        }\n        return false\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp__eoncbx.scala:27:19 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mnums\e[0m = mutable.Buffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m \
    \  |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmp__eoncbx.scala:34:21 ------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m                left -= \e[31m1\e[0m\n\e[31m\e[31m  \
    \ |\e[0m                ^^^^^^^\e[0m\n\e[31m   |\e[0m                value -=\
    \ is not a member of Int - did you mean left.!=?\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmp__eoncbx.scala:38:22 ------------------------\e[0m\e[0m\n\e[31m38\
    \ |\e[0m                right -= \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m         \
    \       ^^^^^^^^\e[0m\n\e[31m   |\e[0m                value -= is not a member\
    \ of Int - did you mean right.!=?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp__eoncbx.scala:41:21\
    \ ------------------------\e[0m\e[0m\n\e[31m41 |\e[0m                left -= \e\
    [31m1\e[0m\n\e[31m\e[31m   |\e[0m                ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                value -= is not a member of Int - did you mean left.!=?\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp__eoncbx.scala:45:22 ------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m                index += \e[31m1\e[0m\n\e[31m\e[31m \
    \  |\e[0m                ^^^^^^^^\e[0m\n\e[31m   |\e[0m                value +=\
    \ is not a member of Int - did you mean index.!=?\n5 errors found\n"
  stdout: ''
  timestamp: 1660009852
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val arr = arr.sortBy(-_)\n\
    \        val sum = 0\n        var index = arr.length-1\n        while (index >=\
    \ 0) {\n            sum += arr(index)\n            if (sum > 0) {\n          \
    \      val temp = arr(index)\n                arr(index) = arr(index+1)\n    \
    \            arr(index+1) = temp\n            }\n            index -= 1\n    \
    \    }\n        sum == arr.sum\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp7mkeud8r.scala:26:18 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(-_)\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmp7mkeud8r.scala:30:16 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m            sum += arr(index)\n\e[31m\e[31m   |\e[0m\
    \            ^^^^^^\e[0m\n\e[31m   |\e[0m            value += is not a member\
    \ of Int - did you mean sum.!=?\n2 errors found\n"
  stdout: ''
  timestamp: 1660009852
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val lastElem = arr.last\n\
    \        if(arr.isEmpty) {\n            return true\n        }\n        val sortedArray\
    \ = arr.sortBy(-_)\n        val lastIndex = sortedArray.lastIndex\n        val\
    \ lastElemIndex = sortedArray(lastElem) - 1\n        val listToShift = ListBuffer.empty[Long]\n\
    \        if(lastElemIndex == -1) {\n            return moveOneBall(listToShift\
    \ +: sortedArray)\n        }\n        listToShift ++= arr(lastElemIndex+1 until\
    \ lastElemIndex+1).map(x => x - 1)\n        moveOneBall(listToShift +: sortedArray)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp9n4ysscv.scala:31:36 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mlastIndex\e[0m = sortedArray.lastIndex\n\
    \e[31m\e[31m   |\e[0m                        ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mvalue lastIndex is not a member of List[Long] - did you mean sortedArray.lastIndexOf?\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp9n4ysscv.scala:32:40 --------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mlastElemIndex\e[0m = sortedArray(lastElem)\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m                                      \
    \  ^^^^^^^^\e[0m\n\e[31m   |\e[0m                                        Found:\
    \    (lastElem : Long)\n\e[31m   |\e[0m                                      \
    \  Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp9n4ysscv.scala:35:31\
    \ --------------------\e[0m\e[0m\n\e[31m35 |\e[0m            \e[33mreturn\e[0m\
    \ moveOneBall(listToShift +: sortedArray)\n\e[31m\e[31m   |\e[0m             \
    \                  ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m     Found:    (listToShift\
    \ : scala.collection.mutable.ListBuffer[Long])\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp9n4ysscv.scala:37:28\
    \ --------------------\e[0m\e[0m\n\e[31m37 |\e[0m        listToShift ++= arr(lastElemIndex+\e\
    [31m1\e[0m until lastElemIndex+\e[31m1\e[0m).map(\e[36mx\e[0m => x - \e[31m1\e\
    [0m)\n\e[31m\e[31m   |\e[0m                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m       Found:    scala.collection.immutable.NumericRange.Exclusive[Long]\n\
    \e[31m   |\e[0m       Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp9n4ysscv.scala:38:20 --------------------\e[0m\e[0m\n\e[31m38\
    \ |\e[0m        moveOneBall(listToShift +: sortedArray)\n\e[31m\e[31m   |\e[0m\
    \                    ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0"
  stdout: ''
  timestamp: 1660009855
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        if (arr.isEmpty)\
    \ true\n        else (\n            // Perform first right shift operation \n\
    \            moveOne(arr) match {\n                case false => (false)\n   \
    \             case true => moveOneBall(arr.tail)\n            }\n        )\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp_8sy88mc.scala:29:12 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m            moveOne(arr) \e[33mmatch\e[0m {\n\e[31m\e\
    [31m   |\e[0m            ^^^^^^^\e[0m\n\e[31m   |\e[0m            Not found: moveOne\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009850
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        if (arr.isEmpty)\
    \ {\n            return true\n        }\n        var temp = 0\n        while (arr.nonEmpty)\
    \ {\n            temp = temp + 1\n            var lastElement = arr.last\n   \
    \         arr.last = (arr.last - temp) >>> 0\n            if (lastElement < arr.last)\
    \ {\n                temp = temp - 1\n                lastElement = arr.last\n\
    \                arr.last = (arr.last - temp) >>> 0\n            }\n        }\n\
    \        return false\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmp1iar7f9j.scala:33:21 -----------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m            arr.last = (arr.last - temp) >>> \e[31m0\e\
    [0m\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m            Reassignment to val last\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E052] Type Error: /tmp/tmp1iar7f9j.scala:37:25 -----------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m                arr.last = (arr.last - temp) >>> \e[31m0\e\
    [0m\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                Reassignment to val last\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660009851
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val start = 0\n\
    \        val end = arr.size - 1\n        var flag = true\n        while (start\
    \ <= end) {\n            var flag = true\n            while (start < end && arr[start]\
    \ <= arr[end]) {\n                start+=1\n                flag = false\n   \
    \         }\n            while (start < end && arr[start] > arr[end]) {\n    \
    \            end-=1\n                flag = false\n            }\n           \
    \ if (flag) {\n                flag = arr.slice(start, end+1).forall(x => x >=\
    \ arr[end]) && arr.slice(start, end+1).forall(x => x <= arr[start])\n        \
    \    }\n            if (!flag) return(true)\n        }\n        return(false)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp9spbjhpz.scala:31:38 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m            \e[33mwhile\e[0m (start < end && arr[\e[35mstart\e\
    [0m] <= arr[\e[35mend\e[0m]) {\n\e[31m\e[31m   |\e[0m                        \
    \              ^^^^^\e[0m\n\e[31m   |\e[0m                                   \
    \   Not found: type start\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmp9spbjhpz.scala:32:21 ------------------------\e[0m\e[0m\n\e[31m32 |\e\
    [0m                start+=\e[31m1\e[0m\n\e[31m\e[31m   |\e[0m                ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                value += is not a member of Int - did you\
    \ mean start.!=?\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp9spbjhpz.scala:35:38\
    \ ------------------------\e[0m\e[0m\n\e[31m35 |\e[0m            \e[33mwhile\e\
    [0m (start < end && arr[\e[35mstart\e[0m] > arr[\e[35mend\e[0m]) {\n\e[31m\e[31m\
    \   |\e[0m                                      ^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                                    Not found: type start\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmp9spbjhpz.scala:36:19 ------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m                end-=\e[31m1\e[0m\n\e[31m\e[31m   |\e\
    [0m                ^^^^^\e[0m\n\e[31m   |\e[0m                value -= is not\
    \ a member of Int - did you mean end.!=?\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp9spbjhpz.scala:40:68 ------------------------\e[0m\e[0m\n\e[31m40 |\e\
    [0m                flag = arr.slice(start, end+\e[31m1\e[0m).forall(\e[36mx\e\
    [0m => x >= arr[\e[35mend\e[0m]) && arr.slice(start, end+\e[31m1\e[0m).forall(\e\
    [36mx\e[0m => x <= arr[\e[35mstart\e[0m])\n\e[31m\e[31m   |\e[0m             \
    \                                                       ^^^\e[0m\n\e[31m   |\e\
    [0m                                                     Not found: type end\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp9spbjhpz.scala:40:122\
    \ ----------------"
  stdout: ''
  timestamp: 1660009856
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        if(arr.isEmpty)\
    \ true else {\n            var res = arr.head\n            for(i <- 1 to arr.length)\
    \ \n                res = res.rightShift((arr.size - i - 1))\n            if(res.compareTo(arr.head)\
    \ == 0) true else false\n        }\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmparw__s3y.scala:29:26 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m                res = res.rightShift((arr.size - i -\
    \ \e[31m1\e[0m))\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                      value rightShift is not a member of\
    \ Long\n1 error found\n"
  stdout: ''
  timestamp: 1660009855
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.size\n\
    \        val newArr = new Array[Long](n + 1)\n        newArr(0) = 0l\n       \
    \ newArr(1) = 1l\n        for (i <- 2 to n) {\n            for (j <- 1 to i) {\n\
    \                if (arr(i) > arr(j)) {\n                    val temp = newArr(i)\n\
    \                    newArr(i) = newArr(j)\n                    newArr(j) = temp\n\
    \                }\n            }\n        }\n        if (newArr(n) == newArr(n-1))\
    \ true\n        else false\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\
    \ == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong, 10l.toLong,\
    \ 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 5\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.moveOneBall$$anonfun$1$$anonfun$1(tmpyvc1__ia.scala:32)\n\tat scala.runtime.java8.JFunction1$mcVI$sp.apply(JFunction1$mcVI$sp.scala:18)\n\
    \tat scala.collection.immutable.Range.foreach(Range.scala:190)\n\tat Problem$.moveOneBall$$anonfun$1(tmpyvc1__ia.scala:37)\n\
    \tat scala.runtime.java8.JFunction1$mcVI$sp.apply(JFunction1$mcVI$sp.scala:18)\n\
    \tat scala.collection.immutable.Range.foreach(Range.scala:190)\n\tat Problem$.moveOneBall(tmpyvc1__ia.scala:38)\n\
    \tat Problem$.main(tmpyvc1__ia.scala:43)\n\tat Problem.main(tmpyvc1__ia.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGen"
  stdout: ''
  timestamp: 1660009858
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        if(arr.isEmpty)\n\
    \            return true\n        if(arr.size != arr.distinct.size)\n        \
    \    return false\n        val list = arr.reverse\n        val num1 = arr.toLong\n\
    \        val num2 = list.last\n        val num3 = list.head\n        val num4\
    \ = list.last\n        val num5 = list.head\n        val num6 = list.last\n  \
    \      val num7 = list.head\n        val num8 = list.last\n        val num9 =\
    \ list.head\n        val num10 = list.last\n        val num11 = list.head\n  \
    \      val num12 = list.last\n        val num13 = list.head\n        val num14\
    \ = list.last\n        val num15 = list.head\n        val num16 = list.last\n\
    \        val num17 = list.head\n        val num18 = list.last\n        val num19\
    \ = list.head\n        val num20 = list.last\n        val num21 = list.head\n\
    \        val num22 = list.last\n        val num23 = list.head\n        val num24\
    \ = list.last\n        val num25 = list.head\n        val num26 = list.last\n\
    \        val num27 = list.head\n        val num28 = list.last\n        val num29\
    \ = list.head\n        val num30 = list.last\n        val num31 = list.head\n\
    \        val num32 = list.last\n        val num33 = list.head\n        val num34\
    \ = list.last\n        val num35 = list.head\n        val num36 = list.last\n\
    \        val num37 = list.head\n        val num38 = list.last\n        val num39\
    \ = list.head\n        val num40 = list.last\n        val num41 = list.head\n\
    \        val num42 = list.last\n        val num43 = list.head\n        val num44\
    \ = list.last\n        val num45 = list.head\n        val num46 = list.last\n\
    \        val num47 = list.head\n        val num48 = list.last\n        val num49\
    \ = list.head\n        val num50 = list.last\n        val num51 = list.head\n\
    \        val num52 = list.last\n        val num53 = list.head\n        val num54\
    \ = list.last\n        val num55 = list.head\n        val num56 = list.last\n\
    \        val num57 = list.head\n        val num58 = list.last\n        val num59\
    \ = list.head\n        val num60 = list.last\n        val num61 = list.head\n\
    \        val num62 = list.last\n        \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmplw691knz.scala:31:23 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mnum1\e[0m = arr.toLong\n\
    \e[31m\e[31m   |\e[0m                   ^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ toLong is not a member of List[Long], but could be made available as an extension\
    \ method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might\
    \ make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e[0m  import\
    \ math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import math.Numeric.Implicits.infixNumericOps\n\
    \e[31m   |\e[0m\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmplw691knz.scala:94:5\
    \ ---------------------\e[0m\e[0m\n\e[31m94 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660009859
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        var flag = true\n\
    \        var count = 0\n        var i = 0\n        for((i <- arr.reverseIterator))\n\
    \        {\n            if(count == 0)\n            {\n                arr(i)\
    \ = 0l\n                count += 1\n            }\n            else\n        \
    \    {\n                if(arr(i) > arr(i-1))\n                {\n           \
    \         arr(i) = 0l\n                    count += 1\n                }\n   \
    \         }\n        }\n        for(i <- arr.reverseIterator)\n        {\n   \
    \         if(arr(i) == 0)\n            {\n                flag = false\n     \
    \           break\n            }\n        }\n        return flag\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmphg3whmxb.scala:29:15 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mfor\e[0m((i <- arr.reverseIterator))\n\e\
    [31m\e[31m   |\e[0m               ^^\e[0m\n\e[31m   |\e[0m               ')' expected,\
    \ but '<-' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmphg3whmxb.scala:30:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        {\n\e[31m\e[31m\
    \   |\e[0m^\e[0m\n\e[31m   |\e[0m'<-' expected, but 'end of statement' found\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660009851
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        if(arr.isEmpty)\
    \ true\n        else if(arr.length == 1) true\n        else if(arr.head == arr.last)\
    \ true\n        else if(!arr.take(arr.length - 1).forall(arr.head > _)) false\n\
    \        else {\n            val temp = arr.take(arr.length - 1)\n           \
    \ arr.take(arr.length - 1) = arr.head\n            arr.head = temp\n         \
    \   moveOneBall(arr)\n        }\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpb7htoidv.scala:32:12 ------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m            arr.take(arr.length - \e[31m1\e[0m) = arr.head\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^\e[0m\n\e[31m   |\e[0m            value\
    \ update is not a member of Int => List[Long]\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpb7htoidv.scala:33:23 --------------------\e[0m\e[0m\n\e[31m33\
    \ |\e[0m            arr.head = temp\n\e[31m\e[31m   |\e[0m                   \
    \    ^^^^\e[0m\n\e[31m   |\e[0m                       Found:    (temp : List[Long])\n\
    \e[31m   |\e[0m                       Required: Long\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660009858
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        require(arr.size\
    \ != 0)\n        // Create a counter which will be used to store number of right\
    \ shifts.\n        var counter = -1\n        // Loop through the array.\n    \
    \    arr.foreach(x => {\n            // Perform right shift operation on the elements\
    \ of the list.\n            if(counter > 0){\n                val temp = arr.tail\n\
    \                arr.tail = arr.init\n                arr.init = temp\n      \
    \          counter--\n            }else{\n                arr.init = x\n     \
    \       }\n        })\n        // Check if the list is non-decreasing after right\
    \ shift operations.\n        if(arr.isEmpty || arr.init.toLong < arr.last.toLong){\n\
    \            return true\n        }else{\n            return false\n        }\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp7b2lms0g.scala:36:25 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m                counter--\n\e[31m\e[31m   |\e[0m    \
    \                     ^\e[0m\n\e[31m   |\e[0m                         expression\
    \ expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E052] Type Error:\
    \ /tmp/tmp7b2lms0g.scala:34:25 -----------------------------\e[0m\e[0m\n\e[31m34\
    \ |\e[0m                arr.tail = arr.init\n\e[31m\e[31m   |\e[0m           \
    \     ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                Reassignment to\
    \ val tail\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmp7b2lms0g.scala:35:25\
    \ -----------------------------\e[0m\e[0m\n\e[31m35 |\e[0m                arr.init\
    \ = temp\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                Reassignment to val init\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmp7b2lms0g.scala:38:27 --------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m                arr.init = x\n\e[31m\e[31m   |\e[0m \
    \                          ^\e[0m\n\e[31m   |\e[0m                           Found:\
    \    (x : Long)\n\e[31m   |\e[0m                           Required: List[Long\
    \ @uncheckedVariance]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp7b2lms0g.scala:42:35\
    \ ------------------------\e[0m\e[0m\n\e[31m42 |\e[0m        \e[33mif\e[0m(arr.isEmpty\
    \ || arr.init.toLong < arr.last.toLong){\n\e[31m\e[31m   |\e[0m              \
    \            ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue toLong is not a member\
    \ of List[Long @uncheckedVariance], but could be made available as an extension\
    \ method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might\
    \ make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e[0m  import\
    \ m"
  stdout: ''
  timestamp: 1660009860
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        if(arr.length ==\
    \ 0) return true\n        if(arr.length ==1) return false\n        if(arr.length\
    \ == 2){\n            val a = arr.head //arr(0)\n            val b = arr.tail.head\
    \ //arr(1)\n            if(a>b) return false\n            return true\n      \
    \  }\n        val l = arr.head //arr(0)\n        val r = arr.tail.head //arr(1)\n\
    \        val temp = l\n        for(i <- 0 until arr.length){\n            val\
    \ x = arr.take(i)\n            val y = arr.drop(i)\n            if(l > r){\n \
    \               val temp1 = y\n                val temp2 = x\n               \
    \ if(x == temp)\n                    y = temp1\n                else if(y == temp)\n\
    \                    x = temp2\n                else\n                    x =\
    \ temp\n            }\n            temp=x\n            l=y\n            if(x==r)\n\
    \                r=y\n        }\n        if(temp==r) true\n        else false\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpkw4z8019.scala:43:19 -----------------------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m                \e[33mif\e[0m(x == temp)\n\e[31m\e[31m\
    \   |\e[0m                   ^^^^^^^^^\e[0m\n\e[31m   |\e[0m    Values of types\
    \ List[Long] and Long cannot be compared with == or !=\n\e[31m\e[31m-- [E052]\
    \ Type Error: /tmp/tmpkw4z8019.scala:44:22 -----------------------------\e[0m\e\
    [0m\n\e[31m44 |\e[0m                    y = temp1\n\e[31m\e[31m   |\e[0m     \
    \               ^^^^^^^^^\e[0m\n\e[31m   |\e[0m                    Reassignment\
    \ to val y\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- Error: /tmp/tmpkw4z8019.scala:45:24\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m45 |\e[0m       \
    \         \e[33melse\e[0m \e[33mif\e[0m(y == temp)\n\e[31m\e[31m   |\e[0m    \
    \                    ^^^^^^^^^\e[0m\n\e[31m   |\e[0m    Values of types List[Long]\
    \ and Long cannot be compared with == or !=\n\e[31m\e[31m-- [E052] Type Error:\
    \ /tmp/tmpkw4z8019.scala:46:22 -----------------------------\e[0m\e[0m\n\e[31m46\
    \ |\e[0m                    x = temp2\n\e[31m\e[31m   |\e[0m                 \
    \   ^^^^^^^^^\e[0m\n\e[31m   |\e[0m                    Reassignment to val x\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpkw4z8019.scala:48:24\
    \ --------------------\e[0m\e[0m\n\e[31m48 |\e[0m                    x = temp\n\
    \e[31m\e[31m   |\e[0m                        ^^^^\e[0m\n\e[31m   |\e[0m      \
    \                  Found:    (temp : Long)\n\e[31m   |\e[0m                  \
    \      Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpkw4z8019.scala:50:17 --------------------\e[0m\e[0m\n\e[31m50\
    \ |\e[0m            temp=x\n\e[31m\e[31m   |\e[0m                 ^\e[0m\n\e[31m\
    \   |\e[0m                 Found:    (x : List[Long])\n\e[31m   |\e[0m       \
    \          Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007"
  stdout: ''
  timestamp: 1660009861
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        var counter = 0\n\
    \        var newArr = arr.toList\n        newArr.foreach { \n            case\
    \ x: Long =>\n                counter += 1\n                if(counter % 2 ==\
    \ 0) newArr.last <- x\n        }\n        if(newArr.last > 0) newArr else false\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpblmjfmr4.scala:31:49 -----------------------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m                \e[33mif\e[0m(counter % \e[31m2\e[0m\
    \ == \e[31m0\e[0m) newArr.last <- x\n\e[31m\e[31m   |\e[0m                   \
    \                              ^^\e[0m\n\e[31m   |\e[0m                      \
    \          end of statement expected but '<-' found\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmpblmjfmr4.scala:33:28 --------------------\e[0m\e[0m\n\
    \e[31m33 |\e[0m        \e[33mif\e[0m(newArr.last > \e[31m0\e[0m) newArr \e[33melse\e\
    [0m \e[31mfalse\e[0m\n\e[31m\e[31m   |\e[0m                            ^^^^^^\e\
    [0m\n\e[31m   |\e[0m                            Found:    (newArr : List[Long])\n\
    \e[31m   |\e[0m                            Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660009858
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val list = arr.toList\n\
    \        var flag = true\n        if(list.isEmpty) {\n            return true\n\
    \        } else {\n            val temp = list.last\n            list.last = 0\n\
    \            list.dropRight(1)\n            list.last += 1\n            list.foreach((x:\
    \ Long) => {\n                if(temp > x) {\n                    flag = false\n\
    \                }\n            })\n        }\n        return flag\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmp987kf1sg.scala:32:22 -----------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m            list.last = \e[31m0\e[0m\n\e[31m\e[31m  \
    \ |\e[0m            ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            Reassignment\
    \ to val last\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp987kf1sg.scala:34:22\
    \ ------------------------\e[0m\e[0m\n\e[31m34 |\e[0m            list.last +=\
    \ \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m            value += is not a member of Long - did you mean Long.!=?\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660009858
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        if (arr.isEmpty)\
    \ true\n        else {\n            var count = 0\n            val m = arr.head\n\
    \            var i = 0\n            while (i < arr.length)\n            {\n  \
    \              if (arr(i) > m) count++\n                i++\n            }\n \
    \           if (count % 2 == 0) arr swap (0, arr.length)\n            else arr\
    \ swap (arr.length - 1, 0)\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpkd5lzgk1.scala:34:19 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m                i++\n\e[31m\e[31m   |\e[0m          \
    \         ^\e[0m\n\e[31m   |\e[0m                   expression expected but \e\
    [31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpkd5lzgk1.scala:33:37\
    \ ------------------------\e[0m\e[0m\n\e[31m33 |\e[0m                \e[33mif\e\
    [0m (arr(i) > m) count++\n\e[31m\e[31m   |\e[0m                              \
    \  ^^^^^^^\e[0m\n\e[31m   |\e[0m                                value ++ is not\
    \ a member of Int\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpkd5lzgk1.scala:36:36\
    \ ------------------------\e[0m\e[0m\n\e[31m36 |\e[0m            \e[33mif\e[0m\
    \ (count % \e[31m2\e[0m == \e[31m0\e[0m) arr swap (\e[31m0\e[0m, arr.length)\n\
    \e[31m\e[31m   |\e[0m                                ^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m        value swap is not a member of List[Long] - did you mean arr.map?\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpkd5lzgk1.scala:37:21 ------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m            \e[33melse\e[0m arr swap (arr.length - \e\
    [31m1\e[0m, \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m                 ^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m        value swap is not a member of List[Long] - did you mean\
    \ arr.map?\n4 errors found\n"
  stdout: ''
  timestamp: 1660009862
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val size = arr.size\n\
    \        val leftBit = arr.last % 2\n        val rightBit = arr.last / 2\n   \
    \     val startIndex = size - 1\n        val endIndex = startIndex - 1\n     \
    \   val temp = mutable.ListBuffer[Long]()\n        // Check if there is only one\
    \ element in list\n        if (size <= 1) true\n        // Check if first element\
    \ is in the left position\n        else if (leftBit == 0) if (arr[startIndex]\
    \ > arr[startIndex + 1]) moveOneBall(arr.tail) else if (arr[startIndex] < arr[startIndex\
    \ + 1]) moveOneBall(arr.tail.reverse) else false\n        // Check if first element\
    \ is in the right position\n        else if (rightBit == 0) if (arr[startIndex]\
    \ > arr[startIndex + 1]) moveOneBall(arr.tail) else if (arr[startIndex] < arr[startIndex\
    \ + 1]) moveOneBall(arr.tail.reverse) else false\n        // Check if last element\
    \ is in the left position\n        else if (leftBit == 1) if (arr[endIndex] >\
    \ arr[endIndex + 1]) moveOneBall(arr.tail) else if (arr[endIndex] < arr[endIndex\
    \ + 1]) moveOneBall(arr.tail.reverse) else false\n        // Check if last element\
    \ is in the right position\n        else if (rightBit == 1) if (arr[endIndex]\
    \ > arr[endIndex + 1]) moveOneBall(arr.tail) else if (arr[endIndex] < arr[endIndex\
    \ + 1]) moveOneBall(arr.tail.reverse) else false\n        else moveOneBall(arr.tail)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpy4vaww_a.scala:31:19 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mtemp\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpy4vaww_a.scala:35:39 ------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (leftBit == \e\
    [31m0\e[0m) \e[33mif\e[0m (arr[startIndex] > arr[startIndex + \e[31m1\e[0m]) moveOneBall(arr.tail)\
    \ \e[33melse\e[0m \e[33mif\e[0m (arr[startIndex] < arr[startIndex + \e[31m1\e\
    [0m]) moveOneBall(arr.tail.reverse) \e[33melse\e[0m \e[31mfalse\e[0m\n\e[31m\e\
    [31m   |\e[0m                                       ^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                                       Not found: type startIndex\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpy4vaww_a.scala:35:109\
    \ -----------------------\e[0m\e[0m\n\e[31m35 |\e[0m        \e[33melse\e[0m \e\
    [33mif\e[0m (leftBit == \e[31m0\e[0m) \e[33mif\e[0m (arr[startIndex] > arr[startIndex\
    \ + \e[31m1\e[0m]) moveOneBall(arr.tail) \e[33melse\e[0m \e[33mif\e[0m (arr[startIndex]\
    \ < arr[startIndex + \e[31m1\e[0m]) moveOneBall(arr.tail.reverse) \e[33melse\e\
    [0m \e[31mfalse\e[0m\n\e[31m\e[31m   |\e[0m                                  \
    \                                                                           ^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                              Not found: type\
    \ startIndex\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpy4vaww_a.scala:37:40\
    \ ------------------------\e[0m\e[0m\n\e[31m37 |\e[0m        \e[33melse\e[0m \e\
    [33mif\e[0m (rightBit == \e[31m0\e[0m) \e[33mif\e[0m (arr[startIndex] > arr[startIndex\
    \ + \e[31m1\e[0m]) moveOneBall(arr.tail) \e[33melse\e[0m \e[33mif\e[0m (arr[startIndex]\
    \ < arr[startIndex + \e[31m1\e[0m]) moveOneBall(arr.t"
  stdout: ''
  timestamp: 1660009858
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val l = new mutable.ListBuffer[Long]()\n\
    \        var n = 0\n        val n = arr.length\n        var count = 0\n      \
    \  var rightShift = false\n        for(i <- 1 until n) {\n            val x =\
    \ arr(i)\n            count += x\n            if(!rightShift) {\n            \
    \    l.append(x)\n            }\n            else {\n                count +=\
    \ l(0)\n                val temp = l\n                l.clear()\n            \
    \    l.append(temp)\n            }\n            rightShift = !rightShift\n   \
    \         count /= 2\n        }\n        if(l.isEmpty) {\n            return true\n\
    \        }\n        else{\n            return false\n        }\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpwquklxrn.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = arr.length\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mn is already\
    \ defined as \e[33mvariable\e[0m \e[35mn\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpwquklxrn.scala:26:20 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36ml\e[0m = \e[33mnew\e[0m\
    \ mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m               \
    \     ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found: mutable\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpwquklxrn.scala:33:18\
    \ ------------------------\e[0m\e[0m\n\e[31m33 |\e[0m            count += x\n\e\
    [31m\e[31m   |\e[0m            ^^^^^^^^\e[0m\n\e[31m   |\e[0m            value\
    \ += is not a member of Int - did you mean Int.!=?\n3 errors found\n"
  stdout: ''
  timestamp: 1660009861
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        if (arr.isEmpty)\
    \ true else {\n            val n = arr.size\n            val r = scala.util.Random\n\
    \            var i = 0\n            var j = n - 1\n            while (i < n &&\
    \ j < n) {\n                if (arr(i) <= arr(j)) {\n                    i +=\
    \ 1\n                }\n                else {\n                    j -= 1\n \
    \               }\n            }\n            val retVal = i != j\n          \
    \  if (retVal) {\n                val l = arr.take(i)\n                val r =\
    \ arr.drop(i + 1)\n                arr :+= r.take(l-1)\n                arr :+=\
    \ r.drop(l+1)\n            }\n            else retVal\n        }\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp3issl1w4.scala:43:20 ------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m                arr :+= r.take(l-\e[31m1\e[0m)\n\e[31m\e\
    [31m   |\e[0m                ^^^^^^^\e[0m\n\e[31m   |\e[0m          value :+=\
    \ is not a member of List[Long] - did you mean arr.:+?\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp3issl1w4.scala:43:32 ------------------------\e[0m\e\
    [0m\n\e[31m43 |\e[0m                arr :+= r.take(l-\e[31m1\e[0m)\n\e[31m\e[31m\
    \   |\e[0m                               ^^\e[0m\n\e[31m   |\e[0mvalue - is not\
    \ a member of List[Long], but could be made available as an extension method.\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might make progress\
    \ towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp3issl1w4.scala:44:20 ------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m                arr :+= r.drop(l+\e[31m1\e[0m)\n\e[31m\e\
    [31m   |\e[0m                ^^^^^^^\e[0m\n\e[31m   |\e[0m          value :+=\
    \ is not a member of List[Long] - did you mean arr.:+?\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp3issl1w4.scala:44:32 ------------------------\e[0m\e\
    [0m\n\e[31m44 |\e[0m                arr :+= r.drop(l+\e[31m1\e[0m)\n\e[31m\e[31m\
    \   |\e[0m                               ^^\e[0m\n\e[31m   |\e[0mvalue + is not\
    \ a member of List[Long], but could be made available as an extension method.\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might make progress\
    \ towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n4 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660009863
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        var left = 0\n \
    \       var right = 0\n        var result = true\n        var maxRight = arr.last\n\
    \        var maxLeft = 0\n        var maxCount = 0\n        for (a <- arr) {\n\
    \            if (maxRight - a > maxCount) {\n                maxLeft = left\n\
    \                maxRight = a\n                maxCount = maxRight - a\n     \
    \       }\n            if (a < maxLeft) {\n                left += 1\n       \
    \     } else {\n                if (a < maxRight) {\n                    right\
    \ += 1\n                }\n            }\n        }\n        var index = left\
    \ + 1\n        var lastIndex = arr.length - 1\n        var count = 0\n       \
    \ var maxCount = 0\n        for (a <- arr) {\n            if (a < maxLeft) {\n\
    \                count += arr.length - index\n            } else {\n         \
    \       if (a < maxRight) {\n                    if (count < maxCount) {\n   \
    \                     count += 1\n                        arr(index) = a\n   \
    \                     index -= 1\n                    } else {\n             \
    \           count += arr.length - index\n                        if (count > maxCount)\
    \ {\n                            maxCount = count\n                          \
    \  arr(lastIndex) = a\n                            lastIndex -= 1\n          \
    \              }\n                    }\n                }\n            }\n  \
    \      }\n        result = count == arr.length\n        return result\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpvdua23tv.scala:49:12 ---------------------------\e\
    [0m\e[0m\n\e[31m49 |\e[0m        \e[33mvar\e[0m \e[36mmaxCount\e[0m = \e[31m0\e\
    [0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmaxCount\
    \ is already defined as \e[33mvariable\e[0m \e[35mmaxCount\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpvdua23tv.scala:36:27\
    \ --------------------\e[0m\e[0m\n\e[31m36 |\e[0m                maxCount = maxRight\
    \ - a\n\e[31m\e[31m   |\e[0m                           ^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                           Found:    Long\n\e[31m   |\e[0m         \
    \                  Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpvdua23tv.scala:57:24 ------------------------\e[0m\e[0m\n\e[31m57 |\e\
    [0m                        arr(index) = a\n\e[31m\e[31m   |\e[0m             \
    \           ^^^\e[0m\n\e[31m   |\e[0m  value update is not a member of List[Long]\
    \ - did you mean arr.updated?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpvdua23tv.scala:63:28\
    \ ------------------------\e[0m\e[0m\n\e[31m63 |\e[0m                        \
    \    arr(lastIndex) = a\n\e[31m\e[31m   |\e[0m                            ^^^\e\
    [0m\n\e[31m   |\e[0m  value update is not a member of List[Long] - did you mean\
    \ arr.updated?\n4 errors found\n"
  stdout: ''
  timestamp: 1660009864
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        def isSorted(arr\
    \ : List[Long]) = {\n            val length = arr.length\n            for(_ <-\
    \ 1 until length) {\n                if(arr(_) < arr(length - _))\n          \
    \          return false\n            }\n            true\n        }\n        \n\
    \        if(arr.isEmpty)\n            true\n        else if(isSorted(arr))\n \
    \           true\n        else {\n            val list = new mutable.ListBuffer[Long]()\n\
    \            val rightShift = arr.lastOption match{\n                case Some(last)\
    \ =>\n                    list.add(last)\n                    arr.lastOption foreach\
    \ (x => list.prepend(x))\n                    arr.lastOption foreach (x => list.prepend(x))\n\
    \                case None => return true\n            }\n            if(rightShift){\n\
    \                val newArray = arr.dropRight(1)\n                newArray foreach(x\
    \ => list.prepend(x))\n                moveOneBall(newArray)\n            } else\
    \ {\n                moveOneBall(list)\n            }\n        }\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E081] Type Error: /tmp/tmpfnxzws1q.scala:29:23 -----------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m                \e[33mif\e[0m(arr(_) < arr(length - _))\n\
    \e[31m\e[31m   |\e[0m                       ^\e[0m\n\e[31m   |\e[0m   Missing\
    \ parameter type\n\e[31m   |\e[0m\n\e[31m   |\e[0m   I could not infer the type\
    \ of the parameter _$1 of expanded function:\n\e[31m   |\e[0m   _$1 => arr(_$1)\
    \ < arr(_$2 => length - _$2).\n\e[31m\e[31m-- [E081] Type Error: /tmp/tmpfnxzws1q.scala:29:41\
    \ -----------------------------\e[0m\e[0m\n\e[31m29 |\e[0m                \e[33mif\e\
    [0m(arr(_) < arr(length - _))\n\e[31m\e[31m   |\e[0m                         \
    \                ^\e[0m\n\e[31m   |\e[0m   Missing parameter type\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m   I could not infer the type of the parameter _$2 of expanded\
    \ function:\n\e[31m   |\e[0m   _$2 => length - _$2.\n\e[31m\e[31m-- [E089] Syntax\
    \ Error: /tmp/tmpfnxzws1q.scala:30:20 ---------------------------\e[0m\e[0m\n\e\
    [31m30 |\e[0m                    \e[33mreturn\e[0m \e[31mfalse\e[0m\n\e[31m\e\
    [31m   |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m          \e\
    [33mmethod\e[0m \e[35misSorted\e[0m has a return statement; it needs a result\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpfnxzws1q.scala:40:27\
    \ ------------------------\e[0m\e[0m\n\e[31m40 |\e[0m            \e[33mval\e[0m\
    \ \e[36mlist\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e\
    [31m   |\e[0m                           ^^^^^^^\e[0m\n\e[31m   |\e[0m        \
    \                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpfnxzws1q.scala:48:15 --------------------\e[0m\e\
    [0m\n\e[31m48 |\e[0m            \e[33mif\e[0m(rightShift){\n\e[31m\e[31m   |\e\
    [0m               ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m               Found:    (rightShift\
    \ : Unit)\n\e[31m   |\e[0m               Required: Boolean\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n5 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660009863
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        require(arr.size\
    \ != 0)\n        if(arr.size == 1) return true\n        val left = arr.last\n\
    \        val right = arr.first\n        var i = 0\n        var j = arr.size -1\n\
    \        val list = new mutable.ArrayBuffer[Long]()\n        while(i <= j) {\n\
    \            while(arr(i) > right) {\n                i += 1\n            }\n\
    \            while(arr(j) < left) {\n                j -= 1\n            }\n \
    \           if(i <= j) {\n                list.add(arr(i))\n                i\
    \ += 1\n                j -= 1\n            }\n        }\n        if(i > 0) {\n\
    \            list.add(arr(i))\n        }\n        if(j < arr.size-1) {\n     \
    \       list.add(arr(j))\n        }\n        while(list.nonEmpty) {\n        \
    \    if(list.last > right) {\n                list.pop()\n            } else {\n\
    \                list.pop(0)\n            }\n        }\n        if(list.nonEmpty)\
    \ {\n            list.remove(0)\n        }\n        list.nonEmpty\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp6szoi186.scala:29:24 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mright\e[0m = arr.first\n\
    \e[31m\e[31m   |\e[0m                    ^^^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \ value first is not a member of List[Long] - did you mean arr.find?\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp6szoi186.scala:32:23 ------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mlist\e[0m = \e[33mnew\e\
    [0m mutable.ArrayBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m            \
    \           ^^^^^^^\e[0m\n\e[31m   |\e[0m                       Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660009863
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n      if (arr.isEmpty) true\n\
    \      else {\n        val a = arr.tail\n        val b = a.head\n        val c\
    \ = arr.head - b.toLong\n        val d = b - c\n        val e = arr.tail.tail\n\
    \        val f = e.head\n        val g = e.tail.head\n        val h = e.tail.tail\n\
    \        val i = f.toLong\n        val j = g.toLong\n        val k = h.toLong\n\
    \        val l = i.toLong\n        val m = j.toLong\n        val n = k.toLong\n\
    \        val o = 1l - d\n        val p = d\n        val q = l\n        val r =\
    \ m\n        val s = n\n        val t = o\n        val u = arr.tail.tail.head.toLong\n\
    \        val v = arr.head - d\n        val w = arr.tail.head - d\n        val\
    \ x = arr.tail.tail.tail.head.toLong\n        val y = arr.head - d\n        val\
    \ z = arr.tail.head - d\n        val w = arr.tail.head - d\n        val x = arr.head\
    \ - d\n        val y = arr.tail.tail.tail.head.toLong\n        val z = arr.tail.tail.head\
    \ - d\n        val w = arr.tail.tail.head - d\n        val x = arr.tail.tail.tail.head\
    \ - d\n        val y = arr.tail.tail.tail.tail.head.toLong\n        val z = arr.tail.tail.tail.tail.head\
    \ - d\n        val w = arr.tail.tail.tail.tail.head - d\n        val x = arr.tail.tail.tail.tail.tail.head.toLong\n\
    \        val y = arr.tail.tail.tail.tail.tail.head - d\n        val z = arr.tail.tail.tail.tail.tail.head\
    \ - d\n        val w = arr.tail.tail.tail.tail.tail.head - d\n        val x =\
    \ arr.tail.tail.tail.tail.tail.tail.head.toLong\n        val y = arr.tail.tail.tail.tail.tail.tail.head\
    \ - d\n        val z = arr.tail.tail.tail.tail.tail.tail.head - d\n        val\
    \ w = arr.tail.tail.tail.tail.tail.tail.head - d\n        val x = arr.tail.tail.tail.tail.tail.tail.tail.head.toLong\n\
    \        val y = arr.tail.tail.tail.tail.tail.tail\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpz1btlab1.scala:83:0 ----------------------------\e\
    [0m\e[0m\n\e[31m83 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpz1btlab1.scala:54:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m54 |\e[0m        \e[33mval\e[0m\
    \ \e[36mw\e[0m = arr.tail.head - d\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mw is already defined as \e[33mvalue\e[0m \e[35mw\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpz1btlab1.scala:55:12 ---------------------------\e[0m\e[0m\n\e[31m55\
    \ |\e[0m        \e[33mval\e[0m \e[36mx\e[0m = arr.head - d\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mx is already defined as \e\
    [33mvalue\e[0m \e[35mx\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpz1btlab1.scala:56:12 ---------------------------\e\
    [0m\e[0m\n\e[31m56 |\e[0m        \e[33mval\e[0m \e[36my\e[0m = arr.tail.tail.tail.head.toLong\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0my is already defined as \e[33mvalue\e[0m \e[35my\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpz1btlab1.scala:57:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m57 |\e[0m        \e[33mval\e[0m\
    \ \e[36mz\e[0m = arr.tail.tail.head - d\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mz is already defined as \e[33mvalue\e[0m \e[35mz\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpz1btlab1.scala:58:12 ---------------------------\e[0m\e[0m\n\e[31m58\
    \ |\e[0m        \e[33mval\e[0m \e[36mw\e[0m = arr.tail.tail.head - d\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e"
  stdout: ''
  timestamp: 1660009866
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        var sorted = 0\n\
    \        if(arr.isEmpty || arr.length == 1){\n            true\n        } else\
    \ {\n            sorted = arr.last\n            for(i <- arr.indices) {\n    \
    \            val temp = arr(i)\n                arr(i) = arr(i+1)\n          \
    \      arr(i+1) = temp\n            }\n            if(arr(0) >= sorted) moveOneBall(arr.tail)\n\
    \            else false\n        }\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5k3195n_.scala:30:25\
    \ --------------------\e[0m\e[0m\n\e[31m30 |\e[0m            sorted = arr.last\n\
    \e[31m\e[31m   |\e[0m                     ^^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                Found:    Long\n\e[31m   |\e[0m                     Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp5k3195n_.scala:33:16\
    \ ------------------------\e[0m\e[0m\n\e[31m33 |\e[0m                arr(i) =\
    \ arr(i+\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m                ^^^\e[0m\n\e[31m \
    \  |\e[0m  value update is not a member of List[Long] - did you mean arr.updated?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp5k3195n_.scala:34:16 ------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m                arr(i+\e[31m1\e[0m) = temp\n\e[31m\e\
    [31m   |\e[0m                ^^^\e[0m\n\e[31m   |\e[0m  value update is not a\
    \ member of List[Long] - did you mean arr.updated?\n3 errors found\n"
  stdout: ''
  timestamp: 1660009865
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        if(arr.isEmpty)\
    \ true\n        else {\n            val l = arr.head\n            var r = arr.last\n\
    \            val m = arr.tail\n            var a = arr.take(l.toInt)\n       \
    \     val b = arr.drop(l.toInt)\n            val ans = false\n            for(\
    \ i <- 1 to arr.length ) {\n                val newA = a.map{x => x + 1}\n   \
    \             val newB = b.map{x => x + 1}\n                if(newA < newB) {\n\
    \                    a = newA\n                    b = newB\n                }\
    \ else {\n                    a = newB\n                    b = newA\n       \
    \         }\n            }\n            val c = b.head\n            val d = b.tail\n\
    \            val n = l\n            val o = arr.take(n)\n            val p = arr.drop(n)\n\
    \            val q = a.map{x => x + 1}\n            val r = arr.map{x => x + 1}\n\
    \            val s = r.head\n            val t = r.tail\n            if(q.head\
    \ < q.tail) {\n                ans = true\n                ans |= moveOneBall(q)\n\
    \            } else {\n                ans |= moveOneBall(p)\n            }\n\
    \            ans |= moveOneBall(q)\n            ans |= moveOneBall(s)\n      \
    \      ans |= moveOneBall(t)\n            ans\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp1xu0xg98.scala:51:16 ---------------------------\e\
    [0m\e[0m\n\e[31m51 |\e[0m            \e[33mval\e[0m \e[36mr\e[0m = arr.map{\e\
    [36mx\e[0m => x + \e[31m1\e[0m}\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mr is already defined as \e[33mvariable\e[0m \e[35mr\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmp1xu0xg98.scala:37:24 ------------------------\e[0m\e[0m\n\e[31m37 |\e\
    [0m                \e[33mif\e[0m(newA < newB) {\n\e[31m\e[31m   |\e[0m       \
    \            ^^^^^^\e[0m\n\e[31m   |\e[0mvalue < is not a member of List[Long],\
    \ but could be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mOne of the following imports might make progress towards fixing the\
    \ problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Ordered.orderingToOrdered\n\
    \e[31m   |\e[0m  import math.Ordering.Implicits.infixOrderingOps\n\e[31m   |\e\
    [0m\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmp1xu0xg98.scala:39:22 -----------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m                    b = newB\n\e[31m\e[31m   |\e[0m \
    \                   ^^^^^^^^\e[0m\n\e[31m   |\e[0m                    Reassignment\
    \ to val b\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmp1xu0xg98.scala:42:22\
    \ -----------------------------\e[0m\e[0m\n\e[31m42 |\e[0m                   \
    \ b = newA\n\e[31m\e[31m   |\e[0m                    ^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                    Reassignment to val b\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmp1xu0xg98.scala:48:29 --------------------\e\
    [0m\e[0m\n\e[31m48 |\e[0m            \e[33mval\e[0m \e[36mo\e[0m = arr.take(n)\n\
    \e[31m\e[31m   |\e[0m                             ^\e[0m\n\e[31m   |\e[0m    \
    \                         Found:    (n : Long)\n\e[31m   |\e[0m              \
    \               Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ availabl"
  stdout: ''
  timestamp: 1660009866
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        // Your code here\n\
    \        var n = arr.size\n        var temp = arr(n)\n        for(i <- 0 to n-1){\n\
    \            while(temp < arr(i)){\n                temp = temp + arr(i)\n   \
    \         }\n            while(temp > arr(i)){\n                temp = temp -\
    \ arr(i)\n            }\n            if(temp < arr(i)){\n                return\
    \ true\n            }\n        }\n        return false\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 5\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.moveOneBall(tmpubcwsh0b.scala:28)\n\tat Problem$.main(tmpubcwsh0b.scala:43)\n\
    \tat Problem.main(tmpubcwsh0b.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009866
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val arr = mutable.ListBuffer.empty[Long]\n\
    \        val visited  = mutable.Set[Long]()\n        arr ++= arr\n        arr\
    \ foreach { x => visited += x}\n        visited.size == arr.size || arr.size <\
    \ 1\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpusorjuxd.scala:26:18 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = mutable.ListBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                  ^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                  Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpusorjuxd.scala:27:23 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mvisited\e[0m  = mutable.Set[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                       ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                       Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660009861
- exit_code: -1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        // First check empty\
    \ list.\n        if (arr.isEmpty) \n            true\n        else {\n       \
    \     // Check if arr[0] is greater than all elements of the list.\n         \
    \   if (arr(0).toLong > arr.map(_.toLong).reduce((x, y) => x + y))\n         \
    \       return false\n            \n            // Perform right shift operations.\n\
    \            val leftArr = arr.slice(1, arr.length)\n            val rightArr\
    \ = arr.slice(0, 1)\n            val temp = leftArr.reverse\n            val newArr\
    \ = rightArr.concat(temp)\n            if (newArr == arr.map(_.toLong).sortBy(_.toLong))\n\
    \                true\n            else\n                moveOneBall(newArr)\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1660009871
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        // Use mutable variable\
    \ instead of returning an immutable list\n        val result = mutable.ListBuffer[Long]()\n\
    \        for ( i <- arr.indices.reverse.drop(1) ) {\n            // Move all elements\
    \ of arr to right by 1\n            arr match {\n                case x :: xs\
    \ if x >= xs => result ++= xs :: arr.drop(i)\n                case x :: xs =>\
    \ result ++= xs :: arr.drop(i)\n                case Nil => return true\n    \
    \        }\n        }\n        // Return result if there is at least one element\n\
    \        !result.isEmpty\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp03dynqmb.scala:27:21 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E134] Type Error: /tmp/tmp03dynqmb.scala:31:34 -----------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m                \e[33mcase\e[0m x :: xs \e[33mif\e[0m\
    \ x >= xs => result ++= xs :: arr.drop(i)\n\e[31m\e[31m   |\e[0m             \
    \                   ^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives\
    \ of \e[33mmethod\e[0m \e[35m>=\e[0m in \e[33mclass\e[0m \e[35mLong\e[0m with\
    \ types\n\e[31m   |\e[0m (x: Double): Boolean\n\e[31m   |\e[0m (x: Float): Boolean\n\
    \e[31m   |\e[0m (x: Long): Boolean\n\e[31m   |\e[0m (x: Int): Boolean\n\e[31m\
    \   |\e[0m (x: Char): Boolean\n\e[31m   |\e[0m (x: Short): Boolean\n\e[31m   |\e\
    [0m (x: Byte): Boolean\n\e[31m   |\e[0mmatch arguments ((xs : List[Long]))\n2\
    \ errors found\n"
  stdout: ''
  timestamp: 1660009864
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        // Your code here\n\
    \        val arr0 = arr.toArray\n        val arr1 = arr0.clone\n        val arr2\
    \ = arr0.clone\n        arr2(0) = 0\n        val l = arr.length\n        val l1\
    \ = arr1.length\n        val l2 = arr2.length\n        var i = 0\n        var\
    \ j = 0\n        var k = 0\n        var l = 0\n        while(i <= l-1) {\n   \
    \         while(j <= l-1) {\n                while(k <= l-1) {\n             \
    \       if(arr(k) < arr(l)) {\n                        arr2(k+2) = arr2(k+1) +\
    \ 1\n                        arr1(k+2) = arr1(k+1) + 1\n                    }\
    \ else if(arr(k) >= arr(l)) {\n                        arr2(k+2) = arr2(k+1) +\
    \ 1\n                        arr1(k+2) = arr1(k+1) + 1\n                    }\n\
    \                    k = k+1\n                }\n                k = k+1\n   \
    \             k = k+1\n                k = k+1\n                l = l-1\n    \
    \            j = j+1\n                j = j+1\n                j = j+1\n     \
    \           i = i+1\n            }\n        }\n        for(i<l-1;i++) {\n    \
    \        if(arr1(i) < arr2(i)) {\n                arr1(i) = arr1(i) + 1\n    \
    \        } else if(arr1(i) >= arr2(i)) {\n                arr1(i) = arr1(i) +\
    \ 1\n            }\n        }\n        for(i<l-1;i++) {\n            if(arr2(i)\
    \ < arr1(i)) {\n                arr2(i) = arr2(i) + 1\n            } else if(arr2(i)\
    \ >= arr1(i)) {\n                arr2(i) = arr2(i) + 1\n            }\n      \
    \  }\n        if(arr1(0)==arr2(0)) {\n            true\n        } else {\n   \
    \         false\n        }\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\
    \ == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong, 10l.toLong,\
    \ 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmplpbibo9w.scala:60:17 ---------------------------\e\
    [0m\e[0m\n\e[31m60 |\e[0m        \e[33mfor\e[0m(i<l-\e[31m1\e[0m;i++) {\n\e[31m\e\
    [31m   |\e[0m                 ^\e[0m\n\e[31m   |\e[0m                 ')' expected,\
    \ but ';' found\n\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmplpbibo9w.scala:60:21\
    \ ---------------------------\e[0m\e[0m\n\e[31m60 |\e[0m        \e[33mfor\e[0m(i<l-\e\
    [31m1\e[0m;i++) {\n\e[31m\e[31m   |\e[0m                     ^\e[0m\n\e[31m  \
    \ |\e[0m                     pattern expected\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E040] Syntax Error: /tmp/tmplpbibo9w.scala:67:17 ---------------------------\e\
    [0m\e[0m\n\e[31m67 |\e[0m        \e[33mfor\e[0m(i<l-\e[31m1\e[0m;i++) {\n\e[31m\e\
    [31m   |\e[0m                 ^\e[0m\n\e[31m   |\e[0m                 ')' expected,\
    \ but ';' found\n\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmplpbibo9w.scala:67:21\
    \ ---------------------------\e[0m\e[0m\n\e[31m67 |\e[0m        \e[33mfor\e[0m(i<l-\e\
    [31m1\e[0m;i++) {\n\e[31m\e[31m   |\e[0m                     ^\e[0m\n\e[31m  \
    \ |\e[0m                     pattern expected\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E161] Naming Error: /tmp/tmplpbibo9w.scala:37:12 ---------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33mvar\e[0m \e[36ml\e[0m = \e[31m0\e[0m\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^\e[0m\n\e[31m   |\e[0ml is already defined\
    \ as \e[33mvalue\e[0m \e[35ml\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E052] Type Error: /tmp/tmplpbibo9w.scala:53:18 -----------------------------\e\
    [0m\e[0m\n\e[31m53 |\e[0m                l = l-\e[31m1\e[0m\n\e[31m\e[31m   |\e\
    [0m                ^^^^^^^\e[0m\n\e[31m   |\e[0m                Reassignment to\
    \ val l\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n6 errors found\n"
  stdout: ''
  timestamp: 1660009864
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        if (arr.isEmpty)\
    \ {\n            return true\n        }\n        val listWithoutHead = arr.drop(1)\n\
    \        val listWithoutTail = arr.reverse.drop(1)\n        if (listWithoutTail.isEmpty)\
    \ {\n            return moveOneBall(listWithoutHead)\n        }\n        val possibleSortedList\
    \ = listWithoutTail.zip(listWithoutHead)\n        possibleSortedList.foreach {\
    \ x =>\n            val temp = x._1\n            val nextEle = x._2\n        \
    \    if (temp > nextEle) {\n                val index = possibleSortedList.indexOf(nextEle)\n\
    \                possibleSortedList.apply(index) = temp\n            }\n     \
    \   }\n        if (possibleSortedList.sum < possibleSortedList.size) {\n     \
    \       return moveOneBall(possibleSortedList.map(_.toLong))\n        } else {\n\
    \            return moveOneBall(possibleSortedList)\n        }\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpul4b3bx8.scala:40:16 ------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m                possibleSortedList.apply(index) = temp\n\
    \e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                value update is not a member of Int => (Long, Long)\n\e[31m\e\
    [31m-- Error: /tmp/tmpul4b3bx8.scala:43:34 -----------------------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m        \e[33mif\e[0m (possibleSortedList.sum < possibleSortedList.size)\
    \ {\n\e[31m\e[31m   |\e[0m                                  ^\e[0m\n\e[31m   |\e\
    [0m          No implicit Ordering defined for B\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m          where:    B is a type variable with constraint >: (Long, Long)\n\e\
    [31m   |\e[0m          .\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpul4b3bx8.scala:44:56\
    \ ------------------------\e[0m\e[0m\n\e[31m44 |\e[0m            \e[33mreturn\e\
    [0m moveOneBall(possibleSortedList.map(_.toLong))\n\e[31m\e[31m   |\e[0m     \
    \                                                 ^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mvalue toLong is not a member of (Long, Long), but could be made available as\
    \ an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports\
    \ might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e[0m  import\
    \ math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import math.Numeric.Implicits.infixNumericOps\n\
    \e[31m   |\e[0m\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpul4b3bx8.scala:46:31\
    \ --------------------\e[0m\e[0m\n\e[31m46 |\e[0m            \e[33mreturn\e[0m\
    \ moveOneBall(possibleSortedList)\n\e[31m\e[31m   |\e[0m                     \
    \          ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                     Found:\
    \    (possibleSortedList : List[(Long, Long)])\n\e[31m   |\e[0m              \
    \       Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660009868
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.size\n\
    \        var start = 0\n        var sum = 0\n        var last = -1\n\n       \
    \ while ( start < n) {\n            sum = arr.slice( start, start+1).reduceLeft(_+_)\n\
    \            if (sum >= last) \n                last = sum\n            else \n\
    \                start = start+1\n        }\n        sum < last\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmptoj03aik.scala:32:55\
    \ --------------------\e[0m\e[0m\n\e[31m32 |\e[0m            sum = arr.slice(\
    \ start, start+\e[31m1\e[0m).reduceLeft(_+_)\n\e[31m\e[31m   |\e[0m          \
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \              Found:    Long\n\e[31m   |\e[0m                  Required: Int\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009867
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        if(arr.isEmpty)\n\
    \            return true\n        val arrSize = arr.size\n        val listToUse\
    \ = arr.toArray\n        val lastIndex = arrSize - 1\n        var sortedArr :\
    \ List[Long] = Nil\n        val result = true\n        val resultArray = arr.toList.toArray\n\
    \        for(i <- 0 until lastIndex){\n            val newSortedArr = listToUse.slice(i+1,\
    \ arrSize)\n            sortedArr = newSortedArr.reverse\n            val sum\
    \ = 0\n            val newSum = 0\n            for(j <- 0 until sortedArr.length){\n\
    \                newSum += sortedArr(j)\n            }\n            if(newSum\
    \ > resultArray(i)){\n                result = false\n            }\n        }\n\
    \        result\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp8ehh_z7c.scala:36:37\
    \ --------------------\e[0m\e[0m\n\e[31m36 |\e[0m            sortedArr = newSortedArr.reverse\n\
    \e[31m\e[31m   |\e[0m                        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                        Found:    \e[1m\e[31mArray\e[0m[Long]\n\e[31m\
    \   |\e[0m                        Required: \e[1m\e[32mList\e[0m[Long]\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp8ehh_z7c.scala:40:23 ------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m                newSum += sortedArr(j)\n\e[31m\e[31m\
    \   |\e[0m                ^^^^^^^^^\e[0m\n\e[31m   |\e[0m               value\
    \ += is not a member of Int - did you mean newSum.!=?\n\e[31m\e[31m-- [E052] Type\
    \ Error: /tmp/tmp8ehh_z7c.scala:43:23 -----------------------------\e[0m\e[0m\n\
    \e[31m43 |\e[0m                result = \e[31mfalse\e[0m\n\e[31m\e[31m   |\e[0m\
    \                ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                Reassignment\
    \ to val result\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660009868
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the list will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get a list sorted in non-decreasing order by performing\
    \ \n    // the following operation on the given list:\n    // You are allowed\
    \ to perform right shift operation any number of times.\n    // One right shift\
    \ operation means shifting all elements of the list by one\n    // position in\
    \ the right direction. The last element of the list will be moved to\n    // the\
    \ starting position in the list i.e. 0th index. \n    // If it is possible to\
    \ obtain the sorted list by performing the above operation\n    // then return\
    \ true else return false.\n    // If the given list is empty then return true.\n\
    \    // Note: The given list is guaranteed to have unique elements.\n    // For\
    \ Example:\n    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n    // be achieved for the given\
    \ list.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong)))\n    // (false)\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // list by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val size = arr.size\n\
    \        if (size == 0) true\n        else {\n            val pos = size - 1\n\
    \            val max = arr.max\n            var i = -1\n            var x = true\n\
    \            while (x && pos >= 0) {\n                i = i + 1\n            \
    \    x = arr(i) < max\n                pos = pos - 1\n            }\n        \
    \    arr(i) = arr.last\n            return x && moveOneBall(arr)\n        }\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmpqfz3oh39.scala:36:20 -----------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m                pos = pos - \e[31m1\e[0m\n\e[31m\e[31m\
    \   |\e[0m                ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                Reassignment\
    \ to val pos\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpqfz3oh39.scala:38:12\
    \ ------------------------\e[0m\e[0m\n\e[31m38 |\e[0m            arr(i) = arr.last\n\
    \e[31m\e[31m   |\e[0m            ^^^\e[0m\n\e[31m   |\e[0m  value update is not\
    \ a member of List[Long] - did you mean arr.updated?\n2 errors found\n"
  stdout: ''
  timestamp: 1660009868
