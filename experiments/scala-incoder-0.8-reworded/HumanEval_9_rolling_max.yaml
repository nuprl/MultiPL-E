name: HumanEval_9_rolling_max
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // From a given list of integers, generate a list of rolling maximum element\
  \ found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers\
  \ : List[Long]) : List[Long] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
  \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
  \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
  \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
  \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
  \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
completions: ["        var current = List.empty[Long]\n        var maximum = numbers.head\n\
    \        var tempList = List.empty[Long]\n        numbers.tail.foreach{value =>\n\
    \            val current = current :+ value\n            val tempListWithCurrentMax\
    \ = tempList :+ maximum\n            maximum = Math.max(maximum, value)\n    \
    \        tempListWithCurrentMax.foreach{max => if (max > maximum) current = current\
    \ :+ max}\n        }\n        current :+ maximum", "        val maxVals = numbers.takeWhile(_\
    \ > 0).reverse\n        val maxCounts = numbers.dropWhile(_ < 0).reverse\n   \
    \     (maxVals, maxCounts)", "        val max_list = ListBuffer[Long]()\n    \
    \    var rolling_max = 0\n\n        for (number <- numbers) {\n            if\
    \ (number > rolling_max) {\n                rolling_max = number\n           \
    \     max_list += rolling_max\n            } else if (number == rolling_max) {\n\
    \                max_list += number\n            }\n        }\n        max_list.toList",
  "        var max = 0\n        numbers.reverse foreach { x =>\n            if (x\
    \ > max) {\n                max = x\n            }\n        }\n        max ::\
    \ rollingMax(numbers.dropRight(1));", "        var max = 0\n        var maxIndex\
    \ = 0\n        var currentMax = 0\n        var rollingMax = scala.collection.mutable.ArrayBuffer.empty[Long]()\n\
    \        var currentIndex = numbers.head\n\n        var sum = 0\n\n        while(numbers.length\
    \ > 0) {\n            sum = numbers(currentIndex).asInstanceOf[Long]\n       \
    \     rollingMax = rollingMax.:+(numbers(currentIndex))\n            currentIndex\
    \ += 1\n\n            if(sum > currentMax) {\n                currentMax = sum\n\
    \                maxIndex = currentIndex\n                rollingMax = rollingMax.:+(numbers(maxIndex))\n\
    \            }\n\n            if(currentIndex < numbers.size) {\n            \
    \    sum = 0\n                currentMax = 0\n                maxIndex = 0\n \
    \               currentIndex = numbers.head\n            }\n        }\n\n    \
    \    rollingMax.subList(0, maxIndex + 1).map((elem) => elem.asInstanceOf[Long]).toList",
  "        val maxValues = mutable.Buffer[Long]()\n        val currentMax = numbers.head\n\
    \        for(i <- 1 until numbers.size) {\n            val value = numbers.lift(i).max\n\
    \            if(value > currentMax) {\n                currentMax = value\n  \
    \              maxValues += currentMax\n            } else if(value == currentMax)\
    \ {\n                maxValues += currentMax\n            } else {\n         \
    \       maxValues += currentMax\n                maxValues += value\n        \
    \    }\n        }\n        maxValues", "        val rollMax = mutable.ArrayBuffer.empty[Long]\n\
    \        numbers.reverse.foreach(rollMax += _)\n        rollMax.reverse.toList",
  "        val max = numbers(0)\n        numbers.reverse.foldLeft(List[Long]()) {\
    \ (result, num) =>\n            if(num > max)\n                result :+ num\n\
    \            else \n                result\n        }.reverse", "        val maxList\
    \ = numbers.foldLeft[List[Long]](List.empty[Long]) { \n            case (acc,\
    \ x) =>\n                if (acc contains x) \n                    acc else acc\
    \ :+ x \n        }\n        val tail = numbers.dropRight(1)\n        if (tail.isEmpty)\
    \ maxList else rollingMax(tail).flatMap { acc =>\n            maxList :+ max(acc)\n\
    \        }", "        var maxes = mutable.Buffer.empty[Long]\n        var max\
    \ = 0l\n        for (n <- numbers) {\n            if (n > max) {\n           \
    \     maxes += n\n                max = n\n            } else if (n == max) {\n\
    \                maxes += n\n            } else if (n > max) {\n             \
    \   maxes = maxes ++ List(max)\n                max = n\n            }\n     \
    \   }\n        maxes += max\n        return maxes.toList", "        // base case\n\
    \        if(numbers.isEmpty) return numbers.tail\n        val first = numbers.head\n\
    \        if(numbers.size == 1) List(first)\n        else {\n            // recursive\
    \ case\n            val tail = rollingMax(numbers.tail)\n            val middle\
    \ = numbers.take(numbers.size / 2).max\n            val maxes = tail filter (_\
    \ >= middle)\n            val maxes.reverse.foldLeft(maxes)( (curMax: List[Long],\
    \ elem: Long) =>\n                curMax :+ elem :+ curMax.last\n            )\n\
    \        }", "        def rollingMaxHelper(numbers: List[Long], maxSoFar: List[Long])\
    \ : List[Long] = {\n            if (numbers.isEmpty) return maxSoFar\n       \
    \     if (numbers.size == 1) return maxSoFar\n            val first = numbers.head\n\
    \            val tail = numbers.tail\n            maxSoFar :+ first\n        \
    \    val nextMax = tail.foldLeft(first)(max(_, number))\n            rollingMaxHelper(tail,\
    \ nextMax)\n        }\n        rollingMaxHelper(numbers, List[Long]())", "   \
    \     val maxNumbers = numbers.map(_.toLong).toList\n        val rollingMaxNumbers\
    \ = maxNumbers.tail.zip(maxNumbers.tail.dropRight(1)).map(a => a._1 + a._2)\n\
    \        rollingMaxNumbers.takeWhile(a => a > maxNumbers.head).reverse", "   \
    \     val len = numbers.size\n        var maxList = numbers.tail\n        var\
    \ maxNumber = numbers.last\n        var rollingMaxList = ListBuffer.empty[Long]\n\
    \        val rollingMax = new mutable.Buffer[Long]()\n        for (i <- 0 until\
    \ len) {\n            rollingMax += numbers(i)\n            rollingMaxList +=\
    \ numbers(i)\n            if (rollingMax.last > maxNumber) {\n               \
    \ maxNumber = rollingMax.last\n                maxList = rollingMaxList\n    \
    \        }\n        }\n        rollingMaxList", "        // For a rolling max,\
    \ we just need to maintain a list of maximum elements seen so far\n        //\
    \ and just append the current element to it when we see it again. The only time\
    \ we add a\n        // new element is when we reach the end.\n        val maxes\
    \ = new mutable.ListBuffer[Long]\n        maxes += numbers.head\n        numbers\
    \ foreach { number =>\n            if (number > maxes.last) {\n              \
    \  maxes += number\n            }\n        }\n        maxes.toList", "       \
    \ require(numbers.nonEmpty, \"numbers cannot be empty\")\n        val listMax\
    \ = numbers.map(x => x)\n        var max = 0L\n        var current = 1L\n    \
    \    var listMaxMax = List[Long]()\n        for (i <- numbers) {\n           \
    \ if (current > x) {\n                listMaxMax = listMax.takeWhile(x => current\
    \ >= x).toList\n                current = 1L\n                max = x\n      \
    \      }\n            if (max < i) current = i\n            else max = i\n   \
    \     }\n        listMaxMax = listMaxMax.map(x => x + 1).toList\n        listMaxMax\
    \ :: listMax", "        numbers.foldLeft(List[Long]()) { (sum, current) =>\n \
    \           val index = sum.size - 1\n            if (index <= current) sum :+\
    \ current\n            else sum.updated(index, current max sum)\n        }.reverse",
  "        numbers.foldLeft(List[Long]()) { (res, x) => {\n            val max = res.max\
    \ { t => if (t > x) t else x }\n            val res = res.init :+ max\n      \
    \      res\n        }", "        var max = 0\n        var maxElem = numbers(0)\n\
    \n        for (i <- 1 to numbers.length - 1) {\n            max = numbers(i)\n\
    \            if (max > maxElem) {\n                maxElem = max\n           \
    \ }\n        }\n        maxElem :: rollingMax(numbers.drop(1))", "        if (numbers.isEmpty)\
    \ return Nil\n        val r = new mutable.ListBuffer[Long]\n        var index\
    \ = 0\n        var max = 0L\n        val r = new mutable.ListBuffer[Long]\n  \
    \      for (i <- 1 to numbers.size) {\n            if (numbers(i) > max) {\n \
    \               index = i\n                max = numbers(i)\n            }\n \
    \           else {\n                val r = numbers.drop(i).filterNot(x => x ==\
    \ numbers(i)).iterator\n                if (r.hasNext) r else null\n         \
    \   }\n        }\n        r :+ max", "        // Sort list to make it more interesting\n\
    \        val sortedNumbers = numbers.sortWith((x, y) => x < y)\n        \n   \
    \     // Sum up all elements except the last\n        var cummulativeSum = sortedNumbers(0)\n\
    \        var cummulativeSumMax = cummulativeSum\n        for(i <- 1 to sortedNumbers.length-1)\
    \ {\n            cummulativeSum += sortedNumbers(i)\n            cummulativeSumMax\
    \ = Math.max(cummulativeSum, cummulativeSumMax)\n        }\n        \n       \
    \ // Append the last\n        numbers :+ cummulativeSumMax", "        numbers.foldLeft(List[Long]()){\
    \ \n            (acc: List[Long], number: Long) => {\n                number match\
    \ {\n                    case x :: xs => x :: acc\n                    case _\
    \ => acc :+ number\n                }\n            }\n        }", "        val\
    \ rollingMaxList = mutable.MutableList[Long]()\n        var max = numbers.last\n\
    \        numbers.foreach{ n =>\n            if (n > max) {\n                max\
    \ = n\n            }\n        }\n        var index = numbers.length\n        while\
    \ (!numbers(index).equals(max)) {\n            rollingMaxList += max\n       \
    \     index += 1\n        }\n        rollingMaxList.toList", "        val rollingMax\
    \ = mutable.ListBuffer[Long]()\n        var maxNum = numbers(0)\n        for (i<-\
    \ 1 to numbers.size)\n        {\n            maxNum = numbers(i)\n           \
    \ for (j<- 0 to i-1)\n            {\n                if (numbers(j) > maxNum)\n\
    \                {\n                    maxNum = numbers(j)\n                }\n\
    \            }\n            rollingMax += maxNum\n        }\n        rollingMax.toList",
  "      val result = ListBuffer[Long]()\n      var rollingMax = numbers.get(0)\n\
    \      for (num <- numbers) {\n        if (num > rollingMax) {\n          rollingMax\
    \ = num\n          result += rollingMax.toLong\n        }\n      }\n      result",
  "        numbers.foldLeft((List[Long](), 0)){ (x, y) =>\n            // Add new\
    \ number at the head of list\n            val temp_list = x match {\n        \
    \        case (acc, 0) => (y :: acc, 0)\n                case (acc, m) => (y ::\
    \ acc, m)\n            }\n            val max_element = temp_list._2\n       \
    \     // Append new element to the head of previous list\n            val temp_list\
    \ = x match {\n                case (acc, 0) => (y :: acc, 0)\n              \
    \  case (acc, m) => (y :: acc, m)\n            }\n            // Find index of\
    \ max_element from previous list\n            val index = temp_list._1.indexOfMax(max_element)\n\
    \            // Append max_element to last element of list\n            temp_list._1\
    \ :+ max_element :: temp_list._2(index).tail\n        }._1", "        val max\
    \ = numbers(0l).max(numbers(numbers.size - 1l))\n        val list = new collection.mutable.ListBuffer[Long]()\n\
    \        for (i <- 0 until numbers.size - 1l) {\n            if (numbers(i + 1l)\
    \ == max) {\n                list += numbers(i).toLong\n            }\n      \
    \  }\n        list.toList", "        var result = List[Long](numbers(0))\n   \
    \     val listOfMaxElements = List[Long]()\n        val maxElement = numbers(0)\n\
    \        numbers.foreach {\n            number => {\n                if(number\
    \ > maxElement) {\n                    maxElement = number\n                 \
    \   listOfMaxElements = ListBuffer(maxElement)\n                } else {\n   \
    \                 listOfMaxElements = listOfMaxElements :+ number\n          \
    \      }\n                result = result ++ listOfMaxElements\n            }\n\
    \        }\n        return result", "        val rollingMaxResult = mutable.List[Long]()\n\
    \        var max = 0\n        var maxIndex = 0\n        for ((number, index) <-\
    \ numbers.zipWithIndex) {\n            if (number > max) {\n                max\
    \ = number\n                maxIndex = index\n            }\n        }\n     \
    \   for (i <- 0 until maxIndex) {\n            val currentMax = numbers(maxIndex\
    \ - i)\n            if (max == currentMax) {\n                rollingMaxResult\
    \ += currentMax\n            } else {\n                rollingMaxResult += max\n\
    \            }\n        }\n        rollingMaxResult", "        val res = numbers.foldLeft(List[Long]())\
    \ { case (acc, number) =>\n            number :: acc\n        }\n        res.reverse",
  "        val rollingMax = new mutable.Array[Long]\n        var maximum = 0L\n  \
    \      var rollingMaxNumber = 0\n        var i = 1\n        var rollingMaxIndex\
    \ = 0\n        while(i < numbers.length) {\n            rollingMax(rollingMaxNumber)\
    \ = numbers(i)\n            rollingMaxNumber += 1\n            i += 1\n      \
    \      maximum = max(maximum, numbers(i))\n        }\n        rollingMaxIndex\
    \ = 1\n        while(rollingMaxIndex < rollingMaxNumber) {\n            maximum\
    \ = max(maximum, rollingMax(rollingMaxIndex))\n            i += 1\n          \
    \  rollingMaxIndex += 1\n        }\n        rollingMax(rollingMaxNumber)", " \
    \       val rollingMax = numbers.foldLeft(List.empty[Long])((acc, x) => acc max\
    \ x)\n        val rollingMaxList: List[Long] = rollingMax.toList\n        rollingMaxList.reverse",
  "        // Using mutable collection to store all rolling maximum elements\n   \
    \     // The purpose of this mutable collection is to prevent multiple time searching\
    \ same rolling\n        // max element in the rolling max list\n        val rollingMaxList\
    \ = mutable.Buffer[Long]()\n        numbers.foreach{number =>\n            if(number\
    \ > rollingMaxList.last){\n                rollingMaxList += number\n        \
    \    }\n        }\n        return rollingMaxList.toList", "        // Use a scala.collection.mutable.Stack\
    \ to keep track of the current max values seen so far.\n        val stack = new\
    \ mutable.Stack[Long]()\n        for (i <- numbers) {\n            if (stack.size\
    \ > 0)\n                stack += max( stack.last , i)\n            else {\n  \
    \              stack += i\n            }\n        }\n        stack.toList", " \
    \       if (numbers.length <= 0) return Nil\n        val max = 0\n        val\
    \ maxElement = numbers.head\n        val maxList = List(numbers.tail.max) :::\
    \ Nil\n        val nextElements = numbers.tail\n        nextElements.tail.foldLeft(List[Long]())((acc,\
    \ element) => {\n            if (element > max) {\n                max = element\n\
    \                maxElement = element\n                maxList = acc\n       \
    \     }\n            if (element == maxElement) {\n                maxList = maxList\
    \ :+ element\n            }\n            if (element < maxElement) maxList = maxList\
    \ :+ element\n            maxList ::: acc\n        })", "        val maxElements\
    \ = mutable.ListBuffer[Long]()\n        for (elem <- numbers) {\n            maxElements\
    \ += elem\n        }\n        val maxIndex = maxElements.max\n        maxIndex.until(maxIndex.head\
    \ + 1).foreach { maxIndex =>\n            maxElements.updated(maxIndex, maxElements(maxIndex))\n\
    \        }\n        return maxElements.toList", "        val m = numbers(numbers.size\
    \ - 1)\n        var i = numbers.size - 1\n        while (i >= 0) {\n         \
    \   if (numbers(i) > m)\n                m = numbers(i)\n            i--\n   \
    \     }\n        numbers", "        // Initialize a list to hold rolling maximum\n\
    \        val rollingMax = new scala.collection.mutable.ListBuffer[Long]()\n  \
    \      for (n <- numbers) {\n            // If number is not in the rolling maximum\
    \ list, add the number to the list\n            if (!rollingMax.contains(n)) {\n\
    \                rollingMax.append(n)\n            }\n        }\n        // Return\
    \ the rolling maximum list\n        rollingMax.toList", "        val maxList =\
    \ numbers.foldLeft(List.empty[Long]){\n            (maxList, elem) =>\n      \
    \          if (elem > maxList.head) maxList :+ elem\n                else maxList\n\
    \        }\n        val list: List[Long] = maxList.drop(maxList.size - 3)\n  \
    \      list", "        val maxes = scala.collection.mutable.ListBuffer.empty[Long]\n\
    \        for (number <- numbers) {\n            val maxIndex = numbers.indexWhere(_\
    \ > number)\n            val maxValue = numbers(maxIndex)\n            if (maxes.isEmpty\
    \ || maxes.last > maxValue)\n                maxes += maxValue\n        }\n  \
    \      maxes.toList", "        val maxSeq = new mutable.ListBuffer[Long]()\n \
    \       numbers.foreach { x =>\n            val maxIndex = maxSeq.findIndex(_.longValue\
    \ < x)\n            maxSeq.update(maxIndex + 1, x)\n        }\n        maxSeq.toList",
  "        val maxList : List[Long] = List.empty[Long]\n        var maxVal : Long\
    \ = 0\n        var maxIndex = 0\n        numbers.zipWithIndex.foreach {\n    \
    \        x => {\n                if (x._2 >= maxIndex){\n                    maxVal\
    \ = x._1\n                    maxIndex = x._2\n                }\n           \
    \     if (x._2 == maxIndex && x._1 > maxVal) {\n                    maxVal = x._1\n\
    \                    maxIndex = x._2\n                }\n            }\n     \
    \   }\n        maxList.add(maxVal)\n        return maxList", "        val numList\
    \ = numbers.toList\n        val numListLen = numList.size\n        val numListMax\
    \ = numList(0).toLong\n        // generate numListLen rolling max list\n     \
    \   val numMaxList = new Array[Long](numListLen)\n        var j = 0\n        for(i\
    \ <- 0 until numListLen){\n            numMaxList(i) = numList(i)\n        }\n\
    \        // append rolling max list\n        while(j < numListLen){\n        \
    \    val maxNum = numMaxList(j)\n            val index = j\n            val k\
    \ = 1\n            while(k <= numListLen){\n                if(numMaxList(index\
    \ + k) > maxNum){\n                    numMaxList(index + k) = maxNum\n      \
    \          }\n                k++\n            }\n            j++\n        }\n\
    \        numMaxList.map(_.toLong)", "        val result = new mutable.ListBuffer[Long]()\n\
    \        numbers.foreach { n =>\n            result += n.toList #:: rollingMax(result.slice)\n\
    \        }\n        result.toList", "        require(numbers.length >= 1)\n  \
    \      var max = 0\n        val maxElem = numbers(0)\n        var index = 0\n\
    \        var newMax = maxElem\n        for(i <- 1 to numbers.length - 1){\n  \
    \          val newElem = numbers(i)\n            if (newElem > maxElem){\n   \
    \             max = newMax\n                index = i\n            }\n       \
    \     newMax = math.max(newElem, max)\n        }\n        val result = List(maxElem,\
    \ index)\n        return result", "        val rollingMax = numbers.sortWith(_\
    \ < _)\n            .reverse\n            .sliding(numbers.size)\n           \
    \ .map { n =>\n                val rollingMax = n.sortWith(_ < _)\n          \
    \          .reverse\n                    .sliding(numbers.size)\n            \
    \        .max\n                rollingMax.max(numbers.last)\n            }\n \
    \           .reverse\n            .toList\n        rollingMax", "      def accumulator(current:\
    \ Long, accumulator: Long) : Long = if (current > accumulator) current else accumulator\n\
    \      numbers.foldLeft(0l.toLong)(accumulator)", "        def computeMax(n: Long,\
    \ max: List[Long]) : List[Long] = {\n            if (n == 0) max\n           \
    \ else computeMax(n - 1, max :+ Math.max(n-1, numbers(n-1)))\n        }\n    \
    \    computeMax(numbers.size, List.empty)", "        def isMax(x : Long, m : List[Long],\
    \ s : List[Long]) : Boolean = {\n            if(m.head == x) {\n             \
    \   true\n            } else {\n                m.head < x && (s = m :: s)\n \
    \           }\n        }\n        def maxRolling(n : List[Long], s : List[Long])\
    \ : List[Long] = {\n            n match {\n                case Nil => s\n   \
    \             case x :: Nil => maxRolling(s, List(x.toLong))\n               \
    \ case x :: xs => maxRolling(isMax(x, xs, s), xs)\n            }\n        }\n\
    \        maxRolling(numbers, Nil)", "        def rolling(list : List[Long], max:\
    \ Long, current : Long) : List[Long] = {\n            list match {\n         \
    \       case Nil => List(current)\n                case head :: tail => if(head\
    \ > current) rolling(tail, max, head) else rolling(tail, max, current)\n     \
    \       }\n        }\n        rolling(numbers, Int.MaxValue, Int.MaxValue).toList",
  "        val numbersList = numbers.toList\n        val result = new mutable.ListBuffer[Long]()\n\
    \        numbersList.iterator\n                .takeWhile(_ <= numbersList(numbersList.size\
    \ - 1))\n                .foreach(result.add((numbersList(numbersList.length -\
    \ 1))))\n        result.toList", "        require(numbers.nonEmpty, \"rollingMax\
    \ requires non-empty list of numbers\")\n        var result = List[Long]()\n \
    \       numberIter(numbers, result)\n        result", "        val max = new mutable.ArrayBuffer[Long]()\n\
    \        for (n <- numbers) {\n            if (n.toInt > max.toInt) max += n.toLong\n\
    \            else n = max\n        }\n        list(a.max(a.last, max.max))", " \
    \       if (numbers.isEmpty)\n            List()\n        else {\n           \
    \ val list = numbers.tail\n            val currentMax = list.head\n          \
    \  val rollingMax = numbers.toList match {\n                case x :: y :: xs\
    \ => if (x == currentMax) y :: rollingMax\n                     else y :: rollingMax.map(v\
    \ => if (v > currentMax) v else currentMax)\n                case _ => numbers.toList\n\
    \            }\n            rollingMax ++ rollingMax.tail\n        }", "     \
    \   numbers.foldRight[List[Long]](List[Long]())((acc, x) => {\n            if\
    \ (acc.last >= x) return acc\n            if (acc contains x) acc :+ x\n     \
    \       else acc :+ acc.last + 1\n        })", "        // For each element in\
    \ the list, generate the maximum (max or rolling max)\n        // until that moment,\
    \ then add it to the list and return it.\n        numbers.foldLeft(List[Long]())((accumulator,\
    \ element) => accumulator :+ math.max(element))", "        numbers.foldLeft(List[Long]()){\n\
    \            (x: mutable.Buffer, n: Long) => {\n                if (x.size < n)\
    \ x ++= List(n.toLong)\n                else\n                { val maxEle = x.lastOption.getOrElse(x.size)\n\
    \                    x ++= List(maxEle - 1, maxEle)}\n            }\n        }.reverse",
  "        val max = new mutable.PriorityQueue[Long]() //max value found so far\n\
    \        numbers.foreach { n =>\n            max.enqueue(math.max(n, max.head))\n\
    \        }\n        val result = new mutable.PriorityQueue[Long]()\n        number.foreach\
    \ { n =>\n            if (max.size > 0) result.enqueue(math.max(n, max.dequeue))\n\
    \        }\n        result.toList", "        val list = numbers.toList\n     \
    \   val max = list.max\n        val max = list.max\n        val max = list.max\n\
    \        val max = list.max\n        val max = list.max\n        val max = list.max\n\
    \        val max = list.max\n        val max = list.max\n        val max = list.max\n\
    \        val max = list.max\n        val max = list.max\n        val max = list.max\n\
    \        val max = list.max\n        val max = list.max\n        val max = list.max\n\
    \        val max = list.max\n        val max = list.max\n        val max = list.max\n\
    \        val max = list.max\n        val max = list.max\n        val max = list.max\n\
    \        val max = list.max\n        val max = list.max\n        val max = list.max\n\
    \        val max = list.max\n        val max = list.max\n        val max = list.max\n\
    \        val max = list.max\n        val max = list.max\n        val max = list.max\n\
    \        val max = list.max\n        val max = list.max\n        val max = list.max\n\
    \        val max = list.max\n        val max = list.max\n        val max = list.max\n\
    \        val max = list.max\n        val max = list.max\n        val max = list.max\n\
    \        val max = list.max\n        val max = list.max\n        val max = list.max\n\
    \        val max = list.max\n        val max = list.max\n        val max = list.max\n\
    \        val max = list.max\n        val max = list.max\n        val max = list.max\n\
    \        val max = list.max\n        val max = list.max\n        val max = list.max\n\
    \        val max = list.max\n        val max = list.max\n        val max = list.max\n\
    \        val max = list.max\n        val max = list.max\n        val max = list.max\n\
    \        val max = list.max\n        val max = list.max\n        val max = list.max\n\
    \        val max = list.max\n        val max = list.max\n        val max = list.max\n\
    \        val max = list.max\n        val max = list.max\n        val max = list.max\n\
    \        val max = list.max\n        val max = list.max\n        val max = list.max\n\
    \        val max = list.max\n        val max = list.max\n        val max = list.max\n\
    \        val max = list.max\n        val max = list.max\n        val max = list.max\n\
    \        val max = list.max\n        val max = list.max\n        val max = list.max\n\
    \        val max = list.max\n        val max = list.max\n        val max = list.max\n\
    \        val max = list.max\n        val max = list.max\n        val max = list.max\n\
    \        ", "        if (numbers.isEmpty) {\n            numbers\n        } else\
    \ {\n            var maxNumbers : List[Long] = List(numbers.head)\n          \
    \  var currentNumbers = List(numbers.tail)\n            var rollingMaxNumber =\
    \ numbers.head\n\n            while (currentNumbers.nonEmpty) {\n            \
    \    var foundRollingMaxNumber = false\n                var rollingMaxIndex =\
    \ -1\n\n                for (i <- 0 until currentNumbers.size) {\n           \
    \         if (maxNumbers.exists(number => number > currentNumbers(i))) {\n   \
    \                     if (foundRollingMaxNumber) {\n                         \
    \   maxNumbers = List(currentNumbers(i))\n                            foundRollingMaxNumber\
    \ = false\n                        } else {\n                            maxNumbers\
    \ = maxNumbers.head :: List(currentNumbers(i))\n                            rollingMaxIndex\
    \ = i + 1\n                            foundRollingMaxNumber = true\n        \
    \                }\n                    }\n                }\n\n             \
    \   if (!foundRollingMaxNumber) {\n                    maxNumbers = rollingMaxNumber\
    \ :: maxNumbers\n                }\n\n                currentNumbers = currentNumbers.tail\n\
    \                rollingMaxNumber = maxNumbers(rollingMaxIndex)\n            }\n\
    \n            maxNumbers\n        }", "        var currentMax = numbers(0)\n \
    \       var currentMaxIndex = -1\n\n        var maxRolling = 0\n        var maxRollingIndex\
    \ = 0\n        var maxRollingValue = 0\n        var maxRollingIndexValue = 0\n\
    \        var rollingValue = 0\n        var rollingIndex = 0\n\n        for (i\
    \ <- 0 until numbers.length) {\n            rollingIndex = 0\n            currentMaxIndex\
    \ = i\n\n            for (j <- 0 until numbers.length) {\n                if (i\
    \ != j) {\n                    rollingValue = numbers(j)\n                   \
    \ if (rollingValue > currentMax) {\n                        currentMax = rollingValue\n\
    \                        currentMaxIndex = j\n                    }\n        \
    \            rollingIndex += 1\n                }\n            }\n\n         \
    \   if (currentMaxIndex != maxRollingIndex) {\n                maxRollingIndex\
    \ = currentMaxIndex\n                maxRollingValue = currentMax\n          \
    \      maxRollingIndexValue = currentMaxIndex\n                rollingValue =\
    \ currentMax\n                rollingIndex = currentMaxIndex\n            } else\
    \ {\n                rollingIndex += 1\n                rollingValue = currentMax\n\
    \                rollingIndexValue = currentMaxIndex\n                if (rollingValue\
    \ > maxRollingValue) {\n                    maxRollingValue = rollingValue\n \
    \                   maxRollingIndexValue = currentMaxIndex\n                }\n\
    \            }\n        }\n\n        return numbers(maxRollingIndexValue) ++ rollingValue",
  "        val maxList = numbers.map(_.toLong).scanLeft(0L)(_ + _).tail\n        val\
    \ rollingMax = maxList.max\n        maxList.map { max =>\n            if (max\
    \ > rollingMax) rollingMax else max\n        }", "        val m = new mutable.HashMap[Long,\
    \ Int]\n        var rollingMax = List[Long]()\n        for(i <- numbers ) {\n\
    \            val curMax = m.getOrElse(i, -1)\n            if(curMax == -1) { //\
    \ first time we encounter this element\n                rollingMax:::=i\n    \
    \            m.put(i, 1)\n            }\n            else { // we have not seen\
    \ the element before and we need to check its rollingMax\n                val\
    \ newMax = Math.max(curMax, i)\n                m.put(i, newMax)\n           \
    \     if(newMax > rollingMax.last) {\n                    rollingMax:::=newMax\n\
    \                }\n            }\n        }\n        rollingMax", "        val\
    \ rollingMax = numbers.map(_ => (numbers.reduceLeftOption(_ > _).getOrElse(0L),\
    \ numbers)).groupBy(x => x(0)).mapValues(x => x.map(y => (y(1), y(2)))).mapValues(x\
    \ => x.map(_._1).max).toList\n        rollingMax.map(_._2)", "        def rollingMaxHelper(numbers:\
    \ List[Long], max: Long, prev: List[Long], result: List[Long]) : List[Long] =\
    \ {\n            if (numbers.isEmpty) {\n                result\n            }\
    \ else {\n                val x = numbers.head\n                if (prev.isEmpty\
    \ || x > prev) {\n                    rollingMaxHelper(numbers.tail, max, List(numbers(0)),\
    \ result :+ max)\n                } else {\n                    rollingMaxHelper(numbers.tail,\
    \ max, List(max), result :+ x)\n                }\n            }\n        }\n\
    \        rollingMaxHelper(numbers, numbers(0), numbers.init, List.empty)", " \
    \       val numbersWithMax = numbers.foldLeft(List[Long]()){case (numbers, i)\
    \ => if (numbers(numbers.size - 1) < i) numbers :+ i else numbers}\n        val\
    \ numbersWithMaxSize = numbersWithMax.size\n        val max = numbersWithMax.last\n\
    \        val maxSize = numbersWithMaxSize - 1\n        val numbersRolled = new\
    \ scala.collection.mutable.ListBuffer[Long]()\n        var i = 0\n        while\
    \ (i < maxSize) {\n            numbersRolled += numbersWithMax(i).abs\n      \
    \      i += 1\n        }\n        numbersRolled.take(maxSize).toList", "     \
    \   require(numbers contains numbers.length, \"The rolling max number list must\
    \ contain its length\")\n        require(numbers contains numbers.head, \"The\
    \ rolling max number list must contain its head\")\n        require(numbers contains\
    \ numbers.tail, \"The rolling max number list must contain its tail\")\n     \
    \   var max = 0l\n        numbers.foreach { number =>\n            val currentMax\
    \ = Math.max(max, number)\n            max = (currentMax + 1).toLong\n       \
    \ }\n        numbers.reverse.takeWhile(number => max < number).toList", "    \
    \    var maxSoFar = -1L\n        var rollingMaxSoFar = -1L\n        var rollingMax\
    \ = List[Long]()\n        var rollingMaxIndex = List[Int]()\n        numbers.foreach(x\
    \ => {\n            rollingMaxSoFar = x\n            if (x > maxSoFar) {\n   \
    \             maxSoFar = x\n            }\n            rollingMaxIndex += 1 //\
    \ update max index\n            rollingMax = rollingMax.toList :+ maxSoFar\n \
    \       })\n        rollingMaxIndex.toList.map(x => rollingMax(x)) // return list\
    \ of rolling max", "        var max = 0L\n        val ret: List[Long] = numbers.map\
    \ { n =>\n            if (max <= n) max = n\n            n else 0L\n        }\n\
    \        return ret.reverse", "        var max = numbers.head\n        var maxIndex\
    \ = numbers.lastIndex\n        numbers.tail.foreach {\n            if (_ > max)\
    \ {\n                max = _\n                maxIndex = _\n            }\n  \
    \      }\n        if (maxIndex - numbers.lastIndex < maxIndex) {\n           \
    \ numbers = numbers.init :+ max\n        }\n        numbers :+ max", "       \
    \ val rollingMaxValues = mutable.ListBuffer.empty[Long]\n        numbers.foreach\
    \ { x =>\n            rollingMaxValues.append(rollingMaxValues(rollingMaxValues.size-1))\n\
    \        }\n        rollingMaxValues.toList", "        def maxRoll(list: List[Long],\
    \ acc: Long) : Long = {\n            if (list.isEmpty) acc\n            else {\n\
    \                val max = math.max(list._1, acc)\n                list.tail.tail.foreach(x\
    \ => acc += x)\n                if (max < acc) max else maxRoll(list.tail, acc)\n\
    \            }\n        }\n        numbers.tail.init.reverse.map(x => maxRoll(numbers.init,\
    \ x)).reverse.drop(numbers.size - 1)", "        val result: List[Long] = Nil\n\
    \        val map = mutable.HashMap[Long, Long]()\n\n        numbers foreach {\
    \ n =>\n            if (map.contains(n)) {\n                val previous = map.get(n)\n\
    \                map.put(n, previous + 1)\n            } else {\n            \
    \    map.put(n, 1L)\n            }\n        }\n\n        numbers.foldLeft(map)((acc:\
    \ Map[Long, Long], n: Long) => {\n            if (acc.contains(n)) {\n       \
    \         val previous = acc.get(n)\n                acc.put(n, previous + 1)\n\
    \            } else {\n                acc.put(n, 1L)\n            }\n       \
    \ })\n\n        acc flatMap {\n            case (k, v) =>\n                if\
    \ (k > v) {\n                    v\n                } else {\n               \
    \     Nil\n                }\n        } toList", "        var curr = numbers(0)\n\
    \        numbers.tail.foreach { n =>\n            if (curr < n) curr = n\n   \
    \         else numbers = numbers :+ n\n        }\n        numbers :+ curr", " \
    \       val maxIndex = numbers.lastIndex\n        if (maxIndex == -1) numbers\
    \ else numbers.drop(maxIndex).map(x => numbers.takeWhile(y => y > x).max)", " \
    \       val res = new ListBuffer[Long]()\n        var max = 0\n        for {\n\
    \            n <- numbers\n        } max += n\n\n        while (max < numbers.length)\
    \ {\n            max += numbers.length\n            res += numbers(max)\n    \
    \    }\n\n        res", "        if (numbers.isEmpty) List(1l.toLong)\n      \
    \  else {\n            var max = 0L\n            var rollingMax: Option[Long]\
    \ = None\n            for (x <- numbers) {\n                if (x > max) max =\
    \ x\n                else {\n                    if (rollingMax.isEmpty) rollingMax\
    \ = x\n                    else rollingMax = Some(rollingMax.get + x)\n      \
    \          }\n            }\n            rollingMax.get\n        }", "       \
    \ var current = List[Long]()\n        var max = 0l\n        numbers.foreach {n\
    \ =>\n            var newMax = math.max(max, n)\n            current = current\
    \ :+ newMax\n            max = newMax\n        }\n        current", "        var\
    \ max = 0L\n        var rollMax = 0L\n        var rollMaxIndex = 0L\n        var\
    \ rollMaxIndexList = List[Long]()\n        var maxIndex = 0L\n\n        numbers.foreach\
    \ { number =>\n            if (number > max) {\n                max = number\n\
    \                maxIndex = number\n                rollMaxIndexList.clear()\n\
    \                rollMaxIndexList.push(number)\n                rollMaxIndex =\
    \ 0L\n            } else if (number == max) {\n                rollMaxIndexList.push(number)\n\
    \                rollMaxIndex += 1\n                rollMaxIndexList.push(number)\n\
    \            } else {\n                if (rollMaxIndexList.contains(maxIndex\
    \ - rollMax)) {\n                    rollMaxIndexList.clear()\n              \
    \      rollMaxIndexList.push(maxIndex)\n                    rollMaxIndex += 1\n\
    \                    rollMaxIndexList.push(maxIndex)\n                }\n    \
    \        }\n        }\n        rollMaxIndexList.toList", "        val currentMax\
    \ = numbers.reduceLeftOption(_ > _).getOrElse(-1L)\n        numbers.reverse.map\
    \ { n =>\n            if (n < currentMax) {\n                currentMax = n\n\
    \                n\n            } else {\n                currentMax\n       \
    \     }\n        }", "        val l = numbers.asInstanceOf[mutable.WrappedArray[Long]]\n\
    \        val maxIndexes = mutable.ListBuffer[Int]()\n\n        def rollingMaxHelper(i\
    \ : Int) : List[Long] = {\n            if (i >= l.length) {\n                maxIndexes\
    \ += i\n                return l\n            }\n            val current = l(i)\n\
    \            val index = i\n            val leftIndexes = maxIndexes ++ List(index\
    \ - 1)\n\n            val leftMaxs = rollingMaxHelper(index)\n            val\
    \ rightMaxs = rollingMaxHelper(index + 1)\n            val leftMax = leftMaxs.max\n\
    \            val rightMax = rightMaxs.max\n\n            val leftGreaterThanRight\
    \ = current > rightMax\n            if (leftGreaterThanRight) leftMaxs else rightMaxs\n\
    \        }\n\n        rollingMaxHelper(0)", "        var max = -math.inf\n   \
    \     for(i <- numbers) {\n            if (max < i) max = i\n        }\n     \
    \   numbers.foldLeft(List[Long]())((l, number) => l.head == number ? l :+ number)",
  "        val maxs = mutable.ListBuffer.empty[Long]\n        numbers foreach { x\
    \ =>\n            while (true) {\n                x match {\n                \
    \    case 3 => maxs += x.toLong\n                    case 2 => maxs += x.toLong\n\
    \                    case 1 => maxs += x.toLong\n                    case 0 =>\
    \ break\n                    case _ => x -= 1\n                }\n           \
    \ }\n        }\n        maxs.toList", "        if (numbers.length == 0) List(1l.toLong)\n\
    \        else {\n            val maxIndex = numbers.length - 1\n            val\
    \ maxValue = numbers.last\n            var currentMax = maxValue\n           \
    \ var currentIndex = 0\n            val result = new mutable.ArrayBuffer(maxValue)\n\
    \            var i = 0\n            for (i <- numbers.indices){\n            \
    \    if (i < maxIndex) {\n                    currentMax = numbers(i)\n      \
    \              currentIndex = i\n                }\n                if (currentMax\
    \ < maxValue) {\n                    result.synchronized {\n                 \
    \       result += currentMax\n                        currentMax = numbers(currentIndex)\n\
    \                    }\n                    currentIndex = currentIndex + 1\n\
    \                }\n            }\n            result.synchronized {\n       \
    \         result += currentMax\n            }\n            result.toList\n   \
    \     }", "        var currentMax = 0\n        var maxIndex = 0\n        var maxRolling\
    \ = List[Long]()\n        for (i <- 0 until numbers.length) {\n            if\
    \ (maxIndex < i) {\n                currentMax = numbers(i)\n                maxIndex\
    \ = 0\n            } else {\n                if (currentMax > numbers(i)) {\n\
    \                    maxIndex = i + 1\n                    maxRolling = (numbers(maxIndex)\
    \ :: maxRolling)\n                    currentMax = numbers(i)\n              \
    \  } else {\n                    maxIndex = i\n                }\n           \
    \ }\n        }\n        maxRolling", "        numbers.foldLeft(List[Long]())(\n\
    \            (l: List[Long], n: Long) => {\n                if (l.length < 5)\
    \ {\n                    l.updated(l.length, n)\n                } else {\n  \
    \                  val l2 = l.drop(l.length - 1).drop(1)\n                   \
    \ l2.max(n) :: l\n                }\n            })", "        var max: Long =\
    \ numbers(0)\n        var result: List[Long] = List()\n\n        numbers match\
    \ {\n            case x :: tail =>\n                x.toLong match {\n       \
    \             case max: Long =>\n                        result = x :: result\n\
    \                    case max =>\n                        max = x\n          \
    \      }\n\n                rollingMax(tail) match {\n                    case\
    \ x :: tail =>\n                        max == x.toLong match {\n            \
    \                case true =>\n                                result = x :: result\n\
    \                            case false =>\n                                rollingMax(tail)\n\
    \                        }\n                    case _ =>\n                  \
    \      result\n                }\n            case Nil =>\n                result\n\
    \        }", "        numbers.toList.tail.reverse.foldLeft(List[Long]())((max,\
    \ element) => {\n            val last = max.last\n            val currMax = last\
    \ match {\n                case None =>\n                    element\n       \
    \         case _ =>\n                    if (element > last) element else last\n\
    \            }\n            val newMax = currMax :: max\n            newMax\n\
    \        })", "        var res = ListBuffer[Long]()\n        var max = 0L\n  \
    \      numbers.foreach{ n =>\n            if(n <= max) {\n                max\
    \ = n\n                res = res :+ max\n            }\n        }\n        return\
    \ res", "        val rollingMaxList = mutable.ListBuffer[Long]()\n        for\
    \ (i <- 0 until numbers.length) {\n            val current = numbers(i)\n    \
    \        rollingMaxList += current\n            for (j <- 0 until rollingMaxList.length)\
    \ {\n                if (current > rollingMaxList(j)) {\n                    rollingMaxList(j)\
    \ = current\n                }\n            }\n        }\n        rollingMaxList.take(numbers.length)",
  "        val max: mutable.Map[Int, Long] = new mutable.HashMap[Int, Long]\n    \
    \    var maxIndex = -1L\n        numbers.foreach { n =>\n            if (max.containsKey(n))\
    \ {\n                max.put(maxIndex, n)\n            } else {\n            \
    \    if (maxIndex != -1) {\n                    maxIndex += 1\n              \
    \      max.put(maxIndex, numbers.last)\n                }\n                maxIndex\
    \ = -1L\n            }\n        }\n        if (maxIndex != -1L) {\n          \
    \  maxIndex += 1\n            max.put(maxIndex, numbers.last)\n        }\n   \
    \     max.toList.sortBy(_._2).reverse", "        val m = numbers.head\n      \
    \  var current = numbers.tail.max\n        numbers match {\n            case head\
    \ :: tail => {\n                val max = tail.max\n                if (current\
    \ < max) head :: rollingMax(tail)\n                else rollingMax(tail)\n   \
    \         }\n            case _ => List(current)\n        }", "        val result\
    \ = new mutable.ListBuffer[Long]()\n        numbers.foreach { number =>\n    \
    \        number match {\n                case x if x >= result.last.max => result.last\
    \ :+ x\n                case x => result :+ x\n            }\n        }\n    \
    \    result.toList", "        val max = numbers(0)\n        val max_max_so_far\
    \ = numbers.tail.foldLeft(0l){ (a,b) => if (a > b) a else b}\n        val max_in_tail\
    \ = numbers.tail.foldLeft(0l){ (a,b) => if (a > b) a else b}\n        val min_max_so_far\
    \ = numbers.head.foldLeft(0l){ (a,b) => if (a > b) a else b}\n        val min_max_in_head\
    \ = numbers.head.foldLeft(0l){ (a,b) => if (a > b) a else b}\n\n        numbers.drop(1).sliding(2).collect\
    \ {\n            x => if (x == max_max_so_far) max_in_tail else if (x == max_max_so_far\
    \ - max_in_tail) max else if (x == max_max_so_far - min_max_so_far) max_in_tail\
    \ else if (x == max_max_so_far - min_max_so_far - max_in_tail) max else min_max_in_head\n\
    \        }.toList", "        val nums = numbers.toList\n        val result = mutable.ArrayBuffer.empty[Long]\n\
    \        val window = nums.head\n        nums.reverse.tail.foreach(num => {\n\
    \            var maxNum = num\n            while (num > window) {\n          \
    \      maxNum = num - maxNum\n            }\n            val value = result.length\n\
    \            if (value > 0 && result(value-1) > maxNum) {\n                result.update(value-1,\
    \ maxNum)\n            }\n        })\n        result.reverse", "        val ret\
    \ = new mutable.ListBuffer[Long]()\n        for (i <- numbers) {\n           \
    \ val lastRet = ret.toList.reverse.tail.last\n            val next = i + lastRet\n\
    \            if (next > numbers(0))\n                ret.append(next)\n      \
    \  }\n        return ret.toList.reverse", "        if (numbers.isEmpty) return\
    \ List()\n        numbers.reverse.foldLeft(numbers.reverse.maxBy(_.toLong).asInstanceOf[Long])((max,\
    \ x) =>\n            if (x <= max) x else max)", "        // Create a mutable\
    \ list to hold rolling max\n        var maxRolling : mutable.Buffer[Long] = mutable.Buffer.empty\n\
    \n        // Start with largest element in the list\n        var largestNum =\
    \ numbers(0)\n        // Keep iterating the numbers and find the rolling max\n\
    \        for (i <- 1 to numbers.size)\n        {\n            // If the current\
    \ number is the largest so far, then add to list\n            if (numbers(i) >\
    \ largestNum)\n            {\n                maxRolling = maxRolling.+(largestNum)\n\
    \                largestNum = numbers(i)\n            }\n        }\n\n       \
    \ // Return the max rolling number list\n        maxRolling.toList", "       \
    \ val buffer = new mutable.ListBuffer[Long]()\n        numbers.foreach( x => {\
    \ if (x < buffer.last) buffer :+= x else buffer.lastOption match {\n         \
    \   case Some(x) => buffer :+= x\n            case None => buffer.last }})\n \
    \       buffer.reverse.foldLeft(List[Long]())( (a,b) => b:: a).reverse", "   \
    \     // Rolling maximum starts at zero (0)\n        val maxes = new mutable.ListBuffer[Long]()\n\
    \        var max = 0\n\n        // Rolling maximum found\n        for (number\
    \ <- numbers) {\n            if (number > max) {\n                max = number\n\
    \                maxes += number\n            } else if (number == max) {\n  \
    \              maxes += number\n            }\n        }\n\n        // Rolling\
    \ maximum found\n        val result = maxes.toList\n        if (maxes.size ==\
    \ 1)\n            result\n        else\n            rollingMax(result)", "   \
    \     def generateMax(x: Int, numbers: List[Long], result: List[Long]): List[Long]\
    \ = {\n            if (x == numbers.size) {\n                result:::numbers.reverse\n\
    \            } else {\n                generateMax(x+1, numbers, generateMax(x,\
    \ numbers, result))\n            }\n        }\n        generateMax(0, numbers,\
    \ Nil)", "        val result = new mutable.ArrayBuffer[Long]()\n        var max\
    \ = 0L\n        var temp = 0L\n        for (i <- 0 until numbers.size - 1) {\n\
    \            temp = 0L\n            max = numbers(i)\n            if (temp > max)\n\
    \                max = temp\n            result += max :: Nil\n        }\n   \
    \     result.reverse", "        val listMax = numbers.foldLeft(List[Long]()) ((l,\
    \ v) => v :: l)\n        val maxIndex = listMax.length\n        val result: List[Long]\
    \ = new mutable.MutableList[Long]()\n        for (i <- 0 until maxIndex) {\n \
    \           val index = i \n            val sum = numbers(index).foldLeft(0l)\
    \ { \n                case (v, acc) => acc + v \n            }\n            result\
    \ += (sum / numbers(index))\n        }\n        result.toList", "        numbers.foldLeft((List[Long](),\
    \ numbers.head)) {\n            case ((current, max), i) =>\n                val\
    \ newMax = max max i\n                val newCurrent = (current :+ i, newMax)\n\
    \                (newCurrent, newMax)\n        }._1.reverse", "        def rollingMaxRecursively(numbers:\
    \ List[Long], i: Int, j : Int, result : List[Long]): List[Long] = {\n        \
    \    if (i >= j)\n                result\n            else\n                rollingMaxRecursively(numbers,\
    \ i + 1, j, result :+ max(numbers(i), numbers(i + 1)))\n        }\n\n        val\
    \ n = numbers.size\n        rollingMaxRecursively(numbers, 0, 0, List.empty[Long])",
  "        var current = List[Long](numbers(0))\n        var max = [Long](numbers(0),\
    \ numbers(0), numbers(0))\n        // Roll until maximum value is found\n    \
    \    for(i <- 1 until numbers.size)\n            for(j \u2190 0 until 3) {\n \
    \               if(j == 0)\n                    current = numbers(i)\n       \
    \         else {\n                    val newMax = current((j-1).toInt) + (current((j).toInt)-current((j-1).toInt))\n\
    \                    if(newMax > max(0))\n                        max = (max(0),\
    \ max(1), max(2))\n                    current = newMax\n                }\n \
    \           }\n        numbers.size\n            match max {\n               \
    \ case x :: y :: z :: _ => x :: y :: z :: rollingMax(numbers.filter(_ != x))\n\
    \                case x :: y :: _ => x :: rollingMax(numbers.filter(_ != x))\n\
    \                case x :: _ => x\n            }", "        var ret: List[Long]\
    \ = Nil\n        val mum = numbers.foldRight(0l) { (m: Long, i: Long) => if (m\
    \ < i) m else i }\n        var k = 0\n        for (i <- numbers) {\n         \
    \   while ( k < i && mum == numbers(k)) {\n                k += 1\n          \
    \  }\n            if ( k == i) ret::= mum\n            else ret::= mum\n     \
    \       mum = i\n            k += 1\n        }\n        ret.reverse", "      \
    \  val numberSet = numbers.toSet\n        if (numberSet.isEmpty) {\n         \
    \   List()\n        }\n        else {\n            var max_val : Long = numbers.head\n\
    \            val numbers = numbers.tail\n            var maxList = List()\n  \
    \          var currentList = List()\n            numbers.foreach { number =>\n\
    \                if (number > max_val) {\n                    max_val = number\n\
    \                }\n                else {\n                    currentList +=\
    \ max_val\n                    max_val = number\n                }\n         \
    \   }\n            currentList += max_val\n            maxList += currentList.toList\n\
    \            maxList\n        }", "        val max = numbers.head\n        val\
    \ index = numbers.indexOf(0)\n        numbers.dropWhile(_ < max).map { x =>\n\
    \            if (x > max) {\n                max = x\n                index\n\
    \            } else {\n                numbers.updated(index, x)\n           \
    \ }\n        }", "        val max_rolling = 0\n        val rolling_max = scala.collection.mutable.ListBuffer.empty[Long]\n\
    \        numbers.foreach(num => \n            if (rolling_max.length < max_rolling\
    \ + num) \n                rolling_max += num\n            else if (rolling_max\
    \ exists (_ == num))\n                max_rolling = rolling_max.length\n     \
    \   )\n        rolling_max.toList", "        val maxRollingWindow = new scala.collection.mutable.ListBuffer[Long]()\n\
    \        var sum = 0l\n        var max = 0L\n        for(i <- numbers)\n     \
    \   {\n            sum += i\n            if(sum > max)\n            {\n      \
    \          maxRollingWindow.clear()\n                maxRollingWindow.append(sum)\n\
    \            }\n            else if(sum < max)\n            {\n              \
    \  maxRollingWindow.append(sum)\n            }\n        }\n        if(maxRollingWindow.length\
    \ == 0)\n        {\n            List()\n        }\n        else\n        {\n \
    \           maxRollingWindow.reverse\n        }", "        if (numbers.isEmpty)\
    \ numbers\n        else {\n            val list = numbers.head :: numbers.tail\n\
    \            val rollingMax = list.reduce({\n                case (a, b) if a.isDefined\
    \ => a.get\n                case (a, b) if b.isDefined => b.get\n            \
    \    case (a, b) => b\n            })\n            rollingMax :: rollingMax(list.drop(1))\n\
    \        }", "        val newNumbers = numbers.reverse.tail.takeWhile(max => {\n\
    \                val lastMax = numbers.reverse.tail.last\n                numbers.reverse.tail.indexWhere(x\
    \ => x > max) === numbers.reverse.tail.size\n        }.reverse.tail.map(i => numbers.reverse.tail.drop(i).max).getOrElse(numbers.reverse.tail.max))\n\
    \        rollingMaxHelper(newNumbers, 0)", "        val maxList : mutable.MutableList[Long]\
    \ = mutable.MutableList[Long]()\n        var maxVal = numbers.head\n        var\
    \ current = 0\n        var currentIndex = 0\n        while(current < numbers.size)\
    \ {\n            if(numbers.exists(x => x == maxVal)) {\n                maxList\
    \ += maxVal\n                maxVal += numbers.drop(currentIndex).head\n     \
    \           currentIndex++\n            } else if(numbers.exists(x => x == maxVal))\
    \ {\n                maxVal += numbers.drop(currentIndex).head\n             \
    \   currentIndex++\n            } else {\n                maxVal += numbers.drop(currentIndex).head\n\
    \                currentIndex++\n            }\n            current++\n      \
    \  }\n        return maxList", "        val rolling = mutable.ListBuffer.empty[Long]\n\
    \        var rollingMax = numbers(0)\n        for (i<-0 to numbers.length-1) {\n\
    \            if (i == numbers.length - 1) {\n                rolling += rollingMax\n\
    \            } else if (numbers(i) < rollingMax) {\n                rollingMax\
    \ += numbers(i + 1)\n            } else {\n                rollingMax -= numbers(i\
    \ + 1)\n                rolling += rollingMax\n            }\n        }\n    \
    \    rolling", "        val maxElement = numbers.head - 1\n        val result\
    \ = List.newBuilder[Long]\n        var index = 1\n        while (index < numbers.length)\
    \ {\n            val currElement = numbers(index)\n            if (currElement\
    \ > maxElement) {\n                if (result == null) result.addLast(maxElement)\n\
    \                else result.addAll(maxElement.toString.split('').map(Long.parseLong(_)).asInstanceOf[List[Long]])\n\
    \            }\n            result.addLast(currElement)\n            index +=\
    \ 1\n        }\n        result.result()", "        def getMin(x : Int) : Int =\
    \ {\n            if(x > 0) {\n                getMin(x - 1)\n            } else\
    \ {\n                if(x == 0) 1\n                else 0\n            }\n   \
    \     }\n\n        val minIndex = new Int()\n        val maxIndex = new Int()\n\
    \        val max = Int.MinValue\n        val maxSize = 0\n        var counter\
    \ = 0\n        var currentMax = 0\n        var currentMaxIndex = 0\n        val\
    \ arr = numbers.toArray\n        for(i <- 0 until arr.length)\n        {\n   \
    \         if(arr(i) < min)\n            {\n                min = arr(i)\n    \
    \            minIndex = counter\n            }\n            if(arr(i) > max)\n\
    \            {\n                max = arr(i)\n                maxIndex = counter\n\
    \            }\n            if(arr(i) == max)\n            {\n               \
    \ currentMax = arr(i)\n                currentMaxIndex = counter\n           \
    \ }\n            counter += 1\n        }\n        var rollingMax: List[Long] =\
    \ List()\n        for(i <- 0 until arr.length)\n        {\n            if(minIndex\
    \ == currentMaxIndex)\n            {\n                if(arr(i) > currentMax)\n\
    \                {\n                    currentMax = arr(i)\n                \
    \    rollingMax = List()\n                    rollingMax = List((arr.indexOf(i),\
    \ currentMax))\n                }\n                else\n                {\n \
    \                   rollingMax = List((arr.indexOf(i), currentMax))\n        \
    \        }\n            }\n            else\n            {\n                if(arr(i)\
    \ > currentMax)\n                {\n                    currentMax = arr(i)\n\
    \                    rollingMax = List()\n                    rollingMax = List((arr.indexOf(i),\
    \ currentMax))\n                }\n                else\n                {\n \
    \                   rollingMax = rollingMax.takeRight(rollingMax.length)\n   \
    \                 rollingMax += List((arr.indexOf(i), currentMax))\n         \
    \       }\n            }\n        }\n        return rollingMax", "        val\
    \ index = new mutable.ListBuffer[Long]()\n        var max = 0L\n        var sum\
    \ = 0L\n        numbers.foreach{n => {\n            sum += n\n            if(sum\
    \ > max) {\n                max = sum\n            }\n            index += 1\n\
    \            sum = 0L\n        }}\n        index ++ List(max)", "        val res\
    \ = []\n\n        // rolling max with 1 element as we start from the beginning\n\
    \        for (i <- 0 until numbers.size)\n            res = res.append(numbers.drop(i).max)\n\
    \n        res", "        val maxes = new collection.mutable.HashSet[Long]()\n\
    \        var max = 0L\n        var index = 0\n        while(index < numbers.size\
    \ && numbers.size > 0) {\n            val current = numbers(index)\n         \
    \   if(maxes.contains(current)) {\n                max = current\n           \
    \ }\n            else {\n                maxes.add(current)\n                max\
    \ = Math.max(max, current)\n                index++\n            }\n        }\n\
    \        numbers.take(index).toList", "        // Use a mutable list to store\
    \ the result\n        val maxResult = mutable.ListBuffer[Long]()\n        // A\
    \ list to store all rolling maximum\n        val allMax = mutable.ListBuffer[Long]()\n\
    \        // Loop the list until we reached a moment where the rolling max number\
    \ is no larger than the actual number in list\n        var index = 0\n       \
    \ for (number <- numbers) {\n            val rollingMaxNumber = number + index\n\
    \            // If we found a rolling maximum number larger than the current max\
    \ number, then add the current max number\n            if (rollingMaxNumber >\
    \ maxResult.last)\n                maxResult += maxResult.last\n            index\
    \ += 1\n            // Add the current rolling max number to the all rolling max\
    \ list\n            allMax += rollingMaxNumber\n        }\n        // Return the\
    \ max result\n        maxResult.toList", "        val result = new mutable.ArrayBuffer(numbers)\n\
    \        val max = numbers(0)\n        val maxElement = numbers(0)\n        for\
    \ (i<-1 to numbers.size-1) {\n            if (result(i) > max) {\n           \
    \     max = result(i)\n                maxElement = result(i)\n            } else\
    \ if (result(i) == max) {\n                maxElement = max(result(i), maxElement)\n\
    \            }\n            result(i) = max\n        }\n        result", "   \
    \     val result = numbers.foldLeft(List[Long]()) {\n            (acc, value)\
    \ => {\n                val candidate = acc.lastOption.orElse(value)\n       \
    \         val currentRoll = candidate.rollingMax\n                if((currentRoll\
    \ == 0l) && (candidate.number > value)) {\n                    acc.reverse::[Long](value)\n\
    \                }\n                else acc\n            }\n        }\n     \
    \   result.last", "        var index = 0\n        var max = 0\n        var temp\
    \ : List[Long] = ListBuffer.empty\n        for (n <- numbers) {\n            if\
    \ (index >= n.toInt) {\n                if (n == max) {\n                    temp\
    \ = temp + (n - max)\n                    index -= (max - max).toInt\n       \
    \         } else {\n                    temp = temp + (max - n)\n            \
    \        index = n.toInt\n                }\n                max = n\n       \
    \     }\n        }\n        temp.toList", "        val maxElem = math.max(numbers)\n\
    \        val maxList = mutable.ListBuffer[Long]()\n        var rollingMax : List[Long]\
    \ = numbers\n        var i = 1\n        while ( i <= maxElem ) {\n           \
    \ var currentMax = rollingMax(i).toLong\n            while ( rollingMax.tail.isEmpty\
    \ || rollingMax.tail.head.toLong < currentMax ) {\n                rollingMax\
    \ :+= rollingMax.head\n            }\n            rollingMax :+= rollingMax.head\n\
    \            if ( rollingMax.last == maxElem ) {\n                maxList :+=\
    \ rollingMax.last\n            }\n            rollingMax :+= rollingMax.tail\n\
    \            i += 1\n        }\n        return maxList", "        val result =\
    \ new scala.collection.mutable.ArrayList[Long]\n        numbers.foreach(x => result.add(x))\
    \ // add all elements to list\n        val maxValue = max(result.toList)\n   \
    \     result.toList.map(x => if (x == maxValue) x else x + 1) // get all possible\
    \ rolling maximum elements from list", "        // Initialize max list\n     \
    \   var maxList = List[Long]()\n\n        // Go through all the elements until\
    \ the current moment\n        for (number <- numbers) {\n            // If the\
    \ current number is greater than the maximum found so far,\n            // update\
    \ max with the current element\n            if (number > maxList.getOrElse(-1l)\
    \ {\n                maxList :+= number\n            }\n        }\n\n        //\
    \ Return the resulting list\n        return maxList", "        val results = new\
    \ mutable.MutableList[Long]()\n        for (x<-numbers)\n        results ::= math.max(x-results.last,\
    \ results.last)\n        \n        results", "        var maximums = scala.collection.mutable.LinkedHashMap[Long,\
    \ Int]()\n        var maximum = numbers(0)\n\n        for (number <- numbers)\
    \ {\n            if (maximums.contains(maximum)) {\n                val prevMax\
    \ = maximums.last.get + 1\n                maximums.last.put(number, prevMax)\n\
    \                maximums.put((number - prevMax), prevMax)\n            } else\
    \ {\n                maximums.put(number, 0)\n            }\n\n            maximum\
    \ = max(number, maximum)\n        }\n\n        val keys = maximums.keys\n    \
    \    val values = maximums.values\n\n        // Return the maximum element of\
    \ each group\n        (keys zip values map (x => (x._1 - x._2, x._2)))", "   \
    \     val result: List[Long] = List();\n        numbers.foreach(x => {\n     \
    \       val max = results.last\n            if (max > x)\n                result.add(x)\n\
    \            else {\n                if (result.last > x)\n                  \
    \  result.last = x\n            }\n        })\n        result", "        def lastMax(n:\
    \ Long): Long = {\n            if(numbers.length <= n){\n                return\
    \ numbers(n)\n            } else {\n                return if(numbers(n) > numbers(n-1))\
    \ numbers(n) else numbers(n-1)\n            }\n        }\n        def min(n1:\
    \ Long, n2: Long) : Long = {\n            if(n1 > n2){\n                n1\n \
    \           } else {\n                n2\n            }\n        }\n        def\
    \ max(n1: Long, n2: Long) : Long = {\n            if(n1 > n2){\n             \
    \   n2\n            } else {\n                n1\n            }\n        }\n \
    \       val maxNums = ListBuffer[Long]()\n        numbers.foldLeft(maxNums){\n\
    \            (maxNums, number) => {\n                val newMax = lastMax(number)\n\
    \                val newMin = lastMax(number - 1)\n                val newMaxs\
    \ = if(newMax > newMin) newMax, newMin else newMin, newMax\n                maxNums\
    \ ++= newMaxs\n            }\n        }\n        return maxNums", "        numbers.foldLeft((List[Long](0l.toLong),\
    \ 0)) {\n            (acc, n) =>\n                val max = acc._1\n         \
    \       val current = acc._2\n                if (n <= current) (n, max) else\
    \ (max, n)\n        }._1.reverse", "        numbers.foldLeft((numbers.head,List[Long]()))\
    \ {\n            case ((max, rolling),i) => (if (i > numbers.length) max else\
    \ rolling.max,i.toLong::rolling)\n        }._2", "        var maxList : List[Long]\
    \ = Nil\n        var maxValue : Long = 0\n        var currentMax = 0\n\n     \
    \   // Sort the list to find the rolling max element\n        numbers.sortWith(_.compare(_.toLong))\
    \ // Sorting in ascending order\n\n        // Find the rolling max element\n \
    \       for (number <- numbers) {\n            if (maxValue < number) {\n    \
    \            maxValue = number\n                maxList = numbers :: Nil\n   \
    \             currentMax = number\n            }\n            else {\n       \
    \         if (currentMax == number) {\n                    maxList = maxList :+\
    \ number\n                }\n                else {\n                    maxList\
    \ = maxList :+ currentMax\n                    currentMax = number\n         \
    \       }\n            }\n        }\n        return maxList", "        require(numbers.nonEmpty,\
    \ \"rollingMax: Empty list provided\");\n        val maxRollings = numbers.length\n\
    \        val maxIndex = 0\n        // The first rolling is the maximum of the\
    \ whole list\n        val max = numbers.head\n        // The rest rollings is\
    \ the maximum of the part after the current rolling list\n        val rest = numbers.tail.takeWhile{\
    \ _ != max }\n        // Starting from the second rolling, compare the highest\
    \ rolling with the current one and update the rolling index\n        // when the\
    \ rolling index is equal to the maximum rolling index\n        val rollingIndex\
    \ = 1\n        rest.foreach{ n => if (n == max) {\n                          \
    \  max <- max\n                            maxIndex <- maxRollings\n         \
    \               } else {\n                            maxIndex <- rollingIndex\n\
    \                        } }\n        if (maxRollings == rollingIndex) {\n   \
    \         List(max)\n        } else {\n            rollingMax rest\n        }",
  "        // Start with empty rolling max\n        var maxList : List[Long] = Nil\n\
    \n        // Iterate over the given numbers, for each iteration find the max of\
    \ the rolling max and the given number\n        for (i <- numbers) {\n       \
    \     var max = 0\n            val rollingMax: List[Long] = maxList\n\n      \
    \      // For each element find the max of the previous max and the given number\
    \ i\n            var j = 1\n            while (rollingMax.head <= j && rollingMax.head\
    \ < i) {\n                max = math.max(max, rollingMax.head)\n             \
    \   rollingMax = rollingMax :: numbers(i to j)\n                j += 1 // Increment\
    \ the iteration index\n            }\n\n            // If the maximum element\
    \ found until moment j is greater than current maximum add it to the rolling max\n\
    \            if (max > numbers(i to j)) {\n                maxList ::= numbers(i\
    \ to j)\n            }\n        }\n\n        // Return the rolling max list\n\
    \        return maxList", "        def rollingMaxRec(list: List[Long], max: Long,\
    \ acc: List[Long]): List[Long] = {\n            if (list.isEmpty)\n          \
    \      return  acc\n            rollingMaxRec(list.tail, list.head, list match\
    \ {\n                case Nil =>  acc.reverse\n                case _ => rollingMaxRec(list.tail,\
    \ max, acc :+ max)\n            })\n        }\n        rollingMaxRec(numbers.reverse,\
    \ numbers.head) match {\n            case Nil => Nil\n            case _ => numbers.reverse\n\
    \        }", "        val currentMax = numbers.head\n        val nextMax = numbers.last\n\
    \        val nextMaxToCheck = currentMax + 1\n        val nextMaxList = new mutable.LinkedList[Long]()\n\
    \        nextMaxList += currentMax\n        while (nextMaxToCheck < numbers.last)\
    \ {\n            nextMaxList += nextMax\n            nextMaxToCheck += currentMax\
    \ + 1\n        }\n        nextMaxList.reverse", "        val rollingMax = new\
    \ mutable.LinkedList[Long]()\n        var currentMax = 0L\n        var i = 0\n\
    \        while(i < numbers.size) {\n            currentMax = Math.max(currentMax,\
    \ numbers(i))\n            i += 1\n            if(rollingMax.size < i)\n     \
    \           rollingMax.add(numbers(i))\n            if(currentMax == numbers(i))\
    \ {\n                i += 1\n                currentMax = numbers(i)\n       \
    \         while(i < numbers.size) {\n                    if(currentMax == numbers(i))\
    \ {\n                        i += 1\n                        currentMax = numbers(i)\n\
    \                        rollingMax.add(currentMax)\n                    } else\
    \ {\n                        currentMax = numbers(i)\n                       \
    \ rollingMax.add(currentMax)\n                        break\n                \
    \    }\n                }\n            }\n        }\n        return rollingMax.toList",
  "        numbers.foldLeft(List[Long]()){ (acc: List[Long], x: Long) => acc match\
    \ {\n            case Nil =>\n                acc.append(x)\n            case\
    \ _ => if (acc.last > x) acc else acc :+ x\n        }}.reverse", "        val\
    \ max = new mutable.HashMap[Long, Long]()\n        numbers.foreach{n => max +=\
    \ n -> math.max(n)}\n        max match {\n            case Nil => Nil\n      \
    \      case m :: Nil => m\n            case m :: tl =>\n                val tl_max\
    \ = rollingMax(tl)\n                m._2 match {\n                    case n if\
    \ n > tl_max(m._1) => m :: tl_max\n                    case n if n < tl_max(m._1)\
    \ => m :: Nil\n                    case n => m :: tl_max\n                }\n\
    \        }", "        if (numbers.isEmpty) List(1l)\n        else {\n        \
    \    val maxList = numbers.maxBy { number =>\n                val index = number\
    \ % numbers.size\n                number - numbers(index)\n            }\n   \
    \         rollingMax(maxList :: numbers)\n        }", "        val nums = numbers.toList\n\
    \        val len = nums.size\n        var max = 0l\n        var rollingMax = nums.toList.tail.foldLeft(0l)(\
    \ (a,b) => if (b > a) b else a )\n        var rollingMaxIndex = 0\n        for\
    \ ( i <- 1 to len-1 ) {\n            rollingMaxIndex = i\n            val prev\
    \ = nums(i - 1)\n            val current = nums(i)\n            if ( current >\
    \ max ) {\n                max = current\n                rollingMax = nums.toList.tail.foldLeft(0l)(\
    \ (a,b) => if (b > a) b else a )\n            }\n            else if ( current\
    \ == max ) {\n                rollingMax = nums.toList.tail.foldLeft(0l)( (a,b)\
    \ => if (b > a) b else a )\n            }\n            else if ( current < max\
    \ ) {\n                rollingMax = nums.toList.tail.foldLeft(0l)( (a,b) => if\
    \ (b > a) a else b )\n                max = current\n                rollingMaxIndex\
    \ = i\n            }\n        }\n        return rollingMax", "        require(numbers\
    \ != null)\n        val rollingMaxElem = mutable.Stack.empty[Long]\n        val\
    \ maxVal = numbers(0)\n        for (x <- numbers) {\n            if (x < maxVal)\
    \ {\n                rollingMaxElem += x\n            } else {\n             \
    \   rollingMaxElem.pop\n                rollingMaxElem += x\n            }\n \
    \           maxVal = rollingMaxElem.last\n        }\n        rollingMaxElem",
  "        // We will keep a map of rolling max element so far.\n        // We will\
    \ also keep a rolling max index so that we can remove the element when the moment\
    \ is reached.\n        val maxes = new mutable.HashMap[Long, Long]\n        val\
    \ rollingMaxIndex = new mutable.ArrayBuffer[Long]()\n        var currentMax =\
    \ -1l\n\n        // Start looping through the numbers from the end of the list\
    \ up to the beginning.\n        numbers.reverse.foreach{\n            // If the\
    \ current number is greater than the rolling max we just found then update it.\n\
    \            if(currentMax < _) maxes += (_ -> currentMax)\n            // Otherwise\
    \ if the current number is greater than the rolling max in the map of rolling\
    \ max elements\n            // then we will update it with the current max and\
    \ add the current index to the list of rolling max indices.\n            else\
    \ if(!maxes.contains(_)) maxes += (_ -> currentMax)\n            // Otherwise\
    \ the numbers are equal, thus we will add the index of the current max to the\
    \ list of rolling max indices.\n            else {\n                maxes += (_\
    \ -> currentMax)\n                rollingMaxIndex += currentMax\n            }\n\
    \            currentMax = maxes.values.max\n        }\n\n        // Remove the\
    \ rolling max index at the end as it is no longer needed.\n        rollingMaxIndex.removeAll(_\
    \ == currentMax)\n\n        // Return the list of rolling max elements.\n    \
    \    maxes.toList.sortBy(_._2)", "        numbers.reverse.foldLeft(List[Long]())((list,\
    \ number) => {\n            if (numbers.length == list.length) list :+ number\n\
    \            else {\n                if (number > list.last) list :+ number\n\
    \                else {\n                    list :+ list.last\n             \
    \   }\n            }\n        })", "        val max = numbers.foldLeft((-1l, 0l))\
    \ { (x, y) =>\n            if (y._1 < x._1) (y._1, y._2) else (x._1, x._2)\n \
    \       }\n        if (max._1 < 0) numbers else numbers.takeWhile(x => x._2 <\
    \ max._1).reverse", "        val maxIndex  = numbers.indexWhere(_.isMax)\n   \
    \     val rollingMax = new mutable.ListBuffer[Long]()\n        val currentMax\
    \ = numbers(maxIndex)\n        var i = 0\n        while(i < maxIndex) {\n    \
    \        rollingMax += numbers(i)\n            currentMax = numbers(i) if maxIndex\
    \ - i + 1 > rollingMax.size \n                || numbers(i) > rollingMax(rollingMax.size-1)\n\
    \            i += 1\n        }\n        rollingMax.reverse", "        val result\
    \ = mutable.ArrayBuffer.empty[Long]\n        val size = numbers.size\n       \
    \ def rollingMaxHelper(index: Int, numbers: List[Long], result: List[Long]): Unit\
    \ = {\n            if (index == size) {\n                result.addAll(numbers.sortBy(_._1).reverse)\n\
    \            } else {\n                for (i <- 0 until numbers.size - 1) {\n\
    \                    result(i) = if (numbers(i) <= numbers(index)) { numbers(index)\
    \ } else { numbers(i) }\n                    rollingMaxHelper(index + 1, numbers,\
    \ result)\n                }\n            }\n        }\n        rollingMaxHelper(0,\
    \ numbers, result)\n        result.result", "        if (numbers.isEmpty) return\
    \ List()\n        val maxRolling = numbers.tail.foldLeft[Long](numbers.head){\
    \ (acc,x) => if (acc > x) acc else x }\n        val rest = rollingMax(numbers.tail)\n\
    \        rest ::: List(maxRolling.toLong)", "        // Define a function to get\
    \ list of rolling max elements\n        // From a given list of integers, generate\
    \ a list of rolling maximum element found until given moment\n        // E.g.\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 2l.toLong))\n        // rollingMax(numbers) will return a List containing [1l.toLong,\
    \ 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong]\n        numbers.foldLeft(List[Long]()){\
    \ case (acc, number) => acc.zip(rollingMaxUntil(number:_*)) }", "        if (numbers.length\
    \ == 0) numbers.reverse\n        val max = numbers(0)\n        val rollingMax\
    \ = List[Long]()\n        for (i <- 1 to numbers.size) {\n            val current\
    \ = numbers(i)\n            if (current > max) {\n                max = current\n\
    \            }\n            else {\n                rollingMax += max\n      \
    \          max = current\n            }\n        }\n        rollingMax", "   \
    \     val r = mutable.ArrayBuffer.empty[Long]\n        numbers.foreach { number\
    \ =>\n            val rm = r.reverse.foldLeft(number) { case (rm, num) =>\n  \
    \              if (rm > num)\n                    rm\n                else\n \
    \                   num\n            }\n            r.append(rm)\n        }\n\
    \        r.foldRight(List[Long]())(_ > _)", "        var max = 0L\n        var\
    \ maxes = new mutable.ArrayList[Long]\n        for (number <- numbers) {\n   \
    \         max += number\n            maxes += number\n            if (max > number)\
    \ {\n                max = 0L\n                maxes = new mutable.ArrayList[Long]\n\
    \            }\n        }\n        maxes", "        var max = 0\n        numbers.reverse.foreach\
    \ { number =>\n            if(number > max) max = number\n        }\n        numbers\
    \ = numbers :+ max\n        numbers.reverse", "        def rollingMaxHelper(numbers\
    \ : List[Long], acc : List[Long]) : List[Long] = {\n            val maxNum = numbers.min\n\
    \            if (numbers.length == 1) acc :+ maxNum\n            else {\n    \
    \            val nextNum = numbers(0)\n                val index = numbers.indexOf(0)\n\
    \                val updatedNums = rollingMaxHelper(numbers.tail, acc :+ maxNum)\n\
    \                if (index < numbers.indexOf(0)) {\n                    updatedNums\n\
    \                } else {\n                    updatedNums :+ nextNum\n      \
    \          }\n            }\n        }\n        rollingMaxHelper(numbers, List(0l))",
  "        numbers.foldLeft(List.empty[Long]) { case (acc, x) => \n            if\
    \ (acc contains x) acc else acc ++ List(max(x,acc.last))\n        }", "      \
    \  var max = numbers(0)\n        var result : List[Long] = List()\n        for\
    \ (number <- numbers) {\n            if (number > max) {\n                max\
    \ += number\n                result ::= max\n            }\n            else {\n\
    \                result += number\n            }\n        }\n        return result",
  "        var max = numbers(0)\n        var maxCount = 1\n        var index = 0\n\
    \        var rollingMaxResult = new mutable.ArrayList[Long]\n        for(x <-\
    \ numbers){\n            if(x < max){ \n                rollingMaxResult.add(max)\n\
    \                rollingMaxResult.add(index)\n                maxCount = 1\n \
    \               max = x\n            }else{\n                maxCount+=1\n   \
    \             max = x\n            }\n            index += 1\n        }\n    \
    \    rollingMaxResult", "        val m = numbers.head\n        val rollingMax\
    \ = m :: rollingMax(numbers.tail)\n        rollingMax.max(numbers.last)", "  \
    \      val rollingMax = new mutable.MutableList[Long]()\n        val max = new\
    \ Long(0)\n        val maxSeq = Seq(numbers)\n        val rollingMaxSeq = rollingMax\
    \ ++= maxSeq\n        val sumRollingMax = rollingMaxSeq.sum\n        rollingMaxSeq.filter(i\
    \ => i > max).foreach(i => rollingMaxSeq.filter(_ != i).foreach(x => rollingMaxSeq.filter(_\
    \ != x).foreach(y => rollingMaxSeq.filter(_ != y)))) \n        rollingMaxSeq.filter(_\
    \ > sumRollingMax).foreach(x => rollingMaxSeq.filter(_ != x).foreach(y => rollingMaxSeq.filter(_\
    \ != y)))\n        rollingMax", "        // Keep track of the max found so far\n\
    \        var max = 0l\n        // Keep track of how many items are left of the\
    \ list \n        var left = 0L\n\n        // If the list is empty, just return\
    \ an empty list\n        if(numbers.isEmpty) Nil\n\n        // Loop through the\
    \ numbers until we reach the moment we wanted\n        numbers.takeWhile{number\
    \ => left > 0 || number > max}.\n            // Then find the max of the remaining\
    \ items\n            foldRight((max, left)){(max, left) => (number, left) =>\n\
    \                if(number > max) max = number\n                left -= 1\n  \
    \              (max, left)}\n", "        var maxIndex = 0\n        var max = 0L\n\
    \        var currentIndex = 0\n        var current = 0L\n        for(i <- 0 until\
    \ numbers.size) {\n            current = numbers(i)\n            if(i == maxIndex)\
    \ {\n                max = current\n            }\n            if(i == currentIndex)\
    \ {\n                max = max max > current ? max : current\n            }\n\
    \            if(i == numbers.size-1) {\n                maxIndex = i\n       \
    \         max = max\n            }\n        }\n        return maxIndex.toList.map(n\
    \ => n.toLong).reverse", "        val len = numbers.length\n        var max =\
    \ 0l\n        var rollingMax = 0l\n        var i = 0\n        while (i < len)\
    \ {\n            max = max(numbers(i), max)\n            if (max > rollingMax)\
    \ {\n                rollingMax = max\n            }\n            i += 1\n   \
    \     }\n        rollingMax.asInstanceOf[List[Long]]", "        val res = numbers.foldLeft(List[Long]())((l,cur)\
    \ => {\n            val max = l(0)\n            for (i <- 0 until l.size) {\n\
    \                if (cur <= l(i)) {\n                    max = l(i)\n        \
    \        }\n            }\n            l.updated(l.size, max)\n        })\n  \
    \      res.reverse", "        val max = numbers.last\n        val list = numbers.dropRight(numbers.last)\n\
    \        val result = new ListBuffer[Long]()\n        for (number <- list) {\n\
    \            if (number > max) {\n                result += (number -> max)\n\
    \            }\n        }\n        result.toList", "        val ret = new mutable.MutableList[Long]()\n\
    \        numbers.tail.foreach{ x =>\n            val maxIndex = ret.lastIndex\n\
    \            val maxValue = ret(maxIndex)\n            val newMax = if (x == maxValue)\
    \ x else x + 1\n            if (newMax > maxValue) {\n                ret.updated(maxIndex,\
    \ newMax)\n            }\n        }\n        return ret.toList", "        val\
    \ maxNumbersSoFar = mutable.LinkedHashMap[Long, Long]()\n        val rollingMax\
    \ = mutable.LinkedHashMap[Long, Long]()\n\n        for (i <- 0 to numbers.length-1)\
    \ {\n            val thisMax = maxNumbersSoFar.getOrElse(numbers(i), -1l)\n  \
    \          if (thisMax == -1l) {\n                maxNumbersSoFar.put(numbers(i),\
    \ numbers(i))\n                rollingMax.put(numbers(i), numbers(i))\n      \
    \      } else {\n                rollingMax.put(numbers(i), max(rollingMax.getOrElse(numbers(i),\
    \ -1l), numbers(i)))\n            }\n        }\n\n        maxNumbersSoFar.values",
  "        val result = mutable.MutableList[Long]()\n        numbers.foreach {\n \
    \           number =>\n                val maxNumber = rollingMaxHelper(result,\
    \ number).max\n                result.add((maxNumber, number))\n        }\n  \
    \      result.toList", "        val m = numbers.foldLeft(0l)(\n            (max,\
    \ num) => max max if num > max else num\n        )\n        val n = numbers.size\
    \ - 1\n        (m to n).map { index => numbers(index) }", "        val indexed\
    \ = numbers.zipWithIndex\n        val rollingMaxedIndex = mutable.ListBuffer[Long]()\n\
    \        while(indexed.hasNext) {\n            val value = indexed.next()._2._1.toLong\n\
    \            rollingMaxedIndex += value\n        }\n        rollingMaxedIndex.toList",
  "        if(numbers == null || numbers.size == 0) List()\n        val result = new\
    \ mutable.ListBuffer[Long]()\n        var nextMax = numbers.head\n        var\
    \ current = numbers.head\n        val lastElements = numbers.tail\n        for((index,\
    \ element) <- 0 until lastElements.size) {\n            if(element > nextMax)\
    \ {\n                result += List((current, nextMax))\n                nextMax\
    \ = element\n            } else if(element == nextMax) {\n                nextMax\
    \ += 1\n            }\n            current = element\n        }\n        if(nextMax\
    \ < numbers.last) result += List((current, nextMax))\n        result", "     \
    \   val maxSeq = List[Long]()\n        for (i <- numbers.iterator) maxSeq += i\n\
    \        var result = List[Long]()\n        for (i<- 1 to numbers.size) {\n  \
    \          val maxSeqI = maxSeq.takeWhile{ x => x <= numbers(i) }\n          \
    \  if (maxSeqI.size == 0) {\n                result += numbers(i)\n          \
    \  }\n            else if (maxSeqI.size == 1) {\n                result += numbers(i)\n\
    \            }\n            else {\n                result +=  maxSeqI.toList.max\n\
    \            }\n        }\n        result", "        var maximum = 0\n       \
    \ var sum = 0\n        var maxNums = List[Long]()\n        for( x <- numbers )\
    \ {\n            if(maximum < x) {\n                maximum = x\n            }\n\
    \            sum += x\n            if(sum == maximum) {\n                maxNums\
    \ = List(maximum)\n            } else {\n                maxNums = maxNums :+\
    \ maximum\n            }\n        }\n        return maxNums", "        val result\
    \ = new scala.collection.mutable.ListBuffer[Long]()\n        for (i<- 0 until\
    \ numbers.size) {\n            val rollingMax = numbers.slice(i+1, numbers.size)\n\
    \            val rollingMaxElement = rollingMax.max\n            result.append(rollingMaxElement)\n\
    \        }\n        return result.toList", "        if (numbers.isEmpty)\n   \
    \         numbers\n        else\n            if (numbers.last > numbers.head)\
    \ {\n                numbers :+ numbers.last\n                rollingMax(numbers.dropRight(numbers.last\
    \ + 1))\n            } else {\n                rollingMax(numbers.dropRight(numbers.head\
    \ + 1))\n            }", "        // First find the rolling maximum element found\n\
    \        var maxElement = numbers.head\n        numbers = numbers.tail\n     \
    \   var currentIndex = 0\n\n        for(number <- numbers) {\n            if(number\
    \ > maxElement) {\n                currentIndex = 0\n                maxElement\
    \ = number\n            } else {\n                currentIndex += 1\n        \
    \    }\n        }\n\n        // Then generate the sequence of rolling maximum\
    \ element found\n        var finalList = []\n        for(number <- numbers until\
    \ numbers.last){\n            finalList += number\n        }\n\n        finalList",
  "      val result = mutable.List.empty[Long]\n      def findMax(nums: List[Long],\
    \ currentIndex : Int, currentSum : Long, currentMax: Long): Unit = {\n       \
    \ if(nums.length <= currentIndex) {\n          result :+= currentMax\n       \
    \   return\n        }\n        val maxIndex = currentIndex\n        val maxSum\
    \ = currentSum + nums(maxIndex)\n        val maxNum = nums(maxIndex)\n       \
    \ if(maxSum > currentMax) {\n          currentMax = maxSum\n          currentSum\
    \ = maxNum\n        }\n        findMax(nums.drop(maxIndex), currentIndex + 1,\
    \ maxSum, currentMax)\n      }\n      findMax(numbers, 0, numbers.head, numbers.head)\n\
    \      result.toList", "        val max = numbers.head\n        val maxList =\
    \ numbers.tail\n        val result = mutable.ListBuffer.empty[Long]\n        //\
    \ Iterate through all element in the tail of maxList, if current is greater than\
    \ max, then update max with current element\n        maxList.foreach{ x =>\n \
    \           if(x>max) {\n                max = x\n            }\n        }\n \
    \       // Append current max to result\n        result += max\n        // Reverse\
    \ the result and return it.\n        result reverse ::: maxList", "        val\
    \ rollingMax = numbers.foldLeft((List[Long](numbers(0).asInstanceOf[Long]), 0))\
    \ {\n            case ((acc, value), number) => acc._1 + (number > acc._2 ? number\
    \ : acc._2)\n            case (acc, value) => acc -> value\n        }._1\n   \
    \     rollingMax.reverse", "        val list = numbers.toList.sortWith((a, b)\
    \ => math.min(a, b))\n        val result = new mutable.ListBuffer[Long]()\n  \
    \      for (i <- 0 until list.length) {\n            val x = list.take(i)\n  \
    \          val y = list.drop(i)\n            val z = (x ++ y ).foldLeft((0,0)){\n\
    \                ((x, y) , (i: Int) => math.max(x, y))\n            }\n      \
    \      result.append(z)\n        }\n        return result.toList.sortWith((a,\
    \ b) => math.min(a, b))", "        val max = numbers(0)\n        val rollingMax\
    \ = numbers.tail\n\n        for (i <- 0 until numbers.size) {\n            if\
    \ (rollingMax(i) > max) {\n                max = rollingMax(i)\n            }\n\
    \        }\n        rollingMax", "        val result: List[Long] = List()\n  \
    \      var maxNumber: Long = 0\n        var maxIndex: Long = -1\n        var currentNumber:\
    \ Long = 0\n        var currentIndex: Long = 0\n        for (currentNumber <-\
    \ numbers) {\n            if (maxIndex == -1) {\n                if (currentNumber\
    \ > maxNumber) {\n                    maxNumber = currentNumber\n            \
    \        maxIndex = currentIndex\n                }\n            } else {\n  \
    \              if (currentNumber > maxNumber) {\n                    maxIndex\
    \ = currentIndex\n                    maxNumber = currentNumber\n            \
    \    }\n            }\n            currentIndex += 1\n        }\n        result.add(maxIndex)\n\
    \        result", "        val max_so_far = numbers.last\n        val result:\
    \ List[Long] = numbers.sliding(numbers.size % numbers.size).foldLeft(List[Long](max_so_far))\
    \ {\n            (sum: List[Long], el: Long) => {\n                sum.lastOption\
    \ match {\n                    case None => sum.append(el)\n                 \
    \   case Some(curMax) =>\n                        if(curMax > el) list(sum.head\
    \ :: sum.tail)\n                        else list\n                }\n       \
    \     }\n        }\n        result", "        val rollingMax = mutable.ArrayBuffer.empty[Long]()\n\
    \        numbers.foreach { n =>\n            if (rollingMax.isEmpty) {\n     \
    \           rollingMax.clear()\n                rollingMax += n\n            \
    \    return\n            }\n            var max = 0\n            var index = 0\n\
    \            rollingMax.foreach((e, i) => {\n                if (i <= index) {\n\
    \                    return\n                }\n                if (e > max) {\n\
    \                    max = e\n                }\n            })\n            index\
    \ += 1\n            rollingMax += max\n        }\n        rollingMax.clear()\n\
    \        rollingMax += numbers(0)\n        return rollingMax", "        var currentMax\
    \ = -1l.toLong\n        var results: List[Long] = Nil\n        numbers.foreach{number\
    \ => currentMax = max(number, currentMax)}\n        results = numbers :+ currentMax\n\
    \        results.distinct", "        numbers.tail.foldLeft(numbers.head){ (max:\
    \ Long, element: Long) =>\n            if (element > max)\n                (element.toLong,\
    \ element)\n            else (max.toLong, max)\n        }.map(_._2)", '        if
    (numbers.isEmpty) List() else (numbers zip rollingMax(numbers.tail)).filter(_._2
    == numbers.head).map(_._1)', "        val maxCount = numbers.count(_.toLong >\
    \ 0)\n        if(maxCount == 0) List(numbers.head)\n        else {\n         \
    \   val rollingMaxes = List.fill(maxCount)(numbers.head)\n            val curMax\
    \ = numbers.head\n\n            var maxIndex = maxCount\n            var curIndex\
    \ = 0\n            for(i <- 1 to maxCount) {\n                rollingMaxes(i)\
    \ = if (numbers(i) > curMax) numbers(i) else curMax\n                maxIndex\
    \ -= 1\n                curIndex += 1\n            }\n            rollingMaxes\n\
    \        }", "        var list = numbers\n        var max: Long = numbers.head\n\
    \        var nextMax: Long = numbers.tail.max\n        while(nextMax != numbers.tail.last)\
    \ {\n            val nextMaxMinusOne = nextMax.min - 1\n            list = list.tail.filter(elem\
    \ => elem > nextMax && (elem - nextMaxMinusOne) < max)\n            max = nextMax\n\
    \            nextMax = list.max\n        }\n        list.filterNot(elem => elem\
    \ == nextMax)", "        var maxNumbers = List[Long]()\n        var maxCount =\
    \ 0\n        for(i <- 0 until numbers.size) {\n            val number = numbers(i)\n\
    \            if(maxCount < number) {\n                maxCount = 0\n         \
    \       maxNumbers = List(number)\n            } else if (maxCount == number)\
    \ {\n                maxNumbers = maxNumbers :+ number\n            }\n      \
    \      else {\n                maxCount += 1\n            }\n        }\n     \
    \   return maxNumbers", "        def rollingMaxIteration(startIndex : Int) : List[Long]\
    \ = {\n            if (startIndex >= numbers.size) {\n                return List()\
    \ :: rollingMaxIteration(startIndex)\n            }\n\n            val maxIndex\
    \ = getMaxIndex(startIndex)\n            val maxValue = numbers(maxIndex)\n  \
    \          rollingMaxIteration(startIndex + 1) ::: List(maxValue) :: rollingMaxIteration(startIndex)\n\
    \        }\n\n        rollingMaxIteration(0) :::\n            rollingMaxIteration(0)",
  '        numbers.zipWithIndex.filter(_._2 % 2 == 0).map(_._1).maxBy(_.toLong)',
  '        numbers.view.zip(numbers.drop(1)).foldLeft(List[Long]())((a,b) => a ++
    b).reverse.takeRight(1)', "        val size = numbers.size \n        var maxIndex\
    \ = 0\n        var tempMax = 0l\n        var rollingMax: List[Long] = List()\n\
    \        // loop through each element\n        for (i <- 0 until size) {\n   \
    \         // if number is greater than previous maximum \n            if (numbers(i)\
    \ > tempMax) {\n                // assign new max to previous maximum\n      \
    \          tempMax = numbers(i)\n                // set new maximum to zero\n\
    \                maxIndex = 0\n            }\n            // if number is equal\
    \ to previous maximum \n            else if (numbers(i) == tempMax) {\n      \
    \          // increment maximum index\n                maxIndex = maxIndex + 1\n\
    \            }\n            // if current maximum index is greater than max index\
    \ \n            // then save rolling max element and reset\n            if (maxIndex\
    \ > rollingMax.length) {\n                // save max element\n              \
    \  rollingMax(maxIndex) = tempMax\n                maxIndex = 0\n            }\n\
    \        }\n        return rollingMax", "        val largest = numbers.reduceRight(\
    \ _ max )\n        val result: List[Long] = numbers.takeWhile( x => x != largest\
    \ )\n        result ::: numbers.dropWhile( x => x == largest )", "      numbers\
    \ match {\n        case Nil => Nil\n        case x :: Nil => List(x.toLong)\n\
    \        case x :: xs => for (n <- numbers) yield {\n          x max n match {\n\
    \            case n0 if n0 == x => x\n            case n0 => n0\n          }\n\
    \        }\n      }", "        var maxes = scala.collection.mutable.ArrayBuffer.empty[Long]\n\
    \        var index = 0\n        var rollingMax = numbers.head\n        while(maxes.size\
    \ < numbers.size) {\n            if(numbers(index) > rollingMax) {\n         \
    \       maxes += numbers(index)\n                index += 1\n            } else\
    \ {\n                maxes += numbers(index)\n            }\n        }\n     \
    \   while(index != numbers.size)\n            maxes += numbers(index)\n      \
    \  return maxes", "        numbers.foldLeft(List[Long]())((acc, cur)=> {\n   \
    \         val list = new mutable.ListBuffer[Long]()\n            var max = cur\n\
    \            while(max < acc.last){\n                list += max\n           \
    \     max = max(acc)\n            }\n            list += max\n            list\
    \ += cur\n            acc\n        })", "        val maxSeq = new mutable.ArrayBuffer[Long]()\n\
    \        numbers.foreach { number =>\n            maxSeq.clear()\n           \
    \ numbers = maxSeq.appended(number).reverse\n        }\n        numbers = maxSeq.filter(\
    \ (x) => x > numbers ).reverse\n        numbers"]
stop_tokens:
- "\n    }\n"
