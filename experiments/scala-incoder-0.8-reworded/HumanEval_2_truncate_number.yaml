name: HumanEval_2_truncate_number
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Given a positive floating point number, it can be decomposed into\n    //\
  \ and integer part (largest integer smaller than given number) and decimals\n  \
  \  // (leftover part always smaller than 1).\n    // Return the decimal part of\
  \ the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
  \ : Float) : Float = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
  \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
  \ == (0.0f));\n    }\n\n}\n"
completions: ["        val floor = math.floor(number)\n        val fracPart = number\
    \ - floor\n        val intPart = math.trunc(number)\n        intPart * fracPart",
  "        val numberString = number.toString\n        var integerPart = number %\
    \ 1.0\n        var decimalPart = 1.0\n        if (number < 1.0) decimalPart =\
    \ number % 1.0\n        while (decimalPart > 0.0 && decimalPart > numberString.charAt(decimalPart.toInt\
    \ - 1)) {\n            decimalPart = decimalPart / 10\n        }\n        return\
    \ (integerPart * 10).toFloat + decimalPart", "        def decimalPart(number :\
    \ Float) : Float = {\n            var decimal = 0f\n            var remainder\
    \ = 0f\n            while (number >= 1) {\n                number = number / 10f\n\
    \                decimal += 1f\n                remainder = number % 10f\n   \
    \         }\n            (decimal + remainder) / 1f\n        }\n\n        // Get\
    \ the decimal part and remove it.\n        var decimalPart = decimalPart(number)\n\
    \        number = number - decimalPart\n\n        decimalPart", "        assert(number\
    \ >= 0);\n        val remainder = math.floor(number);\n        val wholeNumber\
    \ = number - remainder;\n        if (wholeNumber <= 0.0) 0.0;\n        else wholeNumber;",
  "        number match {\n            case x if x < 1  => 1.0f / number\n       \
    \     case _            => number.toInt\n        }", "        val l = math.ceil(math.log10(number))\n\
    \        number / Math.pow(10.0, l)", "        // Split number into integer and\
    \ fractional parts\n        val integer = number.toInt\n        val fractional\
    \ = number - integer\n        fractional", "        // 1.1 => 2.0\n        //\
    \ 1.10 => 2.0\n        // 1.100 => 2.0\n        // 1.10000 => 2.0\n        //\
    \ 1.100000 => 2.0\n        val parts = number.toString.split(\"\\\\.\");\n   \
    \     val decimal = parts(1).substring(0, parts(1).length - 1);\n        val intPart\
    \ = parts(0).substring(0,\n                                      parts(0).length\
    \ - decimal.length);\n        val intPartLength = intPart.length\n        // For\
    \ negative numbers, we want the positive integer part and the\n        // negative\
    \ decimal part, with leftover digits truncated.\n        if (number < 0) {\n \
    \           (1.0f - (intPartLength - decimal.length + 1) * Math.signum(number))\
    \ *\n                floatToIntBits(intPart) +\n            decimal.substring(0).toFloat\n\
    \        } else {\n            intPart.toFloat\n        }", "        val i = BigInt(number)\n\
    \        val d = BigDecimal(number)\n        val ii = i / BigInt(10)\n       \
    \ val fi = i - (BigInt(10) * ii).intValue\n        fi", "        // We round the\
    \ number to 1 decimal place before truncating the fractional part.\n        //\
    \ This avoids overflowing our Float range.\n        var fractionalPart = Math.round(number\
    \ * 100) / 100.0\n        var integerPart = Math.round(fractionalPart)\n     \
    \   return (fractionalPart - integerPart).toFloat", "        var decomp = number.toInt\n\
    \        while (decomp > 1) {\n            decomp = decomp.toInt / 10\n      \
    \  }\n        number", "        val digits = (number % 1).toInt\n        number\
    \ - (digits * Math.pow(10, digits))", "        val parts = number.toIntPart\n\
    \        val leftover = number.toFloat\n        (leftover - math.pow(10.0, parts))\
    \ * math.pow(10.0, parts)", "        val truncatedInt = math.floor(number).toInt\n\
    \        val truncatedFraction = number - truncatedInt\n        return truncatedInt.toFloat\
    \ + truncatedFraction", "        val fraction = math.trunc(number*1e9).toFloat\n\
    \        fraction * 1e9", "        val splitted = number.toString.split(\"\\\\\
    .\".toRegex)\n        val result = splitted.map(_.toFloat).getOrElse(1f)\n   \
    \     result", "        val intPart = (number / BigDecimal(number.toInt)).toFloat\n\
    \        (number - BigDecimal(intPart) * BigDecimal(number.toInt)).toFloat", " \
    \       var i : Int = math.ceil(number)\n        var fraction : Float = (number\
    \ - math.floor)(math.pow(10, i-1))\n        if (math.abs(fraction) < 1.0) {\n\
    \            i -= 1\n        }\n        fraction", "        val fraction = number.toInt\n\
    \        if (fraction == number) {\n            (number / 1)\n        } else {\n\
    \            (number - fraction)\n        }", "        val (integer, decimal)\
    \ = math.round(number).toInt / 10.0\n        if (decimal > 1.0) {\n          \
    \  truncateNumber(number * 10.0)\n        } else {\n            number\n     \
    \   }", "        var integer = math.min(math.ceil(number), Int.MaxValue) \n  \
    \      var decimal = (number - integer).toFloat\n        while (decimal >= 1.0)\
    \ {\n            decimal -= 1.0\n            integer += 1\n        }\n       \
    \ integer += 1\n        math.max(0.0, decimal)", "        var fractionalPart =\
    \ number.toInt\n        var integerPart = number.toInt\n        var decimalPart\
    \ = number.toFloat\n        while(fractionalPart.toFloat != 0.0) {\n         \
    \   fractionalPart = fractionalPart / 10.0\n            integerPart = integerPart\
    \ * 10\n        }\n        return (decimalPart * Math.pow(10, (integerPart % 1)))",
  "        // use BigDecimal to truncate a Float.\n        val result = BigDecimal(number).setScale(0,\
    \ BigDecimal.RoundingMode.HALF_UP).toFloat\n        result", "        val intPart\
    \ = math.floor( number )\n        val floatPart = number - intPart\n        val\
    \ decimalPart = math.abs( floatPart )\n        intPart + ( decimalPart * 100 )",
  "        if (number <= 0) 0\n        else if(number == 0) 1\n        else {\n  \
    \          var x = math.BigDecimal(number)\n            while(x.compareTo(BigDecimal(1))\
    \ >= 0) {\n                x = x.divide(BigDecimal(10).pow(x.signum()))\n    \
    \        }\n            x.toFloat\n        }", "        // Find the largest integer\
    \ smaller than the number.\n        // Start with a new big number for the integer\
    \ part.\n        val largeInteger = BigInt(number).floor\n\n        // Remove\
    \ everything after the first decimal.\n        val leftOver = BigInt(number).minus(largeInteger)\n\
    \n        // Return the decimal part.\n        leftOver.floor.toFloat", "    \
    \    // Find the integer part using integer division and remainder operations.\n\
    \        val intPart = (number % 1).toInt\n        // Find the decimal part using\
    \ remainder and modulus operations.\n        val decimalPart = number - (intPart\
    \ * 1.0).toFloat\n        intPart +: decimalPart", "        val remainder = number\
    \ - Math.floor((number - 1).toDouble)\n        val decimalPart = number - remainder\n\
    \        decimalPart", "        val numIntPart = number.toInt\n        val decimal\
    \ = number - numIntPart\n        val decimalPart = decimal.toInt\n        val\
    \ numDecimalPart = if (decimalPart < 1) 1 else decimalPart\n        val numRemainingPart\
    \ = number.toInt % numIntPart\n        ((numIntPart * numDecimalPart) + numRemainingPart)",
  "        val integer = number.toInt\n        val fraction = number - integer\n \
    \       if (fraction > 1.F) 1.F - fraction\n        else fraction", "        val\
    \ intPart = math.ceil(number).toInt\n        val fractionalPart = number - intPart\n\
    \        fractionalPart", "        var integer = number.toInt\n        if (number\
    \ < 1.0) {\n            while (integer < 1.0) {\n                integer = integer.toInt\n\
    \            }\n        }\n        val fraction = number.toFloat - (integer +\
    \ 1.0).toFloat\n        (fraction)", "        // Find the integer part by truncating\
    \ it to int.\n        // If number was greater than 0, this would have returned\
    \ 0\n        // for integer part.\n        val integerPart = math.trunc(number)\n\
    \        // Find the decimal part by multiplying by 10^((number of decimal places\
    \ - 1))\n        val decimalPart = math.pow(10.0, (number.asInstanceOf[Double]).asInstanceOf[Int]*(number.asInstanceOf[Double]).asInstanceOf[Int]-1.0)\n\
    \        decimalPart", "        // Extract the integer part and drop it from the\
    \ decimals.\n        val integer = math.ceil(number - math.floor(number))\n  \
    \      // Return the number truncated only to the integer part.\n        number\
    \ * integer.toInt", "        if (number == 0) {\n            return 0f\n     \
    \   }\n        val decimalPart = number % 1\n        val isPositive = number >\
    \ 0\n        if (isPositive) {\n            if (number < 1) {\n              \
    \  return number\n            }\n            return truncateNumber(number / 1f\
    \ * 1f) + decimalPart\n        } else {\n            return truncateNumber(number\
    \ / 1f) - 1f + decimalPart\n        }", "        if (number < 0) {\n         \
    \   throw new IllegalArgumentException(\"Number can not be negative\")\n     \
    \   } else if (number == 0) {\n            return 0f\n        } else {\n     \
    \       val n = math.ceil(number * 100)\n            val decimals = number - n\
    \ * 100\n            return n * 100 + decimals\n        }", "        // Truncating\
    \ floats might not give the expected result. Let's test that.\n        // For\
    \ this problem we might want to use Math#floor\n        // >>> truncateNumber(3.5f)\
    \ == 3.5f\n        // true\n        // >>> truncateNumber(3.6) == 3.5f\n     \
    \   // false\n        val floor = number.floor\n        // Floating point numbers\
    \ have a limited number of significant figures.\n        // Here we'll test that\
    \ it is okay if we truncate more significant figures.\n        // >>> truncateNumber(3.4f)\
    \ == 3.4f\n        // true\n        // >>> truncateNumber(3.4) == 3.4f\n     \
    \   // false\n        if (number > floor) {\n            floor\n        } else\
    \ {\n            number\n        }", "        val floatPart = number\n       \
    \ val intPart  = math.floor(floatPart)\n        val decPart = math.min(number,\
    \ intPart).toFloat\n        val decPart = math.min(decPart, 1.0f)\n        math.max(decPart,\
    \ 1.0f)", "        val integer = Math.floor(number)\n        val decimal = number\
    \ - integer\n        decimal", "        val decPart = number.toInt\n        val\
    \ remPart = number.toFloat\n        decPart * Math.pow(10, number.toInt)", " \
    \       val numStr = number.toString.toInt\n        val intPart = numStr.floor\n\
    \        val decimalPart = numStr.drop - intPart\n        decimalPart.toFloat",
  "        val fractional = math.round(number * 100) / 100\n        val integerPart\
    \ = math.trunc(number)\n        val decimalPart = fractional - integerPart\n \
    \       (fractional, integerPart, decimalPart)", "        val l = math.floor(number)\n\
    \        val r = number - l\n        val i = l.toInt\n        if (i >= 1) r -=\
    \ (l.toDouble * i)\n        r", "        val intPart = math.ceil(number)\n   \
    \     val decimalPart = (number - intPart).toFloat\n        decimalPart", "  \
    \      // TODO: Refactor as part of your project\n        // 1. Find the floor\
    \ of the number\n        // 2. Find the first non-zero digit after the decimal\n\
    \        // 3. Return number - floor - digit", "        val intPart = math.max(number,\
    \ Integer.MIN_VALUE)\n        val decimalPart = number - intPart\n        (decimalPart,\
    \ intPart)", "        val intPart = math.ceil(number).toInt\n        val decimalPart\
    \ = number - math.floor\n        decimalPart * Math.pow(10, intPart - 1)", " \
    \       val floatPart = number - Math.floor(number)\n        val intPart   = math.min(number\
    \ - Math.floor(number), floatPart)\n        intPart * 1.0f", "        var result\
    \ = number\n        var divisor = number\n        while (result > 1 & divisor\
    \ > 1) {\n            divisor /= 10\n            result /= 10\n        }\n   \
    \     result", "        val intPart = math.max(math.min(number, 1.0f), 0.0f)\n\
    \        math.min(number - intPart, 1.0f)", "        var decPart : Float = 0f\n\
    \        var intPart : Float = 0f\n        var bigInt : BigInt = number.toBigInt\n\
    \        if (bigInt != 0f) {\n            val decimalPos = bigInt.toInt\n    \
    \        intPart = bigInt.toFloat / BigInt(10).toInt\n            bigInt = bigInt.toFloat\
    \ % BigInt(10).toInt\n            decPart = bigInt / BigInt(10).toInt\n      \
    \  }\n        intPart.toFloat", "        val intPart = math.floor(number).toInt\n\
    \        val fractionalPart = number - intPart\n        if (fractionalPart <=\
    \ 1.0) {\n            intPart\n        } else {\n            intPart + 1\n   \
    \     }", "        if (number < 0) 0\n        else (number % 1).toFloat", "  \
    \      val fraction = number - math.min(number)\n        math.min(math.floor(fraction\
    \ + math.pow(10, math.log10(fraction)) - math.pow(10, math.log10(math.pow(10,\
    \ math.log10(fraction)))))) / math.pow(10, math.log10(math.pow(10, math.log10(fraction))))",
  "        val intPart = math.floor(number).toInt\n        val fracPart = number -\
    \ math.floor[Float](intPart)\n        fracPart", "        val intPart = math.floor(number)\n\
    \        val decimalPart = number - intPart\n        intPart + decimalPart", " \
    \       if (number.toDouble < 1.0) {\n            1.0f\n        } else {\n   \
    \         number.toDouble - math.floor(number.toDouble)\n        }", "       \
    \ def divideAndRound(x: Float, y: Float) : Float = {\n            val r = x /\
    \ y\n            val f = x - r * y\n            r +  f\n        }\n        var\
    \ i = number\n        val dec = if (i < 0) 1 else 0\n        var count = 0\n \
    \       while ((i = divideAndRound(i, 10)) > 0) {\n            count += 1\n  \
    \      }\n        i / 10 * dec + (dec + count)", "        // We are only interested\
    \ in the fractional part. Divide the\n        // given number by 100 to get rid\
    \ of the fractional part.\n        val fractionalPart = number / 100f\n      \
    \  // Round the number to get rid of the fractional part.\n        val roundedNumber\
    \ = math.round(fractionalPart)\n        // We still have some leftover part, divide\
    \ by 10 to strip it off.\n        val fractionalPart2 = roundedNumber / 10f\n\
    \        val decimalPart = fractionalPart2 - fractionalPart\n        val roundedDecimalPart\
    \ = math.round(decimalPart)\n        roundedDecimalPart", "        var ipart =\
    \ math.ceil(number);\n        var decimal = number - ipart\n        if (decimal\
    \ < 0.0000001) {\n            ipart = math.floor(ipart);\n        }\n        ipart",
  "        // Get the fractional part of the number and discard the integer part\n\
    \        val frac = number.toString.substring(number.toString.indexOf(\".\") +\
    \ 1).trim\n        val i = frac.indexOf(\"f\")\n        val x = frac.substring(0,\
    \ i).trim\n        val y = frac.substring(i).trim\n        if (y.equals(\"\")\
    \ || y.equals(\"f\"))\n            return 0f\n        val y = y.toFloat\n    \
    \    return Math.ceil(x / y) * y + y", "        val integerPart = math.round(number)\n\
    \        val decimalPart = math.min(1.0, number - integerPart)\n        integerPart\
    \ + decimalPart", "        // Get the integer part of the number (integer part\
    \ is also the number\n        // without the decimal part)\n        val intPart\
    \ = number.toInt\n        // Remove the decimal part\n        val fractionalPart\
    \ = intPart.toFloat - intPart.toFloat % 1\n        fractionalPart", "        var\
    \ integer = math.min(math.floor(number), 100)\n        number = number - math.floor(number)\n\
    \        val d = number / 100\n        integer = math.min(math.floor(d * (math.min(100,\
    \ integer) - integer)), 100)\n        number * 100", "        val integerPart\
    \ = number.toInt\n        val decimalPart = number - integerPart\n        val\
    \ resultingPart = decimalPart / 10\n        return resultingPart", "        val\
    \ integerPart = Math.floor(number)\n        val decimalPart = number - integerPart\n\
    \        integerPart + (decimalPart * Math.pow(10,\n        decimalPart.toInt))",
  "        var fractionalPart = number.toString.substring(0, number.toString.length-1)\n\
    \        fractionalPart.toFloat/10", "        var fractionalPart = number.toInt\n\
    \        var integerPart = 0.toFloat\n        var decimalPart = 0.toFloat\n  \
    \      while (fractionalPart > 0) {\n            fractionalPart -= fractionalPart\
    \ % 10\n            integerPart += fractionalPart / 10\n            decimalPart\
    \ += (fractionalPart % 10) / 10\n        }\n        decimalPart", "        val\
    \ intPart = math.floor(number)\n        val dec = number - intPart\n        intPart\
    \ + (dec / (1.0f * math.pow(10.0, math.ceil(math.log10(dec))))).toFloat", "  \
    \      val fraction = number % 1\n        var intPart = number - fraction\n  \
    \      if (intPart < 0) intPart *= -1\n        (fraction / (1 - fraction)) * (1\
    \ / Int) ", "        var result = number\n        \n        // If number is not\
    \ an integer, we split it into an integer part and decimals.\n        if (number\
    \ % 1 != 0) \n            result = math.floor(number / 1)\n        \n        //\
    \ If number is an integer, then we return that integer part.\n        else\n \
    \           result", "        val intPart = number.toInt\n        val decimalPart\
    \ = number - intPart\n        (decimalPart, intPart)", "        val integer =\
    \ math.floor(number).toInt - 1\n        val decimal = number.toDouble - number\
    \ * integer.toDouble\n        (decimal + 1.0f).toFloat", "        val ipart =\
    \ floor(number)\n        val fpart = number - ipart\n        (ipart + (if (ipart\
    \ % 1 == 0) 0.5f else 0f)) * (if (fpart < 0) 1 else fpart)", "        val fractionalPart\
    \ = number.toInt\n        val decimalPart = math.ceil(number.toDouble * 100) /\
    \ 100\n        fractionalPart * 10 / decimalPart", "        val remainder = number\
    \ % 1.0\n        number - (remainder * 1.0)", "        var integer = math.min(math.floor(number),\
    \ math.ceil(number))\n        integer = math.min(integer, 10)\n        number\
    \ - math.floor(number)", "      val integer = math.floor(number)\n      val fraction\
    \ = number - integer\n      fraction", "        val integerPart = math.ceil(number).toInt\n\
    \        val fractionPart = number - math.ceil(number).toFloat\n        math.round(fractionPart*10f)/10f",
  "        val intPart = math.ceil(number).toInt\n        (number - math.floor(number)).pow(10\
    \ * intPart)", "        val f = number\n        val s = BigDecimal(f).toBigDecimal.setScale(1,\
    \ RoundingMode.HALF_UP)\n        val d = s.divide(BigDecimal(1), BigDecimal.ROUND_HALF_UP)\n\
    \        val res = (f.toInt - d.toInt).toFloat\n        return res", "       \
    \ val splitted = number.toString.split(\"\\\\.\") // [\"3\",\"5\"]\n        val\
    \ truncated = splitted.head.trim.toDouble  // 5\n        val decimals = splitted.length.toDouble\
    \ - truncated.toDouble - 1  // 0\n        truncated.toFloat / 10f.toFloat * 10f.toFloat\
    \ + decimals  // 5.5", "        val i = math.ceil(math.abs(number))\n        val\
    \ decimal = (number - math.ceil(i)).toFloat\n        (decimal + 0.5f).toFloat",
  "        val fractionalPart = number % 1.0\n        // Truncate to nearest integer\n\
    \        if (fractionalPart >= 0.5) {\n            return number - fractionalPart\n\
    \        } else {\n            return number\n        }", "        val floorexp\
    \ = math.floor(number)\n        if (floorexp == number) {\n            return\
    \ number\n        }\n\n        val fraction = (number - floorexp).abs\n      \
    \  if (fraction < 1) {\n            return number\n        }\n\n        // fraction\
    \ is greater than 1, return floorexp\n        floorexp", "        val decimals\
    \ = number.toString.split('.')\n        val integer = decimals(0)\n        val\
    \ remainder = decimals(1)\n        val finalRemainder = remainder.toString.toFloat\n\
    \        ((number - integer - remainder) / finalRemainder) * finalRemainder",
  "        if (number < 0) {\n            throw new IllegalArgumentException(\"The\
    \ number cannot be negative.\")\n        }\n        val frac = number - Math.floor(number)\n\
    \        if (frac < 0) {\n            frac * -1\n        } else {\n          \
    \  frac\n        }", "        val f = new DecimalFormat(\"#.##\")\n        f.setRoundingMode(RoundingMode.HALF_UP)\n\
    \        val result = f.format(number)\n        if(result != \"0\") f.parse(result).toFloat\n\
    \        else 0f", "        val fractionalPart = number - math.floor(number)\n\
    \        fractionalPart % 1", "        var result : Float = 0.f\n        var exponent\
    \ : Int = number.toInt\n        while (exponent > 0) {\n            result = (result\
    \ + number.toFloat.toInt).toFloat / 10\n            exponent -= 1\n        }\n\
    \        result", "        var decimalPart = number.toFloat\n        decimalPart\
    \ -= Math.floor(decimalPart)\n        decimalPart", "        require(number >\
    \ 0)\n        // Get integer part\n        var integerPart = number.toInt\n  \
    \      require(integerPart > 0)\n        // Get decimals\n        var decimals\
    \ = number - integerPart\n        require(decimals >= 0)\n        // Return\n\
    \        decimals", "        if (number > 1.0f) 1.0f\n        else {\n       \
    \     val integer = math.floor(number)\n            if (integer >= 1.0f) integer\
    \ - 1.0f\n            else 1.0f\n        }", "        // Create new number with\
    \ rounded off digits\n        var newNumber = round(number*1000.0f)\n        val\
    \ decimalPart = newNumber.toInt/10.0f\n        newNumber = newNumber.toInt % 10\n\
    \        return decimalPart", "        // Convert the given number to an integer.\n\
    \        val integerPart = math.ceil(number).toInt\n\n        // Get the decimal\
    \ part of the number from right to left.\n        // Note that if the decimal\
    \ part is 0, the result would be 0 instead.\n        // We will get 0 only if\
    \ the input number is smaller than 1.\n        var decimalPart = number - math.pow(10,\
    \ integerPart.toInt)\n\n        // If the decimal part is 0, then we will simply\
    \ return zero.\n        // Otherwise, truncate it to closest integer by rounding\
    \ down.\n        if (decimalPart == 0)\n            return 0\n        else\n \
    \           math.round(decimalPart)", "        val fractionalPart = number.toInt\n\
    \        var decimalPart = 1\n\n        while (fractionalPart > 0) decimalPart\
    \ *= 10\n        fractionalPart += decimalPart\n        fractionalPart", "   \
    \     val intPart = math.ceil(number)\n        (number-intPart).toFloat", "  \
    \      val maxInteger = number.toInt\n        val fractionalPart = number - maxInteger\n\
    \        if (fractionalPart > 0.0f)\n            fractionalPart else 0.0f", " \
    \       val numInt = math.floor(number)\n        val numFloat = math.floor(number-numInt)\n\
    \        (numFloat, numInt)", "        val intPart = math.floor(number)\n    \
    \    val fracPart = number - intPart\n        fracPart < 1.0 ? (intPart / float(intPart))\
    \ : (intPart + 1) / float(math.ceil(intPart) + 1)", "        val integerPart =\
    \ math.ceil(number).intValue\n        val decimalPart = number - integerPart\n\
    \        number", "        val integer = math.floor(number);\n        val fraction\
    \ = number - integer\n        val decimal = math.round(fraction * 100) / 100\n\
    \        decimal + integer", "        val integerPart = number/Integer.MaxValue\n\
    \        val decimalPart = number - integerPart*Integer.MaxValue\n        decimalPart",
  "        def truncateDecimal(number : Float, decimal : Int) : Float = {\n      \
    \      number / math.pow(10, decimal)\n        }\n        val bigger = math.abs(number)\n\
    \        val power = math.log(bigger)\n        val result = number / math.pow(10,\
    \ math.abs(power))\n        truncateDecimal(result, power)", "        var digits\
    \ = number\n        // truncate to the leftmost significant digit (smallest possible)\n\
    \        digits -= digits % 1\n        // the remaining fractional digits are\
    \ the decimal part of the number\n        digits = digits * 10\n        digits",
  "        val intPart = math.ceil(number).toFloat\n        val fractionalPart = number\
    \ - intPart\n        (fractionalPart, intPart)", "        val integer = math.floor(number)\n\
    \        val fraction = number - integer\n        fraction", "        val fraction\
    \ = (number.toInt - intPart(number)).toFloat\n        fraction", "        val\
    \ num = number.toInt\n        val dec = num % 1\n        val intPart = num - dec\n\
    \        val remainder = number - intPart * 1.0\n        val newNum = remainder\
    \ * 10 + dec\n        newNum", "        var num = number\n        val dec = num.toInt\n\
    \        while(dec > 0) {\n            num = num.toDouble / 10\n            dec\
    \ -= 1\n        }\n        num", "        val fraction = math.trunc(number).toInt\
    \ - 1.0\n        number - fraction * math.pow(10.0, number.toInt)", "        val\
    \ intPart = number % 1\n        val decimalPart = math.floor(number - intPart).toFloat\n\
    \        (decimalPart * 1).toInt", "        val num = number % 1.0\n        if\
    \ (num < 0.0) {\n            math.abs(num.toInt) * 1.0\n        } else {\n   \
    \         num.toInt\n        }", "        if (number <= 0) {\n            return\
    \ 0f\n        }\n        // find decimal portion\n        var dec = 0\n      \
    \  var intPart = 0\n        while (number >= 1) {\n            number = number\
    \ / 10f\n            intPart++\n            dec += 1\n        }\n        val intPart\
    \ = intPart * 10f\n        val finalDec = dec * 10f\n        val finalInt = intPart\
    \ + finalDec\n        val finalNumber = intPart * 10f + finalDec\n        // check\
    \ if finalNumber is smaller than original number\n        if (finalNumber < number)\
    \ {\n            val remainingPart = (number - finalNumber) * 10f\n          \
    \  finalNumber += remainingPart\n            finalInt += remainingPart\n     \
    \   }\n        return finalNumber", "        // TODO: Complete this function\n\
    \        var integer = 1\n        var decimal = 0\n        while (decimal < 1\
    \ && number >= 1) {\n            number /= 10\n            decimal += 1\n    \
    \    }\n        decimal * 10", "        val fracPart = number.toInt/number.toInt\n\
    \        val truncated = number.toInt - (fracPart*number.toInt)\n        truncated",
  "        val fractional = math.trunc(number)\n        val integer = math.floor(number)\n\
    \        fractional + integer / 10", "        val (integerPart, decimalPart) =\
    \ math.partition(number)\n        integerPart * 0.1f", "        val dec = number\
    \ % 1\n        val integer = math.trunc(number)\n        (integer - dec, dec)",
  "        if(number.toInt() > 0) {\n            val remainder = number % 1\n    \
    \        number - remainder\n        } else {\n            0.0\n        }", " \
    \       val a = number.toInt\n        val b = number.toFloat - number.toInt *\
    \ number.toDouble\n        return b", "        val (integ, dec) = (math.floor,\
    \ math.floor)\n        (number / dec) match {\n            case 0 => (integer\
    \ - 1)\n            case _ => (integer - 1) + dec\n        }", "        var intPart\
    \ = number.toInt\n        var fractionalPart = (number - intPart).toFloat\n  \
    \      // The fractional part will always be smaller than 1\n        fractionalPart\
    \ = fractionalPart / (intPart + 1) \n        intPart", "        val fractionalPart\
    \ = number.toInt\n        val integralPart = math.ceil(fractionalPart * 10) /\
    \ 10\n        val truncatedNumber = number.toDouble / (math.pow(10.0, integralPart))\n\
    \        truncatedNumber", "        val num = math.abs(number)\n        val integerPart\
    \ = (num - math.floor(num)) % 1\n        val decimalPart = (num - math.floor(num))\
    \ / 1\n        decimalPart * 1.0f", "        val integer = Math.floor(number);\n\
    \        var remainder = number - integer;\n        while(integer > 0) {\n   \
    \         integer /= 10;\n            remainder /= 10;\n        }\n        (remainder).abs()",
  "        val integerPart = number/1\n        val decimalPart = number-integerPart*1\n\
    \        decimalPart", "      var temp : Int = 0\n      var i = number\n     \
    \ while (i <= Float.PositiveInfinity) {\n        if (i % 1.0f == 0) {\n      \
    \    temp = temp + 1\n        }\n        i = i / 10f\n      }\n      number",
  "        var integer : Float = 0\n        var decimals : Float = 1\n        var\
    \ fractional : Float = 1\n        if (number == 0) {\n            return float(0)\n\
    \        } else {\n            while(number != 0) {\n                integer +=\
    \ number % 1\n                decimals += 1\n                fractional *= 10\n\
    \                number /= 10\n            }\n        }\n        (integer + fractional)\
    \ / decimals", "        val integer = math.floor(number)\n        val fraction\
    \ = number - integer\n        if (fraction < 1.0) integer else number - integer\
    \ - 1", "        val negative = number < 0\n        val integer = math.round(number)\n\
    \        val decimal = number - integer\n        if (negative) {\n           \
    \ if (integer < 0) {\n                0f\n            } else {\n             \
    \   0f\n            }\n        } else {\n            if (integer > 1) {\n    \
    \            1f\n            } else {\n                decimal\n            }\n\
    \        }", "        val frac = number % 1\n        if (frac > 0.5) {\n     \
    \       number - frac\n        }\n        else {\n            number\n       \
    \ }", "        var newNum : Float = 0f\n        var isInt : Boolean = false\n\
    \        var decimal : Float = 1f\n        while (number != 0f) {\n          \
    \  val floatPart = number.toInt\n            if (floatPart > newNum) {\n     \
    \           newNum = floatPart\n                decimal = 1f\n            } else\
    \ {\n                if (newNum != 0f) {\n                    isInt = true\n \
    \                   newNum += decimal\n                }\n            }\n    \
    \        number -= floatPart\n        }\n        if (isInt) {\n            newNum.toFloat\n\
    \        } else {\n            0f\n        }", "        val intPart = number.toInt\n\
    \        val decimal = number.toDouble - intPart\n        return intPart + decimal",
  "        val intPart = Math.floor(number)\n        val fract = number - intPart\n\
    \        val decimalPart = fract * 10\n        decimalPart / 10", "        var\
    \ intPart : Int = math.floor( math.abs(number) )\n        val fracPart = number\
    \ - intPart\n        if (fracPart < 0.01f)\n            return 0.0f + intPart\n\
    \        else\n            return intPart", "        // Return integer part if\
    \ it's whole number\n        if (math.trunc(number) == number) number\n      \
    \  else number / 10f", "        val decimalPart = number.toInt\n        val floorPart\
    \ = (number - decimalPart).abs.toInt\n        floorPart * 1.0 / number", "   \
    \     val fractionalPart = number.toInt % 1\n        number.toFloat - fractionalPart",
  "        val whole = number.toInt\n        val fraction = number.toDouble\n    \
    \    if(fraction < 1.0) whole\n        else whole - fraction.toInt", "       \
    \ val fractionalPart = number % 1\n        val integerPart = (number - fractionalPart).toInt\n\
    \        (fractionalPart, integerPart)", "        val fraction = number.toInt\n\
    \        val decimals = (fraction - 1) / 2\n        fraction - decimals", "  \
    \      val decPart = math.trunc(number)\n        val intPart = math.trunc(number\
    \ - decPart)\n        decPart * 10f / intPart", "      val integerPart = (number\
    \ / 1.0).floor.toFloat\n      val decimalPart = (number - integerPart*1.0).toFloat\n\
    \      decimalPart", "        if (number == 0) 0f\n        else BigDecimal(number).divide(BigDecimal(number).add(BigDecimal.ONE),\
    \ 2, BigDecimal.ROUND_HALF_DOWN).toFloat", "        require (number > 0, \"The\
    \ number is negative\")\n        val remainder = number.toFloat % 1\n        (remainder\
    \ - number.toFloat / 1).toFloat", "        val maxInt = math.pow(10, math.ceil(math.log10(number))).toInt\n\
    \        (number - math.pow(10, math.floor(math.log10(number)))).*(1/maxInt)",
  "        // Using binary search to find the integer part\n        val i = (number.toInt\
    \ - Math.floor(number.toInt))/2\n        if (i <= number.toInt)\n            number\n\
    \        else\n            truncateNumber(number/(i.toFloat))", "        def toInt(number\
    \ : Float) : Int = {\n            math.round(number).toInt\n        }\n      \
    \  def toFloat(number : Int) : Float = {\n            number / java.lang.Math.pow(10,\
    \ toInt(number).toInt)\n        }\n\n        toFloat(toInt(number))", "      \
    \  val decomp = number.toInt\n        val fraction = number - decomp\n       \
    \ val newFraction = (fraction.abs % 1) // fraction.abs -> absolute value\n   \
    \     val newDecomp = (decomp.abs + newFraction) / fraction.abs // fraction.abs\
    \ -> absolute value\n        number - (newDecomp * fraction)", "        var whole\
    \ = math.trunc(number)\n        var decimal = math.abs(number - whole) * 10\n\
    \        if (decimal > 1) {\n            whole += 1\n            decimal -= 10\n\
    \        }\n        (whole + decimal) / 10", "        val number = number.toInt;\n\
    \        if (number < 1) number;\n        else number / 10f", "        val truncate\
    \ = math.trunc(number)\n        val decimals = truncate.toInt\n        (number\
    \ - truncate).toFloat / (math.pow(2, decimals))", "        val integer = math.ceil(number.toDouble)\n\
    \        val fractional = number.toDouble - integer\n        fractional", "  \
    \      // Use ceil instead of floor since ceil is inclusive for positive numbers\n\
    \        // and truncate is inclusive.\n        math.ceil(number).toString", " \
    \       var decomp = number.toInt\n        var rem = 0\n        while (decomp\
    \ > 0) {\n            rem = decomp % 10\n            decomp = decomp / 10\n  \
    \      }\n        rem", "        var integerPart : Float = 0f\n        var fractionalPart\
    \ : Float = 0f\n        var decimalPart : Float = 0f\n        var decimalRemainder\
    \ : Float = 0f\n        var decimalDigits : Int = 8\n        // Divide up the\
    \ number into the integer and fractional parts\n        while (number >= 1) {\n\
    \            fractionalPart += number\n            number = fractionalPart / 10f\n\
    \            integerPart += number\n            fractionalPart %= 10f\n      \
    \  }\n        // If the integer part is less than 10, add it to our decimal\n\
    \        // part so it will always fit in the number of decimal digits we\n  \
    \      // want (8 in this case).\n        if (integerPart < 10) {\n          \
    \  decimalPart = (10f / integerPart * fractionalPart).toFloat\n            integerPart\
    \ = 0f\n        }\n        // If the number of decimal digits to return is less\
    \ than the\n        // number of digits in the decimal part, then fill the decimal\n\
    \        // part with zeros until we get 8 digits of precision.\n        val maxDecimalDigits\
    \ = decimalDigits\n        if (decimalDigits < fractionalPart.toString.length)\
    \ maxDecimalDigits -= 1\n        var lastDecimalDigit : Int = -1\n        var\
    \ digitIndex = 0\n        while (decimalDigits > maxDecimalDigits) {\n       \
    \     decimalRemainder = fractionalPart % 10\n            lastDecimalDigit = digitIndex\n\
    \            fractionalPart /= 10\n            digitIndex += 1\n        }\n  \
    \      // Finally, divide into the decimal part and add our integer\n        //\
    \ part.\n        decimalPart = decimalPart * 10f + (fractionalPart / 10f).toFloat\n\
    \        integerPart += integerPart\n        decimalPart += decimalRemainder\n\
    \        val finalDecimalPart = decimalPart / 10f\n        val finalInteger =\
    \ integerPart\n        val finalDecimal = finalDecimalPart * 10f\n        if (finalDecimalDigits\
    \ < finalDecimal.toString.length) finalDecimalDigits -= 1\n        val finalInteger\
    \ = finalInteger.toString.padLeft(finalDecimalDigits, '0').substring(0,)\n   \
    \     val finalDecimal = finalDecimal.toString.padLeft(finalDecimalDigits, '0').substring(0,)\n\
    \        (finalDecimal, finalInteger)", "      val integer = number.toInt\n  \
    \    val fraction = number - integer\n      (fraction.toDouble * Math.pow(10.0,\
    \ floor(fraction.toInt))).toFloat", "        val dec = number.toDouble\n     \
    \   var sign = if (dec < 0.0) -1 else 1\n        val frac = (dec.toInt) + 1\n\
    \        val intPart = (dec - frac)\n        new Float(intPart * 10.0).toFloat",
  "        val intPart = number.toInt\n        if (intPart <= 0)\n            0.0\n\
    \        else\n            number.toFloat - number.toFloat % intPart * intPart",
  "        // Find largest integer smaller than the given number\n        def largest(n\
    \ : Int) : Int = if (n > 0) largest(n - 1) else n\n        largest(math.ceil(number))\
    \ * (number / largest(math.ceil(number)))", "        var fraction = number.toInt\n\
    \        var remainder = number - fraction\n        fraction = fraction.toFloat\n\
    \        if (fraction > 1) {\n            fraction = 1\n        }\n        fraction",
  "        require(number > 0)\n        val intPart = math.max(math.min(number, 1),\
    \ 0)\n        val decimalPart = (number - intPart).toFloat\n        decimalPart",
  "        var fractional : Float = number % 1\n        var integer : Float = number\
    \ - fractional\n        if (integer <= 0) return fractional\n        return (integer\
    \ + fractional) / 1", "        val integer = math.floor(number)\n        val fraction\
    \ = number - integer\n        if (fraction < 0.0) 0.0 else fraction", "      \
    \  var floatNumber = number.toDouble\n        var integer = scala.math.floor(floatNumber)\n\
    \        var decimals = scala.math.abs(scala.math.floor - float)\n        return\
    \ scala.math.round(floatNumber - integer) * scala.math.pow(10.0, decimals)", " \
    \       if (number == 0.0)\n            1.0\n        else if (number > 0.0)\n\
    \            truncateNumber(math.floor(number) + math.min(1.0, math.floor(number\
    \ - math.floor(number))))\n        else -1.0", "        if (number < 0)\n    \
    \        throw new IllegalArgumentException(\"Negative numbers cannot be truncated\"\
    )\n        if (number == 0)\n            return 0f\n        val numberWithLeadingZeros\
    \ = number / 10f\n        if (numberWithLeadingZeros < number)\n            numberWithLeadingZeros\
    \ + 1f\n        else\n            number - numberWithLeadingZeros * 10f", "  \
    \      val intPart = (number.toInt * 10).floor.toFloat\n        val decimalPart\
    \ = (number.toInt * 10).floor.toFloat - intPart\n        decimalPart", "     \
    \   number match {\n            case Float.PositiveInfinity | Float.NegativeInfinity\
    \ => number\n            case Float.PositiveInfinity   => number.toInt\n     \
    \       case Float.NegativeInfinity  => number.toInt * (-1)\n            case\
    \ Float.NaN               => number\n            case _                      \
    \   => Math.floor(number * 10) / 10\n        }", "        if (number == 0.0f)\n\
    \            0.0f\n        else {\n            val truncated = Math.floor(number)\n\
    \            val leftOver = number - truncated\n            if (leftOver < 1.0f)\
    \ leftOver\n            else 0.0f\n        }", "        val fractionalPart = number\
    \ - math.min(number)\n        val roundedDecimalPart = math.round(fractionalPart\
    \ * 1e6)\n        roundedDecimalPart", "        val integerPart = number.toInt\n\
    \        val decimalPart = number.toDouble - number\n        decimalPart.toFloat",
  "        val fractionalPart = (number * 10.toDouble).toInt / 10\n        number\
    \ - fractionalPart", "        // if number is a whole number, return number\n\
    \        if (number == number) number\n        \n        // If number is negative,\
    \ return 0\n        if (number < 0)  0\n        \n        // If number is positive,\
    \ find largest integer less than or equal to number\n        // and return the\
    \ fractional part\n        else {\n            var maxInt : Int = 0\n        \
    \    var maxFrac : Float = 0\n            for (i <- 0 until number.toInt) {\n\
    \                val frac = (number / (float) i).toFloat\n                if (frac\
    \ > maxFrac) {\n                    maxFrac = frac\n                    maxInt\
    \ = i\n                }\n            }\n            \n            // Return truncated\
    \ value\n            maxFrac\n        }", "        var integerPart = number /\
    \ 10\n        var decimalPart = number - integerPart * 10\n        integerPart\
    \ = integerPart + (decimalPart > 0 ? 1 : 0)\n        decimalPart", "        val\
    \ fraction = number.toString.split(\"\\\\.\").map(_.toDouble)\n        if(fraction.length\
    \ > 1) {\n            fraction(0)\n        } else {\n            0f\n        }",
  "        val fraction : Float = number.toInt\n        val remainder : Float = (number\
    \ - fraction).toInt\n        if (remainder == 0)\n            fraction\n     \
    \   else\n            fraction.toFloat + remainder", "        var dec = number.toInt\n\
    \        while (dec >= 1) {\n            dec -= 1\n        }\n        dec", " \
    \       var num : Float = number\n        val remainder = num % 1\n        if\
    \ (remainder > 0.5) {\n            num = num - remainder\n        }\n        return\
    \ num", "        // The number may be fractional, so we can't just truncate it\
    \ to an int\n        // without risking being off by a whole number.\n       \
    \ val fractionalPart = number % 1\n\n        // Convert the fractional part to\
    \ int\n        val intPart = math.floor(number - fractionalPart).toFloat\n\n \
    \       // If we've gone over 1.0 without rounding, we're done\n        if (intPart.toDouble\
    \ > 1.0) {\n            return number\n        } else {\n            // Otherwise\
    \ return the fractional part\n            return intPart + fractionalPart\n  \
    \      }", "        val fraction = number - Math.floor(number)\n        val whole\
    \ = number - Math.floor(number)\n        (fraction + whole) / Math.pow(10.0, fraction.signum).asInstanceOf[Float]",
  "        var iPart = number / 1\n        var fPart = number % 1\n        while (fPart\
    \ < 0.00000001) fPart *= 10\n        return (iPart + fPart).toFloat", "      \
    \  val fractionalPart = number % 1\n        val intPart = (number - fractionalPart).truncate()\n\
    \        fractionalPart * intPart", "        val fraction = number.toInt\n   \
    \     val decimal = number - fraction\n        fraction / 10f", "      def digits(f\
    \ : Float) : List[Float] = {\n        if (f<0) List(-1) :: digits((-f).abs) else\
    \ (f/f.abs).dropWhile(_>0)\n      }\n      val intPart = digits(number).filter(_<=1).last\n\
    \      val decimalPart = digits(number).filter(_>=1).last\n      intPart + decimalPart",
  "        val intPart = math.floor(number)\n        val decimalPart = number - intPart\n\
    \        decimalPart * 10", "      val decimal = number.toInt\n      (number -\
    \ decimal).toFloat", "        val intPart = (math.floor(number)).ceil.toFloat\n\
    \        val decimalPart = (number - intPart).toFloat\n        intPart + decimalPart",
  "        // First find out how much decimal is left\n        var decimalPart = math.modf(number)\n\
    \        // If it is 0, there is no decimal left\n        if(decimalPart._1 ==\
    \ 0) {\n            return 0f\n        }\n        // If it is not 0, the left\
    \ most digit is our answer\n        // To get the decimal part, we need to floor\
    \ our decimal part\n        var answer = math.floor(decimalPart._1)\n        //\
    \ If the answer is 0, there is nothing to truncate\n        if(answer == 0f) {\n\
    \            return 0f\n        }\n        // If it is 0, just return the answer\n\
    \        if(answer == 0f) {\n            return answer\n        }\n        //\
    \ Otherwise, return answer with the right most number of decimals\n        return\
    \ answer + decimalPart._1 * 10", "        val numStr = (number / 1).toString.toInt\n\
    \        val digits = math.pow(10, numStr.toInt)\n        val fracPart = number\
    \ - math.pow(10, numStr).toFloat\n        fracPart * digits", "        val intPart\
    \ = (number).toInt\n        val decimalPart = (number - intPart).toFloat\n   \
    \     decimalPart", "        var numberIntPart = number\n        var numberDecimalPart\
    \ = 0\n        if (numberIntPart < Integer.MIN_VALUE) {\n            numberIntPart\
    \ = Integer.MIN_VALUE\n        }\n        if (numberIntPart > Integer.MAX_VALUE)\
    \ {\n            numberIntPart = Integer.MAX_VALUE\n        }\n        val intPartLen\
    \ = numberIntPart.toInt\n        val decimalPartLen = numberIntPart - intPartLen\n\
    \        if (numberDecimalPart < decimalPartLen) {\n            numberDecimalPart\
    \ = decimalPartLen\n        }\n        return (number - numberIntPart).toFloat\
    \ / numberDecimalPart * BigDecimal(1.0F)", "        val negative = if (number\
    \ < 0) -1 else 0\n        val sign = if (number < 0) 1 else -1\n\n        val\
    \ integralPart = number.toInt\n        val decimalPart = (number - (integral Part))\
    \ / Math.pow(10, integralPart.toInt)\n\n        if (number < 1) 0\n        else\
    \ decimalPart * Math.pow(10, integralPart.toInt)", "        // Find out how many\
    \ integer parts there will be.\n        // Find out how many decimal parts there\
    \ will be.\n        // Decompose the number into integer and decimal parts.\n\
    \        // Round the decimal part up to the nearest whole number\n        //\
    \ Return the integer part and the decimal part as an int.\n        (number - Math.round(number)).intValue()",
  "        val integerPart = number.toInt\n        val decimalPart = number - integerPart\n\
    \        (decimalPart / 10f)", "        val remainder = math.fmod(number, 1.0)\n\
    \        val integerPart = math.ceil(remainder)\n        val decimalPart = math.floor(remainder)\n\
    \        decimalPart", "        val integerPart = number.toInt\n        val decimalPart\
    \ = number.toDouble\n        decimalPart", "        if (number < 0) {\n      \
    \      throw new IllegalArgumentException(s\"The given number ${number} is negative.\"\
    )\n        }\n        val integerPart = (number >>> 1).asInstanceOf[Float]\n \
    \       val decimalPart = number - integerPart\n        if (decimalPart > 0.5)\
    \ {\n            0.0f\n        } else {\n            1.0f\n        }", "     \
    \   def findDecimal(number : Float) : Float = {\n            val numDec = math.ceil(math.abs(number))\n\
    \            if(number < 1) numDec else numDec\n        }\n        val sign =\
    \ if (number < 0) 1 else -1\n        val newSign = if (number < 0) number / sign\
    \ else number * sign\n        val newNumber = sign * math.floor(newSign / findDecimal(number))\n\
    \        newNumber"]
stop_tokens:
- "\n    }\n"
